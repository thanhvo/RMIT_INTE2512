<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/ContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Direction;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.*;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
<A NAME="1"></A>import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#1',2,'match56-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.scene.control.*;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.stage.Window;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * This is a the SkinBase for ContextMenu based controls so that the CSS parts
 * work right, because otherwise we would have to copy the Keys from there to here.
 */
public class ContextMenuContent extends Region {

    private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;

    private ContextMenu contextMenu;

    /***************************************************************************
     * UI subcomponents
     **************************************************************************/

    private double maxGraphicWidth = 0; // we keep this margin to left for graphic
    private double maxRightWidth = 0;
    private double maxLabelWidth = 0;
    private double maxRowHeight = 0;
    private double maxLeftWidth = 0;
    private double oldWidth = 0;

    private Rectangle clipRect;
    MenuBox itemsContainer;
    private ArrowMenuItem upArrow;
    private ArrowMenuItem downArrow;

    /*
     * We maintain a current focused index which is used
     * in keyboard navigation of menu items.
     */
    private int currentFocusedIndex = -1;

    private boolean itemsDirty = true</B></FONT>;
    private InvalidationListener popupShowingListener = arg0 -&gt; {
        updateItems();
    };
    private WeakInvalidationListener weakPopupShowingListener =
            new WeakInvalidationListener(popupShowingListener);


    /***************************************************************************
     * Constructors
     **************************************************************************/
    public ContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        clipRect = new Rectangle();
         clipRect.setSmooth(false);
        itemsContainer = new MenuBox();
//        itemsContainer = new VBox();
        itemsContainer.setClip(clipRect);

        upArrow = new ArrowMenuItem(this);
        upArrow.setUp(true);
        upArrow.setFocusTraversable(false);

        downArrow = new ArrowMenuItem(this);
        downArrow.setUp(false);
        downArrow.setFocusTraversable(false);
        getChildren().add(itemsContainer);
        getChildren().add(upArrow);
        getChildren().add(downArrow);
        initialize();
        setUpBinds();
        updateItems();
        // RT-20197 add menuitems only on first show.
        popupMenu.showingProperty().addListener(weakPopupShowingListener);

        /*
        ** only add this if we're on an embedded
        ** platform that supports 5-button navigation
        */
        if (Utils.isTwoLevelFocus()) {
            new TwoLevelFocusPopupBehavior(this);
        }
    }

    //For access from controls
    public VBox getItemsContainer() {
        return itemsContainer;
    }
    //For testing purpose only
    int getCurrentFocusIndex() {
        return currentFocusedIndex;
    }
    //For testing purpose only
    void setCurrentFocusedIndex(int index) {
        if (index &lt; itemsContainer.getChildren().size()) {
            currentFocusedIndex = index;
        }
    }

    private void updateItems() {
        if (itemsDirty) {
            updateVisualItems();
            itemsDirty = false;
        }
    }

    private void computeVisualMetrics() {
        maxRightWidth = 0;
        maxLabelWidth = 0;
        maxRowHeight = 0;
        maxGraphicWidth = 0;
        maxLeftWidth = 0;

        for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node child = itemsContainer.getChildren().get(i);
            if (child instanceof MenuItemContainer) {
                final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);

                if (! menuItemContainer.isVisible()) continue;

                double alt = -1;
                Node n = menuItemContainer.left;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.graphic;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.label;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) {
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.right;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }
            }
        }

        // Fix for RT-38838.
        // This fixes the issue where CSS is applied to a menu after it has been
        // showing, resulting in its bounds changing. In this case, we need to
        // shift the submenu such that it is properly aligned with its parent menu.
        //
        // To do this, we must firstly determine if the open submenu is shifted
        // horizontally to appear on the other side of this menu, as this is the
        // only situation where shifting has to happen. If so, we need to check
        // if we should shift the submenu due to changes in width.
        //
        // We need to get the parent menu of this contextMenu, so that we only
        // modify the X value in the following conditions:
        // 1) There exists a parent menu
        // 2) The parent menu is in the correct position (i.e. to the left of this
        //    menu in normal LTR systems).
        final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
        Window ownerWindow = contextMenu.getOwnerWindow();
        if (ownerWindow instanceof ContextMenu) {
            if (contextMenu.getX() &lt; ownerWindow.getX()) {
                if (oldWidth != newWidth) {
                    contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
                }
            }
        }

        oldWidth = newWidth;
    }

    private void updateVisualItems() {
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();

        disposeVisualItems();

        for (int row = 0; row &lt; getItems().size(); row++) {
            final MenuItem item = getItems().get(row);
            if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
                continue;
            }

            if (item instanceof SeparatorMenuItem) {
                // we don't want the hover highlight for separators, so for
                // now this is the simplest approach - just remove the
                // background entirely. This may cause issues if people
                // intend to style the background differently.
                Node node = ((CustomMenuItem) item).getContent();
                node.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(node);
                // Add the (separator) menu item to properties map of this node.
                // Special casing this for separator :
                // This allows associating this container with SeparatorMenuItem.
                node.getProperties().put(MenuItem.class, item);
            } else {
                MenuItemContainer menuItemContainer = new MenuItemContainer(item);
                menuItemContainer.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(menuItemContainer);
            }
        }

        // Add the Menu to properties map of this skin. Used by QA for testing
        // This enables associating a parent menu for this skin showing menu items.
        if (getItems().size() &gt; 0) {
            final MenuItem item = getItems().get(0);
            getProperties().put(Menu.class, item.getParentMenu());
        }

        // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
        NodeHelper.reapplyCSS(this);
    }

    private void disposeVisualItems() {
        // clean up itemsContainer
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
        for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
            Node n = itemsContainerChilder.get(i);

            if (n instanceof MenuItemContainer) {
                MenuItemContainer container = (MenuItemContainer) n;
                container.visibleProperty().unbind();
                container.dispose();
            }
        }
        itemsContainerChilder.clear();
    }

    /**
     * Can be called by Skins when they need to clean up the content of any
     * ContextMenu instances they might have created. This ensures that contents
     * of submenus if any, also get cleaned up.
     */
    public void dispose() {
        disposeBinds();
        disposeVisualItems();

        disposeContextMenu(submenu);
        submenu = null;
        openSubmenu = null;
        selectedBackground = null;
        if (contextMenu != null) {
            contextMenu.getItems().clear();
            contextMenu = null;
        }
    }

    public void disposeContextMenu(ContextMenu menu) {
        if (menu == null) return;

        Skin&lt;?&gt; skin = menu.getSkin();
        if (skin == null) return;

        ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
        if (cmContent == null) return;

        cmContent.dispose(); // recursive call to dispose submenus.
    }

    @Override protected void layoutChildren() {
        if (itemsContainer.getChildren().size() == 0) return;
        final double x = snappedLeftInset();
        final double y = snappedTopInset();
        final double w = getWidth() - x - snappedRightInset();
        final double h = getHeight() - y - snappedBottomInset();
        final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);

        itemsContainer.resize(w,contentHeight);
        itemsContainer.relocate(x, y);

        if (isFirstShow &amp;&amp; ty == 0) {
            upArrow.setVisible(false);
            isFirstShow = false;
        } else {
            upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
        }
        downArrow.setVisible(ty + contentHeight &gt; (y + h));

        clipRect.setX(0);
        clipRect.setY(0);
        clipRect.setWidth(w);
        clipRect.setHeight(h);

        if (upArrow.isVisible()) {
            final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
            clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
            upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
            positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }

        if (downArrow.isVisible()) {
            final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
            downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
            positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }
    }

     @Override protected double computePrefWidth(double height) {
         computeVisualMetrics();
         double prefWidth = 0;
         if (itemsContainer.getChildren().size() == 0) return 0;
         for (Node n : itemsContainer.getChildren()) {
             if (! n.isVisible()) continue;
             prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
         }
         return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
    }

    @Override protected double computePrefHeight(double width) {
        if (itemsContainer.getChildren().size() == 0) return 0;
        final double screenHeight = getScreenHeight();
        final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
        double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
        // the pref height of this menu is the smaller value of the
        // actual pref height and the height of the screens _visual_ bounds.
        double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
        return prefHeight;
    }

    @Override protected double computeMinHeight(double width) {
        return 0.0;
    }

    @Override protected double computeMaxHeight(double height) {
        return getScreenHeight();
    }

    private double getScreenHeight() {
        if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
                contextMenu.getOwnerWindow().getScene() == null) {
            return -1;
        }
        return snapSizeY(com.sun.javafx.util.Utils.getScreen(
            contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());

    }

    private double getContentHeight() {
        double h = 0.0d;
        for (Node i : itemsContainer.getChildren()) {
            if (i.isVisible()) {
               h += snapSizeY(i.prefHeight(-1));
            }
        }
        return h;
    }

    // This handles shifting ty when doing keyboard navigation.
    private void ensureFocusedMenuItemIsVisible(Node node) {
        if (node == null) return;

        final Bounds nodeBounds = node.getBoundsInParent();
        final Bounds clipBounds = clipRect.getBoundsInParent();

        if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
            // this is for moving down the menu
            scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
        } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
            // this is for moving up the menu
            scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
        }
    }

    protected ObservableList&lt;MenuItem&gt; getItems() {
        return contextMenu.getItems();
    }

    /**
     * Finds the index of currently focused item.
     */
    private int findFocusedIndex() {
         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node n = itemsContainer.getChildren().get(i);
            if (n.isFocused()) {
                return i;
            }
        }
        return -1;
    }

    private boolean isFirstShow = true;
    private double ty;

    private void initialize() {
        // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
        contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
            currentFocusedIndex = -1;
            for (Node child : itemsContainer.getChildren()) {
                if (child instanceof MenuItemContainer) {
                    final MenuItem item = ((MenuItemContainer)child).item;
                    // When the choiceBox popup is shown, if this menu item is selected
                    // do a requestFocus so CSS kicks in and the item is highlighted.
                    if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
                        if (((RadioMenuItem)item).isSelected()) {
                            child.requestFocus();
                            break;
                        }
                    }
                }

            }
        });

//        // FIXME For some reason getSkinnable()Behavior traversal functions don't
//        // get called as expected, so I've just put the important code below.
        // We use setOnKeyPressed here as we are not adding a listener to a public
        // event type (ContextMenuContent is not public API), and without this
        // we get the issue shown in RT-34429
        setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent ke) {
                switch (ke.getCode()) {
                    case LEFT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processRightKey(ke);
                        } else {
                            processLeftKey(ke);
                        }
                        break;
                    case RIGHT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processLeftKey(ke);
                        } else {
                            processRightKey(ke);
                        }
                        break;
                    case CANCEL:
                        ke.consume();
                        break;
                    case ESCAPE:
                        // if the owner is not a menubar button, just close the
                        // menu - this will move focus up to the parent menu
                        // as required. In the case of the parent being a
                        // menubar button we special case in the conditional code
                        // beneath this switch statement. See RT-34429 for more context.
                        final Node ownerNode = contextMenu.getOwnerNode();
                        if (! (ownerNode instanceof MenuBarButton)) {
                            contextMenu.hide();
                            ke.consume();
                        }
                        break;
                    case DOWN:
                        // move to the next sibling
                        move(Direction.NEXT);
                        ke.consume();
                        break;
                    case UP:
                        // move to previous sibling
                        move(Direction.PREVIOUS);
                        ke.consume();
                        break;
                    case SPACE:
                    case ENTER:
                        // select the menuitem
                        selectMenuItem();
                        ke.consume();
                        break;
                    default:
                        break;
                }

                if (!ke.isConsumed()) {
                    final Node ownerNode = contextMenu.getOwnerNode();
                    if (ownerNode instanceof MenuItemContainer) {
                        // Forward to parent menu
                        Parent parent = ownerNode.getParent();
                        while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
                            parent = parent.getParent();
                        }
                        if (parent instanceof ContextMenuContent) {
                            parent.getOnKeyPressed().handle(ke);
                        }
                    } else if (ownerNode instanceof MenuBarButton) {
                        // the following code no longer appears necessary, but
                        // leaving in intact for now...
//                        // This is a top-level MenuBar Menu, so forward event to MenuBar
//                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
//                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
//                            mbs.getKeyEventHandler().handle(ke);
//                        }
                    }
                }
            }
        });

        addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            /*
             * we'll only scroll if the arrows are visible in the direction
             * that we're going, otherwise we go into empty space.
             */
            final double textDeltaY = event.getTextDeltaY();
            final double deltaY = event.getDeltaY();
            if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
                (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {

                switch(event.getTextDeltaYUnits()) {
                  case LINES:
                      /*
                      ** scroll lines, use the row height of selected row,
                      ** or row 0 if none selected
                      */
                      int focusedIndex = findFocusedIndex();
                      if (focusedIndex == -1) {
                          focusedIndex = 0;
                      }
                      double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
                      scroll(textDeltaY * rowHeight);
                      break;
                  case PAGES:
                      /*
                      ** page scroll, scroll the menu height
                      */
                      scroll(textDeltaY * itemsContainer.getHeight());
                      break;
                  case NONE:
                      /*
                      ** pixel scroll
                      */
                      scroll(deltaY);
                      break;
                }
                event.consume();
            }
        });
    }

    private Optional&lt;Node&gt; getFocusedNode() {
        final List&lt;Node&gt; children = itemsContainer.getChildren();
        final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
        return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
    }

    private void processLeftKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;

                    // if the submenu for this menu is showing, hide it
                    if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        hideSubmenu();
                        ke.consume();
                    }
                }
            }
        });
    }

    private void processRightKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);

                    // RT-15103
                    // if submenu for this menu is already showing then do nothing
                    // Menubar will process the right key and move to the next menu
                    if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        return;
                    }

                    showMenu(menu);
                    ke.consume();
                }
            }
        });
    }

    private void showMenu(Menu menu) {
        menu.show();
        // request focus on the first item of the submenu after it is shown
        ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
        if (cmContent != null) {
           if (cmContent.itemsContainer.getChildren().size() &gt; 0) {
               cmContent.itemsContainer.getChildren().get(0).requestFocus();
               cmContent.currentFocusedIndex = 0;
           } else {
               cmContent.requestFocus();
           }
        }
    }

    private void selectMenuItem() {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);
                    menu.show();
                } else {
                    ((MenuItemContainer)n).doSelect();
                }
            }
        });
    }

    private void move(Direction dir) {
        int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
        requestFocusOnIndex(findSibling(dir, startIndex));
    }

    private int findSibling(final Direction dir, final int startIndex) {
        final int childCount = itemsContainer.getChildren().size();
        int i = startIndex;
        do {
            if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
                // loop to zero
                i = 0;
            } else if (!dir.isForward() &amp;&amp; i == 0) {
                // loop to end
                i = childCount - 1;
            } else {
                i += (dir.isForward() ? 1 : -1);
            }

            Node n = itemsContainer.getChildren().get(i);
            if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
                return i;
            }
        } while (i != startIndex);
        return -1;
    }

    public void requestFocusOnIndex(int index) {
        currentFocusedIndex = index;
        Node n = itemsContainer.getChildren().get(index);
        selectedBackground = ((MenuItemContainer)n);
        n.requestFocus();
        ensureFocusedMenuItemIsVisible(n);
    }

    /*
     * Get the Y offset from the top of the popup to the menu item whose index
     * is given.
     */
    public double getMenuYOffset(int menuIndex) {
        double offset = 0;
        if (itemsContainer.getChildren().size() &gt; menuIndex) {
            offset = snappedTopInset();
            Node menuitem = itemsContainer.getChildren().get(menuIndex);
            offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
        }
        return offset;
    }

    private void setUpBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), true);
        contextMenu.getItems().addListener(contextMenuItemsListener);
    }

    private void disposeBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), false);
        contextMenu.getItems().removeListener(contextMenuItemsListener);
    }

    private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
        ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
        Menu menu = (Menu) isShowingProperty.getBean();

        if (wasShowing &amp;&amp; ! isShowing) {
            // hide the submenu popup
            hideSubmenu();
        } else if (! wasShowing &amp;&amp; isShowing) {
            // show the submenu popup
            showSubmenu(menu);
        }
    };

    private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
        // Add listeners to the showing property of all menus that have
        // been added, and remove listeners from menus that have been removed
        // FIXME this is temporary - we should be adding and removing
        // listeners such that they use the one listener defined above
        // - but that can't be done until we have the bean in the
        // ObservableValue
        while (c.next()) {
            updateMenuShowingListeners(c.getRemoved(), false);
            updateMenuShowingListeners(c.getAddedSubList(), true);
        }

        // Listener to items in PopupMenu to update items in PopupMenuContent
        itemsDirty = true;
        updateItems(); // RT-29761
    };

    private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
        // re layout as item's visibility changed
        requestLayout();
    };

    private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
        for (MenuItem item : items) {
            if (item instanceof Menu) {
                final Menu menu = (Menu) item;

                if (addListeners) {
                    menu.showingProperty().addListener(menuShowingListener);
                } else {
                    menu.showingProperty().removeListener(menuShowingListener);
                }
            }

             // listen to menu items's visible property.
            if (addListeners) {
                item.visibleProperty().addListener(menuItemVisibleListener);
            } else {
                item.visibleProperty().removeListener(menuItemVisibleListener);
            }
        }
    }

    // For test purpose only
    ContextMenu getSubMenu() {
        return submenu;
    }

    Menu getOpenSubMenu() {
        return openSubmenu;
    }

    private void createSubmenu() {
        if (submenu == null) {
            submenu = new ContextMenu();
            submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
                @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
                                              Boolean oldValue, Boolean newValue) {
                    if (!submenu.isShowing()) {
                        // Maybe user clicked outside or typed ESCAPE.
                        // Make sure menus are in sync.
                        for (Node node : itemsContainer.getChildren()) {
                            if (node instanceof MenuItemContainer
                                  &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
                                Menu menu = (Menu)((MenuItemContainer)node).item;
                                if (menu.isShowing()) {
                                    menu.hide();
                                }
                            }
                        }
                    }
                }
            });
        }
    }

    private void showSubmenu(Menu menu) {
        openSubmenu = menu;
        createSubmenu();
        submenu.getItems().setAll(menu.getItems());
        submenu.show(selectedBackground, Side.RIGHT, 0, 0);
    }

    private void hideSubmenu() {
        if (submenu == null) return;

        submenu.hide();
        openSubmenu = null;

        // Fix for RT-37022 - we dispose content so that we do not process CSS
        // on hidden submenus
        disposeContextMenu(submenu);
        submenu = null;

        // Fix for JDK-8158679 - we put the focus on the menu, and then back
        // on the menu item, so that screen readers can properly speak out
        // the menu item.
        getFocusedNode().ifPresent(n -&gt; {
            requestFocus();
            n.requestFocus();
        });
    }

    private void hideAllMenus(MenuItem item) {
        if (contextMenu != null) contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    private Menu openSubmenu;
    private ContextMenu submenu;

    // FIXME: HACKY. We use this so that a submenu knows where to open from
    // but this will only work for mouse hovers currently - and won't work
    // programmatically.
    // package protected for testing only!
    Region selectedBackground;

    void scroll(double delta) {
        double newTy = ty + delta;
        if (ty == newTy) return;

        // translation should never be positive (this would mean the top of the
        // menu content is detaching from the top of the menu!)
        if (newTy &gt; 0.0) {
            newTy = 0.0;
        }

        // translation should never be greater than the preferred height of the
        // menu content (otherwise the menu content will be detaching from the
        // bottom of the menu).
        // RT-37185: We check the direction of the scroll, to prevent it locking
        // up when scrolling upwards from the very bottom (using the on-screen
        // up arrow).
        if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
            newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
        }

        ty = newTy;
        itemsContainer.requestLayout();
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/
    @Override public Styleable getStyleableParent() {
        return contextMenu;
    }

    private static class StyleableProperties {

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());

            //
            // SkinBase only has Region's unique StlyleableProperty's, none of Nodes
            // So, we need to add effect back in. The effect property is in a
            // private inner class, so get the property from Node the hard way.
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
            for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
                CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
                if (&quot;effect&quot;.equals(styleable.getProperty())) {
                    styleables.add(styleable);
                    break;
                }
            }
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    public Label getLabelAt(int index) {
        return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
    }

    /**
     * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
     * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
     * timeline when mouse is over up/down arrow.
     */
    class MenuBox extends VBox {
        MenuBox() {
            setAccessibleRole(AccessibleRole.CONTEXT_MENU);
        }

        @Override protected void layoutChildren() {
            double yOffset = ty;
            for (Node n : getChildren()) {
                if (n.isVisible()) {
                    final double prefHeight = snapSizeY(n.prefHeight(-1));
                    n.resize(snapSizeX(getWidth()), prefHeight);
                    n.relocate(snappedLeftInset(), yOffset);
                    yOffset += prefHeight;
                }
            }
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case VISIBLE: return contextMenu.isShowing();
                case PARENT_MENU: return contextMenu.getOwnerNode();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }
    }

    class ArrowMenuItem extends StackPane {
         private StackPane upDownArrow;
         private ContextMenuContent popupMenuContent;
         private boolean up = false;
         public final boolean isUp() { return up; }
         public void setUp(boolean value) {
            up = value;
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
        }

        // used to automatically scroll through menu items when the user performs
        // certain interactions, e.g. pressing and holding the arrow buttons
        private Timeline scrollTimeline;

        public ArrowMenuItem(ContextMenuContent pmc) {
            getStyleClass().setAll(&quot;scroll-arrow&quot;);
            upDownArrow = new StackPane();
            this.popupMenuContent = pmc;
            upDownArrow.setMouseTransparent(true);
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
    //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
            addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
                if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
                    return;
                }
                startTimeline();
            });
            addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
                stopTimeline();
            });
            setVisible(false);
            setManaged(false);
            getChildren().add(upDownArrow);
        }

        @Override protected double computePrefWidth(double height) {
//            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
            return itemsContainer.getWidth();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double w = snapSizeX(upDownArrow.prefWidth(-1));
            double h = snapSizeY(upDownArrow.prefHeight(-1));

            upDownArrow.resize(w, h);
            positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }

        private void adjust() {
            if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
        }

        private void startTimeline() {
            scrollTimeline = new Timeline();
            scrollTimeline.setCycleCount(Timeline.INDEFINITE);
            KeyFrame kf = new KeyFrame(
                Duration.millis(60),
                    event -&gt; {
                        adjust();
                    }
            );
            scrollTimeline.getKeyFrames().clear();
            scrollTimeline.getKeyFrames().add(kf);
            scrollTimeline.play();
        }

        private void stopTimeline() {
            scrollTimeline.stop();
            scrollTimeline = null;
        }
    }

    /*
     * Container responsible for laying out a single row in the menu - in other
     * words, this contains and lays out a single MenuItem, regardless of it's
     * specific subtype.
     */
    public class MenuItemContainer extends Region {

        private final MenuItem item;

        private Node left;
        private Node graphic;
        private Node label;
        private Node right;

        private final LambdaMultiplePropertyChangeListenerHandler listener =
            new LambdaMultiplePropertyChangeListenerHandler();

        private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
        private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;

        private EventHandler&lt;ActionEvent&gt; actionEventHandler;

        protected Label getLabel(){
            return (Label) label;
        }

        public MenuItem getItem() {
            return item;
        }

        public MenuItemContainer(MenuItem item){
            if (item == null) {
                throw new NullPointerException(&quot;MenuItem can not be null&quot;);
            }

            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            setFocusTraversable(!(item instanceof CustomMenuItem));
            this.item = item;

            createChildren();

            // listen to changes in the state of certain MenuItem types
            ReadOnlyBooleanProperty pseudoProperty;
            if (item instanceof Menu) {
                pseudoProperty = ((Menu)item).showingProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.MENU);
            } else if (item instanceof RadioMenuItem) {
                pseudoProperty = ((RadioMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
            } else if (item instanceof CheckMenuItem) {
                pseudoProperty = ((CheckMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
            } else {
                setAccessibleRole(AccessibleRole.MENU_ITEM);
            }

            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
            listener.registerChangeListener(item.disableProperty(),
                    e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));

            // Add the menu item to properties map of this node. Used by QA for testing
            // This allows associating this container with corresponding MenuItem.
            getProperties().put(MenuItem.class, item);

            listener.registerChangeListener(item.graphicProperty(), e -&gt; {
                createChildren();
                computeVisualMetrics();
            });

            actionEventHandler = e -&gt; {
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }

                    selectedBackground = MenuItemContainer.this;
                    showMenu(menu);
                } else {
                    doSelect();
                }
            };
            addEventHandler(ActionEvent.ACTION, actionEventHandler);
        }

        public void dispose() {
            if (item instanceof CustomMenuItem) {
                Node node = ((CustomMenuItem)item).getContent();
                if (node != null) {
                    node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
                }
            }

            listener.dispose();
            removeEventHandler(ActionEvent.ACTION, actionEventHandler);

            if (label != null) {
                ((Label)label).textProperty().unbind();
                label.styleProperty().unbind();
                label.idProperty().unbind();

                ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
                if (itemStyleClassListener != null) {
                    item.getStyleClass().removeListener(itemStyleClassListener);
                }
            }

            left = null;
            graphic = null;
            label = null;
            right = null;
        }

        private void createChildren() {
            getChildren().clear();

            // draw background region for hover effects. All content (other
            // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
            // this background also acts as the receiver of user input
            if (item instanceof CustomMenuItem) {
                createNodeMenuItemChildren((CustomMenuItem)item);

                if (mouseEnteredEventHandler == null) {
                    mouseEnteredEventHandler = event -&gt; {
                        requestFocus(); // request Focus on hover
                    };
                } else {
                    removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                }
                addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
            } else {
                // --- add check / radio to left column
                Node leftNode = getLeftGraphic(item);
                if (leftNode != null) {
                    StackPane leftPane = new StackPane();
                    leftPane.getStyleClass().add(&quot;left-container&quot;);
                    leftPane.getChildren().add(leftNode);
                    left = leftPane;
                    getChildren().add(left);
                    left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
                }
                // -- add graphic to graphic pane
                if (item.getGraphic() != null) {
                    Node graphicNode = item.getGraphic();
                    StackPane graphicPane = new StackPane();
                    graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
                    graphicPane.getChildren().add(graphicNode);
                    graphic = graphicPane;
                    getChildren().add(graphic);
                }

                // --- add text to center column
                label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()

                // set up bindings from the MenuItem into the Label
                ((Label)label).textProperty().bind(item.textProperty());
                label.styleProperty().bind(item.styleProperty());
                label.idProperty().bind(item.styleProperty());

                // we want to ensure that any styleclasses set on the menuitem are applied to the
                // label (so we can style appropriately), but we can't just do a binding such as this:
                // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
                // Because that means we overwrite the 'label' style class on the Label.
                // What we really want is to ensure all style classes in the MenuItem are _copied_
                // into the label, which is what we do below
                ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
                    while (c.next()) {
                        label.getStyleClass().removeAll(c.getRemoved());
                        label.getStyleClass().addAll(c.getAddedSubList());
                    }
                };
                item.getStyleClass().addListener(itemStyleClassListener);
                item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);


                label.setMouseTransparent(true);
                getChildren().add(label);

                listener.unregisterChangeListeners(focusedProperty());
                // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
                // e.g this happens when you press the Right key to open a submenu; the first
                // menuitem is focused.
                listener.registerChangeListener(focusedProperty(), e -&gt; {
                    if (isFocused()) {
                        currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
                    }
                });

                // --- draw in right column - this depends on whether we are
                // a Menu or not. A Menu gets an arrow, whereas other MenuItems
                // get the ability to draw an accelerator
                if (item instanceof Menu) {
                    // --- add arrow / accelerator / mnemonic to right column
                    Region rightNode = new Region();
                    rightNode.setMouseTransparent(true);
                    rightNode.getStyleClass().add(&quot;arrow&quot;);

                    StackPane rightPane = new StackPane();
                    rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
                    rightPane.setMouseTransparent(true);
                    rightPane.getStyleClass().add(&quot;right-container&quot;);
                    rightPane.getChildren().add(rightNode);
                    right = rightPane;
                    getChildren().add(rightPane);

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null &amp;&amp; item != openSubmenu) {
                                // if a submenu of a different menu is already
                                // open then close it (RT-15049)
                                hideSubmenu();
                            }

                            selectedBackground = MenuItemContainer.this;
                            requestFocus();  // request Focus on hover
                            final Menu menu = (Menu) item;
                            if (menu.isDisable()) return;
                            menu.show();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            item.fire();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    // show submenu when the menu is hovered over
                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                } else { // normal MenuItem
                    // remove old listeners
                    listener.unregisterChangeListeners(item.acceleratorProperty());

                    // accelerator support
                    updateAccelerator();

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null) {
                                openSubmenu.hide();
                            }
                            requestFocus();  // request Focus on hover
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            doSelect();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);

                    listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
                }
            }
        }

        private void updateAccelerator() {
            if (item.getAccelerator() != null) {
                if (right != null) {
                    getChildren().remove(right);
                }

                String text = item.getAccelerator().getDisplayText();
                right = new Label(text);
                right.setStyle(item.getStyle());
                right.getStyleClass().add(&quot;accelerator-text&quot;);
                getChildren().add(right);
            } else {
                getChildren().remove(right);
            }
        }

        void doSelect() {
            // don't do anything on disabled menu items
            if (item.isDisable()) return;
            // toggle state of check or radio items
            if (item instanceof CheckMenuItem) {
                CheckMenuItem checkItem = (CheckMenuItem)item;
                checkItem.setSelected(!checkItem.isSelected());
            } else if (item instanceof RadioMenuItem) {
                // this is a radio button. If there is a toggleGroup specified, we
                // simply set selected to true. If no toggleGroup is specified, we
                // toggle the selected state, as there is no assumption of mutual
                // exclusivity when no toggleGroup is set.
                final RadioMenuItem radioItem = (RadioMenuItem) item;
                radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
            }

            // fire the action before hiding the menu
            item.fire();

            if (item instanceof CustomMenuItem) {
                CustomMenuItem customMenuItem = (CustomMenuItem) item;
                if (customMenuItem.isHideOnClick()) {
                    hideAllMenus(item);
                }
            } else {
                hideAllMenus(item);
            }
        }

        private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;

        private void createNodeMenuItemChildren(final CustomMenuItem item) {
            Node node = item.getContent();
            getChildren().add(node);

            // handle hideOnClick
            customMenuItemMouseClickedHandler = event -&gt; {
                if (item == null || item.isDisable()) return;

                item.fire();
                if (item.isHideOnClick()) {
                    hideAllMenus(item);
                }
            };
            node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
        }

        @Override protected void layoutChildren() {
            double xOffset;

            final double prefHeight = prefHeight(-1);
            if (left != null) {
                xOffset = snappedLeftInset();
                left.resize(left.prefWidth(-1), left.prefHeight(-1));
                positionInArea(left, xOffset, 0,
                        maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }
            if (graphic != null) {
                xOffset = snappedLeftInset() + maxLeftWidth;
                graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
                positionInArea(graphic, xOffset, 0,
                        maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (label != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
                label.resize(label.prefWidth(-1), label.prefHeight(-1));
                positionInArea(label, xOffset, 0,
                        maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (right != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
                right.resize(right.prefWidth(-1), right.prefHeight(-1));
                positionInArea(right, xOffset, 0,
                    maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
            }

            if ( item instanceof CustomMenuItem) {
                Node n = ((CustomMenuItem) item).getContent();
                if (item instanceof SeparatorMenuItem) {
                    double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
                    n.resize(width, n.prefHeight(-1));
                    positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                } else {
                    n.resize(n.prefWidth(-1), n.prefHeight(-1));
                    //the node should be left aligned
                    positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                }
            }
        }

        @Override protected double computePrefHeight(double width) {
            double prefHeight = 0;
            if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
                prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
            } else {
                prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
            }
             return snappedTopInset() + prefHeight + snappedBottomInset();
        }

        @Override protected double computePrefWidth(double height) {
            double nodeMenuItemWidth = 0;
            if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
                nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
                        snappedRightInset();
            }
            return Math.max(nodeMenuItemWidth,
                    snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
                    maxLabelWidth + maxRightWidth + snappedRightInset());
        }

        // Responsible for returning a graphic (if necessary) to position in the
        // left column of the menu. This may be a Node from the MenuItem.graphic
        // property, or it may be a check/radio item if necessary.
        private Node getLeftGraphic(MenuItem item) {
            if (item instanceof RadioMenuItem) {
                 final Region _graphic = new Region();
                _graphic.getStyleClass().add(&quot;radio&quot;);
                return _graphic;
            } else if (item instanceof CheckMenuItem) {
                final StackPane _graphic = new StackPane();
                _graphic.getStyleClass().add(&quot;check&quot;);
                return _graphic;
            }

            return null;
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case SELECTED:
                    if (item instanceof CheckMenuItem) {
                        return ((CheckMenuItem)item).isSelected();
                    }
                    if (item instanceof RadioMenuItem) {
                        return ((RadioMenuItem) item).isSelected();
                    }
                    return false;
                case ACCELERATOR: return item.getAccelerator();
                case TEXT: {
                    String title = &quot;&quot;;
                    if (graphic != null) {
                        String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    final Label label = getLabel();
                    if (label != null) {
                        String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    if (item instanceof CustomMenuItem) {
                        Node content = ((CustomMenuItem) item).getContent();
                        if (content != null) {
                            String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                            if (t != null) title += t;
                        }
                    }
                    return title;
                }
                case MNEMONIC: {
                    final Label label = getLabel();
                    if (label != null) {
                        String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
                        if (mnemonic != null) return mnemonic;
                    }
                    return null;
                }
                case DISABLED: return item.isDisable();
                case SUBMENU:
                    createSubmenu();
                    // Accessibility might need to see the menu node before the window
                    // is visible (i.e. before the skin is applied).
                    if (submenu.getSkin() == null) {
                        submenu.getStyleableNode().applyCss();
                    }
                    ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
                    return cmContent.itemsContainer;
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case SHOW_MENU:{
                    if (item instanceof Menu) {
                        final Menu menuItem = (Menu) item;
                        if (menuItem.isShowing()) {
                            menuItem.hide();
                        } else {
                            menuItem.show();
                        }
                    }
                    break;
                }
                case FIRE:
                    doSelect();
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }


    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;checked&quot;);

    private class MenuLabel extends Label {

        public MenuLabel(MenuItem item, MenuItemContainer mic) {
            super(item.getText());
            setMnemonicParsing(item.isMnemonicParsing());
            setLabelFor(mic);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerHijrahContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.LocalDate;
import java.time.DateTimeException;
import java.time.YearMonth;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.HijrahChronology;
import java.time.chrono.HijrahDate;
import java.time.chrono.IsoChronology;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;

import javafx.geometry.Pos;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.scene.text.Text;

/**
 * Extends DatePickerContent to add a secondary calendar, allowing the
 * ISO and Islamic calendars to be displayed simultaneously.  The
 * secondary month, day, and year values are displayed as a colored
 * overlay, offset from the primary values.
 *
 * If the current DatePicker Chronology is HijrahChronology, then sets
 * the content's primary Chronology to be IsoChronology, and sets
 * HijrahChronology as the secondary.
 */
public class DatePickerHijrahContent extends DatePickerContent {
    private Label hijrahMonthYearLabel;

    public DatePickerHijrahContent(final DatePicker datePicker) {
        super(datePicker);
    }

    /**
     * The primary chronology for display. This is overridden because
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    @Override protected Chronology getPrimaryChronology() {
        return IsoChronology.INSTANCE;
    }

    @Override protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = super.createMonthYearPane();

        hijrahMonthYearLabel = new Label();
        hijrahMonthYearLabel.getStyleClass().add(&quot;secondary-label&quot;);
        monthYearPane.setBottom(hijrahMonthYearLabel);
        BorderPane.setAlignment(hijrahMonthYearLabel, Pos.CENTER);

        return monthYearPane;
    }


    @Override protected void updateMonthYearPane() {
        super.updateMonthYearPane();

        Locale locale = getLocale();
        HijrahChronology chrono = HijrahChronology.INSTANCE;
        long firstMonth = -1;
        long firstYear = -1;
        String firstMonthStr = null;
        String firstYearStr = null;
        String hijrahStr = null;
        YearMonth displayedYearMonth = displayedYearMonthProperty().get();

        for (DateCell dayCell : dayCells) {
            LocalDate date = dayCellDate(dayCell);

            // Display Hijra month names only for current ISO month.
            if (!displayedYearMonth.equals(YearMonth.from(date))) {
                continue;
            }

            try {
                HijrahDate cDate = chrono.date(date);
                long month = cDate.getLong(MONTH_OF_YEAR);
<A NAME="7"></A>                long year = cDate.getLong(YEAR);

                if (hijrahStr == null || month != firstMonth) {
                    String monthStr = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#7',2,'match56-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>monthFormatter.withLocale(locale)
                                                    .withChronology(chrono)
                                                    .withDecimalStyle(DecimalStyle.of(locale))
                                                    .format(cDate);
                    String yearStr = yearFormatter.withLocale(locale)
                                                    .withChronology(chrono)
                                                    .withDecimalStyle(DecimalStyle.of(locale))
                                                    .format(cDate);
                    if (hijrahStr == null) {
                        firstMonth = month;
                        firstYear = year;
                        firstMonthStr = monthStr;
                        f</B></FONT>irstYearStr = yearStr;
                        hijrahStr = firstMonthStr + &quot; &quot; + firstYearStr;
                    } else {
                        if (year &gt; firstYear) {
                            hijrahStr = firstMonthStr + &quot; &quot; + firstYearStr + &quot; - &quot; + monthStr + &quot; &quot; + yearStr;
                        } else {
                            hijrahStr = firstMonthStr + &quot; - &quot; + monthStr + &quot; &quot; + firstYearStr;
                        }
                        break;
                    }
                }
            } catch (DateTimeException ex) {
                // Date is out of range, ignore.

                //System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
            }
        }

        hijrahMonthYearLabel.setText(hijrahStr);
    }

    @Override protected void createDayCells() {
        super.createDayCells();

        for (DateCell dayCell : dayCells) {
            Text secondaryText = new Text();
            dayCell.getProperties().put(&quot;DateCell.secondaryText&quot;, secondaryText);
        }
    }

    @Override public void updateDayCells() {
        super.updateDayCells();

        Locale locale = getLocale();
        HijrahChronology chrono = HijrahChronology.INSTANCE;

        int majorityMonth = -1;
        int visibleDaysInMajorityMonth = -1;
        int curMonth = -1;
        int visibleDaysInCurMonth = 0;

        for (DateCell dayCell : dayCells) {
            Text secondaryText = (Text)dayCell.getProperties().get(&quot;DateCell.secondaryText&quot;);
            dayCell.getStyleClass().add(&quot;hijrah-day-cell&quot;);
            secondaryText.getStyleClass().setAll(&quot;text&quot;, &quot;secondary-text&quot;);

            try {
                HijrahDate cDate = chrono.date(dayCellDate(dayCell));
//             long month = cDate.getLong(MONTH_OF_YEAR);

                String hijrahStr =
                    dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);

                secondaryText.setText(hijrahStr);
                dayCell.requestLayout();
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                secondaryText.setText(&quot; &quot;);
                dayCell.setDisable(true);
            }

//             if (month == curMonth) {
//                 visibleDaysInCurMonth++;
//             } else {
//                 curMonth = month;
//                 visibleDaysInCurMonth = 1;
//             }
//             if (visibleDaysInCurMonth &gt; visibleDaysInMajorityMonth) {
//                 majorityMonth = month;
//                 visibleDaysInMajorityMonth = visibleDaysInCurMonth;
//             }
        }

//         boolean seenMajorityMonth = false;
//         for (DateCell dayCell : dayCells) {
//             HijrahDate cDate = chrono.date(dayCellDate(dayCell));
//             int month = cDate.get(MONTH_OF_YEAR);
//             Text secondaryText = (Text)dayCell.getProperties().get(&quot;DateCell.secondaryText&quot;);

//             if (month == majorityMonth) {
//                 seenMajorityMonth = true;
//                 secondaryText.getStyleClass().add(&quot;current-month&quot;);
//             } else {
//                 secondaryText.getStyleClass().add(seenMajorityMonth ? &quot;next-month&quot; : &quot;previous-month&quot;);
//             }
//         }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/CellBehaviorBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import javafx.scene.control.Cell;
import javafx.scene.control.Control;
import javafx.scene.control.FocusModel;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.MultipleSelectionModel;
import javafx.scene.control.SelectionMode;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;

import java.util.ArrayList;
import java.util.List;

/**
 * Behaviors for standard cells types. Simply defines methods that subclasses
 * implement so that CellSkinBase has API to call.
 */
public abstract class CellBehaviorBase&lt;T extends Cell&gt; extends BehaviorBase&lt;T&gt; {


    /***************************************************************************
     *                                                                         *
     * Private static implementation                                           *
     *                                                                         *
     **************************************************************************/

    private static final String ANCHOR_PROPERTY_KEY = &quot;anchor&quot;;

    // The virtualised controls all start with selection on row 0 by default.
    // This means that we have a default anchor, but it should be removed if
    // a different anchor could be set - and normally we ignore the default
    // anchor anyway.
    private static final String IS_DEFAULT_ANCHOR_KEY = &quot;isDefaultAnchor&quot;;

    public static &lt;T&gt; T getAnchor(Control control, T defaultResponse) {
        return hasNonDefaultAnchor(control) ?
                (T) control.getProperties().get(ANCHOR_PROPERTY_KEY) :
                defaultResponse;
    }

    public static &lt;T&gt; void setAnchor(Control control, T anchor, boolean isDefaultAnchor) {
        if (control == null) return;
        if (anchor == null) {
            removeAnchor(control);
        } else {
            control.getProperties().put(ANCHOR_PROPERTY_KEY, anchor);
            control.getProperties().put(IS_DEFAULT_ANCHOR_KEY, isDefaultAnchor);
        }
    }

    public static boolean hasNonDefaultAnchor(Control control) {
        Boolean isDefaultAnchor = (Boolean) control.getProperties().remove(IS_DEFAULT_ANCHOR_KEY);
        return (isDefaultAnchor == null || isDefaultAnchor == false) &amp;&amp; hasAnchor(control);
    }

    public static boolean hasDefaultAnchor(Control control) {
        Boolean isDefaultAnchor = (Boolean) control.getProperties().remove(IS_DEFAULT_ANCHOR_KEY);
        return isDefaultAnchor != null &amp;&amp; isDefaultAnchor == true &amp;&amp; hasAnchor(control);
    }

    private static boolean hasAnchor(Control control) {
        return control.getProperties().get(ANCHOR_PROPERTY_KEY) != null;
    }

    public static void removeAnchor(Control control) {
        control.getProperties().remove(ANCHOR_PROPERTY_KEY);
        control.getProperties().remove(IS_DEFAULT_ANCHOR_KEY);
    }



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final InputMap&lt;T&gt; cellInputMap;

    // To support touch devices, we have to slightly modify this behavior, such
    // that selection only happens on mouse release, if only minimal dragging
    // has occurred.
    private boolean latePress = false;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public CellBehaviorBase(T control) {
        super(control);

        // create a map for cell-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        cellInputMap = createInputMap();

        // TODO add focus traversal mappings (?)
        // addDefaultMapping(cellInputMap, FocusTraversalInputMap.getFocusTraversalMappings());

        InputMap.MouseMapping pressedMapping, releasedMapping, mouseDragged;
        addDefaultMapping(
            pressedMapping = new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
            releasedMapping = new InputMap.MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
            mouseDragged = new InputMap.MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged)
        );
        pressedMapping.setAutoConsume(false);
        releasedMapping.setAutoConsume(false);
        mouseDragged.setAutoConsume(false);
    }


    protected abstract Control getCellContainer(); // e.g. ListView
    protected abstract MultipleSelectionModel&lt;?&gt; getSelectionModel();
    protected abstract FocusModel&lt;?&gt; getFocusModel();
    protected abstract void edit(T cell);
    protected boolean handleDisclosureNode(double x, double y) {
        return false;
    }
    protected boolean isClickPositionValid(final double x, final double y) {
        return true;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public InputMap&lt;T&gt; getInputMap() {
        return cellInputMap;
    }

    protected int getIndex() {
        return getNode() instanceof IndexedCell ? ((IndexedCell&lt;?&gt;)getNode()).getIndex() : -1;
    }

    public void mousePressed(MouseEvent e) {
        if (e.isSynthesized()) {
            latePress = true;
        } else {
            latePress  = isSelected();
            if (!latePress) {
                doSelect(e.getX(), e.getY(), e.getButton(), e.getClickCount(),
                        e.isShiftDown(), e.isShortcutDown());
            }
        }
    }

    public void mouseReleased(MouseEvent e) {
        if (latePress) {
            latePress = false;
            doSelect(e.getX(), e.getY(), e.getButton(), e.getClickCount(),
                    e.isShiftDown(), e.isShortcutDown());
        }
    }

    public void mouseDragged(MouseEvent e) {
        latePress = false;
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    protected void doSelect(final double x, final double y, final MouseButton button,
                            final int clickCount, final boolean shiftDown, final boolean shortcutDown) {
        // we update the cell to point to the new tree node
        final T cell = getNode();

        final Control cellContainer = getCellContainer();

        // If the mouse event is not contained within this TreeCell, then
        // we don't want to react to it.
        if (cell.isEmpty() || ! cell.contains(x, y)) {
            return;
        }

        final int index = getIndex();
        boolean selected = cell.isSelected();
        MultipleSelectionModel&lt;?&gt; sm = getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;?&gt; fm = getFocusModel();
        if (fm == null) return;

        // if the user has clicked on the disclosure node, we do nothing other
        // than expand/collapse the tree item (if applicable). We do not do editing!
        if (handleDisclosureNode(x,y)) {
            return;
        }

        // we only care about clicks in certain places (depending on the subclass)
        if (! isClickPositionValid(x, y)) return;

        // if shift is down, and we don't already have the initial focus index
        // recorded, we record the focus index now so that subsequent shift+clicks
        // result in the correct selection occuring (whilst the focus index moves
        // about).
        if (shiftDown) {
            if (! hasNonDefaultAnchor(cellContainer)) {
                setAnchor(cellContainer, fm.getFocusedIndex(), false);
            }
        } else {
            removeAnchor(cellContainer);
        }

        if (button == MouseButton.PRIMARY || (button == MouseButton.SECONDARY &amp;&amp; !selected)) {
            if (sm.getSelectionMode() == SelectionMode.SINGLE) {
                simpleSelect(button, clickCount, shortcutDown);
            } else {
                if (shortcutDown) {
                    if (selected) {
                        // we remove this row from the current selection
                        sm.clearSelection(index);
                        fm.focus(index);
                    } else {
                        // We add this row to the current selection
                        sm.select(index);
                    }
                } else if (shiftDown &amp;&amp; clickCount == 1) {
                    // we add all rows between the current selection focus and
                    // this row (inclusive) to the current selection.
                    final int focusedIndex = getAnchor(cellContainer, fm.getFocusedIndex());

                    selectRows(focusedIndex, index);

                    fm.focus(index);
                } else {
                    simpleSelect(button, clickCount, shortcutDown);
                }
            }
        }
    }

    protected void simpleSelect(MouseButton button, int clickCount, boolean shortcutDown) {
        final int index = getIndex();
<A NAME="4"></A>        MultipleSelectionModel&lt;?&gt; sm = getSelectionModel();
        boolean isAlreadySelected = sm.isSelected(index);

        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#4',2,'match56-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (isAlreadySelected &amp;&amp; shortcutDown) {
            sm.clearSelection(index);
            getFocusModel().focus(index);
            isAlreadySelected = false;
        } else {
            sm.clearAndSelect</B></FONT>(index);
        }

        handleClicks(button, clickCount, isAlreadySelected);
    }

    protected void handleClicks(MouseButton button, int clickCount, boolean isAlreadySelected) {
        // handle editing, which only occurs with the primary mouse button
        if (button == MouseButton.PRIMARY) {
            if (clickCount == 1 &amp;&amp; isAlreadySelected) {
                edit(getNode());
            } else if (clickCount == 1) {
                // cancel editing
                edit(null);
            } else if (clickCount == 2 &amp;&amp; getNode().isEditable()) {
                edit(getNode());
            }
        }
    }

    void selectRows(int focusedIndex, int index) {
        final boolean asc = focusedIndex &lt; index;

        // and then determine all row and columns which must be selected
        int minRow = Math.min(focusedIndex, index);
        int maxRow = Math.max(focusedIndex, index);

        // To prevent RT-32119, we make a copy of the selected indices
        // list first, so that we are not iterating and modifying it
        // concurrently.
        List&lt;Integer&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectionModel().getSelectedIndices());
        for (int i = 0, max = selectedIndices.size(); i &lt; max; i++) {
            int selectedIndex = selectedIndices.get(i);
            if (selectedIndex &lt; minRow || selectedIndex &gt; maxRow) {
                getSelectionModel().clearSelection(selectedIndex);
            }
        }

        if (minRow == maxRow) {
            // RT-32560: This prevents the anchor 'sticking' in
            // the wrong place when a range is selected and then
            // selection goes back to the anchor position.
            // (Refer to the video in RT-32560 for more detail).
            getSelectionModel().select(minRow);
        } else {
            // RT-21444: We need to put the range in the correct
            // order or else the last selected row will not be the
            // last item in the selectedItems list of the selection
            // model,
            if (asc) {
                getSelectionModel().selectRange(minRow, maxRow + 1);
            } else {
                getSelectionModel().selectRange(maxRow, minRow - 1);
            }
        }
    }

    protected boolean isSelected() {
        return getNode().isSelected();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextFieldBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.Properties;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.TextField;
import javafx.scene.control.skin.TextFieldSkin;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.HitInfo;
import javafx.stage.Screen;
import javafx.stage.Window;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.geom.transform.Affine3D;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;

/**
 * Text field behavior.
 */
public class TextFieldBehavior extends TextInputControlBehavior&lt;TextField&gt; {
    private TextFieldSkin skin;
    private TwoLevelFocusBehavior tlFocus;
    private ChangeListener&lt;Scene&gt; sceneListener;
    private ChangeListener&lt;Node&gt; focusOwnerListener;

    public TextFieldBehavior(final TextField textField) {
        super(textField);

        if (Properties.IS_TOUCH_SUPPORTED) {
            contextMenu.getStyleClass().add(&quot;text-input-context-menu&quot;);
        }

        handleFocusChange();

        // Register for change events
        textField.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            handleFocusChange();
        });

        focusOwnerListener = (observable, oldValue, newValue) -&gt; {
            // RT-23699: The selection is now only affected when the TextField
            // gains or loses focus within the Scene, and not when the whole
            // stage becomes active or inactive.
            if (newValue == textField) {
                if (!focusGainedByMouseClick) {
                    textField.selectRange(textField.getLength(), 0);
                }
            } else {
                textField.selectRange(0, 0);
            }
        };

        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
                                new WeakChangeListener&lt;Node&gt;(focusOwnerListener);
        sceneListener = (observable, oldValue, newValue) -&gt; {
            if (oldValue != null) {
                oldValue.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newValue != null) {
                newValue.focusOwnerProperty().addListener(weakFocusOwnerListener);
            }
        };
        textField.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;(sceneListener));

        if (textField.getScene() != null) {
            textField.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(textField); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();
    }

    private void handleFocusChange() {
        TextField textField = getNode();

        if (textField.isFocused()) {
            if (PlatformUtil.isIOS()) {
                // special handling of focus on iOS is required to allow to
                // control native keyboard, because nat. keyboard is poped-up only when native
                // text component gets focus. When we have JFX keyboard we can remove this code
                TextInputTypes type = TextInputTypes.TEXT_FIELD;
                if (textField.getClass().equals(javafx.scene.control.PasswordField.class)) {
                    type = TextInputTypes.PASSWORD_FIELD;
                } else if (textField.getParent().getClass().equals(javafx.scene.control.ComboBox.class)) {
                    type = TextInputTypes.EDITABLE_COMBO;
                }
                final Bounds bounds = textField.getBoundsInParent();
                double w = bounds.getWidth();
                double h = bounds.getHeight();
                Affine3D trans = calculateNodeToSceneTransform(textField);
//                Insets insets = skin.getInsets();
//                w -= insets.getLeft() + insets.getRight();
//                h -= insets.getTop() + insets.getBottom();
                String text = textField.getText();

                // we need to display native text input component on the place where JFX component is drawn
                // all parameters needed to do that are passed to native impl. here
                WindowHelper.getPeer(textField.getScene().getWindow()).requestInput(
                        text, type.ordinal(), w, h,
                        trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),// + insets.getLeft(),
                        trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),// + insets.getTop(),
                        trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
            }
            if (!focusGainedByMouseClick) {
                setCaretAnimating(true);
            }
        } else {
            if (PlatformUtil.isIOS() &amp;&amp; textField.getScene() != null) {
                // releasing the focus =&gt; we need to hide the native component and also native keyboard
                WindowHelper.getPeer(textField.getScene().getWindow()).releaseInput();
            }
            focusGainedByMouseClick = false;
            setCaretAnimating(false);
        }
    }

    static Affine3D calculateNodeToSceneTransform(Node node) {
        final Affine3D transform = new Affine3D();
        do {
            transform.preConcatenate(NodeHelper.getLeafTransform(node));
            node = node.getParent();
        } while (node != null);

        return transform;
    }

    // An unholy back-reference!
    public void setTextFieldSkin(TextFieldSkin skin) {
        this.skin = skin;
    }

    @Override protected void fire(KeyEvent event) {
        TextField textField = getNode();
        EventHandler&lt;ActionEvent&gt; onAction = textField.getOnAction();
        ActionEvent actionEvent = new ActionEvent(textField, null);

        textField.commitValue();
        textField.fireEvent(actionEvent);

        if (onAction == null &amp;&amp; !actionEvent.isConsumed()) {
            forwardToParent(event);
        }
    }

    @Override
    protected void cancelEdit(KeyEvent event) {
        TextField textField = getNode();
        if (textField.getTextFormatter() != null) {
            textField.cancelEdit();
            event.consume();
        } else {
            super.cancelEdit(event);
        }
    }

    @Override protected void deleteChar(boolean previous) {
        skin.deleteChar(previous);
    }

    @Override protected void replaceText(int start, int end, String txt) {
        skin.setForwardBias(true);
        skin.replaceText(start, end, txt);
    }

    @Override protected void deleteFromLineStart() {
        TextField textField = getNode();
        int end = textField.getCaretPosition();

        if (end &gt; 0) {
            replaceText(0, end, &quot;&quot;);
        }
    }

    @Override protected void setCaretAnimating(boolean play) {
        if (skin != null) {
            skin.setCaretAnimating(play);
        }
    }

    /**
     * Function which beeps. This requires a hook into the toolkit, and should
     * also be guarded by something that indicates whether we should beep
     * (as it is pretty annoying and many native controls don't do it).
     */
    private void beep() {
        // TODO
    }

    /**
     * If the focus is gained via response to a mouse click, then we don't
     * want to select all the text even if selectOnFocus is true.
     */
    private boolean focusGainedByMouseClick = false;
    private boolean shiftDown = false;
    private boolean deferClick = false;

    @Override public void mousePressed(MouseEvent e) {
        TextField textField = getNode();
        // We never respond to events if disabled
        if (!textField.isDisabled()) {
            // If the text field doesn't have focus, then we'll attempt to set
            // the focus and we'll indicate that we gained focus by a mouse
            // click, which will then NOT honor the selectOnFocus variable
            // of the textInputControl
            if (!textField.isFocused()) {
                focusGainedByMouseClick = true;
                textField.requestFocus();
            }

            // stop the caret animation
            setCaretAnimating(false);
            // only if there is no selection should we see the caret
//            setCaretOpacity(if (textInputControl.dot == textInputControl.mark) then 1.0 else 0.0);

            // if the primary button was pressed
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                HitInfo hit = skin.getIndex(e.getX(), e.getY());
                int i = hit.getInsertionIndex();
                final int anchor = textField.getAnchor();
                final int caretPosition = textField.getCaretPosition();
                if (e.getClickCount() &lt; 2 &amp;&amp;
                    (Properties.IS_TOUCH_SUPPORTED ||
                     (anchor != caretPosition &amp;&amp;
                      ((i &gt; anchor &amp;&amp; i &lt; caretPosition) || (i &lt; anchor &amp;&amp; i &gt; caretPosition))))) {
                    // if there is a selection, then we will NOT handle the
                    // press now, but will defer until the release. If you
                    // select some text and then press down, we change the
                    // caret and wait to allow you to drag the text (TODO).
                    // When the drag concludes, then we handle the click

                    deferClick = true;
                    // TODO start a timer such that after some millis we
                    // switch into text dragging mode, change the cursor
                    // to indicate the text can be dragged, etc.
                } else if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    switch (e.getClickCount()) {
                        case 1: mouseSingleClick(hit); break;
                        case 2: mouseDoubleClick(hit); break;
                        case 3: mouseTripleClick(hit); break;
                        default: // no-op
                    }
                } else if (e.isShiftDown() &amp;&amp; !(e.isControlDown() || e.isAltDown() || e.isMetaDown()) &amp;&amp; e.getClickCount() == 1) {
                    // didn't click inside the selection, so select
                    shiftDown = true;
                    // if we are on mac os, then we will accumulate the
                    // selection instead of just moving the dot. This happens
                    // by figuring out past which (dot/mark) are extending the
                    // selection, and set the mark to be the other side and
                    // the dot to be the new position.
                    // everywhere else we just move the dot.
                    if (isMac()) {
                        textField.extendSelection(i);
                    } else {
                        skin.positionCaret(hit, true);
                    }
                }
<A NAME="9"></A>                skin.setForwardBias(hit.isLeading());
//                if (textInputControl.editable)
//                    displaySoftwareKeyboard(true);
            <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#9',2,'match56-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        }
        if (contextMenu.isShowing()) {
            contextMenu.hide();
        }
    }

    @Override pu</B></FONT>blic void mouseDragged(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled() &amp;&amp; !deferClick) {
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), true);
                }
            }
        }
    }

    @Override public void mouseReleased(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled()) {
            setCaretAnimating(false);
            if (deferClick) {
                deferClick = false;
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), shiftDown);
                shiftDown = false;
            }
            setCaretAnimating(true);
        }
    }

    @Override public void contextMenuRequested(ContextMenuEvent e) {
        final TextField textField = getNode();

        if (contextMenu.isShowing()) {
            contextMenu.hide();
        } else if (textField.getContextMenu() == null &amp;&amp;
                   textField.getOnContextMenuRequested() == null) {
            double screenX = e.getScreenX();
            double screenY = e.getScreenY();
            double sceneX = e.getSceneX();

            if (Properties.IS_TOUCH_SUPPORTED) {
                Point2D menuPos;
                if (textField.getSelection().getLength() == 0) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                    menuPos = skin.getMenuPosition();
                } else {
                    menuPos = skin.getMenuPosition();
                    if (menuPos != null &amp;&amp; (menuPos.getX() &lt;= 0 || menuPos.getY() &lt;= 0)) {
                        skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                        menuPos = skin.getMenuPosition();
                    }
                }

                if (menuPos != null) {
                    Point2D p = getNode().localToScene(menuPos);
                    Scene scene = getNode().getScene();
                    Window window = scene.getWindow();
                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),
                                                   window.getY() + scene.getY() + p.getY());
                    screenX = location.getX();
                    sceneX = p.getX();
                    screenY = location.getY();
                }
            }

            populateContextMenu();
            double menuWidth = contextMenu.prefWidth(-1);
            double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0);
            Screen currentScreen = com.sun.javafx.util.Utils.getScreenForPoint(screenX, 0);
            Rectangle2D bounds = currentScreen.getBounds();

            if (menuX &lt; bounds.getMinX()) {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), bounds.getMinX(), screenY);
            } else if (screenX + menuWidth &gt; bounds.getMaxX()) {
                double leftOver = menuWidth - ( bounds.getMaxX() - screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), screenX - leftOver, screenY);
            } else {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, 0);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, 0);
                contextMenu.show(getNode(), menuX, screenY);
            }
        }

        e.consume();
    }

    protected void mouseSingleClick(HitInfo hit) {
        skin.positionCaret(hit, false);
    }

    protected void mouseDoubleClick(HitInfo hit) {
        final TextField textField = getNode();
        textField.previousWord();
        if (isWindows()) {
            textField.selectNextWord();
        } else {
            textField.selectEndOfNextWord();
        }
    }

    protected void mouseTripleClick(HitInfo hit) {
        getNode().selectAll();
    }

    // Enumeration of all types of text input that can be simulated on
    // touch device, such as iPad. Type is passed to native code and
    // native text component is shown. It's used as workaround for iOS
    // devices since keyboard control is not possible without native
    // text component being displayed
    enum TextInputTypes {
        TEXT_FIELD,
        PASSWORD_FIELD,
        EDITABLE_COMBO,
        TEXT_AREA;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextInputControlBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.FXVK;

import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.skin.TextInputControlSkin;
import javafx.application.ConditionalFeature;
import javafx.beans.InvalidationListener;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.IndexRange;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PasswordField;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextInputControl;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.Clipboard;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import java.text.Bidi;
import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isLinux;
import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;
import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;
import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public abstract class TextInputControlBehavior&lt;T extends TextInputControl&gt; extends BehaviorBase&lt;T&gt; {

    /**
     * Specifies whether we ought to show handles. We should do it on touch platforms, but not
     * iOS (and maybe not Android either?)
     */
    static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED &amp;&amp; !PlatformUtil.isIOS();

    public static final String DISABLE_FORWARD_TO_PARENT = &quot;TextInputControlBehavior.disableForwardToParent&quot;;

    /**************************************************************************
     * Fields                                                                 *
     *************************************************************************/

    final T textInputControl;

    protected ContextMenu contextMenu;

    private InvalidationListener textListener = observable -&gt; invalidateBidi();

    private final InputMap&lt;T&gt; inputMap;




    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TextInputControlBehavior(T c) {
        super(c);

        this.textInputControl = c;

        textInputControl.textProperty().addListener(textListener);

        // create a map for text input-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();
        final Predicate&lt;KeyEvent&gt; validOnWindows = e -&gt; !PlatformUtil.isWindows();
        final Predicate&lt;KeyEvent&gt; validOnLinux = e -&gt; !PlatformUtil.isLinux();

        KeyMapping cancelEditMapping;
        KeyMapping consumeMostPressedEventsMapping;

        // create a child input map for mappings which are applicable on all
        // platforms, and regardless of editing state
        addDefaultMapping(inputMap,
                // caret movement
                keyMapping(RIGHT, e -&gt; nextCharacterVisually(true)),
                keyMapping(LEFT, e -&gt; nextCharacterVisually(false)),
                keyMapping(UP, e -&gt; c.home()),
                keyMapping(HOME, e -&gt; c.home()),
                keyMapping(DOWN, e -&gt; c.end()),
                keyMapping(END, e -&gt; c.end()),
                keyMapping(ENTER, this::fire),

                keyMapping(new KeyBinding(HOME).shortcut(), e -&gt; c.home()),
                keyMapping(new KeyBinding(END).shortcut(), e -&gt; c.end()),

                // deletion (only applies when control is editable)
                keyMapping(new KeyBinding(BACK_SPACE), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(DELETE), e -&gt; deleteNextChar(), validWhenEditable),

                // cut (only applies when control is editable)
                keyMapping(new KeyBinding(X).shortcut(), e -&gt; cut(), validWhenEditable),
                keyMapping(new KeyBinding(CUT), e -&gt; cut(), validWhenEditable),

                // copy
                keyMapping(new KeyBinding(C).shortcut(), e -&gt; c.copy()),
                keyMapping(new KeyBinding(INSERT).shortcut(), e -&gt; c.copy()),
                keyMapping(COPY, e -&gt; c.copy()),

                // paste (only applies when control is editable)
                keyMapping(new KeyBinding(V).shortcut(), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(PASTE), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(INSERT).shift(), e -&gt; paste(), validWhenEditable),

                // selection
                keyMapping(new KeyBinding(RIGHT).shift(), e -&gt; selectRight()),
                keyMapping(new KeyBinding(LEFT).shift(), e -&gt; selectLeft()),
                keyMapping(new KeyBinding(UP).shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(DOWN).shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(A).shortcut(), e -&gt; c.selectAll()),

                // Traversal Bindings
                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),

                // The following keys are forwarded to the parent container
                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                keyMapping(new KeyBinding(Z).shortcut(), e -&gt; undo()),

                // character input.
                // Any other key press first goes to normal text input
                // Note this is KEY_TYPED because otherwise the character is not available in the event.
                keyMapping(new KeyBinding(null, KEY_TYPED)
                                    .alt(OptionalBoolean.ANY)
                                    .shift(OptionalBoolean.ANY)
                                    .ctrl(OptionalBoolean.ANY)
                                    .meta(OptionalBoolean.ANY),
                           this::defaultKeyTyped),

                // However, we want to consume other key press / release events too, for
                // things that would have been handled by the InputCharacter normally
                consumeMostPressedEventsMapping =
                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),
                               e -&gt; { if (!e.getCode().isFunctionKey()) e.consume(); }),

                // VK
                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -&gt; {
                    FXVK.toggleUseVK(textInputControl);
                }, p -&gt; !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),

                // mouse and context menu mappings
                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),
                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
                new InputMap.Mapping&lt;ContextMenuEvent&gt;(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {
                    @Override public int getSpecificity(Event event) {
                        return 1;
                    }
                }
        );

        cancelEditMapping.setAutoConsume(false);
        consumeMostPressedEventsMapping.setAutoConsume(false);

        // mac os specific mappings
        InputMap&lt;T&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEndExtend()),
            keyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; c.home()),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; c.end()),
            keyMapping(new KeyBinding(LEFT).alt(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).alt(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(DELETE).alt(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -&gt; deleteFromLineStart()),
            keyMapping(new KeyBinding(Z).shortcut().shift(), e -&gt; redo()),
            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; selectEndExtend()),

            // Mac OS specific selection mappings
            keyMapping(new KeyBinding(LEFT).shift().alt(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;T&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHome()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEnd()),
            keyMapping(new KeyBinding(LEFT).ctrl(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(H).ctrl(), e -&gt; deletePreviousChar()),
            keyMapping(new KeyBinding(DELETE).ctrl(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -&gt; c.deselect()),
            keyMapping(new KeyBinding(Y).ctrl(), e -&gt; redo(), validOnWindows),
            keyMapping(new KeyBinding(Z).ctrl().shift(), e -&gt; redo(), validOnLinux),
            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, nonMacOsInputMap);

        addKeyPadMappings(inputMap);

        textInputControl.textProperty().addListener(textListener);

        contextMenu = new ContextMenu();
}

    @Override public InputMap&lt;T&gt; getInputMap() {
        return inputMap;
    }

    /**
     * Bind keypad arrow keys to the same as the regular arrow keys.
     */
    protected void addKeyPadMappings(InputMap&lt;T&gt; map) {
        // First create a temporary map for the keypad mappings
        InputMap&lt;T&gt; tmpMap = new InputMap&lt;&gt;(getNode());
        for (Object o : map.getMappings()) {
            if (o instanceof KeyMapping) {
                KeyMapping mapping = (KeyMapping)o;
                KeyBinding kb = (KeyBinding)mapping.getMappingKey();
                if (kb.getCode() != null) {
                    KeyCode newCode = null;
                    switch (kb.getCode()) {
                        case LEFT:  newCode = KP_LEFT;  break;
                        case RIGHT: newCode = KP_RIGHT; break;
                        case UP:    newCode = KP_UP;    break;
                        case DOWN:  newCode = KP_DOWN;  break;
                        default:
                    }
                    if (newCode != null) {
                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())
                                                                  .ctrl(kb.getCtrl())
                                                                  .alt(kb.getAlt())
                                                                  .meta(kb.getMeta());
                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));
                    }
                }
            }
        }
        // Install mappings
        for (Object o : tmpMap.getMappings()) {
            map.getMappings().add((KeyMapping)o);
        }

        // Recursive call for child maps
        for (Object o : map.getChildInputMaps()) {
            addKeyPadMappings((InputMap&lt;T&gt;)o);
        }
    }


    /**
     * Wraps the event handler to pause caret blinking when
     * processing the key event.
     */
    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(new KeyBinding(keyCode), eventHandler);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(keyBinding, eventHandler, null);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler,
                                    Predicate&lt;KeyEvent&gt; interceptor) {
        return new KeyMapping(keyBinding,
                              e -&gt; {
                                  setCaretAnimating(false);
                                  eventHandler.handle(e);
                                  setCaretAnimating(true);
                              },
                              interceptor);
    }





    /**************************************************************************
     * Disposal methods                                                       *
     *************************************************************************/

    @Override public void dispose() {
        textInputControl.textProperty().removeListener(textListener);
        super.dispose();
    }

    /**************************************************************************
     * Abstract methods                                                       *
     *************************************************************************/

    protected abstract void deleteChar(boolean previous);
    protected abstract void replaceText(int start, int end, String txt);
    protected abstract void setCaretAnimating(boolean play);
    protected abstract void deleteFromLineStart();

    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void contextMenuRequested(ContextMenuEvent e);

    /**************************************************************************
     * Key handling implementation                                            *
     *************************************************************************/

    /**
     * The default handler for a key typed event, which is called when none of
     * the other key bindings match. This is the method which handles basic
     * text entry.
     * @param event not null
     */
    private void defaultKeyTyped(KeyEvent event) {
        final TextInputControl textInput = getNode();
        // I'm not sure this case can actually ever happen, maybe this
        // should be an assert instead?
        if (!textInput.isEditable() || textInput.isDisabled()) return;

        // Sometimes we get events with no key character, in which case
        // we need to bail.
        String character = event.getCharacter();
        if (character.length() == 0) return;

        // Filter out control keys except control+Alt on PC or Alt on Mac
        if (event.isControlDown() || event.isAltDown() || (isMac() &amp;&amp; event.isMetaDown())) {
            if (!((event.isControlDown() || isMac()) &amp;&amp; event.isAltDown())) return;
        }

        setEditing(true);

        // Ignore characters in the control range and the ASCII delete
        // character as well as meta key presses
        if (character.charAt(0) &gt; 0x1F
                &amp;&amp; character.charAt(0) != 0x7F
                &amp;&amp; !event.isMetaDown()) { // Not sure about this one
            final IndexRange selection = textInput.getSelection();
            final int start = selection.getStart();
            final int end = selection.getEnd();

            replaceText(start, end, character);
        }

        setEditing(false);
    }

    private Bidi bidi = null;
    private Boolean mixed = null;
    private Boolean rtlText = null;

    private void invalidateBidi() {
        bidi = null;
        mixed = null;
        rtlText = null;
    }

    private Bidi getBidi() {
        if (bidi == null) {
            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),
                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)
                            ? Bidi.DIRECTION_RIGHT_TO_LEFT
                            : Bidi.DIRECTION_LEFT_TO_RIGHT);
        }
        return bidi;
    }

    protected boolean isMixed() {
        if (mixed == null) {
            mixed = getBidi().isMixed();
        }
        return mixed;
    }

    protected boolean isRTLText() {
        if (rtlText == null) {
            Bidi bidi = getBidi();
            rtlText =
                    (bidi.isRightToLeft() ||
                            (isMixed() &amp;&amp;
                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));
        }
        return rtlText;
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isMixed()) {
            TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;)textInputControl.getSkin();
            skin.moveCaret(TextUnit.CHARACTER, moveRight ? Direction.RIGHT : Direction.LEFT, false);
        } else if (moveRight != isRTLText()) {
            textInputControl.forward();
        } else {
            textInputControl.backward();
        }
    }

    private void selectLeft() {
        if (isRTLText()) {
            textInputControl.selectForward();
        } else {
            textInputControl.selectBackward();
        }
    }

    private void selectRight() {
        if (isRTLText()) {
            textInputControl.selectBackward();
        } else {
            textInputControl.selectForward();
        }
    }

    private void deletePreviousChar() {
        setEditing(true);
        deleteChar(true);
        setEditing(false);
    }

    private void deleteNextChar() {
        setEditing(true);
        deleteChar(false);
        setEditing(false);
    }

    protected void deletePreviousWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int end = textInputControl.getCaretPosition();

        if (end &gt; 0) {
            textInputControl.previousWord();
            int start = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    protected void deleteNextWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int start = textInputControl.getCaretPosition();

        if (start &lt; textInputControl.getLength()) {
            nextWord();
            int end = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    public void deleteSelection() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        IndexRange selection = textInputControl.getSelection();

        if (selection.getLength() &gt; 0) {
            deleteChar(false);
        }
        setEditing(false);
    }

    public void cut() {
        setEditing(true);
        getNode().cut();
        setEditing(false);
    }

    public void paste() {
        setEditing(true);
        getNode().paste();
        setEditing(false);
    }

    public void undo() {
        setEditing(true);
        getNode().undo();
        setEditing(false);
    }

    public void redo() {
        setEditing(true);
        getNode().redo();
        setEditing(false);
    }

    protected void selectPreviousWord() {
        getNode().selectPreviousWord();
    }

    public void selectNextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.selectEndOfNextWord();
        } else {
            textInputControl.selectNextWord();
        }
    }

    private void selectLeftWord() {
        if (isRTLText()) {
            selectNextWord();
        } else {
            selectPreviousWord();
        }
    }

    private void selectRightWord() {
        if (isRTLText()) {
            selectPreviousWord();
        } else {
            selectNextWord();
        }
    }

    protected void selectWord() {
        final TextInputControl textInputControl = getNode();
        textInputControl.previousWord();
        if (isWindows()) {
            textInputControl.selectNextWord();
        } else {
            textInputControl.selectEndOfNextWord();
        }
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void selectAll() {
        getNode().selectAll();
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void previousWord() {
        getNode().previousWord();
    }

    protected void nextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.endOfNextWord();
        } else {
            textInputControl.nextWord();
        }
    }

    private void leftWord() {
        if (isRTLText()) {
            nextWord();
        } else {
            previousWord();
        }
    }

    private void rightWord() {
        if (isRTLText()) {
            previousWord();
<A NAME="21"></A>        } else {
            nextWord();
        }
    <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#21',2,'match56-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    protected void fire(KeyEvent event) { } // TODO move to TextFieldBehavior
    protected void cancelEdit(KeyEvent event) { forwardToParent(event);}</B></FONT> // not autoconsumed

    protected void forwardToParent(KeyEvent event) {
        // fix for JDK-8145515
        if (getNode().getProperties().containsKey(DISABLE_FORWARD_TO_PARENT)) {
            return;
        }

        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }

    protected void selectHome() {
        getNode().selectHome();
    }

    protected void selectEnd() {
        getNode().selectEnd();
    }

    protected void selectHomeExtend() {
        getNode().extendSelection(0);
    }

    protected void selectEndExtend() {
        TextInputControl textInputControl = getNode();
        textInputControl.extendSelection(textInputControl.getLength());
    }

    private boolean editing = false;
    protected void setEditing(boolean b) {
        editing = b;
    }
    public boolean isEditing() {
        return editing;
    }

    protected void populateContextMenu() {
        TextInputControl textInputControl = getNode();
        boolean editable = textInputControl.isEditable();
        boolean hasText = (textInputControl.getLength() &gt; 0);
        boolean hasSelection = (textInputControl.getSelection().getLength() &gt; 0);
        boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength());
        boolean maskText = (textInputControl instanceof PasswordField); // (maskText(&quot;A&quot;) != &quot;A&quot;);
        ObservableList&lt;MenuItem&gt; items = contextMenu.getItems();

        if (SHOW_HANDLES) {
            items.clear();
            if (!maskText &amp;&amp; hasSelection) {
                if (editable) {
                    items.add(cutMI);
                }
                items.add(copyMI);
            }
            if (editable &amp;&amp; Clipboard.getSystemClipboard().hasString()) {
                items.add(pasteMI);
            }
            if (hasText &amp;&amp; !allSelected) {
                if (!hasSelection &amp;&amp; !(textInputControl instanceof PasswordField)) {
                    items.add(selectWordMI);
                }
                items.add(selectAllMI);
            }
            selectWordMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
            selectAllMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
        } else {
            if (editable) {
                items.setAll(undoMI, redoMI, cutMI, copyMI, pasteMI, deleteMI,
                        separatorMI, selectAllMI);
            } else {
                items.setAll(copyMI, separatorMI, selectAllMI);
            }
            undoMI.setDisable(!getNode().isUndoable());
            redoMI.setDisable(!getNode().isRedoable());
            cutMI.setDisable(maskText || !hasSelection);
            copyMI.setDisable(maskText || !hasSelection);
            pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString());
            deleteMI.setDisable(!hasSelection);
        }
    }

    private static class ContextMenuItem extends MenuItem {
        ContextMenuItem(final String action, EventHandler&lt;ActionEvent&gt; onAction) {
            super(getString(&quot;TextInputControl.menu.&quot; + action));
            setOnAction(onAction);
        }
    }

    private final MenuItem undoMI   = new ContextMenuItem(&quot;Undo&quot;, e -&gt; undo());
    private final MenuItem redoMI   = new ContextMenuItem(&quot;Redo&quot;, e -&gt; redo());
    private final MenuItem cutMI    = new ContextMenuItem(&quot;Cut&quot;, e -&gt; cut());
    private final MenuItem copyMI   = new ContextMenuItem(&quot;Copy&quot;, e -&gt; getNode().copy());
    private final MenuItem pasteMI  = new ContextMenuItem(&quot;Paste&quot;, e -&gt; paste());
    private final MenuItem deleteMI = new ContextMenuItem(&quot;DeleteSelection&quot;, e -&gt; deleteSelection());
    private final MenuItem selectWordMI = new ContextMenuItem(&quot;SelectWord&quot;, e -&gt; selectWord());
    private final MenuItem selectAllMI = new ContextMenuItem(&quot;SelectAll&quot;, e -&gt; selectAll());
    private final MenuItem separatorMI = new SeparatorMenuItem();

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/FXVKSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.SkinBase;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.TextField;
import javafx.scene.control.TextArea;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.Scene;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.input.InputEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.Region;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Window;
import javafx.util.Duration;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.HashMap;
import static javafx.scene.input.MouseEvent.MOUSE_PRESSED;
import static javafx.scene.input.TouchEvent.TOUCH_PRESSED;
import static javafx.scene.layout.Region.USE_PREF_SIZE;
import java.security.AccessController;
import java.security.PrivilegedAction;


public class FXVKSkin extends SkinBase&lt;FXVK&gt; {

    private static final int GAP = 6;

    private List&lt;List&lt;Key&gt;&gt; currentBoard;
    private static HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt; boardMap = new HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt;();
    private int numCols;

    private boolean capsDown = false;
    private boolean shiftDown = false;
    private boolean isSymbol = false;
    long lastTime = -1L;

    void clearShift() {
        if (shiftDown &amp;&amp; !capsDown) {
            shiftDown = false;
            updateKeys();
        }
        lastTime = -1L;
    }

    void pressShift() {
        long time = System.currentTimeMillis();

        //potential for a shift lock
        if (shiftDown &amp;&amp; !capsDown) {
            if (lastTime &gt; 0L &amp;&amp; time - lastTime &lt; 400L) {
                //set caps lock
                shiftDown = false;
                capsDown =  true;
            } else {
                //set normal
                shiftDown = false;
                capsDown =  false;
            }
        } else if (!shiftDown &amp;&amp; !capsDown) {
            // set shift
            shiftDown=true;
        } else {
            //set to normal
            shiftDown = false;
            capsDown =  false;
        }

        updateKeys();
        lastTime = time;
    }

    void clearSymbolABC() {
        isSymbol = false;
        updateKeys();
    }

    void pressSymbolABC() {
        isSymbol = !isSymbol;
        updateKeys();
    }

    void clearStateKeys() {
        capsDown = false;
        shiftDown = false;
        isSymbol = false;
        lastTime = -1L;
        updateKeys();
    }

    private void updateKeys() {
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                key.update(capsDown, shiftDown, isSymbol);
            }
        }
    }

    private static Popup vkPopup;
    private static Popup secondaryPopup;
    private static FXVK primaryVK;

    private static Timeline slideInTimeline = new Timeline();
    private static Timeline slideOutTimeline = new Timeline();
    private static boolean hideAfterSlideOut = false;

    private static FXVK secondaryVK;
    private static Timeline secondaryVKDelay;
    private static CharKey secondaryVKKey;
    private static TextInputKey repeatKey;

    private static Timeline repeatInitialDelay;
    private static Timeline repeatSubsequentDelay;

    // key repeat initial delay (ms)
    private static double KEY_REPEAT_DELAY = 400;
    private static double KEY_REPEAT_DELAY_MIN = 100;
    private static double KEY_REPEAT_DELAY_MAX = 1000;

    // key repeat rate (cps)
    private static double KEY_REPEAT_RATE = 25;
    private static double KEY_REPEAT_RATE_MIN = 2;
    private static double KEY_REPEAT_RATE_MAX = 50;

    private Node attachedNode;
    private String vkType = null;

    FXVK fxvk;

    static final double VK_HEIGHT = 243;
    static final double VK_SLIDE_MILLIS = 250;
    static final double PREF_PORTRAIT_KEY_WIDTH = 40;
    static final double PREF_KEY_HEIGHT = 56;

    static boolean vkAdjustWindow = false;
    static boolean vkLookup = false;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String s = System.getProperty(&quot;com.sun.javafx.vk.adjustwindow&quot;);
            if (s != null) {
                vkAdjustWindow = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.sqe.vk.lookup&quot;);
            if (s != null) {
                vkLookup = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatDelay&quot;);
            if (s != null) {
                Double delay = Double.valueOf(s);
                KEY_REPEAT_DELAY = Math.min(Math.max(delay, KEY_REPEAT_DELAY_MIN), KEY_REPEAT_DELAY_MAX);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatRate&quot;);
            if (s != null) {
                Double rate = Double.valueOf(s);
                if (rate &lt;= 0) {
                    //disable key repeat
                    KEY_REPEAT_RATE = 0;
                } else {
                    KEY_REPEAT_RATE = Math.min(Math.max(rate, KEY_REPEAT_RATE_MIN), KEY_REPEAT_RATE_MAX);
                }
            }
            return null;
        });
    }

    // Proxy for read-only Window.yProperty() so we can animate.
    private static DoubleProperty winY = new SimpleDoubleProperty();
    static {
        winY.addListener(valueModel -&gt; {
            if (vkPopup != null) {
                vkPopup.setY(winY.get());
            }
        });
    }

    private static void startSlideIn() {
        slideOutTimeline.stop();
        slideInTimeline.playFromStart();
    }

    private static void startSlideOut(boolean doHide) {
        hideAfterSlideOut = doHide;
        slideInTimeline.stop();
        slideOutTimeline.playFromStart();
    }

    private void adjustWindowPosition(final Node node) {
        if ( !(node instanceof TextInputControl) ) {
            return;
        }

        // attached node y position in window coordinates
        double inputControlMinY = node.localToScene(0.0, 0.0).getY() + node.getScene().getY();
        double inputControlHeight = ((TextInputControl) node).getHeight();
        double inputControlMaxY = inputControlMinY + inputControlHeight;

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(node).getBounds().getHeight();
        double visibleAreaMaxY = screenHeight - VK_HEIGHT;

        double inputLineCenterY = 0.0;
        double inputLineBottomY = 0.0;
        double newWindowYPos = 0.0;
        double screenTopOffset = 10.0;

        if (node instanceof TextField) {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            //check for combo box
            Parent parent = attachedNode.getParent();
            if (parent instanceof ComboBoxBase) {
                //combo box
                // position near screen top
                newWindowYPos = Math.min(screenTopOffset - inputControlMinY, 0);
            } else {
                // position at center of visible screen area
                newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin textAreaSkin = (TextAreaSkin)((TextArea)node).getSkin();
            Bounds caretBounds = textAreaSkin.getCaretBounds();
            double caretMinY = caretBounds.getMinY();
            double caretMaxY = caretBounds.getMaxY();
            inputLineCenterY = inputControlMinY + ( caretMinY + caretMaxY ) / 2;
            inputLineBottomY = inputControlMinY + caretMaxY;

            if (inputControlHeight &lt; visibleAreaMaxY) {
                // position at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - (inputControlMinY + inputControlHeight / 2);
            } else {
                // position the line containing the caret at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - inputLineCenterY;
            }
            newWindowYPos = Math.min(newWindowYPos, 0);

        } else {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            // position at center of visible screen area
            newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
        }

        Window w = node.getScene().getWindow();
        if (origWindowYPos + inputLineBottomY &gt; visibleAreaMaxY) {
            w.setY(newWindowYPos);
        } else {
            w.setY(origWindowYPos);
        }
    }

    private void saveWindowPosition(final Node node) {
        Window w = node.getScene().getWindow();
        origWindowYPos = w.getY();
    }

    private void restoreWindowPosition(final Node node) {
        if (node != null) {
            Scene scene = node.getScene();
            if (scene != null) {
                Window window = scene.getWindow();
                if (window != null) {
                    window.setY(origWindowYPos);
                }
            }
        }
    }

    EventHandler&lt;InputEvent&gt; unHideEventHandler;

    private boolean isVKHidden = false;
    private Double origWindowYPos = null;

    private void registerUnhideHandler(final Node node) {
        if (unHideEventHandler == null) {
            unHideEventHandler = event -&gt; {
                if (attachedNode != null &amp;&amp; isVKHidden) {
                    double screenHeight = com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds().getHeight();
                    if (fxvk.getHeight() &gt; 0 &amp;&amp; (vkPopup.getY() &gt; screenHeight - fxvk.getHeight())) {
                        if (slideInTimeline.getStatus() != Animation.Status.RUNNING) {
                            startSlideIn();
                            if (vkAdjustWindow) {
                                adjustWindowPosition(attachedNode);
                            }
                        }
                    }
                }
                isVKHidden = false;
            };
        }
        node.addEventHandler(TOUCH_PRESSED, unHideEventHandler);
        node.addEventHandler(MOUSE_PRESSED, unHideEventHandler);
    }

    private void unRegisterUnhideHandler(Node node) {
        if (unHideEventHandler != null) {
            node.removeEventHandler(TOUCH_PRESSED, unHideEventHandler);
            node.removeEventHandler(MOUSE_PRESSED, unHideEventHandler);
        }
    }

    private String getNodeVKType(Node node) {
        Integer vkType = (Integer)node.getProperties().get(FXVK.VK_TYPE_PROP_KEY);
        String typeStr = null;
        if (vkType != null) {
            Object typeValue = FXVK.VK_TYPE_NAMES[vkType];
            if (typeValue instanceof String) {
                typeStr = ((String)typeValue).toLowerCase(Locale.ROOT);
            }
        }
        return (typeStr != null ? typeStr : &quot;text&quot;);
    }

    private void updateKeyboardType(Node node) {
        String oldType = vkType;
        vkType = getNodeVKType(node);
        //VK type changed, rebuild
        if ( oldType == null || !vkType.equals(oldType) ) {
            rebuildPrimaryVK(vkType);
        }
    }

    private void closeSecondaryVK() {
        if (secondaryVK != null) {
            secondaryVK.setAttachedNode(null);
            secondaryPopup.hide();
        }
    }

    private void setupPrimaryVK() {
        fxvk.setFocusTraversable(false);
        fxvk.setVisible(true);

        // init popup window and slide animations
        if (vkPopup == null) {
            vkPopup = new Popup();
            vkPopup.setAutoFix(false);
        }
        vkPopup.getContent().setAll(fxvk);

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getHeight();
        double width = com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getWidth();

        //Setup VK slide animations
        slideInTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                         new KeyValue(winY, screenHeight - VK_HEIGHT,
                                      Interpolator.EASE_BOTH)));
        slideOutTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                    event -&gt; {
                        if (hideAfterSlideOut &amp;&amp; vkPopup.isShowing()) {
                            vkPopup.hide();
                        }
                    },
                new KeyValue(winY, screenHeight, Interpolator.EASE_BOTH)));

        //Set VK size
        fxvk.setPrefWidth(width);
        fxvk.setMinWidth(USE_PREF_SIZE);
        fxvk.setMaxWidth(USE_PREF_SIZE);

        fxvk.setPrefHeight(VK_HEIGHT);
        fxvk.setMinHeight(USE_PREF_SIZE);


        //set up long-press triger for secondary VK
        if (secondaryVKDelay == null) {
            secondaryVKDelay = new Timeline();
        }
        KeyFrame kf = new KeyFrame(Duration.millis(500), event -&gt; {
            if (secondaryVKKey != null) {
                showSecondaryVK(secondaryVKKey);
            }
        });
        secondaryVKDelay.getKeyFrames().setAll(kf);

        //Setup key repeat animations
        if (KEY_REPEAT_RATE &gt; 0) {
            repeatInitialDelay = new Timeline(new KeyFrame(
                    Duration.millis(KEY_REPEAT_DELAY),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                        //Start repeat animation
                        repeatSubsequentDelay.playFromStart();
                    }
            ));
            repeatSubsequentDelay = new Timeline(new KeyFrame(
                    Duration.millis(1000.0 / KEY_REPEAT_RATE),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                    }
            ));
            repeatSubsequentDelay.setCycleCount(Animation.INDEFINITE);
        }
    }

    void prerender(Node node) {
        if (fxvk != primaryVK) {
            return;
        }

        //Preload all boards
        loadBoard(&quot;text&quot;);
        loadBoard(&quot;numeric&quot;);
        loadBoard(&quot;url&quot;);
        loadBoard(&quot;email&quot;);

        updateKeyboardType(node);
        fxvk.setVisible(true);

        if (!vkPopup.isShowing()) {
            Rectangle2D screenBounds =
                com.sun.javafx.util.Utils.getScreen(node).getBounds();

            vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
            winY.set(screenBounds.getHeight());
            vkPopup.show(node.getScene().getWindow());
        }
    }

    public FXVKSkin(final FXVK fxvk) {
        super(fxvk);
        this.fxvk = fxvk;
        if (fxvk == FXVK.vk) {
            primaryVK = fxvk;
        }

        if (fxvk == primaryVK) {
            setupPrimaryVK();
        }

        fxvk.attachedNodeProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                Node oldNode = attachedNode;
                attachedNode = fxvk.getAttachedNode();
                if (fxvk != primaryVK) {
                    return;
                }

                closeSecondaryVK();

                if (attachedNode != null) {
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    registerUnhideHandler(attachedNode);
                    updateKeyboardType(attachedNode);

                    //owner window has changed so hide VK and show with new owner
                    if (oldNode == null || oldNode.getScene() == null || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                        if (vkPopup.isShowing()) {
                            vkPopup.hide();
                        } else {
<A NAME="14"></A>                        }
                    }

                    if (!vkPopup.isShowing()) <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#14',2,'match56-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                        Rectangle2D screenBounds =
                            com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds();

                        vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
                        if (oldNode == null || isVKHidden) {</B></FONT>
                            //position off screen
                            winY.set(screenBounds.getHeight());
                        } else {
                            //position on screen (no slide in)
                            winY.set(screenBounds.getHeight() - VK_HEIGHT);
                        }
                        vkPopup.show(attachedNode.getScene().getWindow());
                    }

                    if (oldNode == null || isVKHidden) {
                        startSlideIn();
                    }

                    if (vkAdjustWindow) {
                        //update previous window position only if moving from non-input control node or window has changed.
                        if (oldNode == null || oldNode.getScene() == null
                            || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                            saveWindowPosition(attachedNode);
                        }
                        // Move window containing input node
                        adjustWindowPosition(attachedNode);
                    }
                } else { // attachedNode == null
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    startSlideOut(true);
                    // Restore window position
                    if (vkAdjustWindow) {
                        restoreWindowPosition(oldNode);
                    }
                }
                isVKHidden = false;
            }
        });
    }

    /**
     * builds secondary (long-press) VK
     */
    private void rebuildSecondaryVK() {
        if (secondaryVK.chars == null) {
        } else {
            int nKeys = secondaryVK.chars.length;
            int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
            int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

            Key tmpKey;
            List&lt;List&lt;Key&gt;&gt; rows = new ArrayList&lt;List&lt;Key&gt;&gt;(2);

            for (int i = 0; i &lt; nRows; i++) {
                int start = i * nKeysPerRow;
                int end = Math.min(start + nKeysPerRow, nKeys);
                if (start &gt;= end)
                    break;

                List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(nKeysPerRow);
                for (int j = start; j &lt; end; j++) {
                    tmpKey = new CharKey(secondaryVK.chars[j], null, null);
                    tmpKey.col= (j - start) * 2;
                    tmpKey.colSpan = 2;
                    for (String sc : tmpKey.getStyleClass()) {
                        tmpKey.text.getStyleClass().add(sc + &quot;-text&quot;);
                        tmpKey.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                        tmpKey.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                    }
                    if (secondaryVK.chars[j] != null &amp;&amp; secondaryVK.chars[j].length() &gt; 1) {
                        tmpKey.text.getStyleClass().add(&quot;multi-char-text&quot;);
                    }
                    keys.add(tmpKey);
                }
                rows.add(keys);
            }
            currentBoard = rows;

            getChildren().clear();
            numCols = 0;
            for (List&lt;Key&gt; row : currentBoard) {
                for (Key key : row) {
                    numCols = Math.max(numCols, key.col + key.colSpan);
                }
                getChildren().addAll(row);
            }
        }
    }

    /**
     * builds primary VK based on the keyboard
     * type set on the VirtualKeyboard.
     */
    private void rebuildPrimaryVK(String type) {
        currentBoard = loadBoard(type);

        //Clear all state keys and updates current board
        clearStateKeys();

        getChildren().clear();
        numCols = 0;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                numCols = Math.max(numCols, key.col + key.colSpan);
            }
            getChildren().addAll(row);
        }
    }

    // This skin is designed such that it gives equal widths to all columns. So
    // the pref width is just some hard-coded value (although I could have maybe
    // done it based on the pref width of a text node with the right font).
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return leftInset + (56 * numCols) + rightInset;
    }

    // Pref height is just some value. This isn't overly important.
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + (80 * 5) + bottomInset;
    }

    // Lays the buttons comprising the current keyboard out.
    @Override
    protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        // I have fixed width columns, all the same.
        int numRows = currentBoard.size();
        final double colWidth = ((contentWidth - ((numCols - 1) * GAP)) / numCols);
        double rowHeight = ((contentHeight - ((numRows - 1) * GAP)) / numRows);
        double rowY = contentY;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                double startX = contentX + (key.col * (colWidth + GAP));
                double width = (key.colSpan * (colWidth + GAP)) - GAP;
                key.resizeRelocate((int)(startX + .5), (int)(rowY + .5),
                                   width, rowHeight);
            }
            rowY += rowHeight + GAP;
        }
    }


    /**
     * A Key on the virtual keyboard. This is simply a Region. Some information
     * about the key relative to other keys on the layout is given by the col
     * and colSpan fields.
     */
    private class Key extends Region {
        int col = 0;
        int colSpan = 1;
        protected final Text text;
        protected final Text altText;
        protected final Region icon;

        protected Key() {
            icon = new Region();
            text = new Text();
            text.setTextOrigin(VPos.TOP);
            altText = new Text();
            altText.setTextOrigin(VPos.TOP);
            getChildren().setAll(text, altText, icon);
            getStyleClass().setAll(&quot;key&quot;);
            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    press();
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    release();
            });
        }
        protected void press() { }
        protected void release() {
            clearShift();
        }

        public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) { }

        @Override protected void layoutChildren() {
            final double left = snappedLeftInset();
            final double top = snappedTopInset();
            final double width = getWidth() - left - snappedRightInset();
            final double height = getHeight() - top - snappedBottomInset();

            text.setVisible(icon.getBackground() == null);
            double contentPrefWidth = text.prefWidth(-1);
            double contentPrefHeight = text.prefHeight(-1);
            text.resizeRelocate(
                    (int) (left + ((width - contentPrefWidth) / 2) + .5),
                    (int) (top + ((height - contentPrefHeight) / 2) + .5),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            altText.setVisible(icon.getBackground() == null &amp;&amp; altText.getText().length() &gt; 0);
            contentPrefWidth = altText.prefWidth(-1);
            contentPrefHeight = altText.prefHeight(-1);
            altText.resizeRelocate(
                    (int) left + (width - contentPrefWidth) + .5,
                    (int) (top + ((height - contentPrefHeight) / 2) + .5 - height/2),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            icon.resizeRelocate(left-8, top-8, width+16, height+16);
        }

    }

    /**
     * Any key on the keyboard which will send a KeyEvent to the client. This
     * class just maintains the state and logic for firing an event, using the
     * &quot;chars&quot; and &quot;code&quot; as the values sent in the event. A subclass must set
     * these appropriately.
     */
    private class TextInputKey extends Key {
        String chars = &quot;&quot;;

        protected void press() {
        }
        protected void release() {
            if (fxvk != secondaryVK &amp;&amp; secondaryPopup != null &amp;&amp; secondaryPopup.isShowing()) {
                return;
            }
            sendKeyEvents();
            if (fxvk == secondaryVK) {
                showSecondaryVK(null);
            }
            super.release();
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                if (chars != null) {
                    target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                }
            }
        }
    }

    /**
     * A key which has a letter, a number or symbol on it
     *
     */
    private class CharKey extends TextInputKey {
        private final String letterChars;
        private final String altChars;
        private final String[] moreChars;

        private CharKey(String letter, String alt, String[] moreChars, String id) {
            this.letterChars = letter;
            this.altChars = alt;
            this.moreChars = moreChars;
            this.chars = this.letterChars;

            text.setText(this.chars);
            altText.setText(this.altChars);
            if (vkLookup) {
                setId((id != null ? id : chars).replaceAll(&quot;\\.&quot;, &quot;&quot;));
            }
        }

        private CharKey(String letter, String alt, String[] moreChars) {
            this(letter, alt, moreChars, null);
        }

        protected void press() {
            super.press();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                showSecondaryVK(null);
                secondaryVKKey = CharKey.this;
                secondaryVKDelay.playFromStart();
            }
        }

        protected void release() {
            super.release();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                secondaryVKDelay.stop();
            }
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            if (isSymbol) {
                chars = altChars;
                text.setText(chars);
                if (moreChars != null &amp;&amp; moreChars.length &gt; 0 &amp;&amp; !Character.isLetter(moreChars[0].charAt(0))) {
                    altText.setText(moreChars[0]);
                } else {
                    altText.setText(null);
                }
            } else {
                chars = (capsDown || shiftDown) ? letterChars.toUpperCase() : letterChars.toLowerCase();
                text.setText(chars);
                altText.setText(altChars);
            }
        }
    }

    /**
     * One of several TextInputKeys which have super powers, such as &quot;Tab&quot; and
     * &quot;Return&quot; and &quot;Backspace&quot;. These keys still send events to the client,
     * but may also have additional state related functionality on the keyboard
     * such as the &quot;Shift&quot; key.
     */
    private class SuperKey extends TextInputKey {
        private SuperKey(String letter, String code) {
            this.chars = code;
            text.setText(letter);
            getStyleClass().add(&quot;special&quot;);
            if (vkLookup) {
                setId(letter);
            }
        }
    }

    /**
     * Some keys actually do need to use KeyCode for pressed / released events,
     * and BackSpace is one of them.
     */
    private class KeyCodeKey extends SuperKey {
        private KeyCode code;

        private KeyCodeKey(String letter, String c, KeyCode code) {
            super(letter, c);
            this.code = code;
            if (vkLookup) {
                setId(letter);
            }
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                target.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_RELEASED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
            }
        }
    }

    /**
     * These keys only manipulate the state of the keyboard and never
     * send key events to the client. For example, &quot;Hide&quot;, &quot;Caps Lock&quot;,
     * etc are all KeyboardStateKeys.
     */
    private class KeyboardStateKey extends Key {
        private final String defaultText;
        private final String toggledText;

        private KeyboardStateKey(String defaultText, String toggledText, String id) {
            this.defaultText = defaultText;
            this.toggledText = toggledText;
            text.setText(this.defaultText);
            if (vkLookup &amp;&amp; id != null) {
                setId(id);
            }
            getStyleClass().add(&quot;special&quot;);
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            //change icon

            if (isSymbol) {
                text.setText(this.toggledText);
            } else {
                text.setText(this.defaultText);
            }
        }
    }

    private void showSecondaryVK(final CharKey key) {
        if (key != null) {
            final Node textInput = primaryVK.getAttachedNode();

            if (secondaryVK == null) {
                secondaryVK = new FXVK();
                //secondaryVK.getStyleClass().addAll(&quot;fxvk-secondary&quot;, &quot;fxvk-portrait&quot;);
                secondaryVK.setSkin(new FXVKSkin(secondaryVK));
                secondaryVK.getStyleClass().setAll(&quot;fxvk-secondary&quot;);
                secondaryPopup = new Popup();
                secondaryPopup.setAutoHide(true);
                secondaryPopup.getContent().add(secondaryVK);
            }

            secondaryVK.chars=null;
            ArrayList&lt;String&gt; secondaryList = new ArrayList&lt;String&gt;();

            // Add primary character
            if (!isSymbol) {
                if (key.letterChars != null &amp;&amp; key.letterChars.length() &gt; 0) {
                    if (shiftDown || capsDown) {
                        secondaryList.add(key.letterChars.toUpperCase());
                    } else {
                        secondaryList.add(key.letterChars);
                    }
                }
            }

            // Add secondary character
            if (key.altChars != null &amp;&amp; key.altChars.length() &gt; 0) {
                if (shiftDown || capsDown) {
                    secondaryList.add(key.altChars.toUpperCase());
                } else {
                    secondaryList.add(key.altChars);
                }
            }

            // Add more letters
            if (key.moreChars != null &amp;&amp; key.moreChars.length &gt; 0) {
                if (isSymbol) {
                    //Add non-letters
                    for (String ch : key.moreChars) {
                        if (!Character.isLetter(ch.charAt(0))) {
                            secondaryList.add(ch);
                        }
                    }
                 } else {
                    //Add letters
                    for (String ch : key.moreChars) {
                        if (Character.isLetter(ch.charAt(0))) {
                            if (shiftDown || capsDown) {
                                secondaryList.add(ch.toUpperCase());
                            } else {
                                secondaryList.add(ch);
                            }
                        }
                    }
                }
            }

            boolean isMultiChar = false;
            for (String s : secondaryList) {
                if (s.length() &gt; 1 ) {
                    isMultiChar = true;
                }
            }

            secondaryVK.chars = secondaryList.toArray(new String[secondaryList.size()]);

            if (secondaryVK.chars.length &gt; 1) {
                if (secondaryVK.getSkin() != null) {
                    ((FXVKSkin)secondaryVK.getSkin()).rebuildSecondaryVK();
                }

                secondaryVK.setAttachedNode(textInput);
                FXVKSkin primarySkin = (FXVKSkin)primaryVK.getSkin();
                FXVKSkin secondarySkin = (FXVKSkin)secondaryVK.getSkin();
                //Insets insets = secondarySkin.getInsets();
                int nKeys = secondaryVK.chars.length;
                int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
                int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

                final double w = snappedLeftInset() + snappedRightInset() +
                                 nKeysPerRow * PREF_PORTRAIT_KEY_WIDTH * (isMultiChar ? 2 : 1) + (nKeysPerRow - 1) * GAP;
                final double h = snappedTopInset() + snappedBottomInset() +
                                 nRows * PREF_KEY_HEIGHT + (nRows-1) * GAP;

                secondaryVK.setPrefWidth(w);
                secondaryVK.setMinWidth(USE_PREF_SIZE);
                secondaryVK.setPrefHeight(h);
                secondaryVK.setMinHeight(USE_PREF_SIZE);
                Platform.runLater(() -&gt; {
                    // Position popup on screen
                    Point2D nodePoint =
                        com.sun.javafx.util.Utils.pointRelativeTo(key, w, h, HPos.CENTER, VPos.TOP,
                                                             5, -3, true);
                    double x = nodePoint.getX();
                    double y = nodePoint.getY();
                    Scene scene = key.getScene();
                    x = Math.min(x, scene.getWindow().getX() + scene.getWidth() - w);
                    secondaryPopup.show(key.getScene().getWindow(), x, y);
                });
            }
        } else {
            closeSecondaryVK();
        }
    }


    private List&lt;List&lt;Key&gt;&gt; loadBoard(String type) {
        List&lt;List&lt;Key&gt;&gt; tmpBoard = boardMap.get(type);
        if (tmpBoard != null) {
            return tmpBoard;
        }

        String boardFileName = type.substring(0,1).toUpperCase() + type.substring(1).toLowerCase() + &quot;Board.txt&quot;;
        try {
            tmpBoard = new ArrayList&lt;List&lt;Key&gt;&gt;(5);
            List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(20);

            InputStream boardFile = FXVKSkin.class.getResourceAsStream(boardFileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(boardFile, &quot;UTF-8&quot;));
            String line;
            // A pointer to the current column. This will be incremented for every string
            // of text, or space.
            int c = 0;
            // The col at which the key will be placed
            int col = 0;
            // The number of columns that the key will span
            int colSpan = 1;
            // Whether the &quot;chars&quot; is an identifier, like $shift or $SymbolBoard, etc.
            boolean identifier = false;
            // The textual content of the Key
            List&lt;String&gt; charsList = new ArrayList&lt;String&gt;(10);

            while ((line = reader.readLine()) != null) {
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                // A single line represents a single row of buttons
                for (int i=0; i&lt;line.length(); i++) {
                    char ch = line.charAt(i);

                    // Process the char
                    if (ch == ' ') {
                        c++;
                    } else if (ch == '[') {
                        // Start of a key
                        col = c;
                        charsList = new ArrayList&lt;String&gt;(10);
                        identifier = false;
                    } else if (ch == ']') {
                        String chars = &quot;&quot;;
                        String alt = null;
                        String[] moreChars = null;

                        for (int idx = 0; idx &lt; charsList.size(); idx++) {
                            charsList.set(idx, FXVKCharEntities.get(charsList.get(idx)));
                        }

                        int listSize = charsList.size();
                        if (listSize &gt; 0) {
                            chars = charsList.get(0);
                            if (listSize &gt; 1) {
                                alt = charsList.get(1);
                                if (listSize &gt; 2) {
                                    moreChars = charsList.subList(2, listSize).toArray(new String[listSize - 2]);
                                }
                            }
                        }

                        // End of a key
                        colSpan = c - col;
                        Key key;
                        if (identifier) {
                            if (&quot;$shift&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;&quot;, null, &quot;shift&quot;) {
                                    @Override protected void release() {
                                        pressShift();
                                    }

                                    @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
                                        if (isSymbol) {
                                            this.setDisable(true);
                                            this.setVisible(false);
                                        } else {
                                            if (capsDown) {
                                                icon.getStyleClass().remove(&quot;shift-icon&quot;);
                                                icon.getStyleClass().add(&quot;capslock-icon&quot;);
                                            } else {
                                                icon.getStyleClass().remove(&quot;capslock-icon&quot;);
                                                icon.getStyleClass().add(&quot;shift-icon&quot;);
                                            }
                                            this.setDisable(false);
                                            this.setVisible(true);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;shift&quot;);

                            } else if (&quot;$SymbolABC&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;!#123&quot;, &quot;ABC&quot;, &quot;symbol&quot;) {
                                    @Override protected void release() {
                                        pressSymbolABC();
                                    }
                                };
                            } else if (&quot;$backspace&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;backspace&quot;, &quot;\b&quot;, KeyCode.BACK_SPACE) {
                                    @Override protected void press() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            clearShift();
                                            sendKeyEvents();
                                            repeatKey = this;
                                            repeatInitialDelay.playFromStart();
                                        } else {
                                            super.press();
                                        }
                                    }
                                    @Override protected void release() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            repeatInitialDelay.stop();
                                            repeatSubsequentDelay.stop();
                                        } else {
                                            super.release();
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;backspace&quot;);
                            } else if (&quot;$enter&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;enter&quot;, &quot;\n&quot;, KeyCode.ENTER);
                                key.getStyleClass().add(&quot;enter&quot;);
                            } else if (&quot;$tab&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;tab&quot;, &quot;\t&quot;, KeyCode.TAB);
                            } else if (&quot;$space&quot;.equals(chars)) {
                                key = new CharKey(&quot; &quot;, &quot; &quot;, null, &quot;space&quot;);
                            } else if (&quot;$clear&quot;.equals(chars)) {
                                key = new SuperKey(&quot;clear&quot;, &quot;&quot;);
                            } else if (&quot;$.org&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.org&quot;, &quot;.org&quot;);
                            } else if (&quot;$.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.com&quot;, &quot;.com&quot;);
                            } else if (&quot;$.net&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.net&quot;, &quot;.net&quot;);
                            } else if (&quot;$oracle.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;oracle.com&quot;, &quot;oracle.com&quot;);
                            } else if (&quot;$gmail.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;gmail.com&quot;, &quot;gmail.com&quot;);
                            } else if (&quot;$hide&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;hide&quot;, null, &quot;hide&quot;) {
                                    @Override protected void release() {
                                        isVKHidden = true;
                                        startSlideOut(false);
                                        // Restore window position
                                        if (vkAdjustWindow) {
                                            restoreWindowPosition(attachedNode);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;hide&quot;);
                            } else if (&quot;$undo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;undo&quot;, &quot;&quot;);
                            } else if (&quot;$redo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;redo&quot;, &quot;&quot;);
                            } else {
                                //Unknown Key
                                key = null;
                            }
                        } else {
                            key = new CharKey(chars, alt, moreChars);
                        }
                        if (key != null) {
                            key.col = col;
                            key.colSpan = colSpan;
                            for (String sc : key.getStyleClass()) {
                                key.text.getStyleClass().add(sc + &quot;-text&quot;);
                                key.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                                key.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                            }
                            if (chars != null &amp;&amp; chars.length() &gt; 1) {
                                key.text.getStyleClass().add(&quot;multi-char-text&quot;);
                            }
                            if (alt != null &amp;&amp; alt.length() &gt; 1) {
                                key.altText.getStyleClass().add(&quot;multi-char-text&quot;);
                            }

                            keys.add(key);
                        }
                    } else {
                        // Normal textual characters. Read all the way up to the
                        // next ] or space
                        for (int j=i; j&lt;line.length(); j++) {
                            char c2 = line.charAt(j);
                            boolean e = false;
                            if (c2 == '\\') {
                                j++;
                                i++;
                                e = true;
                                c2 = line.charAt(j);
                            }

                            if (c2 == '$' &amp;&amp; !e) {
                                identifier = true;
                            }

                            if (c2 == '|' &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j + 1;
                            } else if ((c2 == ']' || c2 == ' ') &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j-1;
                                break;
                            }
                        }
                        c++;
                    }
                }

                c = 0;
                col = 0;
                tmpBoard.add(keys);
                keys = new ArrayList&lt;Key&gt;(20);
            }
            reader.close();
            boardMap.put(type, tmpBoard);
            return tmpBoard;
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Cell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.shape.Rectangle;
import javafx.css.PseudoClass;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.value.WritableValue;
import javafx.css.StyleableProperty;

/**
 * The Cell API is used for virtualized controls such as {@link ListView},
 * {@link TreeView}, and {@link TableView}.
 * A Cell is a {@link Labeled} {@link Control}, and is used to render a single
 * &quot;row&quot; inside  a ListView, TreeView or TableView. Cells are also used for each
 * individual 'cell' inside a TableView (i.e. each row/column intersection). See
 * the JavaDoc for each control separately for more detail.
 * &lt;p&gt;
 * Every Cell is associated with a single data item (represented by the
 * {@link #itemProperty() item} property). The Cell is responsible for
 * rendering that item and, where appropriate, for editing the item. An item
 * within a Cell may be represented by text or some other control such as a
 * {@link CheckBox}, {@link ChoiceBox} or any other {@link Node} such as a
 * {@link HBox}, {@link GridPane}, or even a {@link Rectangle}.
 * &lt;p&gt;
 * Because TreeView, ListView, TableView and other such controls can potentially
 * be used for displaying incredibly large amounts of data, it is not feasible
 * to create an actual Cell for every single item in the control.
 * We represent extremely large data sets using only very few Cells. Each Cell
 * is &quot;recycled&quot;, or reused. This is what we mean when we say that these controls
 * are virtualized.
 * &lt;p&gt;
 * Since Cell is a Control, it is essentially a &quot;model&quot;. Its Skin is responsible
 * for defining the look and layout, while the Behavior is responsible for
 * handling all input events and using that information to modify the Control
 * state. Also, the Cell is styled from CSS just like any other Control.
 * However, it is not necessary to implement a Skin for most uses of a Cell.
 * This is because a cell factory can be set - this is detailed more shortly.
 * &lt;p&gt;
 * Because by far the most common use case for cells is to show text to a user,
 * this use case is specially optimized for within Cell. This is done by Cell
 * extending from {@link Labeled}. This means that subclasses of Cell need only
 * set the {@link #textProperty() text} property, rather than create a separate
 * {@link Label} and set that within the Cell. However, for situations where
 * something more than just plain text is called for, it is possible to place
 * any {@link Node} in the Cell {@link #graphicProperty() graphic} property.
 * Despite the term, a graphic can be any Node, and will be fully interactive.
 * For example, a ListCell might be configured with a {@link Button} as its
 * graphic. The Button text could then be bound to the cells
 * {@link #itemProperty() item} property. In this way, whenever the item in the
 * Cell changes, the Button text is automatically updated.
 * &lt;p&gt;
 * Cell sets focusTraversable to false.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;Cell Factories&lt;/b&gt;
 * &lt;p&gt;
 * The default representation of the Cell &lt;code&gt;item&lt;/code&gt; is up to the various
 * virtualized container's skins to render. For example, the ListView by default
 * will convert the item to a String and call {@link #setText(java.lang.String)}
 * with this value. If you want to specialize the Cell used for the
 * ListView (for example), then you must provide an implementation of the
 * {@link ListView#cellFactoryProperty() cellFactory} callback function defined
 * on the ListView. Similar API exists on most controls that use Cells (for example,
 * {@link TreeView#cellFactoryProperty() TreeView},
 * {@link TableView#rowFactoryProperty() TableView},
 * {@link TableColumn#cellFactoryProperty() TableColumn} and
 * {@link ListView#cellFactoryProperty() ListView}.
 * &lt;p&gt;
 * The cell factory is called by the platform whenever it determines that a new
 * cell needs to be created. For example, perhaps your ListView has 10 million
 * items. Creating all 10 million cells would be prohibitively expensive. So
 * instead the ListView skin implementation might only create just enough cells
 * to fit the visual space. If the ListView is resized to be larger, the system
 * will determine that it needs to create some additional cells. In this case
 * it will call the cellFactory callback function (if one is provided) to create
 * the Cell implementation that should be used. If no cell factory is provided,
 * the built-in default implementation will be used.
 * &lt;p&gt;
 * The implementation of the cell factory is then responsible not just for
 * creating a Cell instance, but also configuring that Cell such that it reacts
 * to changes in its state. For example, if I were to create
 * a custom Cell which formatted Numbers such that they would appear as currency
 * types, I might do so like this:
 *
 * &lt;pre&gt;
 * public class MoneyFormatCell extends ListCell&amp;lt;Number&amp;gt; {
 *
 *     public MoneyFormatCell() {    }
 *
 *     &amp;#064;Override protected void updateItem(Number item, boolean empty) {
 *         // calling super here is very important - don't skip this!
 *         super.updateItem(item, empty);
 *
 *         // format the number as if it were a monetary value using the
 *         // formatting relevant to the current locale. This would format
 *         // 43.68 as &quot;$43.68&quot;, and -23.67 as &quot;-$23.67&quot;
 *         setText(item == null ? &quot;&quot; : NumberFormat.getCurrencyInstance().format(item));
 *
 *         // change the text fill based on whether it is positive (green)
 *         // or negative (red). If the cell is selected, the text will
 *         // always be white (so that it can be read against the blue
 *         // background), and if the value is zero, we'll make it black.
 *         if (item != null) {
 *             double value = item.doubleValue();
 *             setTextFill(isSelected() ? Color.WHITE :
 *                 value == 0 ? Color.BLACK :
 *                 value &amp;lt; 0 ? Color.RED : Color.GREEN);
 *         }
 *     }
 * }&lt;/pre&gt;
 *
 * This class could then be used inside a ListView as such:
 *
 * &lt;pre&gt;
 * ObservableList&amp;lt;Number&amp;gt; money = ...;
 * final ListView&amp;lt;Number&amp;gt; listView = new ListView&amp;lt;Number&amp;gt;(money);
 * listView.setCellFactory(new Callback&amp;lt;ListView&amp;lt;Number&amp;gt;, ListCell&amp;lt;Number&amp;gt;&amp;gt;() {
 *     &amp;#064;Override public ListCell&amp;lt;Number&amp;gt; call(ListView&amp;lt;Number&amp;gt; list) {
 *         return new MoneyFormatCell();
 *     }
 * });&lt;/pre&gt;
 *
 * In this example an anonymous inner class is created, that simply returns
 * instances of MoneyFormatCell whenever it is called. The MoneyFormatCell class
 * extends {@link ListCell}, overriding the
 * {@link #updateItem(java.lang.Object, boolean) updateItem} method. This method
 * is called whenever the item in the cell changes, for example when the user
 * scrolls the ListView or the content of the underlying data model changes
 * (and the cell is reused to represent some different item in the ListView).
 * Because of this, there is no need to manage bindings - simply react to the
 * change in items when this method occurs. In the example above, whenever the
 * item changes, we update the cell text property, and also modify the text fill
 * to ensure that we get the correct visuals. In addition, if the cell is &quot;empty&quot;
 * (meaning it is used to fill out space in the ListView but doesn't have any
 * data associated with it), then we just use the empty String.
 * &lt;p&gt;
 * Note that there are additional
 * methods prefixed with 'update' that may be of interest, so be
 * sure to read the API documentation for Cell, and subclasses of Cell, closely.
 * &lt;p&gt;
 * Of course, we can also use the binding API rather than overriding the
 * 'update' methods. Shown below is a very trivial example of how this could
 * be achieved.
 *
 *
 * &lt;pre&gt;
 * public class BoundLabelCell extends ListCell&amp;lt;String&amp;gt; {
 *
 *     public BoundLabelCell() {
 *         textProperty().bind(itemProperty());
 *     }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h3&gt;Key Design Goals&lt;/h3&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Both time and memory efficient for large data sets&lt;/li&gt;
 *   &lt;li&gt;Easy to build and use libraries for custom cells&lt;/li&gt;
 *   &lt;li&gt;Easy to customize cell visuals&lt;/li&gt;
 *   &lt;li&gt;Easy to customize display formatting (12.34 as $12.34 or 1234% etc)&lt;/li&gt;
 *   &lt;li&gt;Easy to extend for custom visuals&lt;/li&gt;
 *   &lt;li&gt;Easy to have &quot;panels&quot; of data for the visuals&lt;/li&gt;
 *   &lt;li&gt;Easy to animate the cell size or other properties&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Key Use Cases&lt;/h3&gt;
 * Following are a number of key use cases used to drive the Cell API design,
 * along with code examples showing how those use cases are satisfied by this
 * API. This is by no means to be considered the definitive list of capabilities
 * or features supported, but rather, to provide some guidance as to how to use
 * the Cell API. The examples below are focused on the ListView, but the same
 * philosophy applies to TreeCells or other kinds of cells.
 * &lt;p&gt;
 * &lt;b&gt;Changing the Cell's Colors&lt;/b&gt;
 * &lt;p&gt;
 * This should be extraordinarily simple in JavaFX. Each Cell can be styled
 * directly from CSS. So for example, if you wanted to change the default
 * background of every cell in a ListView to be WHITE you could do the
 * following CSS:
 *
 * &lt;pre&gt;
 * .list-cell {
 *   -fx-padding: 3 3 3 3;
 *   -fx-background-color: white;
 * }&lt;/pre&gt;
 *
 * If you wanted to set the color of selected ListView cells to be blue, you
 * could add this to your CSS file:
 *
 * &lt;pre&gt;
 * .list-cell:selected {
 *   -fx-background-color: blue;
 * }&lt;/pre&gt;
 *
 * Most Cell implementations extend from {@link IndexedCell} rather than Cell.
 * IndexedCell adds two other pseudoclass states: &quot;odd&quot; and &quot;even&quot;. Using this
 * you can get alternate row striping by doing something like this in your CSS
 * file:
 *
 * &lt;pre&gt;
 * .list-cell:odd {
 *   -fx-background-color: grey;
 * }&lt;/pre&gt;
 *
 * Each of these examples require no code changes. Simply update your CSS
 * file to alter the colors. You can also use the &quot;hover&quot; and other
 * pseudoclasses in CSS the same as with other controls.
 * &lt;p&gt;
 * Another approach to the first example above (formatting a list of numbers) would
 * be to use style classes. Suppose you had an {@link ObservableList} of Numbers
 * to display in a ListView and wanted to color all of the negative values red
 * and all positive or 0 values black.
 * One way to achieve this is with a custom cellFactory which changes the
 * styleClass of the Cell based on whether the value is negative or positive. This
 * is as simple as adding code to test if the number in the cell is negative,
 * and adding a &quot;negative&quot; styleClass. If the number is not negative, the &quot;negative&quot;
 * string should be removed. This approach allows for the colors to be defined
 * from CSS, allowing for simple customization. The CSS file would then include
 * something like the following:
 *
 * &lt;pre&gt;
 * .list-cell {
 *   -fx-text-fill: black;
 * }
 *
 * .list-cell .negative {
 *   -fx-text-fill: red;
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;Most virtualized controls that use the Cell architecture (e.g. {@link ListView},
 * {@link TreeView}, {@link TableView} and {@link TreeTableView}) all support
 * the notion of editing values directly via the cell. You can learn more about
 * the control-specific details by going to the 'editing' section in the class
 * documentation for the controls linked above. The remainder of this section
 * will cover some of the finer details of editing with cells.&lt;/p&gt;
 *
 * &lt;p&gt;The general flow of editing is as follows (note that in these steps the
 * {@link ListView} control is used as an example, but similar API exists for
 * all controls mentioned above, and the process is exactly the same in general):&lt;/p&gt;
 *
 * &lt;ol&gt;
 *     &lt;li&gt;User requests a cell enter editing mode (via keyboard or mouse commands),
 *     or the developer requests that a cell enter editing mode (by calling a
 *     method such as the ListView {@link ListView#edit(int) edit} method.
 *     &lt;strong&gt;Note:&lt;/strong&gt; If the user double-clicks or fires an appropriate
 *     keyboard command to initiate editing, then they are effectively calling
 *     the appropriate edit method on the control (i.e. the entry method for
 *     user-initiated and developer-initiated editing is the same).&lt;/li&gt;
 *     &lt;li&gt;Each cell in the visible region of the control is notified that the
 *     current {@link javafx.scene.control.ListView#editingIndexProperty() editing cell}
 *     has changed, and checks to see if it is itself. At this point one of three
 *     things can happen:
 *         &lt;ol&gt;
 *             &lt;li&gt;If the editing index is the same index as the cell,
 *             {@link #startEdit()} will be called on this cell. Some pointers:
 *                 &lt;ol&gt;
 *                     &lt;li&gt;It is recommended that subclasses of Cell override the {@link #startEdit()}
 *                     method to update the visuals of the cell when enters the editing state. Note
 *                     however that it is very important that subclasses that override the
 *                     {@link #startEdit()} method continue to call {@code super.startEdit()} so
 *                     that parent classes can update additional state that is necessary for
 *                     editing to be successful.&lt;/li&gt;
 *                     &lt;li&gt;Within the {@link #startEdit()} method is an ideal
 *                     time to change the visuals of the cell. For example (and
 *                     note that this example is more fleshed out in the UI control
 *                     javadocs for {@link ListView}, etc), you may set the
 *                     {@link #graphicProperty()} of the cell to a
 *                     {@link TextField} and set the {@link #textProperty()}
 *                     to null. This would allow end users to then type in input
 *                     and make changes to your data model.&lt;/li&gt;
 *                     &lt;li&gt;When the user has completed editing, they will want
 *                     to commit or cancel their change. This is your responsibility
 *                     to handle (e.g. by having the Enter key
 *                     {@link #commitEdit(Object) commit the edit}
 *                     and the ESC key {@link #cancelEdit() cancel the edit}).
 *                     You do this by attaching the appropriate event listeners
 *                     to the nodes you show whilst in the editing state.&lt;/li&gt;
 *                 &lt;/ol&gt;
 *             &lt;/li&gt;
 *             &lt;li&gt;If the editing index is not the same index as the cell, and
 *             if the cell is currently in the {@link #isEditing() editing state},
 *             {@link #cancelEdit()} will be called on this cell. As with the
 *             {@link #startEdit()} method, you should override this method to
 *             clean up the visuals of the cell (and most probably return the
 *             {@link #graphicProperty()} back to null and set the
 *             {@link #textProperty()} to its (possibly new) value. Again,
 *             be sure to always call {@code super.cancelEdit()} to make sure all
 *             state is correctly updated.&lt;/li&gt;
 *             &lt;li&gt;If the editing index is not the same index as the cell, and
 *             if the cell is not currently in the {@link #isEditing()} editing state},
 *             then nothing will happen on this cell.&lt;/li&gt;
 *         &lt;/ol&gt;
 *     &lt;/li&gt;
 * &lt;/ol&gt;
 *
 *
 * @param &lt;T&gt; The type of the item contained within the Cell.
 *
 * @since JavaFX 2.0
 */
public class Cell&lt;T&gt; extends Labeled {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default Cell with the default style class of 'cell'.
     */
    public Cell() {
        setText(null); // default to null text, to match the null item
        // focusTraversable is styleable through css. Calling setFocusTraversable
<A NAME="17"></A>        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling set on the
        // CssMetaData ensures that css will be able to override the value.
        <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#17',2,'match56-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>((StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty()).applyStyle(null, Boolean.FALSE);
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);

        /**
         * Indicates whether or not this cell has focus. For example, a
         * ListView defines zero or one cell as being the &quot;focused&quot; cell. This cell
         * would have focused set to true.
         */
        super.focusedProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable property) {
                pseudoClassStateChanged(PSEUDO_CLASS_FOCUSED, isFocused</B></FONT>()); // TODO is this necessary??

                // The user has shifted focus, so we should cancel the editing on this cell
                if (!isFocused() &amp;&amp; isEditing()) {
                    cancelEdit();
                }
            }
        });

        // initialize default pseudo-class state
        pseudoClassStateChanged(PSEUDO_CLASS_EMPTY, true);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- item
    private ObjectProperty&lt;T&gt; item = new SimpleObjectProperty&lt;T&gt;(this, &quot;item&quot;);

    /**
     * The data value associated with this Cell. This value is set by the
     * virtualized Control when the Cell is created or updated. This represents
     * the raw data value.
    *
    * &lt;p&gt;This value should only be set in subclasses of Cell by the virtualised
    * user interface controls that know how to properly work with the Cell
    * class.
     * @return the data value associated with this cell
     */
    public final ObjectProperty&lt;T&gt; itemProperty() { return item; }

    /**
     * Sets the item to the given value - should not be called directly as the
     * item is managed by the virtualized control.
     * @param value the new data value to set in this cell
     */
    public final void setItem(T value) { item.set(value); }

    /**
     * Returns the data value associated with this Cell.
     * @return the data value associated with this cell
     */
    public final T getItem() { return item.get(); }



    // --- empty
    private ReadOnlyBooleanWrapper empty = new ReadOnlyBooleanWrapper(true) {
        @Override protected void invalidated() {
            final boolean active = get();
            pseudoClassStateChanged(PSEUDO_CLASS_EMPTY,   active);
            pseudoClassStateChanged(PSEUDO_CLASS_FILLED, !active);
        }

        @Override
        public Object getBean() {
            return Cell.this;
        }

        @Override
        public String getName() {
            return &quot;empty&quot;;
        }
    };

    /**
     * A property used to represent whether the cell has any contents.
     * If true, then the Cell contains no data and is not associated with any
     * data item in the virtualized Control.
     *
     * &lt;p&gt;When a cell is empty, it can be styled differently via the 'empty'
     * CSS pseudo class state. For example, it may not receive any
     * alternate row highlighting, or it may not receive hover background
     * fill when hovered.
     * @return the representation of whether this cell has any contents
     */
    public final ReadOnlyBooleanProperty emptyProperty() { return empty.getReadOnlyProperty(); }

    private void setEmpty(boolean value) { empty.set(value); }

    /**
     * Returns a boolean representing whether the cell is considered to be empty
     * or not.
     * @return true if cell is empty, otherwise false
     */
    public final boolean isEmpty() { return empty.get(); }



    // --- selected
    private ReadOnlyBooleanWrapper selected = new ReadOnlyBooleanWrapper() {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_SELECTED, get());
        }

        @Override
        public Object getBean() {
            return Cell.this;
        }

        @Override
        public String getName() {
            return &quot;selected&quot;;
        }
    };

    /**
     * Indicates whether or not this cell has been selected. For example, a
     * ListView defines zero or more cells as being the &quot;selected&quot; cells.
     * @return the representation of whether this cell has been selected
     */
    public final ReadOnlyBooleanProperty selectedProperty() { return selected.getReadOnlyProperty(); }

    void setSelected(boolean value) { selected.set(value); }

    /**
     * Returns whether this cell is currently selected or not.
     * @return True if the cell is selected, false otherwise.
     */
    public final boolean isSelected() { return selected.get(); }



    // --- Editing
    private ReadOnlyBooleanWrapper editing;

    private void setEditing(boolean value) {
        editingPropertyImpl().set(value);
    }

    /**
     * Represents whether the cell is currently in its editing state or not.
     * @return true if this cell is currently in its editing state, otherwise
     * false
     */
    public final boolean isEditing() {
        return editing == null ? false : editing.get();
    }

    /**
     * Property representing whether this cell is currently in its editing state.
     * @return the representation of whether this cell is currently in its
     * editing state
     */
    public final ReadOnlyBooleanProperty editingProperty() {
        return editingPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper editingPropertyImpl() {
        if (editing == null) {
            editing = new ReadOnlyBooleanWrapper(this, &quot;editing&quot;);
        }
        return editing;
    }



    // --- Editable
    private BooleanProperty editable;

    /**
     * Allows for certain cells to not be able to be edited. This is useful in
     * cases where, say, a List has 'header rows' - it does not make sense for
     * the header rows to be editable, so they should have editable set to
     * false.
     *
     * @param value A boolean representing whether the cell is editable or not.
     *      If true, the cell is editable, and if it is false, the cell can not
     *      be edited.
     */
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }

    /**
     * Returns whether this cell is allowed to be put into an editing state.
     * @return true if this cell is allowed to be put into an editing state,
     * otherwise false
     */
    public final boolean isEditable() {
        return editable == null ? true : editable.get();
    }

    /**
     * A property representing whether this cell is allowed to be put into an
     * editing state. By default editable is set to true in Cells (although for
     * a subclass of Cell to be allowed to enter its editing state, it may have
     * to satisfy additional criteria. For example, ListCell requires that the
     * ListView {@link ListView#editableProperty() editable} property is also
     * true.
     * @return the representation of whether this cell is allowed to be put into
     * an editing state
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true);
        }
        return editable;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Call this function to transition from a non-editing state into an editing
     * state, if the cell is editable. If this cell is already in an editing
     * state, it will stay in it.
     */
    public void startEdit() {
        if (isEditable() &amp;&amp; !isEditing() &amp;&amp; !isEmpty()) {
            setEditing(true);
        }
    }

    /**
     * Call this function to transition from an editing state into a non-editing
     * state, without saving any user input.
     */
    public void cancelEdit() {
        if (isEditing()) {
            setEditing(false);
        }
    }

    /**
     * Call this function when appropriate (based on the user interaction requirements
     * of your cell editing user interface) to do two things:
     *
     * &lt;ol&gt;
     *     &lt;li&gt;Fire the appropriate events back to the backing UI control (e.g.
     *     {@link ListView}). This will begin the process of pushing this edit
     *     back to the relevant data source / property (although it does not
     *     guarantee that this will be successful - that is dependent upon the
     *     specific edit commit handler being used). Refer to the UI control
     *     class javadoc for more detail.&lt;/li&gt;
     *     &lt;li&gt;Begin the transition from an editing state into a non-editing state.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;In general there is no need to override this method in custom cell
     * implementations - it should be sufficient to simply call this method
     * when appropriate (e.g. when the user pressed the Enter key, you may do something
     * like {@code cell.commitEdit(converter.fromString(textField.getText()));}&lt;/p&gt;
     *
     * @param newValue The value as input by the end user, which should be
     *      persisted in the relevant way given the data source underpinning the
     *      user interface and the install edit commit handler of the UI control.
     */
    public void commitEdit(T newValue) {
        if (isEditing()) {
            setEditing(false);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (itemDirty) {
            updateItem(getItem(), isEmpty());
            itemDirty = false;
        }
        super.layoutChildren();
    }



    /***************************************************************************
     *                                                                         *
     * Expert API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The updateItem method should not be called by developers, but it is the
     * best method for developers to override to allow for them to customise the
     * visuals of the cell. To clarify, developers should never call this method
     * in their code (they should leave it up to the UI control, such as the
     * {@link javafx.scene.control.ListView} control) to call this method. However,
     * the purpose of having the updateItem method is so that developers, when
     * specifying custom cell factories (again, like the ListView
     * {@link javafx.scene.control.ListView#cellFactoryProperty() cell factory}),
     * the updateItem method can be overridden to allow for complete customisation
     * of the cell.
     *
     * &lt;p&gt;It is &lt;strong&gt;very important&lt;/strong&gt; that subclasses
     * of Cell override the updateItem method properly, as failure to do so will
     * lead to issues such as blank cells or cells with unexpected content
     * appearing within them. Here is an example of how to properly override the
     * updateItem method:
     *
     * &lt;pre&gt;
     * protected void updateItem(T item, boolean empty) {
     *     super.updateItem(item, empty);
     *
     *     if (empty || item == null) {
     *         setText(null);
     *         setGraphic(null);
     *     } else {
     *         setText(item.toString());
     *     }
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note in this code sample two important points:
     * &lt;ol&gt;
     *     &lt;li&gt;We call the super.updateItem(T, boolean) method. If this is not
     *     done, the item and empty properties are not correctly set, and you are
     *     likely to end up with graphical issues.&lt;/li&gt;
     *     &lt;li&gt;We test for the &lt;code&gt;empty&lt;/code&gt; condition, and if true, we
     *     set the text and graphic properties to null. If we do not do this,
     *     it is almost guaranteed that end users will see graphical artifacts
     *     in cells unexpectedly.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param item The new item for the cell.
     * @param empty whether or not this cell represents data from the list. If it
     *        is empty, then it does not represent any domain data, but is a cell
     *        being used to render an &quot;empty&quot; row.
     */
    protected void updateItem(T item, boolean empty) {
        setItem(item);
        setEmpty(empty);
        if (empty &amp;&amp; isSelected()) {
            updateSelected(false);
        }
    }

    /**
     * Updates whether this cell is in a selected state or not.
     * @param selected whether or not to select this cell.
     */
    public void updateSelected(boolean selected) {
        if (selected &amp;&amp; isEmpty()) return;
        boolean wasSelected = isSelected();
        setSelected(selected);

        if (wasSelected != selected) {
            markCellDirty();
        }
    }

    /**
     * This method is called by Cell subclasses so that certain CPU-intensive
     * actions (specifically, calling {@link #updateItem(Object, boolean)}) are
     * only performed when necessary (that is, they are only performed
     * when the currently set {@link #itemProperty() item} is considered to be
     * different than the proposed new item that could be set).
     *
     * &lt;p&gt;The default implementation of this method tests against equality, but
     * developers are able to override this method to perform checks in other ways
     * that are specific to their domain.&lt;/p&gt;
     *
     * @param oldItem The currently-set item contained within the cell (i.e. it is
     *                the same as what is available via {@link #getItem()}).
     * @param newItem The item that will be set in the cell, if this method
     *                returns true. If this method returns false, it may not be
     *                set.
     * @return Returns true if the new item is considered to be different than
     *         the old item. By default this method tests against equality, but
     *         subclasses may alter the implementation to test appropriate to
     *         their needs.
     * @since JavaFX 8u40
     */
    protected boolean isItemChanged(T oldItem, T newItem) {
        return oldItem != null ? !oldItem.equals(newItem) : newItem != null;
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    // itemDirty and markCellDirty introduced as a solution for JDK-8145588.
    // In the fullness of time, a more fully developed solution can be developed
    // that offers a public API around this lazy-dirty impl.
    private boolean itemDirty = false;
    private final void markCellDirty() {
        itemDirty = true;
        requestLayout();
    }


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;cell&quot;;
    private static final PseudoClass PSEUDO_CLASS_SELECTED =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass PSEUDO_CLASS_FOCUSED =
            PseudoClass.getPseudoClass(&quot;focused&quot;);
    private static final PseudoClass PSEUDO_CLASS_EMPTY =
            PseudoClass.getPseudoClass(&quot;empty&quot;);
    private static final PseudoClass PSEUDO_CLASS_FILLED =
            PseudoClass.getPseudoClass(&quot;filled&quot;);

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * is overridden as by default UI controls have focus traversable set to true,
     * but that is not appropriate for this control.
     *
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/SingleSelectionModel.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

/**
 * A SelectionModel which enforces the requirement that only a single index
 * be selected at any given time. This class exists for controls that allow for
 * pluggable selection models, but which do not allow for multiple selection.
 * A good example is the {@link ChoiceBox} control. Conversely, most other
 * controls ({@link ListView}, {@link TreeView}, {@link TableView}, etc)
 * require {@link MultipleSelectionModel} implementations (although
 * MultipleSelectionModel does still allow for single selection to be set via the
 * {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property).
 *
 * @see SelectionModel
 * @see MultipleSelectionModel
 * @see SelectionMode
 * @param &lt;T&gt; The type of the item contained in the control that can be selected.
 * @since JavaFX 2.0
 */
public abstract class SingleSelectionModel&lt;T&gt; extends SelectionModel&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default SingleSelectionModel instance.
     */
    public SingleSelectionModel() { }



    /***************************************************************************
     *                                                                         *
     * Selection API                                                           *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void clearSelection() {
        updateSelectedIndex(-1);
    }

    /**
     * Clears the selection of the given index, if it is currently selected.
     */
    @Override public void clearSelection(int index) {
        if (getSelectedIndex() == index) {
            clearSelection();
        }
    }

    /** {@inheritDoc} */
    @Override public boolean isEmpty() {
        return getItemCount() == 0 || getSelectedIndex() == -1;
    }

    /**
     * &lt;p&gt;This method will return true if the given index is the currently
     * selected index in this SingleSelectionModel.
     *
     * @param index The index to check as to whether it is currently selected
     *      or not.
     * @return True if the given index is selected, false otherwise.
     */
    @Override public boolean isSelected(int index) {
        return getSelectedIndex() == index;
    }

    /**
     * In the SingleSelectionModel, this method is functionally equivalent to
     * calling &lt;code&gt;select(index)&lt;/code&gt;, as only one selection is allowed at
     * a time.
     */
    @Override public void clearAndSelect(int index) {
        select(index);
    }

    /**
     * Selects the index for the first instance of given object in the underlying
     * data model. Since the SingleSelectionModel can
     * only support having a single index selected at a time, this also causes
     * any previously selected index to be unselected.
     */
    @Override public void select(T obj) {
        if (obj == null) {
            setSelectedIndex(-1);
            setSelectedItem(null);
            return;
        }

        final int itemCount = getItemCount();

        for (int i = 0; i &lt; itemCount; i++) {
            final T value = getModelItem(i);
            if (value != null &amp;&amp; value.equals(obj)) {
                select(i);
                return;
            }
        }

        // if we are here, we did not find the item in the entire data model.
        // Even still, we allow for this item to be set to the give object.
        // We expect that in concrete subclasses of this class we observe the
        // data model such that we check to see if the given item exists in it,
        // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
        setSelectedItem(obj);
    }

    /**
     * Selects the given index. Since the SingleSelectionModel can only support having
     * a single index selected at a time, this also causes any previously selected
     * index to be unselected.
     */
    @Override public void select(int index) {
        if (index == -1) {
            clearSelection();
            return;
        }
        final int itemCount = getItemCount();
        if (itemCount == 0 || index &lt; 0 || index &gt;= itemCount) return;
        updateSelectedIndex(index);
    }

    /**
     * Selects the previous index. Since the SingleSelectionModel can only support having
     * a single index selected at a time, this also causes any previously selected
     * index to be unselected.
     */
    @Override public void selectPrevious() {
        if (getSelectedIndex() == 0) return;
        select(getSelectedIndex() - 1);
    }

    /**
     * Selects the next index. Since the SingleSelectionModel can only support having
     * a single index selected at a time, this also causes any previously selected
     * index to be unselected.
     */
    @Override public void selectNext() {
        select(getSelectedIndex() + 1);
    }

    /**
     * Selects the first index. Since the SingleSelectionModel can only support having
     * a single index selected at a time, this also causes any previously selected
     * index to be unselected.
     */
    @Override public void selectFirst() {
        if (getItemCount() &gt; 0) {
            select(0);
        }
    }

    /**
     * Selects the last index. Since the SingleSelectionModel can only support having
     * a single index selected at a time, this also causes any previously selected
     * index to be unselected.
     */
    @Override public void selectLast() {
        int numItems = getItemCount();
        if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
            select(numItems - 1);
        }
    }

    /**
     * Gets the data model item associated with a specific index.
     * @param index The position of the item in the underlying data model.
     * @return The item that exists at the given index.
     */
    protected abstract T getModelItem(int index);

    /**
     * Gets the number of items available for the selection model. If the number
     * of items can change dynamically, it is the responsibility of the
     * concrete SingleSelectionModel implementation to ensure that items are
     * selected or unselected as appropriate as the items change.
     * @return A number greater than or equal to 0.
     */
    protected abstract int getItemCount();

    // Private Implementation
    private void updateSelectedIndex(int newIndex) {
        int currentIndex = getSelectedIndex();
        T currentItem = getSelectedItem();
<A NAME="12"></A>
        setSelectedIndex(newIndex);

        <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#12',2,'match56-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (currentIndex == -1 &amp;&amp; currentItem != null &amp;&amp; newIndex == -1) {
            // no-op: the current selection isn't in the underlying data model -
            // we should keep the selected item as the new index is -1
        } else {
            // we don't use newIndex here, to prevent RT-32139 (which has a unit
            // test developed to prevent regressions in the future)
            setSelectedItem(getModelItem(getSelectedIndex()));
        }
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextArea.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import javafx.beans.InvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WritableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.StyleConverter;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableIntegerProperty;
import javafx.css.StyleableProperty;

import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.collections.ListListenerHelper;
import com.sun.javafx.collections.NonIterableChange;
import javafx.css.converter.SizeConverter;
import javafx.scene.control.skin.TextAreaSkin;

import javafx.css.Styleable;
import javafx.scene.AccessibleRole;

/**
 * Text input component that allows a user to enter multiple lines of
 * plain text. Unlike in previous releases of JavaFX, support for single line
 * input is not available as part of the TextArea control, however this is
 * the sole-purpose of the {@link TextField} control. Additionally, if you want
 * a form of rich-text editing, there is also the
 * {@link javafx.scene.web.HTMLEditor HTMLEditor} control.
 *
 * &lt;p&gt;TextArea supports the notion of showing {@link #promptTextProperty() prompt text}
 * to the user when there is no {@link #textProperty() text} already in the
 * TextArea (either via the user, or set programmatically). This is a useful
 * way of informing the user as to what is expected in the text area, without
 * having to resort to {@link Tooltip tooltips} or on-screen {@link Label labels}.
 *
 * @see TextField
 * @since JavaFX 2.0
 */
public class TextArea extends TextInputControl {
    // Text area content model
    private static final class TextAreaContent implements Content {
        private ExpressionHelper&lt;String&gt; helper = null;
        private ArrayList&lt;StringBuilder&gt; paragraphs = new ArrayList&lt;StringBuilder&gt;();
        private int contentLength = 0;
        private ParagraphList paragraphList = new ParagraphList();
        private ListListenerHelper&lt;CharSequence&gt; listenerHelper;

        private TextAreaContent() {
            paragraphs.add(new StringBuilder(DEFAULT_PARAGRAPH_CAPACITY));
            paragraphList.content = this;
        }

        @Override public String get(int start, int end) {
            int length = end - start;
            StringBuilder textBuilder = new StringBuilder(length);

            int paragraphCount = paragraphs.size();

            int paragraphIndex = 0;
            int offset = start;

            while (paragraphIndex &lt; paragraphCount) {
                StringBuilder paragraph = paragraphs.get(paragraphIndex);
                int count = paragraph.length() + 1;

                if (offset &lt; count) {
                    break;
                }

                offset -= count;
                paragraphIndex++;
            }

            // Read characters until end is reached, appending to text builder
            // and moving to next paragraph as needed
            StringBuilder paragraph = paragraphs.get(paragraphIndex);

            int i = 0;
            while (i &lt; length) {
                if (offset == paragraph.length()
                    &amp;&amp; i &lt; contentLength) {
                    textBuilder.append('\n');
                    paragraph = paragraphs.get(++paragraphIndex);
                    offset = 0;
                } else {
                    textBuilder.append(paragraph.charAt(offset++));
                }

                i++;
            }

            return textBuilder.toString();
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void insert(int index, String text, boolean notifyListeners) {
            if (index &lt; 0
                || index &gt; contentLength) {
                throw new IndexOutOfBoundsException();
            }

            if (text == null) {
                throw new IllegalArgumentException();
            }
            text = TextInputControl.filterInput(text, false, false);
            int length = text.length();
            if (length &gt; 0) {
                // Split the text into lines
                ArrayList&lt;StringBuilder&gt; lines = new ArrayList&lt;StringBuilder&gt;();

                StringBuilder line = new StringBuilder(DEFAULT_PARAGRAPH_CAPACITY);
                for (int i = 0; i &lt; length; i++) {
                    char c = text.charAt(i);

                    if (c == '\n') {
                        lines.add(line);
                        line = new StringBuilder(DEFAULT_PARAGRAPH_CAPACITY);
                    } else {
                        line.append(c);
                    }
                }

                lines.add(line);

                // Merge the text into the existing content
                // Merge the text into the existing content
                int paragraphIndex = paragraphs.size();
                int offset = contentLength + 1;

                StringBuilder paragraph = null;

                do {
                    paragraph = paragraphs.get(--paragraphIndex);
                    offset -= paragraph.length() + 1;
                } while (index &lt; offset);

                int start = index - offset;

                int n = lines.size();
                if (n == 1) {
                    // The text contains only a single line; insert it into the
                    // intersecting paragraph
                    paragraph.insert(start, line);
                    fireParagraphListChangeEvent(paragraphIndex, paragraphIndex + 1,
                        Collections.singletonList((CharSequence)paragraph));
                } else {
                    // The text contains multiple line; split the intersecting
                    // paragraph
                    int end = paragraph.length();
                    CharSequence trailingText = paragraph.subSequence(start, end);
                    paragraph.delete(start, end);

                    // Append the first line to the intersecting paragraph and
                    // append the trailing text to the last line
                    StringBuilder first = lines.get(0);
                    paragraph.insert(start, first);
                    line.append(trailingText);
                    fireParagraphListChangeEvent(paragraphIndex, paragraphIndex + 1,
                        Collections.singletonList((CharSequence)paragraph));

                    // Insert the remaining lines into the paragraph list
                    paragraphs.addAll(paragraphIndex + 1, lines.subList(1, n));
                    fireParagraphListChangeEvent(paragraphIndex + 1, paragraphIndex + n,
                        Collections.EMPTY_LIST);
                }

                // Update content length
                contentLength += length;
                if (notifyListeners) {
                    ExpressionHelper.fireValueChangedEvent(helper);
                }
            }
        }

        @Override public void delete(int start, int end, boolean notifyListeners) {
            if (start &gt; end) {
                throw new IllegalArgumentException();
            }

            if (start &lt; 0
                || end &gt; contentLength) {
                throw new IndexOutOfBoundsException();
            }

            int length = end - start;

            if (length &gt; 0) {
                // Identify the trailing paragraph index
                int paragraphIndex = paragraphs.size();
                int offset = contentLength + 1;

                StringBuilder paragraph = null;

                do {
                    paragraph = paragraphs.get(--paragraphIndex);
                    offset -= paragraph.length() + 1;
                } while (end &lt; offset);

                int trailingParagraphIndex = paragraphIndex;
                int trailingOffset = offset;
                StringBuilder trailingParagraph = paragraph;

                // Identify the leading paragraph index
                paragraphIndex++;
                offset += paragraph.length() + 1;

                do {
                    paragraph = paragraphs.get(--paragraphIndex);
                    offset -= paragraph.length() + 1;
                } while (start &lt; offset);

                int leadingParagraphIndex = paragraphIndex;
                int leadingOffset = offset;
                StringBuilder leadingParagraph = paragraph;

                // Remove the text
                if (leadingParagraphIndex == trailingParagraphIndex) {
                    // The removal affects only a single paragraph
                    leadingParagraph.delete(start - leadingOffset,
                        end - leadingOffset);

                    fireParagraphListChangeEvent(leadingParagraphIndex, leadingParagraphIndex + 1,
                        Collections.singletonList((CharSequence)leadingParagraph));
                } else {
                    // The removal spans paragraphs; remove any intervening paragraphs and
                    // merge the leading and trailing segments
                    CharSequence leadingSegment = leadingParagraph.subSequence(0,
                        start - leadingOffset);
                    int trailingSegmentLength = (start + length) - trailingOffset;

                    trailingParagraph.delete(0, trailingSegmentLength);
                    fireParagraphListChangeEvent(trailingParagraphIndex, trailingParagraphIndex + 1,
                        Collections.singletonList((CharSequence)trailingParagraph));

                    if (trailingParagraphIndex - leadingParagraphIndex &gt; 0) {
                        List&lt;CharSequence&gt; removed = new ArrayList&lt;CharSequence&gt;(paragraphs.subList(leadingParagraphIndex,
                            trailingParagraphIndex));
                        paragraphs.subList(leadingParagraphIndex,
                            trailingParagraphIndex).clear();
                        fireParagraphListChangeEvent(leadingParagraphIndex, leadingParagraphIndex,
                            removed);
                    }

                    // Trailing paragraph is now at the former leading paragraph's index
                    trailingParagraph.insert(0, leadingSegment);
                    fireParagraphListChangeEvent(leadingParagraphIndex, leadingParagraphIndex + 1,
                        Collections.singletonList((CharSequence)leadingParagraph));
                }

                // Update content length
                contentLength -= length;
                if (notifyListeners) {
                    ExpressionHelper.fireValueChangedEvent(helper);
                }
            }
        }

        @Override public int length() {
            return contentLength;
        }

        @Override public String get() {
<A NAME="3"></A>            return get(0, length());
        }

        @Override public void addListener(ChangeListener&lt;? super String&gt; changeListener) <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#3',2,'match56-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            helper = ExpressionHelper.addListener(helper, this, changeListener);
        }

        @Override public void removeListener(ChangeListener&lt;? super String&gt; changeListener) {
            helper = ExpressionHelper.removeListener</B></FONT>(helper, changeListener);
        }

        @Override public String getValue() {
            return get();
        }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        private void fireParagraphListChangeEvent(int from, int to, List&lt;CharSequence&gt; removed) {
            ParagraphListChange change = new ParagraphListChange(paragraphList, from, to, removed);
            ListListenerHelper.fireValueChangedEvent(listenerHelper, change);
        }
    }

    // Observable list of paragraphs
    private static final class ParagraphList extends AbstractList&lt;CharSequence&gt;
            implements ObservableList&lt;CharSequence&gt; {

        private TextAreaContent content;

        @Override
        public CharSequence get(int index) {
            return content.paragraphs.get(index);
        }

        @Override
        public boolean addAll(Collection&lt;? extends CharSequence&gt; paragraphs) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean addAll(CharSequence... paragraphs) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(Collection&lt;? extends CharSequence&gt; paragraphs) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(CharSequence... paragraphs) {
            throw new UnsupportedOperationException();
        }

        @Override
        public int size() {
            return content.paragraphs.size();
        }

        @Override
        public void addListener(ListChangeListener&lt;? super CharSequence&gt; listener) {
            content.listenerHelper = ListListenerHelper.addListener(content.listenerHelper, listener);
        }

        @Override
        public void removeListener(ListChangeListener&lt;? super CharSequence&gt; listener) {
            content.listenerHelper = ListListenerHelper.removeListener(content.listenerHelper, listener);
        }

        @Override
        public boolean removeAll(CharSequence... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean retainAll(CharSequence... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void remove(int from, int to) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void addListener(InvalidationListener listener) {
            content.listenerHelper = ListListenerHelper.addListener(content.listenerHelper, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            content.listenerHelper = ListListenerHelper.removeListener(content.listenerHelper, listener);
        }
    }

    private static final class ParagraphListChange extends NonIterableChange&lt;CharSequence&gt;  {

        private List&lt;CharSequence&gt; removed;

        protected ParagraphListChange(ObservableList&lt;CharSequence&gt; list, int from, int to,
            List&lt;CharSequence&gt; removed) {
            super(from, to, list);

            this.removed = removed;
        }

        @Override
        public List&lt;CharSequence&gt; getRemoved() {
            return removed;
        }

        @Override
        protected int[] getPermutation() {
            return new int[0];
        }
    };

    /**
     * The default value for {@link #prefColumnCountProperty() prefColumnCount}.
     */
    public static final int DEFAULT_PREF_COLUMN_COUNT = 40;

    /**
     * The default value for {@link #prefRowCountProperty() prefRowCount}.
     */
    public static final int DEFAULT_PREF_ROW_COUNT = 10;

    private static final int DEFAULT_PARAGRAPH_CAPACITY = 32;

    /**
     * Creates a {@code TextArea} with empty text content.
     */
    public TextArea() {
        this(&quot;&quot;);
    }

    /**
     * Creates a {@code TextArea} with initial text content.
     *
     * @param text A string for text content.
     */
    public TextArea(String text) {
        super(new TextAreaContent());

        getStyleClass().add(&quot;text-area&quot;);
        setAccessibleRole(AccessibleRole.TEXT_AREA);
        setText(text);
    }

    @Override final void textUpdated() {
        setScrollTop(0);
        setScrollLeft(0);
    }

    /**
     * Returns an unmodifiable list of the character sequences that back the
     * text area's content.
     * @return an unmodifiable list of the character sequences that back the
     * text area's content
     */
    public ObservableList&lt;CharSequence&gt; getParagraphs() {
        return ((TextAreaContent)getContent()).paragraphList;
    }


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * If a run of text exceeds the width of the {@code TextArea},
     * then this variable indicates whether the text should wrap onto
     * another line.
     */
    private BooleanProperty wrapText = new StyleableBooleanProperty(false) {
        @Override public Object getBean() {
            return TextArea.this;
        }

        @Override public String getName() {
            return &quot;wrapText&quot;;
        }

        @Override public CssMetaData&lt;TextArea,Boolean&gt; getCssMetaData() {
            return StyleableProperties.WRAP_TEXT;
        }
    };
    public final BooleanProperty wrapTextProperty() { return wrapText; }
    public final boolean isWrapText() { return wrapText.getValue(); }
    public final void setWrapText(boolean value) { wrapText.setValue(value); }


    /**
     * The preferred number of text columns. This is used for
     * calculating the {@code TextArea}'s preferred width.
     */
    private IntegerProperty prefColumnCount = new StyleableIntegerProperty(DEFAULT_PREF_COLUMN_COUNT) {

        private int oldValue = get();

        @Override
        protected void invalidated() {
            int value = get();
            if (value &lt; 0) {
                if (isBound()) {
                    unbind();
                }
                set(oldValue);
                throw new IllegalArgumentException(&quot;value cannot be negative.&quot;);
            }
            oldValue = value;
        }

        @Override public CssMetaData&lt;TextArea,Number&gt; getCssMetaData() {
            return StyleableProperties.PREF_COLUMN_COUNT;
        }

        @Override
        public Object getBean() {
            return TextArea.this;
        }

        @Override
        public String getName() {
            return &quot;prefColumnCount&quot;;
        }
    };
    public final IntegerProperty prefColumnCountProperty() { return prefColumnCount; }
    public final int getPrefColumnCount() { return prefColumnCount.getValue(); }
    public final void setPrefColumnCount(int value) { prefColumnCount.setValue(value); }


    /**
     * The preferred number of text rows. This is used for calculating
     * the {@code TextArea}'s preferred height.
     */
    private IntegerProperty prefRowCount = new StyleableIntegerProperty(DEFAULT_PREF_ROW_COUNT) {

        private int oldValue = get();

        @Override
        protected void invalidated() {
            int value = get();
            if (value &lt; 0) {
                if (isBound()) {
                    unbind();
                }
                set(oldValue);
                throw new IllegalArgumentException(&quot;value cannot be negative.&quot;);
            }

            oldValue = value;
        }

        @Override public CssMetaData&lt;TextArea,Number&gt; getCssMetaData() {
            return StyleableProperties.PREF_ROW_COUNT;
        }

        @Override
        public Object getBean() {
            return TextArea.this;
        }

        @Override
        public String getName() {
            return &quot;prefRowCount&quot;;
        }
    };
    public final IntegerProperty prefRowCountProperty() { return prefRowCount; }
    public final int getPrefRowCount() { return prefRowCount.getValue(); }
    public final void setPrefRowCount(int value) { prefRowCount.setValue(value); }


    /**
     * The number of pixels by which the content is vertically
     * scrolled.
     */
    private DoubleProperty scrollTop = new SimpleDoubleProperty(this, &quot;scrollTop&quot;, 0);
    public final DoubleProperty scrollTopProperty() { return scrollTop; }
    public final double getScrollTop() { return scrollTop.getValue(); }
    public final void setScrollTop(double value) { scrollTop.setValue(value); }


    /**
     * The number of pixels by which the content is horizontally
     * scrolled.
     */
    private DoubleProperty scrollLeft = new SimpleDoubleProperty(this, &quot;scrollLeft&quot;, 0);
    public final DoubleProperty scrollLeftProperty() { return scrollLeft; }
    public final double getScrollLeft() { return scrollLeft.getValue(); }
    public final void setScrollLeft(double value) { scrollLeft.setValue(value); }


    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TextAreaSkin(this);
    }


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static class StyleableProperties {
        private static final CssMetaData&lt;TextArea,Number&gt; PREF_COLUMN_COUNT =
            new CssMetaData&lt;TextArea,Number&gt;(&quot;-fx-pref-column-count&quot;,
                SizeConverter.getInstance(), DEFAULT_PREF_COLUMN_COUNT) {

            @Override
            public boolean isSettable(TextArea n) {
                return !n.prefColumnCount.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TextArea n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.prefColumnCountProperty();
            }
        };

        private static final CssMetaData&lt;TextArea,Number&gt; PREF_ROW_COUNT =
            new CssMetaData&lt;TextArea,Number&gt;(&quot;-fx-pref-row-count&quot;,
                SizeConverter.getInstance(), DEFAULT_PREF_ROW_COUNT) {

            @Override
            public boolean isSettable(TextArea n) {
                return !n.prefRowCount.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TextArea n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.prefRowCountProperty();
            }
        };

        private static final CssMetaData&lt;TextArea,Boolean&gt; WRAP_TEXT =
            new CssMetaData&lt;TextArea,Boolean&gt;(&quot;-fx-wrap-text&quot;,
                StyleConverter.getBooleanConverter(), false) {

            @Override
            public boolean isSettable(TextArea n) {
                return !n.wrapText.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(TextArea n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.wrapTextProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(TextInputControl.getClassCssMetaData());
            styleables.add(PREF_COLUMN_COUNT);
            styleables.add(PREF_ROW_COUNT);
            styleables.add(WRAP_TEXT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextInputControl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.text.Font;

import java.text.BreakIterator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.util.Utils;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.scene.NodeHelper;
import javafx.util.StringConverter;

/**
 * Abstract base class for text input controls.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public abstract class TextInputControl extends Control {
    /**
     * Interface representing a text input's content. Since it is an ObservableStringValue,
     * you can also bind to, or observe the content.
     * @since JavaFX 2.0
     */
    protected interface Content extends ObservableStringValue {
        /**
         * Retrieves a subset of the content.
         *
         * @param start the start
         * @param end the end
         * @return a subset of the content
         */
        public String get(int start, int end);

        /**
         * Inserts a sequence of characters into the content.
         *
         * @param index the index
         * @param text the text string
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void insert(int index, String text, boolean notifyListeners);

        /**
         * Removes a sequence of characters from the content.
         *
         * @param start the start
         * @param end the end
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void delete(int start, int end, boolean notifyListeners);

        /**
         * Returns the number of characters represented by the content.
         * @return the number of characters
         */
        public int length();
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TextInputControl. The content is an immutable property and
     * must be specified (as non-null) at the time of construction.
     *
     * @param content a non-null implementation of Content.
     */
    protected TextInputControl(final Content content) {
        this.content = content;

        // Add a listener so that whenever the Content is changed, we notify
        // listeners of the text property that it is invalid.
        content.addListener(observable -&gt; {
            if (content.length() &gt; 0) {
                text.textIsNull = false;
            }
            text.controlContentHasChanged();
        });

        // Bind the length to be based on the length of the text property
        length.bind(new IntegerBinding() {
            { bind(text); }
            @Override protected int computeValue() {
                String txt = text.get();
                return txt == null ? 0 : txt.length();
            }
        });

        // Bind the selected text to be based on the selection and text properties
        selectedText.bind(new StringBinding() {
            { bind(selection, text); }
            @Override protected String computeValue() {
                String txt = text.get();
                IndexRange sel = selection.get();
                if (txt == null || sel == null) return &quot;&quot;;

                int start = sel.getStart();
                int end = sel.getEnd();
                int length = txt.length();
                if (end &gt; start + length) end = length;
                if (start &gt; length-1) start = end = 0;
                return txt.substring(start, end);
            }
        });

        focusedProperty().addListener((ob, o, n) -&gt; {
            if (n) {
                if (getTextFormatter() != null) {
                    updateText(getTextFormatter());
                }
            } else {
                commitValue();
            }
        });

        // Specify the default style class
        getStyleClass().add(&quot;text-input&quot;);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The default font to use for text in the TextInputControl. If the TextInputControl's text is
     * rich text then this font may or may not be used depending on the font
     * information embedded in the rich text, but in any case where a default
     * font is required, this font will be used.
     * @return the font property
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Font&gt; fontProperty() {
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {


                private boolean fontSetByCss = false;

                @Override
                public void applyStyle(StyleOrigin newOrigin, Font value) {

                    //
                    // RT-20727 - if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS
                    //
                    try {
                        // super.applyStyle calls set which might throw if value is bound.
                        // Have to make sure fontSetByCss is reset.
                        fontSetByCss = true;
                        super.applyStyle(newOrigin, value);
                    } catch(Exception e) {
                        throw e;
                    } finally {
                        fontSetByCss = false;
                    }

                }


                @Override
                public void set(Font value) {
                    final Font oldValue = get();
                    if (value == null ? oldValue == null : value.equals(oldValue)) {
                        return;
                    }
                    super.set(value);
                }

                @Override
                protected void invalidated() {
                    // RT-20727 - if font is changed by calling setFont, then
                    // css might need to be reapplied since font size affects
                    // calculated values for styles with relative values
                    if(fontSetByCss == false) {
                        NodeHelper.reapplyCSS(TextInputControl.this);
                    }
                }

                @Override
                public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }

                @Override
                public Object getBean() {
                    return TextInputControl.this;
                }

                @Override
                public String getName() {
                    return &quot;font&quot;;
                }
            };
        }
        return font;
    }

    private ObjectProperty&lt;Font&gt; font;
    public final void setFont(Font value) { fontProperty().setValue(value); }
    public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }

    /**
     * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
     * prompt text is displayed.
     *
     * @defaultValue An empty String
     * @since JavaFX 2.2
     */
    private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
        @Override protected void invalidated() {
            // Strip out newlines
            String txt = get();
            if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
                txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
                set(txt);
            }
        }
    };
    public final StringProperty promptTextProperty() { return promptText; }
    public final String getPromptText() { return promptText.get(); }
    public final void setPromptText(String value) { promptText.set(value); }


    /**
     * The property contains currently attached {@link TextFormatter}.
     * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
     *
     * @defaultValue null
     * @since JavaFX 8u40
     */
    private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {

        private TextFormatter&lt;?&gt; oldFormatter = null;

        @Override
        public Object getBean() {
            return TextInputControl.this;
        }

        @Override
        public String getName() {
            return &quot;textFormatter&quot;;
        }

        @Override
        protected void invalidated() {
            final TextFormatter&lt;?&gt; formatter = get();
            try {
                if (formatter != null) {
                    try {
                        formatter.bindToControl(f -&gt; updateText(f));
                    } catch (IllegalStateException e) {
                        if (isBound()) {
                            unbind();
                        }
                        set(null);
                        throw e;
                    }
                    if (!isFocused()) {
                        updateText(get());
                    }
                }

                if (oldFormatter != null) {
                    oldFormatter.unbindFromControl();
                }
            } finally {
                oldFormatter = formatter;
            }
        }
    };
    public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
    public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
    public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }

    private final Content content;
    /**
     * Returns the text input's content model.
     * @return the text input's content model
     */
    protected final Content getContent() {
        return content;
    }

    /**
     * The textual content of this TextInputControl.
     */
    private TextProperty text = new TextProperty();
    public final String getText() { return text.get(); }
    public final void setText(String value) { text.set(value); }
    public final StringProperty textProperty() { return text; }

    /**
     * The number of characters in the text input.
     */
    private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
    public final int getLength() { return length.get(); }
    public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }

    /**
     * Indicates whether this TextInputControl can be edited by the user.
     */
    private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
        }
    };
    public final boolean isEditable() { return editable.getValue(); }
    public final void setEditable(boolean value) { editable.setValue(value); }
    public final BooleanProperty editableProperty() { return editable; }

    /**
     * The current selection.
     */
    private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
    public final IndexRange getSelection() { return selection.getValue(); }
    public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }

    /**
     * Defines the characters in the TextInputControl which are selected
     */
    private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
    public final String getSelectedText() { return selectedText.get(); }
    public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }

    /**
     * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the anchor might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
    public final int getAnchor() { return anchor.get(); }
    public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }

    /**
     * The current position of the caret within the text.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the caretPosition might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
    public final int getCaretPosition() { return caretPosition.get(); }
    public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }

    private UndoRedoChange undoChangeHead = new UndoRedoChange();
    private UndoRedoChange undoChange = undoChangeHead;
    private boolean createNewUndoRecord = false;

    /**
     * The property describes if it's currently possible to undo the latest change of the content that was done.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
    public final boolean isUndoable() { return undoable.get(); }
    public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }


    /**
     * The property describes if it's currently possible to redo the latest change of the content that was undone.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
    public final boolean isRedoable() { return redoable.get(); }
    public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a subset of the text input's content.
     *
     * @param start must be a value between 0 and end - 1.
     * @param end must be less than or equal to the length
     * @return the subset of the text input's content
     */
    public String getText(int start, int end) {
        if (start &gt; end) {
            throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        return getContent().get(start, end);
    }

    /**
     * Appends a sequence of characters to the content.
     *
     * @param text a non null String
     */
    public void appendText(String text) {
        insertText(getLength(), text);
    }

    /**
     * Inserts a sequence of characters into the content.
     *
     * @param index The location to insert the text.
     * @param text The text to insert.
     */
    public void insertText(int index, String text) {
        replaceText(index, index, text);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param range The range of text to delete. The range object must not be null.
     *
     * @see #deleteText(int, int)
     */
    public void deleteText(IndexRange range) {
        replaceText(range, &quot;&quot;);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     */
    public void deleteText(int start, int end) {
        replaceText(start, end, &quot;&quot;);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param range The range of text to replace. The range object must not be null.
     * @param text The text that is to replace the range. This must not be null.
     *
     * @see #replaceText(int, int, String)
     */
    public void replaceText(IndexRange range, String text) {
        final int start = range.getStart();
        final int end = start + range.getLength();
        replaceText(start, end, text);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param text The text that is to replace the range. This must not be null.
     */
    public void replaceText(final int start, final int end, final String text) {
        if (start &gt; end) {
            throw new IllegalArgumentException();
        }

        if (text == null) {
            throw new NullPointerException();
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        if (!this.text.isBound()) {
            final int oldLength = getLength();
            TextFormatter&lt;?&gt; formatter = getTextFormatter();
            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
            if (formatter != null &amp;&amp; formatter.getFilter() != null) {
                change = formatter.getFilter().apply(change);
                if (change == null) {
                    return;
                }
            }

            // Update the content
            updateContent(change, oldLength == 0);

        }
    }

    private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
        final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
        String oldText = getText(change.start, change.end);
        int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
        if (newText.equals(oldText)) {
            // Undo record not required as there is no change in the text.
            return;
        }

        /*
         * A new undo record is created, if
         * 1. createNewUndoRecord is true, currently it is set to true for paste operation
         * 2. Text is selected and a character is typed
         * 3. This is the first operation to be added to undo record
         * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
         * 5. Space character is typed
         * 6. 2500 milliseconds are elapsed since the undo record was created
         * 7. Cursor position is changed and a character is typed
         * 8. A range of text is replaced programmatically using replaceText()
         * Otherwise, the last undo record is updated or discarded.
         */

        int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
        boolean isNewSpaceChar = false;
        if (newText.equals(&quot; &quot;)) {
            if (!UndoRedoChange.isSpaceCharSequence()) {
                isNewSpaceChar = true;
                UndoRedoChange.setSpaceCharSequence(true);
            }
        } else {
            UndoRedoChange.setSpaceCharSequence(false);
        }
        if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
                isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
                (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
            undoChange = undoChange.add(change.start, oldText, newText);
        } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
            // I know I am deleting, and am located at the end of the range of the current undo record
            if (undoChange.newText.length() &gt; 0) {
                undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
                if (undoChange.newText.isEmpty()) {
<A NAME="13"></A>                    // throw away this undo change record
                    undoChange = undoChange.discard();
                }
            } else <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#13',2,'match56-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                if (change.start == endOfUndoChange) {
                    undoChange.oldText += oldText;
                } else { // end == endOfUndoChange
                    undoChange.oldText = oldText + undoChange.oldText;
                    undoChange.start--;
                }
            }</B></FONT>
        } else {
            // I know I am adding, and am located at the end of the range of the current undo record
            undoChange.newText += newText;
        }
        updateUndoRedoState();
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * removing the current selection.
     */
    public void cut() {
        copy();
        IndexRange selection = getSelection();
        deleteText(selection.getStart(), selection.getEnd());
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * leaving the current selection.
     */
     public void copy() {
        final String selectedText = getSelectedText();
        if (selectedText.length() &gt; 0) {
            final ClipboardContent content = new ClipboardContent();
            content.putString(selectedText);
            Clipboard.getSystemClipboard().setContent(content);
        }
    }

    /**
     * Transfers the contents in the clipboard into this text,
     * replacing the current selection.  If there is no selection, the contents
     * in the clipboard is inserted at the current caret position.
     */
    public void paste() {
        final Clipboard clipboard = Clipboard.getSystemClipboard();
        if (clipboard.hasString()) {
            final String text = clipboard.getString();
            if (text != null) {
                createNewUndoRecord = true;
                try {
                    replaceSelection(text);
                } finally {
                    createNewUndoRecord = false;
                }
            }
        }
    }

    /**
     * Moves the selection backward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caretPosition.
     */
    public void selectBackward() {
        if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
            // because the anchor stays put, by moving the caret to the left
            // we ensure that a selection is registered and that it is correct
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
        }
    }

    /**
     * Moves the selection forward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caret forward.
     */
    public void selectForward() {
        final int textLength = getLength();
        if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.following(getCaretPosition()));
        }
    }

    /**
     * The break iterator instances for navigation over words and complex characters.
     */
    private BreakIterator charIterator;
    private BreakIterator wordIterator;

    /**
     * Moves the caret to the beginning of previous word. This function
     * also has the effect of clearing the selection.
     */
    public void previousWord() {
        previousWord(false);
    }

    /**
     * Moves the caret to the beginning of next word. This function
     * also has the effect of clearing the selection.
     */
    public void nextWord() {
        nextWord(false);
    }

    /**
     * Moves the caret to the end of the next word. This function
     * also has the effect of clearing the selection.
     */
    public void endOfNextWord() {
        endOfNextWord(false);
    }

    /**
     * Moves the caret to the beginning of previous word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of previous word.
     */
    public void selectPreviousWord() {
        previousWord(true);
    }

    /**
     * Moves the caret to the beginning of next word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of next word.
     */
    public void selectNextWord() {
        nextWord(true);
    }

    /**
     * Moves the caret to the end of the next word. This does not cause
     * the selection to be cleared.
     */
    public void selectEndOfNextWord() {
        endOfNextWord(true);
    }

    private void previousWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));

        // Skip the non-word region, then move/select to the beginning of the word.
        while (pos != BreakIterator.DONE &amp;&amp;
               !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
            pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
        }

        // move/select
        selectRange(select ? getAnchor() : pos, pos);
    }

    private void nextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
        int current = wordIterator.next();

        // Skip whitespace characters to the beginning of next word, but
        // stop at newline. Then move the caret or select a range.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                char ch = text.charAt(Utils.clamp(0, p, textLength-1));
                // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
                // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
                if (ch != ' ' &amp;&amp; ch != '\t') {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    private void endOfNextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
        int current = wordIterator.next();

        // skip the non-word region, then move/select to the end of the word.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    /**
     * Selects all text in the text input.
     */
    public void selectAll() {
        selectRange(0, getLength());
    }

    /**
     * Moves the caret to before the first char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void home() {
        // user wants to go to start
        selectRange(0, 0);
    }

    /**
     * Moves the caret to after the last char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void end() {
        // user wants to go to end
        final int textLength = getLength();
        if (textLength &gt; 0) {
            selectRange(textLength, textLength);
        }
    }

    /**
     * Moves the caret to before the first char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to before the first char.
     */
    public void selectHome() {
        selectRange(getAnchor(), 0);
    }

    /**
     * Moves the caret to after the last char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to after the last char.
     */
    public void selectEnd() {
        final int textLength = getLength();
        if (textLength &gt; 0) selectRange(getAnchor(), textLength);
    }

    /**
     * Deletes the character that precedes the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deletePreviousChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (dot &gt; 0) {
                // The caret is not at the beginning, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                // Note: Do not use charIterator here, because we do want to
                // break up clusters when deleting backwards.
                int p = Character.offsetByCodePoints(text, dot, -1);
                deleteText(p, dot);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Deletes the character that follows the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deleteNextChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final int textLength = getLength();
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
                // The caret is not at the end, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                if (charIterator == null) {
                    charIterator = BreakIterator.getCharacterInstance();
                }
                charIterator.setText(text);
                int p = charIterator.following(dot);
                deleteText(dot, p);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Moves the caret position forward. If there is no selection, then the
     * caret position is moved one character forward. If there is a selection,
     * then the caret position is moved to the end of the selection and
     * the selection cleared.
     */
    public void forward() {
        // user has moved caret to the right
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.max(dot, mark);
            selectRange(pos, pos);
        } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.following(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Moves the caret position backward. If there is no selection, then the
     * caret position is moved one character backward. If there is a selection,
     * then the caret position is moved to the beginning of the selection and
     * the selection cleared.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void backward() {
        // user has moved caret to the left
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.min(dot, mark);
            selectRange(pos, pos);
        } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.preceding(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Positions the caret to the position indicated by {@code pos}. This
     * function will also clear the selection.
     * @param pos the position
     */
    public void positionCaret(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        selectRange(p, p);
    }

    /**
     * Positions the caret to the position indicated by {@code pos} and extends
     * the selection, if there is one. If there is no selection, then a
     * selection is formed where the anchor is at the current caret position
     * and the caretPosition is moved to pos.
     * @param pos the position
     */
    public void selectPositionCaret(int pos) {
        selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
    }

    /**
     * Positions the anchor and caretPosition explicitly.
     * @param anchor the anchor
     * @param caretPosition the caretPosition
     */
    public void selectRange(int anchor, int caretPosition) {
        caretPosition = Utils.clamp(0, caretPosition, getLength());
        anchor = Utils.clamp(0, anchor, getLength());

        TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        if (formatter != null &amp;&amp; formatter.getFilter() != null) {
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return;
            }
        }

        updateContent(change, false);
    }

    private void doSelectRange(int anchor, int caretPosition) {
        this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
        this.anchor.set(Utils.clamp(0, anchor, getLength()));
        this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
        notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
    }

    /**
     * This function will extend the selection to include the specified pos.
     * This is different from selectPositionCaret in that it does not simply
     * move the caret. Rather, it will reposition the caret and anchor as necessary
     * to ensure that pos becomes the new caret and the far other end of the
     * selection becomes the anchor.
     * @param pos the position
     */
    public void extendSelection(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        int start = Math.min(dot, mark);
        int end = Math.max(dot, mark);
        if (p &lt; start) {
            selectRange(end, p);
        } else {
            selectRange(start, p);
        }
    }

    /**
     * Clears the text.
     */
    public void clear() {
        deselect();
        if (!text.isBound()) {
            setText(&quot;&quot;);
        }
    }

    /**
     * Clears the selection.
     */
    public void deselect() {
        // set the anchor equal to the caret position, which clears the selection
        // while also preserving the caret position
        selectRange(getCaretPosition(), getCaretPosition());
    }

    /**
     * Replaces the selection with the given replacement String. If there is
     * no selection, then the replacement text is simply inserted at the current
     * caret position. If there was a selection, then the selection is cleared
     * and the given replacement text inserted.
     * @param replacement the replacement string
     */
    public void replaceSelection(String replacement) {
        replaceText(getSelection(), replacement);
    }

    /**
     * If possible, undoes the last modification. If {@link #isUndoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void undo() {
        if (isUndoable()) {
            // Apply reverse change here
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (newText != null) {
                getContent().delete(start, start + newText.length(), oldText.isEmpty());
            }

            if (oldText != null) {
                getContent().insert(start, oldText, true);
                doSelectRange(start, start + oldText.length());
            } else {
                doSelectRange(start, start + newText.length());
            }

            undoChange = undoChange.prev;
        }
        updateUndoRedoState();
    }

    /**
     * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void redo() {
        if (isRedoable()) {
            // Apply change here
            undoChange = undoChange.next;
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (oldText != null) {
                getContent().delete(start, start + oldText.length(), newText.isEmpty());
            }

            if (newText != null) {
                getContent().insert(start, newText, true);
                doSelectRange(start + newText.length(), start + newText.length());
            } else {
                doSelectRange(start, start);
            }
        }
        updateUndoRedoState();
        // else beep ?
    }

    // Used by TextArea, although there are probably other better ways of
    // doing this.
    void textUpdated() { }

    private void resetUndoRedoState() {
        undoChange = undoChangeHead;
        undoChange.next = null;
        updateUndoRedoState();
    }

    private void updateUndoRedoState() {
        undoable.set(undoChange != undoChangeHead);
        redoable.set(undoChange.next != null);
    }

    private boolean filterAndSet(String value) {
        // Send the new value through the textFormatter, if one exists.
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        int length = content.length();
        if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
            TextFormatter.Change change = new TextFormatter.Change(
                    TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return false;
            }
            replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        } else {
            replaceText(0, length, value, 0, 0);
        }
        return true;
    }

    /**
     * This is what is ultimately called by every code path that will update
     * the content (except for undo / redo). The input into this method has
     * already run through the textFormatter where appropriate.
     *
     * @param start            The start index into the existing text which
     *                         will be replaced by the new value
     * @param end              The end index into the existing text which will
     *                         be replaced by the new value. As with
     *                         String.replace this is a lastIndex+1 value
     * @param value            The new text value
     * @param anchor           The new selection anchor after the change is made
     * @param caretPosition    The new selection caretPosition after the change
     *                         is made.
     * @return The amount of adjustment made to the end / anchor / caretPosition to
     *         accommodate for subsequent filtering (such as the filtering of
     *         new lines by the TextField)
     */
    private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
        // RT-16566: Need to take into account stripping of chars into the
        // final anchor &amp; caret position
        int length = getLength();
        int adjustmentAmount = 0;
        if (end != start) {
            getContent().delete(start, end, value.isEmpty());
            length -= (end - start);
        }
        if (value != null) {
            getContent().insert(start, value, true);
            adjustmentAmount = value.length() - (getLength() - length);
            anchor -= adjustmentAmount;
            caretPosition -= adjustmentAmount;
        }
        doSelectRange(anchor, caretPosition);
        return adjustmentAmount;
    }

    private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
        T value = formatter.getValue();
        StringConverter&lt;T&gt; converter = formatter.getValueConverter();
        if (converter != null) {
            String text = converter.toString(value);
            if (text == null) text = &quot;&quot;;
            replaceText(0, getLength(), text, text.length(), text.length());
        }
    }

    /**
     * Commit the current text and convert it to a value.
     * @since JavaFX 8u40
     */
    public final void commitValue() {
        if (getTextFormatter() != null) {
            getTextFormatter().updateValue(getText());
        }
    }

    /**
     * If the field is currently being edited, this call will set text to the last commited value.
     * @since JavaFX 8u40
     */
    public final void cancelEdit() {
        if (getTextFormatter() != null) {
            updateText(getTextFormatter());
        }
    }

    private FormatterAccessor accessor;

    private FormatterAccessor getFormatterAccessor() {
        if (accessor == null) {
            accessor = new TextInputControlFromatterAccessor();
        }
        return accessor;
    }


    /**
     * A little utility method for stripping out unwanted characters.
     *
     * @param txt
     * @param stripNewlines
     * @param stripTabs
     * @return The string after having the unwanted characters stripped out.
     */
    static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
        // Most of the time, when text is inserted, there are no illegal
        // characters. So we'll do a &quot;cheap&quot; check for illegal characters.
        // If we find one, we'll do a longer replace algorithm. In the
        // case of illegal characters, this may at worst be an O(2n) solution.
        // Strip out any characters that are outside the printed range
        if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
            StringBuilder s = new StringBuilder(txt.length());
            for (int i=0; i&lt;txt.length(); i++) {
                final char c = txt.charAt(i);
                if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
                    s.append(c);
                }
            }
            txt = s.toString();
        }
        return txt;
    }

    static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
        for (int i=0; i&lt;txt.length(); i++) {
            final char c = txt.charAt(i);
            if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
        }
        return false;
    }

    private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
        if (c == 0x7F) return true;
        if (c == 0xA) return newlineIllegal;
        if (c == 0x9) return tabIllegal;
        if (c &lt; 0x20) return true;
        return false;
    }

    // It can be bound, in which case we will force it to be an eager
    // binding so that we update the content eagerly
    // It can be bidirectionally bound, which basically will just work
    // If somebody changes the content directly, it will be notified and
    // send an invalidation event.
    private class TextProperty extends StringProperty {
        // This is used only when the property is bound
        private ObservableValue&lt;? extends String&gt; observable = null;
        // Added to the observable when bound
        private InvalidationListener listener = null;
        // Used for event handling
        private ExpressionHelper&lt;String&gt; helper = null;
        // The developer my set the Text property to null. Although
        // the Content must be given an empty String, we must still
        // treat the value as though it were null, so that a subsequent
        // getText() will return null.
        private boolean textIsNull = false;

        @Override public String get() {
            // Since we force eager binding and content is always up to date,
            // we just need to get it from content and not through the binding
            return textIsNull ? null : content.get();
        }

        @Override public void set(String value) {
            if (isBound()) {
                throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
            }
            doSet(value);
            markInvalid();
        }

        /**
         * Called whenever the content on the control has changed (as determined
         * by a listener on the content).
         */
        private void controlContentHasChanged() {
            markInvalid();
            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        }

        @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
            if (observable == null) {
                throw new NullPointerException(&quot;Cannot bind to null&quot;);
            }
            if (!observable.equals(this.observable)) {
                unbind();
                this.observable = observable;
                if (listener == null) {
                    listener = new Listener();
                }
                this.observable.addListener(listener);
                markInvalid();
                doSet(observable.getValue());
            }
        }

        @Override public void unbind() {
            if (observable != null) {
                doSet(observable.getValue());
                observable.removeListener(listener);
                observable = null;
            }
        }

        @Override public boolean isBound() {
            return observable != null;
        }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public Object getBean() {
            return TextInputControl.this;
        }

        @Override public String getName() {
            return &quot;text&quot;;
        }

        private void fireValueChangedEvent() {
            ExpressionHelper.fireValueChangedEvent(helper);
        }

        private void markInvalid() {
            fireValueChangedEvent();
        }

        /**
         * doSet is called whenever the setText() method was called directly
         * on the TextInputControl, or when the text property was bound,
         * unbound, or reacted to a binding invalidation. It is *not* called
         * when modifications to the content happened indirectly, such as
         * through the replaceText / replaceSelection methods.
         *
         * @param value The new value
         */
        private void doSet(String value) {
            // Guard against the null value.
            textIsNull = value == null;
            if (value == null) value = &quot;&quot;;

            if (!filterAndSet(value)) return;

            if (getTextFormatter() != null) {
                getTextFormatter().updateValue(getText());
            }

            textUpdated();

            // If the programmer has directly manipulated the text property
            // or has it bound up, then we will clear out any modifications
            // from the undo manager as we must suppose that the control is
            // being reused, for example, between forms.
            resetUndoRedoState();
        }

        private class Listener implements InvalidationListener {
            @Override
            public void invalidated(Observable valueModel) {
                // We now need to force it to be eagerly recomputed
                // because we need to push these changes to the
                // content model. Because changing the model ends
                // up calling invalidate and markInvalid, the
                // listeners will all be notified.
                doSet(observable.getValue());
            }
        }
    }

    /**
     * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
     * records the old and new text, and the start index. It also has
     * the links to the previous and next Changes in the chain. There
     * are two special UndoRedoChange objects in this chain representing the
     * head and the tail so we can have beforeFirst and afterLast
     * behavior as necessary.
     */
    static class UndoRedoChange {
        static long prevRecordTime;
        static final long CHANGE_DURATION = 2500; // milliseconds
        static boolean spaceCharSequence = false;
        int start;
        String oldText;
        String newText;
        UndoRedoChange prev;
        UndoRedoChange next;

        UndoRedoChange() { }

        public UndoRedoChange add(int start, String oldText, String newText) {
            UndoRedoChange c = new UndoRedoChange();
            c.start = start;
            c.oldText = oldText;
            c.newText = newText;
            c.prev = this;
            next = c;
            prevRecordTime = System.currentTimeMillis();
            return c;
        }

        static boolean hasChangeDurationElapsed() {
            return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
        }

        static void setSpaceCharSequence(boolean value) {
            spaceCharSequence = value;
        }
        static boolean isSpaceCharSequence() {
            return spaceCharSequence;
        }

        public UndoRedoChange discard() {
            prev.next = next;
            return prev;
        }

        // Handy to use when debugging, just put it in undo or redo
        // method or replaceText to see what is happening to the undo
        // history as it occurs.
        void debugPrint() {
            UndoRedoChange c = this;
            System.out.print(&quot;[&quot;);
            while (c != null) {
                System.out.print(c.toString());
                if (c.next != null) System.out.print(&quot;, &quot;);
                c = c.next;
            }
            System.out.println(&quot;]&quot;);
        }

        @Override public String toString() {
            if (oldText == null &amp;&amp; newText == null) {
                return &quot;head&quot;;
            }
            if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;added '&quot; + newText + &quot;' at index &quot; + start;
            } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;replaced '&quot; + oldText + &quot;' with '&quot; + newText + &quot;' at index &quot; + start;
            } else {
                return &quot;deleted '&quot; + oldText + &quot;' at index &quot; + start;
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/


    private static final PseudoClass PSEUDO_CLASS_READONLY
            = PseudoClass.getPseudoClass(&quot;readonly&quot;);

    private static class StyleableProperties {
        private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
            new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(TextInputControl n) {
                return n.font == null || !n.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
                return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FONT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                String text = getText();
                if (text == null || text.isEmpty()) {
                    text = getPromptText();
                }
                return text;
            }
            case EDITABLE: return isEditable();
            case SELECTION_START: return getSelection().getStart();
            case SELECTION_END: return getSelection().getEnd();
            case CARET_OFFSET: return getCaretPosition();
            case FONT: return getFont();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SET_TEXT: {
                String value = (String) parameters[0];
                if (value != null) setText(value);
                break;
            }
            case SET_TEXT_SELECTION: {
                Integer start = (Integer) parameters[0];
                Integer end = (Integer) parameters[1];
                if (start != null &amp;&amp; end != null) {
                    selectRange(start,  end);
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }

    private class TextInputControlFromatterAccessor implements FormatterAccessor {
        @Override
        public int getTextLength() {
            return TextInputControl.this.getLength();
        }

        @Override
        public String getText(int begin, int end) {
            return TextInputControl.this.getText(begin, end);
        }

        @Override
        public int getCaret() {
            return TextInputControl.this.getCaretPosition();
        }

        @Override
        public int getAnchor() {
            return TextInputControl.this.getAnchor();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/cell/DefaultTreeCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control.cell;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.scene.Node;
import javafx.scene.control.TreeCell;
import javafx.scene.control.TreeItem;
import javafx.scene.layout.HBox;

import java.lang.ref.WeakReference;

/*
 * Package-protected class used by cell implementations to handle graphics changes
 * to TreeItem.
 */
class DefaultTreeCell&lt;T&gt; extends TreeCell&lt;T&gt; {

    private HBox hbox;

    private WeakReference&lt;TreeItem&lt;T&gt;&gt; treeItemRef;

    private InvalidationListener treeItemGraphicListener = observable -&gt; {
        updateDisplay(getItem(), isEmpty());
    };

    private InvalidationListener treeItemListener = new InvalidationListener() {
        @Override public void invalidated(Observable observable) {
            TreeItem&lt;T&gt; oldTreeItem = treeItemRef == null ? null : treeItemRef.get();
            if (oldTreeItem != null) {
                oldTreeItem.graphicProperty().removeListener(weakTreeItemGraphicListener);
            }

            TreeItem&lt;T&gt; newTreeItem = getTreeItem();
            if (newTreeItem != null) {
                newTreeItem.graphicProperty().addListener(weakTreeItemGraphicListener);
                treeItemRef = new WeakReference&lt;TreeItem&lt;T&gt;&gt;(newTreeItem);
            }
        }
    };

    private WeakInvalidationListener weakTreeItemGraphicListener =
            new WeakInvalidationListener(treeItemGraphicListener);

    private WeakInvalidationListener weakTreeItemListener =
            new WeakInvalidationListener(treeItemListener);

    public DefaultTreeCell() {
        treeItemProperty().addListener(weakTreeItemListener);

        if (getTreeItem() != null) {
            getTreeItem().graphicProperty().addListener(weakTreeItemGraphicListener);
        }
    }

    void updateDisplay(T item, boolean empty) {
        if (item == null || empty) {
            hbox = null;
            setText(null);
            setGraphic(null);
        } else {
            // update the graphic if one is set in the TreeItem
            TreeItem&lt;T&gt; treeItem = getTreeItem();
            if (treeItem != null &amp;&amp; treeItem.getGraphic() != null) {
                if (item instanceof Node) {
                    setText(null);

                    // the item is a Node, and the graphic exists, so
                    // we must insert both into an HBox and present that
                    // to the user (see RT-15910)
                    if (hbox == null) {
                        hbox = new HBox(3);
                    }
                    hbox.getChildren().setAll(treeItem.getGraphic(), (Node)item);
                    setGraphic(hbox);
                } else {
                    hbox = null;
<A NAME="16"></A>                    setText(item.toString());
                    setGraphic(treeItem.getGraphic());
                }
            } else <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#16',2,'match56-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                hbox = null;
                if (item instanceof Node) {
                    setText(null);
                    setGraphic((Node)item);
                } else {</B></FONT>
                    setText(item.toString());
                    setGraphic(null);
                }
            }
        }
    }

    @Override public void updateItem(T item, boolean empty) {
        super.updateItem(item, empty);
        updateDisplay(item, empty);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
<A NAME="20"></A>                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#20',2,'match56-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set</B></FONT>(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextAreaSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.geometry.VerticalDirection;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import javafx.util.Duration;

import java.util.List;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;

/**
 * Default skin implementation for the {@link TextArea} control.
 *
 * @see TextArea
 * @since 9
 */
public class TextAreaSkin extends TextInputControlSkin&lt;TextArea&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /** A shared helper object, used only by downLines(). */
    private static final Path tmpCaretPath = new Path();



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    final private TextArea textArea;

    // *** NOTE: Multiple node mode is not yet fully implemented *** //
    private static final boolean USE_MULTIPLE_NODES = false;

    private final TextAreaBehavior behavior;

    private double computedMinWidth = Double.NEGATIVE_INFINITY;
    private double computedMinHeight = Double.NEGATIVE_INFINITY;
    private double computedPrefWidth = Double.NEGATIVE_INFINITY;
    private double computedPrefHeight = Double.NEGATIVE_INFINITY;
    private double widthForComputedPrefHeight = Double.NEGATIVE_INFINITY;
    private double characterWidth;
    private double lineHeight;

    private ContentView contentView = new ContentView();
    private Group paragraphNodes = new Group();

    private Text promptNode;
    private ObservableBooleanValue usePromptText;

    private ObservableIntegerValue caretPosition;
    private Group selectionHighlightGroup = new Group();

    private ScrollPane scrollPane;
    private Bounds oldViewportBounds;

    private VerticalDirection scrollDirection = null;

    private Path characterBoundingPath = new Path();

    private Timeline scrollSelectionTimeline = new Timeline();
    private EventHandler&lt;ActionEvent&gt; scrollSelectionHandler = event -&gt; {
        switch (scrollDirection) {
            case UP: {
                // TODO Get previous offset
                break;
            }

            case DOWN: {
                // TODO Get next offset
                break;
            }
        }
    };

    private double pressX, pressY; // For dragging handles on embedded
    private boolean handlePressed;

    /**
     * Remembers horizontal position when traversing up / down.
     */
    double targetCaretX = -1;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextAreaSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextAreaSkin(final TextArea control) {
        super(control);

        // install default input map for the text area control
        this.behavior = new TextAreaBehavior(control);
        this.behavior.setTextAreaSkin(this);
//        control.setInputMap(behavior.getInputMap());

        this.textArea = control;

        caretPosition = new IntegerBinding() {
            { bind(control.caretPositionProperty()); }
            @Override protected int computeValue() {
                return control.getCaretPosition();
            }
        };
        caretPosition.addListener((observable, oldValue, newValue) -&gt; {
            targetCaretX = -1;
            if (control.getWidth() &gt; 0) {
                setForwardBias(true);
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
            }
        });

//        setManaged(false);

        // Initialize content
        scrollPane = new ScrollPane();
        scrollPane.setFitToWidth(control.isWrapText());
        scrollPane.setContent(contentView);
        getChildren().add(scrollPane);

        getSkinnable().addEventFilter(ScrollEvent.ANY, event -&gt; {
            if (event.isDirect() &amp;&amp; handlePressed) {
                event.consume();
            }
        });

        // Add selection
        selectionHighlightGroup.setManaged(false);
        selectionHighlightGroup.setVisible(false);
        contentView.getChildren().add(selectionHighlightGroup);

        // Add content view
        paragraphNodes.setManaged(false);
        contentView.getChildren().add(paragraphNodes);

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());
        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        contentView.getChildren().add(caretPath);

        if (SHOW_HANDLES) {
            contentView.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
        }

        scrollPane.hvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollLeft(newValue.doubleValue() * getScrollLeftMax());
        });

        scrollPane.vvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollTop(newValue.doubleValue() * getScrollTopMax());
        });

        // Initialize the scroll selection timeline
        scrollSelectionTimeline.setCycleCount(Timeline.INDEFINITE);
        List&lt;KeyFrame&gt; scrollSelectionFrames = scrollSelectionTimeline.getKeyFrames();
        scrollSelectionFrames.clear();
        scrollSelectionFrames.add(new KeyFrame(Duration.millis(350), scrollSelectionHandler));

        // Add initial text content
        for (int i = 0, n = USE_MULTIPLE_NODES ? control.getParagraphs().size() : 1; i &lt; n; i++) {
            CharSequence paragraph = (n == 1) ? control.textProperty().getValueSafe() : control.getParagraphs().get(i);
            addParagraphNode(i, paragraph.toString());
        }

        control.selectionProperty().addListener((observable, oldValue, newValue) -&gt; {
            // TODO Why do we need two calls here?
            control.requestLayout();
            contentView.requestLayout();
        });

        control.wrapTextProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            scrollPane.setFitToWidth(newValue);
        });

        control.prefColumnCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportWidth();
        });

        control.prefRowCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportHeight();
        });

        updateFontMetrics();
        fontMetrics.addListener(valueModel -&gt; {
            updateFontMetrics();
        });

        contentView.paddingProperty().addListener(valueModel -&gt; {
            updatePrefViewportWidth();
            updatePrefViewportHeight();
        });

        scrollPane.viewportBoundsProperty().addListener(valueModel -&gt; {
            if (scrollPane.getViewportBounds() != null) {
                // ScrollPane creates a new Bounds instance for each
                // layout pass, so we need to check if the width/height
                // have really changed to avoid infinite layout requests.
                Bounds newViewportBounds = scrollPane.getViewportBounds();
                if (oldViewportBounds == null ||
                    oldViewportBounds.getWidth() != newViewportBounds.getWidth() ||
                    oldViewportBounds.getHeight() != newViewportBounds.getHeight()) {

                    invalidateMetrics();
                    oldViewportBounds = newViewportBounds;
                    contentView.requestLayout();
                }
            }
        });

        control.scrollTopProperty().addListener((observable, oldValue, newValue) -&gt; {
            double vValue = (newValue.doubleValue() &lt; getScrollTopMax())
                               ? (newValue.doubleValue() / getScrollTopMax()) : 1.0;
            scrollPane.setVvalue(vValue);
        });

        control.scrollLeftProperty().addListener((observable, oldValue, newValue) -&gt; {
            double hValue = (newValue.doubleValue() &lt; getScrollLeftMax())
                               ? (newValue.doubleValue() / getScrollLeftMax()) : 1.0;
            scrollPane.setHvalue(hValue);
        });

        if (USE_MULTIPLE_NODES) {
            control.getParagraphs().addListener((ListChangeListener.Change&lt;? extends CharSequence&gt; change) -&gt; {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends CharSequence&gt; removed = change.getRemoved();
                    if (from &lt; to) {

                        if (removed.isEmpty()) {
                            // This is an add
                            for (int i = from, n = to; i &lt; n; i++) {
                                addParagraphNode(i, change.getList().get(i).toString());
                            }
                        } else {
                            // This is an update
                            for (int i = from, n = to; i &lt; n; i++) {
                                Node node = paragraphNodes.getChildren().get(i);
                                Text paragraphNode = (Text) node;
                                paragraphNode.setText(change.getList().get(i).toString());
                            }
                        }
                    } else {
                        // This is a remove
                        paragraphNodes.getChildren().subList(from, from + removed.size()).clear();
                    }
                }
            });
        } else {
            control.textProperty().addListener(observable -&gt; {
                invalidateMetrics();
                ((Text)paragraphNodes.getChildren().get(0)).setText(control.textProperty().getValueSafe());
                contentView.requestLayout();
            });
        }

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(), control.promptTextProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty());
            }
        };

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        updateHighlightFill();
        updatePrefViewportWidth();
        updatePrefViewportHeight();
        if (control.isFocused()) setCaretAnimating(true);

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                handlePressed = true;
                e.consume();
            };

            EventHandler&lt;MouseEvent&gt; handleReleaseHandler = event -&gt; {
                handlePressed = false;
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseReleased(handleReleaseHandler);
            selectionHandle1.setOnMouseReleased(handleReleaseHandler);
            selectionHandle2.setOnMouseReleased(handleReleaseHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + caretHandle.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle1.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY + selectionHandle1.getHeight() + 5);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &lt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &gt;= control1.getAnchor()) {
                        pos = control1.getAnchor();
                    }
                }
                positionCaret(hit, true);
                e.consume();
            });

            selectionHandle2.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle2.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &gt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &lt;= control1.getAnchor() + 1) {
                        pos = Math.min(control1.getAnchor() + 2, control1.getLength());
                    }
                    positionCaret(hit, true);
                }
                e.consume();
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void invalidateMetrics() {
        computedMinWidth = Double.NEGATIVE_INFINITY;
        computedMinHeight = Double.NEGATIVE_INFINITY;
        computedPrefWidth = Double.NEGATIVE_INFINITY;
        computedPrefHeight = Double.NEGATIVE_INFINITY;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        scrollPane.resizeRelocate(contentX, contentY, contentWidth, contentHeight);
    }

    /** {@inheritDoc} */
    @Override protected void updateHighlightFill() {
        for (Node node : selectionHighlightGroup.getChildren()) {
            Path selectionHighlightPath = (Path)node;
            selectionHighlightPath.setFill(highlightFillProperty().get());
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Text textNode = getTextNode();
        Point2D p = new Point2D(x - textNode.getLayoutX(), y - getTextTranslateY());
        HitInfo hit = textNode.hitTest(translateCaretPosition(p));
        return hit;
    };

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case LINE:
                switch (dir) {
                    case UP:
                        previousLine(select);
                        break;
                    case DOWN:
                        nextLine(select);
                        break;
                    case BEGINNING:
                        lineStart(select, select &amp;&amp; isMac());
                        break;
                    case END:
                        lineEnd(select, select &amp;&amp; isMac());
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PAGE:
                switch (dir) {
                    case UP:
                        previousPage(select);
                        break;
                    case DOWN:
                        nextPage(select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PARAGRAPH:
                switch (dir) {
                    case UP:
                        paragraphStart(true, select);
                        break;
                    case DOWN:
                        paragraphEnd(true, select);
                        break;
                    case BEGINNING:
                        paragraphStart(false, select);
                        break;
                    case END:
                        paragraphEnd(false, select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
            positionCaret(hit.getInsertionIndex(), leading, false, false);
        } else {
            // We're at beginning or end of line. Try moving up / down.
            int dot = textArea.getCaretPosition();
            targetCaretX = moveRight ? 0 : Double.MAX_VALUE;
            // TODO: Use Bidi sniffing instead of assuming right means forward here?
            downLines(moveRight ? 1 : -1, false, false);
            targetCaretX = -1;
            if (dot == textArea.getCaretPosition()) {
                if (moveRight) {
                    textArea.forward();
                } else {
                    textArea.backward();
                }
            }
        }
    }

    private void downLines(int nLines, boolean select, boolean extendSelection) {
        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();

        // The middle y coordinate of the the line we want to go to.
        double targetLineMidY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2 + nLines * lineHeight;
        if (targetLineMidY &lt; 0) {
            targetLineMidY = 0;
        }

        // The target x for the caret. This may have been set during a
        // previous call.
        double x = (targetCaretX &gt;= 0) ? targetCaretX : (caretBounds.getMaxX());

        // Find a text position for the target x,y.
        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));
        int pos = hit.getCharIndex();

        // Save the old pos temporarily while testing the new one.
        int oldPos = textNode.getCaretPosition();
        boolean oldBias = textNode.isCaretBias();
        textNode.setCaretBias(hit.isLeading());
        textNode.setCaretPosition(pos);
        tmpCaretPath.getElements().clear();
        tmpCaretPath.getElements().addAll(textNode.getCaretShape());
        tmpCaretPath.setLayoutX(textNode.getLayoutX());
        tmpCaretPath.setLayoutY(textNode.getLayoutY());
        Bounds tmpCaretBounds = tmpCaretPath.getLayoutBounds();
        // The y for the middle of the row we found.
        double foundLineMidY = (tmpCaretBounds.getMinY() + tmpCaretBounds.getMaxY()) / 2;
        textNode.setCaretBias(oldBias);
        textNode.setCaretPosition(oldPos);

        // Test if the found line is in the correct direction and move
        // the caret.
        if (nLines == 0 ||
                (nLines &gt; 0 &amp;&amp; foundLineMidY &gt; caretBounds.getMaxY()) ||
                (nLines &lt; 0 &amp;&amp; foundLineMidY &lt; caretBounds.getMinY())) {

            positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, extendSelection);
            targetCaretX = x;
        }
    }

    private void previousLine(boolean select) {
        downLines(-1, select, false);
    }

    private void nextLine(boolean select) {
        downLines(1, select, false);
    }

    private void previousPage(boolean select) {
        downLines(-(int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void nextPage(boolean select) {
        downLines((int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void lineStart(boolean select, boolean extendSelection) {
        targetCaretX = 0;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }

    private void lineEnd(boolean select, boolean extendSelection) {
        targetCaretX = Double.MAX_VALUE;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }


    private void paragraphStart(boolean previousIfAtStart, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();

        if (pos &gt; 0) {
            if (previousIfAtStart &amp;&amp; text.codePointAt(pos-1) == 0x0a) {
                // We are at the beginning of a paragraph.
                // Back up to the previous paragraph.
                pos--;
            }
            // Back up to the beginning of this paragraph
            while (pos &gt; 0 &amp;&amp; text.codePointAt(pos-1) != 0x0a) {
                pos--;
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
                setForwardBias(true);
            }
        }
    }

    private void paragraphEnd(boolean goPastInitialNewline, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();
        int len = text.length();
        boolean wentPastInitialNewline = false;
        boolean goPastTrailingNewline = isWindows();

        if (pos &lt; len) {
            if (goPastInitialNewline &amp;&amp; text.codePointAt(pos) == 0x0a) {
                // We are at the end of a paragraph, start by moving to the
                // next paragraph.
                pos++;
                wentPastInitialNewline = true;
            }
            if (!(goPastTrailingNewline &amp;&amp; wentPastInitialNewline)) {
                // Go to the end of this paragraph
                while (pos &lt; len &amp;&amp; text.codePointAt(pos) != 0x0a) {
                    pos++;
                }
                if (goPastTrailingNewline &amp;&amp; pos &lt; len) {
                    // We are at the end of a paragraph, finish by moving to
                    // the beginning of the next paragraph (Windows behavior).
                    pos++;
                }
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.underlineShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.rangeShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        int pStart = 0;
        Text paragraphNode = null;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                paragraphNode = p;
                break;
            }
            pStart = pEnd + 1;
        }

        if (paragraphNode != null) {
            for (Node node : nodes) {
                node.setLayoutX(paragraphNode.getLayoutX());
                node.setLayoutY(paragraphNode.getLayoutY());
            }
        }
        contentView.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        contentView.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        contentView.layoutChildren();
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - contentView.snappedLeftInset() - getSkinnable().getScrollLeft()),
                    Math.max(0, p.getY() - contentView.snappedTopInset() - getSkinnable().getScrollTop()));
        }
        return p;
    }

    // Public for FXVKSkin
    /**
     * Gets the {@code Bounds} of the caret of the skinned {@code TextArea}.
     * @return the {@code Bounds} of the caret shape, relative to the {@code TextArea}.
     */
    public Bounds getCaretBounds() {
        return getSkinnable().sceneToLocal(caretPath.localToScene(caretPath.getBoundsInLocal()));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case LINE_FOR_OFFSET:
            case LINE_START:
            case LINE_END:
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                Text text = getTextNode();
                return text.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }

        // TODO Unregister listeners on text editor, paragraph list
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Text firstParagraph = (Text) paragraphNodes.getChildren().get(0);
        return Utils.getAscent(getSkinnable().getFont(), firstParagraph.getBoundsType())
                + contentView.snappedTopInset() + textArea.snappedTopInset();
    }

    private char getCharacter(int index) {
        int n = paragraphNodes.getChildren().size();

        int paragraphIndex = 0;
        int offset = index;

        String paragraph = null;
        while (paragraphIndex &lt; n) {
            Text paragraphNode = (Text)paragraphNodes.getChildren().get(paragraphIndex);
            paragraph = paragraphNode.getText();
            int count = paragraph.length() + 1;

            if (offset &lt; count) {
                break;
            }

            offset -= count;
            paragraphIndex++;
        }

        return offset == paragraph.length() ? '\n' : paragraph.charAt(offset);
    }

    /** {@inheritDoc} */
    @Override protected int getInsertionPoint(double x, double y) {
        TextArea textArea = getSkinnable();

        int n = paragraphNodes.getChildren().size();
        int index = -1;

        if (n &gt; 0) {
            if (y &lt; contentView.snappedTopInset()) {
                // Select the character at x in the first row
                Text paragraphNode = (Text)paragraphNodes.getChildren().get(0);
                index = getNextInsertionPoint(paragraphNode, x, -1, VerticalDirection.DOWN);
            } else if (y &gt; contentView.snappedTopInset() + contentView.getHeight()) {
                // Select the character at x in the last row
                int lastParagraphIndex = n - 1;
                Text lastParagraphView = (Text)paragraphNodes.getChildren().get(lastParagraphIndex);

                index = getNextInsertionPoint(lastParagraphView, x, -1, VerticalDirection.UP)
                        + (textArea.getLength() - lastParagraphView.getText().length());
            } else {
                // Select the character at x in the row at y
                int paragraphOffset = 0;
                for (int i = 0; i &lt; n; i++) {
                    Text paragraphNode = (Text)paragraphNodes.getChildren().get(i);

                    Bounds bounds = paragraphNode.getBoundsInLocal();
                    double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();
                    if (y &gt;= paragraphViewY
                            &amp;&amp; y &lt; paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {
                        index = getInsertionPoint(paragraphNode,
                                x - paragraphNode.getLayoutX(),
                                y - paragraphNode.getLayoutY()) + paragraphOffset;
                        break;
                    }

                    paragraphOffset += paragraphNode.getText().length() + 1;
                }
            }
        }

        return index;
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, false);
    }

    private void positionCaret(int pos, boolean leading, boolean select, boolean extendSelection) {
        boolean isNewLine =
                (pos &gt; 0 &amp;&amp;
                        pos &lt;= getSkinnable().getLength() &amp;&amp;
                        getSkinnable().getText().codePointAt(pos-1) == 0x0a);

        // special handling for a new line
        if (!leading &amp;&amp; isNewLine) {
            leading = true;
            pos -= 1;
        }

        if (select) {
            if (extendSelection) {
                getSkinnable().extendSelection(pos);
            } else {
                getSkinnable().selectPositionCaret(pos);
            }
        } else {
            getSkinnable().positionCaret(pos);
        }

        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        TextArea textArea = getSkinnable();

        int paragraphIndex = paragraphNodes.getChildren().size();
        int paragraphOffset = textArea.getLength() + 1;

        Text paragraphNode = null;
        do {
            paragraphNode = (Text)paragraphNodes.getChildren().get(--paragraphIndex);
            paragraphOffset -= paragraphNode.getText().length() + 1;
        } while (index &lt; paragraphOffset);

        int characterIndex = index - paragraphOffset;
        boolean terminator = false;

        if (characterIndex == paragraphNode.getText().length()) {
            characterIndex--;
            terminator = true;
        }

        characterBoundingPath.getElements().clear();
        characterBoundingPath.getElements().addAll(paragraphNode.rangeShape(characterIndex, characterIndex + 1));
        characterBoundingPath.setLayoutX(paragraphNode.getLayoutX());
        characterBoundingPath.setLayoutY(paragraphNode.getLayoutY());

        Bounds bounds = characterBoundingPath.getBoundsInLocal();

        double x = bounds.getMinX() + paragraphNode.getLayoutX() - textArea.getScrollLeft();
        double y = bounds.getMinY() + paragraphNode.getLayoutY() - textArea.getScrollTop();

        // Sometimes the bounds is empty, in which case we must ignore the width/height
        double width = bounds.isEmpty() ? 0 : bounds.getWidth();
        double height = bounds.isEmpty() ? 0 : bounds.getHeight();

        if (terminator) {
            x += width;
            width = 0;
        }

        return new Rectangle2D(x, y, width, height);
    }

    /** {@inheritDoc} */
    @Override protected void scrollCharacterToVisible(final int index) {
        // TODO We queue a callback because when characters are added or
        // removed the bounds are not immediately updated; is this really
        // necessary?

        Platform.runLater(() -&gt; {
            if (getSkinnable().getLength() == 0) {
                return;
            }
            Rectangle2D characterBounds = getCharacterBounds(index);
            scrollBoundsToVisible(characterBounds);
        });
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextAreaBehavior getBehavior() {
        return behavior;
<A NAME="26"></A>    }

    private void createPromptNode() {
        if (promptNode == null &amp;&amp; <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#26',2,'match56-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>usePromptText.get()) {
            promptNode = new Text();
            contentView.getChildren().add(0, promptNode);
            promptNode.setManaged(false);
            promptNode.getStyleClass</B></FONT>().add(&quot;text&quot;);
            promptNode.visibleProperty().bind(usePromptText);
            promptNode.fontProperty().bind(getSkinnable().fontProperty());
            promptNode.textProperty().bind(getSkinnable().promptTextProperty());
            promptNode.fillProperty().bind(promptTextFillProperty());
        }
    }

    private void addParagraphNode(int i, String string) {
        final TextArea textArea = getSkinnable();
        Text paragraphNode = new Text(string);
        paragraphNode.setTextOrigin(VPos.TOP);
        paragraphNode.setManaged(false);
        paragraphNode.getStyleClass().add(&quot;text&quot;);
        paragraphNode.boundsTypeProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updateFontMetrics();
        });
        paragraphNodes.getChildren().add(i, paragraphNode);

        paragraphNode.fontProperty().bind(textArea.fontProperty());
        paragraphNode.fillProperty().bind(textFillProperty());
        paragraphNode.selectionFillProperty().bind(highlightTextFillProperty());
    }

    private double getScrollTopMax() {
        return Math.max(0, contentView.getHeight() - scrollPane.getViewportBounds().getHeight());
    }

    private double getScrollLeftMax() {
        return Math.max(0, contentView.getWidth() - scrollPane.getViewportBounds().getWidth());
    }

    private int getInsertionPoint(Text paragraphNode, double x, double y) {
        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));
        return hitInfo.getInsertionIndex();
    }

    private int getNextInsertionPoint(Text paragraphNode, double x, int from,
        VerticalDirection scrollDirection) {
        // TODO
        return 0;
    }

    private void scrollCaretToVisible() {
        TextArea textArea = getSkinnable();
        Bounds bounds = caretPath.getLayoutBounds();
        double x = bounds.getMinX() - textArea.getScrollLeft();
        double y = bounds.getMinY() - textArea.getScrollTop();
        double w = bounds.getWidth();
        double h = bounds.getHeight();

        if (SHOW_HANDLES) {
            if (caretHandle.isVisible()) {
                h += caretHandle.getHeight();
            } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
                x -= selectionHandle1.getWidth() / 2;
                y -= selectionHandle1.getHeight();
                w += selectionHandle1.getWidth() / 2 + selectionHandle2.getWidth() / 2;
                h += selectionHandle1.getHeight() + selectionHandle2.getHeight();
            }
        }

        if (w &gt; 0 &amp;&amp; h &gt; 0) {
            scrollBoundsToVisible(new Rectangle2D(x, y, w, h));
        }
    }

    private void scrollBoundsToVisible(Rectangle2D bounds) {
        TextArea textArea = getSkinnable();
        Bounds viewportBounds = scrollPane.getViewportBounds();

        double viewportWidth = viewportBounds.getWidth();
        double viewportHeight = viewportBounds.getHeight();
        double scrollTop = textArea.getScrollTop();
        double scrollLeft = textArea.getScrollLeft();
        double slop = 6.0;

        if (bounds.getMinY() &lt; 0) {
            double y = scrollTop + bounds.getMinY();
            if (y &lt;= contentView.snappedTopInset()) {
                y = 0;
            }
            textArea.setScrollTop(y);
        } else if (contentView.snappedTopInset() + bounds.getMaxY() &gt; viewportHeight) {
            double y = scrollTop + contentView.snappedTopInset() + bounds.getMaxY() - viewportHeight;
            if (y &gt;= getScrollTopMax() - contentView.snappedBottomInset()) {
                y = getScrollTopMax();
            }
            textArea.setScrollTop(y);
        }


        if (bounds.getMinX() &lt; 0) {
            double x = scrollLeft + bounds.getMinX() - slop;
            if (x &lt;= contentView.snappedLeftInset() + slop) {
                x = 0;
            }
            textArea.setScrollLeft(x);
        } else if (contentView.snappedLeftInset() + bounds.getMaxX() &gt; viewportWidth) {
            double x = scrollLeft + contentView.snappedLeftInset() + bounds.getMaxX() - viewportWidth + slop;
            if (x &gt;= getScrollLeftMax() - contentView.snappedRightInset() - slop) {
                x = getScrollLeftMax();
            }
            textArea.setScrollLeft(x);
        }
    }

    private void updatePrefViewportWidth() {
        int columnCount = getSkinnable().getPrefColumnCount();
        scrollPane.setPrefViewportWidth(columnCount * characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
        scrollPane.setMinViewportWidth(characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
    }

    private void updatePrefViewportHeight() {
        int rowCount = getSkinnable().getPrefRowCount();
        scrollPane.setPrefViewportHeight(rowCount * lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
        scrollPane.setMinViewportHeight(lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
    }

    private void updateFontMetrics() {
        Text firstParagraph = (Text)paragraphNodes.getChildren().get(0);
        lineHeight = Utils.getLineHeight(getSkinnable().getFont(), firstParagraph.getBoundsType());
        characterWidth = fontMetrics.get().getCharWidth('W');
    }

    private double getTextTranslateX() {
        return contentView.snappedLeftInset();
    }

    private double getTextTranslateY() {
        return contentView.snappedTopInset();
    }

    private double getTextLeft() {
        return 0;
    }

    private Point2D translateCaretPosition(Point2D p) {
        return p;
    }

    private Text getTextNode() {
        if (USE_MULTIPLE_NODES) {
            throw new IllegalArgumentException(&quot;Multiple node traversal is not yet implemented.&quot;);
        }
        return (Text)paragraphNodes.getChildren().get(0);
    }

    private void updateTextNodeCaretPos(int pos) {
        Text textNode = getTextNode();
        if (isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }



    /**************************************************************************
     *
     * Support classes
     *
     **************************************************************************/

    private class ContentView extends Region {
        {
            getStyleClass().add(&quot;content&quot;);

            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                behavior.mousePressed(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                behavior.mouseReleased(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_DRAGGED, event -&gt; {
                behavior.mouseDragged(event);
                event.consume();
            });
        }

        @Override protected ObservableList&lt;Node&gt; getChildren() {
            return super.getChildren();
        }

        @Override public Orientation getContentBias() {
            return Orientation.HORIZONTAL;
        }

        @Override protected double computePrefWidth(double height) {
            if (computedPrefWidth &lt; 0) {
                double prefWidth = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefWidth = Math.max(prefWidth,
                            Utils.computeTextWidth(paragraphNode.getFont(),
                                    paragraphNode.getText(), 0));
                }

                prefWidth += snappedLeftInset() + snappedRightInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefWidth = Math.max(prefWidth, (viewPortBounds != null) ? viewPortBounds.getWidth() : 0);
            }
            return computedPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            if (width != widthForComputedPrefHeight) {
                invalidateMetrics();
                widthForComputedPrefHeight = width;
            }

            if (computedPrefHeight &lt; 0) {
                double wrappingWidth;
                if (width == -1) {
                    wrappingWidth = 0;
                } else {
                    wrappingWidth = Math.max(width - (snappedLeftInset() + snappedRightInset()), 0);
                }

                double prefHeight = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefHeight += Utils.computeTextHeight(
                            paragraphNode.getFont(),
                            paragraphNode.getText(),
                            wrappingWidth,
                            paragraphNode.getBoundsType());
                }

                prefHeight += snappedTopInset() + snappedBottomInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefHeight = Math.max(prefHeight, (viewPortBounds != null) ? viewPortBounds.getHeight() : 0);
            }
            return computedPrefHeight;
        }

        @Override protected double computeMinWidth(double height) {
            if (computedMinWidth &lt; 0) {
                double hInsets = snappedLeftInset() + snappedRightInset();
                computedMinWidth = Math.min(characterWidth + hInsets, computePrefWidth(height));
            }
            return computedMinWidth;
        }

        @Override protected double computeMinHeight(double width) {
            if (computedMinHeight &lt; 0) {
                double vInsets = snappedTopInset() + snappedBottomInset();
                computedMinHeight = Math.min(lineHeight + vInsets, computePrefHeight(width));
            }
            return computedMinHeight;
        }

        @Override public void layoutChildren() {
            TextArea textArea = getSkinnable();
            double width = getWidth();

            // Lay out paragraphs
            final double topPadding = snappedTopInset();
            final double leftPadding = snappedLeftInset();

            double wrappingWidth = Math.max(width - (leftPadding + snappedRightInset()), 0);

            double y = topPadding;

            final List&lt;Node&gt; paragraphNodesChildren = paragraphNodes.getChildren();

            for (int i = 0; i &lt; paragraphNodesChildren.size(); i++) {
                Node node = paragraphNodesChildren.get(i);
                Text paragraphNode = (Text)node;
                paragraphNode.setWrappingWidth(wrappingWidth);

                Bounds bounds = paragraphNode.getBoundsInLocal();
                paragraphNode.setLayoutX(leftPadding);
                paragraphNode.setLayoutY(y);

                y += bounds.getHeight();
            }

            if (promptNode != null) {
                promptNode.setLayoutX(leftPadding);
                promptNode.setLayoutY(topPadding + promptNode.getBaselineOffset());
                promptNode.setWrappingWidth(wrappingWidth);
            }

            // Update the selection
            IndexRange selection = textArea.getSelection();
            Bounds oldCaretBounds = caretPath.getBoundsInParent();

            selectionHighlightGroup.getChildren().clear();

            int caretPos = textArea.getCaretPosition();
            int anchorPos = textArea.getAnchor();

            if (SHOW_HANDLES) {
                // Install and resize the handles for caret and anchor.
                if (selection.getLength() &gt; 0) {
                    selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                            selectionHandle1.prefHeight(-1));
                    selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                            selectionHandle2.prefHeight(-1));
                } else {
                    caretHandle.resize(caretHandle.prefWidth(-1),
                            caretHandle.prefHeight(-1));
                }

                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the actual caret.
                if (selection.getLength() &gt; 0) {
                    int paragraphIndex = paragraphNodesChildren.size();
                    int paragraphOffset = textArea.getLength() + 1;
                    Text paragraphNode = null;
                    do {
                        paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                        paragraphOffset -= paragraphNode.getText().length() + 1;
                    } while (anchorPos &lt; paragraphOffset);

                    updateTextNodeCaretPos(anchorPos - paragraphOffset);
                    caretPath.getElements().clear();
                    caretPath.getElements().addAll(paragraphNode.getCaretShape());
                    caretPath.setLayoutX(paragraphNode.getLayoutX());
                    caretPath.setLayoutY(paragraphNode.getLayoutY());

                    Bounds b = caretPath.getBoundsInParent();
                    if (caretPos &lt; anchorPos) {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    } else {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    }
                }
            }

            {
                // Position caret
                int paragraphIndex = paragraphNodesChildren.size();
                int paragraphOffset = textArea.getLength() + 1;

                Text paragraphNode = null;
                do {
                    paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                    paragraphOffset -= paragraphNode.getText().length() + 1;
                } while (caretPos &lt; paragraphOffset);

                updateTextNodeCaretPos(caretPos - paragraphOffset);

                caretPath.getElements().clear();
                caretPath.getElements().addAll(paragraphNode.getCaretShape());

                caretPath.setLayoutX(paragraphNode.getLayoutX());

                // TODO: Remove this temporary workaround for RT-27533
                paragraphNode.setLayoutX(2 * paragraphNode.getLayoutX() - paragraphNode.getBoundsInParent().getMinX());

                caretPath.setLayoutY(paragraphNode.getLayoutY());
                if (oldCaretBounds == null || !oldCaretBounds.equals(caretPath.getBoundsInParent())) {
                    scrollCaretToVisible();
                }
            }

            // Update selection fg and bg
            int start = selection.getStart();
            int end = selection.getEnd();
            for (int i = 0, max = paragraphNodesChildren.size(); i &lt; max; i++) {
                Node paragraphNode = paragraphNodesChildren.get(i);
                Text textNode = (Text)paragraphNode;
                int paragraphLength = textNode.getText().length() + 1;
                if (end &gt; start &amp;&amp; start &lt; paragraphLength) {
                    textNode.setSelectionStart(start);
                    textNode.setSelectionEnd(Math.min(end, paragraphLength));

                    Path selectionHighlightPath = new Path();
                    selectionHighlightPath.setManaged(false);
                    selectionHighlightPath.setStroke(null);
                    PathElement[] selectionShape = textNode.getSelectionShape();
                    if (selectionShape != null) {
                        selectionHighlightPath.getElements().addAll(selectionShape);
                    }
                    selectionHighlightGroup.getChildren().add(selectionHighlightPath);
                    selectionHighlightGroup.setVisible(true);
                    selectionHighlightPath.setLayoutX(textNode.getLayoutX());
                    selectionHighlightPath.setLayoutY(textNode.getLayoutY());
                    updateHighlightFill();
                } else {
                    textNode.setSelectionStart(-1);
                    textNode.setSelectionEnd(-1);
                    selectionHighlightGroup.setVisible(false);
                }
                start = Math.max(0, start - paragraphLength);
                end   = Math.max(0, end   - paragraphLength);
            }

            if (SHOW_HANDLES) {
                // Position handle for the caret. This could be handle1 or handle2 when
                // a selection is active.
                Bounds b = caretPath.getBoundsInParent();
                if (selection.getLength() &gt; 0) {
                    if (caretPos &lt; anchorPos) {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    } else {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    }
                } else {
                    caretHandle.setLayoutX(b.getMinX() - caretHandle.getWidth() / 2 + 1);
                    caretHandle.setLayoutY(b.getMaxY());
                }
            }

            if (scrollPane.getPrefViewportWidth() == 0
                    || scrollPane.getPrefViewportHeight() == 0) {
                updatePrefViewportWidth();
                updatePrefViewportHeight();
                if (getParent() != null &amp;&amp; scrollPane.getPrefViewportWidth() &gt; 0
                        || scrollPane.getPrefViewportHeight() &gt; 0) {
                    // Force layout of viewRect in ScrollPaneSkin
                    getParent().requestLayout();
                }
            }

            // RT-36454: Fit to width/height only if smaller than viewport.
            // That is, grow to fit but don't shrink to fit.
            Bounds viewportBounds = scrollPane.getViewportBounds();
            boolean wasFitToWidth = scrollPane.isFitToWidth();
            boolean wasFitToHeight = scrollPane.isFitToHeight();
            boolean setFitToWidth = textArea.isWrapText() || computePrefWidth(-1) &lt;= viewportBounds.getWidth();
            boolean setFitToHeight = computePrefHeight(width) &lt;= viewportBounds.getHeight();
            if (wasFitToWidth != setFitToWidth || wasFitToHeight != setFitToHeight) {
                Platform.runLater(() -&gt; {
                    scrollPane.setFitToWidth(setFitToWidth);
                    scrollPane.setFitToHeight(setFitToHeight);
                });
                getParent().requestLayout();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TreeTableViewSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.collections.NonIterableChange;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;

import com.sun.javafx.scene.control.TreeTableViewBackingList;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.event.WeakEventHandler;
import javafx.scene.control.*;

import com.sun.javafx.scene.control.behavior.TreeTableViewBehavior;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.control.TreeItem.TreeModificationEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.util.Callback;

/**
 * Default skin implementation for the {@link TreeTableView} control.
 *
 * @see TreeTableView
 * @since 9
 */
public class TreeTableViewSkin&lt;T&gt; extends TableViewSkinBase&lt;T, TreeItem&lt;T&gt;, TreeTableView&lt;T&gt;, TreeTableRow&lt;T&gt;, TreeTableColumn&lt;T,?&gt;&gt; {

    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    TreeTableViewBackingList&lt;T&gt; tableBackingList;
    ObjectProperty&lt;ObservableList&lt;TreeItem&lt;T&gt;&gt;&gt; tableBackingListProperty;

    private WeakReference&lt;TreeItem&lt;T&gt;&gt; weakRootRef;
    private final TreeTableViewBehavior&lt;T&gt;  behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private EventHandler&lt;TreeItem.TreeModificationEvent&lt;T&gt;&gt; rootListener = e -&gt; {
        if (e.wasAdded() &amp;&amp; e.wasRemoved() &amp;&amp; e.getAddedSize() == e.getRemovedSize()) {
            // Fix for RT-14842, where the children of a TreeItem were changing,
            // but because the overall item count was staying the same, there was
            // no event being fired to the skin to be informed that the items
            // had changed. So, here we just watch for the case where the number
            // of items being added is equal to the number of items being removed.
            markItemCountDirty();
            getSkinnable().requestLayout();
        } else if (e.getEventType().equals(TreeItem.valueChangedEvent())) {
            // Fix for RT-14971 and RT-15338.
            requestRebuildCells();
        } else {
            // Fix for RT-20090. We are checking to see if the event coming
            // from the TreeItem root is an event where the count has changed.
            EventType&lt;?&gt; eventType = e.getEventType();
            while (eventType != null) {
                if (eventType.equals(TreeItem.&lt;T&gt;expandedItemCountChangeEvent())) {
                    markItemCountDirty();
                    getSkinnable().requestLayout();
                    break;
                }
                eventType = eventType.getSuperType();
            }
        }

        // fix for RT-37853
        getSkinnable().edit(-1, null);
    };

    private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakRootListener;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TreeTableViewSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TreeTableViewSkin(final TreeTableView&lt;T&gt; control) {
        super(control);

        // install default input map for the TreeTableView control
        behavior = new TreeTableViewBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        flow.setFixedCellSize(control.getFixedCellSize());
        flow.setCellFactory(flow -&gt; createCell());

        setRoot(getSkinnable().getRoot());

        EventHandler&lt;MouseEvent&gt; ml = event -&gt; {
            // RT-15127: cancel editing on scroll. This is a bit extreme
            // (we are cancelling editing on touching the scrollbars).
            // This can be improved at a later date.
            if (control.getEditingCell() != null) {
                control.edit(-1, null);
            }

            // This ensures that the table maintains the focus, even when the vbar
            // and hbar controls inside the flow are clicked. Without this, the
            // focus border will not be shown when the user interacts with the
            // scrollbars, and more importantly, keyboard navigation won't be
            // available to the user.
            if (control.isFocusTraversable()) {
                control.requestFocus();
            }
        };
        flow.getVbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
        flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);

        // init the behavior 'closures'
        behavior.setOnFocusPreviousRow(() -&gt; onFocusPreviousCell());
        behavior.setOnFocusNextRow(() -&gt; onFocusNextCell());
        behavior.setOnMoveToFirstCell(() -&gt; onMoveToFirstCell());
        behavior.setOnMoveToLastCell(() -&gt; onMoveToLastCell());
        behavior.setOnScrollPageDown(isFocusDriven -&gt; onScrollPageDown(isFocusDriven));
        behavior.setOnScrollPageUp(isFocusDriven -&gt; onScrollPageUp(isFocusDriven));
        behavior.setOnSelectPreviousRow(() -&gt; onSelectPreviousCell());
        behavior.setOnSelectNextRow(() -&gt; onSelectNextCell());
        behavior.setOnSelectLeftCell(() -&gt; onSelectLeftCell());
        behavior.setOnSelectRightCell(() -&gt; onSelectRightCell());

        registerChangeListener(control.rootProperty(), e -&gt; {
            // fix for RT-37853
            getSkinnable().edit(-1, null);

            setRoot(getSkinnable().getRoot());
        });
        registerChangeListener(control.showRootProperty(), e -&gt; {
            // if we turn off showing the root, then we must ensure the root
            // is expanded - otherwise we end up with no visible items in
            // the tree.
            if (! getSkinnable().isShowRoot() &amp;&amp; getRoot() != null) {
                getRoot().setExpanded(true);
            }
            // update the item count in the flow and behavior instances
            updateItemCount();
        });
        registerChangeListener(control.rowFactoryProperty(), e -&gt; flow.recreateCells());
        registerChangeListener(control.expandedItemCountProperty(), e -&gt; markItemCountDirty());
        registerChangeListener(control.fixedCellSizeProperty(), e -&gt; flow.setFixedCellSize(getSkinnable().getFixedCellSize()));
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROW_AT_INDEX: {
                final int rowIndex = (Integer)parameters[0];
                return rowIndex &lt; 0 ? null : flow.getPrivateCell(rowIndex);
            }
            case SELECTED_ITEMS: {
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                TreeTableView.TreeTableViewSelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
                for (TreeTablePosition&lt;T,?&gt; pos : sm.getSelectedCells()) {
                    TreeTableRow&lt;T&gt; row = flow.getPrivateCell(pos.getRow());
                    if (row != null) selection.add(row);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: // TableViewSkinBase
            case CELL_AT_ROW_COLUMN: // TableViewSkinBase
            case COLUMN_AT_INDEX: // TableViewSkinBase
            case HEADER: // TableViewSkinBase
            case VERTICAL_SCROLLBAR: // TableViewSkinBase
            case HORIZONTAL_SCROLLBAR: // TableViewSkinBase
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    @Override
    protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SHOW_ITEM: {
                Node item = (Node)parameters[0];
                if (item instanceof TreeTableCell) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    TreeTableCell&lt;T, ?&gt; cell = (TreeTableCell&lt;T, ?&gt;)item;
                    flow.scrollTo(cell.getIndex());
                }
                break;
            }
            case SET_SELECTED_ITEMS: {
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;Node&gt; items = (ObservableList&lt;Node&gt;)parameters[0];
                if (items != null) {
                    TreeTableView.TreeTableViewSelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
                    if (sm != null) {
                        sm.clearSelection();
                        for (Node item : items) {
                            if (item instanceof TreeTableCell) {
                                @SuppressWarnings(&quot;unchecked&quot;)
                                TreeTableCell&lt;T, ?&gt; cell = (TreeTableCell&lt;T, ?&gt;)item;
                                sm.select(cell.getIndex(), cell.getTableColumn());
                            }
                        }
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private methods                                                         *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    private TreeTableRow&lt;T&gt; createCell() {
        TreeTableRow&lt;T&gt; cell;

        TreeTableView&lt;T&gt; treeTableView = getSkinnable();
        if (treeTableView.getRowFactory() != null) {
            cell = treeTableView.getRowFactory().call(treeTableView);
        } else {
            cell = new TreeTableRow&lt;T&gt;();
        }

        // If there is no disclosure node, then add one of my own
        if (cell.getDisclosureNode() == null) {
            final StackPane disclosureNode = new StackPane();
            disclosureNode.getStyleClass().setAll(&quot;tree-disclosure-node&quot;);
            disclosureNode.setMouseTransparent(true);

            final StackPane disclosureNodeArrow = new StackPane();
            disclosureNodeArrow.getStyleClass().setAll(&quot;arrow&quot;);
            disclosureNode.getChildren().add(disclosureNodeArrow);

            cell.setDisclosureNode(disclosureNode);
        }

        cell.updateTreeTableView(treeTableView);
        return cell;
    }

    private TreeItem&lt;T&gt; getRoot() {
        return weakRootRef == null ? null : weakRootRef.get();
    }
    private void setRoot(TreeItem&lt;T&gt; newRoot) {
        if (getRoot() != null &amp;&amp; weakRootListener != null) {
            getRoot().removeEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }
        weakRootRef = new WeakReference&lt;&gt;(newRoot);
        if (getRoot() != null) {
            weakRootListener = new WeakEventHandler&lt;&gt;(rootListener);
            getRoot().addEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }

        updateItemCount();
    }

    /** {@inheritDoc} */
    @Override protected int getItemCount() {
        return getSkinnable().getExpandedItemCount();
    }

    /** {@inheritDoc} */
    @Override void horizontalScroll() {
        super.horizontalScroll();
        if (getSkinnable().getFixedCellSize() &gt; 0) {
            flow.requestCellLayout();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateItemCount() {
        updatePlaceholderRegionVisibility();

<A NAME="10"></A>        tableBackingList.resetSize();

        int oldCount = flow.getCellCount();
        int newCount = <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#10',2,'match56-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getItemCount();

        // if this is not called even when the count is the same, we get a
        // memory leak in VirtualFlow.sheet.children. This can probably be
        // optimised in the future when time permits.
        flow.setCellCount(newCount);

        if (newCount != oldCount) {
            // The following line is (perhaps temporarily) disabled to
            // resolve two issues: JDK-8155798 and JDK-8147483.
            // A unit test exists in TreeTableViewTest to ensure that
            // the performance issue covered in JDK-8147483 doesn't regress.
            // requestRebuildCells();
        } else {
            needCellsReconfigured = true;
        }
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/javafx/fxml/JavaFXBuilderFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.fxml;

import com.sun.javafx.fxml.BeanAdapter;
import com.sun.javafx.fxml.builder.JavaFXFontBuilder;
import com.sun.javafx.fxml.builder.JavaFXImageBuilder;
import com.sun.javafx.fxml.builder.JavaFXSceneBuilder;
import com.sun.javafx.fxml.builder.ProxyBuilder;
import com.sun.javafx.fxml.builder.TriangleMeshBuilder;
import com.sun.javafx.fxml.builder.URLBuilder;
import com.sun.javafx.logging.PlatformLogger;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.shape.TriangleMesh;
import javafx.scene.text.Font;
import javafx.util.Builder;
import javafx.util.BuilderFactory;
import com.sun.javafx.reflect.ConstructorUtil;
import com.sun.javafx.reflect.MethodUtil;

/**
 * JavaFX builder factory.
 * @since JavaFX 2.0
 */
public final class JavaFXBuilderFactory implements BuilderFactory {
    private final ClassLoader classLoader;
    private final boolean webSupported;
    private static final String WEBVIEW_NAME = &quot;javafx.scene.web.WebView&quot;;

    // WebViewBuilder class name loaded via reflection
// TODO: Uncomment the following when RT-40037 is fixed.
//    private static final String WEBVIEW_BUILDER_NAME =
//            &quot;com.sun.javafx.fxml.builder.web.JavaFXWebViewBuilder&quot;;

// TODO: Remove the following when RT-40037 is fixed.
    private static final String WEBVIEW_BUILDER_NAME =
            &quot;com.sun.javafx.fxml.builder.web.WebViewBuilder&quot;;

    /**
     * Default constructor.
     */
    public JavaFXBuilderFactory() {
        this(FXMLLoader.getDefaultClassLoader());
    }

    /**
     * Constructor that takes a class loader.
     *
     * @param classLoader the class loader to use when loading classes
     * @since JavaFX 2.1
     */
    public JavaFXBuilderFactory(ClassLoader classLoader) {
        if (classLoader == null) {
            throw new NullPointerException();
        }

        this.classLoader = classLoader;
        this.webSupported = Platform.isSupported(ConditionalFeature.WEB);
    }

    /**
     * Returns the builder for the specified type, or null if no builder is
     * used. Most classes will note use a builder.
     *
     * @param type the class being looked up
     *
     * @return the builder for the class, or null if no builder is used
     */
    @Override
    public Builder&lt;?&gt; getBuilder(Class&lt;?&gt; type) {
        if (type == null) {
            throw new NullPointerException();
        }

        Builder&lt;?&gt; builder;

        // All classes without a default constructor need to appear here, as
        // well as any other class that has special requirements that need
        // a builder to handle them.
        if (type == Scene.class) {
            builder = new JavaFXSceneBuilder();
        } else if (type == Font.class) {
            builder = new JavaFXFontBuilder();
        } else if (type == Image.class) {
            builder = new JavaFXImageBuilder();
        } else if (type == URL.class) {
            builder = new URLBuilder(classLoader);
        } else if (type == TriangleMesh.class) {
            builder = new TriangleMeshBuilder();
        } else if (webSupported &amp;&amp; type.getName().equals(WEBVIEW_NAME)) {

// TODO: enable this code when RT-40037 is fixed.
//            // Construct a WebViewBuilder via reflection
//            try {
//                Class&lt;Builder&lt;?&gt;&gt; builderClass =
//                        (Class&lt;Builder&lt;?&gt;&gt;)classLoader.loadClass(WEBVIEW_BUILDER_NAME);
//                Constructor&lt;Builder&lt;?&gt;&gt; constructor = builderClass.getConstructor(new Class[0]);
//                builder = constructor.newInstance();
//            } catch (Exception ex) {
//                // This should never happen
//                ex.printStackTrace();
//                builder = null;
//            }

            // TODO: Remove the following when RT-40037 is fixed.
            try {
                Class&lt;?&gt; builderClass = classLoader.loadClass(WEBVIEW_BUILDER_NAME);
                ObjectBuilderWrapper wrapper = new ObjectBuilderWrapper(builderClass);
                builder = wrapper.createBuilder();
            } catch (Exception ex) {
                builder = null;
            }
        } else if (scanForConstructorAnnotations(type)) {
            builder = new ProxyBuilder(type);
        } else {
            // No builder will be used to construct this class. The class must
            // have a public default constructor, which is the case for all
            // platform classes, except those handled above.
<A NAME="24"></A>            builder = null;
        }

        <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#24',2,'match56-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return builder;
    }

    private boolean scanForConstructorAnnotations(Class&lt;?&gt; type) {
        Constructor constructors[] = ConstructorUtil.getConstructors(type);
        for (Constructor constructor : constructors) {
            Annotation[][] paramAnnotations = constructor.getParameterAnnotations</B></FONT>();
            for (int i = 0; i &lt; constructor.getParameterTypes().length; i++) {
                for (Annotation annotation : paramAnnotations[i]) {
                    if (annotation instanceof NamedArg) {
                        return true;
                    }
                }
            }
        }
        return false;
    }


    /**
     * Legacy ObjectBuilder wrapper.
     *
     * TODO: move this legacy functionality to JavaFXWebViewBuilder and modify
     * it to work without requiring the legacy builders. See RT-40037.
     */
    private static final class ObjectBuilderWrapper {
        private static final Object[]   NO_ARGS = {};
        private static final Class&lt;?&gt;[] NO_SIG = {};

        private final Class&lt;?&gt;           builderClass;
        private final Method             createMethod;
        private final Method             buildMethod;
        private final Map&lt;String,Method&gt; methods = new HashMap&lt;String, Method&gt;();
        private final Map&lt;String,Method&gt; getters = new HashMap&lt;String,Method&gt;();
        private final Map&lt;String,Method&gt; setters = new HashMap&lt;String,Method&gt;();

        final class ObjectBuilder extends AbstractMap&lt;String, Object&gt; implements Builder&lt;Object&gt; {
            private final Map&lt;String,Object&gt; containers = new HashMap&lt;String,Object&gt;();
            private Object                   builder = null;
            private Map&lt;Object,Object&gt;       properties;

            private ObjectBuilder() {
                try {
                    builder = createMethod.invoke(null, NO_ARGS);
                } catch (Exception e) {
                    //TODO
                    throw new RuntimeException(&quot;Creation of the builder &quot; + builderClass.getName() + &quot; failed.&quot;, e);
                }
            }

            @Override
            public Object build() {
                for (Iterator&lt;Entry&lt;String,Object&gt;&gt; iter = containers.entrySet().iterator(); iter.hasNext(); ) {
                    Entry&lt;String, Object&gt; entry = iter.next();

                    put(entry.getKey(), entry.getValue());
                }

                Object res;
                try {
                    res = buildMethod.invoke(builder, NO_ARGS);
                    // TODO:
                    // temporary special case for Node properties until
                    // platform builders are fixed
                    if (properties != null &amp;&amp; res instanceof Node) {
                        ((Map&lt;Object, Object&gt;)((Node)res).getProperties()).putAll(properties);
                    }
                } catch (InvocationTargetException exception) {
                    throw new RuntimeException(exception);
                } catch (IllegalAccessException exception) {
                    throw new RuntimeException(exception);
                } finally {
                    builder = null;
                }

                return res;
            }

            @Override
            public int size() {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean isEmpty() {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean containsKey(Object key) {
                return (getTemporaryContainer(key.toString()) != null);
            }

            @Override
            public boolean containsValue(Object value) {
                throw new UnsupportedOperationException();
            }

            @Override
            public Object get(Object key) {
                return getTemporaryContainer(key.toString());
            }

            @Override
            @SuppressWarnings(&quot;unchecked&quot;)
            public Object put(String key, Object value) {
                // TODO:
                // temporary hack: builders don't have a method for properties...
                if (Node.class.isAssignableFrom(getTargetClass()) &amp;&amp; &quot;properties&quot;.equals(key)) {
                    properties = (Map&lt;Object,Object&gt;) value;
                    return null;
                }
                try {
                    Method m = methods.get(key);
                    if (m == null) {
                        m = findMethod(key);
                        methods.put(key, m);
                    }
                    try {
                        final Class&lt;?&gt; type = m.getParameterTypes()[0];

                        // If the type is an Array, and our value is a list,
                        // we simply convert the list into an array. Otherwise,
                        // we treat the value as a string and split it into a
                        // list using the array component delimiter.
                        if (type.isArray()) {
                            final List&lt;?&gt; list;
                            if (value instanceof List) {
                                list = (List&lt;?&gt;)value;
                            } else {
                                list = Arrays.asList(value.toString().split(FXMLLoader.ARRAY_COMPONENT_DELIMITER));
                            }

                            final Class&lt;?&gt; componentType = type.getComponentType();
                            Object array = Array.newInstance(componentType, list.size());
                            for (int i=0; i&lt;list.size(); i++) {
                                Array.set(array, i, BeanAdapter.coerce(list.get(i), componentType));
                            }
                            value = array;
                        }

                        m.invoke(builder, new Object[] { BeanAdapter.coerce(value, type) });
                    } catch (Exception e) {
                        String msg = &quot;Method &quot; + m.getName() + &quot; failed&quot;;
                        PlatformLogger.getLogger(ObjectBuilderWrapper.class.getName()).warning(msg, e);
                    }
                    //TODO Is it OK to return null here?
                    return null;
                } catch (Exception e) {
                    //TODO Should be reported
                    String msg = &quot;Failed to set &quot; + getTargetClass()+&quot;.&quot; + key + &quot; using &quot; + builderClass;
                    PlatformLogger.getLogger(ObjectBuilderWrapper.class.getName()).warning(msg, e);
                    return null;
                }
            }

            // Should do this in BeanAdapter?
            // This is used to support read-only collection property.
            // This method must return a Collection of the appropriate type
            // if 1. the property is read-only, and 2. the property is a collection.
            // It must return null otherwise.
            Object getReadOnlyProperty(String propName) {
                if (setters.get(propName) != null) return null;
                Method getter = getters.get(propName);
                if (getter == null) {
                    Method setter = null;
                    Class&lt;?&gt; target = getTargetClass();
                    String suffix = Character.toUpperCase(propName.charAt(0)) + propName.substring(1);
                    try {
                        getter = MethodUtil.getMethod(target, &quot;get&quot;+ suffix, NO_SIG);
                        setter = MethodUtil.getMethod(target, &quot;set&quot;+ suffix, new Class[] { getter.getReturnType() });
                    } catch (Exception x) {
                    }
                    if (getter != null) {
                        getters.put(propName, getter);
                        setters.put(propName, setter);
                    }
                    if (setter != null) return null;
                    }

                Class&lt;?&gt; type;
                if (getter == null) {
                    // if we have found no getter it might be a constructor property
                    // try to get the type from the builder method.
                    final Method m = findMethod(propName);
                    if (m == null) {
                        return null;
                    }
                    type = m.getParameterTypes()[0];
                    if (type.isArray()) type = List.class;
                } else {
                    type = getter.getReturnType();
                }

                if (ObservableMap.class.isAssignableFrom(type)) {
                    return FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
                } else if (Map.class.isAssignableFrom(type)) {
                    return new HashMap&lt;Object, Object&gt;();
                } else if (ObservableList.class.isAssignableFrom(type)) {
                    return FXCollections.observableArrayList();
                } else if (List.class.isAssignableFrom(type)) {
                    return new ArrayList&lt;Object&gt;();
                } else if (Set.class.isAssignableFrom(type)) {
                    return new HashSet&lt;Object&gt;();
                }
                return null;
            }

            /**
             * This is used to support read-only collection property.
             * This method must return a Collection of the appropriate type
             * if 1. the property is read-only, and 2. the property is a collection.
             * It must return null otherwise.
             **/
            public Object getTemporaryContainer(String propName) {
                Object o = containers.get(propName);
                if (o == null) {
                    o = getReadOnlyProperty(propName);
                    if (o != null) {
                        containers.put(propName, o);
                    }
                }

                return o;
            }

            @Override
            public Object remove(Object key) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void putAll(Map&lt;? extends String, ? extends Object&gt; m) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void clear() {
                throw new UnsupportedOperationException();
            }

            @Override
            public Set&lt;String&gt; keySet() {
                throw new UnsupportedOperationException();
            }

            @Override
            public Collection&lt;Object&gt; values() {
                throw new UnsupportedOperationException();
            }

            @Override
            public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
                throw new UnsupportedOperationException();
            }
        }

        ObjectBuilderWrapper() {
            builderClass = null;
            createMethod = null;
            buildMethod = null;
        }

        ObjectBuilderWrapper(Class&lt;?&gt; builderClass) throws NoSuchMethodException, InstantiationException, IllegalAccessException {
            this.builderClass = builderClass;
            createMethod = MethodUtil.getMethod(builderClass, &quot;create&quot;, NO_SIG);
            buildMethod = MethodUtil.getMethod(builderClass, &quot;build&quot;, NO_SIG);
            assert Modifier.isStatic(createMethod.getModifiers());
            assert !Modifier.isStatic(buildMethod.getModifiers());
        }

        Builder&lt;Object&gt; createBuilder() {
            return new ObjectBuilder();
        }

        private Method findMethod(String name) {
            if (name.length() &gt; 1
                    &amp;&amp; Character.isUpperCase(name.charAt(1))) {
                name = Character.toUpperCase(name.charAt(0)) + name.substring(1);
            }

            for (Method m : MethodUtil.getMethods(builderClass)) {
                if (m.getName().equals(name)) {
                    return m;
                }
            }
            throw new IllegalArgumentException(&quot;Method &quot; + name + &quot; could not be found at class &quot; + builderClass.getName());
        }

        /**
         * The type constructed by this builder.
         * @return The type constructed by this builder.
         */
        public Class&lt;?&gt; getTargetClass() {
            return buildMethod.getReturnType();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Accessible.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui;

import static javafx.scene.AccessibleAttribute.PARENT;
import static javafx.scene.AccessibleAttribute.ROLE;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.tk.quantum.QuantumToolkit;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Scene;

public abstract class Accessible {

    private EventHandler eventHandler;
    private View view;

    public static abstract class EventHandler {
        public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
            return null;
        }

        public void executeAction(AccessibleAction action, Object... parameters) {
        }

<A NAME="0"></A>        public abstract AccessControlContext getAccessControlContext();
    }

    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#0',2,'match56-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public EventHandler getEventHandler() {
        return this.eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setView(View view) {
        this.view = view;
    }

    public View getView() {
        return view;
    }</B></FONT>

    public void dispose() {
        eventHandler = null;
        view = null;
    }

    public boolean isDisposed() {
        return getNativeAccessible() == 0L;
    }

    @Override
    public String toString() {
         return getClass().getSimpleName() + &quot; (&quot; + eventHandler + &quot;)&quot;;
    }

    protected boolean isIgnored() {
        AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
        if (role == null) return true;
        return role == AccessibleRole.NODE || role == AccessibleRole.PARENT;
    }

    protected abstract long getNativeAccessible();

    protected Accessible getAccessible(Scene scene) {
        if (scene == null) return null;
        return SceneHelper.getAccessible(scene);
    }

    protected Accessible getAccessible(Node node) {
        if (node == null) return null;
        return NodeHelper.getAccessible(node);
    }

    protected long getNativeAccessible(Node node) {
        if (node == null) return 0L;
        Accessible acc = getAccessible(node);
        if (acc == null) return 0L;
        return acc.getNativeAccessible();
    }

    protected Accessible getContainerAccessible(AccessibleRole targetRole) {
        Node node = (Node)getAttribute(PARENT);
        while (node != null) {
            Accessible acc = getAccessible(node);
            AccessibleRole role = (AccessibleRole)acc.getAttribute(ROLE);
            if (role == targetRole) return acc;
            node = (Node)acc.getAttribute(PARENT);
        }
        return null;
    }

    /*
     * IMPORTANT: Calling to the user code should not proceed if
     * this method returns NULL.
     */
    private final AccessControlContext getAccessControlContext() {
        AccessControlContext acc = null;
        try {
            acc = eventHandler.getAccessControlContext();
        } catch (Exception e) {
            /* The node was already removed from the scene */
        }
        return acc;
    }

    private class GetAttribute implements PrivilegedAction&lt;Object&gt; {
        AccessibleAttribute attribute;
        Object[] parameters;
        @Override public Object run() {
            Object result = eventHandler.getAttribute(attribute, parameters);
            if (result != null) {
                Class&lt;?&gt; clazz = attribute.getReturnType();
                if (clazz != null) {
                    try {
                        clazz.cast(result);
                    } catch (Exception e) {
                        String msg = &quot;The expected return type for the &quot; + attribute +
                                     &quot; attribute is &quot; + clazz.getSimpleName() +
                                     &quot; but found &quot; + result.getClass().getSimpleName();
                        System.err.println(msg);
                        return null; //Fail no exception
                    }
                }
            }
            return result;
        }
    }

    private GetAttribute getAttribute = new GetAttribute();

    public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
        AccessControlContext acc = getAccessControlContext();
        if (acc == null) return null;
        return QuantumToolkit.runWithoutRenderLock(() -&gt; {
            getAttribute.attribute = attribute;
            getAttribute.parameters = parameters;
            return AccessController.doPrivileged(getAttribute, acc);
        });
    }

    private class ExecuteAction implements PrivilegedAction&lt;Void&gt; {
        AccessibleAction action;
        Object[] parameters;
        @Override public Void run() {
            eventHandler.executeAction(action, parameters);
            return null;
        }
    }

    private ExecuteAction executeAction = new ExecuteAction();

    public void executeAction(AccessibleAction action, Object... parameters) {
        AccessControlContext acc = getAccessControlContext();
        if (acc == null) return;
        QuantumToolkit.runWithoutRenderLock(() -&gt; {
            executeAction.action = action;
            executeAction.parameters = parameters;
            return AccessController.doPrivileged(executeAction, acc);
        });
    }

    public abstract void sendNotification(AccessibleAttribute notification);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/mac/MacVariant.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.mac;

import java.lang.annotation.Native;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Arrays;
import javafx.geometry.Bounds;

final class MacVariant {
    @Native final static int NSArray_id = 1;
    @Native final static int NSArray_NSString = 2;
    @Native final static int NSArray_int = 3;
    @Native final static int NSArray_range = 4;
    @Native final static int NSAttributedString = 5; /* Uses string for the text and variantArray for the styles */
    @Native final static int NSData = 6;
    @Native final static int NSDate = 7;
    @Native final static int NSDictionary = 8; /* Uses longArray for keys (NSString) and variantArray for values */
    @Native final static int NSNumber_Boolean = 9;
    @Native final static int NSNumber_Int = 10;
    @Native final static int NSNumber_Float = 11;
<A NAME="2"></A>    @Native final static int NSNumber_Double = 12;
    @Native final static int NSString = 13;
    @Native final static int NSURL = 14;
    <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#2',2,'match56-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native final static int NSValue_point = 15;
    @Native final static int NSValue_size = 16;
    @Native final static int NSValue_rectangle = 17;
    @Native final static int NSValue_range = 18;
    @Native final static int NSObject = 19; /* id */

    int type;
    long[] longArray;
    int[] intArray;
    String[] stringArray</B></FONT>;
    MacVariant[] variantArray; /* Used by NSAttributedString and NSDictionary */
    float float1;
    float float2;
    float float3;
    float float4;
    int int1;
    int int2;
    String string;
    long long1;
    double double1;

    /* Used when the Variant represents an attribute within a NSAttributedString */
    int location;
    int length;
    long key;

    static MacVariant createNSArray(Object result) {
        MacVariant variant = new MacVariant();
        variant.type = NSArray_id;
        variant.longArray = (long[])result;
        return variant;
    }

    static MacVariant createNSObject(Object result) {
        MacVariant variant = new MacVariant();
        variant.type = NSObject;
        variant.long1 = (Long)result;
        return variant;
    }

    static MacVariant createNSString(Object result) {
        MacVariant variant = new MacVariant();
        variant.type = NSString;
        variant.string = (String)result;
        return variant;
    }

    static MacVariant createNSAttributedString(Object result) {
        MacVariant variant = new MacVariant();
        variant.type = NSAttributedString;
        variant.string = (String)result;
        return variant;
    }

    static MacVariant createNSDate(Object result) {
        /* Note: [NSDate dateWithTimeIntervalSince1970] used natively
         * takes the number of seconds from the first instant of 1 January 1970, GMT.
         */
        MacVariant variant = new MacVariant();
        variant.type = NSDate;
        variant.long1 = ((LocalDate)result).atStartOfDay(ZoneId.systemDefault()).toEpochSecond();
        return variant;
    }

    static MacVariant createNSValueForSize(Object result) {
        Bounds bounds = (Bounds)result;
        MacVariant variant = new MacVariant();
        variant.type = NSValue_size;
        variant.float1 = (float)bounds.getWidth();
        variant.float2 = (float)bounds.getHeight();
        return variant;
    }

    static MacVariant createNSValueForPoint(Object result) {
        Bounds bounds = (Bounds)result;
        MacVariant variant = new MacVariant();
        variant.type = NSValue_point;
        variant.float1 = (float)bounds.getMinX();
        variant.float2 = (float)bounds.getMinY();
        return variant;
    }

    static MacVariant createNSValueForRectangle(Object result) {
        Bounds bounds = (Bounds)result;
        MacVariant variant = new MacVariant();
        variant.type = NSValue_rectangle;
        variant.float1 = (float)bounds.getMinX();
        variant.float2 = (float)bounds.getMinY();
        variant.float3 = (float)bounds.getWidth();
        variant.float4 = (float)bounds.getHeight();
        return variant;
    }

    static MacVariant createNSValueForRange(Object result) {
        int[] range = (int[])result;
        MacVariant variant = new MacVariant();
        variant.type = NSValue_range;
        variant.int1 = range[0];
        variant.int2 = range[1];
        return variant;
    }

    static MacVariant createNSNumberForBoolean(Object result) {
        Boolean value = (Boolean)result;
        MacVariant variant = new MacVariant();
        variant.type = NSNumber_Boolean;
        variant.int1 = value ? 1 : 0;
        return variant;
    }

    static MacVariant createNSNumberForDouble(Object result) {
        MacVariant variant = new MacVariant();
        variant.type = NSNumber_Double;
        variant.double1 = (Double)result;
        return variant;
    }

    static MacVariant createNSNumberForInt(Object result) {
        MacVariant variant = new MacVariant();
        variant.type = NSNumber_Int;
        variant.int1 = (Integer)result;
        return variant;
    }

    Object getValue() {
        switch (type) {
            case NSNumber_Boolean: return int1 != 0;
            case NSNumber_Int: return int1;
            case NSNumber_Double: return double1;
            case NSArray_id: return longArray;
            case NSArray_int: return intArray;
            case NSValue_range: return new int[] {int1, int2};
            case NSValue_point: return new float[] {float1, float2};
            case NSValue_size: return new float[] {float1, float2};
            case NSValue_rectangle: return new float[] {float1, float2, float3, float4};
            case NSString: return string;
            case NSAttributedString: return string;
            //TODO REST
        }
        return null;
    }

    @Override
    public String toString() {
        Object v = getValue();
        switch (type) {
            case NSArray_id: v = Arrays.toString((long[])v); break;
            case NSArray_int: v = Arrays.toString((int[])v); break;
            case NSValue_range: v = Arrays.toString((int[])v); break;
            case NSAttributedString: v += Arrays.toString(variantArray); break;
            case NSDictionary: v = &quot;keys: &quot; + Arrays.toString(longArray) + &quot; values: &quot; + Arrays.toString(variantArray);
        }
        return &quot;MacVariant type: &quot; + type + &quot; value &quot; + v;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/MX6Cursor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.ui.Size;

import java.io.IOException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;

/** Cursor using a framebuffer overlay on Freescale i.MX6. */
class MX6Cursor extends NativeCursor {

    private int hotspotX;
    private int hotspotY;
    private int offsetX;
    private int offsetY;
    private int cursorX;
    private int cursorY;
    private static final int SHORT_KEY = 0xABAB;
    private static final int CURSOR_WIDTH = 16;
    private static final int CURSOR_HEIGHT = 16;
    private Buffer cursorBuffer;
    private Buffer offsetCursorBuffer;
    private ByteBuffer offsetCursorByteBuffer;
    private int screenWidth;
    private int screenHeight;
    private LinuxSystem system;
    private MXCFBPos pos = new MXCFBPos();
    private MXCFBGblAlpha alpha = new MXCFBGblAlpha();
    private long fd = -1;

    private static class MXCFBColorKey extends C.Structure {
        private final IntBuffer data;
        MXCFBColorKey() {
            b.order(ByteOrder.nativeOrder());
            data = b.asIntBuffer();
<A NAME="27"></A>        }
        @Override
        int sizeof() {
            <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#27',2,'match56-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return 8;
        }
        void setEnable(int enable) {
            data.put(0, enable);
        }
        void setColorKey(int key) {
            data.put(1, key);
        }
    }</B></FONT>

    private static class MXCFBGblAlpha extends C.Structure {
        private final IntBuffer data;
        MXCFBGblAlpha() {
            b.order(ByteOrder.nativeOrder());
            data = b.asIntBuffer();
        }
        @Override
        int sizeof() {
            return 8;
        }
        void setEnable(int enable) {
            data.put(0, enable);
        }
        void setAlpha(int alpha) {
            data.put(1, alpha);
        }
    }

    private static class MXCFBPos extends C.Structure {
        private final ShortBuffer data;
        MXCFBPos() {
            b.order(ByteOrder.nativeOrder());
            data = b.asShortBuffer();
        }
        @Override
        int sizeof() {
            return 4;
        }
        void set(int x, int y) {
            data.put(0, (short) x);
            data.put(1, (short) y);
        }
    }

    MX6Cursor() {
        try {
            SysFS.write(&quot;/sys/class/graphics/fb1/blank&quot;, &quot;0&quot;);
            system = LinuxSystem.getLinuxSystem();
            LinuxSystem.FbVarScreenInfo screen = new LinuxSystem.FbVarScreenInfo();
            fd = system.open(&quot;/dev/fb1&quot;, LinuxSystem.O_RDWR);
            if (fd == -1) {
                throw new IOException(system.getErrorMessage());
            }
            system.ioctl(fd, LinuxSystem.FBIOGET_VSCREENINFO, screen.p);
            screen.setRes(screen.p, CURSOR_WIDTH, CURSOR_HEIGHT);
            screen.setVirtualRes(screen.p, CURSOR_WIDTH, CURSOR_HEIGHT);
            screen.setOffset(screen.p, 0, 0);
            screen.setActivate(screen.p, 0);
            // set up cursor as 16-bit
            screen.setBitsPerPixel(screen.p, 16);
            screen.setRed(screen.p, 5, 11);
            screen.setGreen(screen.p, 6, 5);
            screen.setBlue(screen.p, 5, 0);
            screen.setTransp(screen.p, 0, 0);
            system.ioctl(fd, LinuxSystem.FBIOPUT_VSCREENINFO, screen.p);
            system.ioctl(fd, LinuxSystem.FBIOBLANK, LinuxSystem.FB_BLANK_UNBLANK);

            MXCFBColorKey key = new MXCFBColorKey();
            key.setEnable(1);
            key.setColorKey(((SHORT_KEY &amp; 0xf800)&lt;&lt;8)
                            | ((SHORT_KEY &amp; 0xe000)&lt;&lt;3)
                            | ((SHORT_KEY &amp; 0x07e0)&lt;&lt;5)
                            | ((SHORT_KEY &amp; 0x0600)&gt;&gt;1)
                            | ((SHORT_KEY &amp; 0x001f)&lt;&lt;3)
                            | ((SHORT_KEY &amp; 0x001c)&gt;&gt;2));
            int MXCFB_SET_CLR_KEY = system.IOW('F', 0x22, key.sizeof());
            if (system.ioctl(fd, MXCFB_SET_CLR_KEY, key.p) &lt; 0) {
                throw new IOException(system.strerror(system.errno()));
            }
        } catch (IOException e) {
            if (fd != -1) {
                LinuxSystem.getLinuxSystem().close(fd);
                fd = -1;
            }
            e.printStackTrace();
            System.err.println(&quot;Failed to initialize i.MX6 cursor&quot;);
        }
        NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
        screenWidth = screen.getWidth();
        screenHeight = screen.getHeight();
    }

    @Override
    Size getBestSize() {
        return new Size(CURSOR_WIDTH, CURSOR_HEIGHT);
    }

    @Override
    void setVisibility(boolean visibility) {
        alpha.setEnable(1);
        alpha.setAlpha(visibility ? 255 : 0);
        int MXCFB_SET_GBL_ALPHA = system.IOW('F', 0x21, alpha.sizeof());
        system.ioctl(fd, MXCFB_SET_GBL_ALPHA, alpha.p);
        isVisible = visibility;
        updateImage(true);
    }

    private void updateImage(boolean always) {
        if (isVisible &amp;&amp; cursorBuffer != null) { //skip until cursor is fully initialized
            int newOffsetX, newOffsetY;
            newOffsetX = Math.max(0, CURSOR_WIDTH + cursorX - screenWidth);
            newOffsetY = Math.max(0, CURSOR_HEIGHT + cursorY - screenHeight);
            if (newOffsetX != offsetX || newOffsetY != offsetY || always) {
                NativeCursors.offsetCursor(cursorBuffer, offsetCursorBuffer,
                                           newOffsetX, newOffsetY,
                                           CURSOR_WIDTH, CURSOR_HEIGHT,
                                           16, SHORT_KEY);
                offsetX = newOffsetX;
                offsetY = newOffsetY;
                system.lseek(fd, 0, LinuxSystem.SEEK_SET);
                if (system.write(fd, offsetCursorByteBuffer,
                                 0, offsetCursorByteBuffer.capacity()) &lt; 0) {
                    System.err.println(&quot;Failed to write to i.MX6 cursor: &quot;
                                       + system.getErrorMessage());
                }
            }
        }
    }

    @Override
    void setImage(byte[] cursorImage) {
        // Convert the cursor to the color-keyed format
        ByteBuffer bb = ByteBuffer.allocate(cursorImage.length);
        cursorBuffer = bb.asShortBuffer();
        NativeCursors.colorKeyCursor(cursorImage, cursorBuffer, 16, SHORT_KEY);
        // Create an offset version of the cursor for rendering
        offsetCursorByteBuffer = ByteBuffer.allocateDirect(cursorImage.length);
        offsetCursorByteBuffer.order(ByteOrder.nativeOrder());
        offsetCursorBuffer = offsetCursorByteBuffer.asShortBuffer();
        updateImage(true);
    }

    @Override
    void setLocation(int x, int y) {
        cursorX = x;
        cursorY = y;
        updateImage(false);
        pos.set(x, y);
        int MXCFB_SET_OVERLAY_POS = system.IOWR('F', 0x24, pos.sizeof());
        system.ioctl(fd, MXCFB_SET_OVERLAY_POS, pos.p);
    }

    @Override
    void setHotSpot(int hotspotX, int hotspotY) {
        this.hotspotX = hotspotX;
        this.hotspotY = hotspotY;
    }

    @Override
    void shutdown() {
        setVisibility(false);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/PrismFontLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import com.sun.javafx.scene.text.FontHelper;
import javafx.scene.text.*;
import com.sun.javafx.tk.*;
import java.lang.reflect.Method;
import java.net.URL;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.Properties;

public class PrismFontLoader extends FontLoader {
    private static PrismFontLoader theInstance = new PrismFontLoader();
    public static PrismFontLoader getInstance() { return theInstance; }

    /**
     * Flag to keep track whether the fontCache map has been initialized with
     * the embedded fonts.
     */
    private boolean embeddedFontsLoaded = false;

    Properties loadEmbeddedFontDefinitions() {
        Properties map = new Properties();
        // locate the META-INF directory and search for a fonts.mf
        // located there
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader == null) return map;
        URL u = loader.getResource(&quot;META-INF/fonts.mf&quot;);
        if (u == null) return map;

        // read in the contents of the file
        try (InputStream in = u.openStream()) {
            map.load(in);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return map;
    }

    private void loadEmbeddedFonts() {
        if (!embeddedFontsLoaded) {
            FontFactory fontFactory = getFontFactoryFromPipeline();
            if (!fontFactory.hasPermission()) {
                embeddedFontsLoaded = true;
                return;
            }
            Properties map = loadEmbeddedFontDefinitions();
            Enumeration&lt;?&gt; names = map.keys();
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            while (names.hasMoreElements()) {
                String n = (String)names.nextElement();
                String p = map.getProperty(n);
                if (p.startsWith(&quot;/&quot;)) {
                    p = p.substring(1);
                    try (InputStream in = loader.getResourceAsStream(p)) {
                        fontFactory.loadEmbeddedFont(n, in, 0, true, false);
                    } catch (Exception e) {
                    }
                }
            }
            embeddedFontsLoaded = true;
        }
    }

    private Font[] createFonts(PGFont[] fonts) {
        if (fonts == null || fonts.length == 0) {
            return null;
        }
        Font[] fxFonts = new Font[fonts.length];
        for (int i=0; i&lt;fonts.length; i++) {
            fxFonts[i] = createFont(fonts[i]);
        }
        return fxFonts;
    }

    @Override public Font[] loadFont(InputStream in,
                                     double size,
                                     boolean loadAll) {

        FontFactory factory = getFontFactoryFromPipeline();
        PGFont[] fonts =
            factory.loadEmbeddedFont(null, in, (float)size, true, loadAll);
        return createFonts(fonts);
     }

    @Override public Font[] loadFont(String path,
                                     double size,
                                     boolean loadAll) {

        FontFactory factory = getFontFactoryFromPipeline();
        PGFont[] fonts =
            factory.loadEmbeddedFont(null, path, (float)size, true, loadAll);
        return createFonts(fonts);
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    private Font createFont(PGFont font) {
        return FontHelper.nativeFont(font,
                                     font.getName(),
                                     font.getFamilyName(),
                                     font.getStyleName(),
                                     font.getSize());
    }

    /**
     * Gets all the font families installed on the user's system, including any
     * embedded fonts or SDK fonts.
     *
     * @profile common
     */
    @Override public List&lt;String&gt; getFamilies() {
        loadEmbeddedFonts();
        return Arrays.asList(getFontFactoryFromPipeline().
                             getFontFamilyNames());
    }

    /**
     * Gets the names of all fonts that are installed on the users system,
     * including any embedded fonts and SDK fonts.
     *
     * @profile common
     */
    @Override public List&lt;String&gt; getFontNames() {
        loadEmbeddedFonts();
        return Arrays.asList(getFontFactoryFromPipeline().getFontFullNames());
    }

    /**
     * Gets the names of all fonts in the specified font family that are
     * installed  on the users system, including any embedded fonts and
     * SDK fonts.
     *
     * @profile common
     */
    @Override public List&lt;String&gt; getFontNames(String family) {
        loadEmbeddedFonts();
        return Arrays.asList(getFontFactoryFromPipeline().
                             getFontFullNames(family));
    }

    /**
     * Searches for an appropriate font based on the font family name and
     * weight and posture style. This method is not guaranteed to return
     * a specific font, but does its best to find one that fits the
     * specified requirements.
     *
     * For SDK/runtime fonts, we will attempt to match properties to a
     * SDK/runtime fonts.  If a specific SDK font is not found in the runtime
     * JAR, the font loading will revert to FontFactory default font, rather
     * then finding closest matching available SDK font. This is how SDK font
     * loading was handled in the past.
     *
     * @param family The family of the font
     * @param weight The weight of the font
     * @param posture The posture or posture of the font
     * @param size The point size of the font. This can be a fractional value
     *
     * @profile desktop
     */
    @Override public Font font(String family, FontWeight weight,
                               FontPosture posture, float size) {

        FontFactory fontFactory = getFontFactoryFromPipeline();
        if (!embeddedFontsLoaded &amp;&amp; !fontFactory.isPlatformFont(family)) {
            loadEmbeddedFonts();
        }

        // REMIND. Some day need to have better granularity.

        boolean bold = weight != null &amp;&amp;
                       weight.ordinal() &gt;= FontWeight.BOLD.ordinal();
        boolean italic = posture == FontPosture.ITALIC;
        PGFont prismFont = fontFactory.createFont(family, bold, italic, size);

        // Create Font and set implementation
        Font fxFont = FontHelper.nativeFont(prismFont, prismFont.getName(),
                                            prismFont.getFamilyName(),
                                            prismFont.getStyleName(), size);
        return fxFont;
    }

    /**
     * @param font
     */
    @Override public void loadFont(Font font) {
        FontFactory fontFactory = getFontFactoryFromPipeline();
        String fullName = font.getName();
        if (!embeddedFontsLoaded &amp;&amp; !fontFactory.isPlatformFont(fullName)) {
            loadEmbeddedFonts();
        }

        // find the native Prism Font object based on this JavaFX font. At the
        // conclusion of this method, be sure to set the name, family, and
        // style on the Font object via the setNativeFont method.

        // the Prism font we're trying to find
        PGFont prismFont = fontFactory.createFont(fullName, (float)font.getSize());

        // update the name variable to match what was actually loaded
        String name = prismFont.getName();
<A NAME="6"></A>        String family = prismFont.getFamilyName();
        String style = prismFont.getStyleName();
        FontHelper.setNativeFont(font, prismFont, name, family, style);
    <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#6',2,'match56-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override public FontMetrics getFontMetrics(Font font) {
        if (font != null) {
            PGFont prismFont = (PGFont) FontHelper.getNativeFont(font);
            Metrics metrics = PrismFontUtils.getFontMetrics(prismFont);
            // TODO: what's the difference between ascent and maxAscent?
            float maxAscent = -metrics.getAscent</B></FONT>();//metrics.getMaxAscent();
            float ascent = -metrics.getAscent();
            float xheight = metrics.getXHeight();
            float descent = metrics.getDescent();
            // TODO: what's the difference between descent and maxDescent?
            float maxDescent = metrics.getDescent();//metrics.getMaxDescent();
            float leading = metrics.getLineGap();
            return FontMetrics.createFontMetrics(maxAscent, ascent, xheight, descent, maxDescent, leading, font);
        } else {
            return null; // this should never happen
        }
    }

    @Override public float getCharWidth(char ch, Font font) {
        PGFont prismFont = (PGFont) FontHelper.getNativeFont(font);
        return (float)PrismFontUtils.getCharWidth(prismFont, ch);
    }

    @Override public float getSystemFontSize() {
        // PrismFontFactory is what loads the DLL, so we may as
        // well place the required native method there.
        return PrismFontFactory.getSystemFontSize();
    }

    FontFactory installedFontFactory = null;
    private FontFactory getFontFactoryFromPipeline() {
        if (installedFontFactory != null) {
            return installedFontFactory;
        }
        try {
            Class plc = Class.forName(&quot;com.sun.prism.GraphicsPipeline&quot;);
            Method gpm = plc.getMethod(&quot;getPipeline&quot;, (Class[])null);
            Object plo = gpm.invoke(null);
            Method gfm = plc.getMethod(&quot;getFontFactory&quot;, (Class[])null);
            Object ffo = gfm.invoke(plo);
            installedFontFactory = (FontFactory)ffo;
        } catch (Exception e) {
        }
        return installedFontFactory;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/QuadIterator.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom;

import java.util.NoSuchElementException;

import com.sun.javafx.geom.transform.BaseTransform;

/**
 * A utility class to iterate over the path segments of a quadratic curve
 * segment through the PathIterator interface.
 *
 * @version 10 Feb 1997
 */
class QuadIterator implements PathIterator {
    QuadCurve2D quad;
    BaseTransform transform;
    int index;

    QuadIterator(QuadCurve2D q, BaseTransform tx) {
        this.quad = q;
        this.transform = tx;
    }

    /**
     * Return the winding rule for determining the insideness of the
     * path.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     */
    public int getWindingRule() {
        return WIND_NON_ZERO;
    }

    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
    public boolean isDone() {
        return (index &gt; 1);
    }

    /**
     * Moves the iterator to the next segment of the path forwards
     * along the primary direction of traversal as long as there are
     * more points in that direction.
     */
    public void next() {
        ++index;
    }

    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see #SEG_MOVETO
     * @see #SEG_LINETO
     * @see #SEG_QUADTO
     * @see #SEG_CUBICTO
     * @see #SEG_CLOSE
     */
    public int currentSegment(float[] coords) {
        if (isDone()) {
            throw new NoSuchElementException(&quot;quad iterator iterator out of bounds&quot;);
        }
        int type;
        if (index == 0) {
<A NAME="8"></A>            coords[0] = quad.x1;
            coords[1] = quad.y1;
            type = SEG_MOVETO;
        <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#8',2,'match56-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} else {
            coords[0] = quad.ctrlx;
            coords[1] = quad.ctrly;
            coords[2] = quad.x2;
            coords[3] = quad.y2;
            type = SEG_QUADTO;
        }</B></FONT>
        if (transform != null) {
            transform.transform(coords, 0, coords, 0, index == 0 ? 1 : 2);
        }
        return type;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/QuantumToolkit.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import javafx.application.ConditionalFeature;
import javafx.geometry.Dimension2D;
import javafx.scene.image.Image;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputMethodRequests;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.ImagePattern;
import javafx.scene.paint.LinearGradient;
import javafx.scene.paint.RadialGradient;
import javafx.scene.paint.Stop;
import javafx.scene.shape.ClosePath;
import javafx.scene.shape.CubicCurveTo;
import javafx.scene.shape.FillRule;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.QuadCurveTo;
import javafx.scene.shape.SVGPath;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;
import javafx.stage.FileChooser;
import javafx.stage.Modality;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import java.io.File;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import com.sun.glass.ui.Application;
import com.sun.glass.ui.Clipboard;
import com.sun.glass.ui.ClipboardAssistance;
import com.sun.glass.ui.CommonDialogs;
import com.sun.glass.ui.CommonDialogs.FileChooserResult;
import com.sun.glass.ui.EventLoop;
import com.sun.glass.ui.GlassRobot;
import com.sun.glass.ui.Screen;
import com.sun.glass.ui.Timer;
import com.sun.glass.ui.View;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.embed.HostInterface;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.runtime.async.AbstractRemoteResource;
import com.sun.javafx.runtime.async.AsyncOperationListener;
import com.sun.javafx.scene.text.TextLayoutFactory;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.AppletWindow;
import com.sun.javafx.tk.CompletionListener;
import com.sun.javafx.tk.FileChooserType;
import com.sun.javafx.tk.FontLoader;
import com.sun.javafx.tk.ImageLoader;
import com.sun.javafx.tk.PlatformImage;
import com.sun.javafx.tk.RenderJob;
import com.sun.javafx.tk.ScreenConfigurationAccessor;
import com.sun.javafx.tk.TKClipboard;
import com.sun.javafx.tk.TKDragGestureListener;
import com.sun.javafx.tk.TKDragSourceListener;
import com.sun.javafx.tk.TKDropTargetListener;
import com.sun.javafx.tk.TKScene;
import com.sun.javafx.tk.TKScreenConfigurationListener;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.TKSystemMenu;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.BasicStroke;
import com.sun.prism.Graphics;
import com.sun.prism.GraphicsPipeline;
import com.sun.prism.PixelFormat;
import com.sun.prism.RTTexture;
import com.sun.prism.ResourceFactory;
import com.sun.prism.ResourceFactoryListener;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.impl.Disposer;
import com.sun.prism.impl.PrismSettings;
import com.sun.scenario.DelayedRunnable;
import com.sun.scenario.animation.AbstractMasterTimer;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.scenario.effect.impl.prism.PrImage;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.prism.impl.ManagedResource;

public final class QuantumToolkit extends Toolkit {

    public static final boolean verbose =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;quantum.verbose&quot;));

    public static final boolean pulseDebug =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;quantum.pulse&quot;));

    private static final boolean multithreaded =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                // If it is not specified, or it is true, then it should
                // be true. Otherwise it should be false.
                String value = System.getProperty(&quot;quantum.multithreaded&quot;);
                if (value == null) return true;
                final boolean result = Boolean.parseBoolean(value);
                if (verbose) {
                    System.out.println(result ? &quot;Multi-Threading Enabled&quot; : &quot;Multi-Threading Disabled&quot;);
                }
                return result;
            });

    private static boolean debug =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;quantum.debug&quot;));

    private static Integer pulseHZ =
            AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;javafx.animation.pulse&quot;));

    static final boolean liveResize =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                boolean isSWT = &quot;swt&quot;.equals(System.getProperty(&quot;glass.platform&quot;));
                String result = (PlatformUtil.isMac() || PlatformUtil.isWindows()) &amp;&amp; !isSWT ? &quot;true&quot; : &quot;false&quot;;
                return &quot;true&quot;.equals(System.getProperty(&quot;javafx.live.resize&quot;, result));
            });

    static final boolean drawInPaint =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                boolean isSWT = &quot;swt&quot;.equals(System.getProperty(&quot;glass.platform&quot;));
                String result = PlatformUtil.isMac() &amp;&amp; isSWT ? &quot;true&quot; : &quot;false&quot;;
                return &quot;true&quot;.equals(System.getProperty(&quot;javafx.draw.in.paint&quot;, result));});

    private static boolean singleThreaded =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                Boolean result = Boolean.getBoolean(&quot;quantum.singlethreaded&quot;);
                if (/*verbose &amp;&amp;*/ result) {
                    System.out.println(&quot;Warning: Single GUI Threadiong is enabled, FPS should be slower&quot;);
                }
                return result;
            });

    private static boolean noRenderJobs =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                Boolean result = Boolean.getBoolean(&quot;quantum.norenderjobs&quot;);
                if (/*verbose &amp;&amp;*/ result) {
                    System.out.println(&quot;Warning: Quantum will not submit render jobs, nothing should draw&quot;);
                }
                return result;
            });

    private AtomicBoolean           toolkitRunning = new AtomicBoolean(false);
    private AtomicBoolean           animationRunning = new AtomicBoolean(false);
    private AtomicBoolean           nextPulseRequested = new AtomicBoolean(false);
    private AtomicBoolean           pulseRunning = new AtomicBoolean(false);
    private int                     inPulse = 0;
    private CountDownLatch          launchLatch = new CountDownLatch(1);

    final int                       PULSE_INTERVAL = (int)(TimeUnit.SECONDS.toMillis(1L) / getRefreshRate());
    final int                       FULLSPEED_INTERVAL = 1;     // ms
    boolean                         nativeSystemVsync = false;
    private float                   _maxPixelScale;
    private Runnable                pulseRunnable, userRunnable, timerRunnable;
    private Timer                   pulseTimer = null;
    private Thread                  shutdownHook = null;
    private PaintCollector          collector;
    private QuantumRenderer         renderer;
    private GraphicsPipeline        pipeline;

    private ClassLoader             ccl;

    private HashMap&lt;Object,EventLoop&gt; eventLoopMap = null;

    private final PerformanceTracker perfTracker = new PerformanceTrackerImpl();

    @Override public boolean init() {
        /*
         * Glass Mac, X11 need Application.setDeviceDetails to happen prior to Glass Application.Run
         */
        renderer = QuantumRenderer.getInstance();
        collector = PaintCollector.createInstance(this);
        pipeline = GraphicsPipeline.getPipeline();

        /* shutdown the pipeline on System.exit, ^c
         * needed with X11 and Windows, see RT-32501
         */
        shutdownHook = new Thread(&quot;Glass/Prism Shutdown Hook&quot;) {
            @Override public void run() {
                dispose();
            }
        };
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            Runtime.getRuntime().addShutdownHook(shutdownHook);
            return null;
        });
        return true;
    }

    /**
     * This method is invoked by PlatformImpl. It is typically called on the main
     * thread, NOT the JavaFX Application Thread. The userStartupRunnable will
     * be invoked on the JavaFX Application Thread.
     *
     * @param userStartupRunnable A runnable invoked on the JavaFX Application Thread
     *                            that allows the system to perform some startup
     *                            functionality after the toolkit has been initialized.
     */
    @Override public void startup(final Runnable userStartupRunnable) {
        // Save the context class loader of the launcher thread
        ccl = Thread.currentThread().getContextClassLoader();

        try {
            this.userRunnable = userStartupRunnable;

            // Ensure that the toolkit can only be started here
            Application.run(() -&gt; runToolkit());
        } catch (RuntimeException ex) {
            if (verbose) {
                ex.printStackTrace();
            }
            throw ex;
        } catch (Throwable t) {
            if (verbose) {
                t.printStackTrace();
            }
            throw new RuntimeException(t);
        }

        try {
            launchLatch.await();
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }
    }

    // restart the toolkit if previously terminated
    private void assertToolkitRunning() {
        // not implemented
    }

    boolean shouldWaitForRenderingToComplete() {
        return !multithreaded;
    }

    /**
     * Method to initialize the Scene Graph on the JavaFX application thread.
     * Specifically, we will do static initialization for those classes in
     * the javafx.stage, javafx.scene, and javafx.controls packages necessary
     * to allow subsequent construction of the Scene or any Node, including
     * a PopupControl, on a background thread.
     *
     * This method is called on the JavaFX application thread.
     */
    private static void initSceneGraph() {
        // It is both necessary and sufficient to call a static method on the
        // Screen class to allow PopupControl instances to be created on any thread.
        javafx.stage.Screen.getPrimary();
    }

    // Called by Glass from Application.run()
    void runToolkit() {
        Thread user = Thread.currentThread();

        if (!toolkitRunning.getAndSet(true)) {
            user.setName(&quot;JavaFX Application Thread&quot;);
            // Set context class loader to the same as the thread that called startup
            user.setContextClassLoader(ccl);
            setFxUserThread(user);

            // Glass screens were inited in Application.run(), assign adapters
            assignScreensAdapters();
            /*
             *  Glass Application instance is now valid - create the ResourceFactory
             *  on the render thread
             */
            renderer.createResourceFactory();

            pulseRunnable = () -&gt; QuantumToolkit.this.pulseFromQueue();
            timerRunnable = () -&gt; {
                try {
                    QuantumToolkit.this.postPulse();
                } catch (Throwable th) {
                    th.printStackTrace(System.err);
                }
            };
            pulseTimer = Application.GetApplication().createTimer(timerRunnable);

            Application.GetApplication().setEventHandler(new Application.EventHandler() {
                @Override public void handleQuitAction(Application app, long time) {
                    GlassStage.requestClosingAllWindows();
                }

                @Override public boolean handleThemeChanged(String themeName) {
                    return PlatformImpl.setAccessibilityTheme(themeName);
                }
            });
        }
        // Initialize JavaFX scene graph
        initSceneGraph();
        launchLatch.countDown();
        try {
            Application.invokeAndWait(this.userRunnable);

            if (getMasterTimer().isFullspeed()) {
                /*
                 * FULLSPEED_INTVERVAL workaround
                 *
                 * Application.invokeLater(pulseRunnable);
                 */
                pulseTimer.start(FULLSPEED_INTERVAL);
            } else {
                nativeSystemVsync = Screen.getVideoRefreshPeriod() != 0.0;
                if (nativeSystemVsync) {
                    // system supports vsync
                    pulseTimer.start();
                } else {
                    // rely on millisecond resolution timer to provide
                    // nominal pulse sync and use pulse hinting on
                    // synchronous pipelines to fine tune the interval
                    pulseTimer.start(PULSE_INTERVAL);
                }
            }
        } catch (Throwable th) {
            th.printStackTrace(System.err);
        } finally {
            if (PrismSettings.verbose) {
                System.err.println(&quot; vsync: &quot; + PrismSettings.isVsyncEnabled +
                                   &quot; vpipe: &quot; + pipeline.isVsyncSupported());
            }
            PerformanceTracker.logEvent(&quot;Toolkit.startup - finished&quot;);
        }
    }

    /**
     * Runs the specified supplier, releasing the renderLock if needed.
     * This is called by glass event handlers for Window, View, and
     * Accessible.
     * @param &lt;T&gt; the type of the return value
     * @param supplier the supplier to be run
     * @return the return value from calling supplier.get()
     */
    public static &lt;T&gt; T runWithoutRenderLock(Supplier&lt;T&gt; supplier) {
        final boolean locked = ViewPainter.renderLock.isHeldByCurrentThread();
        try {
            if (locked) {
                ViewPainter.renderLock.unlock();
            }
            return supplier.get();
        } finally {
            if (locked) {
                ViewPainter.renderLock.lock();
            }
        }
    }

    /**
     * Runs the specified supplier, first acquiring the renderLock.
     * The lock is released when done.
     * @param &lt;T&gt; the type of the return value
     * @param supplier the supplier to be run
     * @return the return value from calling supplier.get()
     */
    public static &lt;T&gt; T runWithRenderLock(Supplier&lt;T&gt; supplier) {
        ViewPainter.renderLock.lock();
        try {
            return supplier.get();
        } finally {
            ViewPainter.renderLock.unlock();
        }
    }

    boolean hasNativeSystemVsync() {
        return nativeSystemVsync;
    }

    boolean isVsyncEnabled() {
        return (PrismSettings.isVsyncEnabled &amp;&amp;
                pipeline.isVsyncSupported());
    }

    @Override public void checkFxUserThread() {
        super.checkFxUserThread();
        renderer.checkRendererIdle();
    }

    protected static Thread getFxUserThread() {
        return Toolkit.getFxUserThread();
    }

    @Override public Future addRenderJob(RenderJob r) {
        // Do not run any render jobs (this is for benchmarking only)
        if (noRenderJobs) {
            CompletionListener listener = r.getCompletionListener();
            if (r instanceof PaintRenderJob) {
                ((PaintRenderJob)r).getScene().setPainting(false);
            }
            if (listener != null) {
                try {
                    listener.done(r);
                } catch (Throwable th) {
                    th.printStackTrace();
                }
            }
            return null;
        }
        // Run the render job in the UI thread (this is for benchmarking only)
        if (singleThreaded) {
            r.run();
            return null;
        }
        return (renderer.submitRenderJob(r));
    }

    void postPulse() {
        if (toolkitRunning.get() &amp;&amp;
            (animationRunning.get() || nextPulseRequested.get() || collector.hasDirty()) &amp;&amp;
            !setPulseRunning()) {

            Application.invokeLater(pulseRunnable);

            if (debug) {
                System.err.println(&quot;QT.postPulse@(&quot; + System.nanoTime() + &quot;): &quot; + pulseString());
            }
        } else if (debug) {
            System.err.println(&quot;QT.postPulse#(&quot; + System.nanoTime() + &quot;) DROP: &quot; + pulseString());
        }
    }

    private String pulseString() {
        return ((toolkitRunning.get() ? &quot;T&quot; : &quot;t&quot;) +
                (animationRunning.get() ? &quot;A&quot; : &quot;a&quot;) +
                (pulseRunning.get() ? &quot;P&quot; : &quot;p&quot;) +
                (nextPulseRequested.get() ? &quot;N&quot; : &quot;n&quot;) +
                (collector.hasDirty() ? &quot;D&quot; : &quot;d&quot;));
    }

    private boolean setPulseRunning() {
        return (pulseRunning.getAndSet(true));
    }

    private void endPulseRunning() {
        pulseRunning.set(false);
        if (debug) {
            System.err.println(&quot;QT.endPulse: &quot; + System.nanoTime());
        }
    }

    void pulseFromQueue() {
        try {
            pulse();
        } finally {
            endPulseRunning();
        }
    }

    protected void pulse() {
        pulse(true);
    }

    void pulse(boolean collect) {
        try {
            inPulse++;
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.pulseStart();
            }

            if (!toolkitRunning.get()) {
                return;
            }
            nextPulseRequested.set(false);
            if (animationRunnable != null) {
                animationRunning.set(true);
                animationRunnable.run();
            } else {
                animationRunning.set(false);
            }
            firePulse();
            if (collect) collector.renderAll();
        } finally {
            inPulse--;
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.pulseEnd();
            }
        }
    }

    void vsyncHint() {
        if (isVsyncEnabled()) {
            if (debug) {
                System.err.println(&quot;QT.vsyncHint: postPulse: &quot; + System.nanoTime());
            }
            postPulse();
        }
    }

    @Override  public AppletWindow createAppletWindow(long parent, String serverName) {
        GlassAppletWindow parentWindow = new GlassAppletWindow(parent, serverName);
        // Make this the parent window for all future Stages
        WindowStage.setAppletWindow(parentWindow);
        return parentWindow;
    }

    @Override public void closeAppletWindow() {
        GlassAppletWindow gaw = WindowStage.getAppletWindow();
        if (null != gaw) {
            gaw.dispose();
            WindowStage.setAppletWindow(null);
            // any further strong refs will be in the applet itself
        }
    }

    @Override public TKStage createTKStage(Window peerWindow, boolean securityDialog, StageStyle stageStyle, boolean primary, Modality modality, TKStage owner, boolean rtl, AccessControlContext acc) {
        assertToolkitRunning();
        WindowStage stage = new WindowStage(peerWindow, securityDialog, stageStyle, modality, owner);
        stage.setSecurityContext(acc);
        if (primary) {
            stage.setIsPrimary();
        }
        stage.setRTL(rtl);
        stage.init(systemMenu);
        return stage;
    }

    @Override public boolean canStartNestedEventLoop() {
        return inPulse == 0;
    }

    @Override public Object enterNestedEventLoop(Object key) {
        checkFxUserThread();

        if (key == null) {
            throw new NullPointerException();
        }

        if (!canStartNestedEventLoop()) {
            throw new IllegalStateException(&quot;Cannot enter nested loop during animation or layout processing&quot;);
        }

        if (eventLoopMap == null) {
            eventLoopMap = new HashMap&lt;&gt;();
        }
        if (eventLoopMap.containsKey(key)) {
            throw new IllegalArgumentException(
                    &quot;Key already associated with a running event loop: &quot; + key);
        }
        EventLoop eventLoop = Application.GetApplication().createEventLoop();
        eventLoopMap.put(key, eventLoop);

        Object ret = eventLoop.enter();

        if (!isNestedLoopRunning()) {
            notifyLastNestedLoopExited();
        }

        return ret;
    }

    @Override public void exitNestedEventLoop(Object key, Object rval) {
        checkFxUserThread();

        if (key == null) {
            throw new NullPointerException();
        }
        if (eventLoopMap == null || !eventLoopMap.containsKey(key)) {
            throw new IllegalArgumentException(
                    &quot;Key not associated with a running event loop: &quot; + key);
        }
        EventLoop eventLoop = eventLoopMap.get(key);
        eventLoopMap.remove(key);
        eventLoop.leave(rval);
    }

    @Override public void exitAllNestedEventLoops() {
        checkFxUserThread();
        for (EventLoop eventLoop : eventLoopMap.values()) {
            eventLoop.leave(null);
        }
        eventLoopMap.clear();
        eventLoopMap = null;
    }

    @Override public TKStage createTKPopupStage(Window peerWindow,
                                                StageStyle popupStyle,
                                                TKStage owner,
                                                AccessControlContext acc) {
        assertToolkitRunning();
        boolean securityDialog = owner instanceof WindowStage ?
                ((WindowStage)owner).isSecurityDialog() : false;
        WindowStage stage = new WindowStage(peerWindow, securityDialog, popupStyle, null, owner);
        stage.setSecurityContext(acc);
        stage.setIsPopup();
        stage.init(systemMenu);
        return stage;
    }

    @Override public TKStage createTKEmbeddedStage(HostInterface host, AccessControlContext acc) {
        assertToolkitRunning();
        EmbeddedStage stage = new EmbeddedStage(host);
        stage.setSecurityContext(acc);
        return stage;
    }

    private static ScreenConfigurationAccessor screenAccessor =
        new ScreenConfigurationAccessor() {
            @Override public int getMinX(Object obj) {
               return ((Screen)obj).getX();
            }
            @Override public int getMinY(Object obj) {
                return ((Screen)obj).getY();
            }
            @Override public int getWidth(Object obj) {
                return ((Screen)obj).getWidth();
            }
            @Override public int getHeight(Object obj) {
                return ((Screen)obj).getHeight();
            }
            @Override public int getVisualMinX(Object obj) {
                return ((Screen)obj).getVisibleX();
            }
            @Override public int getVisualMinY(Object obj) {
                return ((Screen)obj).getVisibleY();
            }
            @Override public int getVisualWidth(Object obj) {
                return ((Screen)obj).getVisibleWidth();
            }
            @Override public int getVisualHeight(Object obj) {
                return ((Screen)obj).getVisibleHeight();
            }
            @Override public float getDPI(Object obj) {
                return ((Screen)obj).getResolutionX();
            }
            @Override public float getRecommendedOutputScaleX(Object obj) {
                return ((Screen)obj).getRecommendedOutputScaleX();
            }
            @Override public float getRecommendedOutputScaleY(Object obj) {
                return ((Screen)obj).getRecommendedOutputScaleY();
            }
        };

    @Override public ScreenConfigurationAccessor
                    setScreenConfigurationListener(final TKScreenConfigurationListener listener) {
        Screen.setEventHandler(new Screen.EventHandler() {
            @Override public void handleSettingsChanged() {
                notifyScreenListener(listener);
            }
        });
        return screenAccessor;
    }

    private static void assignScreensAdapters() {
        GraphicsPipeline pipeline = GraphicsPipeline.getPipeline();
        for (Screen screen : Screen.getScreens()) {
            screen.setAdapterOrdinal(pipeline.getAdapterOrdinal(screen));
        }
    }

    private static void notifyScreenListener(TKScreenConfigurationListener listener) {
        assignScreensAdapters();
        listener.screenConfigurationChanged();
    }

    @Override public Object getPrimaryScreen() {
        return Screen.getMainScreen();
    }

    @Override public List&lt;?&gt; getScreens() {
        return Screen.getScreens();
    }

    @Override
    public ScreenConfigurationAccessor getScreenConfigurationAccessor() {
        return screenAccessor;
    }

    @Override
    public PerformanceTracker getPerformanceTracker() {
        return perfTracker;
    }

    @Override
    public PerformanceTracker createPerformanceTracker() {
        return new PerformanceTrackerImpl();
    }

    // Only currently called from the loadImage method below.  We do not
    // necessarily know what the worst render scale we will ever see is
    // because the user has control over that, but we should be loading
    // all dpi variants of an image at all times anyway and then using
    // whichever one is needed to respond to a given rendering request
    // rather than predetermining which one to use up front.  If we switch
    // to making that decision at render time then this method can go away.
    private float getMaxRenderScale() {
        if (_maxPixelScale == 0) {
            for (Object o : getScreens()) {
                _maxPixelScale = Math.max(_maxPixelScale, ((Screen) o).getRecommendedOutputScaleX());
                _maxPixelScale = Math.max(_maxPixelScale, ((Screen) o).getRecommendedOutputScaleY());
            }
        }
        return _maxPixelScale;
    }

    @Override public ImageLoader loadImage(String url, double width, double height, boolean preserveRatio, boolean smooth) {
        return new PrismImageLoader2(url, width, height, preserveRatio, getMaxRenderScale(), smooth);
    }

    @Override public ImageLoader loadImage(InputStream stream, double width, double height,
                                           boolean preserveRatio, boolean smooth) {
        return new PrismImageLoader2(stream, width, height, preserveRatio, smooth);
    }

    @Override public AbstractRemoteResource&lt;? extends ImageLoader&gt; loadImageAsync(
            AsyncOperationListener listener, String url,
            double width, double height, boolean preserveRatio, boolean smooth) {
        return new PrismImageLoader2.AsyncImageLoader(listener, url, width, height, preserveRatio, smooth);
    }

    // Note that this method should only be called by PlatformImpl.runLater
    // It should not be called directly by other FX code since the underlying
    // glass invokeLater method is not thread-safe with respect to toolkit
    // shutdown. Calling Platform.runLater *is* thread-safe even when the
    // toolkit is shutting down.
    @Override public void defer(Runnable runnable) {
        if (!toolkitRunning.get()) return;

        Application.invokeLater(runnable);
    }

    @Override public void exit() {
        // This method must run on the FX application thread
        checkFxUserThread();

        // Turn off pulses so no extraneous runnables are submitted
        pulseTimer.stop();

        // We need to wait for the last frame to finish so that the renderer
        // is not running while we are shutting down glass.
        PaintCollector.getInstance().waitForRenderingToComplete();

        notifyShutdownHooks();

        runWithRenderLock(() -&gt; {
            //TODO - should update glass scene view state
            //TODO - doesn't matter because we are exiting
            Application app = Application.GetApplication();
            app.terminate();
            return null;
        });

        dispose();

        super.exit();
    }

    public void dispose() {
        if (toolkitRunning.compareAndSet(true, false)) {
            pulseTimer.stop();
            renderer.stopRenderer();

            try {
                AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                    Runtime.getRuntime().removeShutdownHook(shutdownHook);
                    return null;
                });
            } catch (IllegalStateException ignore) {
                // throw when shutdown hook already removed
            }
        }
    }

    @Override public boolean isForwardTraversalKey(KeyEvent e) {
        return (e.getCode() == KeyCode.TAB)
                   &amp;&amp; (e.getEventType() == KeyEvent.KEY_PRESSED)
                   &amp;&amp; !e.isShiftDown();
    }

    @Override public boolean isBackwardTraversalKey(KeyEvent e) {
        return (e.getCode() == KeyCode.TAB)
                   &amp;&amp; (e.getEventType() == KeyEvent.KEY_PRESSED)
                   &amp;&amp; e.isShiftDown();
    }

    private Map&lt;Object, Object&gt; contextMap = Collections.synchronizedMap(new HashMap&lt;&gt;());
    @Override public Map&lt;Object, Object&gt; getContextMap() {
        return contextMap;
    }

    @Override public int getRefreshRate() {
        if (pulseHZ == null) {
            return 60;
        } else {
            return pulseHZ;
        }
    }

    private DelayedRunnable animationRunnable;
    @Override public void setAnimationRunnable(DelayedRunnable animationRunnable) {
        if (animationRunnable != null) {
            animationRunning.set(true);
        }
        this.animationRunnable = animationRunnable;
    }

    @Override public void requestNextPulse() {
        nextPulseRequested.set(true);
    }

    @Override public void waitFor(Task t) {
        if (t.isFinished()) {
            return;
        }
    }

    @Override protected Object createColorPaint(Color color) {
        return new com.sun.prism.paint.Color(
                (float)color.getRed(), (float)color.getGreen(),
                (float)color.getBlue(), (float)color.getOpacity());
    }

    private com.sun.prism.paint.Color toPrismColor(Color color) {
        return (com.sun.prism.paint.Color) Toolkit.getPaintAccessor().getPlatformPaint(color);
    }

    private List&lt;com.sun.prism.paint.Stop&gt; convertStops(List&lt;Stop&gt; paintStops) {
        List&lt;com.sun.prism.paint.Stop&gt; stops =
            new ArrayList&lt;&gt;(paintStops.size());
        for (Stop s : paintStops) {
            stops.add(new com.sun.prism.paint.Stop(toPrismColor(s.getColor()),
                                                   (float) s.getOffset()));
        }
        return stops;
    }

    @Override protected Object createLinearGradientPaint(LinearGradient paint) {
        int cmi = com.sun.prism.paint.Gradient.REPEAT;
        CycleMethod cycleMethod = paint.getCycleMethod();
        if (cycleMethod == CycleMethod.NO_CYCLE) {
            cmi = com.sun.prism.paint.Gradient.PAD;
        } else if (cycleMethod == CycleMethod.REFLECT) {
            cmi = com.sun.prism.paint.Gradient.REFLECT;
        }
        // TODO: extract colors/offsets and pass them in directly...
        List&lt;com.sun.prism.paint.Stop&gt; stops = convertStops(paint.getStops());
        return new com.sun.prism.paint.LinearGradient(
            (float)paint.getStartX(), (float)paint.getStartY(), (float)paint.getEndX(), (float)paint.getEndY(),
            null, paint.isProportional(), cmi, stops);
    }

    @Override
    protected Object createRadialGradientPaint(RadialGradient paint) {
        float cx = (float)paint.getCenterX();
        float cy = (float)paint.getCenterY();
        float fa = (float)paint.getFocusAngle();
        float fd = (float)paint.getFocusDistance();

        int cmi = 0;
        if (paint.getCycleMethod() == CycleMethod.NO_CYCLE) {
            cmi = com.sun.prism.paint.Gradient.PAD;
        } else if (paint.getCycleMethod() == CycleMethod.REFLECT) {
            cmi = com.sun.prism.paint.Gradient.REFLECT;
        } else {
            cmi = com.sun.prism.paint.Gradient.REPEAT;
        }

        // TODO: extract colors/offsets and pass them in directly...
        List&lt;com.sun.prism.paint.Stop&gt; stops = convertStops(paint.getStops());
        return new com.sun.prism.paint.RadialGradient(cx, cy, fa, fd,
                (float)paint.getRadius(), null, paint.isProportional(), cmi, stops);
    }

    @Override
    protected Object createImagePatternPaint(ImagePattern paint) {
        if (paint.getImage() == null) {
            return com.sun.prism.paint.Color.TRANSPARENT;
        } else {
            return new com.sun.prism.paint.ImagePattern(
                    (com.sun.prism.Image) Toolkit.getImageAccessor().getPlatformImage(paint.getImage()),
                    (float)paint.getX(),
                    (float)paint.getY(),
                    (float)paint.getWidth(),
                    (float)paint.getHeight(),
                    paint.isProportional(),
                    Toolkit.getPaintAccessor().isMutable(paint));
        }
    }

    static BasicStroke tmpStroke = new BasicStroke();
    private void initStroke(StrokeType pgtype, double strokewidth,
                            StrokeLineCap pgcap,
                            StrokeLineJoin pgjoin, float miterLimit,
                            float[] dashArray, float dashOffset)
    {
        int type;
        if (pgtype == StrokeType.CENTERED) {
            type = BasicStroke.TYPE_CENTERED;
        } else if (pgtype == StrokeType.INSIDE) {
            type = BasicStroke.TYPE_INNER;
        } else {
            type = BasicStroke.TYPE_OUTER;
        }

        int cap;
        if (pgcap == StrokeLineCap.BUTT) {
            cap = BasicStroke.CAP_BUTT;
        } else if (pgcap == StrokeLineCap.SQUARE) {
            cap = BasicStroke.CAP_SQUARE;
        } else {
            cap = BasicStroke.CAP_ROUND;
        }

        int join;
        if (pgjoin == StrokeLineJoin.BEVEL) {
            join = BasicStroke.JOIN_BEVEL;
        } else if (pgjoin == StrokeLineJoin.MITER) {
            join = BasicStroke.JOIN_MITER;
        } else {
            join = BasicStroke.JOIN_ROUND;
        }

        tmpStroke.set(type, (float) strokewidth, cap, join, miterLimit);
        if ((dashArray != null) &amp;&amp; (dashArray.length &gt; 0)) {
            tmpStroke.set(dashArray, dashOffset);
        } else {
            tmpStroke.set((float[])null, 0);
        }
    }

    @Override
    public void accumulateStrokeBounds(Shape shape, float bbox[],
                                       StrokeType pgtype,
                                       double strokewidth,
                                       StrokeLineCap pgcap,
                                       StrokeLineJoin pgjoin,
                                       float miterLimit,
                                       BaseTransform tx)
    {

        initStroke(pgtype, strokewidth, pgcap, pgjoin, miterLimit, null, 0);
        if (tx.isTranslateOrIdentity()) {
            tmpStroke.accumulateShapeBounds(bbox, shape, tx);
        } else {
            Shape.accumulate(bbox, tmpStroke.createStrokedShape(shape), tx);
        }
    }

    @Override
    public boolean strokeContains(Shape shape, double x, double y,
                                  StrokeType pgtype,
                                  double strokewidth,
                                  StrokeLineCap pgcap,
                                  StrokeLineJoin pgjoin,
                                  float miterLimit)
    {
        initStroke(pgtype, strokewidth, pgcap, pgjoin, miterLimit, null, 0);
        // TODO: The contains testing could be done directly without creating a Shape
        return tmpStroke.createStrokedShape(shape).contains((float) x, (float) y);
    }

    @Override
    public Shape createStrokedShape(Shape shape,
                                    StrokeType pgtype,
                                    double strokewidth,
                                    StrokeLineCap pgcap,
                                    StrokeLineJoin pgjoin,
                                    float miterLimit,
                                    float[] dashArray,
                                    float dashOffset) {
        initStroke(pgtype, strokewidth, pgcap, pgjoin, miterLimit,
                   dashArray, dashOffset);
        return tmpStroke.createStrokedShape(shape);
    }

    @Override public Dimension2D getBestCursorSize(int preferredWidth, int preferredHeight) {
        return CursorUtils.getBestCursorSize(preferredWidth, preferredHeight);
    }

    @Override public int getMaximumCursorColors() {
        return 2;
    }

    @Override public int getKeyCodeForChar(String character) {
        return (character.length() == 1)
                ? com.sun.glass.events.KeyEvent.getKeyCodeForChar(
                          character.charAt(0))
                : com.sun.glass.events.KeyEvent.VK_UNDEFINED;
    }

    @Override public PathElement[] convertShapeToFXPath(Object shape) {
        if (shape == null) {
            return new PathElement[0];
        }
        List&lt;PathElement&gt; elements = new ArrayList&lt;&gt;();
        // iterate over the shape and turn it into a series of path
        // elements
        com.sun.javafx.geom.Shape geomShape = (com.sun.javafx.geom.Shape) shape;
        PathIterator itr = geomShape.getPathIterator(null);
        PathIteratorHelper helper = new PathIteratorHelper(itr);
        PathIteratorHelper.Struct struct = new PathIteratorHelper.Struct();

        while (!helper.isDone()) {
            // true if WIND_EVEN_ODD, false if WIND_NON_ZERO
            boolean windEvenOdd = helper.getWindingRule() == PathIterator.WIND_EVEN_ODD;
            int type = helper.currentSegment(struct);
            PathElement el;
            if (type == PathIterator.SEG_MOVETO) {
                el = new MoveTo(struct.f0, struct.f1);
            } else if (type == PathIterator.SEG_LINETO) {
                el = new LineTo(struct.f0, struct.f1);
            } else if (type == PathIterator.SEG_QUADTO) {
                el = new QuadCurveTo(
                    struct.f0,
                    struct.f1,
                    struct.f2,
                    struct.f3);
            } else if (type == PathIterator.SEG_CUBICTO) {
                el = new CubicCurveTo (
                    struct.f0,
                    struct.f1,
                    struct.f2,
                    struct.f3,
                    struct.f4,
                    struct.f5);
            } else if (type == PathIterator.SEG_CLOSE) {
                el = new ClosePath();
            } else {
                throw new IllegalStateException(&quot;Invalid element type: &quot; + type);
            }
            helper.next();
            elements.add(el);
        }

        return elements.toArray(new PathElement[elements.size()]);
    }

    @Override public Filterable toFilterable(Image img) {
        return PrImage.create((com.sun.prism.Image) Toolkit.getImageAccessor().getPlatformImage(img));
    }

    @Override public FilterContext getFilterContext(Object config) {
        if (config == null || (!(config instanceof com.sun.glass.ui.Screen))) {
            return PrFilterContext.getDefaultInstance();
        }
        Screen screen = (Screen)config;
        return PrFilterContext.getInstance(screen);
    }

    @Override public AbstractMasterTimer getMasterTimer() {
        return MasterTimer.getInstance();
    }

    @Override public FontLoader getFontLoader() {
        return com.sun.javafx.font.PrismFontLoader.getInstance();
    }

    @Override public TextLayoutFactory getTextLayoutFactory() {
        return com.sun.javafx.text.PrismTextLayoutFactory.getFactory();
    }

    @Override public Object createSVGPathObject(SVGPath svgpath) {
        int windingRule = svgpath.getFillRule() == FillRule.NON_ZERO ? PathIterator.WIND_NON_ZERO : PathIterator.WIND_EVEN_ODD;
        Path2D path = new Path2D(windingRule);
        path.appendSVGPath(svgpath.getContent());
        return path;
    }

    @Override public Path2D createSVGPath2D(SVGPath svgpath) {
        int windingRule = svgpath.getFillRule() == FillRule.NON_ZERO ? PathIterator.WIND_NON_ZERO : PathIterator.WIND_EVEN_ODD;
        Path2D path = new Path2D(windingRule);
        path.appendSVGPath(svgpath.getContent());
        return path;
    }

    @Override public boolean imageContains(Object image, float x, float y) {
        if (image == null) {
            return false;
        }

        com.sun.prism.Image pImage = (com.sun.prism.Image)image;
        int intX = (int)x + pImage.getMinX();
        int intY = (int)y + pImage.getMinY();

        if (pImage.isOpaque()) {
            return true;
        }

        if (pImage.getPixelFormat() == PixelFormat.INT_ARGB_PRE) {
            IntBuffer ib = (IntBuffer) pImage.getPixelBuffer();
            int index = intX + intY * pImage.getRowLength();
            if (index &gt;= ib.limit()) {
                return false;
            } else {
                return (ib.get(index) &amp; 0xff000000) != 0;
            }
        } else if (pImage.getPixelFormat() == PixelFormat.BYTE_BGRA_PRE) {
            ByteBuffer bb = (ByteBuffer) pImage.getPixelBuffer();
            int index = intX * pImage.getBytesPerPixelUnit() + intY * pImage.getScanlineStride() + 3;
            if (index &gt;= bb.limit()) {
                return false;
            } else {
                return (bb.get(index) &amp; 0xff) != 0;
            }
        } else if (pImage.getPixelFormat() == PixelFormat.BYTE_ALPHA) {
            ByteBuffer bb = (ByteBuffer) pImage.getPixelBuffer();
            int index = intX * pImage.getBytesPerPixelUnit() + intY * pImage.getScanlineStride();
            if (index &gt;= bb.limit()) {
                return false;
            } else {
                return (bb.get(index) &amp; 0xff) != 0;
            }
        }
        return true;
    }

    @Override
    public boolean isNestedLoopRunning() {
        return Application.isNestedLoopRunning();
    }

    @Override
    public boolean isSupported(ConditionalFeature feature) {
        switch (feature) {
            case SCENE3D:
                return GraphicsPipeline.getPipeline().is3DSupported();
            case EFFECT:
                return GraphicsPipeline.getPipeline().isEffectSupported();
            case SHAPE_CLIP:
                return true;
            case INPUT_METHOD:
                return Application.GetApplication().supportsInputMethods();
            case TRANSPARENT_WINDOW:
                return Application.GetApplication().supportsTransparentWindows();
            case UNIFIED_WINDOW:
                return Application.GetApplication().supportsUnifiedWindows();
            case TWO_LEVEL_FOCUS:
                return Application.GetApplication().hasTwoLevelFocus();
            case VIRTUAL_KEYBOARD:
                return Application.GetApplication().hasVirtualKeyboard();
            case INPUT_TOUCH:
                return Application.GetApplication().hasTouch();
            case INPUT_MULTITOUCH:
                return Application.GetApplication().hasMultiTouch();
            case INPUT_POINTER:
                return Application.GetApplication().hasPointer();
            default:
                return false;
        }
    }

    @Override
    public boolean isMSAASupported() {
        return  GraphicsPipeline.getPipeline().isMSAASupported();
    }

    static TransferMode clipboardActionToTransferMode(final int action) {
        switch (action) {
            case Clipboard.ACTION_NONE:
                return null;
            case Clipboard.ACTION_COPY:
            //IE drop action for URL copy
            case Clipboard.ACTION_COPY | Clipboard.ACTION_REFERENCE:
                return TransferMode.COPY;
            case Clipboard.ACTION_MOVE:
            //IE drop action for URL move
            case Clipboard.ACTION_MOVE | Clipboard.ACTION_REFERENCE:
                return TransferMode.MOVE;
            case Clipboard.ACTION_REFERENCE:
                return TransferMode.LINK;
            case Clipboard.ACTION_ANY:
                return TransferMode.COPY; // select a reasonable trasnfer mode as workaround until RT-22840
        }
        return null;
    }

    private QuantumClipboard clipboard;
    @Override public TKClipboard getSystemClipboard() {
        if (clipboard == null) {
            clipboard = QuantumClipboard.getClipboardInstance(new ClipboardAssistance(com.sun.glass.ui.Clipboard.SYSTEM));
        }
        return clipboard;
    }

    private GlassSystemMenu systemMenu = new GlassSystemMenu();
    @Override public TKSystemMenu getSystemMenu() {
        return systemMenu;
    }

    @Override public TKClipboard getNamedClipboard(String name) {
        return null;
    }

    @Override public void startDrag(TKScene scene, Set&lt;TransferMode&gt; tm, TKDragSourceListener l, Dragboard dragboard) {
        if (dragboard == null) {
            throw new IllegalArgumentException(&quot;dragboard should not be null&quot;);
        }

        GlassScene view = (GlassScene)scene;
        view.setTKDragSourceListener(l);

        QuantumClipboard gc = (QuantumClipboard) DragboardHelper.getPeer(dragboard);
        gc.setSupportedTransferMode(tm);
        gc.flush();

        // flush causes a modal DnD event loop, when we return, close the clipboard
        gc.close();
    }

    @Override public void enableDrop(TKScene s, TKDropTargetListener l) {

        assert s instanceof GlassScene;

        GlassScene view = (GlassScene)s;
        view.setTKDropTargetListener(l);
    }

    @Override public void registerDragGestureListener(TKScene s, Set&lt;TransferMode&gt; tm, TKDragGestureListener l) {

        assert s instanceof GlassScene;

        GlassScene view = (GlassScene)s;
        view.setTKDragGestureListener(l);
    }

    @Override
    public void installInputMethodRequests(TKScene scene, InputMethodRequests requests) {

        assert scene instanceof GlassScene;

        GlassScene view = (GlassScene)scene;
        view.setInputMethodRequests(requests);
    }

    static class QuantumImage implements com.sun.javafx.tk.ImageLoader, ResourceFactoryListener {

        // cache rt here
        private com.sun.prism.RTTexture rt;
        private com.sun.prism.Image image;
        private ResourceFactory rf;

        QuantumImage(com.sun.prism.Image image) {
            this.image = image;
        }

        RTTexture getRT(int w, int h, ResourceFactory rfNew) {
            boolean rttOk = rt != null &amp;&amp; rf == rfNew &amp;&amp;
                    rt.getContentWidth() == w &amp;&amp; rt.getContentHeight() == h;
            if (rttOk) {
                rt.lock();
                if (rt.isSurfaceLost()) {
                    rttOk = false;
                }
            }

            if (!rttOk) {
                if (rt != null) {
                    rt.dispose();
                }
                if (rf != null) {
                    rf.removeFactoryListener(this);
                    rf = null;
                }
                rt = rfNew.createRTTexture(w, h, WrapMode.CLAMP_TO_ZERO);
                if (rt != null) {
                    rf = rfNew;
                    rf.addFactoryListener(this);
                }
            }

            return rt;
        }

        void dispose() {
            if (rt != null) {
                rt.dispose();
                rt = null;
            }
        }

        void setImage(com.sun.prism.Image img) {
            image = img;
        }

        @Override
        public Exception getException() {
            return (image == null)
                    ? new IllegalStateException(&quot;Unitialized image&quot;)
                    : null;
        }
        @Override
        public int getFrameCount() { return 1; }
        @Override
        public PlatformImage getFrame(int index) { return image; }
        @Override
        public int getFrameDelay(int index) { return 0; }
        @Override
        public int getLoopCount() { return 0; }
        @Override
        public double getWidth() { return image.getWidth(); }
        @Override
        public double getHeight() { return image.getHeight(); }
        @Override
        public void factoryReset() { dispose(); }
        @Override
        public void factoryReleased() { dispose(); }
    }

    @Override public ImageLoader loadPlatformImage(Object platformImage) {
        if (platformImage instanceof QuantumImage) {
            return (QuantumImage)platformImage;
        }

        if (platformImage instanceof com.sun.prism.Image) {
            return new QuantumImage((com.sun.prism.Image) platformImage);
        }

        throw new UnsupportedOperationException(&quot;unsupported class for loadPlatformImage&quot;);
    }

    @Override
    public PlatformImage createPlatformImage(int w, int h) {
        ByteBuffer bytebuf = ByteBuffer.allocate(w * h * 4);
        return com.sun.prism.Image.fromByteBgraPreData(bytebuf, w, h);
    }

    @Override
    public Object renderToImage(ImageRenderingContext p) {
        Object saveImage = p.platformImage;
        final ImageRenderingContext params = p;
        final com.sun.prism.paint.Paint currentPaint = p.platformPaint instanceof com.sun.prism.paint.Paint ?
                (com.sun.prism.paint.Paint)p.platformPaint : null;

        RenderJob re = new RenderJob(new Runnable() {

            private com.sun.prism.paint.Color getClearColor() {
                if (currentPaint == null) {
                    return com.sun.prism.paint.Color.WHITE;
                } else if (currentPaint.getType() == com.sun.prism.paint.Paint.Type.COLOR) {
                    return (com.sun.prism.paint.Color) currentPaint;
                } else if (currentPaint.isOpaque()) {
                    return com.sun.prism.paint.Color.TRANSPARENT;
                } else {
                    return com.sun.prism.paint.Color.WHITE;
                }
            }

            private void draw(Graphics g, int x, int y, int w, int h) {
                g.setLights(params.lights);
                g.setDepthBuffer(params.depthBuffer);

                g.clear(getClearColor());
                if (currentPaint != null &amp;&amp;
                        currentPaint.getType() != com.sun.prism.paint.Paint.Type.COLOR) {
                    g.getRenderTarget().setOpaque(currentPaint.isOpaque());
                    g.setPaint(currentPaint);
                    g.fillQuad(0, 0, w, h);
                }

                // Set up transform
                if (x != 0 || y != 0) {
                    g.translate(-x, -y);
                }
                if (params.transform != null) {
                    g.transform(params.transform);
                }

                if (params.root != null) {
                    if (params.camera != null) {
                        g.setCamera(params.camera);
                    }
                    NGNode ngNode = params.root;
                    ngNode.render(g);
                }

            }

            @Override
            public void run() {

                ResourceFactory rf = GraphicsPipeline.getDefaultResourceFactory();

                if (!rf.isDeviceReady()) {
                    return;
                }

                int x = params.x;
                int y = params.y;
                int w = params.width;
                int h = params.height;

                if (w &lt;= 0 || h &lt;= 0) {
                    return;
                }

                boolean errored = false;
                try {
                    QuantumImage pImage = (params.platformImage instanceof QuantumImage) ?
                            (QuantumImage)params.platformImage : new QuantumImage(null);

                    com.sun.prism.RTTexture rt = pImage.getRT(w, h, rf);

                    if (rt == null) {
                        return;
                    }

                    Graphics g = rt.createGraphics();

                    draw(g, x, y, w, h);

                    int[] pixels = pImage.rt.getPixels();

                    if (pixels != null) {
                        pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(pixels, w, h));
                    } else {
                        IntBuffer ib = IntBuffer.allocate(w*h);
                        if (pImage.rt.readPixels(ib, pImage.rt.getContentX(),
                                pImage.rt.getContentY(), w, h))
                        {
                            pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(ib, w, h));
                        } else {
                            pImage.dispose();
                            pImage = null;
                        }
                    }

                    rt.unlock();

                    params.platformImage = pImage;

                } catch (Throwable t) {
                    errored = true;
                    t.printStackTrace(System.err);
                } finally {
                    Disposer.cleanUp();
                    rf.getTextureResourcePool().freeDisposalRequestedAndCheckResources(errored);
                }
            }
        });

        final CountDownLatch latch = new CountDownLatch(1);
        re.setCompletionListener(job -&gt; latch.countDown());
        addRenderJob(re);

        do {
            try {
                latch.await();
                break;
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        } while (true);

        Object image = params.platformImage;
        params.platformImage = saveImage;

        return image;
    }

    @Override
    public FileChooserResult showFileChooser(final TKStage ownerWindow,
                                      final String title,
                                      final File initialDirectory,
                                      final String initialFileName,
                                      final FileChooserType fileChooserType,
                                      final List&lt;FileChooser.ExtensionFilter&gt;
                                              extensionFilters,
                                      final FileChooser.ExtensionFilter selectedFilter) {
        WindowStage blockedStage = null;
        try {
            // NOTE: we block the owner of the owner deliberately.
            //       The native system blocks the nearest owner itself.
            //       Otherwise sheets on Mac are unusable.
            blockedStage = blockOwnerStage(ownerWindow);

            return CommonDialogs.showFileChooser(
                    (ownerWindow instanceof WindowStage)
                            ? ((WindowStage) ownerWindow).getPlatformWindow()
                            : null,
                    initialDirectory,
                    initialFileName,
                    title,
                    (fileChooserType == FileChooserType.SAVE)
                            ? CommonDialogs.Type.SAVE
                            : CommonDialogs.Type.OPEN,
                    (fileChooserType == FileChooserType.OPEN_MULTIPLE),
                    convertExtensionFilters(extensionFilters),
                    extensionFilters.indexOf(selectedFilter));
        } finally {
            if (blockedStage != null) {
                blockedStage.setEnabled(true);
            }
        }
    }

    @Override
    public File showDirectoryChooser(final TKStage ownerWindow,
                                     final String title,
                                     final File initialDirectory) {
        WindowStage blockedStage = null;
        try {
            // NOTE: we block the owner of the owner deliberately.
            //       The native system blocks the nearest owner itself.
            //       Otherwise sheets on Mac are unusable.
            blockedStage = blockOwnerStage(ownerWindow);

            return CommonDialogs.showFolderChooser(
                    (ownerWindow instanceof WindowStage)
                            ? ((WindowStage) ownerWindow).getPlatformWindow()
                            : null,
                    initialDirectory, title);
        } finally {
            if (blockedStage != null) {
                blockedStage.setEnabled(true);
            }
        }
    }

    private WindowStage blockOwnerStage(final TKStage stage) {
        if (stage instanceof WindowStage) {
            final TKStage ownerStage = ((WindowStage) stage).getOwner();
            if (ownerStage instanceof WindowStage) {
                final WindowStage ownerWindowStage = (WindowStage) ownerStage;
                ownerWindowStage.setEnabled(false);
                return ownerWindowStage;
            }
        }

        return null;
    }

    private static List&lt;CommonDialogs.ExtensionFilter&gt;
            convertExtensionFilters(final List&lt;FileChooser.ExtensionFilter&gt;
                                            extensionFilters) {
        final CommonDialogs.ExtensionFilter[] glassExtensionFilters =
<A NAME="23"></A>                new CommonDialogs.ExtensionFilter[extensionFilters.size()];

        int i = 0;
        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#23',2,'match56-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (final FileChooser.ExtensionFilter extensionFilter:
                 extensionFilters) {
            glassExtensionFilters[i++] =
                    new CommonDialogs.ExtensionFilter(
                            extensionFilter.getDescription(),
                            extensionFilter.getExtensions());
        }</B></FONT>

        return Arrays.asList(glassExtensionFilters);
    }

    @Override
    public long getMultiClickTime() {
        return View.getMultiClickTime();
    }

    @Override
    public int getMultiClickMaxX() {
        return View.getMultiClickMaxX();
    }

    @Override
    public int getMultiClickMaxY() {
        return View.getMultiClickMaxY();
    }

    @Override
    public String getThemeName() {
        return Application.GetApplication().getHighContrastTheme();
    }

    @Override
    public GlassRobot createRobot() {
        return com.sun.glass.ui.Application.GetApplication().createRobot();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/ImageCursor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import java.util.HashMap;
import java.util.Map;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoublePropertyBase;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectPropertyBase;
import javafx.geometry.Dimension2D;
import javafx.scene.image.Image;

import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.cursor.ImageCursorFrame;
import com.sun.javafx.tk.Toolkit;
import java.util.Arrays;
import javafx.beans.NamedArg;


/**
 * A custom image representation of the mouse cursor. On platforms that don't
 * support custom cursors, {@code Cursor.DEFAULT} will be used in place of the
 * specified ImageCursor.
 *
 * &lt;p&gt;Example:
 * &lt;pre&gt;
import javafx.scene.*;
import javafx.scene.image.*;

Image image = new Image(&quot;mycursor.png&quot;);

Scene scene = new Scene(400, 300);
scene.setCursor(new ImageCursor(image,
                                image.getWidth() / 2,
                                image.getHeight() /2));
 * &lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
public class ImageCursor extends Cursor {
    /**
     * The image to display when the cursor is active. If the image is null,
     * {@code Cursor.DEFAULT} will be used.
     *
     * @defaultValue null
     */
    private ObjectPropertyImpl&lt;Image&gt; image;

    public final Image getImage() {
        return image == null ? null : image.get();
    }

    public final ReadOnlyObjectProperty&lt;Image&gt; imageProperty() {
        return imagePropertyImpl();
    }

    private ObjectPropertyImpl&lt;Image&gt; imagePropertyImpl() {
        if (image == null) {
            image = new ObjectPropertyImpl&lt;Image&gt;(&quot;image&quot;);
        }

        return image;
    }

    /**
     * The X coordinate of the cursor's hot spot. This hotspot represents the
     * location within the cursor image that will be displayed at the mouse
     * position. This must be in the range of [0,image.width-1]. A value
     * less than 0 will be set to 0. A value greater than
     * image.width-1 will be set to image.width-1.
     *
     * @defaultValue 0
     */
    private DoublePropertyImpl hotspotX;

    public final double getHotspotX() {
        return hotspotX == null ? 0.0 : hotspotX.get();
    }

    public final ReadOnlyDoubleProperty hotspotXProperty() {
        return hotspotXPropertyImpl();
    }

    private DoublePropertyImpl hotspotXPropertyImpl() {
        if (hotspotX == null) {
            hotspotX = new DoublePropertyImpl(&quot;hotspotX&quot;);
        }

        return hotspotX;
    }

    /**
     * The Y coordinate of the cursor's hot spot. This hotspot represents the
     * location within the cursor image that will be displayed at the mouse
     * position. This must be in the range of [0,image.height-1]. A value
     * less than 0 will be set to 0. A value greater than
     * image.height-1 will be set to image.height-1.
     *
     * @defaultValue 0
     */
    private DoublePropertyImpl hotspotY;

    public final double getHotspotY() {
        return hotspotY == null ? 0.0 : hotspotY.get();
    }

    public final ReadOnlyDoubleProperty hotspotYProperty() {
        return hotspotYPropertyImpl();
    }

    private DoublePropertyImpl hotspotYPropertyImpl() {
        if (hotspotY == null) {
            hotspotY = new DoublePropertyImpl(&quot;hotspotY&quot;);
        }

        return hotspotY;
    }

    private CursorFrame currentCursorFrame;

    /**
     * Stores the first cursor frame. For non-animated cursors there is only one
     * frame and so the {@code restCursorFrames} is {@code null}.
     */
    private ImageCursorFrame firstCursorFrame;

    /**
     * Maps platform images to cursor frames. It doesn't store the first cursor
     * frame and so it needs to be created only for animated cursors.
     */
    private Map&lt;Object, ImageCursorFrame&gt; otherCursorFrames;

    /**
     * Indicates whether the image cursor is currently in use. The active cursor
     * is bound to the image and invalidates its platform cursor when the image
     * changes.
     */
    private int activeCounter;

    /**
     * Constructs a new empty {@code ImageCursor} which will look as
     * {@code Cursor.DEFAULT}.
     */
    public ImageCursor() {
    }

    /**
     * Constructs an {@code ImageCursor} from the specified image. The cursor's
     * hot spot will default to the upper left corner.
     *
     * @param image the image
     */
    public ImageCursor(@NamedArg(&quot;image&quot;) final Image image) {
        this(image, 0f, 0f);
    }

    /**
     * Constructs an {@code ImageCursor} from the specified image and hotspot
     * coordinates.
     *
     * @param image the image
     * @param hotspotX the X coordinate of the cursor's hot spot
     * @param hotspotY the Y coordinate of the cursor's hot spot
     */
    public ImageCursor(@NamedArg(&quot;image&quot;) final Image image,
                       @NamedArg(&quot;hotspotX&quot;) double hotspotX,
                       @NamedArg(&quot;hotspotY&quot;) double hotspotY) {
        if ((image != null) &amp;&amp; (image.getProgress() &lt; 1)) {
            DelayedInitialization.applyTo(
                    this, image, hotspotX, hotspotY);
        } else {
            initialize(image, hotspotX, hotspotY);
        }
    }

    /**
     * Gets the supported cursor size that is closest to the specified preferred
     * size. A value of (0,0) is returned if the platform does not support
     * custom cursors.
     *
     * &lt;p&gt;
     * Note: if an image is used whose dimensions don't match a supported size
     * (as returned by this method), the implementation will resize the image to
     * a supported size. This may result in a loss of quality.
     *
     * &lt;p&gt;
     * Note: These values can vary between operating systems, graphics cards and
     * screen resolution, but at the time of this writing, a sample Windows
     * Vista machine returned 32x32 for all requested sizes, while sample Mac
     * and Linux machines returned the requested size up to a maximum of 64x64.
     * Applications should provide a 32x32 cursor, which will work well on all
     * platforms, and may optionally wish to provide a 64x64 cursor for those
     * platforms on which it is supported.
     *
     * @param preferredWidth the preferred width of the cursor
     * @param preferredHeight the preferred height of the cursor
     * @return the supported cursor size
     */
    public static Dimension2D getBestSize(double preferredWidth,
                                          double preferredHeight) {
        return Toolkit.getToolkit().getBestCursorSize((int) preferredWidth,
                                                      (int) preferredHeight);
    }

    /**
     * Returns the maximum number of colors supported in a custom image cursor
     * palette.
     *
     * &lt;p&gt;
     * Note: if an image is used which has more colors in its palette than the
     * supported maximum, the implementation will attempt to flatten the
     * palette to the maximum. This may result in a loss of quality.
     *
     * &lt;p&gt;
     * Note: These values can vary between operating systems, graphics cards and
     * screen resolution,  but at the time of this writing, a sample Windows
     * Vista machine returned 256, a sample Mac machine returned
     * Integer.MAX_VALUE, indicating support for full color cursors, and
     * a sample Linux machine returned 2. Applications may want to target these
     * three color depths for an optimal cursor on each platform.
     *
     * @return the maximum number of colors supported in a custom image cursor
     *      palette
     */
    public static int getMaximumColors() {
        return Toolkit.getToolkit().getMaximumCursorColors();
    }

    /**
     * Creates a custom image cursor from one of the specified images. This function
     * will choose the image whose size most closely matched the best cursor size.
     * The hotpotX of the returned ImageCursor is scaled by
     * chosenImage.width/images[0].width and the hotspotY is scaled by
     * chosenImage.height/images[0].height.
     * &lt;p&gt;
     * On platforms that don't support custom cursors, {@code Cursor.DEFAULT} will
     * be used in place of the returned ImageCursor.
     *
     * @param images a sequence of images from which to choose, in order of preference
     * @param hotspotX the X coordinate of the hotspot within the first image
     *        in the images sequence
     * @param hotspotY the Y coordinate of the hotspot within the first image
     *        in the images sequence
     * @return a cursor created from the best image
     */
    public static ImageCursor chooseBestCursor(
            final Image[] images, final double hotspotX, final double hotspotY) {
        final ImageCursor imageCursor = new ImageCursor();

        if (needsDelayedInitialization(images)) {
            DelayedInitialization.applyTo(
                    imageCursor, images, hotspotX, hotspotY);
        } else {
            imageCursor.initialize(images, hotspotX, hotspotY);
        }

        return imageCursor;
    }

    @Override CursorFrame getCurrentFrame() {
        if (currentCursorFrame != null) {
            return currentCursorFrame;
        }

        final Image cursorImage = getImage();

        if (cursorImage == null) {
            currentCursorFrame = Cursor.DEFAULT.getCurrentFrame();
            return currentCursorFrame;
        }

        final Object cursorPlatformImage = Toolkit.getImageAccessor().getPlatformImage(cursorImage);
        if (cursorPlatformImage == null) {
            currentCursorFrame = Cursor.DEFAULT.getCurrentFrame();
            return currentCursorFrame;
        }

        if (firstCursorFrame == null) {
            firstCursorFrame =
                    new ImageCursorFrame(cursorPlatformImage,
                                         cursorImage.getWidth(),
                                         cursorImage.getHeight(),
                                         getHotspotX(),
                                         getHotspotY());
            currentCursorFrame = firstCursorFrame;
        } else if (firstCursorFrame.getPlatformImage() == cursorPlatformImage) {
            currentCursorFrame = firstCursorFrame;
        } else {
            if (otherCursorFrames == null) {
                otherCursorFrames = new HashMap&lt;Object, ImageCursorFrame&gt;();
            }

            currentCursorFrame = otherCursorFrames.get(cursorPlatformImage);
            if (currentCursorFrame == null) {
                // cursor frame not created yet
                final ImageCursorFrame newCursorFrame =
                        new ImageCursorFrame(cursorPlatformImage,
                                             cursorImage.getWidth(),
                                             cursorImage.getHeight(),
                                             getHotspotX(),
                                             getHotspotY());

                otherCursorFrames.put(cursorPlatformImage, newCursorFrame);
                currentCursorFrame = newCursorFrame;
            }
        }

        return currentCursorFrame;
     }

    private void invalidateCurrentFrame() {
        currentCursorFrame = null;
    }

    @Override
    void activate() {
        if (++activeCounter == 1) {
            bindImage(getImage());
            invalidateCurrentFrame();
        }
    }

    @Override
    void deactivate() {
        if (--activeCounter == 0) {
            unbindImage(getImage());
        }
    }

    private void initialize(final Image[] images,
                            final double hotspotX,
                            final double hotspotY) {
        final Dimension2D dim = getBestSize(1f, 1f);

        // If no valid image or if custom cursors are not supported, leave
        // the default image cursor
        if ((images.length == 0) || (dim.getWidth() == 0f)
                                 || (dim.getHeight() == 0f)) {
            return;
        }

        // If only a single image, use it to construct a custom cursor
        if (images.length == 1) {
            initialize(images[0], hotspotX, hotspotY);
            return;
        }

        final Image bestImage = findBestImage(images);
        final double scaleX = bestImage.getWidth() / images[0].getWidth();
        final double scaleY = bestImage.getHeight() / images[0].getHeight();

        initialize(bestImage, hotspotX * scaleX, hotspotY * scaleY);
    }

    private void initialize(Image newImage,
                            double newHotspotX,
                            double newHotspotY) {
        final Image oldImage = getImage();
        final double oldHotspotX = getHotspotX();
        final double oldHotspotY = getHotspotY();

        if ((newImage == null) || (newImage.getWidth() &lt; 1f)
                               || (newImage.getHeight() &lt; 1f)) {
            // If image is invalid set the hotspot to 0
            newHotspotX = 0f;
            newHotspotY = 0f;
        } else {
            if (newHotspotX &lt; 0f) {
                newHotspotX = 0f;
            }
            if (newHotspotX &gt; (newImage.getWidth() - 1f)) {
                newHotspotX = newImage.getWidth() - 1f;
            }
            if (newHotspotY &lt; 0f) {
                newHotspotY = 0f;
            }
            if (newHotspotY &gt; (newImage.getHeight() - 1f)) {
                newHotspotY = newImage.getHeight() - 1f;
            }
        }

        imagePropertyImpl().store(newImage);
        hotspotXPropertyImpl().store(newHotspotX);
        hotspotYPropertyImpl().store(newHotspotY);

        if (oldImage != newImage) {
            if (activeCounter &gt; 0) {
                unbindImage(oldImage);
                bindImage(newImage);
            }

            invalidateCurrentFrame();
            image.fireValueChangedEvent();
        }

        if (oldHotspotX != newHotspotX) {
            hotspotX.fireValueChangedEvent();
        }

        if (oldHotspotY != newHotspotY) {
            hotspotY.fireValueChangedEvent();
        }
    }

    private InvalidationListener imageListener;

    private InvalidationListener getImageListener() {
        if (imageListener == null) {
            imageListener = valueModel -&gt; invalidateCurrentFrame();
        }

        return imageListener;
    }

    private void bindImage(final Image toImage) {
        if (toImage == null) {
            return;
        }

        Toolkit.getImageAccessor().getImageProperty(toImage).addListener(getImageListener());
    }

    private void unbindImage(final Image fromImage) {
        if (fromImage == null) {
            return;
<A NAME="25"></A>        }

        Toolkit.getImageAccessor().getImageProperty(fromImage).removeListener(getImageListener());
    <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#25',2,'match56-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private static boolean needsDelayedInitialization(final Image[] images) {
        for (final Image image: images) {
            if (image.getProgress() &lt; 1) {
                return true;
            }
        }

        return false;
    }

    // Utility function to select the best image
    private stati</B></FONT>c Image findBestImage(final Image[] images) {
        // Check for exact match and return the first such match
        for (final Image image: images) {
            final Dimension2D dim = getBestSize((int) image.getWidth(),
                                                (int) image.getHeight());
            if ((dim.getWidth() == image.getWidth())
                    &amp;&amp; (dim.getHeight() == image.getHeight())) {
                return image;
            }
        }

        // No exact match, check for closest match without down-scaling
        // (i.e., smallest scale &gt;= 1.0)
        Image bestImage = null;
        double bestRatio = Double.MAX_VALUE;
        for (final Image image: images) {
            if ((image.getWidth() &gt; 0) &amp;&amp; (image.getHeight() &gt; 0)) {
                final Dimension2D dim = getBestSize(image.getWidth(),
                                                    image.getHeight());
                final double ratioX = dim.getWidth() / image.getWidth();
                final double ratioY = dim.getHeight() / image.getHeight();
                if ((ratioX &gt;= 1) &amp;&amp; (ratioY &gt;= 1)) {
                    final double ratio = Math.max(ratioX, ratioY);
                    if (ratio &lt; bestRatio) {
                        bestImage = image;
                        bestRatio = ratio;
                    }
                }
            }
        }
        if (bestImage != null) {
            return bestImage;
        }

        // Still no match, check for closest match alowing for down-scaling
        // (i.e., smallest up-scale or down-scale &gt;= 1.0)
        for (final Image image: images) {
            if ((image.getWidth() &gt; 0) &amp;&amp; (image.getHeight() &gt; 0)) {
                final Dimension2D dim = getBestSize(image.getWidth(),
                                                    image.getHeight());
                if ((dim.getWidth() &gt; 0) &amp;&amp; (dim.getHeight() &gt; 0)) {
                    double ratioX = dim.getWidth() / image.getWidth();
                    if (ratioX &lt; 1) {
                        ratioX = 1 / ratioX;
                    }
                    double ratioY = dim.getHeight() / image.getHeight();
                    if (ratioY &lt; 1) {
                        ratioY = 1 / ratioY;
                    }
                    final double ratio = Math.max(ratioX, ratioY);
                    if (ratio &lt; bestRatio) {
                        bestImage = image;
                        bestRatio = ratio;
                    }
                }
            }
        }
        if (bestImage != null) {
            return bestImage;
        }

        return images[0];
    }

    private final class DoublePropertyImpl extends ReadOnlyDoublePropertyBase {
        private final String name;

        private double value;

        public DoublePropertyImpl(final String name) {
            this.name = name;
        }

        public void store(final double value) {
            this.value = value;
        }

        @Override
        public void fireValueChangedEvent() {
            super.fireValueChangedEvent();
        }

        @Override
        public double get() {
            return value;
        }

        @Override
        public Object getBean() {
            return ImageCursor.this;
        }

        @Override
        public String getName() {
            return name;
        }
    }

    private final class ObjectPropertyImpl&lt;T&gt;
            extends ReadOnlyObjectPropertyBase&lt;T&gt; {
        private final String name;

        private T value;

        public ObjectPropertyImpl(final String name) {
            this.name = name;
        }

        public void store(final T value) {
            this.value = value;
        }

        @Override
        public void fireValueChangedEvent() {
            super.fireValueChangedEvent();
        }

        @Override
        public T get() {
            return value;
        }

        @Override
        public Object getBean() {
            return ImageCursor.this;
        }

        @Override
        public String getName() {
            return name;
        }
    }

    private static final class DelayedInitialization
            implements InvalidationListener {
        private final ImageCursor targetCursor;

        private final Image[] images;
        private final double hotspotX;
        private final double hotspotY;

        private final boolean initAsSingle;

        private int waitForImages;

        private DelayedInitialization(final ImageCursor targetCursor,
                                      final Image[] images,
                                      final double hotspotX,
                                      final double hotspotY,
                                      final boolean initAsSingle) {
            this.targetCursor = targetCursor;
            this.images = images;
            this.hotspotX = hotspotX;
            this.hotspotY = hotspotY;
            this.initAsSingle = initAsSingle;
        }


        public static void applyTo(final ImageCursor imageCursor,
                                   final Image[] images,
                                   final double hotspotX,
                                   final double hotspotY) {
            final DelayedInitialization delayedInitialization =
                    new DelayedInitialization(imageCursor,
                                              Arrays.copyOf(images, images.length),
                                              hotspotX,
                                              hotspotY,
                                              false);
            delayedInitialization.start();
        }

        public static void applyTo(final ImageCursor imageCursor,
                                   final Image image,
                                   final double hotspotX,
                                   final double hotspotY) {
            final DelayedInitialization delayedInitialization =
                    new DelayedInitialization(imageCursor,
                                              new Image[] { image },
                                              hotspotX,
                                              hotspotY,
                                              true);
            delayedInitialization.start();
        }

        private void start() {
            for (final Image image: images) {
                if (image.getProgress() &lt; 1) {
                    ++waitForImages;
                    image.progressProperty().addListener(this);
                }
            }
        }

        private void cleanupAndFinishInitialization() {
            for (final Image image: images) {
                image.progressProperty().removeListener(this);
            }

            if (initAsSingle) {
                targetCursor.initialize(images[0], hotspotX, hotspotY);
            } else {
                targetCursor.initialize(images, hotspotX, hotspotY);
            }
        }

        @Override
        public void invalidated(Observable valueModel) {
            if (((ReadOnlyDoubleProperty)valueModel).get() == 1) {
                if (--waitForImages == 0) {
                    cleanupAndFinishInitialization();
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/layout/AnchorPane.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.layout;

import java.util.List;
import javafx.geometry.Bounds;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Node;

/**
 * AnchorPane allows the edges of child nodes to be anchored to an offset from
 * the anchor pane's edges.  If the anchor pane has a border and/or padding set, the
 * offsets will be measured from the inside edge of those insets.
 * &lt;p&gt;
 * AnchorPane lays out each managed child regardless of the child's visible property value;
 * unmanaged children are ignored for all layout calculations.&lt;/p&gt;
 * &lt;p&gt;
 * AnchorPanes may be styled with backgrounds and borders using CSS.  See
 * {@link javafx.scene.layout.Region Region} superclass for details.&lt;/p&gt;
 *
 * &lt;h3&gt;Anchor Constraints&lt;/h3&gt;
 * &lt;p&gt;
 * The application sets anchor constraints on each child to configure the anchors
 * on one or more sides.  If a child is anchored on opposite sides (and is resizable), the
 * anchor pane will resize it to maintain both offsets, otherwise the anchor pane
 * will resize it to its preferred size.  If in the former case (anchored on opposite
 * sides) and the child is not resizable, then only the top/left anchor will be honored.
 * AnchorPane provides a static method for setting each anchor constraint.
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;AnchorPane Constraint Table&lt;/caption&gt;
 * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Constraint&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;topAnchor&lt;/th&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;distance from the anchor pane's top insets to the child's top edge.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;leftAnchor&lt;/th&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;distance from the anchor pane's left insets to the child's left edge.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;bottomAnchor&lt;/th&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;distance from the anchor pane's bottom insets to the child's bottom edge.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;rightAnchor&lt;/th&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;distance from the anchor pane's right insets to the child's right edge.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * AnchorPane Example:
 * &lt;pre&gt;&lt;code&gt;     AnchorPane anchorPane = new AnchorPane();
 *     // List should stretch as anchorPane is resized
 *     ListView list = new ListView();
 *    &lt;b&gt; AnchorPane.setTopAnchor(list, 10.0);
 *     AnchorPane.setLeftAnchor(list, 10.0);
 *     AnchorPane.setRightAnchor(list, 65.0);&lt;/b&gt;
 *     // Button will float on right edge
 *     Button button = new Button(&quot;Add&quot;);
 *     &lt;b&gt;AnchorPane.setTopAnchor(button, 10.0);
 *     AnchorPane.setRightAnchor(button, 10.0);&lt;/b&gt;
 *     anchorPane.getChildren().addAll(list, button);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h3&gt;Resizable Range&lt;/h3&gt;
 * &lt;p&gt;
 * An anchor pane's parent will resize the anchor pane within the anchor pane's resizable range
 * during layout.   By default the anchor pane computes this range based on its content
 * as outlined in the table below.
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;AnchorPane Resize Table&lt;/caption&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th scope=&quot;col&quot;&gt;width&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;height&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;minimum&lt;/th&gt;
 * &lt;td&gt;left/right insets plus width required to display children anchored at left/right with at least their min widths&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus height required to display children anchored at top/bottom with at least their min heights&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;preferred&lt;/th&gt;
 * &lt;td&gt;left/right insets plus width required to display children anchored at left/right with at least their pref widths&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus height required to display children anchored at top/bottom with at least their pref heights&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;maximum&lt;/th&gt;
 * &lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * An anchor pane's unbounded maximum width and height are an indication to the parent that
 * it may be resized beyond its preferred size to fill whatever space is assigned
 * to it.
 * &lt;p&gt;
 * AnchorPane provides properties for setting the size range directly.  These
 * properties default to the sentinel value Region.USE_COMPUTED_SIZE, however the
 * application may set them to other values as needed:
 * &lt;pre&gt;&lt;code&gt;     &lt;b&gt;anchorPane.setPrefSize(300, 300);&lt;/b&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 * Applications may restore the computed values by setting these properties back
 * to Region.USE_COMPUTED_SIZE.
 * &lt;p&gt;
 * AnchorPane does not clip its content by default, so it is possible that children's
 * bounds may extend outside its own bounds if the anchor pane is resized smaller
 * than its preferred size.&lt;/p&gt;
 *
 * @since JavaFX 2.0
 */
public class AnchorPane extends Pane {

    private static final String TOP_ANCHOR = &quot;pane-top-anchor&quot;;
    private static final String LEFT_ANCHOR = &quot;pane-left-anchor&quot;;
    private static final String BOTTOM_ANCHOR = &quot;pane-bottom-anchor&quot;;
    private static final String RIGHT_ANCHOR = &quot;pane-right-anchor&quot;;

    /********************************************************************
     *  BEGIN static methods
     ********************************************************************/

    /**
     * Sets the top anchor for the child when contained by an anchor pane.
     * If set, the anchor pane will maintain the child's size and position so
     * that it's top is always offset by that amount from the anchor pane's top
     * content edge.
     * Setting the value to null will remove the constraint.
     * @param child the child node of an anchor pane
     * @param value the offset from the top of the anchor pane
     */
    public static void setTopAnchor(Node child, Double value) {
        setConstraint(child, TOP_ANCHOR, value);
    }

    /**
     * Returns the child's top anchor constraint if set.
     * @param child the child node of an anchor pane
     * @return the offset from the top of the anchor pane or null if no top anchor was set
     */
    public static Double getTopAnchor(Node child) {
        return (Double)getConstraint(child, TOP_ANCHOR);
    }

    /**
     * Sets the left anchor for the child when contained by an anchor pane.
     * If set, the anchor pane will maintain the child's size and position so
     * that it's left is always offset by that amount from the anchor pane's left
     * content edge.
     * Setting the value to null will remove the constraint.
     * @param child the child node of an anchor pane
     * @param value the offset from the left of the anchor pane
     */
    public static void setLeftAnchor(Node child, Double value) {
        setConstraint(child, LEFT_ANCHOR, value);
    }

    /**
     * Returns the child's left anchor constraint if set.
     * @param child the child node of an anchor pane
     * @return the offset from the left of the anchor pane or null if no left anchor was set
     */
    public static Double getLeftAnchor(Node child) {
        return (Double)getConstraint(child, LEFT_ANCHOR);
    }

    /**
     * Sets the bottom anchor for the child when contained by an anchor pane.
     * If set, the anchor pane will maintain the child's size and position so
     * that it's bottom is always offset by that amount from the anchor pane's bottom
     * content edge.
     * Setting the value to null will remove the constraint.
     * @param child the child node of an anchor pane
     * @param value the offset from the bottom of the anchor pane
     */
    public static void setBottomAnchor(Node child, Double value) {
        setConstraint(child, BOTTOM_ANCHOR, value);
    }

    /**
     * Returns the child's bottom anchor constraint if set.
     * @param child the child node of an anchor pane
     * @return the offset from the bottom of the anchor pane or null if no bottom anchor was set
     */
    public static Double getBottomAnchor(Node child) {
        return (Double)getConstraint(child, BOTTOM_ANCHOR);
    }

    /**
     * Sets the right anchor for the child when contained by an anchor pane.
     * If set, the anchor pane will maintain the child's size and position so
     * that it's right is always offset by that amount from the anchor pane's right
     * content edge.
     * Setting the value to null will remove the constraint.
     * @param child the child node of an anchor pane
     * @param value the offset from the right of the anchor pane
     */
    public static void setRightAnchor(Node child, Double value) {
        setConstraint(child, RIGHT_ANCHOR, value);
    }

    /**
     * Returns the child's right anchor constraint if set.
     * @param child the child node of an anchor pane
     * @return the offset from the right of the anchor pane or null if no right anchor was set
     */
    public static Double getRightAnchor(Node child) {
        return (Double)getConstraint(child, RIGHT_ANCHOR);
    }

    /**
     * Removes all anchor pane constraints from the child node.
     * @param child the child node
     */
    public static void clearConstraints(Node child) {
        setTopAnchor(child, null);
        setRightAnchor(child, null);
        setBottomAnchor(child, null);
        setLeftAnchor(child, null);
    }

    /********************************************************************
     *  END static methods
     ********************************************************************/

    /**
     * Creates an AnchorPane layout.
     */
    public AnchorPane() {
        super();
    }

    /**
     * Creates an AnchorPane layout with the given children.
     * @param children    The initial set of children for this pane.
     * @since JavaFX 8.0
     */
    public AnchorPane(Node... children) {
        super();
        getChildren().addAll(children);
    }

    @Override protected double computeMinWidth(double height) {
        return computeWidth(true, height);
    }

    @Override protected double computeMinHeight(double width) {
        return computeHeight(true, width);
    }

    @Override protected double computePrefWidth(double height) {
        return computeWidth(false, height);
    }

    @Override protected double computePrefHeight(double width) {
        return computeHeight(false, width);
    }

    private double computeWidth(final boolean minimum, final double height) {
        double max = 0;
        double contentHeight = height != -1 ? height - getInsets().getTop() - getInsets().getBottom() : -1;
        final List&lt;Node&gt; children = getManagedChildren();
        for (Node child : children) {
            Double leftAnchor = getLeftAnchor(child);
            Double rightAnchor = getRightAnchor(child);

            double left = leftAnchor != null? leftAnchor :
                (rightAnchor != null? 0 : child.getLayoutBounds().getMinX() + child.getLayoutX());
            double right = rightAnchor != null? rightAnchor : 0;
            double childHeight = -1;
            if (child.getContentBias() == Orientation.VERTICAL &amp;&amp; contentHeight != -1) {
                // The width depends on the node's height!
                childHeight = computeChildHeight(child, getTopAnchor(child), getBottomAnchor(child), contentHeight, -1);
            }
            max = Math.max(max, left + (minimum &amp;&amp; leftAnchor != null &amp;&amp; rightAnchor != null?
                    child.minWidth(childHeight) : computeChildPrefAreaWidth(child, -1, null, childHeight, false)) + right);
        }

        final Insets insets = getInsets();
        return insets.getLeft() + max + insets.getRight();
    }

    private double computeHeight(final boolean minimum, final double width) {
        double max = 0;
        double contentWidth = width != -1 ? width - getInsets().getLeft()- getInsets().getRight() : -1;
        final List&lt;Node&gt; children = getManagedChildren();
        for (Node child : children) {
            Double topAnchor = getTopAnchor(child);
            Double bottomAnchor = getBottomAnchor(child);

            double top = topAnchor != null? topAnchor :
                (bottomAnchor != null? 0 : child.getLayoutBounds().getMinY() + child.getLayoutY());
            double bottom = bottomAnchor != null? bottomAnchor : 0;
            double childWidth = -1;
            if (child.getContentBias() == Orientation.HORIZONTAL &amp;&amp; contentWidth != -1) {
                childWidth = computeChildWidth(child, getLeftAnchor(child), getRightAnchor(child), contentWidth, -1);
            }
            max = Math.max(max, top + (minimum &amp;&amp; topAnchor != null &amp;&amp; bottomAnchor != null?
                    child.minHeight(childWidth) : computeChildPrefAreaHeight(child, -1, null, childWidth)) + bottom);
        }

        final Insets insets = getInsets();
        return insets.getTop() + max + insets.getBottom();
    }

    private double computeChildWidth(Node child, Double leftAnchor, Double rightAnchor, double areaWidth, double height) {
        if (leftAnchor != null &amp;&amp; rightAnchor != null &amp;&amp; child.isResizable()) {
            final Insets insets = getInsets();
            return areaWidth - insets.getLeft() - insets.getRight() - leftAnchor - rightAnchor;
        }
        return computeChildPrefAreaWidth(child, -1, Insets.EMPTY, height, true);
    }

    private double computeChildHeight(Node child, Double topAnchor, Double bottomAnchor, double areaHeight, double width) {
        if (topAnchor != null &amp;&amp; bottomAnchor != null &amp;&amp; child.isResizable()) {
            final Insets insets = getInsets();
            return areaHeight - insets.getTop() - insets.getBottom() - topAnchor - bottomAnchor;
        }
<A NAME="5"></A>        return computeChildPrefAreaHeight(child, -1, Insets.EMPTY, width);
    }

    @Override protected void layoutChildren() <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#5',2,'match56-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        final Insets insets = getInsets();
        final List&lt;Node&gt; children = getManagedChildren();
        for (Node child : children) {
            final Double topAnchor = getTopAnchor(child);
            final Double bottomAnchor = getBottomAnchor(child);
            final Double leftAnchor = getLeftAnchor</B></FONT>(child);
            final Double rightAnchor = getRightAnchor(child);
            final Bounds childLayoutBounds = child.getLayoutBounds();
            final Orientation bias = child.getContentBias();

            double x = child.getLayoutX() + childLayoutBounds.getMinX();
            double y = child.getLayoutY() + childLayoutBounds.getMinY();
            double w;
            double h;

            if (bias == Orientation.VERTICAL) {
                // width depends on height
                // WARNING: The order of these calls is crucial, there is some
                // hidden ordering dependency here!
                h = computeChildHeight(child, topAnchor, bottomAnchor, getHeight(), -1);
                w = computeChildWidth(child, leftAnchor, rightAnchor, getWidth(), h);
            } else if (bias == Orientation.HORIZONTAL) {
                w = computeChildWidth(child, leftAnchor, rightAnchor, getWidth(), -1);
                h = computeChildHeight(child, topAnchor, bottomAnchor, getHeight(), w);
            } else {
                // bias may be null
                w = computeChildWidth(child, leftAnchor, rightAnchor, getWidth(), -1);
                h = computeChildHeight(child, topAnchor, bottomAnchor, getHeight(), -1);
            }

            if (leftAnchor != null) {
                x = insets.getLeft() + leftAnchor;
            } else if (rightAnchor != null) {
                x = getWidth() - insets.getRight() - rightAnchor - w;
            }

            if (topAnchor != null) {
                y = insets.getTop() + topAnchor;
            } else if (bottomAnchor != null) {
                y = getHeight() - insets.getBottom() - bottomAnchor - h;
            }

            child.resizeRelocate(x, y, w, h);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/com/sun/javafx/embed/swing/CachingTransferable.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.embed.swing;

<A NAME="19"></A>import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.io.UnsupportedEncodingException;
<FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#19',2,'match56-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javafx.scene.input.Clipboard;
import javafx.scene.input.DataFormat;

/**
 * A Transferable implementation backed by a Map.
 * The data can be populated either from AWT Transferable
 * or from FX Clipboard.
 */
public class CachingTransferable implements Transferable {

    @Override
    public Object getTransferData(final DataFlavor flavor) throws UnsupportedEncodingException
    {
        String mimeType = DataFlavorUtils.getFxMimeType(flavor)</B></FONT>;
        return DataFlavorUtils.adjustFxData(
                flavor, getData(mimeType));
    }

    @Override
    public DataFlavor[] getTransferDataFlavors() {
        final String mimeTypes[] = getMimeTypes();
        return DataFlavorUtils.getDataFlavors(mimeTypes);
    }

    @Override
    public boolean isDataFlavorSupported(final DataFlavor flavor) {
        return isMimeTypeAvailable(
                DataFlavorUtils.getFxMimeType(flavor));
    }

    private Map&lt;String, Object&gt; mimeType2Data = Collections.EMPTY_MAP;

    public void updateData(Transferable t, boolean fetchData) {
        final Map&lt;String, DataFlavor&gt; mimeType2DataFlavor =
                DataFlavorUtils.adjustSwingDataFlavors(
                t.getTransferDataFlavors());

        // If we keep reference to source Transferable in SwingDragSource and
        // call Transferable#getTransferData() on it from
        // SwingDragSource#getData() we may run into
        // &quot;java.awt.dnd.InvalidDnDOperationException&quot; issue as
        // SwingDragSource#getData() is called from FX user code and from
        // QuantumClipboard#getContent() (sik!). These calls usually take
        // place in the context of
        // EmbeddedSceneDTInterface#handleDragDrop() method as the
        // normal handling of DnD.
        // Instead of keeping reference to source Transferable we just read
        // all its data while in the context safe for calling
        // Transferable#getTransferData().
        //
        // This observation is true for standard AWT Transferable-s.
        // Things may be totally broken for custom Transferable-s though.

        // For performance reasons, the DRAG_ENTERED and DRAG_OVER event
        // handlers pass fetchData == false so as to update the set of
        // available MIME types only. The DRAG_DROPPED handler passes
        // fetchData == true which also fetches all the data.
        // NOTE: Due to JDK-8028585 this code won't be able to fetch data
        // when invoked from handlers other than DROPPED in any case.

        try {
            mimeType2Data = DataFlavorUtils.readAllData(t, mimeType2DataFlavor,
                    fetchData);
        } catch (Exception e) {
            mimeType2Data = Collections.EMPTY_MAP;
        }
    }

    public void updateData(Clipboard cb, boolean fetchData) {
        mimeType2Data = new HashMap&lt;&gt;();
        for (DataFormat f : cb.getContentTypes()) {
            mimeType2Data.put(DataFlavorUtils.getMimeType(f),
                    fetchData ? cb.getContent(f) : null);
        }
    }

    public Object getData(final String mimeType) {
        return mimeType2Data.get(mimeType);
    }

    public String[] getMimeTypes() {
        return mimeType2Data.keySet().toArray(new String[0]);
    }

    public boolean isMimeTypeAvailable(final String mimeType) {
        return Arrays.asList(getMimeTypes()).contains(mimeType);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import com.sun.glass.ui.Screen;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PGFont;
import com.sun.javafx.geom.*;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.scene.text.TextLayout;
import com.sun.javafx.sg.prism.*;
import com.sun.javafx.text.TextRun;
import com.sun.prism.*;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.*;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.webkit.graphics.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import static com.sun.scenario.effect.Blend.Mode.*;
import com.sun.scenario.effect.impl.Renderer;
import com.sun.scenario.effect.impl.prism.PrRenderer;

class WCGraphicsPrismContext extends WCGraphicsContext {

    public enum Type {
        /**
         * Base context associated with the topmost page buffer.
         * Created and disposed during a single render pass.
         */
        PRIMARY,

        /**
         * A context associated with a dedicated buffer representing
         * a separate render target like canvas, buffered image etc.
         * Its life cycle is not limited to a single render pass.
         */
        DEDICATED
    }

    private final static PlatformLogger log =
            PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
    private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
            AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
            System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));

    Graphics baseGraphics;
    private BaseTransform baseTransform;

    private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();

    private ContextState state = new ContextState();

    // Cache for getPlatformGraphics
    private Graphics cachedGraphics = null;

    private int fontSmoothingType;
    private boolean isRootLayerValid = false;

    WCGraphicsPrismContext(Graphics g) {
        state.setClip(g.getClipRect());
        state.setAlpha(g.getExtraAlpha());
        baseGraphics = g;
        initBaseTransform(g.getTransformNoClone());
    }

    WCGraphicsPrismContext() {
    }

    public Type type() {
        return Type.PRIMARY;
    }

    final void initBaseTransform(BaseTransform t) {
        baseTransform = new Affine3D(t);
        state.setTransform((Affine3D)baseTransform);
    }

    private void resetCachedGraphics() {
        cachedGraphics = null;
    }

    @Override
    public Object getPlatformGraphics() {
        return getGraphics(false);
    }

    Graphics getGraphics(boolean checkClip) {
        if (cachedGraphics == null) {
            Layer l = state.getLayerNoClone();
            cachedGraphics = (l != null)
                    ? l.getGraphics()
                    : baseGraphics;

            state.apply(cachedGraphics);

            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
                         cachedGraphics);
            }
        }

        Rectangle clip = cachedGraphics.getClipRectNoClone();
        return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
            ? null
            : cachedGraphics;
    }

    public void saveState()
    {
        state.markAsRestorePoint();
        saveStateInternal();
    }

    private void saveStateInternal()
    {
        states.add(state);
        state = state.clone();
    }

    private void startNewLayer(Layer layer) {
        saveStateInternal();

        // layer has the same bounds as clip, so we have to translate
        Rectangle clip = state.getClipNoClone();

        //left-side (post-) translate.
        //NB! an order of transforms is essential!
        Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
                -clip.x,
                -clip.y));
        newTr.concatenate(state.getTransformNoClone());

        //move clip to (0, 0) - start of texture
        clip.x = 0;
        clip.y = 0;
        //no-clone - no-set!

        Graphics g = getGraphics(true);
        if (g != null &amp;&amp; g != baseGraphics) {
            layer.init(g);
        }

        state.setTransform(newTr);
        state.setLayer(layer);

        resetCachedGraphics();
    }

    private void renderLayer(final Layer layer) {
        WCTransform cur = getTransform();

        //translate to (layer.getX(), layer.getY())
        setTransform(new WCTransform(
            1.0, 0.0,
            0.0, 1.0,
            layer.getX(), layer.getY()));

        // composite drawing delegated to the layer rendering
        Graphics g = getGraphics(true);
        if (g != null) {
            layer.render(g);
        }

        //restore transform
        setTransform(cur);
    }

    private void restoreStateInternal() {
        int size = states.size();
        if (size == 0) {
            assert false: &quot;Unbalanced restoreState&quot;;
            return;
        }

        Layer layer = state.getLayerNoClone();
        state = states.remove(size - 1);
        if (layer != state.getLayerNoClone()) {
            renderLayer(layer);
            layer.dispose();
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;Popped layer &quot; + layer);
            }
        } else {
            resetCachedGraphics();
        }
    }

    public void restoreState()
    {
        log.fine(&quot;restoring state&quot;);
        do {
            restoreStateInternal();
        } while ( !state.isRestorePoint() );
    }

    /**
     *  Renders all layers to the underlaying Graphics, but preserves the
     *  current state and the states stack
     */
    private void flushAllLayers() {
        if (state == null) {
            // context disposed
            return;
        }

        if (isRootLayerValid) {
            log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
            return;
        }

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;FlushAllLayers&quot;);
        }

        ContextState currentState = state;

        for (int i = states.size() - 1; i &gt;=0; i--) {
            Layer layer = state.getLayerNoClone();
            state = states.get(i);
            if (layer != state.getLayerNoClone()) {
                renderLayer(layer);
            } else {
                resetCachedGraphics();
            }
        }

        Layer layer = state.getLayerNoClone();
        if (layer != null) {
            renderLayer(layer);
        }

        state = currentState;
        isRootLayerValid = true;
    }


    public void dispose() {
        if (!states.isEmpty()) {
            log.fine(&quot;Unbalanced saveState/restoreState&quot;);
        }
        for (ContextState state: states) {
            if (state.getLayerNoClone() != null) {
                state.getLayerNoClone().dispose();
            }
        }
        states.clear();

        if (state != null &amp;&amp; state.getLayerNoClone() != null) {
            state.getLayerNoClone().dispose();
        }
        state = null;
    }


    public void setClip(WCPath path, boolean isOut) {
        Affine3D tr = new Affine3D(state.getTransformNoClone());
        path.transform(
                tr.getMxx(), tr.getMyx(),
                tr.getMxy(), tr.getMyy(),
                tr.getMxt(), tr.getMyt());
        //path now is in node coordinates, as well as clip

        if (!isOut) {
            WCRectangle pathBounds = path.getBounds();

            // path bounds could be fractional so 'inclusive' rounding
            // is used for determining clip rectangle
            int pixelX = (int) Math.floor(pathBounds.getX());
            int pixelY = (int) Math.floor(pathBounds.getY());
            int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
            int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;

            state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
        }

        Rectangle clip = state.getClipNoClone();

        if (isOut) {
            path.addRect(clip.x, clip.y, clip.width, clip.height);
            //Out clip path is always EVENODD.
        }

        path.translate(-clip.x, -clip.y);

        Layer layer = new ClipLayer(
            getGraphics(false), clip, path, type() == Type.DEDICATED);

        startNewLayer(layer);

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
            log.fine(&quot;Pushed layer &quot; + layer);
        }
    }

    private Rectangle transformClip(Rectangle localClip) {
        if (localClip==null) {
            return null;
        }

        float[] points = new float[] {
            localClip.x, localClip.y,
            localClip.x + localClip.width, localClip.y,
            localClip.x, localClip.y + localClip.height,
            localClip.x  + localClip.width, localClip.y + localClip.height};
        state.getTransformNoClone().transform(points, 0, points, 0, 4);
        float minX = Math.min(
               points[0], Math.min(
               points[2], Math.min(
               points[4], points[6])));
        float maxX = Math.max(
               points[0], Math.max(
               points[2], Math.max(
               points[4], points[6])));
        float minY = Math.min(
               points[1], Math.min(
               points[3], Math.min(
               points[5], points[7])));
        float maxY = Math.max(
               points[1], Math.max(
               points[3], Math.max(
               points[5], points[7])));
        return new Rectangle(new RectBounds(minX, minY, maxX, maxY));

/* #1 loose rotate
        state.getTransformNoClone().transform(localClip, localClip);
*/
/* #2 problem with negative coordinates
        RectBounds rb = TransformedShape.transformedShape(
            new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
            state.getTransformNoClone()).getBounds();
        return rb.isEmpty()
            ? null
            : new Rectangle(rb);
 */
    }

    private void setClip(Rectangle shape) {
        Affine3D tr = state.getTransformNoClone();
        if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
         &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
         &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
            //There is no rotation here: scale + translation.
            //Fast &amp; easy!
            state.clip(transformClip(shape));
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;setClip({0})&quot;, shape);
            }
            if (DEBUG_DRAW_CLIP_SHAPE) {
                //Draw clip shape
                Rectangle rc = state.getClipNoClone();
                if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
                    WCTransform cur = getTransform();
                    //translate to (layer.getX(), layer.getY())
                    setTransform(new WCTransform(
                        1.0, 0.0,
                        0.0, 1.0,
                        0.0, 0.0));

                    Graphics g2d = getGraphics(true);
                    if (g2d != null) {
                        float fbase = (float)Math.random();
                        g2d.setPaint(new Color(
                                fbase,
                                1f - fbase,
                                0.5f,
                                0.1f));
                        g2d.setStroke(new BasicStroke());
                        g2d.fillRect(rc.x, rc.y, rc.width, rc.height);

                        g2d.setPaint(new Color(
                                1f - fbase,
                                fbase,
                                0.5f,
                                1f));
                        g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
                    }
                    //restore transform
                    setTransform(cur);
                    state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
                }
            }
            if (cachedGraphics != null) {
                cachedGraphics.setClipRect(state.getClipNoClone());
            }
        } else {
            //twisted axis set
            WCPath path = new WCPathImpl();
            path.addRect(shape.x, shape.y, shape.width, shape.height);
            setClip(path, false);
        }
    }

    public void setClip(int cx, int cy, int cw, int ch) {
        setClip(new Rectangle(cx, cy, cw, ch));
    }

    public void setClip(WCRectangle c) {
        setClip(new Rectangle((int)c.getX(), (int)c.getY(),
                              (int)c.getWidth(), (int)c.getHeight()));
    }

    public WCRectangle getClip() {
        Rectangle r = state.getClipNoClone();
        return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
    }

    protected Rectangle getClipRectNoClone() {
        return state.getClipNoClone();
    }

    protected Affine3D getTransformNoClone() {
        return state.getTransformNoClone();
    }

    public void translate(float x, float y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
        }
        state.translate(x, y);
        if (cachedGraphics != null) {
            cachedGraphics.translate(x, y);
        }
    }

    public void scale(float sx, float sy) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
        }
        state.scale(sx, sy);
        if (cachedGraphics != null) {
            cachedGraphics.scale(sx, sy);
        }
    }

    public void rotate(float radians) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
        }
        state.rotate(radians);
        if (cachedGraphics != null) {
            cachedGraphics.setTransform(state.getTransformNoClone());
        }
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderRect(float x, float y, float w, float h,
                                       DropShadow shadow, BasicStroke stroke)
    {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldCalculateIntersection() {
        return false;
    }

    @Override
    public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = (rgba != null)
                    ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
                    : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
            log.fine(String.format(format, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
                DropShadow shadow = state.getShadowNoClone();
                // TextureMapperJava::drawSolidColor calls fillRect with perspective
                // projection.
                if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, 0, 0);
                    render(g, shadow, paint, null, node);
<A NAME="15"></A>                } else {
                    g.setPaint(paint);
                    g.fillRect(x, y, w, h);
                <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#15',2,'match56-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            }
        }.paint();
    }

    @Override
    public void fillRoundedRect(final float x</B></FONT>, final float y, final float w, final float h,
        final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
        final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
        final int rgba)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
                    + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
                    x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
                    bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                // Prism only supports single arcWidth/Height.
                // We work around by calculating average width and height here

                float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
                float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;

                Paint paint = createColor(rgba);
                DropShadow shadow = state.getShadowNoClone();
                if (shadow != null) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, arcW, arcH);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRoundRect(x, y, w, h, arcW, arcH);
                }
            }
        }.paint();
    }

    @Override
    public void clearRect(final float x, final float y, final float w, final float h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
        }
        if (shouldCalculateIntersection()) {
            // No intersection is applicable for clearRect.
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.clearQuad(x, y, x + w, y + h);
            }
        }.paint();
    }

    @Override
    public void setFillColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
        }
        state.setPaint(createColor(rgba));
    }

    @Override
    public void setFillGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setTextMode(boolean fill, boolean stroke, boolean clip) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
        }
        state.setTextMode(fill, stroke, clip);
    }

    @Override
    public void setFontSmoothingType(int fontSmoothingType) {
        this.fontSmoothingType = fontSmoothingType;
    }

    @Override
    public int getFontSmoothingType() {
        return fontSmoothingType;
    }

    @Override
    public void setStrokeStyle(int style) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeStyle({0})&quot;, style);
        }
        state.getStrokeNoClone().setStyle(style);
    }

    @Override
    public void setStrokeColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
        }
        state.getStrokeNoClone().setPaint(createColor(rgba));
    }

    @Override
    public void setStrokeWidth(float width) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
        }
        state.getStrokeNoClone().setThickness(width);
    }

    @Override
    public void setStrokeGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setLineDash(float offset, float... sizes) {
        if (log.isLoggable(Level.FINE)) {
            StringBuilder s = new StringBuilder(&quot;[&quot;);
            for (int i=0; i &lt; sizes.length; i++) {
                s.append(sizes[i]).append(',');
            }
            s.append(']');
            log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
        }
        state.getStrokeNoClone().setDashOffset(offset);
        if (sizes != null) {
            boolean allZero = true;
            for (int i = 0; i &lt; sizes.length; i++) {
                if (sizes[i] != 0) {
                    allZero = false;
                    break;
                }
            }
            if (allZero) {
                sizes = null;
            }
        }
        state.getStrokeNoClone().setDashSizes(sizes);
    }

    @Override
    public void setLineCap(int lineCap) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineCap(lineCap);
    }

    @Override
    public void setLineJoin(int lineJoin) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineJoin(lineJoin);
    }

    @Override
    public void setMiterLimit(float miterLimit) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
        }
        state.getStrokeNoClone().setMiterLimit(miterLimit);
    }

    @Override
    public void setShadow(float dx, float dy, float blur, int rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
            log.fine(String.format(format, dx, dy, blur, rgba));
        }
        state.setShadow(createShadow(dx, dy, blur, rgba));
    }

    @Override
    public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPolygon({0})&quot;,
                    new Object[] {shouldAntialias});
        }
        if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
                                state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Path2D p2d = (Path2D) path.getPlatformPath();
                g.setPaint(state.getPaintNoClone());
                g.fill(p2d);
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(p2d);
                }
            }
        }.paint();
    }

    @Override
    public void drawLine(final int x0, final int y0, final int x1, final int y1) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
                    new Object[] {x0, y0, x1, y1});
        }
        Line2D line = new Line2D(x0, y0, x1, y1);
        if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawLine(x0, y0, x1, y1);
                }
            }
        }.paint();
    }

    @Override
    public void drawPattern(
        final WCImage texture,
        final WCRectangle srcRect,
        final WCTransform patternTransform,
        final WCPoint phase,
        final WCRectangle destRect)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
                    new Object[] {destRect.getIntX(), destRect.getIntY(),
                                  destRect.getIntWidth(),
                                  destRect.getIntHeight()});
        }
        if (!shouldRenderRect(destRect.getX(), destRect.getY(),
                              destRect.getWidth(), destRect.getHeight(), null, null))
        {
            return;
        }
        if (texture != null) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    // The handling of pattern transform is modeled after the WebKit
                    // ImageCG.cpp's Image::drawPattern()
                    float adjustedX = phase.getX()
                            + srcRect.getX() * (float) patternTransform.getMatrix()[0];
                    float adjustedY = phase.getY()
                            + srcRect.getY() * (float) patternTransform.getMatrix()[3];
                    float scaledTileWidth =
                            srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
                    float scaledTileHeight =
                            srcRect.getHeight() * (float) patternTransform.getMatrix()[3];

                    Image img = ((PrismImage)texture).getImage();

                    // Create subImage only if srcRect doesn't fit the texture bounds. See RT-20193.
                    if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {

                        img = img.createSubImage(srcRect.getIntX(),
                                                 srcRect.getIntY(),
                                                 (int)Math.ceil(srcRect.getWidth()),
                                                 (int)Math.ceil(srcRect.getHeight()));
                    }
                    g.setPaint(new ImagePattern(
                               img,
                               adjustedX, adjustedY,
                               scaledTileWidth, scaledTileHeight,
                               false, false));

                    g.fillRect(destRect.getX(), destRect.getY(),
                               destRect.getWidth(), destRect.getHeight());
                }
            }.paint();
        }
    }

    @Override
    public void drawImage(final WCImage img,
                          final float dstx, final float dsty, final float dstw, final float dsth,
                          final float srcx, final float srcy, final float srcw, final float srch)
    {
        if (log.isLoggable(Level.FINE)){
            log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
                    &quot;src({4},{5},{6},{7}))&quot;,
                    new Object[] {dstx, dsty, dstw, dsth,
                                  srcx, srcy, srcw, srch});
        }
        if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
            return;
        }
        if (img instanceof PrismImage) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    PrismImage pi = (PrismImage) img;
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        NGImageView node = new NGImageView();
                        node.setImage(pi.getImage());
                        node.setX(dstx);
                        node.setY(dsty);
                        node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
                        node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
                        render(g, shadow, null, null, node);
                    } else {
                        pi.draw(g,
                                (int) dstx, (int) dsty,
                                (int) (dstx + dstw), (int) (dsty + dsth),
                                (int) srcx, (int) srcy,
                                (int) (srcx + srcw), (int) (srcy + srch));
                    }
                }
            }.paint();
        }
    }

    @Override
    public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
        if (!shouldRenderRect(x, y, w, h, null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                image.order(ByteOrder.nativeOrder());
                Image img = Image.fromByteBgraPreData(image, w, h);
                ResourceFactory rf = g.getResourceFactory();
                Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
                g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
                txt.dispose();
            }
        }.paint();
    }

    @Override
    public void drawIcon(WCIcon icon, int x, int y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
                    new Object[] {x, y});
        }
    }

    @Override
    public void drawRect(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
                    new Object[]{x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint c = state.getPaintNoClone();
                if (c != null &amp;&amp; c.isOpaque()) {
                    g.setPaint(c);
                    g.fillRect(x, y, w, h);
                }

                if (state.getStrokeNoClone().apply(g)) {
                    g.drawRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void drawString(final WCFont f, final int[] glyphs,
                           final float[] advances, final float x, final float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
                    glyphs.length, x, y));
        }
        PGFont font = (PGFont)f.getPlatformFont();
        TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);

        DropShadow shadow = state.getShadowNoClone();
        BasicStroke stroke = state.isTextStroke()
                ? state.getStrokeNoClone().getPlatformStroke()
                : null;

        final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
        if (shouldCalculateIntersection()) {
            Metrics m = strike.getMetrics();
            gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
            if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
                return;
            }
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = state.isTextFill()
                        ? state.getPaintNoClone()
                        : null;
                if (shadow != null) {
                    final NGText span = new NGText();
                    span.setGlyphs(new GlyphList[] {gl});
                    span.setFont(font);
                    span.setFontSmoothingType(fontSmoothingType);
                    render(g, shadow, paint, stroke, span);
                } else {
                    if (paint != null) {
                        g.setPaint(paint);
                        g.drawString(gl, strike, x, y, null, 0, 0);
                    }
                    if (stroke != null) {
<A NAME="11"></A>                        paint = state.getStrokeNoClone().getPaint();
                        if (paint != null) {
                            g.setPaint(paint);
                            <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#11',2,'match56-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>g.setStroke(stroke);
                            g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
                        }
                    }
                }
            }
        }.paint();
    }

    @Override </B></FONT>public void drawString(WCFont f, String str, boolean rtl,
            int from, int to, float x, float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;str='%s' (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
                    str, str.length(), from, to, rtl, x, y));
        }
        TextLayout layout = TextUtilities.createLayout(
                str.substring(from, to), f.getPlatformFont());
        int count = 0;
        GlyphList[] runs = layout.getRuns();
        for (GlyphList run: runs) {
            count += run.getGlyphCount();
        }

        int[] glyphs = new int[count];
        float[] adv = new float[count];
        count = 0;
        for (GlyphList run: layout.getRuns()) {
            int gc = run.getGlyphCount();
            for (int i = 0; i &lt; gc; i++) {
                glyphs[count] = run.getGlyphCode(i);
                adv[count] = run.getPosX(i + 1) - run.getPosX(i);
                count++;
            }
        }

        // adjust x coordinate (see RT-29908)
        if (rtl) {
            x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
                  layout.getBounds().getWidth());
        } else {
            x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
        }
        drawString(f, glyphs, adv, x, y);
    }

    @Override
    public void setComposite(int composite) {
        log.fine(&quot;setComposite({0})&quot;, composite);
        state.setCompositeOperation(composite);
    }

    @Override
    public void drawEllipse(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
                    new Object[] { x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(state.getPaintNoClone());
                g.fillEllipse(x, y, w, h);
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawEllipse(x, y, w, h);
                }
            }
        }.paint();
    }

    private final static BasicStroke focusRingStroke =
        new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
                         BasicStroke.JOIN_ROUND, 0.0f,
                         new float[] {1.0f}, 0.0f);

    @Override
    public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(createColor(rgba));
                BasicStroke stroke = g.getStroke();
                g.setStroke(focusRingStroke);
                g.drawRoundRect(x, y, w, h, 4, 4);
                g.setStroke(stroke);
            }
        }.paint();
    }

    public void setAlpha(float alpha) {
        log.fine(&quot;setAlpha({0})&quot;, alpha);

        state.setAlpha(alpha);

        if (null != cachedGraphics) {
            cachedGraphics.setExtraAlpha(state.getAlpha());
        }
    }

    public float getAlpha() {
        return state.getAlpha();
    }

    @Override public void beginTransparencyLayer(float opacity) {
        TransparencyLayer layer = new TransparencyLayer(
                getGraphics(false), state.getClipNoClone(), opacity);

        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
        }

        //[saveStateIntertal] will work as [saveState]
        state.markAsRestorePoint();

        startNewLayer(layer);
    }

    @Override public void endTransparencyLayer() {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
        }

        //pair to [startNewLayer] that works as [saveState] call
        restoreState();
    }

    @Override
    public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
            }
        }.paint();
    }

    @Override
    public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
                              int pressedPart, int hoveredPart)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
        }

        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
            }
        }.paint();
    }

    private static Rectangle intersect(Rectangle what, Rectangle with) {
        if (what == null) {
            return with;
        }
        RectBounds b = what.toRectBounds();
        b.intersectWith(with);
        what.setBounds(b);
        return what;
    }

    static Color createColor(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color(r, g, b, a);
    }

    private static Color4f createColor4f(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color4f(r, g, b, a);
    }

    private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
        if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
            return null;
        }
        DropShadow shadow = new DropShadow();
        shadow.setOffsetX((int) dx);
        shadow.setOffsetY((int) dy);
        shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
        shadow.setColor(createColor4f(rgba));
        return shadow;
    }

    private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
        if (node instanceof NGShape) {
            NGShape shape = (NGShape) node;
            Shape realShape = shape.getShape();
            Paint strokePaint = state.getStrokeNoClone().getPaint();
            if ((stroke != null) &amp;&amp; (strokePaint != null)) {
                realShape = stroke.createStrokedShape(realShape);
                shape.setDrawStroke(stroke);
                shape.setDrawPaint(strokePaint);
                shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
            } else {
                shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
            }
            shape.setFillPaint(paint);
            shape.setContentBounds(realShape.getBounds());
        }
        boolean culling = g.hasPreCullingBits();
        g.setHasPreCullingBits(false);
        node.setEffect(effect);
        node.render(g);
        g.setHasPreCullingBits(culling);
    }

    private static final class ContextState {
        private final WCStrokeImpl stroke = new WCStrokeImpl();
        private Rectangle clip;
        private Paint paint;
        private float alpha;

        private boolean textFill = true;
        private boolean textStroke = false;
        private boolean textClip = false;
        private boolean restorePoint = false;

        private DropShadow shadow;
        private Affine3D xform;
        private GeneralTransform3D perspectiveTransform;
        private Layer layer;
        private int compositeOperation;

        private ContextState() {
            clip = null;
            paint = Color.BLACK;
            stroke.setPaint(Color.BLACK);
            alpha = 1.0f;
            xform = new Affine3D();
            perspectiveTransform = new GeneralTransform3D();
            compositeOperation = COMPOSITE_SOURCE_OVER;
        }

        private ContextState(ContextState state) {
            stroke.copyFrom(state.getStrokeNoClone());
            setPaint(state.getPaintNoClone());
            clip = state.getClipNoClone();
            if (clip != null) {
                clip = new Rectangle(clip);
            }
            xform = new Affine3D(state.getTransformNoClone());
            perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
            setShadow(state.getShadowNoClone());
            setLayer(state.getLayerNoClone());
            setAlpha(state.getAlpha());
            setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
            setCompositeOperation(state.getCompositeOperation());
        }

        @Override
        protected ContextState clone() {
            return new ContextState(this);
        }

        private void apply(Graphics g) {
            g.setTransform(getTransformNoClone());
            g.setPerspectiveTransform(getPerspectiveTransformNoClone());
            g.setClipRect(getClipNoClone());
            g.setExtraAlpha(getAlpha());
        }

        private int getCompositeOperation() {
            return compositeOperation;
        }

        private void setCompositeOperation(int compositeOperation) {
            this.compositeOperation = compositeOperation;
        }

        private WCStrokeImpl getStrokeNoClone() {
            return stroke;
        }

        private Paint getPaintNoClone() {
            return paint;
        }

        private void setPaint(Paint paint) {
            this.paint = paint;
        }

        private Rectangle getClipNoClone() {
            return clip;
        }

        private Layer getLayerNoClone() {
            return layer;
        }

        private void setLayer(Layer layer) {
            this.layer = layer;
        }

        private void setClip(Rectangle area) {
            clip = area;
        }

        private void clip(Rectangle area) {
            if (null == clip) {
                clip = area;
            } else {
                clip.intersectWith(area);
            }
        }

        private void setAlpha(float alpha) {
            this.alpha = alpha;
        }

        private float getAlpha() {
            return alpha;
        }

        private void setTextMode(boolean fill, boolean stroke, boolean clip) {
            textFill = fill;
            textStroke = stroke;
            textClip = clip;
        }

        private boolean isTextFill() {
            return textFill;
        }

        private boolean isTextStroke() {
            return textStroke;
        }

        private boolean isTextClip() {
            return textClip;
        }

        private void markAsRestorePoint() {
            restorePoint = true;
        }

        private boolean isRestorePoint() {
            return restorePoint;
        }

        private void setShadow(DropShadow shadow) {
            this.shadow = shadow;
        }

        private DropShadow getShadowNoClone() {
            return shadow;
        }

        private Affine3D getTransformNoClone() {
            return xform;
        }

        private GeneralTransform3D getPerspectiveTransformNoClone() {
            return perspectiveTransform;
        }

        private void setTransform(final Affine3D at) {
            this.xform.setTransform(at);
        }

        private void setPerspectiveTransform(final GeneralTransform3D gt) {
            this.perspectiveTransform.set(gt);
        }

        private void concatTransform(Affine3D at) {
            xform.concatenate(at);
        }

        private void translate(double dx, double dy) {
            xform.translate(dx, dy);
        }

        private void scale(double sx, double sy) {
            xform.scale(sx,sy);
        }

        private void rotate(double radians) {
            xform.rotate(radians);
        }
    }

    private abstract static class Layer {
        FilterContext fctx;
        PrDrawable buffer;
        Graphics graphics;
        final Rectangle bounds;
        boolean permanent;

        Layer(Graphics g, Rectangle bounds, boolean permanent) {
            this.bounds = new Rectangle(bounds);
            this.permanent = permanent;

            // avoid creating zero-size drawable, see also RT-21410
            int w = Math.max(bounds.width, 1);
            int h = Math.max(bounds.height, 1);
            fctx = getFilterContext(g);
            if (permanent) {
                ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
                RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
                rtt.makePermanent();
                buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
            } else {
                buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
            }
        }

        Graphics getGraphics() {
            if (graphics == null) {
                graphics = buffer.createGraphics();
            }
            return graphics;
        }

        abstract void init(Graphics g);

        abstract void render(Graphics g);

        private void dispose() {
            if (buffer != null) {
                if (permanent) {
                    buffer.flush(); // releases the resource
                } else {
                    Effect.releaseCompatibleImage(fctx, buffer);
                }
                fctx = null;
                buffer = null;
            }
        }

        private double getX() { return (double) bounds.x; }
        private double getY() { return (double) bounds.y; }
    }

    private final class TransparencyLayer extends Layer {
        private final float opacity;

        private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
            super(g, bounds, false);
            this.opacity = opacity;
        }

        @Override void init(Graphics g) {
            state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
        }

        @Override void render(Graphics g) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    float op = g.getExtraAlpha();
                    g.setExtraAlpha(opacity);
                    Affine3D tx = new Affine3D(g.getTransformNoClone());
                    g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                    g.drawTexture(buffer.getTextureObject(),
                            bounds.x, bounds.y, bounds.width, bounds.height);
                    g.setTransform(tx);
                    g.setExtraAlpha(op);
                }
            }.paint(g);
        }

        @Override public String toString() {
            return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
                bounds.x, bounds.y, bounds.width, bounds.height, opacity);
        }
    }

    private static final class ClipLayer extends Layer {
        private final WCPath normalizedToClipPath;
        private boolean srcover;

        private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
                          boolean permanent)
        {
            super(g, bounds, permanent);
            this.normalizedToClipPath = normalizedToClipPath;
            srcover = true;
        }

        @Override void init(Graphics g) {
            RTTexture texture = null;
            ReadbackGraphics readbackGraphics = null;
            try {
                readbackGraphics = (ReadbackGraphics) g;
                texture = readbackGraphics.readBack(bounds);
                getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
            } finally {
                if (readbackGraphics != null &amp;&amp; texture != null) {
                    readbackGraphics.releaseReadBackBuffer(texture);
                }
            }
            srcover = false;
        }

        @Override void render(Graphics g) {
            Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();

            // render normalizedToClipPath to a drawable
            PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
                    fctx, bounds.width, bounds.height);
            Graphics bufferGraphics = bufferImg.createGraphics();

            bufferGraphics.setPaint(Color.BLACK);
            bufferGraphics.fill(p2d);

            // blend buffer and clipImg onto |g|
            if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
                MaskTextureGraphics mg = (MaskTextureGraphics) g;
                if (srcover) {
                    mg.drawPixelsMasked(buffer.getTextureObject(),
                                        bufferImg.getTextureObject(),
                                        bounds.x, bounds.y, bounds.width, bounds.height,
                                        0, 0, 0, 0);
                } else {
                    mg.maskInterpolatePixels(buffer.getTextureObject(),
                                             bufferImg.getTextureObject(),
                                             bounds.x, bounds.y, bounds.width, bounds.height,
                                             0, 0, 0, 0);
                }
            } else {
                Blend blend = new Blend(Blend.Mode.SRC_IN,
                        new PassThrough(bufferImg, bounds.width, bounds.height),
                        new PassThrough(buffer, bounds.width, bounds.height));
                Affine3D tx = new Affine3D(g.getTransformNoClone());
                g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
                g.setTransform(tx);
            }

            Effect.releaseCompatibleImage(fctx, bufferImg);
        }

        @Override public String toString() {
            return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
                    bounds.x, bounds.y, bounds.width, bounds.height,
                    normalizedToClipPath);
        }
    }

    private abstract class Composite {
        abstract void doPaint(Graphics g);

        void paint() {
            paint(getGraphics(true));
        }

        void paint(Graphics g) {
            if (g != null) {
                CompositeMode oldCompositeMode = g.getCompositeMode();
                switch (state.getCompositeOperation()) {
                    // decode operations that don't require Blend first
                    case COMPOSITE_COPY:
                        g.setCompositeMode(CompositeMode.SRC);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    case COMPOSITE_SOURCE_OVER:
                        g.setCompositeMode(CompositeMode.SRC_OVER);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    default:
                        // other operations require usage of Blend
                        blend(g);
                        break;
                }
                isRootLayerValid = false;
            }
        }

        private void blend(Graphics g) {
            FilterContext fctx = getFilterContext(g);
            PrDrawable dstImg = null;
            PrDrawable srcImg = null;
            ReadbackGraphics readBackGraphics = null;
            RTTexture texture = null;
            Rectangle clip = state.getClipNoClone();
            WCImage image = getImage();
            try {
                if (image != null &amp;&amp; image instanceof PrismImage) {
                    // blending on canvas
                    dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                    Graphics dstG = dstImg.createGraphics();
                    ((PrismImage) image).draw(dstG,
                            0, 0, clip.width, clip.height,
                            clip.x, clip.y, clip.width, clip.height);
                } else {
                    // blending on page
                    readBackGraphics = (ReadbackGraphics) g;
                    texture = readBackGraphics.readBack(clip);
                    dstImg = PrDrawable.create(fctx, texture);
                }

                srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                Graphics srcG = srcImg.createGraphics();
                state.apply(srcG);
                doPaint(srcG);

                g.clear();
                PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);

            } finally {
                if (srcImg != null) {
                    Effect.releaseCompatibleImage(fctx, srcImg);
                }
                if (dstImg != null) {
                    if (readBackGraphics != null &amp;&amp; texture != null) {
                        readBackGraphics.releaseReadBackBuffer(texture);
                    } else {
                        Effect.releaseCompatibleImage(fctx, dstImg);
                    }
                }
            }
        }

        // provides some syntax sugar for createEffect()
        private Effect createBlend(Blend.Mode mode,
                                   PrDrawable dstImg,
                                   PrDrawable srcImg,
                                   int width,
                                   int height)
        {
            return new Blend(
                    mode,
                    new PassThrough(dstImg, width, height),
                    new PassThrough(srcImg, width, height));
        }

        private Effect createEffect(PrDrawable dstImg,
                                    PrDrawable srcImg,
                                    int width,
                                    int height)
        {
            switch (state.getCompositeOperation()) {
                case COMPOSITE_CLEAR: // same as xor
                case COMPOSITE_XOR:
                    return new Blend(
                            SRC_OVER,
                            createBlend(SRC_OUT, dstImg, srcImg, width, height),
                            createBlend(SRC_OUT, srcImg, dstImg, width, height)
                    );
                case COMPOSITE_SOURCE_IN:
                    return createBlend(SRC_IN, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_OUT:
                    return createBlend(SRC_OUT, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_ATOP:
                    return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
                case COMPOSITE_DESTINATION_OVER:
                    return createBlend(SRC_OVER, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_IN:
                    return createBlend(SRC_IN, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_OUT:
                    return createBlend(SRC_OUT, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_ATOP:
                    return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
                case COMPOSITE_HIGHLIGHT:
                    return createBlend(ADD, dstImg, srcImg, width, height);
                default:
                    return createBlend(SRC_OVER, dstImg, srcImg, width, height);
            }
        }
    }

    private static final class PassThrough extends Effect {
        private final PrDrawable img;
        private final int width;
        private final int height;

        private PassThrough(PrDrawable img, int width, int height) {
            this.img = img;
            this.width = width;
            this.height = height;
        }

        @Override public ImageData filter(
                FilterContext fctx,
                BaseTransform transform,
                Rectangle outputClip,
                Object renderHelper,
                Effect defaultInput) {
            // We have an unpaired lock() here, because unlocking is done
            // internally by ImageData. See RT-33625 for details.
            img.lock();
            ImageData imgData = new ImageData(fctx, img, new Rectangle(
                                              (int) transform.getMxt(),
                                              (int) transform.getMyt(),
                                              width, height));
            imgData.setReusable(true);
            return imgData;
        }

        @Override public RectBounds getBounds(
                BaseTransform transform,
                Effect defaultInput) {
            return null;
        }

        @Override public AccelType getAccelType(FilterContext fctx) {
            return AccelType.INTRINSIC;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null;
        }
    }

    private static FilterContext getFilterContext(Graphics g) {
        Screen screen = g.getAssociatedScreen();
        if (screen == null) {
            ResourceFactory factory = g.getResourceFactory();
            return PrFilterContext.getPrinterContext(factory);
        } else {
            return PrFilterContext.getInstance(screen);
        }
    }

    @Override
    public void strokeArc(final int x, final int y, final int w, final int h,
                          final int startAngle, final int angleSpan)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
                                   x, y, w, h, startAngle, angleSpan));
        }
        Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
        if (state.getStrokeNoClone().isApplicable() &amp;&amp;
            !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(arc);
                }
            }
        }.paint();
    }

    @Override
    public WCImage getImage() {
        return null;
    }

    @Override
    public void strokeRect(final float x, final float y, final float w, final float h,
                           final float lineWidth) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
                                   x, y, w, h, lineWidth));
        }
        BasicStroke stroke = new BasicStroke(
            lineWidth,
            BasicStroke.CAP_BUTT,
            BasicStroke.JOIN_MITER,
            Math.max(1.0f, lineWidth),
            state.getStrokeNoClone().getDashSizes(),
            state.getStrokeNoClone().getDashOffset());

        if (!shouldRenderRect(x, y, w, h, null, stroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setStroke(stroke);
                Paint paint = state.getStrokeNoClone().getPaint();
                if (paint == null) {
                    paint = state.getPaintNoClone();
                }
                g.setPaint(paint);
                g.drawRect(x, y, w, h);
            }
        }.paint();
    }

    @Override
    public void strokePath(final WCPath path) {
        log.fine(&quot;strokePath&quot;);
        if (path != null) {
            final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
            final DropShadow shadow = state.getShadowNoClone();
            final Path2D p2d = (Path2D)path.getPlatformPath();

            if ((stroke == null &amp;&amp; shadow == null) ||
                !shouldRenderShape(p2d, shadow, stroke))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, null, stroke, node);
                    } else if (stroke != null) {
                        Paint paint = state.getStrokeNoClone().getPaint();
                        if (paint == null) {
                            paint = state.getPaintNoClone();
                        }
                        g.setPaint(paint);
<A NAME="18"></A>                        g.setStroke(stroke);
                        g.draw(p2d);
                    }
                <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#18',2,'match56-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            }.paint();
        }
    }

    @Override
    public void fillPath(final WCPath path) {
        log.fine</B></FONT>(&quot;fillPath&quot;);
        if (path != null) {
            if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
                                   state.getShadowNoClone(), null))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    Path2D p2d = (Path2D) path.getPlatformPath();
                    Paint paint = state.getPaintNoClone();
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, paint, null, node);
                    } else {
                        g.setPaint(paint);
                        g.fill(p2d);
                    }
                }
            }.paint();
        }
    }

    public void setPerspectiveTransform(WCTransform tm) {
        final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
        state.setPerspectiveTransform(at);
        resetCachedGraphics();
    }

    public void setTransform(WCTransform tm) {
        final double m[] = tm.getMatrix();
        final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        if (state.getLayerNoClone() == null) {
            at.preConcatenate(baseTransform);
        }
        state.setTransform(at);
        resetCachedGraphics();
    }

    public WCTransform getTransform() {
        Affine3D xf = state.getTransformNoClone();
        return new WCTransform(xf.getMxx(), xf.getMyx(),
                               xf.getMxy(), xf.getMyy(),
                               xf.getMxt(), xf.getMyt());
    }

    public void concatTransform(WCTransform tm) {
        double m[] = tm.getMatrix();
        Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        state.concatTransform(at);
        resetCachedGraphics();
    }

    @Override
    public void flush() {
        flushAllLayers();
    }

    @Override
    public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
        return new WCLinearGradient(p1, p2);
    }

    @Override
    public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
        return new WCRadialGradient(p1, r1, p2, r2);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/GameView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
<A NAME="22"></A>import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
<FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match56-0.html#22',2,'match56-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import java.util.ArrayList;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class GameView extends VBox{
    int[] cardIndices = { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10};
    ArrayList &lt;Card&gt; cards = new ArrayList&lt;&gt;(</B></FONT>);
    private GridPane matrixCards;
    private TimeBar timeBar;
    private Image image;
    private Text timeDisplay;
    private Timer timer;
    private int min = 1;
    private int sec = 59;
    private int milliSec = 99;
    private int totalFront;

    public GameView() {
        setSpacing(20);
        setAlignment(Pos.CENTER_RIGHT);

        matrixCards = new GridPane();
        String prefix = &quot;Images/&quot;;
        String postfix = &quot;.jpg&quot;;
        shuffleCards();
        for (int col = 1; col &lt;= 5; col++) {
            for (int row = 1; row &lt;= 4; row++) {
                String cardID = Integer.toString(cardIndices[row - 1 + 4*(col-1)]);
                Card temp = new Card(prefix + cardID + postfix);
                matrixCards.add(temp, col, row);
                cards.add(temp);
            }
        }
        setTimeBar(new TimeBar());
        getChildren().addAll(matrixCards, getTimeBar());

        //Set timeDisplay
        setTimeDisplay(new Text(&quot;Time: 00:00:00&quot;));
        getTimeDisplay().setFill(Color.YELLOW);
        getTimeDisplay().setFont(Font.font(&quot;Courier&quot;, FontWeight.BOLD, FontPosture.REGULAR, 15));
        getChildren().add(getTimeDisplay());
        timerProcess(); //Set timer
    }

    //For Card
    public void shuffleCards() {
        Random rand = new Random();
        for (int i = 0; i &lt; cardIndices.length; i++) {
            int randomIndexToSwap = rand.nextInt(cardIndices.length);
            int temp = cardIndices[randomIndexToSwap];
            cardIndices[randomIndexToSwap] = cardIndices[i];
            cardIndices[i] = temp;
        }
    }
    //For timer
    private void timerProcess() {

        setTotalFront(0);
        int delay = 40;
        int period = 40;
        setTimer(new Timer());
        getTimer().scheduleAtFixedRate(new TimerTask() {
            public void run() {
                getTimeDisplay().setText(&quot;Time: &quot;+ showCountDown());
            }
        }, delay, period);
    }

    //For timer
    private String showCountDown() {
        setMilliSec(getMilliSec() -4);
        if (getMilliSec() &lt; 0){
            setMilliSec(99);
            setSec(getSec() - 1);
        }
        if (getSec() == 0){
            setSec(59);
            setMin(getMin() - 1);
        }
        if (getMin() &lt; 0) {
            getTimer().cancel();
            return &quot;00:00:00&quot;;
        };
        if (getTotalFront() == 20){
            getTimer().cancel();
        }
        return &quot;0&quot;+Integer.toString(getMin())+&quot;:&quot;+Integer.toString(getSec()/10)+Integer.toString(getSec()%10)+&quot;:&quot;+Integer.toString(getMilliSec());
    }

    private TimeBar getTimeBar() {
        return timeBar;
    }

    private void setTimeBar(TimeBar timeBar) {
        this.timeBar = timeBar;
    }

    private Image getImage() {
        return image;
    }

    private void setImage(Image image) {
        this.image = image;
    }

    public ArrayList&lt;Card&gt; getCards() {
        return cards;
    }

    private Text getTimeDisplay() {
        return timeDisplay;
    }

    private void setTimeDisplay(Text timeDisplay) {
        this.timeDisplay = timeDisplay;
    }

    private Timer getTimer() {
        return timer;
    }

    private void setTimer(Timer timer) {
        this.timer = timer;
    }

    private int getMin() {
        return min;
    }

    private void setMin(int min) {
        this.min = min;
    }

    private int getSec() {
        return sec;
    }

    private void setSec(int sec) {
        this.sec = sec;
    }

    private int getMilliSec() {
        return milliSec;
    }

    private void setMilliSec(int milliSec) {
        this.milliSec = milliSec;
    }

    private int getTotalFront() {
        return totalFront;
    }

    private void setTotalFront(int totalFront) {
        this.totalFront = totalFront;
    }
}
</PRE>

</BODY>
</HTML>
