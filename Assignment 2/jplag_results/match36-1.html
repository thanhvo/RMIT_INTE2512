<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/com/sun/javafx/reflect/MethodUtil.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.reflect;

import java.io.EOFException;
import java.security.AllPermission;
import java.security.AccessController;
import java.security.PermissionCollection;
import java.security.SecureClassLoader;
import java.security.PrivilegedExceptionAction;
import java.security.CodeSource;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import com.sun.javafx.reflect.ReflectUtil;


class Trampoline {
    static {
        if (Trampoline.class.getClassLoader() == null) {
            throw new Error(
                &quot;Trampoline must not be defined by the bootstrap classloader&quot;);
        }
        if (Trampoline.class.getClassLoader() == ClassLoader.getPlatformClassLoader()) {
            throw new Error(
                &quot;Trampoline must not be defined by the platform classloader&quot;);
        }
    }

    private static void ensureInvocableMethod(Method m)
        throws InvocationTargetException
    {
        Class&lt;?&gt; clazz = m.getDeclaringClass();
        if (clazz.equals(AccessController.class) ||
            clazz.equals(Method.class) ||
            clazz.getName().startsWith(&quot;java.lang.invoke.&quot;))
            throw new InvocationTargetException(
                new UnsupportedOperationException(&quot;invocation not supported&quot;));
    }

    private static Object invoke(Method m, Object obj, Object[] params)
        throws InvocationTargetException, IllegalAccessException
    {
        ensureInvocableMethod(m);
        return m.invoke(obj, params);
    }
}

/*
 * Create a trampoline class.
 */
public final class MethodUtil extends SecureClassLoader {
    private static final String MISC_PKG = &quot;com.sun.javafx.reflect.&quot;;
    private static final String TRAMPOLINE = MISC_PKG + &quot;Trampoline&quot;;
    private static final Method bounce = getTrampoline();

    private MethodUtil() {
        super();
    }

    public static Method getMethod(Class&lt;?&gt; cls, String name, Class&lt;?&gt;[] args)
        throws NoSuchMethodException {
        ReflectUtil.checkPackageAccess(cls);
        return cls.getMethod(name, args);
    }

    public static Method[] getMethods(Class&lt;?&gt; cls) {
        ReflectUtil.checkPackageAccess(cls);
        return cls.getMethods();
    }

    /*
     * Discover the public methods on public classes
     * and interfaces accessible to any caller by calling
     * Class.getMethods() and walking towards Object until
     * we're done.
     */
    /*public*/
    static Method[] getPublicMethods(Class&lt;?&gt; cls) {
        // compatibility for update release
        if (System.getSecurityManager() == null) {
            return cls.getMethods();
        }
        Map&lt;Signature, Method&gt; sigs = new HashMap&lt;Signature, Method&gt;();
        while (cls != null) {
            boolean done = getInternalPublicMethods(cls, sigs);
            if (done) {
                break;
            }
            getInterfaceMethods(cls, sigs);
            cls = cls.getSuperclass();
        }
        return sigs.values().toArray(new Method[sigs.size()]);
    }

    /*
     * Process the immediate interfaces of this class or interface.
     */
    private static void getInterfaceMethods(Class&lt;?&gt; cls,
                                            Map&lt;Signature, Method&gt; sigs) {
        Class&lt;?&gt;[] intfs = cls.getInterfaces();
        for (int i=0; i &lt; intfs.length; i++) {
            Class&lt;?&gt; intf = intfs[i];
            boolean done = getInternalPublicMethods(intf, sigs);
            if (!done) {
                getInterfaceMethods(intf, sigs);
            }
        }
    }

    /*
     *
     * Process the methods in this class or interface
     */
    private static boolean getInternalPublicMethods(Class&lt;?&gt; cls,
                                                    Map&lt;Signature, Method&gt; sigs) {
        Method[] methods = null;
        try {
            /*
             * This class or interface is non-public so we
             * can't use any of it's methods. Go back and
             * try again with a superclass or superinterface.
             */
            if (!Modifier.isPublic(cls.getModifiers())) {
                return false;
            }
            if (!ReflectUtil.isPackageAccessible(cls)) {
                return false;
            }

            methods = cls.getMethods();
        } catch (SecurityException se) {
            return false;
        }

        /*
         * Check for inherited methods with non-public
         * declaring classes. They might override and hide
         * methods from their superclasses or
         * superinterfaces.
         */
        boolean done = true;
        for (int i=0; i &lt; methods.length; i++) {
            Class&lt;?&gt; dc = methods[i].getDeclaringClass();
            if (!Modifier.isPublic(dc.getModifiers())) {
                done = false;
                break;
            }
        }

        if (done) {
            /*
             * We're done. Spray all the methods into
             * the list and then we're out of here.
             */
            for (int i=0; i &lt; methods.length; i++) {
                addMethod(sigs, methods[i]);
            }
        } else {
            /*
             * Simulate cls.getDeclaredMethods() by
             * stripping away inherited methods.
             */
            for (int i=0; i &lt; methods.length; i++) {
                Class&lt;?&gt; dc = methods[i].getDeclaringClass();
                if (cls.equals(dc)) {
                    addMethod(sigs, methods[i]);
                }
            }
        }
        return done;
    }

    private static void addMethod(Map&lt;Signature, Method&gt; sigs, Method method) {
        Signature signature = new Signature(method);
        if (!sigs.containsKey(signature)) {
            sigs.put(signature, method);
        } else if (!method.getDeclaringClass().isInterface()){
            /*
             * Superclasses beat interfaces.
             */
            Method old = sigs.get(signature);
            if (old.getDeclaringClass().isInterface()) {
<A NAME="39"></A>                sigs.put(signature, method);
            }
        }
    <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#39',2,'match36-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * A class that represents the unique elements of a method that will be a
     * key in the method cache.
     */
    private static class Signature {
        private final String methodName;
        private final Class&lt;?&gt;[] argClasses;
        private final int hashCode;

        Signature(Method m) {
            this.methodName = m.getName();
            this.argClasses = m.getParameterTypes();
            t</B></FONT>his.hashCode = methodName.hashCode() + Arrays.hashCode(argClasses);
        }

        @Override public int hashCode() {
            return hashCode;
        }

        @Override public boolean equals(Object o2) {
            if (this == o2) {
                return true;
            }
            Signature that = (Signature)o2;
            if (!(methodName.equals(that.methodName))) {
                return false;
            }
            if (argClasses.length != that.argClasses.length) {
                return false;
            }
            for (int i = 0; i &lt; argClasses.length; i++) {
                if (!(argClasses[i] == that.argClasses[i])) {
                  return false;
                }
            }
            return true;
        }
    }


    /*
     * Get the (unnamed) module of the trampoline class
     */
    public static Module getTrampolineModule() {
        return bounce.getDeclaringClass().getModule();
    }

    /*
     * Bounce through the trampoline.
     */
    public static Object invoke(Method m, Object obj, Object[] params)
        throws InvocationTargetException, IllegalAccessException {
        try {
            return bounce.invoke(null, new Object[] {m, obj, params});
        } catch (InvocationTargetException ie) {
            Throwable t = ie.getCause();

            if (t instanceof InvocationTargetException) {
                throw (InvocationTargetException)t;
            } else if (t instanceof IllegalAccessException) {
                throw (IllegalAccessException)t;
            } else if (t instanceof RuntimeException) {
                throw (RuntimeException)t;
            } else if (t instanceof Error) {
                throw (Error)t;
            } else {
                throw new Error(&quot;Unexpected invocation error&quot;, t);
            }
        } catch (IllegalAccessException iae) {
            // this can't happen
            throw new Error(&quot;Unexpected invocation error&quot;, iae);
        }
    }

    private static Method getTrampoline() {
        try {
            return AccessController.doPrivileged(
                new PrivilegedExceptionAction&lt;Method&gt;() {
                    public Method run() throws Exception {
                        Class&lt;?&gt; t = getTrampolineClass();
                        Class&lt;?&gt;[] types = {
                            Method.class, Object.class, Object[].class
                        };
                        Method b = t.getDeclaredMethod(&quot;invoke&quot;, types);
                        b.setAccessible(true);
                        return b;
                    }
                });
        } catch (Exception e) {
            throw new InternalError(&quot;bouncer cannot be found&quot;, e);
        }
    }


    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        // First, check if the class has already been loaded
        ReflectUtil.checkPackageAccess(name);
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            try {
                c = findClass(name);
            } catch (ClassNotFoundException e) {
                // Fall through ...
            }
            if (c == null) {
                c = getParent().loadClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }


    protected Class&lt;?&gt; findClass(final String name)
        throws ClassNotFoundException
    {
        if (!name.startsWith(MISC_PKG)) {
            throw new ClassNotFoundException(name);
        }
        String path = name.replace('.', '/').concat(&quot;.class&quot;);
        try {
            InputStream in = MethodUtil.class.getModule().getResourceAsStream(path);
            if (in != null) {
                try (in) {
                    byte[] b = in.readAllBytes();
                    return defineClass(name, b);
                }
            }
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }

        throw new ClassNotFoundException(name);
    }


    /*
     * Define the proxy classes
     */
    private Class&lt;?&gt; defineClass(String name, byte[] b) throws IOException {
        CodeSource cs = new CodeSource(null, (java.security.cert.Certificate[])null);
        if (!name.equals(TRAMPOLINE)) {
            throw new IOException(&quot;MethodUtil: bad name &quot; + name);
        }
        return defineClass(name, b, 0, b.length, cs);
    }

    protected PermissionCollection getPermissions(CodeSource codesource)
    {
        PermissionCollection perms = super.getPermissions(codesource);
        perms.add(new AllPermission());
        return perms;
    }

    private static Class&lt;?&gt; getTrampolineClass() {
        try {
            return Class.forName(TRAMPOLINE, true, new MethodUtil());
        } catch (ClassNotFoundException e) {
        }
        return null;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/property/DoubleProperty.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.beans.property;
<A NAME="43"></A>
import com.sun.javafx.binding.BidirectionalBinding;
import com.sun.javafx.binding.ExpressionHelper;
<FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#43',2,'match36-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.beans.binding.Bindings;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableDoubleValue;
import com.sun.javafx.binding.Logging;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableDoubleValue;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * This class defines a {@link Property} wrapping a {@code double} value.
 * &lt;p&gt;
 * The value of a {@code DoubleProperty} can be get and set with {@link #get()},
 * {@link #getValue()}, {@link #set(double)}, and {@link #setValue(Number)}.
 * &lt;p&gt;
 * A property can be bound and unbound unidirectional with
 * {@link #bind(ObservableValue)} and {@link #unbind()}. Bidirectional bindings
 * can be created and removed with {@link #bindBidirectional(Property)} and
 * {@link #unbindBidirectional(Property)}.
 * &lt;p&gt;
 * The context of a {@code DoubleProperty} can be read with {@link #getBean()}
 * and {@link #getName()}.
 * &lt;p&gt;
 * Note: setting or binding this property to a null value will set the property to &quot;0.0&quot;. See {@link #setValue(java.lang.Number) }.
 *
 * @see javafx.beans.value.ObservableDoubleValue
 * @see javafx.beans.value.WritableDoubleValue
 * @see ReadOnlyDoubleProperty
 * @see Property
 *
 * @since JavaFX 2.0
 */
public abstract class DoubleProperty extends ReadOnlyDoubleProperty implements
        Property&lt;Number&gt;, WritableDoubleValue {

    /**
     * {@inheritDoc}
     */
    @Override
    public void setValue(Number v) {</B></FONT>
        if (v == null) {
            Logging.getLogger().fine(&quot;Attempt to set double property to null, using default value instead.&quot;, new NullPointerException());
            set(0.0);
        } else {
            set(v.doubleValue());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void bindBidirectional(Property&lt;Number&gt; other) {
        Bindings.bindBidirectional(this, other);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void unbindBidirectional(Property&lt;Number&gt; other) {
        Bindings.unbindBidirectional(this, other);
    }

    /**
     * Returns a string representation of this {@code DoubleProperty} object.
     * @return a string representation of this {@code DoubleProperty} object.
     */
    @Override
    public String toString() {
        final Object bean = getBean();
        final String name = getName();
        final StringBuilder result = new StringBuilder(
                &quot;DoubleProperty [&quot;);
        if (bean != null) {
            result.append(&quot;bean: &quot;).append(bean).append(&quot;, &quot;);
        }
        if ((name != null) &amp;&amp; (!name.equals(&quot;&quot;))) {
            result.append(&quot;name: &quot;).append(name).append(&quot;, &quot;);
        }
        result.append(&quot;value: &quot;).append(get()).append(&quot;]&quot;);
        return result.toString();
    }

    /**
     * Returns a {@code DoubleProperty} that wraps a
     * {@link javafx.beans.property.Property} and is
     * bidirectionally bound to it.
     * Changing this property will result in a change of the original property.
     *
     * &lt;p&gt;
     * This is very useful when bidirectionally binding an ObjectProperty&amp;lt;Double&amp;gt; and
     * a DoubleProperty.
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     *   DoubleProperty doubleProperty = new SimpleDoubleProperty(1.0);
     *   ObjectProperty&amp;lt;Double&amp;gt; objectProperty = new SimpleObjectProperty&amp;lt;&amp;gt;(2.0);
     *
     *   // Need to keep the reference as bidirectional binding uses weak references
     *   DoubleProperty objectAsDouble = DoubleProperty.doubleProperty(objectProperty);
     *
     *   doubleProperty.bindBidirectional(objectAsDouble);
     *
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * Another approach is to convert the DoubleProperty to ObjectProperty using
     * {@link #asObject()} method.
     * &lt;p&gt;
     * Note: null values in the source property will be interpreted as 0.0
     *
     * @param property
     *            The source {@code Property}
     * @return A {@code DoubleProperty} that wraps the
     *         {@code Property}
     * @throws NullPointerException
     *             if {@code property} is {@code null}
     * @see #asObject()
     * @since JavaFX 8.0
     */
    public static DoubleProperty doubleProperty(final Property&lt;Double&gt; property) {
        if (property == null) {
            throw new NullPointerException(&quot;Property cannot be null&quot;);
        }
        return new DoublePropertyBase() {
            private final AccessControlContext acc = AccessController.getContext();
            {
                BidirectionalBinding.bindNumber(this, property);
            }

            @Override
            public Object getBean() {
                return null; // Virtual property, no bean
            }

            @Override
            public String getName() {
                return property.getName();
            }

            @Override
            protected void finalize() throws Throwable {
                try {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        BidirectionalBinding.unbindNumber(property, this);
                        return null;
                    }, acc);
                } finally {
                    super.finalize();
                }
            }
        };
    }

    /**
     * Creates an {@link javafx.beans.property.ObjectProperty}
     * that bidirectionally bound to this {@code DoubleProperty}. If the
     * value of this {@code DoubleProperty} changes, the value of the
     * {@code ObjectProperty} will be updated automatically and vice-versa.
     *
     * &lt;p&gt;
     * Can be used for binding an ObjectProperty to DoubleProperty.
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     *   DoubleProperty doubleProperty = new SimpleDoubleProperty(1.0);
     *   ObjectProperty&amp;lt;Double&amp;gt; objectProperty = new SimpleObjectProperty&amp;lt;&amp;gt;(2.0);
     *
     *   objectProperty.bind(doubleProperty.asObject());
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return the new {@code ObjectProperty}
     * @since JavaFX 8.0
     */
    @Override
    public ObjectProperty&lt;Double&gt; asObject() {
        return new ObjectPropertyBase&lt;Double&gt; () {
            private final AccessControlContext acc = AccessController.getContext();
            {
                BidirectionalBinding.bindNumber(this, DoubleProperty.this);
            }

            @Override
            public Object getBean() {
                return null; // Virtual property, does not exist on a bean
            }

            @Override
            public String getName() {
                return DoubleProperty.this.getName();
            }

            @Override
            protected void finalize() throws Throwable {
                try {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        BidirectionalBinding.unbindNumber(this, DoubleProperty.this);
                        return null;
                    }, acc);
                } finally {
                    super.finalize();
                }
            }

        };
    }


}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextFieldBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.Properties;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.TextField;
import javafx.scene.control.skin.TextFieldSkin;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.HitInfo;
import javafx.stage.Screen;
import javafx.stage.Window;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.geom.transform.Affine3D;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;

/**
 * Text field behavior.
 */
public class TextFieldBehavior extends TextInputControlBehavior&lt;TextField&gt; {
    private TextFieldSkin skin;
    private TwoLevelFocusBehavior tlFocus;
    private ChangeListener&lt;Scene&gt; sceneListener;
    private ChangeListener&lt;Node&gt; focusOwnerListener;

    public TextFieldBehavior(final TextField textField) {
        super(textField);

        if (Properties.IS_TOUCH_SUPPORTED) {
            contextMenu.getStyleClass().add(&quot;text-input-context-menu&quot;);
        }

        handleFocusChange();

        // Register for change events
        textField.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            handleFocusChange();
        });

        focusOwnerListener = (observable, oldValue, newValue) -&gt; {
            // RT-23699: The selection is now only affected when the TextField
            // gains or loses focus within the Scene, and not when the whole
            // stage becomes active or inactive.
            if (newValue == textField) {
                if (!focusGainedByMouseClick) {
                    textField.selectRange(textField.getLength(), 0);
                }
            } else {
                textField.selectRange(0, 0);
            }
        };

        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
                                new WeakChangeListener&lt;Node&gt;(focusOwnerListener);
        sceneListener = (observable, oldValue, newValue) -&gt; {
            if (oldValue != null) {
                oldValue.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newValue != null) {
                newValue.focusOwnerProperty().addListener(weakFocusOwnerListener);
            }
        };
        textField.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;(sceneListener));

        if (textField.getScene() != null) {
            textField.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(textField); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();
    }

    private void handleFocusChange() {
        TextField textField = getNode();

        if (textField.isFocused()) {
            if (PlatformUtil.isIOS()) {
                // special handling of focus on iOS is required to allow to
                // control native keyboard, because nat. keyboard is poped-up only when native
                // text component gets focus. When we have JFX keyboard we can remove this code
                TextInputTypes type = TextInputTypes.TEXT_FIELD;
                if (textField.getClass().equals(javafx.scene.control.PasswordField.class)) {
                    type = TextInputTypes.PASSWORD_FIELD;
                } else if (textField.getParent().getClass().equals(javafx.scene.control.ComboBox.class)) {
                    type = TextInputTypes.EDITABLE_COMBO;
                }
                final Bounds bounds = textField.getBoundsInParent();
                double w = bounds.getWidth();
                double h = bounds.getHeight();
                Affine3D trans = calculateNodeToSceneTransform(textField);
//                Insets insets = skin.getInsets();
//                w -= insets.getLeft() + insets.getRight();
//                h -= insets.getTop() + insets.getBottom();
                String text = textField.getText();

                // we need to display native text input component on the place where JFX component is drawn
                // all parameters needed to do that are passed to native impl. here
                WindowHelper.getPeer(textField.getScene().getWindow()).requestInput(
                        text, type.ordinal(), w, h,
                        trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),// + insets.getLeft(),
                        trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),// + insets.getTop(),
                        trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
            }
            if (!focusGainedByMouseClick) {
                setCaretAnimating(true);
            }
        } else {
            if (PlatformUtil.isIOS() &amp;&amp; textField.getScene() != null) {
                // releasing the focus =&gt; we need to hide the native component and also native keyboard
                WindowHelper.getPeer(textField.getScene().getWindow()).releaseInput();
            }
            focusGainedByMouseClick = false;
            setCaretAnimating(false);
        }
    }

    static Affine3D calculateNodeToSceneTransform(Node node) {
        final Affine3D transform = new Affine3D();
        do {
            transform.preConcatenate(NodeHelper.getLeafTransform(node));
            node = node.getParent();
        } while (node != null);

        return transform;
    }

    // An unholy back-reference!
    public void setTextFieldSkin(TextFieldSkin skin) {
        this.skin = skin;
    }

    @Override protected void fire(KeyEvent event) {
        TextField textField = getNode();
        EventHandler&lt;ActionEvent&gt; onAction = textField.getOnAction();
        ActionEvent actionEvent = new ActionEvent(textField, null);

        textField.commitValue();
        textField.fireEvent(actionEvent);

        if (onAction == null &amp;&amp; !actionEvent.isConsumed()) {
            forwardToParent(event);
        }
    }

    @Override
    protected void cancelEdit(KeyEvent event) {
        TextField textField = getNode();
        if (textField.getTextFormatter() != null) {
            textField.cancelEdit();
            event.consume();
        } else {
            super.cancelEdit(event);
        }
    }

    @Override protected void deleteChar(boolean previous) {
        skin.deleteChar(previous);
    }

    @Override protected void replaceText(int start, int end, String txt) {
        skin.setForwardBias(true);
        skin.replaceText(start, end, txt);
    }

    @Override protected void deleteFromLineStart() {
        TextField textField = getNode();
        int end = textField.getCaretPosition();

        if (end &gt; 0) {
            replaceText(0, end, &quot;&quot;);
        }
    }

    @Override protected void setCaretAnimating(boolean play) {
        if (skin != null) {
            skin.setCaretAnimating(play);
        }
    }

    /**
     * Function which beeps. This requires a hook into the toolkit, and should
     * also be guarded by something that indicates whether we should beep
     * (as it is pretty annoying and many native controls don't do it).
     */
    private void beep() {
        // TODO
    }

    /**
     * If the focus is gained via response to a mouse click, then we don't
     * want to select all the text even if selectOnFocus is true.
     */
    private boolean focusGainedByMouseClick = false;
    private boolean shiftDown = false;
    private boolean deferClick = false;

    @Override public void mousePressed(MouseEvent e) {
        TextField textField = getNode();
        // We never respond to events if disabled
        if (!textField.isDisabled()) {
            // If the text field doesn't have focus, then we'll attempt to set
            // the focus and we'll indicate that we gained focus by a mouse
            // click, which will then NOT honor the selectOnFocus variable
            // of the textInputControl
            if (!textField.isFocused()) {
                focusGainedByMouseClick = true;
                textField.requestFocus();
            }

            // stop the caret animation
            setCaretAnimating(false);
            // only if there is no selection should we see the caret
//            setCaretOpacity(if (textInputControl.dot == textInputControl.mark) then 1.0 else 0.0);

            // if the primary button was pressed
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                HitInfo hit = skin.getIndex(e.getX(), e.getY());
                int i = hit.getInsertionIndex();
                final int anchor = textField.getAnchor();
                final int caretPosition = textField.getCaretPosition();
                if (e.getClickCount() &lt; 2 &amp;&amp;
                    (Properties.IS_TOUCH_SUPPORTED ||
                     (anchor != caretPosition &amp;&amp;
                      ((i &gt; anchor &amp;&amp; i &lt; caretPosition) || (i &lt; anchor &amp;&amp; i &gt; caretPosition))))) {
                    // if there is a selection, then we will NOT handle the
                    // press now, but will defer until the release. If you
                    // select some text and then press down, we change the
                    // caret and wait to allow you to drag the text (TODO).
                    // When the drag concludes, then we handle the click

                    deferClick = true;
                    // TODO start a timer such that after some millis we
                    // switch into text dragging mode, change the cursor
                    // to indicate the text can be dragged, etc.
                } else if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    switch (e.getClickCount()) {
                        case 1: mouseSingleClick(hit); break;
                        case 2: mouseDoubleClick(hit); break;
                        case 3: mouseTripleClick(hit); break;
                        default: // no-op
                    }
                } else if (e.isShiftDown() &amp;&amp; !(e.isControlDown() || e.isAltDown() || e.isMetaDown()) &amp;&amp; e.getClickCount() == 1) {
                    // didn't click inside the selection, so select
                    shiftDown = true;
                    // if we are on mac os, then we will accumulate the
                    // selection instead of just moving the dot. This happens
                    // by figuring out past which (dot/mark) are extending the
                    // selection, and set the mark to be the other side and
                    // the dot to be the new position.
                    // everywhere else we just move the dot.
                    if (isMac()) {
                        textField.extendSelection(i);
                    } else {
                        skin.positionCaret(hit, true);
                    }
                }
                skin.setForwardBias(hit.isLeading());
//                if (textInputControl.editable)
//                    displaySoftwareKeyboard(true);
            }
        }
        if (contextMenu.isShowing()) {
            contextMenu.hide();
        }
    }

    @Override public void mouseDragged(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled() &amp;&amp; !deferClick) {
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), true);
                }
            }
        }
    }

    @Override public void mouseReleased(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled()) {
            setCaretAnimating(false);
            if (deferClick) {
                deferClick = false;
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), shiftDown);
                shiftDown = false;
            }
            setCaretAnimating(true);
        }
    }

    @Override public void contextMenuRequested(ContextMenuEvent e) {
        final TextField textField = getNode();

        if (contextMenu.isShowing()) {
            contextMenu.hide();
        } else if (textField.getContextMenu() == null &amp;&amp;
                   textField.getOnContextMenuRequested() == null) {
            double screenX = e.getScreenX();
            double screenY = e.getScreenY();
            double sceneX = e.getSceneX();

            if (Properties.IS_TOUCH_SUPPORTED) {
                Point2D menuPos;
                if (textField.getSelection().getLength() == 0) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                    menuPos = skin.getMenuPosition();
                } else {
                    menuPos = skin.getMenuPosition();
                    if (menuPos != null &amp;&amp; (menuPos.getX() &lt;= 0 || menuPos.getY() &lt;= 0)) {
                        skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                        menuPos = skin.getMenuPosition();
                    }
                }

                if (menuPos != null) {
                    Point2D p = getNode().localToScene(menuPos);
                    Scene scene = getNode().getScene();
                    Window window = scene.getWindow();
                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),
                                                   window.getY() + scene.getY() + p.getY());
                    screenX = location.getX();
                    sceneX = p.getX();
                    screenY = location.getY();
                }
            }

            populateContextMenu();
            double menuWidth = contextMenu.prefWidth(-1);
            double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0);
            Screen currentScreen = com.sun.javafx.util.Utils.getScreenForPoint(screenX, 0);
            Rectangle2D bounds = currentScreen.getBounds();

<A NAME="10"></A>            if (menuX &lt; bounds.getMinX()) {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#10',2,'match36-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getNode(), bounds.getMinX(), screenY);
            } else if (screenX + menuWidth &gt; bounds.getMaxX()) {
                double leftOver = menuWidth - ( bounds.getMaxX() - screenX);
                getNode</B></FONT>().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), screenX - leftOver, screenY);
            } else {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, 0);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, 0);
                contextMenu.show(getNode(), menuX, screenY);
            }
        }

        e.consume();
    }

    protected void mouseSingleClick(HitInfo hit) {
        skin.positionCaret(hit, false);
    }

    protected void mouseDoubleClick(HitInfo hit) {
        final TextField textField = getNode();
        textField.previousWord();
        if (isWindows()) {
            textField.selectNextWord();
        } else {
            textField.selectEndOfNextWord();
        }
    }

    protected void mouseTripleClick(HitInfo hit) {
        getNode().selectAll();
    }

    // Enumeration of all types of text input that can be simulated on
    // touch device, such as iPad. Type is passed to native code and
    // native text component is shown. It's used as workaround for iOS
    // devices since keyboard control is not possible without native
    // text component being displayed
    enum TextInputTypes {
        TEXT_FIELD,
        PASSWORD_FIELD,
        EDITABLE_COMBO,
        TEXT_AREA;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/inputmap/KeyBinding.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.inputmap;

import com.sun.javafx.util.Utils;
import com.sun.javafx.tk.Toolkit;
import javafx.event.EventType;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

import java.util.Objects;

import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean.*;

/**
 * KeyBindings are used to describe which action should occur based on some
 * KeyEvent state and Control state. These bindings are used to populate the
 * keyBindings variable on BehaviorBase. The KeyBinding can be subclassed to
 * add additional matching criteria. A match in a subclass should always have
 * a specificity that is 1 greater than its superclass in the case of a match,
 * or 0 in the case where there is no match.
 *
 * Note that this API is, at present, quite odd in that you use a constructor
 * and then use shift(), ctrl(), alt(), or meta() separately. It gave me an
 * object-literal like approach but isn't ideal. We will want some builder
 * approach here (similar as in other places).
 *
 * @since 9
 */
public class KeyBinding {
    private final KeyCode code;
    private final EventType&lt;KeyEvent&gt; eventType;
    private OptionalBoolean shift = FALSE;
    private OptionalBoolean ctrl = FALSE;
    private OptionalBoolean alt = FALSE;
    private OptionalBoolean meta = FALSE;

    public KeyBinding(KeyCode code) {
        this(code, null);
    }

    /**
     * Designed for 'catch-all' situations, e.g. all KeyTyped events.
     * @param type
     */
    public KeyBinding(EventType&lt;KeyEvent&gt; type) {
        this(null, type);
    }

    public KeyBinding(KeyCode code, EventType&lt;KeyEvent&gt; type) {
        this.code = code;
        this.eventType = type != null ? type : KeyEvent.KEY_PRESSED;
    }

    public final KeyBinding shift() {
        return shift(TRUE);
    }

    public final KeyBinding shift(OptionalBoolean value) {
        shift = value;
        return this;
    }

    public final KeyBinding ctrl() {
        return ctrl(TRUE);
    }

    public final KeyBinding ctrl(OptionalBoolean value) {
        ctrl = value;
        return this;
    }

    public final KeyBinding alt() {
        return alt(TRUE);
    }

    public final KeyBinding alt(OptionalBoolean value) {
        alt = value;
        return this;
    }

    public final KeyBinding meta() {
        return meta(TRUE);
    }

    public final KeyBinding meta(OptionalBoolean value) {
        meta = value;
        return this;
    }

    public final KeyBinding shortcut() {
        if (Toolkit.getToolkit().getClass().getName().endsWith(&quot;StubToolkit&quot;)) {
            // FIXME: We've hit the terrible StubToolkit (which only appears
            // during testing). We will dumb down what we do here
            if (Utils.isMac()) {
                return meta();
            } else {
                return ctrl();
            }
        } else {
            switch (Toolkit.getToolkit().getPlatformShortcutKey()) {
                case SHIFT:
                    return shift();

                case CONTROL:
                    return ctrl();

                case ALT:
                    return alt();

                case META:
                    return meta();

                default:
                    return this;
            }
        }
    }



    public final KeyCode getCode() { return code; }
    public final EventType&lt;KeyEvent&gt; getType() { return eventType; }
    public final OptionalBoolean getShift() { return shift; }
    public final OptionalBoolean getCtrl() { return ctrl; }
    public final OptionalBoolean getAlt() { return alt; }
    public final OptionalBoolean getMeta() { return meta; }

    public int getSpecificity(KeyEvent event) {
        int s = 0;
        if (code != null &amp;&amp; code != event.getCode()) return 0; else s = 1;
        if (!shift.equals(event.isShiftDown())) return 0; else if (shift != ANY) s++;
        if (!ctrl.equals(event.isControlDown())) return 0; else if (ctrl != ANY) s++;
        if (!alt.equals(event.isAltDown())) return 0; else if (alt != ANY) s++;
        if (!meta.equals(event.isMetaDown())) return 0; else if (meta != ANY) s++;
        if (eventType != null &amp;&amp; eventType != event.getEventType()) return 0; else s++;
        // We can now trivially accept it
        return s;
    }

    /** {@inheritDoc} */
    @Override public String toString() {
        return &quot;KeyBinding [code=&quot; + code + &quot;, shift=&quot; + shift +
                &quot;, ctrl=&quot; + ctrl + &quot;, alt=&quot; + alt +
                &quot;, meta=&quot; + meta + &quot;, type=&quot; + eventType + &quot;]&quot;;
    }

    /** {@inheritDoc} */
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof KeyBinding)) return false;
        KeyBinding that = (KeyBinding) o;
        return Objects.equals(getCode(), that.getCode()) &amp;&amp;
                Objects.equals(eventType, that.eventType) &amp;&amp;
                Objects.equals(getShift(), that.getShift()) &amp;&amp;
                Objects.equals(getCtrl(), that.getCtrl()) &amp;&amp;
                Objects.equals(getAlt(), that.getAlt()) &amp;&amp;
                Objects.equals(getMeta(), that.getMeta());
<A NAME="6"></A>    }

    /** {@inheritDoc} */
    @Override public int hashCode() <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#6',2,'match36-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        return Objects.hash(getCode(), eventType, getShift(), getCtrl(), getAlt(), getMeta());
    }

    public static KeyBinding toKeyBinding(KeyEvent keyEvent) {</B></FONT>
        KeyBinding newKeyBinding = new KeyBinding(keyEvent.getCode(), keyEvent.getEventType());
        if (keyEvent.isShiftDown()) newKeyBinding.shift();
        if (keyEvent.isControlDown()) newKeyBinding.ctrl();
        if (keyEvent.isAltDown()) newKeyBinding.alt();
        if (keyEvent.isShortcutDown()) newKeyBinding.shortcut();
        return newKeyBinding;
    }

    /**
     * A tri-state boolean used with KeyBinding.
     */
    public enum OptionalBoolean {
        TRUE,
        FALSE,
        ANY;

        public boolean equals(boolean b) {
            if (this == ANY) return true;
            if (b &amp;&amp; this == TRUE) return true;
            if (!b &amp;&amp; this == FALSE) return true;
            return false;
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/CategoryAxis.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.List;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoubleWrapper;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.geometry.Dimension2D;
import javafx.geometry.Side;
import javafx.util.Duration;

import com.sun.javafx.charts.ChartLayoutAnimator;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.SizeConverter;

import java.util.Collections;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * A axis implementation that will works on string categories where each
 * value as a unique category(tick mark) along the axis.
 * @since JavaFX 2.0
 */
public final class CategoryAxis extends Axis&lt;String&gt; {

    // -------------- PRIVATE FIELDS -------------------------------------------
    private List&lt;String&gt; allDataCategories = new ArrayList&lt;String&gt;();
    private boolean changeIsLocal = false;
    /** This is the gap between one category and the next along this axis */
    private final DoubleProperty firstCategoryPos = new SimpleDoubleProperty(this, &quot;firstCategoryPos&quot;, 0);
    private Object currentAnimationID;
    private final ChartLayoutAnimator animator = new ChartLayoutAnimator(this);
    private ListChangeListener&lt;String&gt; itemsListener = c -&gt; {
        while (c.next()) {
            if(!c.getAddedSubList().isEmpty()) {
                // remove duplicates else they will get rendered on the chart.
                // Ideally we should be using a Set for categories.
                for (String addedStr : c.getAddedSubList())
                    checkAndRemoveDuplicates(addedStr);
                }
            if (!isAutoRanging()) {
                allDataCategories.clear();
                allDataCategories.addAll(getCategories());
                rangeValid = false;
            }
            requestAxisLayout();
        }
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** The margin between the axis start and the first tick-mark */
    private DoubleProperty startMargin = new StyleableDoubleProperty(5) {
        @Override protected void invalidated() {
            requestAxisLayout();
        }

        @Override public CssMetaData&lt;CategoryAxis,Number&gt; getCssMetaData() {
            return StyleableProperties.START_MARGIN;
        }

        @Override
        public Object getBean() {
            return CategoryAxis.this;
        }

        @Override
        public String getName() {
            return &quot;startMargin&quot;;
        }
    };
    public final double getStartMargin() { return startMargin.getValue(); }
    public final void setStartMargin(double value) { startMargin.setValue(value); }
    public final DoubleProperty startMarginProperty() { return startMargin; }

    /** The margin between the last tick mark and the axis end */
    private DoubleProperty endMargin = new StyleableDoubleProperty(5) {
        @Override protected void invalidated() {
            requestAxisLayout();
        }


        @Override public CssMetaData&lt;CategoryAxis,Number&gt; getCssMetaData() {
            return StyleableProperties.END_MARGIN;
        }

        @Override
        public Object getBean() {
            return CategoryAxis.this;
        }

        @Override
        public String getName() {
            return &quot;endMargin&quot;;
        }
    };
    public final double getEndMargin() { return endMargin.getValue(); }
    public final void setEndMargin(double value) { endMargin.setValue(value); }
    public final DoubleProperty endMarginProperty() { return endMargin; }

    /** If this is true then half the space between ticks is left at the start
     * and end
     */
    private BooleanProperty gapStartAndEnd = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            requestAxisLayout();
        }


        @Override public CssMetaData&lt;CategoryAxis,Boolean&gt; getCssMetaData() {
            return StyleableProperties.GAP_START_AND_END;
        }

        @Override
        public Object getBean() {
            return CategoryAxis.this;
        }

        @Override
        public String getName() {
            return &quot;gapStartAndEnd&quot;;
        }
    };
    public final boolean isGapStartAndEnd() { return gapStartAndEnd.getValue(); }
    public final void setGapStartAndEnd(boolean value) { gapStartAndEnd.setValue(value); }
    public final BooleanProperty gapStartAndEndProperty() { return gapStartAndEnd; }

    private ObjectProperty&lt;ObservableList&lt;String&gt;&gt; categories = new ObjectPropertyBase&lt;ObservableList&lt;String&gt;&gt;() {
        ObservableList&lt;String&gt; old;
        @Override protected void invalidated() {
            if (getDuplicate() != null) {
                throw new IllegalArgumentException(&quot;Duplicate category added; &quot;+getDuplicate()+&quot; already present&quot;);
            }
            final ObservableList&lt;String&gt; newItems = get();
            if (old != newItems) {
                // Add and remove listeners
                if (old != null) old.removeListener(itemsListener);
                if (newItems != null) newItems.addListener(itemsListener);
                old = newItems;
            }
        }

        @Override
        public Object getBean() {
            return CategoryAxis.this;
        }

        @Override
        public String getName() {
            return &quot;categories&quot;;
        }
    };

    /**
     * The ordered list of categories plotted on this axis. This is set automatically
     * based on the charts data if autoRanging is true. If the application sets the categories
     * then auto ranging is turned off. If there is an attempt to add duplicate entry into this list,
     * an {@link IllegalArgumentException} is thrown.
     * @param value the ordered list of categories plotted on this axis
     */
    public final void setCategories(ObservableList&lt;String&gt; value) {
        categories.set(value);
        if (!changeIsLocal) {
            setAutoRanging(false);
            allDataCategories.clear();
            allDataCategories.addAll(getCategories());
        }
        requestAxisLayout();
    }

    private void checkAndRemoveDuplicates(String category) {
        if (getDuplicate() != null) {
            getCategories().remove(category);
            throw new IllegalArgumentException(&quot;Duplicate category ; &quot;+category+&quot; already present&quot;);
        }
    }

    private String getDuplicate() {
        if (getCategories() != null) {
            for (int i = 0; i &lt; getCategories().size(); i++) {
                for (int j = 0; j &lt; getCategories().size(); j++) {
                    if (getCategories().get(i).equals(getCategories().get(j)) &amp;&amp; i != j) {
                        return getCategories().get(i);
                    }
                }
            }
        }
        return null;
    }
    /**
     * Returns a {@link ObservableList} of categories plotted on this axis.
     *
     * @return ObservableList of categories for this axis.
     */
    public final ObservableList&lt;String&gt; getCategories() {
        return categories.get();
    }

    /** This is the gap between one category and the next along this axis */
    private final ReadOnlyDoubleWrapper categorySpacing = new ReadOnlyDoubleWrapper(this, &quot;categorySpacing&quot;, 1);
    public final double getCategorySpacing() {
        return categorySpacing.get();
    }
    public final ReadOnlyDoubleProperty categorySpacingProperty() {
        return categorySpacing.getReadOnlyProperty();
    }

    // -------------- CONSTRUCTORS -------------------------------------------------------------------------------------

    /**
     * Create a auto-ranging category axis with an empty list of categories.
     */
    public CategoryAxis() {
        changeIsLocal = true;
        setCategories(FXCollections.&lt;String&gt;observableArrayList());
        changeIsLocal = false;
    }

    /**
     * Create a category axis with the given categories. This will not auto-range but be fixed with the given categories.
     *
     * @param categories List of the categories for this axis
     */
    public CategoryAxis(ObservableList&lt;String&gt; categories) {
        setCategories(categories);
    }

    // -------------- PRIVATE METHODS ----------------------------------------------------------------------------------

    private double calculateNewSpacing(double length, List&lt;String&gt; categories) {
        final Side side = getEffectiveSide();
        double newCategorySpacing = 1;
        if(categories != null) {
            double bVal = (isGapStartAndEnd() ? (categories.size()) : (categories.size() - 1));
            // RT-14092 flickering  : check if bVal is 0
            newCategorySpacing = (bVal == 0) ? 1 : (length-getStartMargin()-getEndMargin()) / bVal;
        }
        // if autoranging is off setRange is not called so we update categorySpacing
        if (!isAutoRanging()) categorySpacing.set(newCategorySpacing);
        return newCategorySpacing;
    }

    private double calculateNewFirstPos(double length, double catSpacing) {
        final Side side = getEffectiveSide();
        double newPos = 1;
        double offset = ((isGapStartAndEnd()) ? (catSpacing / 2) : (0));
        if (side.isHorizontal()) {
            newPos = 0 + getStartMargin() + offset;
        }  else { // VERTICAL
            newPos = length - getStartMargin() - offset;
        }
        // if autoranging is off setRange is not called so we update first cateogory pos.
        if (!isAutoRanging()) firstCategoryPos.set(newPos);
        return newPos;
    }

    // -------------- PROTECTED METHODS --------------------------------------------------------------------------------

    /**
     * Called to get the current axis range.
     *
     * @return A range object that can be passed to setRange() and calculateTickValues()
     */
    @Override protected Object getRange() {
        return new Object[]{ getCategories(), categorySpacing.get(), firstCategoryPos.get(), getEffectiveTickLabelRotation() };
    }

    /**
     * Called to set the current axis range to the given range. If isAnimating() is true then this method should
     * animate the range to the new range.
     *
     * @param range A range object returned from autoRange()
     * @param animate If true animate the change in range
     */
    @Override protected void setRange(Object range, boolean animate) {
        Object[] rangeArray = (Object[]) range;
        @SuppressWarnings({&quot;unchecked&quot;}) List&lt;String&gt; categories = (List&lt;String&gt;)rangeArray[0];
//        if (categories.isEmpty()) new java.lang.Throwable().printStackTrace();
        double newCategorySpacing = (Double)rangeArray[1];
        double newFirstCategoryPos = (Double)rangeArray[2];
        setEffectiveTickLabelRotation((Double)rangeArray[3]);

        changeIsLocal = true;
        setCategories(FXCollections.&lt;String&gt;observableArrayList(categories));
        changeIsLocal = false;
        if (animate) {
            animator.stop(currentAnimationID);
            currentAnimationID = animator.animate(
                new KeyFrame(Duration.ZERO,
                    new KeyValue(firstCategoryPos, firstCategoryPos.get()),
                    new KeyValue(categorySpacing, categorySpacing.get())
                ),
                new KeyFrame(Duration.millis(1000),
                    new KeyValue(firstCategoryPos,newFirstCategoryPos),
                    new KeyValue(categorySpacing,newCategorySpacing)
                )
            );
        } else {
            categorySpacing.set(newCategorySpacing);
            firstCategoryPos.set(newFirstCategoryPos);
        }
    }

    /**
     * This calculates the categories based on the data provided to invalidateRange() method. This must not
     * effect the state of the axis, changing any properties of the axis. Any results of the auto-ranging should be
     * returned in the range object. This will we passed to setRange() if it has been decided to adopt this range for
     * this axis.
     *
     * @param length The length of the axis in screen coordinates
     * @return Range information, this is implementation dependent
     */
    @Override protected Object autoRange(double length) {
        final Side side = getEffectiveSide();
        // TODO check if we can display all categories
        final double newCategorySpacing = calculateNewSpacing(length,allDataCategories);
        final double newFirstPos = calculateNewFirstPos(length, newCategorySpacing);
        double tickLabelRotation = getTickLabelRotation();
        if (length &gt;= 0) {
            double requiredLengthToDisplay = calculateRequiredSize(side.isVertical(), tickLabelRotation);
            if (requiredLengthToDisplay &gt; length) {
                // try to rotate the text to increase the density
                if (side.isHorizontal() &amp;&amp; tickLabelRotation != 90) {
                    tickLabelRotation = 90;
                }
                if (side.isVertical() &amp;&amp; tickLabelRotation != 0) {
                    tickLabelRotation = 0;
                }
            }
        }
        return new Object[]{allDataCategories, newCategorySpacing, newFirstPos, tickLabelRotation};
    }

    private double calculateRequiredSize(boolean axisVertical, double tickLabelRotation) {
        // Calculate the max space required between categories labels
        double maxReqTickGap = 0;
        double last = 0;
        boolean first = true;
        for (String category: allDataCategories) {
            Dimension2D textSize = measureTickMarkSize(category, tickLabelRotation);
            double size = (axisVertical || (tickLabelRotation != 0)) ? textSize.getHeight() : textSize.getWidth();
            // TODO better handle calculations for rotated text, overlapping text etc
            if (first) {
                first = false;
                last = size/2;
            } else {
                maxReqTickGap = Math.max(maxReqTickGap, last + 6 + (size/2) );
            }
        }
        return getStartMargin() + maxReqTickGap*allDataCategories.size() + getEndMargin();
    }

    /**
     * Calculate a list of all the data values for each tick mark in range
     *
     * @param length The length of the axis in display units
     * @return A list of tick marks that fit along the axis if it was the given length
     */
    @Override protected List&lt;String&gt; calculateTickValues(double length, Object range) {
        Object[] rangeArray = (Object[]) range;
        //noinspection unchecked
        return (List&lt;String&gt;)rangeArray[0];
    }

    /**
     * Get the string label name for a tick mark with the given value
     *
     * @param value The value to format into a tick label string
     * @return A formatted string for the given value
     */
    @Override protected String getTickMarkLabel(String value) {
        // TODO use formatter
        return value;
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value tick mark value
     * @param range range to use during calculations
     * @return size of tick mark label for given value
     */
    @Override protected Dimension2D measureTickMarkSize(String value, Object range) {
        final Object[] rangeArray = (Object[]) range;
        final double tickLabelRotation = (Double)rangeArray[3];
        return measureTickMarkSize(value,tickLabelRotation);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * Called when data has changed and the range may not be valid any more. This is only called by the chart if
     * isAutoRanging() returns true. If we are auto ranging it will cause layout to be requested and auto ranging to
     * happen on next layout pass.
     *
     * @param data The current set of all data that needs to be plotted on this axis
     */
    @Override public void invalidateRange(List&lt;String&gt; data) {
        super.invalidateRange(data);
        // Create unique set of category names
        List&lt;String&gt; categoryNames = new ArrayList&lt;String&gt;();
        categoryNames.addAll(allDataCategories);
        //RT-21141 allDataCategories needs to be updated based on data -
        // and should maintain the order it originally had for the categories already present.
        // and remove categories not present in data
        for(String cat : allDataCategories) {
            if (!data.contains(cat)) categoryNames.remove(cat);
        }
        // add any new category found in data
//        for(String cat : data) {
        for (int i = 0; i &lt; data.size(); i++) {
           int len = categoryNames.size();
           if (!categoryNames.contains(data.get(i))) categoryNames.add((i &gt; len) ? len : i, data.get(i));
        }
        allDataCategories.clear();
        allDataCategories.addAll(categoryNames);
    }

    final List&lt;String&gt; getAllDataCategories() {
        return allDataCategories;
    }

    /**
     * Get the display position along this axis for a given value.
     *
     * If the value is not equal to any of the categories, Double.NaN is returned
     *
     * @param value The data value to work out display position for
     * @return display position or Double.NaN if value not one of the categories
     */
    @Override public double getDisplayPosition(String value) {
        // find index of value
        final ObservableList&lt;String&gt; cat = getCategories();
        if (!cat.contains(value)) {
            return Double.NaN;
        }
<A NAME="29"></A>        if (getEffectiveSide().isHorizontal()) {
            return firstCategoryPos.get() + cat.indexOf(value) * categorySpacing.get();
        } else {
            return <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#29',2,'match36-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>firstCategoryPos.get() + cat.indexOf(value) * categorySpacing.get() * -1;
        }
    }

    /**
     * Get the data value for the given display position on this axis. If the axis
     * is a CategoryAxis this will be the nearest value.
     *
     * @param  displayPosition A pixel position on this axis
     * @return the nearest data value to the given pixel position or
     *         null if not on axis;
     */
    @Override public String getValueForDisplay(double displayPosition) {
        if (getEffectiveSide().isHorizontal</B></FONT>()) {
            if (displayPosition &lt; 0 || displayPosition &gt; getWidth()) return null;
            double d = (displayPosition - firstCategoryPos.get()) /   categorySpacing.get();
            return toRealValue(d);
        } else { // VERTICAL
            if (displayPosition &lt; 0 || displayPosition &gt; getHeight()) return null;
            double d = (displayPosition - firstCategoryPos.get()) /   (categorySpacing.get() * -1);
            return toRealValue(d);
        }
    }

    /**
     * Checks if the given value is plottable on this axis
     *
     * @param value The value to check if its on axis
     * @return true if the given value is plottable on this axis
     */
    @Override public boolean isValueOnAxis(String value) {
        return getCategories().indexOf(&quot;&quot; + value) != -1;
    }

    /**
     * All axis values must be representable by some numeric value. This gets the numeric value for a given data value.
     *
     * @param value The data value to convert
     * @return Numeric value for the given data value
     */
    @Override public double toNumericValue(String value) {
        return getCategories().indexOf(value);
    }

    /**
     * All axis values must be representable by some numeric value. This gets the data value for a given numeric value.
     *
     * @param value The numeric value to convert
     * @return Data value for given numeric value
     */
    @Override public String toRealValue(double value) {
        int index = (int)Math.round(value);
        List&lt;String&gt; categories = getCategories();
        if (index &gt;= 0 &amp;&amp; index &lt; categories.size()) {
            return getCategories().get(index);
        } else {
            return null;
        }
    }

    /**
     * Get the display position of the zero line along this axis. As there is no concept of zero on a CategoryAxis
     * this is always Double.NaN.
     *
     * @return always Double.NaN for CategoryAxis
     */
    @Override public double getZeroPosition() {
        return Double.NaN;
    }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;CategoryAxis,Number&gt; START_MARGIN =
            new CssMetaData&lt;CategoryAxis,Number&gt;(&quot;-fx-start-margin&quot;,
                SizeConverter.getInstance(), 5.0) {

            @Override
            public boolean isSettable(CategoryAxis n) {
                return n.startMargin == null || !n.startMargin.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(CategoryAxis n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.startMarginProperty();
            }
        };

        private static final CssMetaData&lt;CategoryAxis,Number&gt; END_MARGIN =
            new CssMetaData&lt;CategoryAxis,Number&gt;(&quot;-fx-end-margin&quot;,
                SizeConverter.getInstance(), 5.0) {

            @Override
            public boolean isSettable(CategoryAxis n) {
                return n.endMargin == null || !n.endMargin.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(CategoryAxis n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.endMarginProperty();
            }
        };

        private static final CssMetaData&lt;CategoryAxis,Boolean&gt; GAP_START_AND_END =
            new CssMetaData&lt;CategoryAxis,Boolean&gt;(&quot;-fx-gap-start-and-end&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(CategoryAxis n) {
                return n.gapStartAndEnd == null || !n.gapStartAndEnd.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(CategoryAxis n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.gapStartAndEndProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
            new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Axis.getClassCssMetaData());
            styleables.add(START_MARGIN);
            styleables.add(END_MARGIN);
            styleables.add(GAP_START_AND_END);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/Chart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.scene.control.skin.Utils;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.ObservableList;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;

import com.sun.javafx.charts.ChartLayoutAnimator;
import com.sun.javafx.charts.Legend;
import com.sun.javafx.scene.NodeHelper;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Base class for all charts. It has 3 parts the title, legend and chartContent. The chart content is populated by the
 * specific subclass of Chart.
 *
 * @since JavaFX 2.0
 */
public abstract class Chart extends Region {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------

    private static final int MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT = 200;
    private static final int MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT = 150;

    /** Title Label */
    private final Label titleLabel = new Label();
    /**
     * This is the Pane that Chart subclasses use to contain the chart content,
     * It is sized to be inside the chart area leaving space for the title and legend.
     */
    private final Pane chartContent = new Pane() {
        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double left = snappedLeftInset();
            final double bottom = snappedBottomInset();
            final double right = snappedRightInset();
            final double width = getWidth();
            final double height = getHeight();
            final double contentWidth = snapSizeX(width - (left + right));
            final double contentHeight = snapSizeY(height - (top + bottom));
            layoutChartChildren(snapPositionY(top), snapPositionX(left), contentWidth, contentHeight);
        }
        @Override public boolean usesMirroring() {
            return useChartContentMirroring;
        }
    };
    // Determines if chart content should be mirrored if node orientation is right-to-left.
    boolean useChartContentMirroring = true;

    /** Animator for animating stuff on the chart */
    private final ChartLayoutAnimator animator = new ChartLayoutAnimator(chartContent);

    // -------------- PUBLIC PROPERTIES --------------------------------------------------------------------------------

    /** The chart title */
    private StringProperty title = new StringPropertyBase() {
        @Override protected void invalidated() {
            titleLabel.setText(get());
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;title&quot;;
        }
    };
    public final String getTitle() { return title.get(); }
    public final void setTitle(String value) { title.set(value); }
    public final StringProperty titleProperty() { return title; }

    /**
     * The side of the chart where the title is displayed
     * @defaultValue Side.TOP
     */
    private ObjectProperty&lt;Side&gt; titleSide = new StyleableObjectProperty&lt;Side&gt;(Side.TOP) {
        @Override protected void invalidated() {
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Side&gt; getCssMetaData() {
            return StyleableProperties.TITLE_SIDE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;titleSide&quot;;
        }
    };
    public final Side getTitleSide() { return titleSide.get(); }
    public final void setTitleSide(Side value) { titleSide.set(value); }
    public final ObjectProperty&lt;Side&gt; titleSideProperty() { return titleSide; }

    /**
     * The node to display as the Legend. Subclasses can set a node here to be displayed on a side as the legend. If
     * no legend is wanted then this can be set to null
     */
    private final ObjectProperty&lt;Node&gt; legend = new ObjectPropertyBase&lt;Node&gt;() {
        private Node old = null;
        @Override protected void invalidated() {
            Node newLegend = get();
            if (old != null) getChildren().remove(old);
            if (newLegend != null) {
                getChildren().add(newLegend);
                newLegend.setVisible(isLegendVisible());
            }
            old = newLegend;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legend&quot;;
        }
    };
    protected final Node getLegend() { return legend.getValue(); }
    protected final void setLegend(Node value) { legend.setValue(value); }
    protected final ObjectProperty&lt;Node&gt; legendProperty() { return legend; }

    /**
     * When true the chart will display a legend if the chart implementation supports a legend.
     */
    private final BooleanProperty legendVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LEGEND_VISIBLE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legendVisible&quot;;
        }
    };
    public final boolean isLegendVisible() { return legendVisible.getValue(); }
    public final void setLegendVisible(boolean value) { legendVisible.setValue(value); }
    public final BooleanProperty legendVisibleProperty() { return legendVisible; }

    /**
     * The side of the chart where the legend should be displayed
     *
     * @defaultValue Side.BOTTOM
     */
    private ObjectProperty&lt;Side&gt; legendSide = new StyleableObjectProperty&lt;Side&gt;(Side.BOTTOM) {
        @Override protected void invalidated() {
            final Side legendSide = get();
            final Node legend = getLegend();
            if(legend instanceof Legend) ((Legend)legend).setVertical(Side.LEFT.equals(legendSide) || Side.RIGHT.equals(legendSide));
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Side&gt; getCssMetaData() {
            return StyleableProperties.LEGEND_SIDE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legendSide&quot;;
        }
    };
    public final Side getLegendSide() { return legendSide.get(); }
    public final void setLegendSide(Side value) { legendSide.set(value); }
    public final ObjectProperty&lt;Side&gt; legendSideProperty() { return legendSide; }

    /** When true any data changes will be animated. */
    private BooleanProperty animated = new SimpleBooleanProperty(this, &quot;animated&quot;, true);

    /**
     * Indicates whether data changes will be animated or not.
     *
     * @return true if data changes will be animated and false otherwise.
     */
    public final boolean getAnimated() { return animated.get(); }
    public final void setAnimated(boolean value) { animated.set(value); }
    public final BooleanProperty animatedProperty() { return animated; }

    // -------------- PROTECTED PROPERTIES -----------------------------------------------------------------------------

    /**
     * Modifiable and observable list of all content in the chart. This is where implementations of Chart should add
     * any nodes they use to draw their chart. This excludes the legend and title which are looked after by this class.
     *
     * @return Observable list of plot children
     */
    protected ObservableList&lt;Node&gt; getChartChildren() {
        return chartContent.getChildren();
    }

    // -------------- CONSTRUCTOR --------------------------------------------------------------------------------------

    /**
     * Creates a new default Chart instance.
     */
<A NAME="44"></A>    public Chart() {
        titleLabel.setAlignment(Pos.CENTER);
        titleLabel.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
        <FONT color="#e57ded"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#44',2,'match36-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getChildren().addAll(titleLabel, chartContent);
        getStyleClass().add(&quot;chart&quot;);
        titleLabel.getStyleClass().add(&quot;chart-title&quot;);
        chartContent.getStyleClass().add(&quot;chart-content&quot;);
        // mark chartContent as unmanaged because any changes to its preferred size shouldn't cause a relayout
        chartContent.setManaged(false);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * Play a animation involving the given keyframes. On every frame of the animation the chart will be relayed out
     *
     * @param keyFrames Array of KeyFrames to play
     */
    void animate(KeyFrame...keyFrames) { animator.animate(keyFrames); }</B></FONT>

    /**
     * Play the given animation on every frame of the animation the chart will be relayed out until the animation
     * finishes. So to add a animation to a chart, create a animation on data model, during layoutChartContent() map
     * data model to nodes then call this method with the animation.
     *
     * @param animation The animation to play
     */
    protected void animate(Animation animation) { animator.animate(animation); }

    /** Call this when you know something has changed that needs the chart to be relayed out. */
    protected void requestChartLayout() {
        chartContent.requestLayout();
    }

    /**
     * This is used to check if any given animation should run. It returns true if animation is enabled and the node
     * is visible and in a scene.
     * @return true if animation is enabled and the node is visible and in a scene
     */
    protected final boolean shouldAnimate(){
        return getAnimated() &amp;&amp; NodeHelper.isTreeShowing(this);
    }

    /**
     * Called to update and layout the chart children available from getChartChildren()
     *
     * @param top The top offset from the origin to account for any padding on the chart content
     * @param left The left offset from the origin to account for any padding on the chart content
     * @param width The width of the area to layout the chart within
     * @param height The height of the area to layout the chart within
     */
    protected abstract void layoutChartChildren(double top, double left, double width, double height);

    /**
     * Invoked during the layout pass to layout this chart and all its content.
     */
    @Override protected void layoutChildren() {
        double top = snappedTopInset();
        double left = snappedLeftInset();
        double bottom = snappedBottomInset();
        double right = snappedRightInset();
        final double width = getWidth();
        final double height = getHeight();
        // layout title
        if (getTitle() != null) {
            titleLabel.setVisible(true);
            if (getTitleSide().equals(Side.TOP)) {
                final double titleHeight = snapSizeY(titleLabel.prefHeight(width-left-right));
                titleLabel.resizeRelocate(left,top,width-left-right,titleHeight);
                top += titleHeight;
            } else if (getTitleSide().equals(Side.BOTTOM)) {
                final double titleHeight = snapSizeY(titleLabel.prefHeight(width-left-right));
                titleLabel.resizeRelocate(left,height-bottom-titleHeight,width-left-right,titleHeight);
                bottom += titleHeight;
            } else if (getTitleSide().equals(Side.LEFT)) {
                final double titleWidth = snapSizeX(titleLabel.prefWidth(height-top-bottom));
                titleLabel.resizeRelocate(left,top,titleWidth,height-top-bottom);
                left += titleWidth;
            } else if (getTitleSide().equals(Side.RIGHT)) {
                final double titleWidth = snapSizeX(titleLabel.prefWidth(height-top-bottom));
                titleLabel.resizeRelocate(width-right-titleWidth,top,titleWidth,height-top-bottom);
                right += titleWidth;
            }
        } else {
            titleLabel.setVisible(false);
        }
        // layout legend
        final Node legend = getLegend();
        if (legend != null) {
            boolean shouldShowLegend = isLegendVisible();
            if (shouldShowLegend) {
                if (getLegendSide() == Side.TOP) {
                    final double legendHeight = snapSizeY(legend.prefHeight(width-left-right));
                    final double legendWidth = Utils.boundedSize(snapSizeX(legend.prefWidth(legendHeight)), 0, width - left - right);
                    legend.resizeRelocate(left + (((width - left - right)-legendWidth)/2), top, legendWidth, legendHeight);
                    if ((height - bottom - top - legendHeight) &lt; MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        top += legendHeight;
                    }
                } else if (getLegendSide() == Side.BOTTOM) {
                    final double legendHeight = snapSizeY(legend.prefHeight(width-left-right));
                    final double legendWidth = Utils.boundedSize(snapSizeX(legend.prefWidth(legendHeight)), 0, width - left - right);
                    legend.resizeRelocate(left + (((width - left - right)-legendWidth)/2), height-bottom-legendHeight, legendWidth, legendHeight);
                    if ((height - bottom - top - legendHeight) &lt; MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        bottom += legendHeight;
                    }
                } else if (getLegendSide() == Side.LEFT) {
                    final double legendWidth = snapSizeX(legend.prefWidth(height-top-bottom));
                    final double legendHeight = Utils.boundedSize(snapSizeY(legend.prefHeight(legendWidth)), 0, height - top - bottom);
                    legend.resizeRelocate(left,top +(((height-top-bottom)-legendHeight)/2),legendWidth,legendHeight);
                    if ((width - left - right - legendWidth) &lt; MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        left += legendWidth;
                    }
                } else if (getLegendSide() == Side.RIGHT) {
                    final double legendWidth = snapSizeX(legend.prefWidth(height-top-bottom));
                    final double legendHeight = Utils.boundedSize(snapSizeY(legend.prefHeight(legendWidth)), 0, height - top - bottom);
                    legend.resizeRelocate(width-right-legendWidth,top +(((height-top-bottom)-legendHeight)/2),legendWidth,legendHeight);
                    if ((width - left - right - legendWidth) &lt; MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        right += legendWidth;
                    }
                }
            }
            legend.setVisible(shouldShowLegend);
        }
        // whats left is for the chart content
        chartContent.resizeRelocate(left,top,width-left-right,height-top-bottom);
    }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So minimum
     * height is a constant 150.
     */
    @Override protected double computeMinHeight(double width) { return 150; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So minimum
     * width is a constant 200.
     */
    @Override protected double computeMinWidth(double height) { return 200; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So preferred
     * width is a constant 500.
     */
    @Override protected double computePrefWidth(double height) { return 500.0; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So preferred
     * height is a constant 400.
     */
    @Override protected double computePrefHeight(double width) { return 400.0; }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;Chart,Side&gt; TITLE_SIDE =
            new CssMetaData&lt;Chart,Side&gt;(&quot;-fx-title-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class),
                Side.TOP) {

            @Override
            public boolean isSettable(Chart node) {
                return node.titleSide == null || !node.titleSide.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)node.titleSideProperty();
            }
        };

        private static final CssMetaData&lt;Chart,Side&gt; LEGEND_SIDE =
            new CssMetaData&lt;Chart,Side&gt;(&quot;-fx-legend-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class),
                Side.BOTTOM) {

            @Override
            public boolean isSettable(Chart node) {
                return node.legendSide == null || !node.legendSide.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)node.legendSideProperty();
            }
        };

        private static final CssMetaData&lt;Chart,Boolean&gt; LEGEND_VISIBLE =
            new CssMetaData&lt;Chart,Boolean&gt;(&quot;-fx-legend-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Chart node) {
                return node.legendVisible == null || !node.legendVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.legendVisibleProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(TITLE_SIDE);
            styleables.add(LEGEND_VISIBLE);
            styleables.add(LEGEND_SIDE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/StackedBarChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;


import java.util.*;

import javafx.animation.*;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;

import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;

import javafx.css.converter.SizeConverter;

import javafx.collections.ListChangeListener;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;


/**
 * StackedBarChart is a variation of {@link BarChart} that plots bars indicating
 * data values for a category. The bars can be vertical or horizontal depending
 * on which axis is a category axis.
 * The bar for each series is stacked on top of the previous series.
 * @since JavaFX 2.1
 */
public class StackedBarChart&lt;X, Y&gt; extends XYChart&lt;X, Y&gt; {

    // -------------- PRIVATE FIELDS -------------------------------------------
    private Map&lt;Series&lt;X, Y&gt;, Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt;&gt; seriesCategoryMap =
            new HashMap&lt;&gt;();
    private final Orientation orientation;
    private CategoryAxis categoryAxis;
    private ValueAxis valueAxis;
    // RT-23125 handling data removal when a category is removed.
    private ListChangeListener&lt;String&gt; categoriesListener = new ListChangeListener&lt;String&gt;() {
        @Override public void onChanged(ListChangeListener.Change&lt;? extends String&gt; c) {
            while (c.next()) {
                for(String cat : c.getRemoved()) {
                    for (Series&lt;X, Y&gt; series : getData()) {
                        for (Data&lt;X, Y&gt; data : series.getData()) {
                            if ((cat).equals((orientation == orientation.VERTICAL) ?
                                    data.getXValue() : data.getYValue())) {
                                boolean animatedOn = getAnimated();
                                setAnimated(false);
                                dataItemRemoved(data, series);
                                setAnimated(animatedOn);
                            }
                        }
                    }
                    requestChartLayout();
                }
            }
        }
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------
    /** The gap to leave between bars in separate categories */
    private DoubleProperty categoryGap = new StyleableDoubleProperty(10) {
        @Override protected void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return StackedBarChart.this;
        }

        @Override
        public String getName() {
            return &quot;categoryGap&quot;;
        }

        public CssMetaData&lt;StackedBarChart&lt;?,?&gt;,Number&gt; getCssMetaData() {
            return StackedBarChart.StyleableProperties.CATEGORY_GAP;
        }
    };

    public double getCategoryGap() {
        return categoryGap.getValue();
    }

    public void setCategoryGap(double value) {
        categoryGap.setValue(value);
    }

    public DoubleProperty categoryGapProperty() {
        return categoryGap;
    }

    // -------------- CONSTRUCTOR ----------------------------------------------
    /**
     * Construct a new StackedBarChart with the given axis. The two axis should be a ValueAxis/NumberAxis and a CategoryAxis,
     * they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public StackedBarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis, yAxis, FXCollections.&lt;Series&lt;X, Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new StackedBarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a
     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public StackedBarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X, Y&gt;&gt; data) {
        super(xAxis, yAxis);
        getStyleClass().add(&quot;stacked-bar-chart&quot;);
        if (!((xAxis instanceof ValueAxis &amp;&amp; yAxis instanceof CategoryAxis)
                || (yAxis instanceof ValueAxis &amp;&amp; xAxis instanceof CategoryAxis))) {
            throw new IllegalArgumentException(&quot;Axis type incorrect, one of X,Y should be CategoryAxis and the other NumberAxis&quot;);
        }
        if (xAxis instanceof CategoryAxis) {
            categoryAxis = (CategoryAxis) xAxis;
            valueAxis = (ValueAxis) yAxis;
            orientation = Orientation.VERTICAL;
        } else {
            categoryAxis = (CategoryAxis) yAxis;
            valueAxis = (ValueAxis) xAxis;
            orientation = Orientation.HORIZONTAL;
        }
        // update css
        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, orientation == Orientation.HORIZONTAL);
        pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE, orientation == Orientation.VERTICAL);
        setData(data);
        categoryAxis.getCategories().addListener(categoriesListener);
    }

    /**
     * Construct a new StackedBarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a
     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     * @param categoryGap The gap to leave between bars in separate categories
     */
    public StackedBarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X, Y&gt;&gt; data, @NamedArg(&quot;categoryGap&quot;) double categoryGap) {
        this(xAxis, yAxis);
        setData(data);
        setCategoryGap(categoryGap);
    }

    // -------------- METHODS --------------------------------------------------
    @Override protected void dataItemAdded(Series&lt;X, Y&gt; series, int itemIndex, Data&lt;X, Y&gt; item) {
        String category;
        if (orientation == Orientation.VERTICAL) {
            category = (String) item.getXValue();
        } else {
            category = (String) item.getYValue();
        }
        // Don't plot if category does not already exist ?
//        if (!categoryAxis.getCategories().contains(category)) return;

        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; categoryMap = seriesCategoryMap.get(series);

        if (categoryMap == null) {
            categoryMap = new HashMap&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt;();
            seriesCategoryMap.put(series, categoryMap);
        }
        // list to hold more that one bar &quot;positive and negative&quot;
        List&lt;Data&lt;X, Y&gt;&gt; itemList = categoryMap.get(category) != null ? categoryMap.get(category) : new ArrayList&lt;Data&lt;X, Y&gt;&gt;();
        itemList.add(item);
        categoryMap.put(category, itemList);
//        categoryMap.put(category, item);
        Node bar = createBar(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            animateDataAdd(item, bar);
        } else {
            getPlotChildren().add(bar);
        }
    }

    @Override protected void dataItemRemoved(final Data&lt;X, Y&gt; item, final Series&lt;X, Y&gt; series) {
        final Node bar = item.getNode();

        if (bar != null) {
<A NAME="9"></A>            bar.focusTraversableProperty().unbind();
        }

        <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#9',2,'match36-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (shouldAnimate()) {
            Timeline t = createDataRemoveTimeline(item, bar, series);
            t.setOnFinished(event -&gt; {
                removeDataItemFromDisplay</B></FONT>(series, item);
            });
            t.play();
        } else {
            processDataRemove(series, item);
            removeDataItemFromDisplay(series, item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
        double barVal;
        double currentVal;
        if (orientation == Orientation.VERTICAL) {
            barVal = ((Number) item.getYValue()).doubleValue();
            currentVal = ((Number) getCurrentDisplayedYValue(item)).doubleValue();
        } else {
            barVal = ((Number) item.getXValue()).doubleValue();
            currentVal = ((Number) getCurrentDisplayedXValue(item)).doubleValue();
        }
        if (currentVal &gt; 0 &amp;&amp; barVal &lt; 0) { // going from positive to negative
            // add style class negative
            item.getNode().getStyleClass().add(&quot;negative&quot;);
        } else if (currentVal &lt; 0 &amp;&amp; barVal &gt; 0) { // going from negative to positive
            // remove style class negative
            item.getNode().getStyleClass().remove(&quot;negative&quot;);
        }
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        // Note: is there a more efficient way of doing this?
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; series = getData().get(i);
            for (int j=0; j&lt;series.getData().size(); j++) {
                Data&lt;X,Y&gt; item = series.getData().get(j);
                Node bar = item.getNode();
                bar.getStyleClass().setAll(&quot;chart-bar&quot;, &quot;series&quot; + i, &quot;data&quot; + j, series.defaultColorStyleClass);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected void seriesAdded(Series&lt;X, Y&gt; series, int seriesIndex) {
        // handle any data already in series
        // create entry in the map
        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; categoryMap = new HashMap&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt;();
        for (int j = 0; j &lt; series.getData().size(); j++) {
            Data&lt;X, Y&gt; item = series.getData().get(j);
            Node bar = createBar(series, seriesIndex, item, j);
            String category;
            if (orientation == Orientation.VERTICAL) {
                category = (String) item.getXValue();
            } else {
                category = (String) item.getYValue();
            }
            // list of two item positive and negative
            List&lt;Data&lt;X, Y&gt;&gt; itemList = categoryMap.get(category) != null ? categoryMap.get(category) : new ArrayList&lt;Data&lt;X, Y&gt;&gt;();
            itemList.add(item);
            categoryMap.put(category, itemList);
            if (shouldAnimate()) {
                animateDataAdd(item, bar);
            } else {
                double barVal = (orientation == Orientation.VERTICAL) ? ((Number)item.getYValue()).doubleValue() :
                    ((Number)item.getXValue()).doubleValue();
                if (barVal &lt; 0) {
                    bar.getStyleClass().add(&quot;negative&quot;);
                }
                getPlotChildren().add(bar);
            }
        }
        if (categoryMap.size() &gt; 0) {
            seriesCategoryMap.put(series, categoryMap);
        }
    }

    @Override protected void seriesRemoved(final Series&lt;X, Y&gt; series) {
        // remove all symbol nodes
        if (shouldAnimate()) {
            ParallelTransition pt = new ParallelTransition();
            pt.setOnFinished(event -&gt; {
                removeSeriesFromDisplay(series);
                requestChartLayout();
            });
            for (Data&lt;X, Y&gt; d : series.getData()) {
                final Node bar = d.getNode();
                // Animate series deletion
                if (getSeriesSize() &gt; 1) {
                    Timeline t = createDataRemoveTimeline(d, bar, series);
                    pt.getChildren().add(t);
                } else {
                    // fade out last series
                    FadeTransition ft = new FadeTransition(Duration.millis(700), bar);
                    ft.setFromValue(1);
                    ft.setToValue(0);
                    ft.setOnFinished(actionEvent -&gt; {
                        processDataRemove(series, d);
                        bar.setOpacity(1.0);
                    });
                    pt.getChildren().add(ft);
                }
            }
            pt.play();
        } else {
            for (Data&lt;X, Y&gt; d : series.getData()) {
                processDataRemove(series, d);
            }
            removeSeriesFromDisplay(series);
            requestChartLayout();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        // This override is necessary to update axis range based on cumulative Y value for the
        // Y axis instead of the inherited way where the max value in the data range is used.
        boolean categoryIsX = categoryAxis == getXAxis();
        if (categoryAxis.isAutoRanging()) {
            List cData = new ArrayList();
            for (Series&lt;X, Y&gt; series : getData()) {
                for (Data&lt;X, Y&gt; data : series.getData()) {
                    if (data != null) cData.add(categoryIsX ? data.getXValue() : data.getYValue());
                }
            }
            categoryAxis.invalidateRange(cData);
        }
        if (valueAxis.isAutoRanging()) {
            List&lt;Number&gt; vData = new ArrayList&lt;&gt;();
            for (String category : categoryAxis.getAllDataCategories()) {
                double totalXN = 0;
                double totalXP = 0;
                Iterator&lt;Series&lt;X, Y&gt;&gt; seriesIterator = getDisplayedSeriesIterator();
                while (seriesIterator.hasNext()) {
                    Series&lt;X, Y&gt; series = seriesIterator.next();
                    for (final Data&lt;X, Y&gt; item : getDataItem(series, category)) {
                        if (item != null) {
                            boolean isNegative = item.getNode().getStyleClass().contains(&quot;negative&quot;);
                            Number value = (Number) (categoryIsX ? item.getYValue() : item.getXValue());
                            if (!isNegative) {
                                totalXP += valueAxis.toNumericValue(value);
                            } else {
                                totalXN += valueAxis.toNumericValue(value);
                            }
                        }
                    }
                }
                vData.add(totalXP);
                vData.add(totalXN);
            }
            valueAxis.invalidateRange(vData);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        double catSpace = categoryAxis.getCategorySpacing();
        // calculate bar spacing
        final double availableBarSpace = catSpace - getCategoryGap();
        final double barWidth = availableBarSpace;
        final double barOffset = -((catSpace - getCategoryGap()) / 2);
        // update bar positions and sizes
        for (String category : categoryAxis.getCategories()) {
            double currentPositiveValue = 0;
            double currentNegativeValue = 0;
            Iterator&lt;Series&lt;X, Y&gt;&gt; seriesIterator = getDisplayedSeriesIterator();
            while (seriesIterator.hasNext()) {
                Series&lt;X, Y&gt; series = seriesIterator.next();
                for (final Data&lt;X, Y&gt; item : getDataItem(series, category)) {
                    if (item != null) {
                        final Node bar = item.getNode();
                        final double categoryPos;
                        final double valNumber;
                        final X xValue = getCurrentDisplayedXValue(item);
                        final Y yValue = getCurrentDisplayedYValue(item);
                        if (orientation == Orientation.VERTICAL) {
                            categoryPos = getXAxis().getDisplayPosition(xValue);
                            valNumber = getYAxis().toNumericValue(yValue);
                        } else {
                            categoryPos = getYAxis().getDisplayPosition(yValue);
                            valNumber = getXAxis().toNumericValue(xValue);
                        }
                        double bottom;
                        double top;
                        boolean isNegative = bar.getStyleClass().contains(&quot;negative&quot;);
                        if (!isNegative) {
                            bottom = valueAxis.getDisplayPosition(currentPositiveValue);
                            top = valueAxis.getDisplayPosition(currentPositiveValue + valNumber);
                            currentPositiveValue += valNumber;
                        } else {
                            bottom = valueAxis.getDisplayPosition(currentNegativeValue + valNumber);
                            top = valueAxis.getDisplayPosition(currentNegativeValue);
                            currentNegativeValue += valNumber;
                        }

                        if (orientation == Orientation.VERTICAL) {
                            bar.resizeRelocate(categoryPos + barOffset,
                                    top, barWidth, bottom - top);
                        } else {
                            bar.resizeRelocate(bottom,
                                    categoryPos + barOffset,
                                    top - bottom, barWidth);
                        }
                    }
                }
            }
        }
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-bar&quot;, &quot;series&quot; + seriesIndex,
                &quot;bar-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }

    private void updateMap(Series&lt;X,Y&gt; series, Data&lt;X,Y&gt; item) {
        final String category = (orientation == Orientation.VERTICAL) ? (String)item.getXValue() :
                                     (String)item.getYValue();
        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; categoryMap = seriesCategoryMap.get(series);
        if (categoryMap != null) {
            categoryMap.remove(category);
            if (categoryMap.isEmpty()) seriesCategoryMap.remove(series);
        }
        if (seriesCategoryMap.isEmpty() &amp;&amp; categoryAxis.isAutoRanging()) categoryAxis.getCategories().clear();
    }

    private void processDataRemove(final Series&lt;X,Y&gt; series, final Data&lt;X,Y&gt; item) {
        Node bar = item.getNode();
        getPlotChildren().remove(bar);
        updateMap(series, item);
    }

    private void animateDataAdd(Data&lt;X, Y&gt; item, Node bar) {
        double barVal;
        if (orientation == Orientation.VERTICAL) {
            barVal = ((Number) item.getYValue()).doubleValue();
            if (barVal &lt; 0) {
                bar.getStyleClass().add(&quot;negative&quot;);
            }
            item.setYValue(getYAxis().toRealValue(getYAxis().getZeroPosition()));
            setCurrentDisplayedYValue(item, getYAxis().toRealValue(getYAxis().getZeroPosition()));
            getPlotChildren().add(bar);
            item.setYValue(getYAxis().toRealValue(barVal));
            animate(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedYValueProperty(item),
                            getCurrentDisplayedYValue(item))),
                    new KeyFrame(Duration.millis(700), new KeyValue(
                            currentDisplayedYValueProperty(item),
                            item.getYValue(), Interpolator.EASE_BOTH))
            );
        } else {
            barVal = ((Number) item.getXValue()).doubleValue();
            if (barVal &lt; 0) {
                bar.getStyleClass().add(&quot;negative&quot;);
            }
            item.setXValue(getXAxis().toRealValue(getXAxis().getZeroPosition()));
            setCurrentDisplayedXValue(item, getXAxis().toRealValue(getXAxis().getZeroPosition()));
            getPlotChildren().add(bar);
            item.setXValue(getXAxis().toRealValue(barVal));
            animate(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedXValueProperty(item),
                            getCurrentDisplayedXValue(item))),
                    new KeyFrame(Duration.millis(700), new KeyValue(
                            currentDisplayedXValueProperty(item),
                            item.getXValue(), Interpolator.EASE_BOTH))
            );
        }
    }

    private Timeline createDataRemoveTimeline(Data&lt;X, Y&gt; item, final Node bar, final Series&lt;X, Y&gt; series) {
        Timeline t = new Timeline();
        if (orientation == Orientation.VERTICAL) {
            item.setYValue(getYAxis().toRealValue(getYAxis().getZeroPosition()));
            t.getKeyFrames().addAll(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedYValueProperty(item),
                            getCurrentDisplayedYValue(item))),
                    new KeyFrame(Duration.millis(700), actionEvent -&gt; {
                        processDataRemove(series, item);
                    }, new KeyValue(
                            currentDisplayedYValueProperty(item),
                            item.getYValue(), Interpolator.EASE_BOTH))
            );
        } else {
            item.setXValue(getXAxis().toRealValue(getXAxis().getZeroPosition()));
            t.getKeyFrames().addAll(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedXValueProperty(item),
                            getCurrentDisplayedXValue(item))),
                    new KeyFrame(Duration.millis(700), actionEvent -&gt; {
                        processDataRemove(series, item);
                    }, new KeyValue(
                            currentDisplayedXValueProperty(item),
                            item.getXValue(), Interpolator.EASE_BOTH))
            );
        }
        return t;
    }

    private Node createBar(Series&lt;X, Y&gt; series, int seriesIndex, final Data&lt;X, Y&gt; item, int itemIndex) {
        Node bar = item.getNode();
        if (bar == null) {
            bar = new StackPane();
            bar.setAccessibleRole(AccessibleRole.TEXT);
            bar.setAccessibleRoleDescription(&quot;Bar&quot;);
            bar.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(bar);
        }
        bar.getStyleClass().setAll(&quot;chart-bar&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex, series.defaultColorStyleClass);
        return bar;
    }

    private List&lt;Data&lt;X, Y&gt;&gt; getDataItem(Series&lt;X, Y&gt; series, String category) {
        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; catmap = seriesCategoryMap.get(series);
        return catmap != null ? catmap.get(category) != null ?
            catmap.get(category) : new ArrayList&lt;Data&lt;X, Y&gt;&gt;() : new ArrayList&lt;Data&lt;X, Y&gt;&gt;();
    }

// -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
    private static class StyleableProperties {

        private static final CssMetaData&lt;StackedBarChart&lt;?,?&gt;,Number&gt; CATEGORY_GAP =
            new CssMetaData&lt;StackedBarChart&lt;?,?&gt;,Number&gt;(&quot;-fx-category-gap&quot;,
                SizeConverter.getInstance(), 10.0)  {

            @Override
            public boolean isSettable(StackedBarChart&lt;?,?&gt; node) {
                return node.categoryGap == null || !node.categoryGap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(StackedBarChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.categoryGapProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CATEGORY_GAP);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** Pseudoclass indicating this is a vertical chart. */
    private static final PseudoClass VERTICAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;vertical&quot;);

    /** Pseudoclass indicating this is a horizontal chart. */
    private static final PseudoClass HORIZONTAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;horizontal&quot;);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ListCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.List;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;

import javafx.scene.control.skin.ListCellSkin;

/**
 * &lt;p&gt;The {@link Cell} type used within {@link ListView} instances. In addition
 * to the API defined on Cell and {@link IndexedCell}, the ListCell is more
 * tightly bound to a ListView, allowing for better support of editing events,
 * etc.
 *
 * &lt;p&gt;A ListView maintains selection, indicating which cell(s) have been selected,
 * and focus, indicating the current focus owner for any given ListView. For each
 * property, each ListCell has a boolean reflecting whether this specific cell is
 * selected or focused. To achieve this, each ListCell has a reference back to
 * the ListView that it is being used within. Each ListCell belongs to one and
 * only one ListView.
 *
 * &lt;p&gt;Note that in the case of virtualized controls like ListView, when a cell
 * has focus this is not in the same sense as application focus. When a ListCell
 * has focus it simply represents the fact that the cell will  receive keyboard
 * events in the situation that the owning ListView actually contains focus. Of
 * course, in the case where a cell has a Node set in the
 * {@link #graphicProperty() graphic} property, it is completely legal for this
 * Node to request, and acquire focus as would normally be expected.
 *
 * @param &lt;T&gt; The type of the item contained within the ListCell.
 * @since JavaFX 2.0
 */
// TODO add code examples
public class ListCell&lt;T&gt; extends IndexedCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default ListCell with the default style class of 'list-cell'.
     */
    public ListCell() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.LIST_ITEM);
    }


    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *     We have to listen to a number of properties on the ListView itself  *
     *     as well as attach listeners to a couple different ObservableLists.  *
     *     We have to be sure to unhook these listeners whenever the reference *
     *     to the ListView changes, or whenever one of the ObservableList      *
     *     references changes (such as setting the selectionModel, focusModel, *
     *     or items).                                                          *
     *                                                                         *
     **************************************************************************/

    /**
     * Listens to the editing index on the ListView. It is possible for the developer
     * to call the ListView#edit(int) method and cause a specific cell to start
     * editing. In such a case, we need to be notified so we can call startEdit
     * on our side.
     */
    private final InvalidationListener editingListener = value -&gt; {
        updateEditing();
    };
    private boolean updateEditingIndex = true;

    /**
     * Listens to the selection model on the ListView. Whenever the selection model
     * is changed (updated), the selected property on the ListCell is updated accordingly.
     */
    private final ListChangeListener&lt;Integer&gt; selectedListener = c -&gt; {
        updateSelection();
    };

    /**
     * Listens to the selectionModel property on the ListView. Whenever the entire model is changed,
     * we have to unhook the weakSelectedListener and update the selection.
     */
    private final ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelPropertyListener = new ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;() {
        @Override
        public void changed(
                ObservableValue&lt;? extends MultipleSelectionModel&lt;T&gt;&gt; observable,
                MultipleSelectionModel&lt;T&gt; oldValue,
                MultipleSelectionModel&lt;T&gt; newValue) {

            if (oldValue != null) {
                oldValue.getSelectedIndices().removeListener(weakSelectedListener);
            }

            if (newValue != null) {
                newValue.getSelectedIndices().addListener(weakSelectedListener);
            }

            updateSelection();
        }

    };

    /**
     * Listens to the items on the ListView. Whenever the items are changed in such a way that
     * it impacts the index of this ListCell, then we must update the item.
     */
    private final ListChangeListener&lt;T&gt; itemsListener = c -&gt; {
        boolean doUpdate = false;
        while (c.next()) {
            // RT-35395: We only update the item in this cell if the current cell
            // index is within the range of the change and certain changes to the
            // list have occurred.
            final int currentIndex = getIndex();
            final ListView&lt;T&gt; lv = getListView();
            final List&lt;T&gt; items = lv == null ? null : lv.getItems();
            final int itemCount = items == null ? 0 : items.size();

            final boolean indexAfterChangeFromIndex = currentIndex &gt;= c.getFrom();
            final boolean indexBeforeChangeToIndex = currentIndex &lt; c.getTo() || currentIndex == itemCount;
            final boolean indexInRange = indexAfterChangeFromIndex &amp;&amp; indexBeforeChangeToIndex;

            doUpdate = indexInRange || (indexAfterChangeFromIndex &amp;&amp; !c.wasReplaced() &amp;&amp; (c.wasRemoved() || c.wasAdded()));
        }

        if (doUpdate) {
            updateItem(-1);
        }
    };

    /**
     * Listens to the items property on the ListView. Whenever the entire list is changed,
     * we have to unhook the weakItemsListener and update the item.
     */
    private final InvalidationListener itemsPropertyListener = new InvalidationListener() {
        private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(null);

        @Override public void invalidated(Observable observable) {
            ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
            if (oldItems != null) {
                oldItems.removeListener(weakItemsListener);
            }

            ListView&lt;T&gt; listView = getListView();
            ObservableList&lt;T&gt; items = listView == null ? null : listView.getItems();
            weakItemsRef = new WeakReference&lt;&gt;(items);

            if (items != null) {
                items.addListener(weakItemsListener);
            }
            updateItem(-1);
        }
    };

    /**
     * Listens to the focus model on the ListView. Whenever the focus model changes,
     * the focused property on the ListCell is updated
     */
    private final InvalidationListener focusedListener = value -&gt; {
        updateFocus();
    };

    /**
     * Listens to the focusModel property on the ListView. Whenever the entire model is changed,
     * we have to unhook the weakFocusedListener and update the focus.
     */
    private final ChangeListener&lt;FocusModel&lt;T&gt;&gt; focusModelPropertyListener = new ChangeListener&lt;FocusModel&lt;T&gt;&gt;() {
        @Override public void changed(ObservableValue&lt;? extends FocusModel&lt;T&gt;&gt; observable,
                                      FocusModel&lt;T&gt; oldValue,
                                      FocusModel&lt;T&gt; newValue) {
            if (oldValue != null) {
                oldValue.focusedIndexProperty().removeListener(weakFocusedListener);
            }
            if (newValue != null) {
                newValue.focusedIndexProperty().addListener(weakFocusedListener);
            }
            updateFocus();
        }
    };


    private final WeakInvalidationListener weakEditingListener = new WeakInvalidationListener(editingListener);
    private final WeakListChangeListener&lt;Integer&gt; weakSelectedListener = new WeakListChangeListener&lt;Integer&gt;(selectedListener);
    private final WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; weakSelectionModelPropertyListener = new WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;(selectionModelPropertyListener);
    private final WeakListChangeListener&lt;T&gt; weakItemsListener = new WeakListChangeListener&lt;T&gt;(itemsListener);
    private final WeakInvalidationListener weakItemsPropertyListener = new WeakInvalidationListener(itemsPropertyListener);
    private final WeakInvalidationListener weakFocusedListener = new WeakInvalidationListener(focusedListener);
    private final WeakChangeListener&lt;FocusModel&lt;T&gt;&gt; weakFocusModelPropertyListener = new WeakChangeListener&lt;FocusModel&lt;T&gt;&gt;(focusModelPropertyListener);

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The ListView associated with this Cell.
     */
    private ReadOnlyObjectWrapper&lt;ListView&lt;T&gt;&gt; listView = new ReadOnlyObjectWrapper&lt;ListView&lt;T&gt;&gt;(this, &quot;listView&quot;) {
        /**
         * A weak reference to the ListView itself, such that whenever the ...
         */
        private WeakReference&lt;ListView&lt;T&gt;&gt; weakListViewRef = new WeakReference&lt;ListView&lt;T&gt;&gt;(null);

        @Override protected void invalidated() {
            // Get the current and old list view references
            final ListView&lt;T&gt; currentListView = get();
            final ListView&lt;T&gt; oldListView = weakListViewRef.get();

            // If the currentListView is the same as the oldListView, then
            // there is nothing to be done.
            if (currentListView == oldListView) return;

            // If the old list view is not null, then we must unhook all its listeners
            if (oldListView != null) {
                // If the old selection model isn't null, unhook it
                final MultipleSelectionModel&lt;T&gt; sm = oldListView.getSelectionModel();
                if (sm != null) {
                    sm.getSelectedIndices().removeListener(weakSelectedListener);
                }

                // If the old focus model isn't null, unhook it
                final FocusModel&lt;T&gt; fm = oldListView.getFocusModel();
                if (fm != null) {
                    fm.focusedIndexProperty().removeListener(weakFocusedListener);
                }

                // If the old items isn't null, unhook the listener
                final ObservableList&lt;T&gt; items = oldListView.getItems();
                if (items != null) {
                    items.removeListener(weakItemsListener);
                }

                // Remove the listeners of the properties on ListView
                oldListView.editingIndexProperty().removeListener(weakEditingListener);
                oldListView.itemsProperty().removeListener(weakItemsPropertyListener);
                oldListView.focusModelProperty().removeListener(weakFocusModelPropertyListener);
                oldListView.selectionModelProperty().removeListener(weakSelectionModelPropertyListener);
            }

            if (currentListView != null) {
                final MultipleSelectionModel&lt;T&gt; sm = currentListView.getSelectionModel();
                if (sm != null) {
                    sm.getSelectedIndices().addListener(weakSelectedListener);
                }

                final FocusModel&lt;T&gt; fm = currentListView.getFocusModel();
                if (fm != null) {
                    fm.focusedIndexProperty().addListener(weakFocusedListener);
                }

                final ObservableList&lt;T&gt; items = currentListView.getItems();
                if (items != null) {
                    items.addListener(weakItemsListener);
                }

                currentListView.editingIndexProperty().addListener(weakEditingListener);
                currentListView.itemsProperty().addListener(weakItemsPropertyListener);
                currentListView.focusModelProperty().addListener(weakFocusModelPropertyListener);
                currentListView.selectionModelProperty().addListener(weakSelectionModelPropertyListener);

                weakListViewRef = new WeakReference&lt;ListView&lt;T&gt;&gt;(currentListView);
            }

            updateItem(-1);
            updateSelection();
            updateFocus();
            requestLayout();
        }
    };
    private void setListView(ListView&lt;T&gt; value) { listView.set(value); }
    public final ListView&lt;T&gt; getListView() { return listView.get(); }
    public final ReadOnlyObjectProperty&lt;ListView&lt;T&gt;&gt; listViewProperty() { return listView.getReadOnlyProperty(); }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void indexChanged(int oldIndex, int newIndex) {
        super.indexChanged(oldIndex, newIndex);

        if (isEditing() &amp;&amp; newIndex == oldIndex) {
            // no-op
            // Fix for RT-31165 - if we (needlessly) update the index whilst the
            // cell is being edited it will no longer be in an editing state.
            // This means that in certain (common) circumstances that it will
            // appear that a cell is uneditable as, despite being clicked, it
            // will not change to the editing state as a layout of VirtualFlow
            // is immediately invoked, which forces all cells to be updated.
        } else {
            updateItem(oldIndex);
            updateSelection();
            updateFocus();
        }
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new ListCellSkin&lt;T&gt;(this);
    }


    /***************************************************************************
     *                                                                         *
     * Editing API                                                             *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void startEdit() {
        final ListView&lt;T&gt; list = getListView();
        if (!isEditable() || (list != null &amp;&amp; ! list.isEditable())) {
            return;
        }

        // it makes sense to get the cell into its editing state before firing
        // the event to the ListView below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

         // Inform the ListView of the edit starting.
        if (list != null) {
            list.fireEvent(new ListView.EditEvent&lt;T&gt;(list,
<A NAME="25"></A>                    ListView.&lt;T&gt;editStartEvent(),
                    null,
                    getIndex()));
            <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#25',2,'match36-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>list.edit(getIndex());
            list.requestFocus();
        }
    }

    /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing</B></FONT>()) return;
        ListView&lt;T&gt; list = getListView();

        if (list != null) {
            // Inform the ListView of the edit being ready to be committed.
            list.fireEvent(new ListView.EditEvent&lt;T&gt;(list,
                    ListView.&lt;T&gt;editCommitEvent(),
                    newValue,
                    list.getEditingIndex()));
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state.
        // This MUST come before the updateItem call below, otherwise it will
        // call cancelEdit(), resulting in both commit and cancel events being
        // fired (as identified in RT-29650)
        super.commitEdit(newValue);

        // update the item within this cell, so that it represents the new value
        updateItem(newValue, false);

        if (list != null) {
            // reset the editing index on the ListView. This must come after the
            // event is fired so that the developer on the other side can consult
            // the ListView editingIndex property (if they choose to do that
            // rather than just grab the int from the event).
            list.edit(-1);

            // request focus back onto the list, only if the current focus
            // owner has the list as a parent (otherwise the user might have
            // clicked out of the list entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(list);
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

         // Inform the ListView of the edit being cancelled.
        ListView&lt;T&gt; list = getListView();

        super.cancelEdit();

        if (list != null) {
            int editingIndex = list.getEditingIndex();

            // reset the editing index on the ListView
            if (updateEditingIndex) list.edit(-1);

            // request focus back onto the list, only if the current focus
            // owner has the list as a parent (otherwise the user might have
            // clicked out of the list entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(list);

            list.fireEvent(new ListView.EditEvent&lt;T&gt;(list,
                    ListView.&lt;T&gt;editCancelEvent(),
                    null,
                    editingIndex));
        }
    }


    /* *************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean firstRun = true;
    private void updateItem(int oldIndex) {
        final ListView&lt;T&gt; lv = getListView();
        final List&lt;T&gt; items = lv == null ? null : lv.getItems();
        final int index = getIndex();
        final int itemCount = items == null ? -1 : items.size();

        // Compute whether the index for this cell is for a real item
        boolean valid = items != null &amp;&amp; index &gt;=0 &amp;&amp; index &lt; itemCount;

        final T oldValue = getItem();
        final boolean isEmpty = isEmpty();

        // Cause the cell to update itself
        outer: if (valid) {
            final T newValue = items.get(index);

            // RT-35864 - if the index didn't change, then avoid calling updateItem
            // unless the item has changed.
            if (oldIndex == index) {
                if (!isItemChanged(oldValue, newValue)) {
                    // RT-37054:  we break out of the if/else code here and
                    // proceed with the code following this, so that we may
                    // still update references, listeners, etc as required.
                    break outer;
                }
            }
            updateItem(newValue, false);
        } else {
            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            if ((!isEmpty &amp;&amp; oldValue != null) || firstRun) {
                updateItem(null, true);
                firstRun = false;
            }
        }
    }

    /**
     * Updates the ListView associated with this Cell.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param listView the ListView associated with this cell
     */
    public final void updateListView(ListView&lt;T&gt; listView) {
        setListView(listView);
    }

    private void updateSelection() {
        if (isEmpty()) return;
        int index = getIndex();
        ListView&lt;T&gt; listView = getListView();
        if (index == -1 || listView == null) return;

        SelectionModel&lt;T&gt; sm = listView.getSelectionModel();
        if (sm == null) {
            updateSelected(false);
            return;
        }

        boolean isSelected = sm.isSelected(index);
        if (isSelected() == isSelected) return;

        updateSelected(isSelected);
    }

    private void updateFocus() {
        int index = getIndex();
        ListView&lt;T&gt; listView = getListView();
        if (index == -1 || listView == null) return;

        FocusModel&lt;T&gt; fm = listView.getFocusModel();
        if (fm == null) {
            setFocused(false);
            return;
        }

        setFocused(fm.isFocused(index));
    }

    private void updateEditing() {
        final int index = getIndex();
        final ListView&lt;T&gt; list = getListView();
        final int editIndex = list == null ? -1 : list.getEditingIndex();
        final boolean editing = isEditing();

        // Check that the list is specified, and my index is not -1
        if (index != -1 &amp;&amp; list != null) {
            // If my index is the index being edited and I'm not currently in
            // the edit mode, then I need to enter the edit mode
            if (index == editIndex &amp;&amp; !editing) {
                startEdit();
            } else if (index != editIndex &amp;&amp; editing) {
                // If my index is not the one being edited then I need to cancel
                // the edit. The tricky thing here is that as part of this call
                // I cannot end up calling list.edit(-1) the way that the standard
                // cancelEdit method would do. Yet, I need to call cancelEdit
                // so that subclasses which override cancelEdit can execute. So,
                // I have to use a kind of hacky flag workaround.
                updateEditingIndex = false;
                cancelEdit();
                updateEditingIndex = true;
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;list-cell&quot;;



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case INDEX: return getIndex();
            case SELECTED: return isSelected();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS: {
                ListView&lt;T&gt; listView = getListView();
                if (listView != null) {
                    FocusModel&lt;T&gt; fm = listView.getFocusModel();
                    if (fm != null) {
                        fm.focus(getIndex());
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/MultipleSelectionModelBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.collections.NonIterableChange;
import static javafx.scene.control.SelectionMode.SINGLE;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.sun.javafx.scene.control.MultipleAdditionAndRemovedChange;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableListBase;
import javafx.util.Callback;

import javafx.util.Pair;


/**
 * An abstract class that implements more of the abstract MultipleSelectionModel
 * abstract class. However, this class is package-protected and not intended
 * for public use.
 *
 * @param &lt;T&gt; The type of the underlying data model for the UI control.
 */
abstract class MultipleSelectionModelBase&lt;T&gt; extends MultipleSelectionModel&lt;T&gt; {

    /***********************************************************************
     *                                                                     *
     * Constructors                                                        *
     *                                                                     *
     **********************************************************************/

    public MultipleSelectionModelBase() {
        selectedIndexProperty().addListener(valueModel -&gt; {
            // we used to lazily retrieve the selected item, but now we just
            // do it when the selection changes. This is hardly likely to be
            // expensive, and we still lazily handle the multiple selection
            // cases over in MultipleSelectionModel.
            setSelectedItem(getModelItem(getSelectedIndex()));
        });

        selectedIndices = new SelectedIndicesList();

        selectedItems = new SelectedItemsReadOnlyObservableList&lt;T&gt;(selectedIndices, () -&gt; getItemCount()) {
            @Override protected T getModelItem(int index) {
                return MultipleSelectionModelBase.this.getModelItem(index);
            }
        };
    }



    /***********************************************************************
     *                                                                     *
     * Observable properties                                               *
     *                                                                     *
     **********************************************************************/

    /*
     * We only maintain the values of the selectedIndex and selectedIndices
     * properties. The value of the selectedItem and selectedItems properties
     * is determined on-demand. We fire the SELECTED_ITEM and SELECTED_ITEMS
     * property change events whenever the related SELECTED_INDEX or
     * SELECTED_INDICES properties change.
     *
     * This means that the cost of the ListViewSelectionModel is cheap in most
     * cases, assuming that the end-consumer isn't calling getSelectedItems
     * too aggressively. Of course, this is only an issue when the ListViewModel
     * is being populated by some remote, expensive to query data source.
     *
     * In addition, we do not provide ObservableLists for the selected indices or the
     * selected items properties, as this would allow the API consumer to add
     * observers to these ObservableLists. This would make life tougher as we would
     * then be forced to keep these ObservableLists in-sync at all times, which for
     * the selectedItems ObservableList, would require potentially a lot of work and
     * memory. Instead, we return a List, and allow for changes to these Lists
     * to be observed through the SELECTED_INDICES and SELECTED_ITEMS
     * properties.
     */


    final SelectedIndicesList selectedIndices;
    @Override public ObservableList&lt;Integer&gt; getSelectedIndices() {
        return selectedIndices;
    }

    private final ObservableListBase&lt;T&gt; selectedItems;
    @Override public ObservableList&lt;T&gt; getSelectedItems() {
        return selectedItems;
    }



    /***********************************************************************
     *                                                                     *
     * Internal field                                                      *
     *                                                                     *
     **********************************************************************/

    ListChangeListener.Change selectedItemChange;



    /***********************************************************************
     *                                                                     *
     * Public selection API                                                *
     *                                                                     *
     **********************************************************************/

    /**
     * Returns the number of items in the data model that underpins the control.
     * An example would be that a ListView selection model would likely return
     * &lt;code&gt;listView.getItems().size()&lt;/code&gt;. The valid range of selectable
     * indices is between 0 and whatever is returned by this method.
     * @return the number of items in the data model that underpins the control
     */
    protected abstract int getItemCount();

    /**
     * Returns the item at the given index. An example using ListView would be
     * &lt;code&gt;listView.getItems().get(index)&lt;/code&gt;.
     *
     * @param index The index of the item that is requested from the underlying
     *      data model.
     * @return Returns null if the index is out of bounds, or an element of type
     *      T that is related to the given index.
     */
    protected abstract T getModelItem(int index);
    protected abstract void focus(int index);
    protected abstract int getFocusedIndex();

    static class ShiftParams {
        private final int clearIndex;
        private final int setIndex;
        private final boolean selected;

        ShiftParams(int clearIndex, int setIndex, boolean selected) {
            this.clearIndex = clearIndex;
            this.setIndex = setIndex;
            this.selected = selected;
        }

        public final int getClearIndex() {
            return clearIndex;
        }

        public final int getSetIndex() {
            return setIndex;
        }

        public final boolean isSelected() {
            return selected;
        }
    }

    // package only
    void shiftSelection(int position, int shift, final Callback&lt;ShiftParams, Void&gt; callback) {
        shiftSelection(Arrays.asList(new Pair&lt;&gt;(position, shift)), callback);
    }

    void shiftSelection(List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts, final Callback&lt;ShiftParams, Void&gt; callback) {
        int selectedIndicesCardinality = selectedIndices.size(); // number of true bits
        if (selectedIndicesCardinality == 0) return;

        int selectedIndicesSize = selectedIndices.bitsetSize();   // number of bits reserved

        int[] perm = new int[selectedIndicesSize];
        Arrays.fill(perm, -1);

        // sort the list so that we iterate from highest position to lowest position
        Collections.sort(shifts, (s1, s2) -&gt; Integer.compare(s2.getKey(), s1.getKey()));
        final int lowestShiftPosition = shifts.get(shifts.size() - 1).getKey();

        // make a copy of the selectedIndices before so we can compare to it afterwards
        BitSet selectedIndicesCopy = (BitSet) selectedIndices.bitset.clone();

        startAtomic();
        for (Pair&lt;Integer, Integer&gt; shift : shifts) {
            doShift(shift, callback, perm);
        }
        stopAtomic();

        // strip out all useless -1 default values from the perm array
        final int[] prunedPerm = Arrays.stream(perm).filter(value -&gt; value &gt; -1).toArray();
        final boolean hasSelectionChanged = prunedPerm.length &gt; 0;

        // This ensure that the selection remains accurate when a shift occurs.
        final int selectedIndex = getSelectedIndex();
        if (selectedIndex &gt;= lowestShiftPosition &amp;&amp; selectedIndex &gt; -1) {
            // sum up the total shift, where the position is less than or equal
            // to the previously selected index
            int totalShift = shifts.stream()
                    .filter(shift -&gt; shift.getKey() &lt;= selectedIndex)
                    .mapToInt(shift -&gt; shift.getValue())
                    .sum();

            // Fix for RT-38787: we used to not enter this block if
            // selectedIndex + shift resulted in a value less than zero, whereas
            // now we just set the newSelectionLead to zero in that instance.
            // There exists unit tests that cover this.
            final int newSelectionLead = Math.max(0, selectedIndex + totalShift);

            setSelectedIndex(newSelectionLead);

            // added the selectedIndices call for RT-30356.
            // changed to check if hasPermutated, and to call select(..) for RT-40010.
            // This forces the selection event to go through the system and fire
            // the necessary events.
            if (hasSelectionChanged) {
                selectedIndices.set(newSelectionLead, true);
            } else {
                select(newSelectionLead);
            }

            // removed due to RT-27185
//            focus(newSelectionLead);
        }

        if (hasSelectionChanged) {
            // work out what indices were removed and added
            BitSet removed = (BitSet) selectedIndicesCopy.clone();
            removed.andNot(selectedIndices.bitset);

            BitSet added = (BitSet) selectedIndices.bitset.clone();
            added.andNot(selectedIndicesCopy);

            selectedIndices.reset();
            selectedIndices.callObservers(new MultipleAdditionAndRemovedChange&lt;&gt;(
                    added.stream().boxed().collect(Collectors.toList()),
                    removed.stream().boxed().collect(Collectors.toList()),
                    selectedIndices
            ));
        }
    }

    private void doShift(Pair&lt;Integer, Integer&gt; shiftPair, final Callback&lt;ShiftParams, Void&gt; callback, int[] perm) {
        final int position = shiftPair.getKey();
        final int shift = shiftPair.getValue();

        // with no check here, we get RT-15024
        if (position &lt; 0) return;
        if (shift == 0) return;

        int idx = (int) Arrays.stream(perm).filter(value -&gt; value &gt; -1).count();

        int selectedIndicesSize = selectedIndices.bitsetSize() - idx;   // number of bits reserved

        if (shift &gt; 0) {
            for (int i = selectedIndicesSize - 1; i &gt;= position &amp;&amp; i &gt;= 0; i--) {
                boolean selected = selectedIndices.isSelected(i);

                if (callback == null) {
                    selectedIndices.clear(i);
                    selectedIndices.set(i + shift, selected);
                } else {
                    callback.call(new ShiftParams(i, i + shift, selected));
                }

                if (selected) {
                    perm[idx++] = i + 1;
                }
            }
            selectedIndices.clear(position);
        } else if (shift &lt; 0) {
            for (int i = position; i &lt; selectedIndicesSize; i++) {
                if ((i + shift) &lt; 0) continue;
                if ((i + 1 + shift) &lt; position) continue;
                boolean selected = selectedIndices.isSelected(i + 1);

                if (callback == null) {
                    selectedIndices.clear(i + 1);
                    selectedIndices.set(i + 1 + shift, selected);
                } else {
                    callback.call(new ShiftParams(i + 1, i + 1 + shift, selected));
                }

                if (selected) {
                    perm[idx++] = i;
                }
            }
        }
    }

    void startAtomic() {
        selectedIndices.startAtomic();
    }

    void stopAtomic() {
        selectedIndices.stopAtomic();
    }

    boolean isAtomic() {
        return selectedIndices.isAtomic();
    }

    @Override public void clearAndSelect(int row) {
        if (row &lt; 0 || row &gt;= getItemCount()) {
            clearSelection();
            return;
        }

        final boolean wasSelected = isSelected(row);

        // RT-33558 if this method has been called with a given row, and that
        // row is the only selected row currently, then this method becomes a no-op.
        if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
            // before we return, we double-check that the selected item
            // is equal to the item in the given index
            if (getSelectedItem() == getModelItem(row)) {
                return;
            }
        }

        // firstly we make a copy of the selection, so that we can send out
        // the correct details in the selection change event.
        // We remove the new selection from the list seeing as it is not removed.
        BitSet selectedIndicesCopy = new BitSet();
        selectedIndicesCopy.or(selectedIndices.bitset);
        selectedIndicesCopy.clear(row);
        List&lt;Integer&gt; previousSelectedIndices = new SelectedIndicesList(selectedIndicesCopy);

        // RT-32411 We used to call quietClearSelection() here, but this
        // resulted in the selectedItems and selectedIndices lists never
        // reporting that they were empty.
        // makeAtomic toggle added to resolve RT-32618
        startAtomic();

        // then clear the current selection
        clearSelection();

        // and select the new row
        select(row);
        stopAtomic();

        // fire off a single add/remove/replace notification (rather than
        // individual remove and add notifications) - see RT-33324
        ListChangeListener.Change&lt;Integer&gt; change;

        /*
         * getFrom() documentation:
         *   If wasAdded is true, the interval contains all the values that were added.
         *   If wasPermutated is true, the interval marks the values that were permutated.
         *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
         *   return the same number - the place where the removed elements were positioned in the list.
         */
        if (wasSelected) {
            change = ControlUtils.buildClearAndSelectChange(selectedIndices, previousSelectedIndices, row);
        } else {
            int changeIndex = Math.max(0, selectedIndices.indexOf(row));
            change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                    changeIndex, changeIndex+1, previousSelectedIndices, selectedIndices);
        }

        selectedIndices.callObservers(change);
    }

    @Override public void select(int row) {
        if (row == -1) {
            clearSelection();
            return;
        }
        if (row &lt; 0 || row &gt;= getItemCount()) {
            return;
        }

        boolean isSameRow = row == getSelectedIndex();
        T currentItem = getSelectedItem();
        T newItem = getModelItem(row);
        boolean isSameItem = newItem != null &amp;&amp; newItem.equals(currentItem);
        boolean fireUpdatedItemEvent = isSameRow &amp;&amp; ! isSameItem;

        // focus must come first so that we have the anchors set appropriately
        focus(row);

        if (! selectedIndices.isSelected(row)) {
            if (getSelectionMode() == SINGLE) {
                startAtomic();
                quietClearSelection();
                stopAtomic();
            }
            selectedIndices.set(row);
        }

<A NAME="31"></A>        setSelectedIndex(row);

        if (fireUpdatedItemEvent) {
            <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#31',2,'match36-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setSelectedItem(newItem);
        }
    }

    @Override public void select(T obj) {
//        if (getItemCount() &lt;= 0) return;

        if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
            clearSelection</B></FONT>();
            return;
        }

        // We have no option but to iterate through the model and select the
        // first occurrence of the given object. Once we find the first one, we
        // don't proceed to select any others.
        Object rowObj = null;
        for (int i = 0, max = getItemCount(); i &lt; max; i++) {
            rowObj = getModelItem(i);
            if (rowObj == null) continue;

            if (rowObj.equals(obj)) {
                if (isSelected(i)) {
                    return;
                }

                if (getSelectionMode() == SINGLE) {
                    quietClearSelection();
                }

                select(i);
                return;
            }
        }

        // if we are here, we did not find the item in the entire data model.
        // Even still, we allow for this item to be set to the give object.
        // We expect that in concrete subclasses of this class we observe the
        // data model such that we check to see if the given item exists in it,
        // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
        setSelectedIndex(-1);
        setSelectedItem(obj);
    }

    @Override public void selectIndices(int row, int... rows) {
        if (rows == null || rows.length == 0) {
            select(row);
            return;
        }

        /*
         * Performance optimisation - if multiple selection is disabled, only
         * process the end-most row index.
         */

        int rowCount = getItemCount();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();

            for (int i = rows.length - 1; i &gt;= 0; i--) {
                int index = rows[i];
                if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                    selectedIndices.set(index);
                    select(index);
                    break;
                }
            }

            if (selectedIndices.isEmpty()) {
                if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                    selectedIndices.set(row);
                    select(row);
                }
            }
        } else {
            selectedIndices.set(row, rows);

            IntStream.concat(IntStream.of(row), IntStream.of(rows))
                     .filter(index -&gt; index &gt;= 0 &amp;&amp; index &lt; rowCount)
                     .reduce((first, second) -&gt; second)
                     .ifPresent(lastIndex -&gt; {
                         setSelectedIndex(lastIndex);
                         focus(lastIndex);
                         setSelectedItem(getModelItem(lastIndex));
                     });
        }
    }

    @Override public void selectAll() {
        if (getSelectionMode() == SINGLE) return;

        if (getItemCount() &lt;= 0) return;

        final int rowCount = getItemCount();
        final int focusedIndex = getFocusedIndex();

        // set all selected indices to true
        clearSelection();
        selectedIndices.set(0, rowCount, true);

        if (focusedIndex == -1) {
            setSelectedIndex(rowCount - 1);
            focus(rowCount - 1);
        } else {
            setSelectedIndex(focusedIndex);
            focus(focusedIndex);
        }
    }

    @Override public void selectFirst() {
        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (getItemCount() &gt; 0) {
            select(0);
        }
    }

    @Override public void selectLast() {
        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        int numItems = getItemCount();
        if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
            select(numItems - 1);
        }
    }

    @Override public void clearSelection(int index) {
        if (index &lt; 0) return;

        // TODO shouldn't directly access like this
        // TODO might need to update focus and / or selected index/item
        boolean wasEmpty = selectedIndices.isEmpty();
        selectedIndices.clear(index);

        if (! wasEmpty &amp;&amp; selectedIndices.isEmpty()) {
            clearSelection();
        }
    }

    @Override public void clearSelection() {
        quietClearSelection();

        if (! isAtomic()) {
            setSelectedIndex(-1);
            focus(-1);
        }
    }

    private void quietClearSelection() {
        selectedIndices.clear();
    }

    @Override public boolean isSelected(int index) {
        // Note the change in semantics here - we used to check to ensure that
        // the index is less than the item count, but now simply ensure that
        // it is less than the length of the selectedIndices bitset. This helps
        // to resolve issues such as RT-26721, where isSelected(int) was being
        // called for indices that exceeded the item count, as a TreeItem (e.g.
        // the root) was being collapsed.
//        if (index &gt;= 0 &amp;&amp; index &lt; getItemCount()) {
        if (index &gt;= 0 &amp;&amp; index &lt; selectedIndices.bitsetSize()) {
            return selectedIndices.isSelected(index);
        }

        return false;
    }

    @Override public boolean isEmpty() {
        return selectedIndices.isEmpty();
    }

    @Override public void selectPrevious() {
        int focusIndex = getFocusedIndex();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (focusIndex == -1) {
            select(getItemCount() - 1);
        } else if (focusIndex &gt; 0) {
            select(focusIndex - 1);
        }
    }

    @Override public void selectNext() {
        int focusIndex = getFocusedIndex();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (focusIndex == -1) {
            select(0);
        } else if (focusIndex != getItemCount() -1) {
            select(focusIndex + 1);
        }
    }



    /***********************************************************************
     *                                                                     *
     * Private implementation                                              *
     *                                                                     *
     **********************************************************************/

    class SelectedIndicesList extends ReadOnlyUnbackedObservableList&lt;Integer&gt; {
        private final BitSet bitset;

        private int lastGetIndex = -1;
        private int lastGetValue = -1;

        // Fix for RT-20945 (and numerous other issues!)
        private int atomicityCount = 0;

//        @Override
//        public void callObservers(Change&lt;Integer&gt; c) {
//            throw new RuntimeException(&quot;callObservers unavailable&quot;);
//        }

        public SelectedIndicesList() {
            this(new BitSet());
        }

        public SelectedIndicesList(BitSet bitset) {
            this.bitset = bitset;
        }

        boolean isAtomic() {
            return atomicityCount &gt; 0;
        }
        void startAtomic() {
            atomicityCount++;
        }
        void stopAtomic() {
            atomicityCount = Math.max(0, atomicityCount - 1);
        }

        // Returns the selected index at the given index.
        // e.g. if our selectedIndices are [1,3,5], then an index of 2 will return 5 here.
        @Override public Integer get(int index) {
            final int itemCount = size();
            if (index &lt; 0 || index &gt;= itemCount)  {
                throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot; + itemCount);
            }

            if (index == (lastGetIndex + 1) &amp;&amp; lastGetValue &lt; itemCount) {
                // we're iterating forward in order, short circuit for
                // performance reasons (RT-39776)
                lastGetIndex++;
                lastGetValue = bitset.nextSetBit(lastGetValue + 1);
                return lastGetValue;
            } else if (index == (lastGetIndex - 1) &amp;&amp; lastGetValue &gt; 0) {
                // we're iterating backward in order, short circuit for
                // performance reasons (RT-39776)
                lastGetIndex--;
                lastGetValue = bitset.previousSetBit(lastGetValue - 1);
                return lastGetValue;
            } else {
                for (lastGetIndex = 0, lastGetValue = bitset.nextSetBit(0);
                     lastGetValue &gt;= 0 || lastGetIndex == index;
                     lastGetIndex++, lastGetValue = bitset.nextSetBit(lastGetValue + 1)) {
                    if (lastGetIndex == index) {
                        return lastGetValue;
                    }
                }
            }

            return -1;
        }

        public void set(int index) {
            if (!isValidIndex(index) || isSelected(index)) {
                return;
            }

            _beginChange();
            bitset.set(index);
            int indicesIndex = indexOf(index);
            _nextAdd(indicesIndex, indicesIndex + 1);
            _endChange();
        }

        private boolean isValidIndex(int index) {
            return index &gt;= 0 &amp;&amp; index &lt; getItemCount();
        }

        public void set(int index, boolean isSet) {
            if (isSet) {
                set(index);
            } else {
                clear(index);
            }
        }

        public void set(int index, int end, boolean isSet) {
            _beginChange();
            if (isSet) {
                bitset.set(index, end, isSet);
                int indicesIndex = indexOf(index);
                int span = end - index;
                _nextAdd(indicesIndex, indicesIndex + span);
            } else {
                // TODO handle remove
                bitset.set(index, end, isSet);
            }
            _endChange();
        }

        public void set(int index, int... indices) {
            if (indices == null || indices.length == 0) {
                set(index);
            } else {
                // we reduce down to the minimal number of changes possible
                // by finding all contiguous indices, of all indices that are
                // not already selected, and which are in the valid range
                startAtomic();
                List&lt;Integer&gt; sortedNewIndices =
                        IntStream.concat(IntStream.of(index), IntStream.of(indices))
                        .distinct()
                        .filter(this::isValidIndex)
                        .filter(this::isNotSelected)
                        .sorted()
                        .boxed()
                        .peek(this::set) // we also set here, but it's atomic!
                        .collect(Collectors.toList());
                stopAtomic();

                final int size = sortedNewIndices.size();
                if (size == 0) {
                    // no-op
                } else if (size == 1) {
                    _beginChange();
                    int _index = sortedNewIndices.get(0);
                    int indicesIndex = indexOf(_index);
                    _nextAdd(indicesIndex, indicesIndex + 1);
                    _endChange();
                } else {
                    _beginChange();
                    int pos = 0;
                    int start = 0;
                    int end = 0;

                    // starting from pos, we keep going until the value is
                    // not the next value
                    int startValue = sortedNewIndices.get(pos++);
                    start = indexOf(startValue);
                    end = start + 1;
                    int endValue = startValue;
                    while (pos &lt; size) {
                        int previousEndValue = endValue;
                        endValue = sortedNewIndices.get(pos++);
                        ++end;
                        if (previousEndValue != (endValue - 1)) {
                            _nextAdd(start, end);
                            start = end;
                            continue;
                        }

                        // special case for when we get to the point where the loop is about to end
                        // and we have uncommitted changes to fire.
                        if (pos == size) {
                            _nextAdd(start, start + pos);
                        }
                    }

                    _endChange();
                }
            }
        }

        public void clear() {
            _beginChange();
            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
            bitset.clear();
            _nextRemove(0, removed);
            _endChange();
        }

        public void clear(int index) {
            if (!bitset.get(index)) return;

            _beginChange();
            bitset.clear(index);
            _nextRemove(index, index);
            _endChange();
        }

//        public void clearAndSelect(int index) {
//            if (index &lt; 0 || index &gt;= getItemCount()) {
//                clearSelection();
//                return;
//            }
//
//            final boolean wasSelected = isSelected(index);
//
//            // RT-33558 if this method has been called with a given row, and that
//            // row is the only selected row currently, then this method becomes a no-op.
//            if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
//                // before we return, we double-check that the selected item
//                // is equal to the item in the given index
//                if (getSelectedItem() == getModelItem(index)) {
//                    return;
//                }
//            }
//
//            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
//            boolean isSelected = removed.contains(index);
//            if (isSelected) {
//                removed.remove((Object)index);
//            }
//
//            if (removed.isEmpty()) {
//                set(index);
//            }
//
//            bitset.clear();
//            bitset.set(index);
//            _beginChange();
//            if (isSelected) {
//                _nextRemove(0, removed);
//            } else {
//                _nextAdd(0, 1);
//                _nextRemove(0, removed);
//            }
//            _endChange();
//        }

        public boolean isSelected(int index) {
            return bitset.get(index);
        }

        public boolean isNotSelected(int index) {
            return !isSelected(index);
        }

        /** Returns number of true bits in BitSet */
        @Override public int size() {
            return bitset.cardinality();
        }

        /** Returns the number of bits reserved in the BitSet */
        public int bitsetSize() {
            return bitset.size();
        }

        @Override public int indexOf(Object obj) {
            reset();
            return super.indexOf(obj);
        }

        @Override public boolean contains(Object o) {
            if (o instanceof Number) {
                Number n = (Number) o;
                int index = n.intValue();

                return index &gt;= 0 &amp;&amp; index &lt; bitset.length() &amp;&amp;
                        bitset.get(index);
            }

            return false;
        }

        public void reset() {
            this.lastGetIndex = -1;
            this.lastGetValue = -1;
        }

        @Override public void _beginChange() {
            if (!isAtomic()) {
                super._beginChange();
            }
        }
<A NAME="32"></A>
        @Override public void _endChange() {
            if (!isAtomic()) {
                <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#32',2,'match36-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super._endChange();
            }
        }

        @Override public final void _nextUpdate(int pos) {
            if (!isAtomic()) {
                nextUpdate</B></FONT>(pos);
            }
        }

        @Override public final void _nextSet(int idx, Integer old) {
            if (!isAtomic()) {
                nextSet(idx, old);
            }
        }

        @Override public final void _nextReplace(int from, int to, List&lt;? extends Integer&gt; removed) {
            if (!isAtomic()) {
                nextReplace(from, to, removed);
            }
        }

        @Override public final void _nextRemove(int idx, List&lt;? extends Integer&gt; removed) {
            if (!isAtomic()) {
                nextRemove(idx, removed);
            }
        }

        @Override public final void _nextRemove(int idx, Integer removed) {
            if (!isAtomic()) {
                nextRemove(idx, removed);
            }
        }

        @Override public final void _nextPermutation(int from, int to, int[] perm) {
            if (!isAtomic()) {
                nextPermutation(from, to, perm);
            }
        }

        @Override public final void _nextAdd(int from, int to) {
            if (!isAtomic()) {
                nextAdd(from, to);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TableCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.css.PseudoClass;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.event.Event;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.control.TableView.TableViewFocusModel;

import javafx.scene.control.skin.TableCellSkin;
import javafx.collections.WeakListChangeListener;
import java.lang.ref.WeakReference;
import java.util.List;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.collections.FXCollections;

import javafx.scene.control.TableColumn.CellEditEvent;


/**
 * Represents a single row/column intersection in a {@link TableView}. To
 * represent this intersection, a TableCell contains an
 * {@link #indexProperty() index} property, as well as a
 * {@link #tableColumnProperty() tableColumn} property. In addition, a TableCell
 * instance knows what {@link TableRow} it exists in.
 *
 * &lt;p&gt;&lt;strong&gt;A note about selection:&lt;/strong&gt; A TableCell visually shows it is
 * selected when two conditions are met:
 * &lt;ol&gt;
 *   &lt;li&gt;The {@link TableSelectionModel#isSelected(int, TableColumnBase)} method
 *   returns true for the row / column that this cell represents, and&lt;/li&gt;
 *   &lt;li&gt;The {@link javafx.scene.control.TableSelectionModel#cellSelectionEnabledProperty() cell selection mode}
 *   property is set to true (to represent that it is allowable to select
 *   individual cells (and not just rows of cells)).&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @see TableView
 * @see TableColumn
 * @see Cell
 * @see IndexedCell
 * @see TableRow
 * @param &lt;S&gt; The type of the TableView generic type (i.e. S == TableView&amp;lt;S&amp;gt;).
 *           This should also match with the first generic type in TableColumn.
 * @param &lt;T&gt; The type of the item contained within the Cell.
 * @since JavaFX 2.0
 */
public class TableCell&lt;S,T&gt; extends IndexedCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Constructs a default TableCell instance with a style class of 'table-cell'
     */
    public TableCell() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TABLE_CELL);

        updateColumnIndex();
    }



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    // package for testing
    boolean lockItemOnEdit = false;


    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private boolean itemDirty = false;

    /*
     * This is the list observer we use to keep an eye on the SelectedCells
     * ObservableList in the table view. Because it is possible that the table can
     * be mutated, we create this observer here, and add/remove it from the
     * storeTableView method.
     */
    private ListChangeListener&lt;TablePosition&gt; selectedListener = c -&gt; {
        while (c.next()) {
            if (c.wasAdded() || c.wasRemoved()) {
                updateSelection();
            }
        }
    };

    // same as above, but for focus
    private final InvalidationListener focusedListener = value -&gt; {
        updateFocus();
    };

    // same as above, but for for changes to the properties on TableRow
    private final InvalidationListener tableRowUpdateObserver = value -&gt; {
        itemDirty = true;
        requestLayout();
    };

    private final InvalidationListener editingListener = value -&gt; {
        updateEditing();
    };

    private ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
        updateColumnIndex();
    };

    private ListChangeListener&lt;String&gt; columnStyleClassListener = c -&gt; {
        while (c.next()) {
            if (c.wasRemoved()) {
                getStyleClass().removeAll(c.getRemoved());
            }

            if (c.wasAdded()) {
                getStyleClass().addAll(c.getAddedSubList());
            }
        }
    };

    private final InvalidationListener columnStyleListener = value -&gt; {
        if (getTableColumn() != null) {
            possiblySetStyle(getTableColumn().getStyle());
        }
    };

    private final InvalidationListener columnIdListener = value -&gt; {
        if (getTableColumn() != null) {
            possiblySetId(getTableColumn().getId());
        }
    };

    private final WeakListChangeListener&lt;TablePosition&gt; weakSelectedListener =
            new WeakListChangeListener&lt;&gt;(selectedListener);
    private final WeakInvalidationListener weakFocusedListener =
            new WeakInvalidationListener(focusedListener);
    private final WeakInvalidationListener weaktableRowUpdateObserver =
            new WeakInvalidationListener(tableRowUpdateObserver);
    private final WeakInvalidationListener weakEditingListener =
            new WeakInvalidationListener(editingListener);
    private final WeakInvalidationListener weakColumnStyleListener =
            new WeakInvalidationListener(columnStyleListener);
    private final WeakInvalidationListener weakColumnIdListener =
            new WeakInvalidationListener(columnIdListener);
    private final WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; weakVisibleLeafColumnsListener =
            new WeakListChangeListener&lt;&gt;(visibleLeafColumnsListener);
    private final WeakListChangeListener&lt;String&gt; weakColumnStyleClassListener =
            new WeakListChangeListener&lt;String&gt;(columnStyleClassListener);


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- TableColumn
    private ReadOnlyObjectWrapper&lt;TableColumn&lt;S,T&gt;&gt; tableColumn = new ReadOnlyObjectWrapper&lt;TableColumn&lt;S,T&gt;&gt;() {
        @Override protected void invalidated() {
            updateColumnIndex();
        }

        @Override public Object getBean() {
            return TableCell.this;
        }

        @Override public String getName() {
            return &quot;tableColumn&quot;;
        }
    };
    /**
     * The TableColumn instance that backs this TableCell.
     * @return the TableColumn instance that backs this TableCell
     */
    public final ReadOnlyObjectProperty&lt;TableColumn&lt;S,T&gt;&gt; tableColumnProperty() { return tableColumn.getReadOnlyProperty(); }
    private void setTableColumn(TableColumn&lt;S,T&gt; value) { tableColumn.set(value); }
    public final TableColumn&lt;S,T&gt; getTableColumn() { return tableColumn.get(); }


    // --- TableView
    private ReadOnlyObjectWrapper&lt;TableView&lt;S&gt;&gt; tableView;
    private void setTableView(TableView&lt;S&gt; value) {
        tableViewPropertyImpl().set(value);
    }
    public final TableView&lt;S&gt; getTableView() {
        return tableView == null ? null : tableView.get();
    }

    /**
     * The TableView associated with this TableCell.
     * @return the TableView associated with this TableCell
     */
    public final ReadOnlyObjectProperty&lt;TableView&lt;S&gt;&gt; tableViewProperty() {
        return tableViewPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TableView&lt;S&gt;&gt; tableViewPropertyImpl() {
        if (tableView == null) {
            tableView = new ReadOnlyObjectWrapper&lt;TableView&lt;S&gt;&gt;() {
                private WeakReference&lt;TableView&lt;S&gt;&gt; weakTableViewRef;
                @Override protected void invalidated() {
                    TableView.TableViewSelectionModel&lt;S&gt; sm;
                    TableViewFocusModel&lt;S&gt; fm;

                    if (weakTableViewRef != null) {
                        cleanUpTableViewListeners(weakTableViewRef.get());
                    }

                    if (get() != null) {
                        sm = get().getSelectionModel();
                        if (sm != null) {
                            sm.getSelectedCells().addListener(weakSelectedListener);
                        }

                        fm = get().getFocusModel();
                        if (fm != null) {
                            fm.focusedCellProperty().addListener(weakFocusedListener);
                        }

                        get().editingCellProperty().addListener(weakEditingListener);
                        get().getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);

                        weakTableViewRef = new WeakReference&lt;TableView&lt;S&gt;&gt;(get());
                    }

                    updateColumnIndex();
                }

                @Override public Object getBean() {
                    return TableCell.this;
                }

                @Override public String getName() {
                    return &quot;tableView&quot;;
                }
            };
        }
        return tableView;
    }



    // --- TableRow
    /**
     * The TableRow that this TableCell currently finds itself placed within.
     * The TableRow may be null early in the TableCell lifecycle, in the period
     * between the TableCell being instantiated and being set into an owner
     * TableRow.
     */
    private ReadOnlyObjectWrapper&lt;TableRow&lt;S&gt;&gt; tableRow = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;tableRow&quot;);
    private void setTableRow(TableRow&lt;S&gt; value) { tableRow.set(value); }
    public final TableRow&lt;S&gt; getTableRow() { return tableRow.get(); }
    public final ReadOnlyObjectProperty&lt;TableRow&lt;S&gt;&gt; tableRowProperty() { return tableRow;  }



    /***************************************************************************
     *                                                                         *
     * Editing API                                                             *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void startEdit() {
        final TableView&lt;S&gt; table = getTableView();
        final TableColumn&lt;S,T&gt; column = getTableColumn();
        if (! isEditable() ||
                (table != null &amp;&amp; ! table.isEditable()) ||
                (column != null &amp;&amp; ! getTableColumn().isEditable())) {
            return;
        }

        // We check the boolean lockItemOnEdit field here, as whilst we want to
        // updateItem normally, when it comes to unit tests we can't have the
        // item change in all circumstances.
        if (! lockItemOnEdit) {
            updateItem(-1);
        }

        // it makes sense to get the cell into its editing state before firing
        // the event to listeners below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

<A NAME="22"></A>        if (column != null) {
            CellEditEvent&lt;S,?&gt; editEvent = new CellEditEvent&lt;&gt;(
                table,
                <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#22',2,'match36-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>table.getEditingCell(),
                TableColumn.editStartEvent(),
                null
            );

            Event.fireEvent(column, editEvent);
        }
    }

    /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing</B></FONT>()) return;

        final TableView&lt;S&gt; table = getTableView();
        if (table != null) {
            // Inform the TableView of the edit being ready to be committed.
            CellEditEvent editEvent = new CellEditEvent(
                table,
                table.getEditingCell(),
                TableColumn.editCommitEvent(),
                newValue
            );

            Event.fireEvent(getTableColumn(), editEvent);
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state.
        // This MUST come before the updateItem call below, otherwise it will
        // call cancelEdit(), resulting in both commit and cancel events being
        // fired (as identified in RT-29650)
        super.commitEdit(newValue);

        // update the item within this cell, so that it represents the new value
        updateItem(newValue, false);

        if (table != null) {
            // reset the editing cell on the TableView
            table.edit(-1, null);

            // request focus back onto the table, only if the current focus
            // owner has the table as a parent (otherwise the user might have
            // clicked out of the table entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(table);
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

        final TableView&lt;S&gt; table = getTableView();

        super.cancelEdit();

        // reset the editing index on the TableView
        if (table != null) {
            TablePosition&lt;S,?&gt; editingCell = table.getEditingCell();
            if (updateEditingIndex) table.edit(-1, null);

            // request focus back onto the table, only if the current focus
            // owner has the table as a parent (otherwise the user might have
            // clicked out of the table entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(table);

<A NAME="23"></A>            CellEditEvent&lt;S,?&gt; editEvent = new CellEditEvent&lt;&gt;(
                table,
                editingCell,
                <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#23',2,'match36-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TableColumn.editCancelEvent(),
                null
            );

            Event.fireEvent(getTableColumn(), editEvent);
        }
    }



    /* *************************************************************************
     *                                                                         *
     * Overriding methods                                                      *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void updateSelected(boolean selected) {
        // copied from Cell, with the first conditional clause below commented
        // out, as it is valid for an empty TableCell to be selected, as long
        // as the parent TableRow is not empty (see RT-15529).
        /*if (selected &amp;&amp; isEmpty()) return;*/
        if (getTableRow</B></FONT>() == null || getTableRow().isEmpty()) return;
        setSelected(selected);
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TableCellSkin&lt;S,T&gt;(this);
    }

//    @Override public void dispose() {
//        cleanUpTableViewListeners(getTableView());
//
//        if (currentObservableValue != null) {
//            currentObservableValue.removeListener(weaktableRowUpdateObserver);
//        }
//
//        super.dispose();
//    }

    /* *************************************************************************
    *                                                                         *
    * Private Implementation                                                  *
    *                                                                         *
    **************************************************************************/

    private void cleanUpTableViewListeners(TableView&lt;S&gt; tableView) {
        if (tableView != null) {
            TableView.TableViewSelectionModel&lt;S&gt; sm = tableView.getSelectionModel();
            if (sm != null) {
                sm.getSelectedCells().removeListener(weakSelectedListener);
            }

            TableViewFocusModel&lt;S&gt; fm = tableView.getFocusModel();
            if (fm != null) {
                fm.focusedCellProperty().removeListener(weakFocusedListener);
            }

            tableView.editingCellProperty().removeListener(weakEditingListener);
            tableView.getVisibleLeafColumns().removeListener(weakVisibleLeafColumnsListener);
        }
    }

    @Override void indexChanged(int oldIndex, int newIndex) {
        super.indexChanged(oldIndex, newIndex);

        // Ideally we would just use the following two lines of code, rather
        // than the updateItem() call beneath, but if we do this we end up with
        // RT-22428 where all the columns are collapsed.
        // itemDirty = true;
        // requestLayout();
        updateItem(oldIndex);
        updateSelection();
        updateFocus();

        // Fix for JDK-8150525
        updateEditing();
    }

    private boolean isLastVisibleColumn = false;
    private int columnIndex = -1;

    private void updateColumnIndex() {
        TableView&lt;S&gt; tv = getTableView();
        TableColumn&lt;S,T&gt; tc = getTableColumn();
        columnIndex = tv == null || tc == null ? -1 : tv.getVisibleLeafIndex(tc);

        // update the pseudo class state regarding whether this is the last
        // visible cell (i.e. the right-most).
        isLastVisibleColumn = getTableColumn() != null &amp;&amp;
                columnIndex != -1 &amp;&amp;
                columnIndex == getTableView().getVisibleLeafColumns().size() - 1;
        pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
    }

    private void updateSelection() {
        /*
         * This cell should be selected if the selection mode of the table
         * is cell-based, and if the row and column that this cell represents
         * is selected.
         *
         * If the selection mode is not cell-based, then the listener in the
         * TableRow class might pick up the need to set an entire row to be
         * selected.
         */
        if (isEmpty()) return;

        final boolean isSelected = isSelected();
        if (! isInCellSelectionMode()) {
            if (isSelected) {
                updateSelected(false);
            }
            return;
        }

        final TableView&lt;S&gt; tableView = getTableView();
        if (getIndex() == -1 || tableView == null) return;

        TableSelectionModel&lt;S&gt; sm = tableView.getSelectionModel();
        if (sm == null) {
            updateSelected(false);
            return;
        }

        boolean isSelectedNow = sm.isSelected(getIndex(), getTableColumn());
        if (isSelected == isSelectedNow) return;

        updateSelected(isSelectedNow);
    }

    private void updateFocus() {
        final boolean isFocused = isFocused();
        if (! isInCellSelectionMode()) {
            if (isFocused) {
                setFocused(false);
            }
            return;
        }

        final TableView&lt;S&gt; tableView = getTableView();
        final TableRow&lt;S&gt; tableRow = getTableRow();
        final int index = getIndex();
        if (index == -1 || tableView == null || tableRow == null) return;

        final TableViewFocusModel&lt;S&gt; fm = tableView.getFocusModel();
        if (fm == null) {
            setFocused(false);
            return;
        }

        setFocused(fm.isFocused(index, getTableColumn()));
    }

    private void updateEditing() {
        if (getIndex() == -1 || getTableView() == null) return;

        TablePosition&lt;S,?&gt; editCell = getTableView().getEditingCell();
        boolean match = match(editCell);

        if (match &amp;&amp; ! isEditing()) {
            startEdit();
        } else if (! match &amp;&amp; isEditing()) {
            // If my index is not the one being edited then I need to cancel
            // the edit. The tricky thing here is that as part of this call
            // I cannot end up calling list.edit(-1) the way that the standard
            // cancelEdit method would do. Yet, I need to call cancelEdit
            // so that subclasses which override cancelEdit can execute. So,
            // I have to use a kind of hacky flag workaround.
            updateEditingIndex = false;
            cancelEdit();
            updateEditingIndex = true;
        }
    }
    private boolean updateEditingIndex = true;

    private boolean match(TablePosition&lt;S,?&gt; pos) {
        return pos != null &amp;&amp; pos.getRow() == getIndex() &amp;&amp; pos.getTableColumn() == getTableColumn();
    }

    private boolean isInCellSelectionMode() {
        TableView&lt;S&gt; tableView = getTableView();
        if (tableView == null) return false;
        TableSelectionModel&lt;S&gt; sm = tableView.getSelectionModel();
        return sm != null &amp;&amp; sm.isCellSelectionEnabled();
    }

    /*
     * This was brought in to fix the issue in RT-22077, namely that the
     * ObservableValue was being GC'd, meaning that changes to the value were
     * no longer being delivered. By extracting this value out of the method,
     * it is now referred to from TableCell and will therefore no longer be
     * GC'd.
     */
    private ObservableValue&lt;T&gt; currentObservableValue = null;

    private boolean isFirstRun = true;

    private WeakReference&lt;S&gt; oldRowItemRef;

    /*
     * This is called when we think that the data within this TableCell may have
     * changed. You'll note that this is a private function - it is only called
     * when one of the triggers above call it.
     */
    private void updateItem(int oldIndex) {
        if (currentObservableValue != null) {
            currentObservableValue.removeListener(weaktableRowUpdateObserver);
        }

        // get the total number of items in the data model
        final TableView&lt;S&gt; tableView = getTableView();
        final List&lt;S&gt; items = tableView == null ? FXCollections.&lt;S&gt;emptyObservableList() : tableView.getItems();
        final TableColumn&lt;S,T&gt; tableColumn = getTableColumn();
        final int itemCount = items == null ? -1 : items.size();
        final int index = getIndex();
        final boolean isEmpty = isEmpty();
        final T oldValue = getItem();

        final TableRow&lt;S&gt; tableRow = getTableRow();
        final S rowItem = tableRow == null ? null : tableRow.getItem();

        final boolean indexExceedsItemCount = index &gt;= itemCount;

        // there is a whole heap of reasons why we should just punt...
        outer: if (indexExceedsItemCount ||
                index &lt; 0 ||
                columnIndex &lt; 0 ||
                !isVisible() ||
                tableColumn == null ||
                !tableColumn.isVisible()) {

            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            // RT-32621: There are circumstances where we need to updateItem,
            // even when the index is greater than the itemCount. For example,
            // RT-32621 identifies issues where a TreeTableView collapses a
            // TreeItem but the custom cells remain visible. This is now
            // resolved with the check for indexExceedsItemCount.
            if ((!isEmpty &amp;&amp; oldValue != null) || isFirstRun || indexExceedsItemCount) {
                updateItem(null, true);
                isFirstRun = false;
            }
            return;
        } else {
            currentObservableValue = tableColumn.getCellObservableValue(index);
            final T newValue = currentObservableValue == null ? null : currentObservableValue.getValue();

            // RT-35864 - if the index didn't change, then avoid calling updateItem
            // unless the item has changed.
            if (oldIndex == index) {
                if (!isItemChanged(oldValue, newValue)) {
                    // RT-36670: we need to check the row item here to prevent
                    // the issue where the cell value and index doesn't change,
                    // but the backing row object does.
                    S oldRowItem = oldRowItemRef != null ? oldRowItemRef.get() : null;
                    if (oldRowItem != null &amp;&amp; oldRowItem.equals(rowItem)) {
                        // RT-37054:  we break out of the if/else code here and
                        // proceed with the code following this, so that we may
                        // still update references, listeners, etc as required//.
                        break outer;
                    }
                }
            }
            updateItem(newValue, false);
        }

        oldRowItemRef = new WeakReference&lt;&gt;(rowItem);

        if (currentObservableValue == null) {
            return;
        }

        // add property change listeners to this item
        currentObservableValue.addListener(weaktableRowUpdateObserver);
    }

    @Override protected void layoutChildren() {
        if (itemDirty) {
            updateItem(-1);
            itemDirty = false;
        }
        super.layoutChildren();
    }




    /***************************************************************************
     *                                                                         *
     *                              Expert API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Updates the TableView associated with this TableCell. This is typically
     * only done once when the TableCell is first added to the TableView.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param tv the TableView associated with this TableCell
     */
    public final void updateTableView(TableView tv) {
        setTableView(tv);
    }

    /**
     * Updates the TableRow associated with this TableCell.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param tableRow the TableRow associated with this TableCell
     */
    public final void updateTableRow(TableRow tableRow) {
        this.setTableRow(tableRow);
    }

    /**
     * Updates the TableColumn associated with this TableCell.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param col the TableColumn associated with this TableCell
     */
    public final void updateTableColumn(TableColumn col) {
        // remove style class of existing table column, if it is non-null
        TableColumn&lt;S,T&gt; oldCol = getTableColumn();
        if (oldCol != null) {
            oldCol.getStyleClass().removeListener(weakColumnStyleClassListener);
            getStyleClass().removeAll(oldCol.getStyleClass());

            oldCol.idProperty().removeListener(weakColumnIdListener);
            oldCol.styleProperty().removeListener(weakColumnStyleListener);

            String id = getId();
            String style = getStyle();
            if (id != null &amp;&amp; id.equals(oldCol.getId())) {
                setId(null);
            }
            if (style != null &amp;&amp; style.equals(oldCol.getStyle())) {
                setStyle(&quot;&quot;);
            }
        }

        setTableColumn(col);

        if (col != null) {
            getStyleClass().addAll(col.getStyleClass());
            col.getStyleClass().addListener(weakColumnStyleClassListener);

            col.idProperty().addListener(weakColumnIdListener);
            col.styleProperty().addListener(weakColumnStyleListener);

            possiblySetId(col.getId());
            possiblySetStyle(col.getStyle());
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;table-cell&quot;;
    private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
            PseudoClass.getPseudoClass(&quot;last-visible&quot;);

    private void possiblySetId(String idCandidate) {
        if (getId() == null || getId().isEmpty()) {
            setId(idCandidate);
        }
    }

    private void possiblySetStyle(String styleCandidate) {
        if (getStyle() == null || getStyle().isEmpty()) {
            setStyle(styleCandidate);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROW_INDEX: return getIndex();
            case COLUMN_INDEX: return columnIndex;
            case SELECTED: return isInCellSelectionMode() ? isSelected() : getTableRow().isSelected();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS: {
                TableView&lt;S&gt; tableView = getTableView();
                if (tableView != null) {
                    TableViewFocusModel&lt;S&gt; fm = tableView.getFocusModel();
                    if (fm != null) {
                        fm.focus(getIndex(), getTableColumn());
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TreeCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.css.PseudoClass;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ListChangeListener;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.skin.TreeCellSkin;
import javafx.collections.WeakListChangeListener;
import java.lang.ref.WeakReference;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;

/**
 * The {@link Cell} type used with the {@link TreeView} control. In addition to
 * the API defined on {@link IndexedCell}, the TreeCell
 * exposes additional states and pseudo classes for use by CSS.
 * &lt;p&gt;
 * A TreeCell watches the selection model of the TreeView for which it is
 * associated, ensuring that it visually indicates to the user whether it is
 * selected. When a TreeCell is selected, this is exposed both via the
 * {@link #selectedProperty() selected} property, as well as via the 'selected'
 * CSS pseudo class state.
 * &lt;p&gt;
 * Due to the fact that TreeCell extends from {@link IndexedCell}, each TreeCell
 * also provides an {@link #indexProperty() index} property. The index will be
 * updated as cells are expanded and collapsed, and therefore should be
 * considered a view index rather than a model index.
 * &lt;p&gt;
 * Finally, each TreeCell also has a reference back to the TreeView that it is
 * being used with. Each TreeCell belongs to one and only one TreeView.
 *
 * @see TreeView
 * @see TreeItem
 * @param &lt;T&gt; The type of the value contained within the
 *      {@link #treeItemProperty() TreeItem} property.
 * @since JavaFX 2.0
 */
public class TreeCell&lt;T&gt; extends IndexedCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TreeCell instance.
     */
    public TreeCell() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TREE_ITEM);
    }



    /***************************************************************************
     *                                                                         *
     * Callbacks and events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;Integer&gt; selectedListener = c -&gt; {
        updateSelection();
    };

    /**
     * Listens to the selectionModel property on the TreeView. Whenever the entire model is changed,
     * we have to unhook the weakSelectedListener and update the selection.
     */
    private final ChangeListener&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; selectionModelPropertyListener = new ChangeListener&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt;() {
        @Override public void changed(ObservableValue&lt;? extends MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; observable,
                                      MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; oldValue,
                                      MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; newValue) {
            if (oldValue != null) {
                oldValue.getSelectedIndices().removeListener(weakSelectedListener);
            }
            if (newValue != null) {
                newValue.getSelectedIndices().addListener(weakSelectedListener);
            }
            updateSelection();
        }
    };

    private final InvalidationListener focusedListener = valueModel -&gt; {
        updateFocus();
    };

    /**
     * Listens to the focusModel property on the TreeView. Whenever the entire model is changed,
     * we have to unhook the weakFocusedListener and update the focus.
     */
    private final ChangeListener&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; focusModelPropertyListener = new ChangeListener&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt;() {
        @Override public void changed(ObservableValue&lt;? extends FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; observable,
                                      FocusModel&lt;TreeItem&lt;T&gt;&gt; oldValue,
                                      FocusModel&lt;TreeItem&lt;T&gt;&gt; newValue) {
            if (oldValue != null) {
                oldValue.focusedIndexProperty().removeListener(weakFocusedListener);
            }
            if (newValue != null) {
                newValue.focusedIndexProperty().addListener(weakFocusedListener);
            }
            updateFocus();
        }
    };

    private final InvalidationListener editingListener = valueModel -&gt; {
        updateEditing();
    };

    private final InvalidationListener leafListener = new InvalidationListener() {
        @Override public void invalidated(Observable valueModel) {
            // necessary to update the disclosure node in the skin when the
            // leaf property changes
            TreeItem&lt;T&gt; treeItem = getTreeItem();
            if (treeItem != null) {
                requestLayout();
            }
        }
    };

    /* proxy pseudo-class state change from treeItem's expandedProperty */
    private boolean oldIsExpanded;
    private final InvalidationListener treeItemExpandedInvalidationListener = new InvalidationListener() {
        @Override public void invalidated(Observable o) {
            boolean isExpanded = ((BooleanProperty)o).get();
            pseudoClassStateChanged(EXPANDED_PSEUDOCLASS_STATE,   isExpanded);
            pseudoClassStateChanged(COLLAPSED_PSEUDOCLASS_STATE, !isExpanded);
            if (isExpanded != oldIsExpanded) {
                notifyAccessibleAttributeChanged(AccessibleAttribute.EXPANDED);
            }
            oldIsExpanded = isExpanded;
        }
    };

    private final InvalidationListener rootPropertyListener = observable -&gt; {
        updateItem(-1);
    };

    private final WeakListChangeListener&lt;Integer&gt; weakSelectedListener = new WeakListChangeListener&lt;Integer&gt;(selectedListener);
    private final WeakChangeListener&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; weakSelectionModelPropertyListener = new WeakChangeListener&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt;(selectionModelPropertyListener);
    private final WeakInvalidationListener weakFocusedListener = new WeakInvalidationListener(focusedListener);
    private final WeakChangeListener&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; weakFocusModelPropertyListener = new WeakChangeListener&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt;(focusModelPropertyListener);
    private final WeakInvalidationListener weakEditingListener = new WeakInvalidationListener(editingListener);
    private final WeakInvalidationListener weakLeafListener = new WeakInvalidationListener(leafListener);
    private final WeakInvalidationListener weakTreeItemExpandedInvalidationListener =
            new WeakInvalidationListener(treeItemExpandedInvalidationListener);
    private final WeakInvalidationListener weakRootPropertyListener = new WeakInvalidationListener(rootPropertyListener);




    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- TreeItem
    private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; treeItem =
        new ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt;(this, &quot;treeItem&quot;) {

            TreeItem&lt;T&gt; oldValue = null;

            @Override protected void invalidated() {
                if (oldValue != null) {
                    oldValue.expandedProperty().removeListener(weakTreeItemExpandedInvalidationListener);
                }

                oldValue = get();

                if (oldValue != null) {
                    oldIsExpanded = oldValue.isExpanded();
                    oldValue.expandedProperty().addListener(weakTreeItemExpandedInvalidationListener);
                    // fake an invalidation to ensure updated pseudo-class state
                    weakTreeItemExpandedInvalidationListener.invalidated(oldValue.expandedProperty());
                }

            }
    };
    private void setTreeItem(TreeItem&lt;T&gt; value) {
        treeItem.set(value);
    }

    /**
     * Returns the TreeItem currently set in this TreeCell.
     * @return the TreeItem currently set in this TreeCell
     */
    public final TreeItem&lt;T&gt; getTreeItem() { return treeItem.get(); }

    /**
     * Each TreeCell represents at most a single {@link TreeItem}, which is
     * represented by this property.
     * @return the TreeItem property representing this TreeCell
     */
    public final ReadOnlyObjectProperty&lt;TreeItem&lt;T&gt;&gt; treeItemProperty() { return treeItem.getReadOnlyProperty(); }



    // --- Disclosure Node
    private ObjectProperty&lt;Node&gt; disclosureNode = new SimpleObjectProperty&lt;Node&gt;(this, &quot;disclosureNode&quot;);

    /**
     * The node to use as the &quot;disclosure&quot; triangle, or toggle, used for
     * expanding and collapsing items. This is only used in the case of
     * an item in the tree which contains child items. If not specified, the
     * TreeCell's Skin implementation is responsible for providing a default
     * disclosure node.
     * @param value the disclosure node
     */
    public final void setDisclosureNode(Node value) { disclosureNodeProperty().set(value); }

    /**
     * Returns the current disclosure node set in this TreeCell.
     * @return the current disclosure node set in this TreeCell
     */
    public final Node getDisclosureNode() { return disclosureNode.get(); }

    /**
     * The disclosure node is commonly seen represented as a triangle that rotates
     * on screen to indicate whether or not the TreeItem that it is placed
     * beside is expanded or collapsed.
     * @return the disclosure node
     */
    public final ObjectProperty&lt;Node&gt; disclosureNodeProperty() { return disclosureNode; }


    // --- TreeView
    private ReadOnlyObjectWrapper&lt;TreeView&lt;T&gt;&gt; treeView = new ReadOnlyObjectWrapper&lt;TreeView&lt;T&gt;&gt;() {
        private WeakReference&lt;TreeView&lt;T&gt;&gt; weakTreeViewRef;
        @Override protected void invalidated() {
            MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm;
            FocusModel&lt;TreeItem&lt;T&gt;&gt; fm;

            if (weakTreeViewRef != null) {
                TreeView&lt;T&gt; oldTreeView = weakTreeViewRef.get();
                if (oldTreeView != null) {
                    // remove old listeners
                    sm = oldTreeView.getSelectionModel();
                    if (sm != null) {
                        sm.getSelectedIndices().removeListener(weakSelectedListener);
                    }

                    fm = oldTreeView.getFocusModel();
                    if (fm != null) {
                        fm.focusedIndexProperty().removeListener(weakFocusedListener);
                    }

                    oldTreeView.editingItemProperty().removeListener(weakEditingListener);
                    oldTreeView.focusModelProperty().removeListener(weakFocusModelPropertyListener);
                    oldTreeView.selectionModelProperty().removeListener(weakSelectionModelPropertyListener);
                    oldTreeView.rootProperty().removeListener(weakRootPropertyListener);
                }

                weakTreeViewRef = null;
            }

            TreeView&lt;T&gt; treeView = get();
            if (treeView != null) {
                sm = treeView.getSelectionModel();
                if (sm != null) {
                    // listening for changes to treeView.selectedIndex and IndexedCell.index,
                    // to determine if this cell is selected
                    sm.getSelectedIndices().addListener(weakSelectedListener);
                }

                fm = treeView.getFocusModel();
                if (fm != null) {
                    // similar to above, but this time for focus
                    fm.focusedIndexProperty().addListener(weakFocusedListener);
                }

                treeView.editingItemProperty().addListener(weakEditingListener);
                treeView.focusModelProperty().addListener(weakFocusModelPropertyListener);
                treeView.selectionModelProperty().addListener(weakSelectionModelPropertyListener);
                treeView.rootProperty().addListener(weakRootPropertyListener);

                weakTreeViewRef = new WeakReference&lt;TreeView&lt;T&gt;&gt;(treeView);
            }

            updateItem(-1);
            requestLayout();
        }

        @Override
        public Object getBean() {
            return TreeCell.this;
        }

        @Override
        public String getName() {
            return &quot;treeView&quot;;
        }
    };

    private void setTreeView(TreeView&lt;T&gt; value) { treeView.set(value); }

    /**
     * Returns the TreeView associated with this TreeCell.
     * @return the TreeView associated with this TreeCell
     */
    public final TreeView&lt;T&gt; getTreeView() { return treeView.get(); }

    /**
     * A TreeCell is explicitly linked to a single {@link TreeView} instance,
     * which is represented by this property.
     * @return the TreeView property of this TreeCell
     */
    public final ReadOnlyObjectProperty&lt;TreeView&lt;T&gt;&gt; treeViewProperty() { return treeView.getReadOnlyProperty(); }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void startEdit() {
        if (isEditing()) return;

        final TreeView&lt;T&gt; tree = getTreeView();
        if (! isEditable() || (tree != null &amp;&amp; ! tree.isEditable())) {
//            if (Logging.getControlsLogger().isLoggable(PlatformLogger.SEVERE)) {
//                Logging.getControlsLogger().severe(
//                    &quot;Can not call TreeCell.startEdit() on this TreeCell, as it &quot;
//                        + &quot;is not allowed to enter its editing state (TreeCell: &quot;
//                        + this + &quot;, TreeView: &quot; + tree + &quot;).&quot;);
//            }
            return;
        }

        updateItem(-1);

        // it makes sense to get the cell into its editing state before firing
        // the event to the TreeView below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

         // Inform the TreeView of the edit starting.
<A NAME="26"></A>        if (tree != null) {
            tree.fireEvent(new TreeView.EditEvent&lt;T&gt;(tree,
                    TreeView.&lt;T&gt;editStartEvent(),
                    <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#26',2,'match36-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getTreeItem(),
                    getItem(),
                    null));

            tree.requestFocus();
        }
    }

     /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing</B></FONT>()) return;
        final TreeItem&lt;T&gt; treeItem = getTreeItem();
        final TreeView&lt;T&gt; tree = getTreeView();
        if (tree != null) {
            // Inform the TreeView of the edit being ready to be committed.
            tree.fireEvent(new TreeView.EditEvent&lt;T&gt;(tree,
                    TreeView.&lt;T&gt;editCommitEvent(),
                    treeItem,
                    getItem(),
                    newValue));
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state.
        // This MUST come before the updateItem call below, otherwise it will
        // call cancelEdit(), resulting in both commit and cancel events being
        // fired (as identified in RT-29650)
        super.commitEdit(newValue);

        // update the item within this cell, so that it represents the new value
        if (treeItem != null) {
            treeItem.setValue(newValue);
            updateTreeItem(treeItem);
            updateItem(newValue, false);
        }

        if (tree != null) {
            // reset the editing item in the TreetView
            tree.edit(null);

            // request focus back onto the tree, only if the current focus
            // owner has the tree as a parent (otherwise the user might have
            // clicked out of the tree entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(tree);
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

        TreeView&lt;T&gt; tree = getTreeView();

        super.cancelEdit();

        if (tree != null) {
            // reset the editing index on the TreeView
            if (updateEditingIndex) tree.edit(null);

            // request focus back onto the tree, only if the current focus
            // owner has the tree as a parent (otherwise the user might have
            // clicked out of the tree entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(tree);

            tree.fireEvent(new TreeView.EditEvent&lt;T&gt;(tree,
                    TreeView.&lt;T&gt;editCancelEvent(),
                    getTreeItem(),
                    getItem(),
                    null));
        }
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TreeCellSkin&lt;T&gt;(this);
    }

    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void indexChanged(int oldIndex, int newIndex) {
        super.indexChanged(oldIndex, newIndex);

        // when the cell index changes, this may result in the cell
        // changing state to be selected and/or focused.
        if (isEditing() &amp;&amp; newIndex == oldIndex) {
            // no-op
            // Fix for RT-31165 - if we (needlessly) update the index whilst the
            // cell is being edited it will no longer be in an editing state.
            // This means that in certain (common) circumstances that it will
            // appear that a cell is uneditable as, despite being clicked, it
            // will not change to the editing state as a layout of VirtualFlow
            // is immediately invoked, which forces all cells to be updated.
        } else {
            updateItem(oldIndex);
            updateSelection();
            updateFocus();
        }
    }

    private boolean isFirstRun = true;
    private void updateItem(int oldIndex) {
        TreeView&lt;T&gt; tv = getTreeView();
        if (tv == null) return;

        // Compute whether the index for this cell is for a real item
        int index = getIndex();
        boolean valid = index &gt;=0 &amp;&amp; index &lt; tv.getExpandedItemCount();
        final boolean isEmpty = isEmpty();
        final TreeItem&lt;T&gt; oldTreeItem = getTreeItem();

        // Cause the cell to update itself
        outer: if (valid) {
            // update the TreeCell state.
            // get the new treeItem that is about to go in to the TreeCell
            TreeItem&lt;T&gt; newTreeItem = tv.getTreeItem(index);
            T newValue = newTreeItem == null ? null : newTreeItem.getValue();
            T oldValue = oldTreeItem == null ? null : oldTreeItem.getValue();

            // For the sake of RT-14279, it is important that the order of these
            // method calls is as shown below. If the order is switched, it is
            // likely that events will be fired where the item is null, even
            // though calling cell.getTreeItem().getValue() returns the value
            // as expected

            // RT-35864 - if the index didn't change, then avoid calling updateItem
            // unless the item has changed.
            if (oldIndex == index) {
                if (!isItemChanged(oldValue, newValue)) {
                    // RT-37054:  we break out of the if/else code here and
                    // proceed with the code following this, so that we may
                    // still update references, listeners, etc as required.
                    break outer;
                }
            }
            updateTreeItem(newTreeItem);
            updateItem(newValue, false);
        } else {
            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            if ((!isEmpty &amp;&amp; oldTreeItem != null) || isFirstRun) {
                updateTreeItem(null);
                updateItem(null, true);
                isFirstRun = false;
            }
        }
    }

    private void updateSelection() {
        if (isEmpty()) return;
        if (getIndex() == -1 || getTreeView() == null) return;

        SelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getTreeView().getSelectionModel();
        if (sm == null) {
            updateSelected(false);
            return;
        }

        boolean isSelected = sm.isSelected(getIndex());
        if (isSelected() == isSelected) return;

        updateSelected(isSelected);
    }

    private void updateFocus() {
        if (getIndex() == -1 || getTreeView() == null) return;

        FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getTreeView().getFocusModel();
        if (fm == null) {
            setFocused(false);
            return;
        }

        setFocused(fm.isFocused(getIndex()));
    }

    private boolean updateEditingIndex = true;
    private void updateEditing() {
        final int index = getIndex();
        final TreeView&lt;T&gt; tree = getTreeView();
        final TreeItem&lt;T&gt; treeItem = getTreeItem();
        final TreeItem&lt;T&gt; editItem = tree == null ? null : tree.getEditingItem();
        final boolean editing = isEditing();

        if (index == -1 || tree == null || treeItem == null) return;

        final boolean match = treeItem.equals(editItem);

        // If my tree item is the item being edited and I'm not currently in
        // the edit mode, then I need to enter the edit mode
        if (match &amp;&amp; !editing) {
            startEdit();
        } else if (! match &amp;&amp; editing) {
            // If my tree item is not the one being edited then I need to cancel
            // the edit. The tricky thing here is that as part of this call
            // I cannot end up calling tree.edit(null) the way that the standard
            // cancelEdit method would do. Yet, I need to call cancelEdit
            // so that subclasses which override cancelEdit can execute. So,
            // I have to use a kind of hacky flag workaround.
            updateEditingIndex = false;
            cancelEdit();
            updateEditingIndex = true;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Expert API                                                              *
     *                                                                         *
     **************************************************************************/



    /**
     * Updates the TreeView associated with this TreeCell.
     *
     * @param tree The new TreeView that should be associated with this TreeCell.
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     */
    public final void updateTreeView(TreeView&lt;T&gt; tree) {
        setTreeView(tree);
    }

    /**
     * Updates the TreeItem associated with this TreeCell.
     *
     * @param treeItem The new TreeItem that should be associated with this
     *      TreeCell.
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     */
    public final void updateTreeItem(TreeItem&lt;T&gt; treeItem) {
        TreeItem&lt;T&gt; _treeItem = getTreeItem();
        if (_treeItem != null) {
            _treeItem.leafProperty().removeListener(weakLeafListener);
        }
        setTreeItem(treeItem);
        if (treeItem != null) {
            treeItem.leafProperty().addListener(weakLeafListener);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;tree-cell&quot;;

    private static final PseudoClass EXPANDED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;expanded&quot;);
    private static final PseudoClass COLLAPSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;collapsed&quot;);


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        TreeItem&lt;T&gt; treeItem = getTreeItem();
        TreeView&lt;T&gt; treeView = getTreeView();
        switch (attribute) {
            case TREE_ITEM_PARENT: {
                if (treeView == null) return null;
                if (treeItem == null) return null;
                TreeItem&lt;T&gt; parent = treeItem.getParent();
                if (parent == null) return null;
                int parentIndex = treeView.getRow(parent);
                return treeView.queryAccessibleAttribute(AccessibleAttribute.ROW_AT_INDEX, parentIndex);
            }
            case TREE_ITEM_COUNT: {
                if (treeItem == null) return 0;
                if (!treeItem.isExpanded()) return 0;
                return treeItem.getChildren().size();
            }
            case TREE_ITEM_AT_INDEX: {
                if (treeItem == null) return null;
                if (!treeItem.isExpanded()) return null;
                int index = (Integer)parameters[0];
                if (index &gt;= treeItem.getChildren().size()) return null;
                TreeItem&lt;T&gt; child = treeItem.getChildren().get(index);
                if (child == null) return null;
                int childIndex = treeView.getRow(child);
                return treeView.queryAccessibleAttribute(AccessibleAttribute.ROW_AT_INDEX, childIndex);
            }
            case LEAF: return treeItem == null ? true : treeItem.isLeaf();
            case EXPANDED: return treeItem == null ? false : treeItem.isExpanded();
            case INDEX: return getIndex();
            case SELECTED: return isSelected();
            case DISCLOSURE_LEVEL: {
                return treeView == null ? 0 : treeView.getTreeItemLevel(treeItem);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case EXPAND: {
                TreeItem&lt;T&gt; treeItem = getTreeItem();
                if (treeItem != null) treeItem.setExpanded(true);
                break;
            }
            case COLLAPSE: {
                TreeItem&lt;T&gt; treeItem = getTreeItem();
                if (treeItem != null) treeItem.setExpanded(false);
                break;
            }
            case REQUEST_FOCUS: {
                TreeView&lt;T&gt; treeView = getTreeView();
                if (treeView != null) {
                    FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = treeView.getFocusModel();
                    if (fm != null) {
                        fm.focus(getIndex());
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TreeTableCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.css.PseudoClass;
import javafx.scene.control.skin.TreeTableCellSkin;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.event.Event;

import javafx.collections.WeakListChangeListener;
import java.lang.ref.WeakReference;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;

import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.control.TreeTableColumn.CellEditEvent;
import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;


/**
 * Represents a single row/column intersection in a {@link TreeTableView}. To
 * represent this intersection, a TreeTableCell contains an
 * {@link #indexProperty() index} property, as well as a
 * {@link #tableColumnProperty() tableColumn} property. In addition, a TreeTableCell
 * instance knows what {@link TreeTableRow} it exists in.
 *
 * &lt;p&gt;&lt;strong&gt;A note about selection:&lt;/strong&gt; A TreeTableCell visually shows it is
 * selected when two conditions are met:
 * &lt;ol&gt;
 *   &lt;li&gt;The {@link TableSelectionModel#isSelected(int, TableColumnBase)} method
 *   returns true for the row / column that this cell represents, and&lt;/li&gt;
 *   &lt;li&gt;The {@link javafx.scene.control.TableSelectionModel#cellSelectionEnabledProperty() cell selection mode}
 *   property is set to true (to represent that it is allowable to select
 *   individual cells (and not just rows of cells)).&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @param &lt;S&gt; The type of the TreeTableView generic type
 * @see TreeTableView
 * @see TreeTableColumn
 * @see Cell
 * @see IndexedCell
 * @see TreeTableRow
 * @param &lt;T&gt; The type of the item contained within the Cell.
 * @since JavaFX 8.0
 */
public class TreeTableCell&lt;S,T&gt; extends IndexedCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Constructs a default TreeTableCell instance with a style class of
     * 'tree-table-cell'.
     */
    public TreeTableCell() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TREE_TABLE_CELL);

        updateColumnIndex();
    }



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    // package for testing
    boolean lockItemOnEdit = false;



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private boolean itemDirty = false;

    /*
     * This is the list observer we use to keep an eye on the SelectedCells
     * ObservableList in the tree table view. Because it is possible that the table can
     * be mutated, we create this observer here, and add/remove it from the
     * storeTableView method.
     */
    private ListChangeListener&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedListener = c -&gt; {
        while (c.next()) {
            if (c.wasAdded() || c.wasRemoved()) {
                updateSelection();
            }
        }
    };

    // same as above, but for focus
    private final InvalidationListener focusedListener = value -&gt; {
        updateFocus();
    };

    // same as above, but for for changes to the properties on TableRow
    private final InvalidationListener tableRowUpdateObserver = value -&gt; {
        itemDirty = true;
        requestLayout();
    };

    private final InvalidationListener editingListener = value -&gt; {
        updateEditing();
    };

    private ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
        updateColumnIndex();
    };

    private ListChangeListener&lt;String&gt; columnStyleClassListener = c -&gt; {
        while (c.next()) {
            if (c.wasRemoved()) {
                getStyleClass().removeAll(c.getRemoved());
            }

            if (c.wasAdded()) {
                getStyleClass().addAll(c.getAddedSubList());
            }
        }
    };

    private final InvalidationListener rootPropertyListener = observable -&gt; {
        updateItem(-1);
    };

    private final InvalidationListener columnStyleListener = value -&gt; {
        if (getTableColumn() != null) {
            possiblySetStyle(getTableColumn().getStyle());
        }
    };

    private final InvalidationListener columnIdListener = value -&gt; {
        if (getTableColumn() != null) {
            possiblySetId(getTableColumn().getId());
        }
    };

    private final WeakListChangeListener&lt;TreeTablePosition&lt;S,?&gt;&gt; weakSelectedListener =
            new WeakListChangeListener&lt;TreeTablePosition&lt;S,?&gt;&gt;(selectedListener);
    private final WeakInvalidationListener weakFocusedListener =
            new WeakInvalidationListener(focusedListener);
    private final WeakInvalidationListener weaktableRowUpdateObserver =
            new WeakInvalidationListener(tableRowUpdateObserver);
    private final WeakInvalidationListener weakEditingListener =
            new WeakInvalidationListener(editingListener);
    private final WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; weakVisibleLeafColumnsListener =
            new WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;(visibleLeafColumnsListener);
    private final WeakListChangeListener&lt;String&gt; weakColumnStyleClassListener =
            new WeakListChangeListener&lt;String&gt;(columnStyleClassListener);
    private final WeakInvalidationListener weakColumnStyleListener =
            new WeakInvalidationListener(columnStyleListener);
    private final WeakInvalidationListener weakColumnIdListener =
            new WeakInvalidationListener(columnIdListener);
    private final WeakInvalidationListener weakRootPropertyListener =
            new WeakInvalidationListener(rootPropertyListener);


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- TableColumn
    /**
     * The TreeTableColumn instance that backs this TreeTableCell.
     */
    private ReadOnlyObjectWrapper&lt;TreeTableColumn&lt;S,T&gt;&gt; treeTableColumn =
            new ReadOnlyObjectWrapper&lt;TreeTableColumn&lt;S,T&gt;&gt;(this, &quot;treeTableColumn&quot;) {
        @Override protected void invalidated() {
            updateColumnIndex();
        }
    };
    public final ReadOnlyObjectProperty&lt;TreeTableColumn&lt;S,T&gt;&gt; tableColumnProperty() { return treeTableColumn.getReadOnlyProperty(); }
    private void setTableColumn(TreeTableColumn&lt;S,T&gt; value) { treeTableColumn.set(value); }
    public final TreeTableColumn&lt;S,T&gt; getTableColumn() { return treeTableColumn.get(); }


    // --- TableView
    /**
     * The TreeTableView associated with this TreeTableCell.
     */
    private ReadOnlyObjectWrapper&lt;TreeTableView&lt;S&gt;&gt; treeTableView;
    private void setTreeTableView(TreeTableView&lt;S&gt; value) {
        treeTableViewPropertyImpl().set(value);
    }
    public final TreeTableView&lt;S&gt; getTreeTableView() {
        return treeTableView == null ? null : treeTableView.get();
    }
    public final ReadOnlyObjectProperty&lt;TreeTableView&lt;S&gt;&gt; treeTableViewProperty() {
        return treeTableViewPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TreeTableView&lt;S&gt;&gt; treeTableViewPropertyImpl() {
        if (treeTableView == null) {
            treeTableView = new ReadOnlyObjectWrapper&lt;TreeTableView&lt;S&gt;&gt;(this, &quot;treeTableView&quot;) {
                private WeakReference&lt;TreeTableView&lt;S&gt;&gt; weakTableViewRef;
                @Override protected void invalidated() {
                    TreeTableView.TreeTableViewSelectionModel&lt;S&gt; sm;
                    TreeTableView.TreeTableViewFocusModel&lt;S&gt; fm;

                    if (weakTableViewRef != null) {
                        TreeTableView&lt;S&gt; oldTableView = weakTableViewRef.get();
                        if (oldTableView != null) {
                            sm = oldTableView.getSelectionModel();
                            if (sm != null) {
                                sm.getSelectedCells().removeListener(weakSelectedListener);
                            }

                            fm = oldTableView.getFocusModel();
                            if (fm != null) {
                                fm.focusedCellProperty().removeListener(weakFocusedListener);
                            }

                            oldTableView.editingCellProperty().removeListener(weakEditingListener);
                            oldTableView.getVisibleLeafColumns().removeListener(weakVisibleLeafColumnsListener);
                            oldTableView.rootProperty().removeListener(weakRootPropertyListener);
                        }
                    }

                    TreeTableView&lt;S&gt; newTreeTableView = get();
                    if (newTreeTableView != null) {
                        sm = newTreeTableView.getSelectionModel();
                        if (sm != null) {
                            sm.getSelectedCells().addListener(weakSelectedListener);
                        }

                        fm = newTreeTableView.getFocusModel();
                        if (fm != null) {
                            fm.focusedCellProperty().addListener(weakFocusedListener);
                        }

                        newTreeTableView.editingCellProperty().addListener(weakEditingListener);
                        newTreeTableView.getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);
                        newTreeTableView.rootProperty().addListener(weakRootPropertyListener);

                        weakTableViewRef = new WeakReference&lt;TreeTableView&lt;S&gt;&gt;(newTreeTableView);
                    }

                    updateColumnIndex();
                }
            };
        }
        return treeTableView;
    }


    // --- TableRow
    /**
     * The TreeTableRow that this TreeTableCell currently finds itself placed within.
     */
    private ReadOnlyObjectWrapper&lt;TreeTableRow&lt;S&gt;&gt; treeTableRow =
            new ReadOnlyObjectWrapper&lt;TreeTableRow&lt;S&gt;&gt;(this, &quot;treeTableRow&quot;);
    private void setTreeTableRow(TreeTableRow&lt;S&gt; value) { treeTableRow.set(value); }
    public final TreeTableRow&lt;S&gt; getTreeTableRow() { return treeTableRow.get(); }
    public final ReadOnlyObjectProperty&lt;TreeTableRow&lt;S&gt;&gt; tableRowProperty() { return treeTableRow;  }



    /***************************************************************************
     *                                                                         *
     * Editing API                                                             *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void startEdit() {
        if (isEditing()) return;

        final TreeTableView&lt;S&gt; table = getTreeTableView();
        final TreeTableColumn&lt;S,T&gt; column = getTableColumn();
        if (! isEditable() ||
                (table != null &amp;&amp; ! table.isEditable()) ||
                (column != null &amp;&amp; ! getTableColumn().isEditable())) {
            return;
        }

        // We check the boolean lockItemOnEdit field here, as whilst we want to
        // updateItem normally, when it comes to unit tests we can't have the
        // item change in all circumstances.
        if (! lockItemOnEdit) {
            updateItem(-1);
        }

        // it makes sense to get the cell into its editing state before firing
        // the event to listeners below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

<A NAME="27"></A>        if (column != null) {
            CellEditEvent editEvent = new CellEditEvent(
                table,
                <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#27',2,'match36-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>table.getEditingCell(),
                TreeTableColumn.&lt;S,T&gt;editStartEvent(),
                null
            );

            Event.fireEvent(column, editEvent);
        }
    }

    /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing</B></FONT>()) return;

        final TreeTableView&lt;S&gt; table = getTreeTableView();
        if (table != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            TreeTablePosition&lt;S,T&gt; editingCell = (TreeTablePosition&lt;S,T&gt;) table.getEditingCell();

            // Inform the TableView of the edit being ready to be committed.
            CellEditEvent&lt;S,T&gt; editEvent = new CellEditEvent&lt;S,T&gt;(
                table,
                editingCell,
                TreeTableColumn.&lt;S,T&gt;editCommitEvent(),
                newValue
            );

            Event.fireEvent(getTableColumn(), editEvent);
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state.
        // This MUST come before the updateItem call below, otherwise it will
        // call cancelEdit(), resulting in both commit and cancel events being
        // fired (as identified in RT-29650)
        super.commitEdit(newValue);

        // update the item within this cell, so that it represents the new value
        updateItem(newValue, false);

        if (table != null) {
            // reset the editing cell on the TableView
            table.edit(-1, null);

            // request focus back onto the table, only if the current focus
            // owner has the table as a parent (otherwise the user might have
            // clicked out of the table entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(table);
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

        final TreeTableView&lt;S&gt; table = getTreeTableView();

        super.cancelEdit();

        // reset the editing index on the TableView
        if (table != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            TreeTablePosition&lt;S,T&gt; editingCell = (TreeTablePosition&lt;S,T&gt;) table.getEditingCell();

            if (updateEditingIndex) table.edit(-1, null);

            // request focus back onto the table, only if the current focus
            // owner has the table as a parent (otherwise the user might have
            // clicked out of the table entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(table);

<A NAME="28"></A>            CellEditEvent&lt;S,T&gt; editEvent = new CellEditEvent&lt;S,T&gt;(
                table,
                editingCell,
                <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#28',2,'match36-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TreeTableColumn.&lt;S,T&gt;editCancelEvent(),
                null
            );

            Event.fireEvent(getTableColumn(), editEvent);
        }
    }



    /* *************************************************************************
     *                                                                         *
     * Overriding methods                                                      *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void updateSelected(boolean selected) {
        // copied from Cell, with the first conditional clause below commented
        // out, as it is valid for an empty TableCell to be selected, as long
        // as the parent TableRow is not empty (see RT-15529).
        /*if (selected &amp;&amp; isEmpty()) return;*/
        if (getTreeTableRow</B></FONT>() == null || getTreeTableRow().isEmpty()) return;
        setSelected(selected);
    }



    /* *************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void indexChanged(int oldIndex, int newIndex) {
        super.indexChanged(oldIndex, newIndex);

        if (isEditing() &amp;&amp; newIndex == oldIndex) {
            // no-op
            // Fix for RT-31165 - if we (needlessly) update the index whilst the
            // cell is being edited it will no longer be in an editing state.
            // This means that in certain (common) circumstances that it will
            // appear that a cell is uneditable as, despite being clicked, it
            // will not change to the editing state as a layout of VirtualFlow
            // is immediately invoked, which forces all cells to be updated.
        } else {
            // Ideally we would just use the following two lines of code, rather
            // than the updateItem() call beneath, but if we do this we end up with
            // RT-22428 where all the columns are collapsed.
            // itemDirty = true;
            // requestLayout();
            updateItem(oldIndex);
            updateSelection();
            updateFocus();
            updateEditing();
        }
    }

    private boolean isLastVisibleColumn = false;
    private int columnIndex = -1;

    private void updateColumnIndex() {
        final TreeTableView&lt;S&gt; tv = getTreeTableView();
        TreeTableColumn&lt;S,T&gt; tc = getTableColumn();
        columnIndex = tv == null || tc == null ? -1 : tv.getVisibleLeafIndex(tc);

        // update the pseudo class state regarding whether this is the last
        // visible cell (i.e. the right-most).
        isLastVisibleColumn = getTableColumn() != null &amp;&amp;
                columnIndex != -1 &amp;&amp;
                columnIndex == tv.getVisibleLeafColumns().size() - 1;
        pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
    }

    private void updateSelection() {
        /*
         * This cell should be selected if the selection mode of the table
         * is cell-based, and if the row and column that this cell represents
         * is selected.
         *
         * If the selection mode is not cell-based, then the listener in the
         * TableRow class might pick up the need to set an entire row to be
         * selected.
         */
        if (isEmpty()) return;

        final boolean isSelected = isSelected();
        if (! isInCellSelectionMode()) {
            if (isSelected) {
                updateSelected(false);
            }
            return;
        }

        final TreeTableView&lt;S&gt; tv = getTreeTableView();
        if (getIndex() == -1 || tv == null) return;

        TreeTableView.TreeTableViewSelectionModel&lt;S&gt; sm = tv.getSelectionModel();
        if (sm == null) {
            updateSelected(false);
            return;
        }

        boolean isSelectedNow = sm.isSelected(getIndex(), getTableColumn());
        if (isSelected == isSelectedNow) return;

        updateSelected(isSelectedNow);
    }

    private void updateFocus() {
        final boolean isFocused = isFocused();
        if (! isInCellSelectionMode()) {
            if (isFocused) {
                setFocused(false);
            }
            return;
        }

        final TreeTableView&lt;S&gt; tv = getTreeTableView();
        if (getIndex() == -1 || tv == null) return;

        TreeTableView.TreeTableViewFocusModel&lt;S&gt; fm = tv.getFocusModel();
        if (fm == null) {
            setFocused(false);
            return;
        }

        setFocused(fm.isFocused(getIndex(), getTableColumn()));
    }

    private void updateEditing() {
        final TreeTableView&lt;S&gt; tv = getTreeTableView();
        if (getIndex() == -1 || tv == null) return;

        TreeTablePosition&lt;S,?&gt; editCell = tv.getEditingCell();
        boolean match = match(editCell);

        if (match &amp;&amp; ! isEditing()) {
            startEdit();
        } else if (! match &amp;&amp; isEditing()) {
            // If my index is not the one being edited then I need to cancel
            // the edit. The tricky thing here is that as part of this call
            // I cannot end up calling list.edit(-1) the way that the standard
            // cancelEdit method would do. Yet, I need to call cancelEdit
            // so that subclasses which override cancelEdit can execute. So,
            // I have to use a kind of hacky flag workaround.
            updateEditingIndex = false;
            cancelEdit();
            updateEditingIndex = true;
        }
    }
    private boolean updateEditingIndex = true;

    private boolean match(TreeTablePosition pos) {
        return pos != null &amp;&amp; pos.getRow() == getIndex() &amp;&amp; pos.getTableColumn() == getTableColumn();
    }

    private boolean isInCellSelectionMode() {
        TreeTableView&lt;S&gt; tv = getTreeTableView();
        if (tv == null) return false;
        TreeTableView.TreeTableViewSelectionModel&lt;S&gt; sm = tv.getSelectionModel();
        return sm != null &amp;&amp; sm.isCellSelectionEnabled();
    }

    /*
     * This was brought in to fix the issue in RT-22077, namely that the
     * ObservableValue was being GC'd, meaning that changes to the value were
     * no longer being delivered. By extracting this value out of the method,
     * it is now referred to from TableCell and will therefore no longer be
     * GC'd.
     */
    private ObservableValue&lt;T&gt; currentObservableValue = null;

    private boolean isFirstRun = true;

    private WeakReference&lt;S&gt; oldRowItemRef;

    /*
     * This is called when we think that the data within this TreeTableCell may have
     * changed. You'll note that this is a private function - it is only called
     * when one of the triggers above call it.
     */
    private void updateItem(int oldIndex) {
        if (currentObservableValue != null) {
            currentObservableValue.removeListener(weaktableRowUpdateObserver);
        }

        // get the total number of items in the data model
        final TreeTableView&lt;S&gt; tableView = getTreeTableView();
        final TreeTableColumn&lt;S,T&gt; tableColumn = getTableColumn();
        final int itemCount = tableView == null ? -1 : getTreeTableView().getExpandedItemCount();
        final int index = getIndex();
        final boolean isEmpty = isEmpty();
        final T oldValue = getItem();

        final TreeTableRow&lt;S&gt; tableRow = getTreeTableRow();
        final S rowItem = tableRow == null ? null : tableRow.getItem();

        final boolean indexExceedsItemCount = index &gt;= itemCount;

        // there is a whole heap of reasons why we should just punt...
        outer: if (indexExceedsItemCount ||
                index &lt; 0 ||
                columnIndex &lt; 0 ||
                !isVisible() ||
                tableColumn == null ||
                !tableColumn.isVisible() ||
                tableView.getRoot() == null) {

            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            // RT-32621: There are circumstances where we need to updateItem,
            // even when the index is greater than the itemCount. For example,
            // RT-32621 identifies issues where a TreeTableView collapses a
            // TreeItem but the custom cells remain visible. This is now
            // resolved with the check for indexExceedsItemCount.
            if ((!isEmpty &amp;&amp; oldValue != null) || isFirstRun || indexExceedsItemCount) {
                updateItem(null, true);
                isFirstRun = false;
            }
            return;
        } else {
            currentObservableValue = tableColumn.getCellObservableValue(index);

            final T newValue = currentObservableValue == null ? null : currentObservableValue.getValue();

            // RT-35864 - if the index didn't change, then avoid calling updateItem
            // unless the item has changed.
            if (oldIndex == index) {
                if (!isItemChanged(oldValue, newValue)) {
                    // RT-36670: we need to check the row item here to prevent
                    // the issue where the cell value and index doesn't change,
                    // but the backing row object does.
                    S oldRowItem = oldRowItemRef != null ? oldRowItemRef.get() : null;
                    if (oldRowItem != null &amp;&amp; oldRowItem.equals(rowItem)) {
                        // RT-37054:  we break out of the if/else code here and
                        // proceed with the code following this, so that we may
                        // still update references, listeners, etc as required.
                        break outer;
                    }
                }
            }
            updateItem(newValue, false);
        }

        oldRowItemRef = new WeakReference&lt;&gt;(rowItem);

        if (currentObservableValue == null) {
            return;
        }

        // add property change listeners to this item
        currentObservableValue.addListener(weaktableRowUpdateObserver);
    }

    @Override protected void layoutChildren() {
        if (itemDirty) {
            updateItem(-1);
            itemDirty = false;
        }
        super.layoutChildren();
    }




    /***************************************************************************
     *                                                                         *
     *                              Expert API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Updates the TreeTableView associated with this TreeTableCell. This is typically
     * only done once when the TreeTableCell is first added to the TreeTableView.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param tv the TreeTableView associated with this TreeTableCell
     */
    public final void updateTreeTableView(TreeTableView&lt;S&gt; tv) {
        setTreeTableView(tv);
    }

    /**
     * Updates the TreeTableRow associated with this TreeTableCell.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param treeTableRow the TreeTableRow associated with this TreeTableCell
     */
    public final void updateTreeTableRow(TreeTableRow&lt;S&gt; treeTableRow) {
        this.setTreeTableRow(treeTableRow);
    }

    /**
     * Updates the TreeTableColumn associated with this TreeTableCell.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param col the TreeTableColumn associated with this TreeTableCell
     */
    public final void updateTreeTableColumn(TreeTableColumn&lt;S,T&gt; col) {
        // remove style class of existing tree table column, if it is non-null
        TreeTableColumn&lt;S,T&gt; oldCol = getTableColumn();
        if (oldCol != null) {
            oldCol.getStyleClass().removeListener(weakColumnStyleClassListener);
            getStyleClass().removeAll(oldCol.getStyleClass());

            oldCol.idProperty().removeListener(weakColumnIdListener);
            oldCol.styleProperty().removeListener(weakColumnStyleListener);

            String id = getId();
            String style = getStyle();
            if (id != null &amp;&amp; id.equals(oldCol.getId())) {
                setId(null);
            }
            if (style != null &amp;&amp; style.equals(oldCol.getStyle())) {
                setStyle(&quot;&quot;);
            }
        }

        setTableColumn(col);

        if (col != null) {
            getStyleClass().addAll(col.getStyleClass());
            col.getStyleClass().addListener(weakColumnStyleClassListener);

            col.idProperty().addListener(weakColumnIdListener);
            col.styleProperty().addListener(weakColumnStyleListener);

            possiblySetId(col.getId());
            possiblySetStyle(col.getStyle());
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-cell&quot;;
    private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
            PseudoClass.getPseudoClass(&quot;last-visible&quot;);

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TreeTableCellSkin&lt;S,T&gt;(this);
    }

    private void possiblySetId(String idCandidate) {
        if (getId() == null || getId().isEmpty()) {
            setId(idCandidate);
        }
    }

    private void possiblySetStyle(String styleCandidate) {
        if (getStyle() == null || getStyle().isEmpty()) {
            setStyle(styleCandidate);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROW_INDEX: return getIndex();
            case COLUMN_INDEX: return columnIndex;
            case SELECTED: return isInCellSelectionMode() ? isSelected() : getTreeTableRow().isSelected();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS: {
                TreeTableView&lt;S&gt; treeTableView = getTreeTableView();
                if (treeTableView != null) {
                    TreeTableViewFocusModel&lt;S&gt; fm = treeTableView.getFocusModel();
                    if (fm != null) {
                        fm.focus(getIndex(), getTableColumn());
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TreeTableColumn.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.Properties;
import javafx.css.CssMetaData;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.scene.Node;
import javafx.scene.control.skin.*;
import javafx.util.Callback;
import javafx.css.Styleable;

/**
 * A {@link TreeTableView} is made up of a number of TreeTableColumn instances. Each
 * TreeTableColumn in a {@link TreeTableView} is responsible for displaying
 * (and editing) the contents of that column. As well as being responsible for
 * displaying and editing data for a single column, a TreeTableColumn also
 * contains the necessary properties to:
 * &lt;ul&gt;
 *    &lt;li&gt;Be resized (using {@link #minWidthProperty() minWidth}/
 *    {@link #prefWidthProperty() prefWidth}/
 *    {@link #maxWidthProperty() maxWidth} and {@link #widthProperty() width} properties)
 *    &lt;li&gt;Have its {@link #visibleProperty() visibility} toggled
 *    &lt;li&gt;Display {@link #textProperty() header text}
 *    &lt;li&gt;Display any {@link #getColumns() nested columns} it may contain
 *    &lt;li&gt;Have a {@link #contextMenuProperty() context menu} when the user
 *      right-clicks the column header area
 *    &lt;li&gt;Have the contents of the table be sorted (using
 *      {@link #comparatorProperty() comparator}, {@link #sortableProperty() sortable} and
 *      {@link #sortTypeProperty() sortType})
 * &lt;/ul&gt;
 *
 * When creating a TreeTableColumn instance, perhaps the two most important properties
 * to set are the column {@link #textProperty() text} (what to show in the column
 * header area), and the column {@link #cellValueFactoryProperty() cell value factory}
 * (which is used to populate individual cells in the column). This can be
 * achieved using some variation on the following code:
 *
 * &lt;pre&gt;{@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 *         return p.getValue().getValue().firstNameProperty();
 *     }
 *  });
 * }}&lt;/pre&gt;
 *
 * This approach assumes that the object returned from &lt;code&gt;p.getValue().getValue()&lt;/code&gt;
 * has a JavaFX {@link ObservableValue} that can simply be returned. The benefit of this
 * is that the TableView will internally create bindings to ensure that,
 * should the returned {@link ObservableValue} change, the cell contents will be
 * automatically refreshed.
 *
 * &lt;p&gt;In situations where a TableColumn must interact with classes created before
 * JavaFX, or that generally do not wish to use JavaFX APIs for properties, it is
 * possible to wrap the returned value in a {@link ReadOnlyObjectWrapper} instance. For
 * example:
 *
 *&lt;pre&gt;{@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 *         return new ReadOnlyObjectWrapper(p.getValue().getValue().getFirstName());
 *     }
 *  });
 * }}&lt;/pre&gt;
 *
 * It is hoped that over time there will be convenience cell value factories
 * developed and made available to developers. As of the JavaFX 2.0 release,
 * there is one such convenience class: {@link javafx.scene.control.cell.TreeItemPropertyValueFactory}.
 * This class removes the need to write the code above, instead relying on reflection to
 * look up a given property from a String. Refer to the
 * &lt;code&gt;TreeItemPropertyValueFactory&lt;/code&gt; class documentation for more information
 * on how to use this with a TableColumn.
 *
 * Finally, for more detail on how to use TableColumn, there is further documentation in
 * the {@link TableView} class documentation.
 *
 * @param &lt;S&gt; The type of the TableView generic type (i.e. S == TableView&amp;lt;S&amp;gt;)
 * @param &lt;T&gt; The type of the content in all cells in this TableColumn.
 * @see TableView
 * @see TableCell
 * @see TablePosition
 * @see javafx.scene.control.cell.TreeItemPropertyValueFactory
 * @since JavaFX 8.0
 */
public class TreeTableColumn&lt;S,T&gt; extends TableColumnBase&lt;TreeItem&lt;S&gt;,T&gt; implements EventTarget {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Parent event for any TreeTableColumn edit event.
     * @param &lt;S&gt; the type of the TreeTableView generic type
     * @param &lt;T&gt; the type of the content in all cells in this TreeTableColumn
     * @return the edit event
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S,T&gt; EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; editAnyEvent() {
        return (EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;) EDIT_ANY_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
            new EventType&lt;&gt;(Event.ANY, &quot;TREE_TABLE_COLUMN_EDIT&quot;);

    /**
     * Indicates that the user has performed some interaction to start an edit
     * event, or alternatively the
     * {@link TreeTableView#edit(int, javafx.scene.control.TreeTableColumn)}
     * method has been called.
     * @param &lt;S&gt; the type of the TreeTableView generic type
     * @param &lt;T&gt; the type of the content in all cells in this TreeTableColumn
     * @return the edit start event
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S,T&gt; EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; editStartEvent() {
        return (EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;) EDIT_START_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_START_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);

    /**
     * Indicates that the editing has been canceled, meaning that no change should
     * be made to the backing data source.
     * @param &lt;S&gt; the type of the TreeTableView generic type
     * @param &lt;T&gt; the type of the content in all cells in this TreeTableColumn
     * @return the edit cancel event
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S,T&gt; EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; editCancelEvent() {
        return (EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;) EDIT_CANCEL_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);

    /**
     * Indicates that the editing has been committed by the user, meaning that
     * a change should be made to the backing data source to reflect the new
     * data.
     * @param &lt;S&gt; the type of the TreeTableView generic type
     * @param &lt;T&gt; the type of the content in all cells in this TreeTableColumn
     * @return the edit commit event
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S,T&gt; EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; editCommitEvent() {
        return (EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;) EDIT_COMMIT_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);



    /**
     * If no cellFactory is specified on a TreeTableColumn instance, then this one
     * will be used by default. At present it simply renders the TableCell item
     * property within the {@link TableCell#graphicProperty() graphic} property
     * if the {@link Cell#itemProperty() item} is a Node, or it simply calls
     * &lt;code&gt;toString()&lt;/code&gt; if it is not null, setting the resulting string
     * inside the {@link Cell#textProperty() text} property.
     */
    public static final Callback&lt;TreeTableColumn&lt;?,?&gt;, TreeTableCell&lt;?,?&gt;&gt; DEFAULT_CELL_FACTORY =
            new Callback&lt;TreeTableColumn&lt;?,?&gt;, TreeTableCell&lt;?,?&gt;&gt;() {
        @Override public TreeTableCell&lt;?,?&gt; call(TreeTableColumn&lt;?,?&gt; param) {
            return new TreeTableCell() {
                @Override protected void updateItem(Object item, boolean empty) {
                    if (item == getItem()) return;

                    super.updateItem(item, empty);

                    if (item == null) {
                        super.setText(null);
                        super.setGraphic(null);
                    } else if (item instanceof Node) {
                        super.setText(null);
                        super.setGraphic((Node)item);
                    } else {
                        super.setText(item.toString());
                        super.setGraphic(null);
                    }
                }
            };
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TreeTableColumn with default cell factory, comparator, and
     * onEditCommit implementation.
     */
    public TreeTableColumn() {
        getStyleClass().add(DEFAULT_STYLE_CLASS);

        setOnEditCommit(DEFAULT_EDIT_COMMIT_HANDLER);

        // we listen to the columns list here to ensure that widths are
        // maintained properly, and to also set the column hierarchy such that
        // all children columns know that this TreeTableColumn is their parent.
        getColumns().addListener(weakColumnsListener);

        treeTableViewProperty().addListener(observable -&gt; {
            // set all children of this tableView to have the same TableView
            // as this column
            for (TreeTableColumn&lt;S, ?&gt; tc : getColumns()) {
                tc.setTreeTableView(getTreeTableView());
            }

            // This code was commented out due to RT-22391, with this enabled
            // the parent column will be null, which is not desired
//                // set the parent of this column to also have this tableView
//                if (getParentColumn() != null) {
//                    getParentColumn().setTableView(getTableView());
//                }
        });
    }

    /**
     * Creates a TreeTableColumn with the text set to the provided string, with
     * default cell factory, comparator, and onEditCommit implementation.
     *
     * @param text The string to show when the TreeTableColumn is placed within
     *      the TreeTableView.
     */
    public TreeTableColumn(String text) {
        this();
        setText(text);
    }



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
<A NAME="4"></A>     **************************************************************************/

    private EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; DEFAULT_EDIT_COMMIT_HANDLER =
            <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#4',2,'match36-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>t -&gt; {
                ObservableValue&lt;T&gt; ov = getCellObservableValue(t.getRowValue());
                if (ov instanceof WritableValue) {
                    ((WritableValue)ov).setValue(t.getNewValue</B></FONT>());
                }
            };

    private ListChangeListener&lt;TreeTableColumn&lt;S, ?&gt;&gt; columnsListener = new ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;() {
        @Override public void onChanged(ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S,?&gt;&gt; c) {
            while (c.next()) {
                // update the TreeTableColumn.treeTableView property
                for (TreeTableColumn&lt;S,?&gt; tc : c.getRemoved()) {
                    // Fix for RT-16978. In TableColumnHeader we add before we
                    // remove when moving a TreeTableColumn. This means that for
                    // a very brief moment the tc is duplicated, and we can prevent
                    // nulling out the tableview and parent column. Without this
                    // here, in a very special circumstance it is possible to null
                    // out the entire content of a column by reordering and then
                    // sorting another column.
                    if (getColumns().contains(tc)) continue;

                    tc.setTreeTableView(null);
                    tc.setParentColumn(null);
                }
                for (TreeTableColumn&lt;S,?&gt; tc : c.getAddedSubList()) {
                    tc.setTreeTableView(getTreeTableView());
                }

                updateColumnWidths();
            }
        }
    };

    private WeakListChangeListener&lt;TreeTableColumn&lt;S, ?&gt;&gt; weakColumnsListener =
            new WeakListChangeListener&lt;&gt;(columnsListener);


    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // Contains any children columns that should be nested within this column
    private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = FXCollections.&lt;TreeTableColumn&lt;S,?&gt;&gt;observableArrayList();



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/


    // --- TreeTableView
    /**
     * The TreeTableView that this TreeTableColumn belongs to.
     */
    private ReadOnlyObjectWrapper&lt;TreeTableView&lt;S&gt;&gt; treeTableView =
            new ReadOnlyObjectWrapper&lt;TreeTableView&lt;S&gt;&gt;(this, &quot;treeTableView&quot;);
    public final ReadOnlyObjectProperty&lt;TreeTableView&lt;S&gt;&gt; treeTableViewProperty() {
        return treeTableView.getReadOnlyProperty();
    }
    final void setTreeTableView(TreeTableView&lt;S&gt; value) { treeTableView.set(value); }
    public final TreeTableView&lt;S&gt; getTreeTableView() { return treeTableView.get(); }



    // --- Cell value factory
    /**
     * The cell value factory needs to be set to specify how to populate all
     * cells within a single TreeTableColumn. A cell value factory is a {@link Callback}
     * that provides a {@link CellDataFeatures} instance, and expects an
     * {@link ObservableValue} to be returned. The returned ObservableValue instance
     * will be observed internally to allow for updates to the value to be
     * immediately reflected on screen.
     *
     * &lt;p&gt;An example of how to set a cell value factory is:
     *
     * &lt;pre&gt;{@code
     * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
     *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
     *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
     *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
     *         return p.getValue().getValue().firstNameProperty();
     *     }
     *  });
     * }}&lt;/pre&gt;
     *
     * A common approach is to want to populate cells in a TreeTableColumn using
     * a single value from a Java bean. To support this common scenario, there
     * is the {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} class.
     * Refer to this class for more information on how to use it, but briefly
     * here is how the above use case could be simplified using the TreeItemPropertyValueFactory class:
     *
     * &lt;pre&gt;&lt;code&gt;
     * firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&amp;lt;Person,String&amp;gt;(&quot;firstName&quot;));
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @see javafx.scene.control.cell.TreeItemPropertyValueFactory
     */
    private ObjectProperty&lt;Callback&lt;TreeTableColumn.CellDataFeatures&lt;S,T&gt;, ObservableValue&lt;T&gt;&gt;&gt; cellValueFactory;
    public final void setCellValueFactory(Callback&lt;TreeTableColumn.CellDataFeatures&lt;S,T&gt;, ObservableValue&lt;T&gt;&gt; value) {
        cellValueFactoryProperty().set(value);
    }
    public final Callback&lt;TreeTableColumn.CellDataFeatures&lt;S,T&gt;, ObservableValue&lt;T&gt;&gt; getCellValueFactory() {
        return cellValueFactory == null ? null : cellValueFactory.get();
    }
    public final ObjectProperty&lt;Callback&lt;TreeTableColumn.CellDataFeatures&lt;S,T&gt;, ObservableValue&lt;T&gt;&gt;&gt; cellValueFactoryProperty() {
        if (cellValueFactory == null) {
            cellValueFactory = new SimpleObjectProperty&lt;Callback&lt;TreeTableColumn.CellDataFeatures&lt;S,T&gt;, ObservableValue&lt;T&gt;&gt;&gt;(this, &quot;cellValueFactory&quot;);
        }
        return cellValueFactory;
    }


    // --- Cell Factory
    /**
     * The cell factory for all cells in this column. The cell factory
     * is responsible for rendering the data contained within each TreeTableCell
     * for a single TreeTableColumn.
     *
     * &lt;p&gt;By default TreeTableColumn uses a {@link #DEFAULT_CELL_FACTORY default cell
     * factory}, but this can be replaced with a custom implementation, for
     * example to show data in a different way or to support editing. There is a
     * lot of documentation on creating custom cell factories
     * elsewhere (see {@link Cell} and {@link TreeTableView} for example).&lt;/p&gt;
     *
     * &lt;p&gt;Finally, there are a number of pre-built cell factories available in the
     * {@link javafx.scene.control.cell} package.
     *
     */
    private final ObjectProperty&lt;Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt;&gt; cellFactory =
        new SimpleObjectProperty&lt;Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt;&gt;(
            this, &quot;cellFactory&quot;, (Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt;) ((Callback) DEFAULT_CELL_FACTORY)) {
                @Override protected void invalidated() {
                    TreeTableView&lt;S&gt; table = getTreeTableView();
                    if (table == null) return;
                    Map&lt;Object,Object&gt; properties = table.getProperties();
                    if (properties.containsKey(Properties.RECREATE)) {
                        properties.remove(Properties.RECREATE);
                    }
                    properties.put(Properties.RECREATE, Boolean.TRUE);
                }
            };
    public final void setCellFactory(Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt; value) {
        cellFactory.set(value);
    }
    public final Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt; getCellFactory() {
        return cellFactory.get();
    }
    public final ObjectProperty&lt;Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt;&gt; cellFactoryProperty() {
        return cellFactory;
    }


    // --- Sort Type
    /**
     * Used to state whether this column, if it is part of a sort order (see
     * {@link TreeTableView#getSortOrder()} for more details), should be sorted
     * in ascending or descending order.
     * Simply toggling this property will result in the sort order changing in
     * the TreeTableView, assuming of course that this column is in the
     * sortOrder ObservableList to begin with.
     */
    private ObjectProperty&lt;SortType&gt; sortType;
    public final ObjectProperty&lt;SortType&gt; sortTypeProperty() {
        if (sortType == null) {
            sortType = new SimpleObjectProperty&lt;SortType&gt;(this, &quot;sortType&quot;, SortType.ASCENDING);
        }
        return sortType;
    }
    public final void setSortType(SortType value) {
        sortTypeProperty().set(value);
    }
    public final SortType getSortType() {
        return sortType == null ? SortType.ASCENDING : sortType.get();
    }


    // --- On Edit Start
    /**
     * This event handler will be fired when the user successfully initiates
     * editing.
     */
    private ObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt; onEditStart;
    public final void setOnEditStart(EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; value) {
        onEditStartProperty().set(value);
    }
    public final EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; getOnEditStart() {
        return onEditStart == null ? null : onEditStart.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt; onEditStartProperty() {
        if (onEditStart == null) {
            onEditStart = new SimpleObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt;(this, &quot;onEditStart&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(TreeTableColumn.&lt;S,T&gt;editStartEvent(), get());
                }
            };
        }
        return onEditStart;
    }


    // --- On Edit Commit
    /**
     * This event handler will be fired when the user successfully commits their
     * editing.
     */
    private ObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt; onEditCommit;
    public final void setOnEditCommit(EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; value) {
        onEditCommitProperty().set(value);
    }
    public final EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; getOnEditCommit() {
        return onEditCommit == null ? null : onEditCommit.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt; onEditCommitProperty() {
        if (onEditCommit == null) {
            onEditCommit = new SimpleObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt;(this, &quot;onEditCommit&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(TreeTableColumn.&lt;S,T&gt;editCommitEvent(), get());
                }
            };
        }
        return onEditCommit;
    }


    // --- On Edit Cancel
    /**
     * This event handler will be fired when the user cancels editing a cell.
     */
    private ObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt; onEditCancel;
    public final void setOnEditCancel(EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; value) {
        onEditCancelProperty().set(value);
    }
    public final EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; getOnEditCancel() {
        return onEditCancel == null ? null : onEditCancel.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt; onEditCancelProperty() {
        if (onEditCancel == null) {
            onEditCancel = new SimpleObjectProperty&lt;EventHandler&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt;&gt;(this, &quot;onEditCancel&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(TreeTableColumn.&lt;S,T&gt;editCancelEvent(), get());
                }
            };
        }
        return onEditCancel;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getColumns() {
        return columns;
    }

    /** {@inheritDoc} */
    @Override public final ObservableValue&lt;T&gt; getCellObservableValue(int index) {
        if (index &lt; 0) return null;

        // Get the table
        final TreeTableView&lt;S&gt; table = getTreeTableView();
        if (table == null || index &gt;= table.getExpandedItemCount()) return null;

        // Get the rowData
        TreeItem&lt;S&gt; item = table.getTreeItem(index);
        return getCellObservableValue(item);
    }

    /** {@inheritDoc} */
    @Override public final ObservableValue&lt;T&gt; getCellObservableValue(TreeItem&lt;S&gt; item) {
        // Get the factory
        final Callback&lt;TreeTableColumn.CellDataFeatures&lt;S,T&gt;, ObservableValue&lt;T&gt;&gt; factory = getCellValueFactory();
        if (factory == null) return null;

        // Get the table
        final TreeTableView&lt;S&gt; table = getTreeTableView();
        if (table == null) return null;

        // Call the factory
        final TreeTableColumn.CellDataFeatures&lt;S,T&gt; cdf = new TreeTableColumn.CellDataFeatures&lt;S,T&gt;(table, this, item);
        return factory.call(cdf);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;table-column&quot;;

    /**
     * {@inheritDoc}
     * @return &quot;TreeTableColumn&quot;
     */
    @Override public String getTypeSelector() {
        return &quot;TreeTableColumn&quot;;
    }

    /**
     * {@inheritDoc}
     * @return {@code getTreeTableView()}
     */
    @Override public Styleable getStyleableParent() {
        return getTreeTableView();
    }

    /**
     * {@inheritDoc}
    */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return Collections.emptyList();
    }

    /** {@inheritDoc} */
    @Override public Node getStyleableNode() {
        if (! (getTreeTableView().getSkin() instanceof TreeTableViewSkin)) return null;
        TreeTableViewSkin&lt;?&gt; skin = (TreeTableViewSkin&lt;?&gt;) getTreeTableView().getSkin();

        TableHeaderRow tableHeader = null;
        for (Node n : skin.getChildren()) {
            if (n instanceof TableHeaderRow) {
                tableHeader = (TableHeaderRow)n;
            }
        }

        NestedTableColumnHeader rootHeader = null;
        for (Node n : tableHeader.getChildren()) {
            if (n instanceof NestedTableColumnHeader) {
                rootHeader = (NestedTableColumnHeader) n;
            }
        }

        // we now need to do a search for the header. We'll go depth-first.
        return scan(rootHeader);
    }

    private TableColumnHeader scan(TableColumnHeader header) {
        // firstly test that the parent isn't what we are looking for
        if (TreeTableColumn.this.equals(header.getTableColumn())) {
            return header;
        }

        if (header instanceof NestedTableColumnHeader) {
            NestedTableColumnHeader parent = (NestedTableColumnHeader) header;
            for (int i = 0; i &lt; parent.getColumnHeaders().size(); i++) {
                TableColumnHeader result = scan(parent.getColumnHeaders().get(i));
                if (result != null) {
                    return result;
                }
            }
        }

        return null;
    }



    /***************************************************************************
     *                                                                         *
     * Support Interfaces                                                      *
     *                                                                         *
     **************************************************************************/

    /**
     * A support class used in TreeTableColumn as a wrapper class
     * to provide all necessary information for a particular {@link Cell}. Once
     * instantiated, this class is immutable.
     *
     * @param &lt;S&gt; The TableView type
     * @param &lt;T&gt; The TreeTableColumn type
     * @since JavaFX 8.0
     */
    public static class CellDataFeatures&lt;S,T&gt; {
        private final TreeTableView&lt;S&gt; treeTableView;
        private final TreeTableColumn&lt;S,T&gt; tableColumn;
        private final TreeItem&lt;S&gt; value;

        /**
         * Instantiates a CellDataFeatures instance with the given properties
         * set as read-only values of this instance.
         *
         * @param treeTableView The TableView that this instance refers to.
         * @param tableColumn The TreeTableColumn that this instance refers to.
         * @param value The value for a row in the TableView.
         */
        public CellDataFeatures(TreeTableView&lt;S&gt; treeTableView,
                TreeTableColumn&lt;S,T&gt; tableColumn, TreeItem&lt;S&gt; value) {
            this.treeTableView = treeTableView;
            this.tableColumn = tableColumn;
            this.value = value;
        }

        /**
         * Returns the value passed in to the constructor.
         * @return the value passed in to the constructor
         */
        public TreeItem&lt;S&gt; getValue() {
            return value;
        }

        /**
         * Returns the {@link TreeTableColumn} passed in to the constructor.
         * @return the {@link TreeTableColumn} passed in to the constructor
         */
        public TreeTableColumn&lt;S,T&gt; getTreeTableColumn() {
            return tableColumn;
        }

        /**
         * Returns the {@link TableView} passed in to the constructor.
         * @return the {@link TableView} passed in to the constructor
         */
        public TreeTableView&lt;S&gt; getTreeTableView() {
            return treeTableView;
        }
    }



    /**
     * An event that is fired when a user performs an edit on a table cell.
     * @since JavaFX 8.0
     */
    public static class CellEditEvent&lt;S,T&gt; extends Event {
        private static final long serialVersionUID = -609964441682677579L;

        /**
         * Common supertype for all cell edit event types.
         */
        public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;

        // represents the new value input by the end user. This is NOT the value
        // to go back into the TableView.items list - this new value represents
        // just the input for a single cell, so it is likely that it needs to go
        // back into a property within an item in the TableView.items list.
        private final T newValue;

        // The location of the edit event
        private transient final TreeTablePosition&lt;S,T&gt; pos;

        /**
         * Creates a new event that can be subsequently fired to the relevant listeners.
         *
         * @param table The TableView on which this event occurred.
         * @param pos The position upon which this event occurred.
         * @param eventType The type of event that occurred.
         * @param newValue The value input by the end user.
         */
        public CellEditEvent(TreeTableView&lt;S&gt; table, TreeTablePosition&lt;S,T&gt; pos,
                EventType&lt;TreeTableColumn.CellEditEvent&lt;S,T&gt;&gt; eventType, T newValue) {
            super(table, Event.NULL_SOURCE_TARGET, eventType);

            if (table == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }
            this.pos = pos;
            this.newValue = newValue;
        }

        /**
         * Returns the TableView upon which this event occurred.
         * @return The TableView control upon which this event occurred.
         */
        public TreeTableView&lt;S&gt; getTreeTableView() {
            return pos.getTreeTableView();
        }

        /**
         * Returns the TreeTableColumn upon which this event occurred.
         *
         * @return The TreeTableColumn that the edit occurred in.
         */
        public TreeTableColumn&lt;S,T&gt; getTableColumn() {
            return pos.getTableColumn();
        }

        /**
         * Returns the position upon which this event occurred.
         * @return The position upon which this event occurred.
         */
        public TreeTablePosition&lt;S,T&gt; getTreeTablePosition() {
            return pos;
        }

        /**
         * Returns the new value input by the end user. This is &lt;b&gt;not&lt;/b&gt; the value
         * to go back into the TableView.items list - this new value represents
         * just the input for a single cell, so it is likely that it needs to go
         * back into a property within an item in the TableView.items list.
         *
         * @return An Object representing the new value input by the user.
         */
        public T getNewValue() {
            return newValue;
        }

        /**
         * Attempts to return the old value at the position referred to in the
         * TablePosition returned by {@link #getTreeTablePosition()}. This may return
         * null for a number of reasons.
         *
         * @return Returns the value stored in the position being edited, or null
         *     if it can not be retrieved.
         */
        public T getOldValue() {
            TreeItem&lt;S&gt; rowData = getRowValue();
            if (rowData == null || pos.getTableColumn() == null) {
                return null;
            }

            // if we are here, we now need to get the data for the specific column
            return (T) pos.getTableColumn().getCellData(rowData);
        }

        /**
         * Convenience method that returns the value for the row (that is, from
         * the TableView {@link TableView#itemsProperty() items} list), for the
         * row contained within the {@link TablePosition} returned in
         * {@link #getTreeTablePosition()}.
         * @return the row value
         */
        public TreeItem&lt;S&gt; getRowValue() {
//            List&lt;S&gt; items = getTreeTableView().getItems();
//            if (items == null) return null;

            TreeTableView&lt;S&gt; treeTable = getTreeTableView();
            int row = pos.getRow();
            if (row &lt; 0 || row &gt;= treeTable.getExpandedItemCount()) return null;

            return treeTable.getTreeItem(row);
        }
    }

    /**
     * Enumeration that specifies the type of sorting being applied to a specific
     * column.
     * @since JavaFX 8.0
     */
    public static enum SortType {
        /**
         * Column will be sorted in an ascending order.
         */
        ASCENDING,

        /**
         * Column will be sorted in a descending order.
         */
        DESCENDING;

        // UNSORTED
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TreeTableRow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.css.PseudoClass;
import javafx.scene.control.skin.TreeTableRowSkin;
import java.lang.ref.WeakReference;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ListChangeListener;
import javafx.collections.WeakListChangeListener;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
import javafx.scene.control.TreeTableView.TreeTableViewSelectionModel;

/**
 * &lt;p&gt;TreeTableRow is an {@link javafx.scene.control.IndexedCell IndexedCell}, but
 * rarely needs to be used by developers creating TreeTableView instances. The only
 * time TreeTableRow is likely to be encountered at all by a developer is if they
 * wish to create a custom {@link TreeTableView#rowFactoryProperty() rowFactory}
 * that replaces an entire row of a TreeTableView.&lt;/p&gt;
 *
 * &lt;p&gt;More often than not, it is actually easier for a developer to customize
 * individual cells in a row, rather than the whole row itself. To do this,
 * you can specify a custom {@link TreeTableColumn#cellFactoryProperty() cellFactory}
 * on each TreeTableColumn instance.&lt;/p&gt;
 *
 * @see TreeTableView
 * @see TreeTableColumn
 * @see TreeTableCell
 * @see IndexedCell
 * @see Cell
 * @param &lt;T&gt; The type of the item contained within the Cell.
 * @since JavaFX 8.0
 */
public class TreeTableRow&lt;T&gt; extends IndexedCell&lt;T&gt; {


    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TreeTableRow instance.
     */
    public TreeTableRow() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TREE_TABLE_ROW);
    }



    /***************************************************************************
     *                                                                         *
     * Callbacks and events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;Integer&gt; selectedListener = c -&gt; {
        updateSelection();
    };

    private final InvalidationListener focusedListener = valueModel -&gt; {
        updateFocus();
    };

    private final InvalidationListener editingListener = valueModel -&gt; {
        updateEditing();
    };

    private final InvalidationListener leafListener = new InvalidationListener() {
        @Override public void invalidated(Observable valueModel) {
            // necessary to update the disclosure node in the skin when the
            // leaf property changes
            TreeItem&lt;T&gt; treeItem = getTreeItem();
            if (treeItem != null) {
                requestLayout();
            }
        }
    };

    private boolean oldExpanded;
    private final InvalidationListener treeItemExpandedInvalidationListener = o -&gt; {
        final boolean expanded = ((BooleanProperty)o).get();
        pseudoClassStateChanged(EXPANDED_PSEUDOCLASS_STATE,   expanded);
        pseudoClassStateChanged(COLLAPSED_PSEUDOCLASS_STATE, !expanded);
        if (expanded != oldExpanded) {
            notifyAccessibleAttributeChanged(AccessibleAttribute.EXPANDED);
        }
        oldExpanded = expanded;
    };

    private final WeakListChangeListener&lt;Integer&gt; weakSelectedListener =
            new WeakListChangeListener&lt;Integer&gt;(selectedListener);
    private final WeakInvalidationListener weakFocusedListener =
            new WeakInvalidationListener(focusedListener);
    private final WeakInvalidationListener weakEditingListener =
            new WeakInvalidationListener(editingListener);
    private final WeakInvalidationListener weakLeafListener =
            new WeakInvalidationListener(leafListener);
    private final WeakInvalidationListener weakTreeItemExpandedInvalidationListener =
            new WeakInvalidationListener(treeItemExpandedInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- TreeItem
    private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; treeItem =
        new ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt;(this, &quot;treeItem&quot;) {

            TreeItem&lt;T&gt; oldValue = null;

            @Override protected void invalidated() {
                if (oldValue != null) {
                    oldValue.expandedProperty().removeListener(weakTreeItemExpandedInvalidationListener);
                }

                oldValue = get();

                if (oldValue != null) {
                    oldExpanded = oldValue.isExpanded();
                    oldValue.expandedProperty().addListener(weakTreeItemExpandedInvalidationListener);
                    // fake an invalidation to ensure updated pseudo-class state
                    weakTreeItemExpandedInvalidationListener.invalidated(oldValue.expandedProperty());
                }
            }
    };
    private void setTreeItem(TreeItem&lt;T&gt; value) {
        treeItem.set(value);
    }

    /**
     * Returns the TreeItem currently set in this TreeTableRow.
     * @return the TreeItem currently set in this TreeTableRow
     */
    public final TreeItem&lt;T&gt; getTreeItem() { return treeItem.get(); }

    /**
     * Each TreeTableCell represents at most a single {@link TreeItem}, which is
     * represented by this property.
     * @return the tree item property
     */
    public final ReadOnlyObjectProperty&lt;TreeItem&lt;T&gt;&gt; treeItemProperty() { return treeItem.getReadOnlyProperty(); }



    // --- Disclosure Node
    private ObjectProperty&lt;Node&gt; disclosureNode = new SimpleObjectProperty&lt;Node&gt;(this, &quot;disclosureNode&quot;);

    /**
     * The node to use as the &quot;disclosure&quot; triangle, or toggle, used for
     * expanding and collapsing items. This is only used in the case of
     * an item in the tree which contains child items. If not specified, the
     * TreeTableCell's Skin implementation is responsible for providing a default
     * disclosure node.
     * @param value the disclosure node
     */
    public final void setDisclosureNode(Node value) { disclosureNodeProperty().set(value); }

    /**
     * Returns the current disclosure node set in this TreeTableCell.
     * @return the disclosure node
     */
    public final Node getDisclosureNode() { return disclosureNode.get(); }

    /**
     * The disclosure node is commonly seen represented as a triangle that rotates
     * on screen to indicate whether or not the TreeItem that it is placed
     * beside is expanded or collapsed.
     * @return the disclosure node property
     */
    public final ObjectProperty&lt;Node&gt; disclosureNodeProperty() { return disclosureNode; }


    // --- TreeView
    private ReadOnlyObjectWrapper&lt;TreeTableView&lt;T&gt;&gt; treeTableView = new ReadOnlyObjectWrapper&lt;TreeTableView&lt;T&gt;&gt;(this, &quot;treeTableView&quot;) {
        private WeakReference&lt;TreeTableView&lt;T&gt;&gt; weakTreeTableViewRef;
        @Override protected void invalidated() {
            TreeTableViewSelectionModel&lt;T&gt; sm;
            TreeTableViewFocusModel&lt;T&gt; fm;

            if (weakTreeTableViewRef != null) {
                TreeTableView&lt;T&gt; oldTreeTableView = weakTreeTableViewRef.get();
                if (oldTreeTableView != null) {
                    // remove old listeners
                    sm = oldTreeTableView.getSelectionModel();
                    if (sm != null) {
                        sm.getSelectedIndices().removeListener(weakSelectedListener);
                    }

                    fm = oldTreeTableView.getFocusModel();
                    if (fm != null) {
                        fm.focusedIndexProperty().removeListener(weakFocusedListener);
                    }

                    oldTreeTableView.editingCellProperty().removeListener(weakEditingListener);
                }

                weakTreeTableViewRef = null;
            }

            if (get() != null) {
                sm = get().getSelectionModel();
                if (sm != null) {
                    // listening for changes to treeView.selectedIndex and IndexedCell.index,
                    // to determine if this cell is selected
                    sm.getSelectedIndices().addListener(weakSelectedListener);
                }

                fm = get().getFocusModel();
                if (fm != null) {
                    // similar to above, but this time for focus
                    fm.focusedIndexProperty().addListener(weakFocusedListener);
                }

                get().editingCellProperty().addListener(weakEditingListener);

                weakTreeTableViewRef = new WeakReference&lt;TreeTableView&lt;T&gt;&gt;(get());
            }

            updateItem();
            requestLayout();
        }
    };

    private void setTreeTableView(TreeTableView&lt;T&gt; value) { treeTableView.set(value); }

    /**
     * Returns the TreeTableView associated with this TreeTableCell.
     * @return the tree table view
     */
    public final TreeTableView&lt;T&gt; getTreeTableView() { return treeTableView.get(); }

    /**
     * A TreeTableCell is explicitly linked to a single {@link TreeTableView} instance,
     * which is represented by this property.
     * @return the tree table view property
     */
    public final ReadOnlyObjectProperty&lt;TreeTableView&lt;T&gt;&gt; treeTableViewProperty() { return treeTableView.getReadOnlyProperty(); }




    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     *************************************************************************
     * @param oldIndex
     * @param newIndex*/


    @Override void indexChanged(int oldIndex, int newIndex) {
        index = getIndex();

        // when the cell index changes, this may result in the cell
        // changing state to be selected and/or focused.
        updateItem();
        updateSelection();
        updateFocus();
//        oldIndex = index;
    }


    /** {@inheritDoc} */
    @Override public void startEdit() {
        final TreeTableView&lt;T&gt; treeTable = getTreeTableView();
        if (! isEditable() || (treeTable != null &amp;&amp; ! treeTable.isEditable())) {
            return;
        }

        // it makes sense to get the cell into its editing state before firing
        // the event to the TreeView below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

         // Inform the TreeView of the edit starting.
<A NAME="24"></A>        if (treeTable != null) {
            treeTable.fireEvent(new TreeTableView.EditEvent&lt;T&gt;(treeTable,
                    TreeTableView.&lt;T&gt;editStartEvent(),
                    <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#24',2,'match36-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getTreeItem(),
                    getItem(),
                    null));

            treeTable.requestFocus();
        }
    }

     /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing</B></FONT>()) return;
        final TreeItem&lt;T&gt; treeItem = getTreeItem();
        final TreeTableView&lt;T&gt; treeTable = getTreeTableView();
        if (treeTable != null) {
            // Inform the TreeView of the edit being ready to be committed.
            treeTable.fireEvent(new TreeTableView.EditEvent&lt;T&gt;(treeTable,
                    TreeTableView.&lt;T&gt;editCommitEvent(),
                    treeItem,
                    getItem(),
                    newValue));
        }

        // update the item within this cell, so that it represents the new value
        if (treeItem != null) {
            treeItem.setValue(newValue);
            updateTreeItem(treeItem);
            updateItem(newValue, false);
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state
        super.commitEdit(newValue);

        if (treeTable != null) {
            // reset the editing item in the TreetView
            treeTable.edit(-1, null);
            treeTable.requestFocus();
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

        TreeTableView&lt;T&gt; treeTable = getTreeTableView();
        if (treeTable != null) {
            treeTable.fireEvent(new TreeTableView.EditEvent&lt;T&gt;(treeTable,
                    TreeTableView.&lt;T&gt;editCancelEvent(),
                    getTreeItem(),
                    getItem(),
                    null));
        }

        super.cancelEdit();

        if (treeTable != null) {
            // reset the editing index on the TreeView
            treeTable.edit(-1, null);
            treeTable.requestFocus();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private int index = -1;
    private boolean isFirstRun = true;

    private void updateItem() {
        TreeTableView&lt;T&gt; tv = getTreeTableView();
        if (tv == null) return;

        // Compute whether the index for this cell is for a real item
        boolean valid = index &gt;=0 &amp;&amp; index &lt; tv.getExpandedItemCount();

        final TreeItem&lt;T&gt; oldTreeItem = getTreeItem();
        final boolean isEmpty = isEmpty();

        // Cause the cell to update itself
        if (valid) {
            // update the TreeCell state.
            // get the new treeItem that is about to go in to the TreeCell
            final TreeItem&lt;T&gt; newTreeItem = tv.getTreeItem(index);
            final T newValue = newTreeItem == null ? null : newTreeItem.getValue();

            // For the sake of RT-14279, it is important that the order of these
            // method calls is as shown below. If the order is switched, it is
            // likely that events will be fired where the item is null, even
            // though calling cell.getTreeItem().getValue() returns the value
            // as expected

            // There used to be conditional code here to prevent updateItem from
            // being called when the value didn't change, but that led us to
            // issues such as RT-33108, where the value didn't change but the item
            // we needed to be listening to did. Without calling updateItem we
            // were breaking things, so once again the conditionals are gone.
            updateTreeItem(newTreeItem);
            updateItem(newValue, false);
        } else {
            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            if ((!isEmpty &amp;&amp; oldTreeItem != null) || isFirstRun) {
                updateTreeItem(null);
                updateItem(null, true);
                isFirstRun = false;
            }
        }
    }

    private void updateSelection() {
        if (isEmpty()) return;
        if (index == -1 || getTreeTableView() == null) return;
        if (getTreeTableView().getSelectionModel() == null) return;

        boolean isSelected = getTreeTableView().getSelectionModel().isSelected(index);
        if (isSelected() == isSelected) return;

        updateSelected(isSelected);
    }

    private void updateFocus() {
        if (getIndex() == -1 || getTreeTableView() == null) return;
        if (getTreeTableView().getFocusModel() == null) return;

        setFocused(getTreeTableView().getFocusModel().isFocused(getIndex()));
    }

    private void updateEditing() {
        if (getIndex() == -1 || getTreeTableView() == null || getTreeItem() == null) return;

        final TreeTablePosition&lt;T,?&gt; editingCell = getTreeTableView().getEditingCell();
        if (editingCell != null &amp;&amp; editingCell.getTableColumn() != null) {
            return;
        }

        final TreeItem&lt;T&gt; editItem = editingCell == null ? null : editingCell.getTreeItem();
        if (! isEditing() &amp;&amp; getTreeItem().equals(editItem)) {
            startEdit();
        } else if (isEditing() &amp;&amp; ! getTreeItem().equals(editItem)) {
            cancelEdit();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Expert API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Updates the TreeTableView associated with this TreeTableCell.
     *
     * @param treeTable The new TreeTableView that should be associated with this
     *         TreeTableCell.
     * Note: This function is intended to be used by experts, primarily
     *         by those implementing new Skins. It is not common
     *         for developers or designers to access this function directly.
     */
    public final void updateTreeTableView(TreeTableView&lt;T&gt; treeTable) {
        setTreeTableView(treeTable);
    }

    /**
     * Updates the TreeItem associated with this TreeTableCell.
     *
     * @param treeItem The new TreeItem that should be associated with this
     *      TreeTableCell.
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     */
    public final void updateTreeItem(TreeItem&lt;T&gt; treeItem) {
        TreeItem&lt;T&gt; _treeItem = getTreeItem();
        if (_treeItem != null) {
            _treeItem.leafProperty().removeListener(weakLeafListener);
        }
        setTreeItem(treeItem);
        if (treeItem != null) {
            treeItem.leafProperty().addListener(weakLeafListener);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-row-cell&quot;;

    private static final PseudoClass EXPANDED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;expanded&quot;);
    private static final PseudoClass COLLAPSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;collapsed&quot;);

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TreeTableRowSkin&lt;T&gt;(this);
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        final TreeItem&lt;T&gt; treeItem = getTreeItem();
        final TreeTableView&lt;T&gt; treeTableView = getTreeTableView();

        switch (attribute) {
            case TREE_ITEM_PARENT: {
                if (treeItem == null) return null;
                TreeItem&lt;T&gt; parent = treeItem.getParent();
                if (parent == null) return null;
                int parentIndex = treeTableView.getRow(parent);
                return treeTableView.queryAccessibleAttribute(AccessibleAttribute.ROW_AT_INDEX, parentIndex);
            }
            case TREE_ITEM_COUNT: {
                if (treeItem == null) return 0;
                if (!treeItem.isExpanded()) return 0;
                return treeItem.getChildren().size();
            }
            case TREE_ITEM_AT_INDEX: {
                if (treeItem == null) return null;
                if (!treeItem.isExpanded()) return null;
                int index = (Integer)parameters[0];
                if (index &gt;= treeItem.getChildren().size()) return null;
                TreeItem&lt;T&gt; child = treeItem.getChildren().get(index);
                if (child == null) return null;
                int childIndex = treeTableView.getRow(child);
                return treeTableView.queryAccessibleAttribute(AccessibleAttribute.ROW_AT_INDEX, childIndex);
            }
            case LEAF: return treeItem == null ? true : treeItem.isLeaf();
            case EXPANDED: return treeItem == null ? false : treeItem.isExpanded();
            case INDEX: return getIndex();
            case DISCLOSURE_LEVEL: {
                return treeTableView == null ? 0 : treeTableView.getTreeItemLevel(treeItem);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case EXPAND: {
                TreeItem&lt;T&gt; treeItem = getTreeItem();
                if (treeItem != null) treeItem.setExpanded(true);
                break;
            }
            case COLLAPSE: {
                TreeItem&lt;T&gt; treeItem = getTreeItem();
                if (treeItem != null) treeItem.setExpanded(false);
                break;
            }
            default: super.executeAccessibleAction(action);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableColumnHeader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TableColumnBaseHelper;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.value.WritableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumnBase;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import javafx.css.converter.SizeConverter;

import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;


/**
 * Region responsible for painting a single column header. A subcomponent used by
 * subclasses of {@link TableViewSkinBase}.
 *
 * @since 9
 */
public class TableColumnHeader extends Region {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/

    static final String DEFAULT_STYLE_CLASS = &quot;column-header&quot;;

    // Copied from TableColumn. The value here should always be in-sync with
    // the value in TableColumn
    static final double DEFAULT_COLUMN_WIDTH = 80.0F;



    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    private boolean autoSizeComplete = false;

    private double dragOffset;
    private NestedTableColumnHeader nestedColumnHeader;
    private TableHeaderRow tableHeaderRow;
    private NestedTableColumnHeader parentHeader;

    // work out where this column currently is within its parent
    Label label;

    // sort order
    int sortPos = -1;
    private Region arrow;
    private Label sortOrderLabel;
    private HBox sortOrderDots;
    private Node sortArrow;
    private boolean isSortColumn;

    private boolean isSizeDirty = false;

    boolean isLastVisibleColumn = false;

    // package for testing
    int columnIndex = -1;

    private int newColumnPos;

    // the line drawn in the table when a user presses and moves a column header
    // to indicate where the column will be dropped. This is provided by the
    // table skin, but manipulated by the header
    Region columnReorderLine;



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TableColumnHeader instance to visually represent the given
     * {@link TableColumnBase} instance.
     *
     * @param tc The table column to be visually represented by this instance.
     */
    public TableColumnHeader(final TableColumnBase tc) {
        setTableColumn(tc);
        setFocusTraversable(false);

        initStyleClasses();
        initUI();

        // change listener for multiple properties
        changeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();
        changeListenerHandler.registerChangeListener(sceneProperty(), e -&gt; updateScene());

        if (getTableColumn() != null) {
            changeListenerHandler.registerChangeListener(tc.idProperty(), e -&gt; setId(tc.getId()));
            changeListenerHandler.registerChangeListener(tc.styleProperty(), e -&gt; setStyle(tc.getStyle()));
            changeListenerHandler.registerChangeListener(tc.widthProperty(), e -&gt; {
                // It is this that ensures that when a column is resized that the header
                // visually adjusts its width as necessary.
                isSizeDirty = true;
                requestLayout();
            });
            changeListenerHandler.registerChangeListener(tc.visibleProperty(), e -&gt; setVisible(getTableColumn().isVisible()));
            changeListenerHandler.registerChangeListener(tc.sortNodeProperty(), e -&gt; updateSortGrid());
            changeListenerHandler.registerChangeListener(tc.sortableProperty(), e -&gt; {
                // we need to notify all headers that a sortable state has changed,
                // in case the sort grid in other columns needs to be updated.
                if (TableSkinUtils.getSortOrder(getTableSkin()).contains(getTableColumn())) {
                    NestedTableColumnHeader root = getTableHeaderRow().getRootHeader();
                    updateAllHeaders(root);
                }
            });
            changeListenerHandler.registerChangeListener(tc.textProperty(), e -&gt; label.setText(tc.getText()));
            changeListenerHandler.registerChangeListener(tc.graphicProperty(), e -&gt; label.setGraphic(tc.getGraphic()));

            setId(tc.getId());
            setStyle(tc.getStyle());
            /* Having TableColumn role parented by TableColumn causes VoiceOver to be unhappy */
            setAccessibleRole(AccessibleRole.TABLE_COLUMN);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    final LambdaMultiplePropertyChangeListenerHandler changeListenerHandler;

    private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderListener = c -&gt; {
        updateSortPosition();
    };

    private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
        updateColumnIndex();
        updateSortPosition();
    };

    private ListChangeListener&lt;String&gt; styleClassListener = c -&gt; {
        while (c.next()) {
            if (c.wasRemoved()) {
                getStyleClass().removeAll(c.getRemoved());
            }
            if (c.wasAdded()) {
                getStyleClass().addAll(c.getAddedSubList());
            }
        }
    };

    private WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakSortOrderListener =
            new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrderListener);
    private final WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakVisibleLeafColumnsListener =
            new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(visibleLeafColumnsListener);
    private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
            new WeakListChangeListener&lt;String&gt;(styleClassListener);

    private static final EventHandler&lt;MouseEvent&gt; mousePressedHandler = me -&gt; {
        TableColumnHeader header = (TableColumnHeader) me.getSource();
        TableColumnBase tableColumn = header.getTableColumn();

        ContextMenu menu = tableColumn.getContextMenu();
        if (menu != null &amp;&amp; menu.isShowing()) {
            menu.hide();
        }

        if (me.isConsumed()) return;
        me.consume();

        header.getTableHeaderRow().columnDragLock = true;

        // pass focus to the table, so that the user immediately sees
        // the focus rectangle around the table control.
        header.getTableSkin().getSkinnable().requestFocus();

        if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
            header.columnReorderingStarted(me.getX());
        }
    };

    private static final EventHandler&lt;MouseEvent&gt; mouseDraggedHandler = me -&gt; {
        if (me.isConsumed()) return;
        me.consume();

        TableColumnHeader header = (TableColumnHeader) me.getSource();

        if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
            header.columnReordering(me.getSceneX(), me.getSceneY());
        }
    };

    private static final EventHandler&lt;MouseEvent&gt; mouseReleasedHandler = me -&gt; {
        if (me.isPopupTrigger()) return;
        if (me.isConsumed()) return;
        me.consume();

        TableColumnHeader header = (TableColumnHeader) me.getSource();
        header.getTableHeaderRow().columnDragLock = false;

        if (header.getTableHeaderRow().isReordering() &amp;&amp; header.isColumnReorderingEnabled()) {
            header.columnReorderingComplete();
        } else if (me.isStillSincePress()) {
            header.sortColumn(me.isShiftDown());
        }
    };

    private static final EventHandler&lt;ContextMenuEvent&gt; contextMenuRequestedHandler = me -&gt; {
        TableColumnHeader header = (TableColumnHeader) me.getSource();
        TableColumnBase tableColumn = header.getTableColumn();

        ContextMenu menu = tableColumn.getContextMenu();
        if (menu != null) {
            menu.show(header, me.getScreenX(), me.getScreenY());
            me.consume();
        }
    };



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- size
    private DoubleProperty size;
    private final double getSize() {
        return size == null ? 20.0 : size.doubleValue();
    }
    private final DoubleProperty sizeProperty() {
        if (size == null) {
            size = new StyleableDoubleProperty(20) {
                @Override
                protected void invalidated() {
                    double value = get();
                    if (value &lt;= 0) {
                        if (isBound()) {
                            unbind();
                        }
                        set(20);
                        throw new IllegalArgumentException(&quot;Size cannot be 0 or negative&quot;);
                    }
                }



                @Override public Object getBean() {
                    return TableColumnHeader.this;
                }

                @Override public String getName() {
                    return &quot;size&quot;;
                }

                @Override public CssMetaData&lt;TableColumnHeader,Number&gt; getCssMetaData() {
                    return StyleableProperties.SIZE;
                }
            };
        }
        return size;
    }


    /**
     * A property that refers to the {@link TableColumnBase} instance that this
     * header is visually represents.
     */
    // --- table column
    private ReadOnlyObjectWrapper&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumn = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;tableColumn&quot;);
    private final void setTableColumn(TableColumnBase&lt;?,?&gt; column) {
        tableColumn.set(column);
    }
    public final TableColumnBase&lt;?,?&gt; getTableColumn() {
        return tableColumn.get();
    }
    public final ReadOnlyObjectProperty&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumnProperty() {
        return tableColumn.getReadOnlyProperty();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (isSizeDirty) {
            resize(getTableColumn().getWidth(), getHeight());
            isSizeDirty = false;
        }

        double sortWidth = 0;
        double w = snapSizeX(getWidth()) - (snappedLeftInset() + snappedRightInset());
        double h = getHeight() - (snappedTopInset() + snappedBottomInset());
        double x = w;

        // a bit hacky, but we REALLY don't want the arrow shape to fluctuate
        // in size
        if (arrow != null) {
            arrow.setMaxSize(arrow.prefWidth(-1), arrow.prefHeight(-1));
        }

        if (sortArrow != null &amp;&amp; sortArrow.isVisible()) {
            sortWidth = sortArrow.prefWidth(-1);
            x -= sortWidth;
            sortArrow.resize(sortWidth, sortArrow.prefHeight(-1));
            positionInArea(sortArrow, x, snappedTopInset(),
                    sortWidth, h, 0, HPos.CENTER, VPos.CENTER);
        }
<A NAME="19"></A>
        if (label != null) {
            double labelWidth = w - sortWidth;
            <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#19',2,'match36-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>label.resizeRelocate(snappedLeftInset(), 0, labelWidth, getHeight());
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        if (getNestedColumnHeader() != null) {</B></FONT>
            double width = getNestedColumnHeader().prefWidth(height);

            if (getTableColumn() != null) {
                TableColumnBaseHelper.setWidth(getTableColumn(), width);
            }

            return width;
        } else if (getTableColumn() != null &amp;&amp; getTableColumn().isVisible()) {
            return snapSizeX(getTableColumn().getWidth());
        }

        return 0;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width) {
        return label == null ? 0 : label.minHeight(width);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        if (getTableColumn() == null) return 0;
        return Math.max(getSize(), label.prefHeight(-1));
    }

    /** {@inheritDoc} */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** {@inheritDoc} */
    @Override  public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case INDEX: return getIndex(getTableColumn());
            case TEXT: return getTableColumn() != null ? getTableColumn().getText() : null;
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    void initStyleClasses() {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        installTableColumnStyleClassListener();
    }

    void installTableColumnStyleClassListener() {
        TableColumnBase tc = getTableColumn();
        if (tc != null) {
            // add in all styleclasses from the table column into the header, and also set up a listener
            // so that any subsequent changes to the table column are also applied to the header
            getStyleClass().addAll(tc.getStyleClass());
            tc.getStyleClass().addListener(weakStyleClassListener);
        }
    }

    NestedTableColumnHeader getNestedColumnHeader() { return nestedColumnHeader; }
    void setNestedColumnHeader(NestedTableColumnHeader nch) { nestedColumnHeader = nch; }

    TableHeaderRow getTableHeaderRow() { return tableHeaderRow; }
    void setTableHeaderRow(TableHeaderRow thr) {
        tableHeaderRow = thr;
        updateTableSkin();
    }

    private void updateTableSkin() {
        // when we get the table header row, we are also given the skin,
        // so this is the time to hook up listeners, etc.
        TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin = getTableSkin();
        if (tableSkin == null) return;

        updateColumnIndex();
        this.columnReorderLine = tableSkin.getColumnReorderLine();

        if (getTableColumn() != null) {
            updateSortPosition();
            TableSkinUtils.getSortOrder(tableSkin).addListener(weakSortOrderListener);
            TableSkinUtils.getVisibleLeafColumns(tableSkin).addListener(weakVisibleLeafColumnsListener);
        }
    }

    TableViewSkinBase&lt;?,?,?,?,?&gt; getTableSkin() {
        return tableHeaderRow == null ? null : tableHeaderRow.tableSkin;
    }

    NestedTableColumnHeader getParentHeader() { return parentHeader; }
    void setParentHeader(NestedTableColumnHeader ph) { parentHeader = ph; }

    // RT-29682: When the sortable property of a TableColumnBase changes this
    // may impact other TableColumnHeaders, as they may need to change their
    // sort order representation. Rather than install listeners across all
    // TableColumn in the sortOrder list for their sortable property, we simply
    // update the sortPosition of all headers whenever the sortOrder property
    // changes, assuming the column is within the sortOrder list.
    private void updateAllHeaders(TableColumnHeader header) {
        if (header instanceof NestedTableColumnHeader) {
            List&lt;TableColumnHeader&gt; children = ((NestedTableColumnHeader)header).getColumnHeaders();
            for (int i = 0; i &lt; children.size(); i++) {
                updateAllHeaders(children.get(i));
            }
        } else {
            header.updateSortPosition();
        }
    }

    private void updateScene() {
        // RT-17684: If the TableColumn widths are all currently the default,
        // we attempt to 'auto-size' based on the preferred width of the first
        // n rows (we can't do all rows, as that could conceivably be an unlimited
        // number of rows retrieved from a very slow (e.g. remote) data source.
        // Obviously, the bigger the value of n, the more likely the default
        // width will be suitable for most values in the column
        final int n = 30;
        if (! autoSizeComplete) {
            if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
                return;
            }
            doColumnAutoSize(getTableColumn(), n);
            autoSizeComplete = true;
        }
    }

    void dispose() {
        TableViewSkinBase tableSkin = getTableSkin();
        if (tableSkin != null) {
            TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
            TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
        }

        changeListenerHandler.dispose();
    }

    private boolean isSortingEnabled() {
        // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
        // to always return true (for now), as we want to support column sorting
        // everywhere
        return true;
    }

    private boolean isColumnReorderingEnabled() {
        // we only allow for column reordering if there are more than one column,
        return !Properties.IS_TOUCH_SUPPORTED &amp;&amp; TableSkinUtils.getVisibleLeafColumns(getTableSkin()).size() &gt; 1;
    }

    private void initUI() {
        // TableColumn will be null if we are dealing with the root NestedTableColumnHeader
        if (getTableColumn() == null) return;

        // set up mouse events
        setOnMousePressed(mousePressedHandler);
        setOnMouseDragged(mouseDraggedHandler);
        setOnDragDetected(event -&gt; event.consume());
        setOnContextMenuRequested(contextMenuRequestedHandler);
        setOnMouseReleased(mouseReleasedHandler);

        // --- label
        label = new Label();
        label.setText(getTableColumn().getText());
        label.setGraphic(getTableColumn().getGraphic());
        label.setVisible(getTableColumn().isVisible());

        // ---- container for the sort arrow (which is not supported on embedded
        // platforms)
        if (isSortingEnabled()) {
            // put together the grid
            updateSortGrid();
        }
    }

    private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {
        double prefWidth = column.getPrefWidth();

        // if the prefWidth has been set, we do _not_ autosize columns
        if (prefWidth == DEFAULT_COLUMN_WIDTH) {
            TableSkinUtils.resizeColumnToFitContent(getTableSkin(), column, cellsToMeasure);
//            getTableViewSkin().resizeColumnToFitContent(column, cellsToMeasure);
        }
    }

    private void updateSortPosition() {
        this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
        updateSortGrid();
    }

    private void updateSortGrid() {
        // Fix for RT-14488
        if (this instanceof NestedTableColumnHeader) return;

        getChildren().clear();
        getChildren().add(label);

        // we do not support sorting in embedded devices
        if (! isSortingEnabled()) return;

        isSortColumn = sortPos != -1;
        if (! isSortColumn) {
            if (sortArrow != null) {
                sortArrow.setVisible(false);
            }
            return;
        }

        // RT-28016: if the tablecolumn is not a visible leaf column, we should ignore this
        int visibleLeafIndex = TableSkinUtils.getVisibleLeafIndex(getTableSkin(), getTableColumn());
        if (visibleLeafIndex == -1) return;

        final int sortColumnCount = getVisibleSortOrderColumnCount();
        boolean showSortOrderDots = sortPos &lt;= 3 &amp;&amp; sortColumnCount &gt; 1;

        Node _sortArrow = null;
        if (getTableColumn().getSortNode() != null) {
            _sortArrow = getTableColumn().getSortNode();
            getChildren().add(_sortArrow);
        } else {
            GridPane sortArrowGrid = new GridPane();
            _sortArrow = sortArrowGrid;
            sortArrowGrid.setPadding(new Insets(0, 3, 0, 0));
            getChildren().add(sortArrowGrid);

            // if we are here, and the sort arrow is null, we better create it
            if (arrow == null) {
                arrow = new Region();
                arrow.getStyleClass().setAll(&quot;arrow&quot;);
                arrow.setVisible(true);
                arrow.setRotate(isAscending(getTableColumn()) ? 180.0F : 0.0F);
                changeListenerHandler.registerChangeListener(getSortTypeProperty(getTableColumn()), e -&gt; {
                    updateSortGrid();
                    if (arrow != null) {
                        arrow.setRotate(isAscending(getTableColumn()) ? 180 : 0.0);
                    }
                });
            }

            arrow.setVisible(isSortColumn);

            if (sortPos &gt; 2) {
                if (sortOrderLabel == null) {
                    // ---- sort order label (for sort positions greater than 3)
                    sortOrderLabel = new Label();
                    sortOrderLabel.getStyleClass().add(&quot;sort-order&quot;);
                }

                // only show the label if the sortPos is greater than 3 (for sortPos
                // values less than three, we show the sortOrderDots instead)
                sortOrderLabel.setText(&quot;&quot; + (sortPos + 1));
                sortOrderLabel.setVisible(sortColumnCount &gt; 1);

                // update the grid layout
                sortArrowGrid.add(arrow, 1, 1);
                GridPane.setHgrow(arrow, Priority.NEVER);
                GridPane.setVgrow(arrow, Priority.NEVER);
                sortArrowGrid.add(sortOrderLabel, 2, 1);
            } else if (showSortOrderDots) {
                if (sortOrderDots == null) {
                    sortOrderDots = new HBox(0);
                    sortOrderDots.getStyleClass().add(&quot;sort-order-dots-container&quot;);
                }

                // show the sort order dots
                boolean isAscending = isAscending(getTableColumn());
                int arrowRow = isAscending ? 1 : 2;
                int dotsRow = isAscending ? 2 : 1;

                sortArrowGrid.add(arrow, 1, arrowRow);
                GridPane.setHalignment(arrow, HPos.CENTER);
                sortArrowGrid.add(sortOrderDots, 1, dotsRow);

                updateSortOrderDots(sortPos);
            } else {
                // only show the arrow
                sortArrowGrid.add(arrow, 1, 1);
                GridPane.setHgrow(arrow, Priority.NEVER);
                GridPane.setVgrow(arrow, Priority.ALWAYS);
            }
        }

        sortArrow = _sortArrow;
        if (sortArrow != null) {
            sortArrow.setVisible(isSortColumn);
        }

        requestLayout();
    }

    private void updateSortOrderDots(int sortPos) {
        double arrowWidth = arrow.prefWidth(-1);

        sortOrderDots.getChildren().clear();

        for (int i = 0; i &lt;= sortPos; i++) {
            Region r = new Region();
            r.getStyleClass().add(&quot;sort-order-dot&quot;);

            String sortTypeName = getSortTypeName(getTableColumn());
            if (sortTypeName != null &amp;&amp; ! sortTypeName.isEmpty()) {
                r.getStyleClass().add(sortTypeName.toLowerCase(Locale.ROOT));
            }

            sortOrderDots.getChildren().add(r);

            // RT-34914: fine tuning the placement of the sort dots. We could have gone to a custom layout, but for now
            // this works fine.
            if (i &lt; sortPos) {
                Region spacer = new Region();
                double lp = sortPos == 1 ? 1 : 0;
                spacer.setPadding(new Insets(0, 1, 0, lp));
                sortOrderDots.getChildren().add(spacer);
            }
        }

        sortOrderDots.setAlignment(Pos.TOP_CENTER);
        sortOrderDots.setMaxWidth(arrowWidth);
    }

    // Package for testing purposes only.
    void moveColumn(TableColumnBase column, final int newColumnPos) {
        if (column == null || newColumnPos &lt; 0) return;

        ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);

        final int columnsCount = columns.size();
        final int currentPos = columns.indexOf(column);

        int actualNewColumnPos = newColumnPos;

        // Fix for RT-35141: We need to account for hidden columns.
        // We keep iterating until we see 'requiredVisibleColumns' number of visible columns
        final int requiredVisibleColumns = actualNewColumnPos;
        int visibleColumnsSeen = 0;
        for (int i = 0; i &lt; columnsCount; i++) {
            if (visibleColumnsSeen == (requiredVisibleColumns + 1)) {
                break;
            }

            if (columns.get(i).isVisible()) {
                visibleColumnsSeen++;
            } else {
                actualNewColumnPos++;
            }
        }
        // --- end of RT-35141 fix

        if (actualNewColumnPos &gt;= columnsCount) {
            actualNewColumnPos = columnsCount - 1;
        } else if (actualNewColumnPos &lt; 0) {
            actualNewColumnPos = 0;
        }

        if (actualNewColumnPos == currentPos) return;

        List&lt;TableColumnBase&lt;?,?&gt;&gt; tempList = new ArrayList&lt;&gt;(columns);
        tempList.remove(column);
        tempList.add(actualNewColumnPos, column);

        columns.setAll(tempList);
    }

    private ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; getColumns(TableColumnBase column) {
        return column.getParentColumn() == null ?
                TableSkinUtils.getColumns(getTableSkin()) :
                column.getParentColumn().getColumns();
    }

    private int getIndex(TableColumnBase&lt;?,?&gt; column) {
        if (column == null) return -1;

        ObservableList&lt;? extends TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);

        int index = -1;
        for (int i = 0; i &lt; columns.size(); i++) {
            TableColumnBase&lt;?,?&gt; _column = columns.get(i);
            if (! _column.isVisible()) continue;

            index++;
            if (column.equals(_column)) break;
        }

        return index;
    }

    private void updateColumnIndex() {
//        TableView tv = getTableView();
        TableColumnBase tc = getTableColumn();
        TableViewSkinBase tableSkin = getTableSkin();
        columnIndex = tableSkin == null || tc == null ? -1 :TableSkinUtils.getVisibleLeafIndex(tableSkin,tc);

        // update the pseudo class state regarding whether this is the last
        // visible cell (i.e. the right-most).
        isLastVisibleColumn = getTableColumn() != null &amp;&amp;
                columnIndex != -1 &amp;&amp;
                columnIndex == TableSkinUtils.getVisibleLeafColumns(tableSkin).size() - 1;
        pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
    }

    private void sortColumn(final boolean addColumn) {
        if (! isSortingEnabled()) return;

        // we only allow sorting on the leaf columns and columns
        // that actually have comparators defined, and are sortable
        if (getTableColumn() == null || getTableColumn().getColumns().size() != 0 || getTableColumn().getComparator() == null || !getTableColumn().isSortable()) return;
//        final int sortPos = getTable().getSortOrder().indexOf(column);
//        final boolean isSortColumn = sortPos != -1;

        final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());

        // addColumn is true e.g. when the user is holding down Shift
        if (addColumn) {
            if (!isSortColumn) {
                setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
                sortOrder.add(getTableColumn());
            } else if (isAscending(getTableColumn())) {
                setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
            } else {
                int i = sortOrder.indexOf(getTableColumn());
                if (i != -1) {
                    sortOrder.remove(i);
                }
            }
        } else {
            // the user has clicked on a column header - we should add this to
            // the TableView sortOrder list if it isn't already there.
            if (isSortColumn &amp;&amp; sortOrder.size() == 1) {
                // the column is already being sorted, and it's the only column.
                // We therefore move through the 2nd or 3rd states:
                //   1st click: sort ascending
                //   2nd click: sort descending
                //   3rd click: natural sorting (sorting is switched off)
                if (isAscending(getTableColumn())) {
                    setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
                } else {
                    // remove from sort
                    sortOrder.remove(getTableColumn());
                }
            } else if (isSortColumn) {
                // the column is already being used to sort, so we toggle its
                // sortAscending property, and also make the column become the
                // primary sort column
                if (isAscending(getTableColumn())) {
                    setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
                } else if (isDescending(getTableColumn())) {
                    setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
                }

                // to prevent multiple sorts, we make a copy of the sort order
                // list, moving the column value from the current position to
                // its new position at the front of the list
                List&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderCopy = new ArrayList&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrder);
                sortOrderCopy.remove(getTableColumn());
                sortOrderCopy.add(0, getTableColumn());
                sortOrder.setAll(getTableColumn());
            } else {
                // add to the sort order, in ascending form
                setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
                sortOrder.setAll(getTableColumn());
            }
        }
    }

    // Because it is possible that some columns are in the sortOrder list but are
    // not themselves sortable, we cannot just do sortOrderList.indexOf(column).
    // Therefore, this method does the proper work required of iterating through
    // and ignoring non-sortable (and null) columns in the sortOrder list.
    private int getSortPosition() {
        if (getTableColumn() == null) {
            return -1;
        }

        final List&lt;TableColumnBase&gt; sortOrder = getVisibleSortOrderColumns();
        int pos = 0;
        for (int i = 0; i &lt; sortOrder.size(); i++) {
            TableColumnBase _tc = sortOrder.get(i);

            if (getTableColumn().equals(_tc)) {
                return pos;
            }

            pos++;
        }

        return -1;
    }

    private List&lt;TableColumnBase&gt; getVisibleSortOrderColumns() {
        final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());

        List&lt;TableColumnBase&gt; visibleSortOrderColumns = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; sortOrder.size(); i++) {
            TableColumnBase _tc = sortOrder.get(i);
            if (_tc == null || ! _tc.isSortable() || ! _tc.isVisible()) {
                continue;
            }

            visibleSortOrderColumns.add(_tc);
        }

        return visibleSortOrderColumns;
    }

    // as with getSortPosition above, this method iterates through the sortOrder
    // list ignoring the null and non-sortable columns, so that we get the correct
    // number of columns in the sortOrder list.
    private int getVisibleSortOrderColumnCount() {
        return getVisibleSortOrderColumns().size();
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation: Column Reordering                               *
     *                                                                         *
     **************************************************************************/

    // package for testing
    void columnReorderingStarted(double dragOffset) {
        if (! getTableColumn().isReorderable()) return;

        // Used to ensure the column ghost is positioned relative to where the
        // user clicked on the column header
        this.dragOffset = dragOffset;

        // Note here that we only allow for reordering of 'root' columns
        getTableHeaderRow().setReorderingColumn(getTableColumn());
        getTableHeaderRow().setReorderingRegion(this);
    }

    // package for testing
    void columnReordering(double sceneX, double sceneY) {
        if (! getTableColumn().isReorderable()) return;

        // this is for handling the column drag to reorder columns.
        // It shows a line to indicate where the 'drop' will be.

        // indicate that we've started dragging so that the dragging
        // line overlay is shown
        getTableHeaderRow().setReordering(true);

        // Firstly we need to determine where to draw the line.
        // Find which column we're over
        TableColumnHeader hoverHeader = null;

        // x represents where the mouse is relative to the parent
        // NestedTableColumnHeader
        final double x = getParentHeader().sceneToLocal(sceneX, sceneY).getX();

        // calculate where the ghost column header should be
        double dragX = getTableSkin().getSkinnable().sceneToLocal(sceneX, sceneY).getX() - dragOffset;
        getTableHeaderRow().setDragHeaderX(dragX);

        double startX = 0;
        double endX = 0;
        double headersWidth = 0;
        newColumnPos = 0;
        for (TableColumnHeader header : getParentHeader().getColumnHeaders()) {
            if (! header.isVisible()) continue;

            double headerWidth = header.prefWidth(-1);
            headersWidth += headerWidth;

            startX = header.getBoundsInParent().getMinX();
            endX = startX + headerWidth;

            if (x &gt;= startX &amp;&amp; x &lt; endX) {
                hoverHeader = header;
                break;
            }
            newColumnPos++;
        }

        // hoverHeader will be null if the drag occurs outside of the
        // tableview. In this case we handle the newColumnPos specially
        // and then short-circuit. This results in the drop action
        // resulting in the correct result (the column will drop at
        // the start or end of the table).
        if (hoverHeader == null) {
            newColumnPos = x &gt; headersWidth ? (getParentHeader().getColumns().size() - 1) : 0;
            return;
        }

        // This is the x-axis value midway through hoverHeader. It's
        // used to determine whether the drop should be to the left
        // or the right of hoverHeader.
        double midPoint = startX + (endX - startX) / 2;
        boolean beforeMidPoint = x &lt;= midPoint;

        // Based on where the mouse actually is, we have to shuffle
        // where we want the column to end up. This code handles that.
        int currentPos = getIndex(getTableColumn());
        newColumnPos += newColumnPos &gt; currentPos &amp;&amp; beforeMidPoint ?
            -1 : (newColumnPos &lt; currentPos &amp;&amp; !beforeMidPoint ? 1 : 0);

        double lineX = getTableHeaderRow().sceneToLocal(hoverHeader.localToScene(hoverHeader.getBoundsInLocal())).getMinX();
        lineX = lineX + ((beforeMidPoint) ? (0) : (hoverHeader.getWidth()));

        if (lineX &gt;= -0.5 &amp;&amp; lineX &lt;= getTableSkin().getSkinnable().getWidth()) {
            columnReorderLine.setTranslateX(lineX);

            // then if this is the first event, we set the property to true
            // so that the line becomes visible until the drop is completed.
            // We also set reordering to true so that the various reordering
            // effects become visible (ghost, transparent overlay, etc).
            columnReorderLine.setVisible(true);
        }

        getTableHeaderRow().setReordering(true);
    }

    // package for testing
    void columnReorderingComplete() {
        if (! getTableColumn().isReorderable()) return;

        // Move col from where it is now to the new position.
        moveColumn(getTableColumn(), newColumnPos);

        // cleanup
        columnReorderLine.setTranslateX(0.0F);
        columnReorderLine.setLayoutX(0.0F);
        newColumnPos = 0;

        getTableHeaderRow().setReordering(false);
        columnReorderLine.setVisible(false);
        getTableHeaderRow().setReorderingColumn(null);
        getTableHeaderRow().setReorderingRegion(null);
        dragOffset = 0.0F;
    }

    double getDragRectHeight() {
        return getHeight();
    }

    // Used to test whether this column header properly represents the given column.
    // In particular, whether it has child column headers for all child columns
    boolean represents(TableColumnBase&lt;?, ?&gt; column) {
        if (!column.getColumns().isEmpty()) {
            // this column has children, but we are in a TableColumnHeader instance,
            // so the match is bad.
            return false;
        }
        return column == getTableColumn();
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
            PseudoClass.getPseudoClass(&quot;last-visible&quot;);

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;TableColumnHeader,Number&gt; SIZE =
            new CssMetaData&lt;TableColumnHeader,Number&gt;(&quot;-fx-size&quot;,
                 SizeConverter.getInstance(), 20.0) {

            @Override
            public boolean isSettable(TableColumnHeader n) {
                return n.size == null || !n.size.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TableColumnHeader n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.sizeProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);

         }
    }

    /**
     * Returnst the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/javafx/fxml/FXMLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.fxml;

import com.sun.javafx.util.Logging;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.regex.Pattern;

import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.Property;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.*;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.util.Builder;
import javafx.util.BuilderFactory;
import javafx.util.Callback;

import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.util.StreamReaderDelegate;

import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.fxml.BeanAdapter;
import com.sun.javafx.fxml.ParseTraceElement;
import com.sun.javafx.fxml.PropertyNotFoundException;
import com.sun.javafx.fxml.expression.Expression;
import com.sun.javafx.fxml.expression.ExpressionValue;
import com.sun.javafx.fxml.expression.KeyPath;
import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
import com.sun.javafx.fxml.FXMLLoaderHelper;
import com.sun.javafx.fxml.MethodHelper;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.EnumMap;
import java.util.Locale;
import java.util.StringTokenizer;
import com.sun.javafx.reflect.ConstructorUtil;
import com.sun.javafx.reflect.MethodUtil;
import com.sun.javafx.reflect.ReflectUtil;

/**
 * Loads an object hierarchy from an XML document.
 * For more information, see the
 * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 * document.
 *
 * @since JavaFX 2.0
 */
public class FXMLLoader {

    // Indicates permission to get the ClassLoader
    private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
        new RuntimePermission(&quot;getClassLoader&quot;);

    // Instance of StackWalker used to get caller class (must be private)
    private static final StackWalker walker =
        AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));

    // Abstract base class for elements
    private abstract class Element {
        public final Element parent;

        public Object value = null;
        private BeanAdapter valueAdapter = null;

        public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();

        public Element() {
            parent = current;
        }

        public boolean isCollection() {
            // Return true if value is a list, or if the value's type defines
            // a default property that is a list
            boolean collection;
            if (value instanceof List&lt;?&gt;) {
                collection = true;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

                if (defaultProperty != null) {
                    collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
                } else {
                    collection = false;
                }
            }

            return collection;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void add(Object element) throws LoadException {
            // If value is a list, add element to it; otherwise, get the value
            // of the default property, which is assumed to be a list and add
            // to that (coerce to the appropriate type)
            List&lt;Object&gt; list;
            if (value instanceof List&lt;?&gt;) {
                list = (List&lt;Object&gt;)value;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
                String defaultPropertyName = defaultProperty.value();

                // Get the list value
                list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);

                // Coerce the element to the list item type
                if (!Map.class.isAssignableFrom(type)) {
                    Type listType = getValueAdapter().getGenericType(defaultPropertyName);
                    element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
                }
            }

            list.add(element);
        }

        public void set(Object value) throws LoadException {
            if (this.value == null) {
                throw constructLoadException(&quot;Cannot set value on this element.&quot;);
            }

            // Apply value to this element's properties
            Class&lt;?&gt; type = this.value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
            if (defaultProperty == null) {
                throw constructLoadException(&quot;Element does not define a default property.&quot;);
            }

            getProperties().put(defaultProperty.value(), value);
        }

        public void updateValue(Object value) {
            this.value = value;
            valueAdapter = null;
        }

        public boolean isTyped() {
            return !(value instanceof Map&lt;?, ?&gt;);
        }

        public BeanAdapter getValueAdapter() {
            if (valueAdapter == null) {
                valueAdapter = new BeanAdapter(value);
            }

            return valueAdapter;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Map&lt;String, Object&gt; getProperties() {
            return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
        }

        public void processStartElement() throws IOException {
            for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
                String prefix = xmlStreamReader.getAttributePrefix(i);
                String localName = xmlStreamReader.getAttributeLocalName(i);
                String value = xmlStreamReader.getAttributeValue(i);

                if (loadListener != null
                    &amp;&amp; prefix != null
                    &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                    loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
                }

                processAttribute(prefix, localName, value);
            }
        }

        public void processEndElement() throws IOException {
            // No-op
        }

        public void processCharacters() throws IOException {
            throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
        }

        public void processInstancePropertyAttributes() throws IOException {
            if (instancePropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : instancePropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }
        }

        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix == null) {
                // Add the attribute to the appropriate list
                if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
                    if (loadListener != null) {
                        loadListener.readEventHandlerAttribute(localName, value);
                    }

                    eventHandlerAttributes.add(new Attribute(localName, null, value));
                } else {
                    int i = localName.lastIndexOf('.');

                    if (i == -1) {
                        // The attribute represents an instance property
                        if (loadListener != null) {
                            loadListener.readPropertyAttribute(localName, null, value);
                        }

                        instancePropertyAttributes.add(new Attribute(localName, null, value));
                    } else {
                        // The attribute represents a static property
                        String name = localName.substring(i + 1);
                        Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                        if (sourceType != null) {
                            if (loadListener != null) {
                                loadListener.readPropertyAttribute(name, sourceType, value);
                            }

                            staticPropertyAttributes.add(new Attribute(name, sourceType, value));
                        } else if (staticLoad) {
                            if (loadListener != null) {
                                loadListener.readUnknownStaticPropertyAttribute(localName, value);
                            }
                        } else {
                            throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
                        }
                    }

                }
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void processPropertyAttribute(Attribute attribute) throws IOException {
            String value = attribute.value;
            if (isBindingExpression(value)) {
                // Resolve the expression
                Expression expression;

                if (attribute.sourceType != null) {
                    throw constructLoadException(&quot;Cannot bind to static property.&quot;);
                }

                if (!isTyped()) {
                    throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
                }

                // TODO We may want to identify binding properties in processAttribute()
                // and apply them after build() has been called
                if (this.value instanceof Builder) {
                    throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
                }

                if (!isStaticLoad()) {
                    value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
                            value.length() - 1);
                    expression = Expression.valueOf(value);

                    // Create the binding
                    BeanAdapter targetAdapter = new BeanAdapter(this.value);
                    ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
                    Class&lt;?&gt; type = targetAdapter.getType(attribute.name);

                    if (propertyModel instanceof Property&lt;?&gt;) {
                        ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
                    }
                }
            } else if (isBidirectionalBindingExpression(value)) {
                throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
            } else {
                processValue(attribute.sourceType, attribute.name, value);
            }
        }

        private boolean isBindingExpression(String aValue) {
            return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
                   &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
        }

        private boolean isBidirectionalBindingExpression(String aValue) {
            return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
        }

        private boolean processValue(Class sourceType, String propertyName, String aValue)
            throws LoadException {

            boolean processed = false;
                //process list or array first
                if (sourceType == null &amp;&amp; isTyped()) {
                    BeanAdapter valueAdapter = getValueAdapter();
                    Class&lt;?&gt; type = valueAdapter.getType(propertyName);

                    if (type == null) {
                        throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
                            + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
                    }

                    if (List.class.isAssignableFrom(type)
                        &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
                        populateListFromString(valueAdapter, propertyName, aValue);
                        processed = true;
                    } else if (type.isArray()) {
                        applyProperty(propertyName, sourceType,
                                populateArrayFromString(type, aValue));
                        processed = true;
                    }
                }
                if (!processed) {
                    applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
                    processed = true;
                }
                return processed;
        }

        /**
         * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
         */
        private Object resolvePrefixedValue(String aValue) throws LoadException {
            if (aValue.startsWith(ESCAPE_PREFIX)) {
                aValue = aValue.substring(ESCAPE_PREFIX.length());

                if (aValue.length() == 0
                    || !(aValue.startsWith(ESCAPE_PREFIX)
                        || aValue.startsWith(RELATIVE_PATH_PREFIX)
                        || aValue.startsWith(RESOURCE_KEY_PREFIX)
                        || aValue.startsWith(EXPRESSION_PREFIX)
                        || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
                    throw constructLoadException(&quot;Invalid escape sequence.&quot;);
                }
                return aValue;
            } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing relative path.&quot;);
                }
                if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
                    return aValue;
                } else {
                        if (aValue.charAt(0) == '/') {
                            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                            final URL res = getClassLoader().getResource(aValue.substring(1));
                            if (res == null) {
                                throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
                            }
                            return res.toString();
                        } else {
                            try {
                                return new URL(FXMLLoader.this.location, aValue).toString();
                            } catch (MalformedURLException e) {
                                System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
                            }
                        }
                }
            } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing resource key.&quot;);
                }
                if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
                    return aValue;
                } else {
                    // Resolve the resource value
                    if (resources == null) {
                        throw constructLoadException(&quot;No resources specified.&quot;);
                    }
                    if (!resources.containsKey(aValue)) {
                        throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
                    }

                    return resources.getString(aValue);
                }
            } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
                aValue = aValue.substring(EXPRESSION_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression.&quot;);
                }
                if (aValue.startsWith(EXPRESSION_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
                    return aValue;
                } else if (aValue.equals(NULL_KEYWORD)) {
                    // The attribute value is null
                    return null;
                }
                return Expression.get(namespace, KeyPath.parse(aValue));
            }
            return aValue;
        }

        /**
         * Creates an array of given type and populates it with values from
         * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
         * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
         * the array becomes relative to document location.
         */
        private Object populateArrayFromString(
                Class&lt;?&gt;type,
                String stringValue) throws LoadException {

            Object propertyValue = null;
            // Split the string and set the values as an array
            Class&lt;?&gt; componentType = type.getComponentType();

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
                propertyValue = Array.newInstance(componentType, values.length);
                for (int i = 0; i &lt; values.length; i++) {
                    Array.set(propertyValue, i,
                            BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
                            type.getComponentType()));
                }
            } else {
                propertyValue = Array.newInstance(componentType, 0);
            }
            return propertyValue;
        }

        /**
         * Populates list with values from a string where tokens are separated
         * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
         * a value added to the list becomes relative to document location.
         */
        private void populateListFromString(
                BeanAdapter valueAdapter,
                String listPropertyName,
                String stringValue) throws LoadException {
            // Split the string and add the values to the list
            List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
            Type listType = valueAdapter.getGenericType(listPropertyName);
            Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);

            if (itemType instanceof ParameterizedType) {
                itemType = ((ParameterizedType)itemType).getRawType();
            }

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);

                for (String aValue: values) {
                    aValue = aValue.trim();
                    list.add(
                            BeanAdapter.coerce(resolvePrefixedValue(aValue),
                                               (Class&lt;?&gt;)itemType));
                }
            }
        }

        public void warnDeprecatedEscapeSequence(String prefix) {
            System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
                + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
        }

        public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
            if (sourceType == null) {
                getProperties().put(name, value);
            } else {
                BeanAdapter.put(this.value, sourceType, name, value);
            }
        }

        private Object getExpressionObject(String handlerValue) throws LoadException{
            if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());

                if (handlerValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression reference.&quot;);
                }

                Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
                if (expression == null) {
                    throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
                }
                return expression;
            }
            return null;
        }

        private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
            Object expression = getExpressionObject(handlerValue);
            if (expression != null) {
                if (type.isInstance(expression)) {
                    return (T) expression;
                }
                throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
                        + &quot;Does not point to a &quot; + type.getName());
            }
            return null;
        }

        private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
            if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());

                if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    if (handlerName.length() == 0) {
                        throw constructLoadException(&quot;Missing controller method.&quot;);
                    }

                    if (controller == null) {
                        throw constructLoadException(&quot;No controller specified.&quot;);
                    }

                    for (SupportedType t : types) {
                        Method method = controllerAccessor
                                            .getControllerMethods()
                                            .get(t)
                                            .get(handlerName);
                        if (method != null) {
                            return new MethodHandler(controller, method, t);
                        }
                    }
                    Method method = controllerAccessor
                                        .getControllerMethods()
                                        .get(SupportedType.PARAMETERLESS)
                                        .get(handlerName);
                    if (method != null) {
                        return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
                    }

                    return null;

                }

            }
            return null;
        }

        public void processEventHandlerAttributes() throws LoadException {
            if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
                for (Attribute attribute : eventHandlerAttributes) {
                    String handlerName = attribute.value;
                    if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableListHandler(handlerName);
                    } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableMapHandler(handlerName);
                    } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableSetHandler(handlerName);
                    } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
                        processPropertyHandler(attribute.name, handlerName);
                    } else {
                        EventHandler&lt;? extends Event&gt; eventHandler = null;
                        MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
                        if (handler != null) {
                            eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
                        }

                        if (eventHandler == null) {
                            eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
                        }

                        if (eventHandler == null) {
                            if (handlerName.length() == 0 || scriptEngine == null) {
                                throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;='&quot; + attribute.value
                                        + &quot;', either the event handler is not in the Namespace or there is an error in the script.&quot;);
                            }

                            eventHandler = new ScriptEventHandler(handlerName, scriptEngine);
                        }

                        // Add the handler
                        getValueAdapter().put(attribute.name, eventHandler);
                    }
                }
            }
        }

        private void processObservableListHandler(String handlerValue) throws LoadException {
            ObservableList list = (ObservableList)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
                if (handler != null) {
                    list.addListener(new ObservableListChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                   if (listener instanceof ListChangeListener) {
                    list.addListener((ListChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    list.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableMapHandler(String handlerValue) throws LoadException {
            ObservableMap map = (ObservableMap)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
                if (handler != null) {
                    map.addListener(new ObservableMapChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof MapChangeListener) {
                    map.addListener((MapChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    map.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableSetHandler(String handlerValue) throws LoadException {
            ObservableSet set = (ObservableSet)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
                if (handler != null) {
                    set.addListener(new ObservableSetChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof SetChangeListener) {
                    set.addListener((SetChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    set.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {
            int i = EVENT_HANDLER_PREFIX.length();
            int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();

            if (i != j) {
                String key = Character.toLowerCase(attributeName.charAt(i))
                        + attributeName.substring(i + 1, j);

                ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
                if (propertyModel == null) {
                    throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
                            + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
                }

                if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
                    if (handler != null) {
                        if (handler.type == SupportedType.EVENT) {
                            // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
                            // has been used instead of usual property change parameters
                            propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
                                @Override
                                public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
                                    handler.invoke(new Event(value, null, Event.ANY));
                                }
                            });
                        } else {
                            propertyModel.addListener(new PropertyChangeAdapter(handler));
                        }
                    } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                    }
                } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                    Object listener = getExpressionObject(handlerValue);
                    if (listener instanceof ChangeListener) {
                        propertyModel.addListener((ChangeListener) listener);
                    } else if (listener instanceof InvalidationListener) {
                        propertyModel.addListener((InvalidationListener) listener);
                    } else {
                        throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                                + &quot;Must be either ChangeListener or InvalidationListener&quot;);
                    }
                }

            }
        }
    }

    // Element representing a value
    private abstract class ValueElement extends Element {
        public String fx_id = null;

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            updateValue(constructValue());

            if (value instanceof Builder&lt;?&gt;) {
                processInstancePropertyAttributes();
            } else {
                processValue();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processEndElement() throws IOException {
            super.processEndElement();

            // Build the value, if necessary
            if (value instanceof Builder&lt;?&gt;) {
                Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
                updateValue(builder.build());

                processValue();
            } else {
                processInstancePropertyAttributes();
            }

            processEventHandlerAttributes();

            // Process static property attributes
            if (staticPropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : staticPropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }

            // Process static property elements
            if (staticPropertyElements.size() &gt; 0) {
                for (PropertyElement element : staticPropertyElements) {
                    BeanAdapter.put(value, element.sourceType, element.name, element.value);
                }
            }

            if (parent != null) {
                if (parent.isCollection()) {
                    parent.add(value);
                } else {
                    parent.set(value);
                }
            }
        }

        private Object getListValue(Element parent, String listPropertyName, Object value) {
            // If possible, coerce the value to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(listPropertyName);

                if (listType != null) {
                    Type itemType = BeanAdapter.getGenericListItemType(listType);

                    if (itemType instanceof ParameterizedType) {
                        itemType = ((ParameterizedType)itemType).getRawType();
                    }

                    value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
                }
            }

            return value;
        }

        private void processValue() throws LoadException {
            // If this is the root element, update the value
            if (parent == null) {
                root = value;

                // checking version of fx namespace - throw exception if not supported
                String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
                if (fxNSURI != null) {
                    String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
                        throw constructLoadException(&quot;Loading FXML document of version &quot; +
                                fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
                    }
                }

                // checking the version JavaFX API - print warning if not supported
                String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
                if (defaultNSURI != null) {
                    String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
                        Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
                                nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
                    }
                }
            }

            // Add the value to the namespace
            if (fx_id != null) {
                namespace.put(fx_id, value);

                // If the value defines an ID property, set it
                IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);

                if (idProperty != null) {
                    Map&lt;String, Object&gt; properties = getProperties();
                    // set fx:id property value to Node.id only if Node.id was not
                    // already set when processing start element attributes
                    if (properties.get(idProperty.value()) == null) {
                        properties.put(idProperty.value(), fx_id);
                    }
                }

                // Set the controller field value
                injectFields(fx_id, value);
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processCharacters() throws LoadException {
            Class&lt;?&gt; type = value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

            // If the default property is a read-only list, add the value to it;
            // otherwise, set the value as the default property
            if (defaultProperty != null) {
                String text = xmlStreamReader.getText();
                text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

                String defaultPropertyName = defaultProperty.value();
                BeanAdapter valueAdapter = getValueAdapter();

                if (valueAdapter.isReadOnly(defaultPropertyName)
                    &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
                    List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
                    list.add(getListValue(this, defaultPropertyName, text));
                } else {
                    valueAdapter.put(defaultPropertyName, text.trim());
                }
            } else {
                throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_ID_ATTRIBUTE)) {
                    // Verify that ID is a valid identifier
                    if (value.equals(NULL_KEYWORD)) {
                        throw constructLoadException(&quot;Invalid identifier.&quot;);
                    }

                    for (int i = 0, n = value.length(); i &lt; n; i++) {
                        if (!Character.isJavaIdentifierPart(value.charAt(i))) {
                            throw constructLoadException(&quot;Invalid identifier.&quot;);
                        }
                    }

                    fx_id = value;

                } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
                    if (current.parent != null) {
                        throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
                            + &quot; can only be applied to root element.&quot;);
                    }

                    if (controller != null) {
                        throw constructLoadException(&quot;Controller value already specified.&quot;);
                    }

                    if (!staticLoad) {
                        Class&lt;?&gt; type;
                        try {
                            type = getClassLoader().loadClass(value);
                        } catch (ClassNotFoundException exception) {
                            throw constructLoadException(exception);
                        }

                        try {
                            if (controllerFactory == null) {
                                ReflectUtil.checkPackageAccess(type);
                                setController(type.newInstance());
                            } else {
                                setController(controllerFactory.call(type));
                            }
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                } else {
                    throw constructLoadException(&quot;Invalid attribute.&quot;);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        public abstract Object constructValue() throws IOException;
    }

    // Element representing a class instance
    private class InstanceDeclarationElement extends ValueElement {
        public Class&lt;?&gt; type;

        public String constant = null;
        public String factory = null;

        public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
            this.type = type;
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_VALUE_ATTRIBUTE)) {
                    this.value = value;
                } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
                    constant = value;
                } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
                    factory = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            Object value;
            if (this.value != null) {
                value = BeanAdapter.coerce(this.value, type);
            } else if (constant != null) {
                value = BeanAdapter.getConstantValue(type, constant);
            } else if (factory != null) {
                Method factoryMethod;
                try {
                    factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
                } catch (NoSuchMethodException exception) {
                    throw constructLoadException(exception);
                }

                try {
                    value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                if (value == null) {
                    value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                }

                if (value == null) {
                    try {
                        ReflectUtil.checkPackageAccess(type);
                        value = type.newInstance();
<A NAME="12"></A>                    } catch (InstantiationException exception) {
                        throw constructLoadException(exception);
                    } catch (IllegalAccessException exception) {
                        throw <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#12',2,'match36-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>constructLoadException(exception);
                    }
                }
            }</B></FONT>

            return value;
        }
    }

    // Element representing an unknown type
    private class UnknownTypeElement extends ValueElement {
        // Map type representing an unknown value
        @DefaultProperty(&quot;items&quot;)
        public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
            private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
            private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();

            @Override
            public Object get(Object key) {
                if (key == null) {
                    throw new NullPointerException();
                }

                return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
                    items : values.get(key);
            }

            @Override
            public Object put(String key, Object value) {
                if (key == null) {
                    throw new NullPointerException();
                }

                if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
                    throw new IllegalArgumentException();
                }

                return values.put(key, value);
            }

            @Override
            public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
                return Collections.emptySet();
            }
        }

        @Override
        public void processEndElement() throws IOException {
            // No-op
        }

        @Override
        public Object constructValue() throws LoadException {
            return new UnknownValueMap();
        }
    }

    // Element representing an include
    private class IncludeElement extends ValueElement {
        public String source = null;
        public ResourceBundle resources = FXMLLoader.this.resources;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    resources = ResourceBundle.getBundle(value, Locale.getDefault(),
                            FXMLLoader.this.resources.getClass().getClassLoader());
                } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    charset = Charset.forName(value);
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            if (source == null) {
                throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            URL location;
            final ClassLoader cl = getClassLoader();
            if (source.charAt(0) == '/') {
            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                location = cl.getResource(source.substring(1));
                if (location == null) {
                    throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
                }
            } else {
                if (FXMLLoader.this.location == null) {
                    throw constructLoadException(&quot;Base location is undefined.&quot;);
                }

                location = new URL(FXMLLoader.this.location, source);
            }

            FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
                builderFactory, controllerFactory, charset,
                loaders);
            fxmlLoader.parentLoader = FXMLLoader.this;

            if (isCyclic(FXMLLoader.this, fxmlLoader)) {
                throw new IOException(
                        String.format(
                        &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
                        fxmlLoader.location.toExternalForm(),
                        FXMLLoader.this.location.toExternalForm()));
            }
            fxmlLoader.setClassLoader(cl);
            fxmlLoader.setStaticLoad(staticLoad);

            Object value = fxmlLoader.loadImpl(callerClass);

            if (fx_id != null) {
                String id = this.fx_id + CONTROLLER_SUFFIX;
                Object controller = fxmlLoader.getController();

                namespace.put(id, controller);
                injectFields(id, controller);
            }

            return value;
        }
    }

    private void injectFields(String fieldName, Object value) throws LoadException {
        if (controller != null &amp;&amp; fieldName != null) {
            List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
            if (fields != null) {
                try {
                    for (Field f : fields) {
                        f.set(controller, value);
                    }
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                }
            }
        }
    }

    // Element representing a reference
    private class ReferenceElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            return Expression.get(namespace, path);
        }
    }

    // Element representing a copy
    private class CopyElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            Object sourceValue = Expression.get(namespace, path);
            Class&lt;?&gt; sourceValueType = sourceValue.getClass();

            Constructor&lt;?&gt; constructor = null;
            try {
                constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            Object value;
            if (constructor != null) {
                try {
                    ReflectUtil.checkPackageAccess(sourceValueType);
                    value = constructor.newInstance(sourceValue);
                } catch (InstantiationException exception) {
                    throw constructLoadException(exception);
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                throw constructLoadException(&quot;Can't copy value &quot; + sourceValue + &quot;.&quot;);
            }

            return value;
        }
    }

    // Element representing a predefined root value
    private class RootElement extends ValueElement {
        public String type = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    type = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (type == null) {
                throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
            }

            Class&lt;?&gt; type = getType(this.type);

            if (type == null) {
                throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
            }

            Object value;
            if (root == null) {
                if (staticLoad) {
                    value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                    if (value == null) {
                        value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                    }

                    if (value == null) {
                        try {
                            ReflectUtil.checkPackageAccess(type);
                            value = type.newInstance();
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                    root = value;
                } else {
                    throw constructLoadException(&quot;Root hasn't been set. Use method setRoot() before load.&quot;);
                }
            } else {
                if (!type.isAssignableFrom(root.getClass())) {
                    throw constructLoadException(&quot;Root is not an instance of &quot;
                        + type.getName() + &quot;.&quot;);
                }

                value = root;
            }

            return value;
        }
    }

    // Element representing a property
    private class PropertyElement extends Element {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final boolean readOnly;

        public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }

            this.name = name;
            this.sourceType = sourceType;

            if (sourceType == null) {
                // The element represents an instance property
                if (name.startsWith(EVENT_HANDLER_PREFIX)) {
                    throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
                }

                Map&lt;String, Object&gt; parentProperties = parent.getProperties();

                if (parent.isTyped()) {
                    readOnly = parent.getValueAdapter().isReadOnly(name);
                } else {
                // If the map already defines a value for the property, assume
                    // that it is read-only
                    readOnly = parentProperties.containsKey(name);
                }

                if (readOnly) {
                    Object value = parentProperties.get(name);
                    if (value == null) {
                        throw constructLoadException(&quot;Invalid property.&quot;);
                    }

                    updateValue(value);
                }
            } else {
                // The element represents a static property
                readOnly = false;
            }
        }

<A NAME="18"></A>        @Override
        public boolean isCollection() {
            return (readOnly) ? super.isCollection() : false;
        <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#18',2,'match36-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        @Override
        public void add(Object element) throws LoadException {
            // Coerce the element to the list item type
            if (parent.isTyped()) {</B></FONT>
                Type listType = parent.getValueAdapter().getGenericType(name);
                element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
            }

            // Add the item to the list
            super.add(element);
        }

        @Override
        public void set(Object value) throws LoadException {
            // Update the value
            updateValue(value);

            if (sourceType == null) {
                // Apply value to parent element's properties
                parent.getProperties().put(name, value);
            } else {
                if (parent.value instanceof Builder) {
                    // Defer evaluation of the property
                    parent.staticPropertyElements.add(this);
                } else {
                    // Apply the static property value
                    BeanAdapter.put(parent.value, sourceType, name, value);
                }
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (!readOnly) {
                throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
            }

            super.processAttribute(prefix, localName, value);
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (readOnly) {
                processInstancePropertyAttributes();
                processEventHandlerAttributes();
            }
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();

            if (readOnly) {
                if (isCollection()) {
                    add(text);
                } else {
                    super.processCharacters();
                }
            } else {
                set(text);
            }
        }
    }

    // Element representing an unknown static property
    private class UnknownStaticPropertyElement extends Element {
        public UnknownStaticPropertyElement() throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }
        }

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void set(Object value) {
            updateValue(value);
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

            updateValue(text.trim());
        }
    }

    // Element representing a script block
    private class ScriptElement extends Element {
        public String source = null;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            if (source != null &amp;&amp; !staticLoad) {
                int i = source.lastIndexOf(&quot;.&quot;);
                if (i == -1) {
                    throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
                        + source + &quot;\&quot;.&quot;);
                }

                String extension = source.substring(i + 1);
                ScriptEngine engine;
                final ClassLoader cl = getClassLoader();
                if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
                    // If we have a page language and it's engine supports the extension, use the same engine
                    engine = scriptEngine;
                } else {
                    ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
                    try {
                        Thread.currentThread().setContextClassLoader(cl);
                        ScriptEngineManager scriptEngineManager = getScriptEngineManager();
                        engine = scriptEngineManager.getEngineByExtension(extension);
                    } finally {
                        Thread.currentThread().setContextClassLoader(oldLoader);
                    }
                }

                if (engine == null) {
                    throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
                        + &quot; extension &quot; + extension + &quot;.&quot;);
                }

                try {
                    URL location;
                    if (source.charAt(0) == '/') {
                        // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                        location = cl.getResource(source.substring(1));
                    } else {
                        if (FXMLLoader.this.location == null) {
                            throw constructLoadException(&quot;Base location is undefined.&quot;);
                        }

                        location = new URL(FXMLLoader.this.location, source);
                    }

                    InputStreamReader scriptReader = null;
                    try {
                        scriptReader = new InputStreamReader(location.openStream(), charset);
                        engine.eval(scriptReader);
                    } catch(ScriptException exception) {
                        exception.printStackTrace();
                    } finally {
                        if (scriptReader != null) {
                            scriptReader.close();
                        }
                    }
                } catch (IOException exception) {
                    throw constructLoadException(exception);
                }
            }
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (value != null &amp;&amp; !staticLoad) {
                // Evaluate the script
                try {
                    scriptEngine.eval((String)value);
                } catch (ScriptException exception) {
                    System.err.println(exception.getMessage());
                }
            }
        }

        @Override
        public void processCharacters() throws LoadException {
            if (source != null) {
                throw constructLoadException(&quot;Script source already specified.&quot;);
            }

            if (scriptEngine == null &amp;&amp; !staticLoad) {
                throw constructLoadException(&quot;Page language not specified.&quot;);
            }

            updateValue(xmlStreamReader.getText());
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null
                &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                source = value;
            } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                charset = Charset.forName(value);
            } else {
                throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }
    }

    // Element representing a define block
    private class DefineElement extends Element {
        @Override
        public boolean isCollection() {
            return true;
        }

        @Override
        public void add(Object element) {
            // No-op
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws LoadException{
            throw constructLoadException(&quot;Element does not support attributes.&quot;);
        }
    }

    // Class representing an attribute of an element
    private static class Attribute {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final String value;

        public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
            this.name = name;
            this.sourceType = sourceType;
            this.value = value;
        }
    }

    // Event handler that delegates to a method defined by the controller object
    private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
        private final MethodHandler handler;

        public ControllerMethodEventHandler(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void handle(T event) {
            handler.invoke(event);
        }
    }

    // Event handler implemented in script code
    private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
        public final String script;
        public final ScriptEngine scriptEngine;

        public ScriptEventHandler(String script, ScriptEngine scriptEngine) {
            this.script = script;
            this.scriptEngine = scriptEngine;
        }

        @Override
        public void handle(Event event) {
            // Don't pollute the page namespace with values defined in the script
            Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
            Bindings localBindings = scriptEngine.createBindings();
            localBindings.put(EVENT_KEY, event);
            localBindings.putAll(engineBindings);
            scriptEngine.setBindings(localBindings, ScriptContext.ENGINE_SCOPE);

            // Execute the script
            try {
                scriptEngine.eval(script);
            } catch (ScriptException exception){
                throw new RuntimeException(exception);
            }

            // Restore the original bindings
            scriptEngine.setBindings(engineBindings, ScriptContext.ENGINE_SCOPE);
        }
    }

    // Observable list change listener
    private static class ObservableListChangeAdapter implements ListChangeListener {
        private final MethodHandler handler;

        public ObservableListChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable map change listener
    private static class ObservableMapChangeAdapter implements MapChangeListener {
        public final MethodHandler handler;

        public ObservableMapChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable set change listener
    private static class ObservableSetChangeAdapter implements SetChangeListener {
        public final MethodHandler handler;

        public ObservableSetChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Property model change listener
    private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
        public final MethodHandler handler;

        public PropertyChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
            handler.invoke(observable, oldValue, newValue);
        }
    }

    private static class MethodHandler {
        private final Object controller;
        private final Method method;
        private final SupportedType type;

        private MethodHandler(Object controller, Method method, SupportedType type) {
            this.method = method;
            this.controller = controller;
            this.type = type;
        }

        public void invoke(Object... params) {
            try {
                if (type != SupportedType.PARAMETERLESS) {
                    MethodHelper.invoke(method, controller, params);
                } else {
                    MethodHelper.invoke(method, controller, new Object[] {});
                }
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            }
        }
    }

    private URL location;
    private ResourceBundle resources;

    private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();

    private Object root = null;
    private Object controller = null;

    private BuilderFactory builderFactory;
    private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
    private Charset charset;

    private final LinkedList&lt;FXMLLoader&gt; loaders;

    private ClassLoader classLoader = null;
    private boolean staticLoad = false;
    private LoadListener loadListener = null;

    private FXMLLoader parentLoader;

    private XMLStreamReader xmlStreamReader = null;
    private Element current = null;

    private ScriptEngine scriptEngine = null;

    private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
    private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();

    private ScriptEngineManager scriptEngineManager = null;

    private static ClassLoader defaultClassLoader = null;

    private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);

    private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();

    /**
     * The character set used when character set is not explicitly specified.
     */
    public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;

    /**
     * The tag name of language processing instruction.
     */
    public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
    /**
     * The tag name of import processing instruction.
     */
    public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;

    /**
     * Prefix of 'fx' namespace.
     */
    public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
    /**
     * The name of fx:controller attribute of a root.
     */
    public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
    /**
     * The name of fx:id attribute.
     */
    public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
    /**
     * The name of fx:value attribute.
     */
    public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
    /**
     * The tag name of 'fx:constant'.
     * @since JavaFX 2.2
     */
    public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
    /**
     * The name of 'fx:factory' attribute.
     */
    public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;

    /**
     * The tag name of {@literal &lt;fx:include&gt;}.
     */
    public static final String INCLUDE_TAG = &quot;include&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'source' attribute.
     */
    public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'resources' attribute.
     */
    public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'charset' attribute.
     */
    public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:script&gt;}.
     */
    public static final String SCRIPT_TAG = &quot;script&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'source' attribute.
     */
    public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'charset' attribute.
     */
    public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:define&gt;}.
     */
    public static final String DEFINE_TAG = &quot;define&quot;;

    /**
     * The tag name of {@literal &lt;fx:reference&gt;}.
     */
    public static final String REFERENCE_TAG = &quot;reference&quot;;
    /**
     * The {@literal &lt;fx:reference&gt;} 'source' attribute.
     */
    public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The tag name of {@literal &lt;fx:root&gt;}.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TAG = &quot;root&quot;;
    /**
     * The {@literal &lt;fx:root&gt;} 'type' attribute.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;

    /**
     * The tag name of {@literal &lt;fx:copy&gt;}.
     */
    public static final String COPY_TAG = &quot;copy&quot;;
    /**
     * The {@literal &lt;fx:copy&gt;} 'source' attribute.
     */
    public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The prefix of event handler attributes.
     */
    public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
    /**
     * The name of the Event object in event handler scripts.
     */
    public static final String EVENT_KEY = &quot;event&quot;;
    /**
     * Suffix for property change/invalidation handlers.
     */
    public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
    private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;

    /**
     * Value that represents 'null'.
     */
    public static final String NULL_KEYWORD = &quot;null&quot;;

    /**
     * Escape prefix for escaping special characters inside attribute values.
     * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
     * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
     * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
     * @since JavaFX 2.1
     */
    public static final String ESCAPE_PREFIX = &quot;\\&quot;;
    /**
     * Prefix for relative location resolution.
     */
    public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
    /**
     * Prefix for resource resolution.
     */
    public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
    /**
     * Prefix for (variable) expression resolution.
     */
    public static final String EXPRESSION_PREFIX = &quot;$&quot;;
    /**
     * Prefix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
    /**
     * Suffix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;

    /**
     * Prefix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
    /**
     * Suffix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;

    /**
     * Delimiter for arrays as values.
     * @since JavaFX 2.1
     */
    public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;

    /**
     * A key for location URL in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String LOCATION_KEY = &quot;location&quot;;
    /**
     * A key for ResourceBundle in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String RESOURCES_KEY = &quot;resources&quot;;

    /**
     * Prefix for controller method resolution.
     */
    public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
    /**
     * A key for controller in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.1
     */
    public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
    /**
     * A suffix for controllers of included fxml files.
     * The full key is stored in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;

    /**
     * The name of initialize method.
     * @since JavaFX 2.2
     */
    public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;

    /**
     * Contains the current javafx version.
     * @since JavaFX 8.0
     */
    public static final String JAVAFX_VERSION;

    /**
     * Contains the current fx namepsace version.
     * @since JavaFX 8.0
     */
    public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;

    static {
        JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            @Override
            public String run() {
                return System.getProperty(&quot;javafx.version&quot;);
            }
        });

        FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
            @Override
            public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
                fxmlLoader.setStaticLoad(staticLoad);
            }
        });
    }

    /**
     * Creates a new FXMLLoader instance.
     */
    public FXMLLoader() {
        this((URL)null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location) {
        this(location, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources) {
        this(location, resources, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
        this(location, resources, builderFactory, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param charset the character set used by this loader
     */
    public FXMLLoader(Charset charset) {
        this(null, null, null, null, charset);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
        this(location, resources, builderFactory, controllerFactory, charset,
            new LinkedList&lt;FXMLLoader&gt;());
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @param loaders list of loaders
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
        LinkedList&lt;FXMLLoader&gt; loaders) {
        setLocation(location);
        setResources(resources);
        setBuilderFactory(builderFactory);
        setControllerFactory(controllerFactory);
        setCharset(charset);

        this.loaders = new LinkedList(loaders);
    }

    /**
     * Returns the location used to resolve relative path attribute values.
     * @return the location used to resolve relative path attribute values
     */
    public URL getLocation() {
        return location;
    }

    /**
     * Sets the location used to resolve relative path attribute values.
     *
     * @param location the location
     */
    public void setLocation(URL location) {
        this.location = location;
    }

    /**
     * Returns the resources used to resolve resource key attribute values.
     * @return the resources used to resolve resource key attribute values
     */
    public ResourceBundle getResources() {
        return resources;
    }

    /**
     * Sets the resources used to resolve resource key attribute values.
     *
     * @param resources the resources
     */
    public void setResources(ResourceBundle resources) {
        this.resources = resources;
    }

    /**
     * Returns the namespace used by this loader.
     * @return the namespace
     */
    public ObservableMap&lt;String, Object&gt; getNamespace() {
        return namespace;
    }

    /**
     * Returns the root of the object hierarchy.
     * @param &lt;T&gt; the type of the root object
     * @return the root of the object hierarchy
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getRoot() {
        return (T)root;
    }

    /**
     * Sets the root of the object hierarchy. The value passed to this method
     * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
     * must be called prior to loading the document when using
     * {@code &lt;fx:root&gt;}.
     *
     * @param root the root of the object hierarchy
     *
     * @since JavaFX 2.2
     */
    public void setRoot(Object root) {
        this.root = root;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof FXMLLoader) {
            FXMLLoader loader = (FXMLLoader)obj;
            if (location == null || loader.location == null) {
                return loader.location == location;
            }
            return location.toExternalForm().equals(
                    loader.location.toExternalForm());
        }
        return false;
    }

    private boolean isCyclic(
                            FXMLLoader currentLoader,
                            FXMLLoader node) {
        if (currentLoader == null) {
            return false;
        }
        if (currentLoader.equals(node)) {
            return true;
        }
        return isCyclic(currentLoader.parentLoader, node);
    }

    /**
     * Returns the controller associated with the root object.
     * @param &lt;T&gt; the type of the controller
     * @return the controller associated with the root object
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getController() {
        return (T)controller;
    }

    /**
     * Sets the controller associated with the root object. The value passed to
     * this method is used as the value of the {@code fx:controller} attribute.
     * This method must be called prior to loading the document when using
     * controller event handlers when an {@code fx:controller} attribute is not
     * specified in the document.
     *
     * @param controller the controller to associate with the root object
     *
     * @since JavaFX 2.2
     */
    public void setController(Object controller) {
        this.controller = controller;

        if (controller == null) {
            namespace.remove(CONTROLLER_KEYWORD);
        } else {
            namespace.put(CONTROLLER_KEYWORD, controller);
        }

        controllerAccessor.setController(controller);
    }

    /**
     * Returns the builder factory used by this loader.
     * @return the builder factory
     */
    public BuilderFactory getBuilderFactory() {
        return builderFactory;
    }

    /**
     * Sets the builder factory used by this loader.
     *
     * @param builderFactory the builder factory
     */
    public void setBuilderFactory(BuilderFactory builderFactory) {
        this.builderFactory = builderFactory;
    }

    /**
     * Returns the controller factory used by this loader.
     * @return the controller factory
     * @since JavaFX 2.1
     */
    public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
        return controllerFactory;
    }

    /**
     * Sets the controller factory used by this loader.
     *
     * @param controllerFactory the controller factory
     * @since JavaFX 2.1
     */
    public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this.controllerFactory = controllerFactory;
    }

    /**
     * Returns the character set used by this loader.
     * @return the character set
     */
    public Charset getCharset() {
        return charset;
    }

    /**
     * Sets the character set used by this loader.
     *
     * @param charset the character set
     * @since JavaFX 2.1
     */
    public void setCharset(Charset charset) {
        if (charset == null) {
            throw new NullPointerException(&quot;charset is null.&quot;);
        }

        this.charset = charset;
    }

    /**
     * Returns the classloader used by this loader.
     * @return the classloader
     * @since JavaFX 2.1
     */
    public ClassLoader getClassLoader() {
        if (classLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            final Class caller = (sm != null) ?
                    walker.getCallerClass() :
                    null;
            return getDefaultClassLoader(caller);
        }
        return classLoader;
    }

    /**
     * Sets the classloader used by this loader and clears any existing
     * imports.
     *
     * @param classLoader the classloader
     * @since JavaFX 2.1
     */
    public void setClassLoader(ClassLoader classLoader) {
        if (classLoader == null) {
            throw new IllegalArgumentException();
        }

        this.classLoader = classLoader;

        clearImports();
    }

    /*
     * Returns the static load flag.
     */
    boolean isStaticLoad() {
        // SB-dependency: RT-21226 has been filed to track this
        return staticLoad;
    }

    /*
     * Sets the static load flag.
     *
     * @param staticLoad
     */
    void setStaticLoad(boolean staticLoad) {
        // SB-dependency: RT-21226 has been filed to track this
        this.staticLoad = staticLoad;
    }

    /**
     * Returns this loader's load listener.
     *
     * @return the load listener
     *
     * @since 9
     */
    public LoadListener getLoadListener() {
        // SB-dependency: RT-21228 has been filed to track this
        return loadListener;
    }

    /**
     * Sets this loader's load listener.
     *
     * @param loadListener the load listener
     *
     * @since 9
     */
    public final void setLoadListener(LoadListener loadListener) {
        // SB-dependency: RT-21228 has been filed to track this
        this.loadListener = loadListener;
    }

    /**
     * Loads an object hierarchy from a FXML document. The location from which
     * the document will be loaded must have been set by a prior call to
     * {@link #setLocation(URL)}.
     *
     * @param &lt;T&gt; the type of the root object
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public &lt;T&gt; T load() throws IOException {
        return loadImpl((System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param inputStream an input stream containing the FXML data to load
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public &lt;T&gt; T load(InputStream inputStream) throws IOException {
        return loadImpl(inputStream, (System.getSecurityManager() != null)
                                         ? walker.getCallerClass()
                                         : null);
    }

    private Class&lt;?&gt; callerClass;

    private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
        if (location == null) {
            throw new IllegalStateException(&quot;Location is not set.&quot;);
        }

        InputStream inputStream = null;
        T value;
        try {
            inputStream = location.openStream();
            value = loadImpl(inputStream, callerClass);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return value;
    }

    @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
    private &lt;T&gt; T loadImpl(InputStream inputStream,
                           Class&lt;?&gt; callerClass) throws IOException {
        if (inputStream == null) {
            throw new NullPointerException(&quot;inputStream is null.&quot;);
        }

        this.callerClass = callerClass;
        controllerAccessor.setCallerClass(callerClass);
        try {
            clearImports();

            // Initialize the namespace
            namespace.put(LOCATION_KEY, location);
            namespace.put(RESOURCES_KEY, resources);

            // Clear the script engine
            scriptEngine = null;

            // Create the parser
            try {
                XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);

                // Some stream readers incorrectly report an empty string as the prefix
                // for the default namespace; correct this as needed
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
                xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
                    @Override
                    public String getPrefix() {
                        String prefix = super.getPrefix();

                        if (prefix != null
                            &amp;&amp; prefix.length() == 0) {
                            prefix = null;
                        }

                        return prefix;
                    }

                    @Override
                    public String getAttributePrefix(int index) {
                        String attributePrefix = super.getAttributePrefix(index);

                        if (attributePrefix != null
                            &amp;&amp; attributePrefix.length() == 0) {
                            attributePrefix = null;
                        }

                        return attributePrefix;
                    }
                };
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            // Push this loader onto the stack
            loaders.push(this);

            // Parse the XML stream
            try {
                while (xmlStreamReader.hasNext()) {
                    int event = xmlStreamReader.next();

                    switch (event) {
                        case XMLStreamConstants.PROCESSING_INSTRUCTION: {
                            processProcessingInstruction();
                            break;
                        }

                        case XMLStreamConstants.COMMENT: {
                            processComment();
                            break;
                        }

                        case XMLStreamConstants.START_ELEMENT: {
                            processStartElement();
                            break;
                        }

                        case XMLStreamConstants.END_ELEMENT: {
                            processEndElement();
                            break;
                        }

                        case XMLStreamConstants.CHARACTERS: {
                            processCharacters();
                            break;
                        }
                    }
                }
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            if (controller != null) {
                if (controller instanceof Initializable) {
                    ((Initializable)controller).initialize(location, resources);
                } else {
                    // Inject controller fields
                    Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
                            controllerAccessor.getControllerFields();

                    injectFields(LOCATION_KEY, location);

                    injectFields(RESOURCES_KEY, resources);

                    // Initialize the controller
                    Method initializeMethod = controllerAccessor
                                                  .getControllerMethods()
                                                  .get(SupportedType.PARAMETERLESS)
                                                  .get(INITIALIZE_METHOD_NAME);

                    if (initializeMethod != null) {
                        try {
                            MethodHelper.invoke(initializeMethod, controller, new Object [] {});
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        } catch (InvocationTargetException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                }
            }
        } catch (final LoadException exception) {
            throw exception;
        } catch (final Exception exception) {
            throw constructLoadException(exception);
        } finally {
            controllerAccessor.setCallerClass(null);
            // Clear controller accessor caches
            controllerAccessor.reset();
            // Clear the parser
            xmlStreamReader = null;
        }

        return (T)root;
    }

    private void clearImports() {
        packages.clear();
        classes.clear();
    }

    private LoadException constructLoadException(String message){
        return new LoadException(message + constructFXMLTrace());
    }

    private LoadException constructLoadException(Throwable cause) {
        return new LoadException(constructFXMLTrace(), cause);
    }

    private LoadException constructLoadException(String message, Throwable cause){
        return new LoadException(message + constructFXMLTrace(), cause);
    }

    private String constructFXMLTrace() {
        StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);

        for (FXMLLoader loader : loaders) {
            messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);

            if (loader.current != null) {
                messageBuilder.append(&quot;:&quot;);
                messageBuilder.append(loader.getLineNumber());
            }

            messageBuilder.append(&quot;\n&quot;);
        }
        return messageBuilder.toString();
    }

    /**
     * Returns the current line number.
     */
    int getLineNumber() {
        return xmlStreamReader.getLocation().getLineNumber();
    }

    /**
     * Returns the current parse trace.
     */
    ParseTraceElement[] getParseTrace() {
        ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];

        int i = 0;
        for (FXMLLoader loader : loaders) {
            parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
                loader.getLineNumber() : -1);
        }

        return parseTrace;
    }

    private void processProcessingInstruction() throws LoadException {
        String piTarget = xmlStreamReader.getPITarget().trim();

        if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
            processLanguage();
        } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
            processImport();
        }
    }

    private void processLanguage() throws LoadException {
        if (scriptEngine != null) {
            throw constructLoadException(&quot;Page language already set.&quot;);
        }

        String language = xmlStreamReader.getPIData();

        if (loadListener != null) {
            loadListener.readLanguageProcessingInstruction(language);
        }

        if (!staticLoad) {
            ScriptEngineManager scriptEngineManager = getScriptEngineManager();
            scriptEngine = scriptEngineManager.getEngineByName(language);
        }
    }

    private void processImport() throws LoadException {
        String target = xmlStreamReader.getPIData().trim();

        if (loadListener != null) {
            loadListener.readImportProcessingInstruction(target);
        }

        if (target.endsWith(&quot;.*&quot;)) {
            importPackage(target.substring(0, target.length() - 2));
        } else {
            importClass(target);
        }
    }

    private void processComment() throws LoadException {
        if (loadListener != null) {
            loadListener.readComment(xmlStreamReader.getText());
        }
    }

    private void processStartElement() throws IOException {
        // Create the element
        createElement();

        // Process the start tag
        current.processStartElement();

        // Set the root value
        if (root == null) {
            root = current.value;
        }
    }

    private void createElement() throws IOException {
        String prefix = xmlStreamReader.getPrefix();
        String localName = xmlStreamReader.getLocalName();

        if (prefix == null) {
            int i = localName.lastIndexOf('.');

            if (Character.isLowerCase(localName.charAt(i + 1))) {
                String name = localName.substring(i + 1);

                if (i == -1) {
                    // This is an instance property
                    if (loadListener != null) {
                        loadListener.beginPropertyElement(name, null);
                    }

                    current = new PropertyElement(name, null);
                } else {
                    // This is a static property
                    Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                    if (sourceType != null) {
                        if (loadListener != null) {
                            loadListener.beginPropertyElement(name, sourceType);
                        }

                        current = new PropertyElement(name, sourceType);
                    } else if (staticLoad) {
                        // The source type was not recognized
                        if (loadListener != null) {
                            loadListener.beginUnknownStaticPropertyElement(localName);
                        }

                        current = new UnknownStaticPropertyElement();
                    } else {
                        throw constructLoadException(localName + &quot; is not a valid property.&quot;);
                    }
                }
            } else {
                if (current == null &amp;&amp; root != null) {
                    throw constructLoadException(&quot;Root value already specified.&quot;);
                }

                Class&lt;?&gt; type = getType(localName);

                if (type != null) {
                    if (loadListener != null) {
                        loadListener.beginInstanceDeclarationElement(type);
                    }

                    current = new InstanceDeclarationElement(type);
                } else if (staticLoad) {
                    // The type was not recognized
                    if (loadListener != null) {
                        loadListener.beginUnknownTypeElement(localName);
                    }

                    current = new UnknownTypeElement();
                } else {
                    throw constructLoadException(localName + &quot; is not a valid type.&quot;);
                }
            }
        } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
            if (localName.equals(INCLUDE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginIncludeElement();
                }

                current = new IncludeElement();
            } else if (localName.equals(REFERENCE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginReferenceElement();
                }

                current = new ReferenceElement();
            } else if (localName.equals(COPY_TAG)) {
                if (loadListener != null) {
                    loadListener.beginCopyElement();
                }

                current = new CopyElement();
            } else if (localName.equals(ROOT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginRootElement();
                }

                current = new RootElement();
            } else if (localName.equals(SCRIPT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginScriptElement();
                }

                current = new ScriptElement();
            } else if (localName.equals(DEFINE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginDefineElement();
                }

                current = new DefineElement();
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
            }
        } else {
            throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
        }
    }

    private void processEndElement() throws IOException {
        current.processEndElement();

        if (loadListener != null) {
            loadListener.endElement(current.value);
        }

        // Move up the stack
        current = current.parent;
    }

    private void processCharacters() throws IOException {
        // Process the characters
        if (!xmlStreamReader.isWhiteSpace()) {
            current.processCharacters();
        }
    }

    private void importPackage(String name) throws LoadException {
        packages.add(name);
    }

    private void importClass(String name) throws LoadException {
        try {
            loadType(name, true);
        } catch (ClassNotFoundException exception) {
            throw constructLoadException(exception);
        }
    }

    private Class&lt;?&gt; getType(String name) throws LoadException {
        Class&lt;?&gt; type = null;

        if (Character.isLowerCase(name.charAt(0))) {
            // This is a fully-qualified class name
            try {
                type = loadType(name, false);
            } catch (ClassNotFoundException exception) {
                // No-op
            }
        } else {
            // This is an unqualified class name
            type = classes.get(name);

            if (type == null) {
                // The class has not been loaded yet; look it up
                for (String packageName : packages) {
                    try {
                        type = loadTypeForPackage(packageName, name);
                    } catch (ClassNotFoundException exception) {
                        // No-op
                    }

                    if (type != null) {
                        break;
                    }
                }

                if (type != null) {
                    classes.put(name, type);
                }
            }
        }

        return type;
    }

    private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
        int i = name.indexOf('.');
        int n = name.length();
        while (i != -1
            &amp;&amp; i &lt; n
            &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
            i = name.indexOf('.', i + 1);
        }

        if (i == -1 || i == n) {
            throw new ClassNotFoundException();
        }

        String packageName = name.substring(0, i);
        String className = name.substring(i + 1);

        Class&lt;?&gt; type = loadTypeForPackage(packageName, className);

        if (cache) {
            classes.put(className, type);
        }

        return type;
    }

    // TODO Rename to loadType() when deprecated static version is removed
    private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
        return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    private static enum SupportedType {
        PARAMETERLESS {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 0;
            }

        },
        EVENT {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        Event.class.isAssignableFrom(m.getParameterTypes()[0]);
            }

        },
        LIST_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
            }

        },
        MAP_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
            }

        },
        SET_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
            }

        },
        PROPERTY_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 3 &amp;&amp;
                        ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
                        &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
            }

        };

        protected abstract boolean methodIsOfType(Method m);
    }

    private static SupportedType toSupportedType(Method m) {
        for (SupportedType t : SupportedType.values()) {
            if (t.methodIsOfType(m)) {
                return t;
            }
        }
        return null;
    }

    private ScriptEngineManager getScriptEngineManager() {
        if (scriptEngineManager == null) {
            scriptEngineManager = new javax.script.ScriptEngineManager();
            scriptEngineManager.setBindings(new SimpleBindings(namespace));
        }

        return scriptEngineManager;
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param packageName the package name of the class to load
     * @param className the name of the class to load
     *
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
        return loadType(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param className the name of the class to load
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
        ReflectUtil.checkPackageAccess(className);
        return Class.forName(className, true, getDefaultClassLoader());
    }

    private static boolean needsClassLoaderPermissionCheck(Class caller) {
        if (caller == null) {
            return false;
        }
        return !FXMLLoader.class.getModule().equals(caller.getModule());
    }

    private static ClassLoader getDefaultClassLoader(Class caller) {
        if (defaultClassLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                if (needsClassLoaderPermissionCheck(caller)) {
                    sm.checkPermission(GET_CLASSLOADER_PERMISSION);
                }
            }
            return Thread.currentThread().getContextClassLoader();
        }
        return defaultClassLoader;
    }

    /**
     * Returns the default class loader.
     * @return the default class loader
     * @since JavaFX 2.1
     */
    public static ClassLoader getDefaultClassLoader() {
        final SecurityManager sm = System.getSecurityManager();
        final Class caller = (sm != null) ?
                walker.getCallerClass() :
                null;
        return getDefaultClassLoader(caller);
    }

    /**
     * Sets the default class loader.
     *
     * @param defaultClassLoader
     * The default class loader to use when loading classes.
     * @since JavaFX 2.1
     */
    public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
        if (defaultClassLoader == null) {
            throw new NullPointerException();
        }
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }

        FXMLLoader.defaultClassLoader = defaultClassLoader;
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location) throws IOException {
        return loadImpl(location, (System.getSecurityManager() != null)
                                      ? walker.getCallerClass()
                                      : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
            throws IOException {
        return loadImpl(location, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources)
                                     throws IOException {
        return loadImpl(location, resources,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources,  null,
                        callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used to load the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     * @param charset the character set used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                             Charset charset) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        charset,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Charset charset, Class&lt;?&gt; callerClass)
                                          throws IOException {
        if (location == null) {
            throw new NullPointerException(&quot;Location is required.&quot;);
        }

        FXMLLoader fxmlLoader =
                new FXMLLoader(location, resources, builderFactory,
                               controllerFactory, charset);

        return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
    }

    /**
     * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
     * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
     * @param nsVer String representation of JavaFX version to compare against runtime version
     * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
     *          number &amp;gt; 0 if runtime is higher version
     */
    static int compareJFXVersions(String rtVer, String nsVer) {

        int retVal = 0;

        if (rtVer == null || &quot;&quot;.equals(rtVer) ||
            nsVer == null || &quot;&quot;.equals(nsVer)) {
            return retVal;
        }

        if (rtVer.equals(nsVer)) {
            return retVal;
        }

        // version string can contain '-'
        int dashIndex = rtVer.indexOf(&quot;-&quot;);
        if (dashIndex &gt; 0) {
            rtVer = rtVer.substring(0, dashIndex);
        }

        // or &quot;_&quot;
        int underIndex = rtVer.indexOf(&quot;_&quot;);
        if (underIndex &gt; 0) {
            rtVer = rtVer.substring(0, underIndex);
        }

        // do not try to compare if the string is not valid version format
        if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
            !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
            return retVal;
        }

        StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
        StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
        int nsDigit = 0, rtDigit = 0;
        boolean rtVerEnd = false;

        while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
            if (rtVerTokenizer.hasMoreTokens()) {
                rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
                retVal = rtDigit - nsDigit;
            } else {
                rtVerEnd = true;
                break;
            }
        }

        if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
            if (rtDigit &gt; 0) {
                retVal = 1;
            }
        }

        if (rtVerEnd) {
            if (nsDigit &gt; 0) {
                retVal = -1;
            } else {
                while (nsVerTokenizer.hasMoreTokens()) {
                    nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
                    if (nsDigit &gt; 0) {
                        retVal = -1;
                        break;
                    }
                }
            }
        }

        return retVal;
    }

    private static void checkClassLoaderPermission() {
        final SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }
    }

    private final ControllerAccessor controllerAccessor =
            new ControllerAccessor();

    private static final class ControllerAccessor {
        private static final int PUBLIC = 1;
        private static final int PROTECTED = 2;
        private static final int PACKAGE = 4;
        private static final int PRIVATE = 8;
        private static final int INITIAL_CLASS_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;
        private static final int INITIAL_MEMBER_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;

        private static final int METHODS = 0;
        private static final int FIELDS = 1;

        private Object controller;
        private ClassLoader callerClassLoader;

        private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
        private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;

        void setController(final Object controller) {
            if (this.controller != controller) {
                this.controller = controller;
                reset();
            }
        }

        void setCallerClass(final Class&lt;?&gt; callerClass) {
            final ClassLoader newCallerClassLoader =
                    (callerClass != null) ? callerClass.getClassLoader()
                                          : null;
            if (callerClassLoader != newCallerClassLoader) {
                callerClassLoader = newCallerClassLoader;
                reset();
            }
        }

        void reset() {
            controllerFields = null;
            controllerMethods = null;
        }

        Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
            if (controllerFields == null) {
                controllerFields = new HashMap&lt;&gt;();

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     FIELDS);
            }

            return controllerFields;
        }

        Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
            if (controllerMethods == null) {
                controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
                for (SupportedType t: SupportedType.values()) {
                    controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
                }

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     METHODS);
            }

            return controllerMethods;
        }

        private void addAccessibleMembers(final Class&lt;?&gt; type,
                                          final int prevAllowedClassAccess,
                                          final int prevAllowedMemberAccess,
                                          final int membersType) {
            if (type == Object.class) {
                return;
            }

            int allowedClassAccess = prevAllowedClassAccess;
            int allowedMemberAccess = prevAllowedMemberAccess;
            if ((callerClassLoader != null)
                    &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
                // restrict further access
                allowedClassAccess &amp;= PUBLIC;
                allowedMemberAccess &amp;= PUBLIC;
            }

            final int classAccess = getAccess(type.getModifiers());
            if ((classAccess &amp; allowedClassAccess) == 0) {
                // we are done
                return;
            }

            ReflectUtil.checkPackageAccess(type);

            addAccessibleMembers(type.getSuperclass(),
                                 allowedClassAccess,
                                 allowedMemberAccess,
                                 membersType);

            final int finalAllowedMemberAccess = allowedMemberAccess;
            AccessController.doPrivileged(
                    new PrivilegedAction&lt;Void&gt;() {
                        @Override
                        public Void run() {
                            if (membersType == FIELDS) {
                                addAccessibleFields(type,
                                                    finalAllowedMemberAccess);
                            } else {
                                addAccessibleMethods(type,
                                                     finalAllowedMemberAccess);
                            }

                            return null;
                        }
                    });
        }

        private void addAccessibleFields(final Class&lt;?&gt; type,
                                         final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Field[] fields = type.getDeclaredFields();
            for (int i = 0; i &lt; fields.length; ++i) {
                final Field field = fields[i];
                final int memberModifiers = field.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.FINAL)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (field.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public field
                        continue;
                    }

                    // Ensure that the field is accessible
                    field.setAccessible(true);
                }

                List&lt;Field&gt; list = controllerFields.get(field.getName());
                if (list == null) {
                    list = new ArrayList&lt;&gt;(1);
                    controllerFields.put(field.getName(), list);
                }
                list.add(field);

            }
        }

        private void addAccessibleMethods(final Class&lt;?&gt; type,
                                          final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Method[] methods = type.getDeclaredMethods();
            for (int i = 0; i &lt; methods.length; ++i) {
                final Method method = methods[i];
                final int memberModifiers = method.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.NATIVE)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (method.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public method
                        continue;
                    }

                    // Ensure that the method is accessible
                    method.setAccessible(true);
                }

                // Add this method to the map if:
                // a) it is the initialize() method, or
                // b) it takes a single event argument, or
                // c) it takes no arguments and a handler with this
                //    name has not already been defined
                final String methodName = method.getName();
                final SupportedType convertedType;

                if ((convertedType = toSupportedType(method)) != null) {
                    controllerMethods.get(convertedType)
                                     .put(methodName, method);
                }
            }
        }

        private static int getAccess(final int fullModifiers) {
            final int untransformedAccess =
                    fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
                                                      | Modifier.PUBLIC);

            switch (untransformedAccess) {
                case Modifier.PUBLIC:
                    return PUBLIC;

                case Modifier.PROTECTED:
                    return PROTECTED;

                case Modifier.PRIVATE:
                    return PRIVATE;

                default:
                    return PACKAGE;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Cursor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.lang.annotation.Native;

<A NAME="1"></A>public abstract class Cursor {

    @Native public final static int CURSOR_NONE = -1;
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#1',2,'match36-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native public final static int CURSOR_CUSTOM = 0;
    @Native public final static int CURSOR_DEFAULT = 1;
    @Native public final static int CURSOR_TEXT = 2;
    @Native public final static int CURSOR_CROSSHAIR = 3;
    @Native public final static int CURSOR_CLOSED_HAND = 4;
    @Native public final static int CURSOR_OPEN_HAND = 5;
    @Native public final static int CURSOR_POINTING_HAND = 6;
    @Native public final static int CURSOR_RESIZE_LEFT = 7;
    @Native public final static int CURSOR_RESIZE_RIGHT = 8;
    @Native public final static int CURSOR_RESIZE_UP = 9;
    @Native public final static int CURSOR_RESIZE_DOWN = 10;
    @Native public final static int CURSOR_RESIZE_LEFTRIGHT = 11;
    @Native public final static int CURSOR_RESIZE_UPDOWN = 12;
    @Native public final static int CURSOR_DISAPPEAR = 13;
    @Native public final static int CURSOR_WAIT = 14;
    @Native public final static int CURSOR_RESIZE_SOUTHWEST = 15;
    @Native public final static int CURSOR_RESIZE_SOUTHEAST = 16;
    @Native public final static int CURSOR_RESIZE_NORTHWEST = 17;
    @Native public final static int CURSOR_RESIZE_NORTHEAST = 18;
    @Native public final static int CURSOR_MOVE = 19;
    private final static int CURSOR_MAX = 19;

    private final int type;

    // Native cursor ptr, for custom cursors
    private long ptr</B></FONT>;

    protected Cursor(final int type) {
        Application.checkEventThread();
        this.type = type;
    }

    protected Cursor(final int x, final int y, final Pixels pixels) {
        this(CURSOR_CUSTOM);
        ptr = _createCursor(x, y, pixels);
    }

    public final int getType() {
        Application.checkEventThread();
        return type;
    }

    protected final long getNativeCursor() {
        Application.checkEventThread();
        return ptr;
    }

    /**
     * Shows or hides the cursor.
     * &lt;p&gt;
     * If the cursor is currently hidden with a previous call to {@code
     * setVisible(false)}, setting a new cursor shape (e.g. by means of calling
     * {@code Window.setCursor()}) does not automatically display the cursor on
     * the screen until the client code calls {@code setVisible(true)} to show
     * the cursor again.
     * &lt;p&gt;
     * If the mouse cursor is located over a non-Glass window at the time of
     * calling this method, the call may or may not affect the native cursor's
     * visibility. This behavior is platform-dependent.
     * &lt;p&gt;
     * When the mouse pointer is moved over a non-Glass window, depending on
     * the native platform behavior, the cursor may or may not become visible
     * on the screen, even if it was previously hidden by calling {@code
     * setVisible(false)}. After this occurs, on some platforms the cursor may
     * even remain visible permanently. For example, Mac OS X makes the cursor
     * visible unconditionally when the mouse is moved over the Dock or Menu
     * Bar areas. There's no way to detect that the native cursor became
     * visible, however, from Glass perspective it is still considered hidden,
     * and thus, when the mouse cursor is needed again, the app should call
     * {@code setVisible(true)} in order to continue to operate properly.
     * &lt;p&gt;
     * Calling this method multiple times with the same argument may not have
     * any effect. For example, if the cursor was hidden and the native OS
     * restored its visibility, calling {@code setVisible(false)} again may not
     * hide the cursor. If the app needs to ultimately hide the cursor, it
     * should first show the cursor again, and then proceed with hiding it.
     */
    public static void setVisible(boolean visible) {
        Application.checkEventThread();
        Application.GetApplication().staticCursor_setVisible(visible);
    }

    /**
     * Returns the 'best' cursor size based on the given preferred size.
     */
    public static Size getBestSize(int width, int height) {
        Application.checkEventThread();
        return Application.GetApplication().staticCursor_getBestSize(width, height);
    }

    protected abstract long _createCursor(int x, int y, Pixels pixels);
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Screen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public final class Screen {

    // the list of attached screens provided by native.
    // screens[0] is the default/main Screen
    private static volatile List&lt;Screen&gt; screens = null ;

    // If dpiOverride is non-zero, use its value as screen DPI
    private static final int dpiOverride;

    static {
        dpiOverride = AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;com.sun.javafx.screenDPI&quot;, 0)).intValue();
    }

    public static class EventHandler {
        public void handleSettingsChanged() {
        }
    }

    public static double getVideoRefreshPeriod() {
        Application.checkEventThread();
        return Application.GetApplication().staticScreen_getVideoRefreshPeriod();
    }

    /**
     * Could be called from any thread
     * @return the main screen
     */
    public static Screen getMainScreen() {
        return getScreens().get(0);
    }

    /**
     * Could be called from any thread
     * @return list of all available screens
     */
    public static List&lt;Screen&gt; getScreens() {
        if (screens == null) {
            throw new RuntimeException(&quot;Internal graphics not initialized yet&quot;);
        }

        return screens;
    }

    private static EventHandler eventHandler;

    private volatile long ptr;
    private volatile int adapter;

    private final int depth;

    private final int x;
    private final int y;
    private final int width;
    private final int height;

    private final int platformX;
    private final int platformY;
    private final int platformWidth;
    private final int platformHeight;

    private final int visibleX;
    private final int visibleY;
    private final int visibleWidth;
    private final int visibleHeight;

    private final int resolutionX;
    private final int resolutionY;

    private final float platformScaleX;
    private final float platformScaleY;
    private final float outputScaleX;
    private final float outputScaleY;

    public Screen(
            long nativePtr,

            int depth,
            int x,
            int y,
            int width,
            int height,

            int platformX,
            int platformY,
            int platformWidth,
            int platformHeight,

            int visibleX,
            int visibleY,
            int visibleWidth,
            int visibleHeight,

            int resolutionX,
            int resolutionY,

            float platformScaleX,
            float platformScaleY,
            float outputScaleX,
            float outputScaleY
            ) {
        this.ptr = nativePtr;

        this.depth = depth;

        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        this.platformX = platformX;
        this.platformY = platformY;
        this.platformWidth = platformWidth;
        this.platformHeight = platformHeight;

        this.visibleX = visibleX;
        this.visibleY = visibleY;
        this.visibleWidth = visibleWidth;
        this.visibleHeight = visibleHeight;

        if (dpiOverride &gt; 0) {
            this.resolutionX = this.resolutionY = dpiOverride;
        } else {
            this.resolutionX = resolutionX;
            this.resolutionY = resolutionY;
        }

        this.platformScaleX = platformScaleX;
        this.platformScaleY = platformScaleY;
        this.outputScaleX = outputScaleX;
        this.outputScaleY = outputScaleY;
    }

    /**
     * Could be called from any thread
     */
    public int getDepth() {
        return this.depth;
    }

    /**
     * Could be called from any thread
     */
    public int getX() {
        return this.x;
    }

    /**
     * Could be called from any thread
     */
    public int getY() {
        return this.y;
    }

    /**
     * Could be called from any thread
     */
    public int getWidth() {
        return this.width;
    }

    /**
     * Could be called from any thread
     */
    public int getHeight() {
        return this.height;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformX() {
        return this.platformX;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformY() {
        return this.platformY;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformWidth() {
        return this.platformWidth;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformHeight() {
        return this.platformHeight;
    }

    public float fromPlatformX(int px) {
        return this.x + (px - platformX) / platformScaleX;
    }

    public float fromPlatformY(int py) {
        return this.y + (py - platformY) / platformScaleY;
    }

    public int toPlatformX(float ux) {
        return platformX + Math.round((ux - this.x) * platformScaleX);
    }

    public int toPlatformY(float uy) {
        return platformY + Math.round((uy - this.y) * platformScaleY);
    }

    public float portionIntersectsPlatformRect(int x, int y, int w, int h) {
        int x0 = Math.max(x, platformX);
        int y0 = Math.max(y, platformY);
        int x1 = Math.min(x + w, platformX + platformWidth);
        int y1 = Math.min(y + h, platformY + platformHeight);
        if ((x1 -= x0) &lt;= 0) return 0.0f;
        if ((y1 -= y0) &lt;= 0) return 0.0f;
        float ret = x1 * y1;
        return (ret / w) / h;
    }

    public boolean containsPlatformRect(int x, int y, int w, int h) {
        if (!containsPlatformCoords(x, y)) return false;
        if (w &lt;= 0 || h &lt;= 0) return true;
        return (x + w &lt;= platformX + platformWidth &amp;&amp;
                y + h &lt;= platformY + platformHeight);
    }

    public boolean containsPlatformCoords(int x, int y) {
        x -= platformX;
        y -= platformY;
        return (x &gt;= 0 &amp;&amp; x &lt; platformWidth &amp;&amp;
                y &gt;= 0 &amp;&amp; y &lt; platformHeight);
    }

    /**
     * Returns the horizontal scaling of the UI (window sizes and event
     * coordinates) from FX logical units to the platform units.
     * Could be called from any thread
     * @return platform X scaling
     */
    public float getPlatformScaleX() {
        return this.platformScaleX;
    }

    /**
     * Returns the vertical scaling of the UI (window sizes and event
     * coordinates) from FX logical units to the platform units.
     * Could be called from any thread
     * @return platform Y scaling
     */
    public float getPlatformScaleY() {
        return this.platformScaleY;
    }

    /**
     * Returns the recommended horizontal scaling for the rendered frames.
     * Could be called from any thread
     * @return recommended render X scaling
     */
    public float getRecommendedOutputScaleX() {
        return this.outputScaleX;
    }

    /**
     * Returns the recommended vertical scaling for the rendered frames.
     * Could be called from any thread
     * @return recommended render Y scaling
     */
    public float getRecommendedOutputScaleY() {
        return this.outputScaleY;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleX() {
        return this.visibleX;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleY() {
        return this.visibleY;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleWidth() {
        return this.visibleWidth;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleHeight() {
        return this.visibleHeight;
    }

    /**
     * Could be called from any thread
     */
    public int getResolutionX() {
        return this.resolutionX;
    }

    /**
     * Could be called from any thread
     */
    public int getResolutionY() {
        return this.resolutionY;
    }

    /**
     * Could be called from any thread
     */
    public long getNativeScreen() {
        return this.ptr;
    }

    private void dispose() {
        this.ptr = 0L;
    }

    public int getAdapterOrdinal() {
        return this.adapter;
    }

    public void setAdapterOrdinal(int adapter) {
        this.adapter = adapter;
    }

    public static void setEventHandler(EventHandler eh) {
        Application.checkEventThread();
        eventHandler = eh;
    }

    /**
     * Called from native when the Screen definitions change.
     */
    public static void notifySettingsChanged() {
        // Save the old screens in order to dispose them later
        List&lt;Screen&gt; oldScreens = screens;

        // Get the new screens
        initScreens();

        if (eventHandler != null) {
            eventHandler.handleSettingsChanged();
        }

        // Update the screen for each window to match the new instance.
        // Note that if a window has moved to another screen, the window
        // will be notified separately of that from native code and the
        // new screen will be updated there
        List&lt;Window&gt; windows = Window.getWindows();
        for (Window w : windows) {
            Screen oldScreen = w.getScreen();
            for (Screen newScreen : screens) {
                if (oldScreen.getNativeScreen() == newScreen.getNativeScreen()) {
                    w.setScreen(newScreen);
                    break;
                }
            }
        }

        // Dispose the old screens
        if (oldScreens != null) {
            for (Screen screen : oldScreens) {
                screen.dispose();
            }
        }
    }

    static void initScreens() {
        Application.checkEventThread();
        Screen[] newScreens = Application.GetApplication().staticScreen_getScreens();
        if (newScreens == null) {
            throw new RuntimeException(&quot;Internal graphics failed to initialize&quot;);
        }
        screens = Collections.unmodifiableList(Arrays.asList(newScreens));
    }

<A NAME="3"></A>    @Override public String toString() {
        return  &quot;Screen:&quot;+&quot;\n&quot;+
                &quot;    ptr:&quot;+getNativeScreen()+&quot;\n&quot;+
                &quot;    adapter:&quot;+<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#3',2,'match36-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getAdapterOrdinal()+&quot;\n&quot;+
                &quot;    depth:&quot;+getDepth()+&quot;\n&quot;+
                &quot;    x:&quot;+getX()+&quot;\n&quot;+
                &quot;    y:&quot;+getY()+&quot;\n&quot;+
                &quot;    width:&quot;+getWidth()+&quot;\n&quot;+
                &quot;    height:&quot;+getHeight()+&quot;\n&quot;+
                &quot;    platformX:&quot;+getPlatformX()+&quot;\n&quot;+
                &quot;    platformY:&quot;+getPlatformY()+&quot;\n&quot;+
                &quot;    platformWidth:&quot;+getPlatformWidth()+&quot;\n&quot;+
                &quot;    platformHeight:&quot;+getPlatformHeight()+&quot;\n&quot;+
                &quot;    visibleX:&quot;+getVisibleX()+&quot;\n&quot;+
                &quot;    visibleY:&quot;+getVisibleY()+&quot;\n&quot;+
                &quot;    visibleWidth:&quot;+getVisibleWidth()+&quot;\n&quot;+
                &quot;    visibleHeight:&quot;+getVisibleHeight()+&quot;\n&quot;+
                &quot;    platformScaleX:&quot;+getPlatformScaleX()+&quot;\n&quot;+
                &quot;    platformScaleY:&quot;+getPlatformScaleY()+&quot;\n&quot;+
                &quot;    outputScaleX:&quot;+getRecommendedOutputScaleX()+&quot;\n&quot;+
                &quot;    outputScaleY:&quot;+getRecommendedOutputScaleY()+&quot;\n&quot;+
                &quot;    resolutionX:&quot;+getResolutionX()+&quot;\n&quot;+
                &quot;    resolutionY:&quot;+getResolutionY()+&quot;\n&quot;;
    }

    @Override public boolean equals(Object o) {</B></FONT>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Screen screen = (Screen) o;
        return ptr == screen.ptr
                &amp;&amp; adapter == screen.adapter
                &amp;&amp; depth == screen.depth
                &amp;&amp; x == screen.x
                &amp;&amp; y == screen.y
                &amp;&amp; width == screen.width
                &amp;&amp; height == screen.height
                &amp;&amp; visibleX == screen.visibleX
                &amp;&amp; visibleY == screen.visibleY
                &amp;&amp; visibleWidth == screen.visibleWidth
                &amp;&amp; visibleHeight == screen.visibleHeight
                &amp;&amp; resolutionX == screen.resolutionX
                &amp;&amp; resolutionY == screen.resolutionY
                &amp;&amp; Float.compare(screen.platformScaleX, platformScaleX) == 0
                &amp;&amp; Float.compare(screen.platformScaleY, platformScaleY) == 0
                &amp;&amp; Float.compare(screen.outputScaleX, outputScaleX) == 0
                &amp;&amp; Float.compare(screen.outputScaleY, outputScaleY) == 0;
    }

    @Override public int hashCode() {
        int result = 17;
        result = 31 * result + (int) (ptr ^ (ptr &gt;&gt;&gt; 32));
        result = 31 * result + adapter;
        result = 31 * result + depth;
        result = 31 * result + x;
        result = 31 * result + y;
        result = 31 * result + width;
        result = 31 * result + height;
        result = 31 * result + visibleX;
        result = 31 * result + visibleY;
        result = 31 * result + visibleWidth;
        result = 31 * result + visibleHeight;
        result = 31 * result + resolutionX;
        result = 31 * result + resolutionY;
        result = 31 * result + (platformScaleX != +0.0f ? Float.floatToIntBits(platformScaleX) : 0);
        result = 31 * result + (platformScaleY != +0.0f ? Float.floatToIntBits(platformScaleY) : 0);
        result = 31 * result + (outputScaleX != +0.0f ? Float.floatToIntBits(outputScaleX) : 0);
        result = 31 * result + (outputScaleY != +0.0f ? Float.floatToIntBits(outputScaleY) : 0);
        return result;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/LinuxInputDeviceRegistry.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import java.io.File;
import java.io.IOException;
import java.security.AllPermission;
import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;

class LinuxInputDeviceRegistry extends InputDeviceRegistry {

    LinuxInputDeviceRegistry(boolean headless) {
        if (headless) {
            // Keep the registry but do not bind it to udev.
            return;
        }
        Map&lt;File, LinuxInputDevice&gt; deviceMap = new HashMap&lt;&gt;();
        UdevListener udevListener = (action, event) -&gt; {
            String subsystem = event.get(&quot;SUBSYSTEM&quot;);
            String devPath = event.get(&quot;DEVPATH&quot;);
            String devName = event.get(&quot;DEVNAME&quot;);
            if (subsystem != null &amp;&amp; subsystem.equals(&quot;input&quot;)
                    &amp;&amp; devPath != null &amp;&amp; devName != null) {
                try {
                    File sysPath = new File(&quot;/sys&quot;, devPath);
                    if (action.equals(&quot;add&quot;)
                            || (action.equals(&quot;change&quot;)
                            &amp;&amp; !deviceMap.containsKey(sysPath))) {
                        File devNode = new File(devName);
                        LinuxInputDevice device = createDevice(
                                devNode, sysPath, event);
                        if (device != null) {
                            deviceMap.put(sysPath, device);
                        }
                    } else if (action.equals(&quot;remove&quot;)) {
                        LinuxInputDevice device = deviceMap.get(sysPath);
                        deviceMap.remove(sysPath);
                        if (device != null) {
<A NAME="5"></A>                            devices.remove(device);
                        }
                    }
                <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#5',2,'match36-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        Udev.getInstance().addListener(udevListener);
        // Request updates for existing devices
        SysFS.triggerUdevNotification(&quot;input&quot;);
    }

    private LinuxInputDevice createDevice(File devNode</B></FONT>,
                                          File sysPath,
                                          Map&lt;String, String&gt; udevManifest)
            throws IOException {
        LinuxInputDevice device = new LinuxInputDevice(
                devNode, sysPath, udevManifest);
        return addDeviceInternal(device, &quot;Linux input: &quot; + devNode.toString());
    }

    LinuxInputDevice addDevice(LinuxInputDevice device, String name) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPermission(new AllPermission());
        }
        return addDeviceInternal(device, name);
    }

    private LinuxInputDevice addDeviceInternal(LinuxInputDevice device, String name) {
        LinuxInputProcessor processor = createInputProcessor(device);
        if (processor == null) {
            return null;
        } else {
            device.setInputProcessor(processor);
            Thread thread = new Thread(device);
            thread.setName(name);
            thread.setDaemon(true);
            thread.start();
            devices.add(device);
            return device;
        }
    }

    void removeDevice(LinuxInputDevice device) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPermission(new AllPermission());
        }
        devices.remove(device);
    }

    private LinuxInputProcessor createInputProcessor(LinuxInputDevice device) {
        if (device.isTouch()) {
            BitSet absCaps = device.getCapability(&quot;abs&quot;);
            boolean isMT = absCaps.get(LinuxInput.ABS_MT_POSITION_X)
                    &amp;&amp; absCaps.get(LinuxInput.ABS_MT_POSITION_Y);
            if (isMT) {
                if (absCaps.get(LinuxInput.ABS_MT_TRACKING_ID)) {
                    return new LinuxStatefulMultiTouchProcessor(device);
                } else {
                    return new LinuxStatelessMultiTouchProcessor(device);
                }
            } else {
                return new LinuxSimpleTouchProcessor(device);
            }
        } else if (device.isRelative()) {
            return new LinuxMouseProcessor();
        } else {
            BitSet keyCaps = device.getCapability(&quot;key&quot;);
            if (keyCaps != null &amp;&amp; !keyCaps.isEmpty()) {
                return new LinuxKeyProcessor();
            } else {
                return null;
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/VNCScreen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.MouseEvent;
import javafx.application.Platform;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.BitSet;
import java.util.HashSet;
import java.util.Set;

/** A headless screen that is available for remote connections using the
 * RFB 3.3 protocol on port 5901.
 */
class VNCScreen extends HeadlessScreen {

    private ServerSocketChannel server;
    private Set&lt;ClientConnection&gt; clients = new HashSet&lt;ClientConnection&gt;();

    VNCScreen() {
        super(1024, 600, 32);
        try {
            server = ServerSocketChannel.open();
            int vncPort = AccessController.doPrivileged(
<A NAME="7"></A>                    (PrivilegedAction&lt;Integer&gt;)
                            () -&gt; Integer.getInteger(&quot;vnc.port&quot;, 5901));
            server.bind(new InetSocketAddress(vncPort));
            Thread t = new Thread(<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#7',2,'match36-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new ConnectionAccepter());
            t.setDaemon(true);
            t.setName(&quot;VNC Server on port &quot; + vncPort);
            t.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Overrid</B></FONT>e
    public void shutdown() {
        super.shutdown();
        for (ClientConnection cc : clients) {
            try {
                cc.socket.close();
            } catch (IOException e) { }
        }
    }

    @Override
    public void swapBuffers() {
        ClientConnection[] ccs;
        synchronized (clients) {
            ccs = clients.toArray(new ClientConnection[clients.size()]);
        }
        for (ClientConnection cc : ccs) {
            try {
                sendBuffer(cc.socket);
            } catch (IOException e) {
                clients.remove(cc);
            }
        }
        super.swapBuffers();
    }

    private void removeClient(ClientConnection cc, IOException e) {
        synchronized (clients) {
            if (clients.contains(cc)) {
                System.out.format(&quot;Disconnecting %s: %s\n&quot;,
                                  cc.descriptor, e.getMessage());
                clients.remove(cc);
            }
        }
    }

    private void sendBuffer(WritableByteChannel out) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(16);
        buffer.order(ByteOrder.BIG_ENDIAN);
        buffer.put((byte) 0);
        buffer.put((byte) 0);
        buffer.putShort((short) 1); // rectangle count
        buffer.putShort((short) 0); // x
        buffer.putShort((short) 0); // y
        buffer.putShort((short) width);
        buffer.putShort((short) height);
        buffer.putInt(0); // raw
        buffer.flip();
        out.write(buffer);
        fb.write(out);
    }

    private class ConnectionAccepter implements Runnable {
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(64);
            buffer.order(ByteOrder.BIG_ENDIAN);
            while (true) {
                try {
                    SocketChannel client = server.accept();
                    System.out.format(&quot;Connection received from %s\n&quot;,
                                      client.getRemoteAddress());
                    // Declare the server protocol version
                    buffer.clear();
                    buffer.put(&quot;RFB 003.003\n&quot;.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    // Read the client protocol version
                    buffer.clear();
                    buffer.limit(12);
                    client.read(buffer);
                    buffer.flip();
                    System.out.format(&quot;Client supports %s\n&quot;,
                                      Charset.forName(&quot;UTF-8&quot;)
                                              .decode(buffer).toString().trim());
                    buffer.clear();
                    buffer.putInt(1); // no authentication
                    buffer.flip();
                    client.write(buffer);
                    buffer.clear();
                    buffer.limit(1);
                    client.read(buffer);
                    System.out.format(&quot;Client share request: %d\n&quot;,
                                      buffer.get(0));
                    buffer.clear();
                    buffer.putShort((short) width);
                    buffer.putShort((short) height);
                    buffer.put((byte) depth);
                    buffer.put((byte) depth);
                    buffer.put((byte) (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN) ? 0 : 1));
                    buffer.put((byte) 1); // true color
                    if (depth == 32) {
                        buffer.putShort((short) 255); // red max
                        buffer.putShort((short) 255); // green max
                        buffer.putShort((short) 255); // blue max
                        buffer.put((byte) 16); // red offset
                        buffer.put((byte) 8); // blue offset
                        buffer.put((byte) 0); // green offset
                    } else {
                        buffer.putShort((byte) (short) 31);
                        buffer.putShort((byte) (short) 63);
                        buffer.putShort((byte) (short) 31);
                        buffer.put((byte) 11);
                        buffer.put((byte) 5);
                        buffer.put((byte) 0);
                    }
                    buffer.put((byte) 0); // padding
                    buffer.put((byte) 0);
                    buffer.put((byte) 0);
                    String name = &quot;JavaFX on &quot; + client.getLocalAddress();
                    buffer.putInt(name.length());
                    buffer.put(name.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    ClientConnection cc = new ClientConnection();
                    cc.socket = client;
                    Thread t = new Thread(cc);
                    t.setDaemon(true);
                    t.setName(&quot;VNC client connection from &quot;
                                      + client.getRemoteAddress());
                    t.start();
                    synchronized (clients) {
                        clients.add(cc);
                    }
                    sendBuffer(client);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private class ClientConnection implements Runnable {
        private SocketChannel socket;
        private String descriptor;
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(32);
            buffer.order(ByteOrder.BIG_ENDIAN);
            try {
                descriptor = socket.getRemoteAddress().toString();
                while (true) {
                    buffer.clear();
                    buffer.limit(4);
                    socket.read(buffer);
                    switch (buffer.get(0)) {
                        case 0: // SetPixelFormat
                            // discard the message in the next 16 bytes
                            buffer.clear();
                            buffer.limit(16);
                            socket.read(buffer);
                            break;
                        case 1: // FixColorMapEntries
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            // discard color map entries
                            int colorMapEntryCount = buffer.getShort(0);
                            for (int i = 0; i &lt; colorMapEntryCount; i++) {
                                buffer.clear();
                                buffer.limit(6);
                                socket.read(buffer);
                            }
                            break;
                        case 2: // SetEncodings
                            // discard encodings
                            int encodingCount = buffer.getShort(2);
                            for (int i = 0; i &lt; encodingCount; i++) {
                                buffer.clear();
                                buffer.limit(4);
                                socket.read(buffer);
                            }
                        case 3: // FramebufferUpdateRequest
                            buffer.clear();
                            buffer.limit(6);
                            socket.read(buffer);
                            Platform.runLater(() -&gt; {
                                try {
                                    if (fb.hasReceivedData()) {
                                        // an update is in progress and will
                                        // be sent on the next call to
                                        // swapBuffers. No need to
                                        // respond to this request.
                                    } else {
                                        sendBuffer(socket);
                                    }
                                } catch (IOException e) {
                                    removeClient(ClientConnection.this, e);
                                }
                            });
                            break;
                        case 4: // KeyEvent
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            break;
                        case 5: { // PointerEvent
                            int x = buffer.getShort(2);
                            buffer.position(1);
                            buffer.limit(2);
                            BitSet buttons = BitSet.valueOf(buffer);
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            int y = buffer.getShort(0);
                            final MouseState state = new MouseState();
                            state.setX(x);
                            state.setY(y);
                            if (buttons.get(0)) {
                                state.pressButton(MouseEvent.BUTTON_LEFT);
                            }
                            if (buttons.get(1)) {
                                state.pressButton(MouseEvent.BUTTON_OTHER);
                            }
                            if (buttons.get(2)) {
                                state.pressButton(MouseEvent.BUTTON_RIGHT);
                            }
                            Platform.runLater(() -&gt; MouseInput.getInstance().setState(state, false));
                            break;
                        }
                        case 6: // ClientCutText
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            int textLength = buffer.getInt(0);
                            for (int i = 0; i &lt; textLength; i++) {
                                buffer.clear();
                                buffer.limit(1);
                                socket.read(buffer);
                            }
                            break;
                        default:
                            System.err.format(
                                    &quot;Unknown message %d from client %s\n&quot;,
                                    buffer.get(0), socket.getRemoteAddress());
                    }
                }
            } catch (IOException e) {
                removeClient(this, e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/win/WinHTMLCodec.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.win;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.io.File;

import java.net.URL;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;
import java.util.ArrayList;

final class WinHTMLCodec {
    public static final String defaultCharset = &quot;UTF-8&quot;;
<A NAME="13"></A>
    public static byte[] encode(byte[] html) {
        return HTMLCodec.convertToHTMLFormat(html);
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#13',2,'match36-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public static byte[] decode(byte[] data) {
        try {
            ByteArrayInputStream bais = new ByteArrayInputStream(data);
            InputStream is = new</B></FONT> HTMLCodec(bais, EHTMLReadMode.HTML_READ_SELECTION);

            // the initial size is larger, but we avoid relocations
            ByteArrayOutputStream baos = new ByteArrayOutputStream(data.length);

            // Very inefficient. But clipboard operations shouldn't be super fast either.
            // Might use available() to estimate a buffer size, and copy blocks instead.
            int b;
            while ((b = is.read()) != -1) {
                baos.write(b);
            }

            return baos.toByteArray();
        } catch (IOException ex) {
            throw new RuntimeException(&quot;Unexpected IOException caught&quot;, ex);
        }
    }
}

// ***************************************************************************
// The code below is copied from JDK unmodified
// ***************************************************************************

enum EHTMLReadMode {
    HTML_READ_ALL,
    HTML_READ_FRAGMENT,
    HTML_READ_SELECTION
}

/**
 * on decode: This stream takes an InputStream which provides data in CF_HTML format,
 * strips off the description and context to extract the original HTML data.
 *
 * on encode: static convertToHTMLFormat is responsible for HTML clipboard header creation
 */
class HTMLCodec extends InputStream {
    //static section
    public static final String ENCODING = &quot;UTF-8&quot;;

    public static final String VERSION = &quot;Version:&quot;;
    public static final String START_HTML = &quot;StartHTML:&quot;;
    public static final String END_HTML = &quot;EndHTML:&quot;;
    public static final String START_FRAGMENT = &quot;StartFragment:&quot;;
    public static final String END_FRAGMENT = &quot;EndFragment:&quot;;
    public static final String START_SELECTION = &quot;StartSelection:&quot;; //optional
    public static final String END_SELECTION = &quot;EndSelection:&quot;; //optional

    public static final String START_FRAGMENT_CMT = &quot;&lt;!--StartFragment--&gt;&quot;;
    public static final String END_FRAGMENT_CMT = &quot;&lt;!--EndFragment--&gt;&quot;;
    public static final String SOURCE_URL = &quot;SourceURL:&quot;;
    public static final String DEF_SOURCE_URL = &quot;about:blank&quot;;

    public static final String EOLN = &quot;\r\n&quot;;

    private static final String VERSION_NUM = &quot;1.0&quot;;
    private static final int PADDED_WIDTH = 10;

    private static String toPaddedString(int n, int width) {
        String string = &quot;&quot; + n;
        int len = string.length();
        if (n &gt;= 0 &amp;&amp; len &lt; width) {
            char[] array = new char[width - len];
            Arrays.fill(array, '0');
            StringBuffer buffer = new StringBuffer(width);
            buffer.append(array);
            buffer.append(string);
            string = buffer.toString();
        }
        return string;
    }

    /**
     * convertToHTMLFormat adds the MS HTML clipboard header to byte array that
     * contains the parameters pairs.
     *
     * The consequence of parameters is fixed, but some or all of them could be
     * omitted. One parameter per one text line.
     * It looks like that:
     *
     * Version:1.0\r\n                -- current supported version
     * StartHTML:000000192\r\n        -- shift in array to the first byte after the header
     * EndHTML:000000757\r\n          -- shift in array of last byte for HTML syntax analysis
     * StartFragment:000000396\r\n    -- shift in array jast after &lt;!--StartFragment--&gt;
     * EndFragment:000000694\r\n      -- shift in array before start  &lt;!--EndFragment--&gt;
     * StartSelection:000000398\r\n   -- shift in array of the first char in copied selection
     * EndSelection:000000692\r\n     -- shift in array of the last char in copied selection
     * SourceURL:http://sun.com/\r\n  -- base URL for related referenses
     * &lt;HTML&gt;...&lt;BODY&gt;...&lt;!--StartFragment--&gt;.....................&lt;!--EndFragment--&gt;...&lt;/BODY&gt;&lt;HTML&gt;
     * ^                                     ^ ^                ^^                                 ^
     * \ StartHTML                           | \-StartSelection | \EndFragment              EndHTML/
     *                                       \-StartFragment    \EndSelection
     *
     *Combinations with tags sequence
     *&lt;!--StartFragment--&gt;&lt;HTML&gt;...&lt;BODY&gt;...&lt;/BODY&gt;&lt;HTML&gt;&lt;!--EndFragment--&gt;
     * or
     *&lt;HTML&gt;...&lt;!--StartFragment--&gt;...&lt;BODY&gt;...&lt;/BODY&gt;&lt;!--EndFragment--&gt;&lt;HTML&gt;
     * are vailid too.
     */
    public static byte[] convertToHTMLFormat(byte[] bytes) {
        // Calculate section offsets
        String htmlPrefix = &quot;&quot;;
        String htmlSuffix = &quot;&quot;;
        {
            //we have extend the fragment to full HTML document correctly
            //to avoid HTML and BODY tags doubling
            String stContext = new String(bytes);
            String stUpContext = stContext.toUpperCase();
            if( -1 == stUpContext.indexOf(&quot;&lt;HTML&quot;) ) {
                htmlPrefix = &quot;&lt;HTML&gt;&quot;;
                htmlSuffix = &quot;&lt;/HTML&gt;&quot;;
                if( -1 == stUpContext.indexOf(&quot;&lt;BODY&quot;) ) {
                    htmlPrefix = htmlPrefix +&quot;&lt;BODY&gt;&quot;;
                    htmlSuffix = &quot;&lt;/BODY&gt;&quot; + htmlSuffix;
                };
            };
            htmlPrefix = htmlPrefix + START_FRAGMENT_CMT;
            htmlSuffix = END_FRAGMENT_CMT + htmlSuffix;
        }

        String stBaseUrl = DEF_SOURCE_URL;
        int nStartHTML =
            VERSION.length() + VERSION_NUM.length() + EOLN.length()
            + START_HTML.length() + PADDED_WIDTH + EOLN.length()
            + END_HTML.length() + PADDED_WIDTH + EOLN.length()
            + START_FRAGMENT.length() + PADDED_WIDTH + EOLN.length()
            + END_FRAGMENT.length() + PADDED_WIDTH + EOLN.length()
            + SOURCE_URL.length() + stBaseUrl.length() + EOLN.length()
            ;
        int nStartFragment = nStartHTML + htmlPrefix.length();
        int nEndFragment = nStartFragment + bytes.length - 1;
        int nEndHTML = nEndFragment + htmlSuffix.length();

        StringBuilder header = new StringBuilder(
            nStartFragment
            + START_FRAGMENT_CMT.length()
        );
        //header
        header.append(VERSION);
        header.append(VERSION_NUM);
        header.append(EOLN);

        header.append(START_HTML);
        header.append(toPaddedString(nStartHTML, PADDED_WIDTH));
        header.append(EOLN);

        header.append(END_HTML);
        header.append(toPaddedString(nEndHTML, PADDED_WIDTH));
        header.append(EOLN);

        header.append(START_FRAGMENT);
        header.append(toPaddedString(nStartFragment, PADDED_WIDTH));
        header.append(EOLN);

        header.append(END_FRAGMENT);
        header.append(toPaddedString(nEndFragment, PADDED_WIDTH));
        header.append(EOLN);

        header.append(SOURCE_URL);
        header.append(stBaseUrl);
        header.append(EOLN);

        //HTML
        header.append(htmlPrefix);

        byte[] headerBytes = null, trailerBytes = null;

        try {
            headerBytes = header.toString().getBytes(ENCODING);
            trailerBytes = htmlSuffix.getBytes(ENCODING);
        } catch (UnsupportedEncodingException cannotHappen) {
            return null;
        }

        byte[] retval = new byte[headerBytes.length + bytes.length +
                                 trailerBytes.length];

        System.arraycopy(headerBytes, 0, retval, 0, headerBytes.length);
        System.arraycopy(bytes, 0, retval, headerBytes.length,
                       bytes.length - 1);
        System.arraycopy(trailerBytes, 0, retval,
                         headerBytes.length + bytes.length - 1,
                         trailerBytes.length);
        retval[retval.length-1] = 0;

        return retval;
    }

    ////////////////////////////////////
    //decoder instance data and methods:

    private final BufferedInputStream bufferedStream;
    private boolean descriptionParsed = false;
    private boolean closed = false;

     // InputStreamReader uses an 8K buffer. The size is not customizable.
    public static final int BYTE_BUFFER_LEN = 8192;

    // CharToByteUTF8.getMaxBytesPerChar returns 3, so we should not buffer
    // more chars than 3 times the number of bytes we can buffer.
    public static final int CHAR_BUFFER_LEN = BYTE_BUFFER_LEN / 3;

    private static final String FAILURE_MSG =
        &quot;Unable to parse HTML description: &quot;;
    private static final String INVALID_MSG =
        &quot; invalid&quot;;

    //HTML header mapping:
    private long   iHTMLStart,// StartHTML -- shift in array to the first byte after the header
                   iHTMLEnd,  // EndHTML -- shift in array of last byte for HTML syntax analysis
                   iFragStart,// StartFragment -- shift in array jast after &lt;!--StartFragment--&gt;
                   iFragEnd,  // EndFragment -- shift in array before start &lt;!--EndFragment--&gt;
                   iSelStart, // StartSelection -- shift in array of the first char in copied selection
                   iSelEnd;   // EndSelection -- shift in array of the last char in copied selection
    private String stBaseURL; // SourceURL -- base URL for related referenses
    private String stVersion; // Version -- current supported version

    //Stream reader markers:
    private long iStartOffset,
                 iEndOffset,
                 iReadCount;

    private EHTMLReadMode readMode;

    public HTMLCodec(
        InputStream _bytestream,
        EHTMLReadMode _readMode) throws IOException
    {
        bufferedStream = new BufferedInputStream(_bytestream, BYTE_BUFFER_LEN);
        readMode = _readMode;
    }

    public synchronized String getBaseURL() throws IOException
    {
        if( !descriptionParsed ) {
            parseDescription();
        }
        return stBaseURL;
    }
    public synchronized String getVersion() throws IOException
    {
        if( !descriptionParsed ) {
            parseDescription();
        }
        return stVersion;
    }

    /**
     * parseDescription parsing HTML clipboard header as it described in
     * comment to convertToHTMLFormat
     */
    private void parseDescription() throws IOException
    {
        stBaseURL = null;
        stVersion = null;

        // initialization of array offset pointers
        // to the same &quot;uninitialized&quot; state.
        iHTMLEnd =
            iHTMLStart =
                iFragEnd =
                    iFragStart =
                        iSelEnd =
                            iSelStart = -1;

        bufferedStream.mark(BYTE_BUFFER_LEN);
        String astEntries[] = new String[] {
            //common
            VERSION,
            START_HTML,
            END_HTML,
            START_FRAGMENT,
            END_FRAGMENT,
            //ver 1.0
            START_SELECTION,
            END_SELECTION,
            SOURCE_URL
        };
        BufferedReader bufferedReader = new BufferedReader(
            new InputStreamReader(
                bufferedStream,
                ENCODING
            ),
            CHAR_BUFFER_LEN
        );
        long iHeadSize = 0;
        long iCRSize = EOLN.length();
        int iEntCount = astEntries.length;
        boolean bContinue = true;

        for( int  iEntry = 0; iEntry &lt; iEntCount; ++iEntry ){
            String stLine = bufferedReader.readLine();
            if( null==stLine ) {
                break;
            }
            //some header entries are optional, but the order is fixed.
            for( ; iEntry &lt; iEntCount; ++iEntry ){
                if( !stLine.startsWith(astEntries[iEntry]) ) {
                    continue;
                }
                iHeadSize += stLine.length() + iCRSize;
                String stValue = stLine.substring(astEntries[iEntry].length()).trim();
                if( null!=stValue ) {
                    try{
                        switch( iEntry ){
                        case 0:
                            stVersion = stValue;
                            break;
                        case 1:
                            iHTMLStart = Integer.parseInt(stValue);
                            break;
                        case 2:
                            iHTMLEnd = Integer.parseInt(stValue);
                            break;
                        case 3:
                            iFragStart = Integer.parseInt(stValue);
                            break;
                        case 4:
                            iFragEnd = Integer.parseInt(stValue);
                            break;
                        case 5:
                            iSelStart = Integer.parseInt(stValue);
                            break;
                        case 6:
                            iSelEnd = Integer.parseInt(stValue);
                            break;
                        case 7:
                            stBaseURL = stValue;
                            break;
                        };
                    } catch ( NumberFormatException e ) {
                        throw new IOException(FAILURE_MSG + astEntries[iEntry]+ &quot; value &quot; + e + INVALID_MSG);
                    }
                }
                break;
            }
        }
        //some entries could absent in HTML header,
        //so we have find they by another way.
        if( -1 == iHTMLStart )
            iHTMLStart = iHeadSize;
        if( -1 == iFragStart )
            iFragStart = iHTMLStart;
        if( -1 == iFragEnd )
            iFragEnd = iHTMLEnd;
        if( -1 == iSelStart )
            iSelStart = iFragStart;
        if( -1 == iSelEnd )
            iSelEnd = iFragEnd;

        //one of possible modes
        switch( readMode ){
        case HTML_READ_ALL:
            iStartOffset = iHTMLStart;
            iEndOffset = iHTMLEnd;
            break;
        case HTML_READ_FRAGMENT:
            iStartOffset = iFragStart;
            iEndOffset = iFragEnd;
            break;
        case HTML_READ_SELECTION:
        default:
            iStartOffset = iSelStart;
            iEndOffset = iSelEnd;
            break;
        }

        bufferedStream.reset();
        if( -1 == iStartOffset ){
            throw new IOException(FAILURE_MSG + &quot;invalid HTML format.&quot;);
        }

        int curOffset = 0;
        while (curOffset &lt; iStartOffset){
            curOffset += bufferedStream.skip(iStartOffset - curOffset);
        }

        iReadCount = curOffset;

        if( iStartOffset != iReadCount ){
            throw new IOException(FAILURE_MSG + &quot;Byte stream ends in description.&quot;);
        }
        descriptionParsed = true;
    }

    public synchronized int read() throws IOException {
        if( closed ){
            throw new IOException(&quot;Stream closed&quot;);
        }

        if( !descriptionParsed ){
            parseDescription();
        }
        if( -1 != iEndOffset &amp;&amp; iReadCount &gt;= iEndOffset ) {
            return -1;
        }

        int retval = bufferedStream.read();
        if( retval == -1 ) {
            return -1;
        }
        ++iReadCount;
        return retval;
    }

    public synchronized void close() throws IOException {
        if( !closed ){
            closed = true;
            bufferedStream.close();
        }
    }
}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/AndroidFontFinder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import com.sun.glass.utils.NativeLibLoader;

/**
 * Class AndroidFontFinder reads font descriptor from
 * /system/etc/system_fonts.xml. If that file doesn't exist it is replaced by
 * embedded font descriptor {@link com/sun/javafx/font/android_system_fonts.xml} which
 * defines some basic mappings based on best guess which fonts are mandatory on
 * platforms lower than 4.0 and how they map to typefaces.
 */
class AndroidFontFinder {

    private final static String SYSTEM_FONT_NAME    = &quot;sans serif&quot;;
    private final static float SYSTEM_FONT_SIZE     = 16.0f;

    final static String fontDescriptor_2_X_Path = &quot;/com/sun/javafx/font/android_system_fonts.xml&quot;;
    final static String fontDescriptor_4_X_Path = &quot;/system/etc/system_fonts.xml&quot;;
    final static String systemFontsDir = &quot;/system/fonts&quot;;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            NativeLibLoader.loadLibrary(&quot;javafx_font&quot;);
            return null;
        });
    }

    public static String getSystemFont() {
        return SYSTEM_FONT_NAME;
    }

    public static float getSystemFontSize() {
        return SYSTEM_FONT_SIZE;
    }

    public static String getSystemFontsDir() {
        return systemFontsDir;
    }

    private static boolean parse_2_X_SystemDefaultFonts(
            final HashMap&lt;String, String&gt; fontToFileMap,
            final HashMap&lt;String, String&gt; fontToFamilyNameMap,
            final HashMap&lt;String, ArrayList&lt;String&gt;&gt; familyToFontListMap) {

        InputStream is = AndroidFontFinder.class
                .getResourceAsStream(fontDescriptor_2_X_Path);
        if (is == null) {
            System.err
                    .println(&quot;Resource not found: &quot; + fontDescriptor_2_X_Path);
            return false;
        }
        return parseSystemDefaultFonts(is, fontToFileMap, fontToFamilyNameMap,
                familyToFontListMap);
    }

    private static boolean parse_4_X_SystemDefaultFonts(
            final HashMap&lt;String, String&gt; fontToFileMap,
            final HashMap&lt;String, String&gt; fontToFamilyNameMap,
            final HashMap&lt;String, ArrayList&lt;String&gt;&gt; familyToFontListMap) {
        File iFile = new File(fontDescriptor_4_X_Path);
        try {
            return parseSystemDefaultFonts(new FileInputStream(iFile),
                    fontToFileMap, fontToFamilyNameMap, familyToFontListMap);

        } catch (FileNotFoundException e) {
            System.err.println(&quot;File not found: &quot; + fontDescriptor_4_X_Path);
        }
        return false;
    }

    private static boolean parseSystemDefaultFonts(final InputStream is,
            final HashMap&lt;String, String&gt; fontToFileMap,
            final HashMap&lt;String, String&gt; fontToFamilyNameMap,
            final HashMap&lt;String, ArrayList&lt;String&gt;&gt; familyToFontListMap) {

        try {

            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser saxParser = factory.newSAXParser();

            DefaultHandler handler = new DefaultHandler() {
                private final static char DASH      = '-';
                private final static String FAMILY  = &quot;family&quot;;

                private final static String FILE    = &quot;file&quot;;
                private final static String FILESET = &quot;fileset&quot;;
                private final static String NAME    = &quot;name&quot;;
                private final static String NAMESET = &quot;nameset&quot;;
                private final static char SPACE     = ' ';
                final List&lt;String&gt; filesets = new ArrayList&lt;&gt;();

                boolean inFamily = false;
                boolean inFile = false;
                boolean inFileset = false;
                boolean inName = false;
                boolean inNameset = false;

                private final List&lt;String&gt; namesets = new ArrayList&lt;&gt;();
                private final String[] styles = new String[] {
                        &quot;regular&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold italic&quot; };

                public void characters(char[] ch, int start, int length)
                        throws SAXException {
                    if (inName) {
                        String nameset = new String(ch, start, length)
                                .toLowerCase();
                        namesets.add(nameset);
                    } else if (inFile) {
                        String fileset = new String(ch, start, length);
                        filesets.add(fileset);
                    }
                }

                public void endElement(String uri, String localName,
                        String qName) throws SAXException {
                    if (qName.equalsIgnoreCase(FAMILY)) {
                        for (String family : namesets) {
                            int i = 0;
                            String familyName = family.replace(DASH, SPACE);
                            for (String file : filesets) {
                                String fullName = familyName + &quot; &quot; + styles[i];
                                String fullFile = systemFontsDir
                                        + File.separator + file;
                                File f = new File(fullFile);
                                if (!f.exists() || !f.canRead()) {
                                    continue;
                                }
                                fontToFileMap.put(fullName, fullFile);
                                fontToFamilyNameMap.put(fullName, familyName);
                                ArrayList&lt;String&gt; list = familyToFontListMap
                                        .get(familyName);
                                if (list == null) {
                                    list = new ArrayList&lt;String&gt;();
                                    familyToFontListMap.put(familyName, list);
                                }
                                list.add(fullName);
                                i++;
                            }
                        }
                        inFamily = false;
                    } else if (qName.equalsIgnoreCase(NAMESET)) {
                        inNameset = false;
                    } else if (qName.equalsIgnoreCase(FILESET)) {
                        inFileset = false;
                    } else if (qName.equalsIgnoreCase(NAME)) {
                        inName = false;
                    } else if (qName.equalsIgnoreCase(FILE)) {
                        inFile = false;
                    }
                }

                @Override
                public void startElement(String uri, String localName,
                        String qName, Attributes attributes)
                        throws SAXException {
                    if (qName.equalsIgnoreCase(FAMILY)) {
                        inFamily = true;
                        namesets.clear();
                        filesets.clear();
                    } else if (qName.equalsIgnoreCase(NAMESET)) {
                        inNameset = true;
                    } else if (qName.equalsIgnoreCase(FILESET)) {
                        inFileset = true;
                    } else if (qName.equalsIgnoreCase(NAME)) {
                        inName = true;
                    } else if (qName.equalsIgnoreCase(FILE)) {
                        inFile = true;
                    }
<A NAME="15"></A>                }
            };// DefaultHandler

            <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#15',2,'match36-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>saxParser.parse(is, handler);
            return true;

        } catch (IOException e) {
            System.err.println(&quot;Failed to load default fonts descriptor: &quot;
                    + fontDescriptor_4_X_Path);
        }</B></FONT> catch (Exception e) {
            System.err.println(&quot;Failed parsing default fonts descriptor;&quot;);
            e.printStackTrace();
        }
        return false;
    }

    public static void populateFontFileNameMap(
            HashMap&lt;String, String&gt; fontToFileMap,
            HashMap&lt;String, String&gt; fontToFamilyNameMap,
            HashMap&lt;String, ArrayList&lt;String&gt;&gt; familyToFontListMap,
            Locale locale) {

        if (fontToFileMap == null || fontToFamilyNameMap == null
                || familyToFontListMap == null) {
            return;
        }
        if (locale == null) {
            locale = Locale.ENGLISH;
        }

        boolean systemFonts_4_X_DescriptorFound = parse_4_X_SystemDefaultFonts(
                fontToFileMap, fontToFamilyNameMap, familyToFontListMap);
        if (!systemFonts_4_X_DescriptorFound) {
            parse_2_X_SystemDefaultFonts(fontToFileMap, fontToFamilyNameMap,
                    familyToFontListMap);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/stage/WindowHelper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.stage;

import com.sun.javafx.tk.TKStage;
import com.sun.javafx.util.Utils;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.stage.Screen;
import javafx.stage.Window;

import java.security.AccessControlContext;

/**
 * Used to access internal window methods.
 */
public class WindowHelper {
    private static final WindowHelper theInstance;
    private static WindowAccessor windowAccessor;

    static {
        theInstance = new WindowHelper();
        Utils.forceInit(Window.class);
    }

    protected WindowHelper() {
    }

    private static WindowHelper getInstance() {
        return theInstance;
    }

    public static void initHelper(Window window) {
        setHelper(window, getInstance());
    }

    private static WindowHelper getHelper(Window window) {
        return windowAccessor.getHelper(window);
<A NAME="41"></A>    }

    protected static void setHelper(Window window, WindowHelper windowHelper) {
        <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#41',2,'match36-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>windowAccessor.setHelper(window, windowHelper);
    }

    /*
     * Static helper methods for cases where the implementation is done in an
     * instance method that is overridden by subclasses.
     * These methods exist in the base class only.
     */
    public static void visibleChanging(Window window, boolean visible) {
        getHelper(window).visibleChangingImpl(window, visible);
    }

    public static void visibleChanged(Window window, boolean visible) {
        getHelper(window).visibleChangedImpl(window, visible);
    }

    /*
     * Methods that will be overridden by subclasses
     */
    protected void visibleChangingImpl(Window window</B></FONT>, boolean visible) {
        windowAccessor.doVisibleChanging(window, visible);
    }

    protected void visibleChangedImpl(Window window, boolean visible) {
        windowAccessor.doVisibleChanged(window, visible);
    }

    /*
     * Methods used by Window (base) class only
     */

    public static TKStage getPeer(Window window) {
        return windowAccessor.getPeer(window);
    }

    public static void setPeer(Window window, TKStage peer) {
        windowAccessor.setPeer(window, peer);
    }

    public static WindowPeerListener getPeerListener(Window window) {
        return windowAccessor.getPeerListener(window);
    }

    public static void setPeerListener(Window window, WindowPeerListener peerListener) {
        windowAccessor.setPeerListener(window, peerListener);
    }

    public static void setFocused(Window window, boolean value) {
        windowAccessor.setFocused(window, value);
    }

    public static void notifyLocationChanged(final Window window,
                                             final double x,
                                             final double y) {
        windowAccessor.notifyLocationChanged(window, x, y);
    }

    public static void notifySizeChanged(final Window window,
                                         final double width,
                                         final double height) {
        windowAccessor.notifySizeChanged(window, width, height);
    }

    public static void notifyScaleChanged(final Window window,
                                          final double newOutputScaleX,
                                          final double newOutputScaleY) {
        windowAccessor.notifyScaleChanged(window, newOutputScaleX, newOutputScaleY);
    }

    static AccessControlContext getAccessControlContext(Window window) {
        return windowAccessor.getAccessControlContext(window);
    }

    public static void setWindowAccessor(final WindowAccessor newAccessor) {
        if (windowAccessor != null) {
            throw new IllegalStateException();
        }

        windowAccessor = newAccessor;
    }

    public static WindowAccessor getWindowAccessor() {
        return windowAccessor;
    }

    public interface WindowAccessor {
        WindowHelper getHelper(Window window);
        void setHelper(Window window, WindowHelper windowHelper);
        void doVisibleChanging(Window window, boolean visible);
        void doVisibleChanged(Window window, boolean visible);
        TKStage getPeer(Window window);
        void setPeer(Window window, TKStage peer);
        WindowPeerListener getPeerListener(Window window);
        void setPeerListener(Window window, WindowPeerListener peerListener);
        void setFocused(Window window, boolean value);
        void notifyLocationChanged(Window window, double x, double y);

        void notifySizeChanged(Window window, double width, double height);

        void notifyScreenChanged(Window window, Object from, Object to);

        float getPlatformScaleX(Window window);
        float getPlatformScaleY(Window window);

        void notifyScaleChanged(Window window, double newOutputScaleX, double newOutputScaleY);

        ReadOnlyObjectProperty&lt;Screen&gt; screenProperty(Window window);

        AccessControlContext getAccessControlContext(Window window);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/es2/ES2Context.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.es2;

import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGDefaultCamera;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.Material;
import com.sun.prism.RTTexture;
import com.sun.prism.RenderTarget;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.ps.BaseShaderContext;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderFactory;

class ES2Context extends BaseShaderContext {

    // Temporary variables
    private static GeneralTransform3D scratchTx = new GeneralTransform3D();
    private static final GeneralTransform3D flipTx = new GeneralTransform3D();
    private static final Affine3D scratchAffine3DTx = new Affine3D();
    // contains the combined projection/modelview matrix (elements 0-15)
    private static float rawMatrix[] = new float[GLContext.NUM_MATRIX_ELEMENTS];

    private GeneralTransform3D projViewTx = new GeneralTransform3D();
    private GeneralTransform3D worldTx = new GeneralTransform3D();
    private Vec3d cameraPos = new Vec3d();

    private RenderTarget currentTarget;
    private final GLContext glContext;
    private final GLDrawable dummyGLDrawable;
    private final GLPixelFormat pixelFormat;
    private State state;
    private int quadIndices;
    // The drawable that is current to the glContext
    private GLDrawable currentDrawable = null;
    private int indexBuffer = 0;
    private int shaderProgram;

    public static final int NUM_QUADS = PrismSettings.superShader ? 4096 : 256;

    ES2Context(Screen screen, ShaderFactory factory) {
        super(screen, factory, NUM_QUADS);
        GLFactory glF = ES2Pipeline.glFactory;

        // NOTE: There is issue with the returned value of getNativeScreen.
        // HMonitor (Windows), GTKMonitor index (Linux) ...
        // We would prefer HDC (Windows) and screen number(index) (Linux)
        pixelFormat =
                glF.createGLPixelFormat(screen.getNativeScreen(),
                ES2Pipeline.pixelFormatAttributes);

        dummyGLDrawable = glF.createDummyGLDrawable(pixelFormat);
        glContext = glF.createGLContext(dummyGLDrawable, pixelFormat,
                glF.getShareContext(), PrismSettings.isVsyncEnabled);
        makeCurrent(dummyGLDrawable);

        glContext.enableVertexAttributes();
        quadIndices = genQuadsIndexBuffer(NUM_QUADS);
        setIndexBuffer(quadIndices);
        state = new State();
    }

    static short [] getQuadIndices16bit(int numQuads) {
        short data[] = new short[numQuads * 6];

        for (int i = 0; i != numQuads; ++i) {
            int vtx = i * 4;
            int idx = i * 6;
            data[idx+0] = (short) (vtx+0);
            data[idx+1] = (short) (vtx+1);
            data[idx+2] = (short) (vtx+2);

            data[idx+3] = (short) (vtx+2);
            data[idx+4] = (short) (vtx+1);
            data[idx+5] = (short) (vtx+3);
        }

        return data;
    }

    int genQuadsIndexBuffer(int numQuads) {
        if (numQuads * 6 &gt; 0x10000)
            throw new IllegalArgumentException(&quot;vertex indices overflow&quot;);

        return glContext.createIndexBuffer16(getQuadIndices16bit(numQuads));
    }

    final void clearContext() {
        if (currentDrawable != null) {
            currentDrawable.swapBuffers(glContext);
        }
    }

    final void setIndexBuffer(int ib) {
        if (indexBuffer != ib) {
            glContext.setIndexBuffer(indexBuffer = ib);
        }
    }

    GLContext getGLContext() {
        return glContext;
    }

    GLPixelFormat getPixelFormat() {
        return pixelFormat;
    }

    ES2Shader getPhongShader(ES2MeshView meshView) {
        return ES2PhongShader.getShader(meshView, this);
    }

    void makeCurrent(GLDrawable drawable) {
        if (drawable == null) {
            drawable = dummyGLDrawable;
        }
        if (drawable != currentDrawable) {
            glContext.makeCurrent(drawable);
            // Need to restore FBO to on screen framebuffer
            glContext.bindFBO(0);
            currentDrawable = drawable;
        }
    }

    /**
     * Called from ES2Graphics.updateRenderTarget() in response to a window
     * resize event.  This method ensures that the context is made current
     * after the resize event, which is required on Mac OS X in order to
     * force a call to [NSOpenGLContext update].
     */
    void forceRenderTarget(ES2Graphics g) {
        updateRenderTarget(g.getRenderTarget(), g.getCameraNoClone(),
                g.isDepthTest() &amp;&amp; g.isDepthBuffer());
    }

    int getShaderProgram() {
        return shaderProgram;
    }

    // Forcibly sets the current shader program to the given object.
    void setShaderProgram(int progid) {
        shaderProgram = progid;
        glContext.setShaderProgram(progid);
    }

    // Sets the current shader program to the given object only if it was
    // not already the current program.
    void updateShaderProgram(int progid) {
        if (progid != shaderProgram) {
            setShaderProgram(progid);
        }
    }

    @Override
    protected void init() {
        super.init();
    }

    @Override
    protected void releaseRenderTarget() {
        currentTarget = null;
        super.releaseRenderTarget();
    }

    @Override
    protected State updateRenderTarget(RenderTarget target, NGCamera camera,
            boolean depthTest) {
        int fboID = ((ES2RenderTarget)target).getFboID();
        glContext.bindFBO(fboID);

        boolean msaa = false;
        if (target instanceof ES2RTTexture) {
            // Attach a depth buffer to the currently bound FBO
            ES2RTTexture rtTarget = (ES2RTTexture)target;
            msaa = rtTarget.isMSAA();
            if (depthTest) {
                rtTarget.attachDepthBuffer(this);
            }
        }

        // update viewport
        int x = target.getContentX();
        int y = target.getContentY();
        int w = target.getContentWidth();
        int h = target.getContentHeight();
        glContext.updateViewportAndDepthTest(x, y, w, h, depthTest);
        glContext.updateMSAAState(msaa);

        if (camera instanceof NGDefaultCamera) {
            // update projection matrix; this will be uploaded to the shader
            // along with the modelview matrix in updateShaderTransform()
            ((NGDefaultCamera) camera).validate(w, h);
            scratchTx = camera.getProjViewTx(scratchTx);
        } else {
            scratchTx = camera.getProjViewTx(scratchTx);
            // TODO: verify that this is the right solution. There may be
            // other use-cases where rendering needs different viewport size.
            double vw = camera.getViewWidth();
            double vh = camera.getViewHeight();
            if (w != vw || h != vh) {
                scratchTx.scale(vw / w, vh / h, 1.0);
            }
        }

        if (target instanceof ES2RTTexture) {
            // Compute a flipped version of projViewTx
            projViewTx.set(flipTx);
            projViewTx.mul(scratchTx);
        } else {
            projViewTx.set(scratchTx);
        }

        // update camera position; this will be uploaded to the shader
        // when we switch to 3D state
        cameraPos = camera.getPositionInWorld(cameraPos);

        currentTarget = target;
        return state;
    }

    @Override
    protected void updateTexture(int texUnit, Texture tex) {
        glContext.updateActiveTextureUnit(texUnit);

        if (tex == null) {
            glContext.updateBoundTexture(0);
        } else {
            ES2Texture es2Tex = (ES2Texture)tex;
            glContext.updateBoundTexture(es2Tex.getNativeSourceHandle());
            es2Tex.updateWrapState();
            es2Tex.updateFilterState();
        }
    }

    @Override
    protected void updateShaderTransform(Shader shader, BaseTransform xform) {
        if (xform == null) {
            xform = BaseTransform.IDENTITY_TRANSFORM;
        }

        scratchTx.set(projViewTx);
        final GeneralTransform3D perspectiveTransform = getPerspectiveTransformNoClone();
        if (perspectiveTransform.isIdentity()) {
            updateRawMatrix(scratchTx.mul(xform));
        } else {
            updateRawMatrix(scratchTx.mul(xform).mul(perspectiveTransform));
        }

        ES2Shader es2shader = (ES2Shader) shader;
        es2shader.setMatrix(&quot;mvpMatrix&quot;, rawMatrix);
//        printRawMatrix(&quot;mvpMatrix&quot;);

        if (es2shader.isPixcoordUsed()) {
            // the gl_FragCoord variable is in window coordinates and
            // does not take the viewport origin into account (or the fact
            // that we do a y-flip of the projection matrix in the case
            // of onscreen windows for that matter); we need to update
            // the special jsl_pixCoordOffset param here so that the shader
            // can continue to treat pixcoord as if it were in the range
            // [0,0] to [contentWidth,contentHeight] of the destination surface
            float xoff = currentTarget.getContentX();
            float yoff = currentTarget.getContentY();
            float yinv, yflip;
            if (currentTarget instanceof ES2SwapChain) {
                // there is a y-flip in this case
                yinv = currentTarget.getPhysicalHeight();
                yflip = 1f;
            } else {
                // no y-flip for RTTextures
                yinv = 0f;
                yflip = -1f;
            }
            shader.setConstant(&quot;jsl_pixCoordOffset&quot;, xoff, yoff, yinv, yflip);
        }
    }

    @Override
<A NAME="33"></A>    protected void updateWorldTransform(BaseTransform xform) {
        worldTx.setIdentity();
        if ((xform != null) &amp;&amp; (!xform.isIdentity())) {
            <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#33',2,'match36-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>worldTx.mul(xform);
        }
    }

    @Override
    protected void updateClipRect(Rectangle clipRect) {
        if (clipRect == null || clipRect.isEmpty()) {
            glContext.scissorTest</B></FONT>(false, 0, 0, 0, 0);
        } else {
            // the scissor rectangle is specified using the lower-left
            // origin of the clip region (in the framebuffer's coordinate
            // space), so we must account for the x/y offsets of the
            // destination surface, and use a flipped y origin when rendering
            // to an ES2SwapChain
            int w = clipRect.width;
            int h = clipRect.height;
            int x = currentTarget.getContentX();
            int y = currentTarget.getContentY();
            if (currentTarget instanceof ES2RTTexture) {
                x += clipRect.x;
                y += clipRect.y;
            } else {
                int dsth = currentTarget.getPhysicalHeight();
                x += clipRect.x;
                y += dsth - (clipRect.y + h);
            }
            glContext.scissorTest(true, x, y, w, h);
        }
    }

    @Override
    protected void updateCompositeMode(CompositeMode mode) {
        switch (mode) {
            case CLEAR:
                glContext.blendFunc(GLContext.GL_ZERO, GLContext.GL_ZERO);
                break;
            case SRC:
                glContext.blendFunc(GLContext.GL_ONE, GLContext.GL_ZERO);
                break;
            case SRC_OVER:
                glContext.blendFunc(GLContext.GL_ONE, GLContext.GL_ONE_MINUS_SRC_ALPHA);
                break;
            case DST_OUT:
                glContext.blendFunc(GLContext.GL_ZERO, GLContext.GL_ONE_MINUS_SRC_ALPHA);
                break;
            case ADD:
                glContext.blendFunc(GLContext.GL_ONE, GLContext.GL_ONE);
                break;
            default:
                throw new InternalError(&quot;Unrecognized composite mode: &quot; + mode);
        }
    }

    @Override
    public void setDeviceParametersFor2D() {
        // invalidate cache data
        indexBuffer = 0;
        shaderProgram = 0;
        glContext.setDeviceParametersFor2D();

        // Bind vertex attributes and index buffer
        glContext.enableVertexAttributes();
        setIndexBuffer(quadIndices);
    }

    @Override
    public void setDeviceParametersFor3D() {
        // unbind vertex attributes and index buffer
        glContext.disableVertexAttributes();
        glContext.setDeviceParametersFor3D();
    }

    long createES2Mesh() {
        return glContext.createES2Mesh();
    }

    // TODO: 3D - Should this be called dispose?
    void releaseES2Mesh(long nativeHandle) {
        glContext.releaseES2Mesh(nativeHandle);
    }

    boolean buildNativeGeometry(long nativeHandle, float[] vertexBuffer,
            int vertexBufferLength, short[] indexBuffer, int indexBufferLength) {
        return glContext.buildNativeGeometry(nativeHandle, vertexBuffer,
                vertexBufferLength, indexBuffer, indexBufferLength);
    }

    boolean buildNativeGeometry(long nativeHandle, float[] vertexBuffer,
            int vertexBufferLength, int[] indexBuffer, int indexBufferLength) {
        return glContext.buildNativeGeometry(nativeHandle, vertexBuffer,
                vertexBufferLength, indexBuffer, indexBufferLength);
    }

    long createES2PhongMaterial() {
        return glContext.createES2PhongMaterial();
    }

    // TODO: 3D - Should this be called dispose?
    void releaseES2PhongMaterial(long nativeHandle) {
        glContext.releaseES2PhongMaterial(nativeHandle);
    }

    void setSolidColor(long nativeHandle, float r, float g, float b, float a) {
        glContext.setSolidColor(nativeHandle, r, g, b, a);
    }

    void setMap(long nativeHandle, int mapType, int texID) {
        glContext.setMap(nativeHandle, mapType, texID);
    }

    long createES2MeshView(ES2Mesh mesh) {
        return glContext.createES2MeshView(mesh.getNativeHandle());
    }

    // TODO: 3D - Should this be called dispose?
    void releaseES2MeshView(long nativeHandle) {
        glContext.releaseES2MeshView(nativeHandle);
    }

    void setCullingMode(long nativeHandle, int cullingMode) {
        // NOTE: Native code has set clockwise order as front-facing
        glContext.setCullingMode(nativeHandle, cullingMode);
    }

    void setMaterial(long nativeHandle, Material material) {
        ES2PhongMaterial es2Material = (ES2PhongMaterial)material;

        glContext.setMaterial(nativeHandle,
                (es2Material).getNativeHandle());
    }

    void setWireframe(long nativeHandle, boolean wireframe) {
       glContext.setWireframe(nativeHandle, wireframe);
    }

    void setAmbientLight(long nativeHandle, float r, float g, float b) {
        glContext.setAmbientLight(nativeHandle, r, g, b);
    }

    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w) {
        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);
    }

    @Override
    public void blit(RTTexture srcRTT, RTTexture dstRTT,
                     int srcX0, int srcY0, int srcX1, int srcY1,
                     int dstX0, int dstY0, int dstX1, int dstY1)
    {
        // If dstRTT is null then will blit to currently bound fbo
        int dstFboID = dstRTT == null ? 0 : ((ES2RTTexture)dstRTT).getFboID();
        int srcFboID = ((ES2RTTexture)srcRTT).getFboID();
        glContext.blitFBO(srcFboID, dstFboID,
                          srcX0, srcY0, srcX1, srcY1,
                          dstX0, dstY0, dstX1, dstY1);
    }

    void renderMeshView(long nativeHandle, Graphics g, ES2MeshView meshView) {

        ES2Shader shader = (ES2Shader) getPhongShader(meshView);
        setShaderProgram(shader.getProgramObject());

        // Support retina display by scaling the projViewTx and pass it to the shader.
        float pixelScaleFactorX = g.getPixelScaleFactorX();
        float pixelScaleFactorY = g.getPixelScaleFactorY();
        if (pixelScaleFactorX != 1.0 || pixelScaleFactorY != 1.0) {
            scratchTx = scratchTx.set(projViewTx);
            scratchTx.scale(pixelScaleFactorX, pixelScaleFactorY, 1.0);
            updateRawMatrix(scratchTx);
        } else {
            updateRawMatrix(projViewTx);
        }
        shader.setMatrix(&quot;viewProjectionMatrix&quot;, rawMatrix);
        shader.setConstant(&quot;camPos&quot;, (float) cameraPos.x,
                (float) cameraPos.y, (float)cameraPos.z);

        // Undo the SwapChain scaling done in createGraphics() because 3D needs
        // this information in the shader (via projViewTx)
        BaseTransform xform = g.getTransformNoClone();
        if (pixelScaleFactorX != 1.0 || pixelScaleFactorY != 1.0) {
            scratchAffine3DTx.setToIdentity();
            scratchAffine3DTx.scale(1.0 / pixelScaleFactorX, 1.0 / pixelScaleFactorY);
            scratchAffine3DTx.concatenate(xform);
            updateWorldTransform(scratchAffine3DTx);
        } else {
            updateWorldTransform(xform);
        }
        updateRawMatrix(worldTx);

        shader.setMatrix(&quot;worldMatrix&quot;, rawMatrix);
//        printRawMatrix(&quot;worldMatrix&quot;);

        ES2PhongShader.setShaderParamaters(shader, meshView, this);

        glContext.renderMeshView(nativeHandle);
    }

    @Override
    protected void renderQuads(float coordArray[], byte colorArray[], int numVertices) {
        glContext.drawIndexedQuads(coordArray, colorArray, numVertices);
    }

    void printRawMatrix(String mesg) {
        System.err.println(mesg + &quot; = &quot;);
        for (int i = 0; i &lt; 4; i++) {
            System.err.println(rawMatrix[i] + &quot;, &quot; + rawMatrix[i+4]
                    + &quot;, &quot; + rawMatrix[i+8] + &quot;, &quot; + rawMatrix[i+12]);
        }
    }

    // Need to transpose the matrix because OpenGL stores its matrix in
    // column major (though matrix computation is done in row major)
    private void updateRawMatrix(GeneralTransform3D src) {
        rawMatrix[0]  = (float)src.get(0); // Scale X
        rawMatrix[1]  = (float)src.get(4); // Shear Y
        rawMatrix[2]  = (float)src.get(8);
        rawMatrix[3]  = (float)src.get(12);
        rawMatrix[4]  = (float)src.get(1); // Shear X
        rawMatrix[5]  = (float)src.get(5); // Scale Y
        rawMatrix[6]  = (float)src.get(9);
        rawMatrix[7]  = (float)src.get(13);
        rawMatrix[8]  = (float)src.get(2);
        rawMatrix[9]  = (float)src.get(6);
        rawMatrix[10] = (float)src.get(10);
        rawMatrix[11] = (float)src.get(14);
        rawMatrix[12] = (float)src.get(3);  // Translate X
        rawMatrix[13] = (float)src.get(7);  // Translate Y
        rawMatrix[14] = (float)src.get(11);
        rawMatrix[15] = (float)src.get(15);
    }

    static {
        BaseTransform tx = Affine2D.getScaleInstance(1.0, -1.0);
        flipTx.setIdentity();
        flipTx.mul(tx);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/BaseResourcePool.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl;

import java.lang.ref.WeakReference;

/**
 * The base implementation of the {@link ResourcePool} interface, providing
 * bookkeeping for the {@link managed()} method and support for sharing
 * resources amongst multiple pools.
 * @param &lt;T&gt; the type of objects stored in this resource pool
 */
public abstract class BaseResourcePool&lt;T&gt; implements ResourcePool&lt;T&gt; {
    // Number of calls to freeDisposalRequestedAndCheckResources() before we
    // consider a resource to have not been used in a hypothetical &quot;FOREVER&quot;.
    private static final int FOREVER = 1024;
    // Number of calls to freeDisposalRequestedAndCheckResources() before we
    // consider a resource to have not been used &quot;RECENTLY&quot;, with different
    // cutoffs for useful and unuseful textures.
    private static final int RECENTLY_USEFUL = 100;
    private static final int RECENT = 10;

    static interface Predicate {
        boolean test(ManagedResource&lt;?&gt; mr);
    }

    private static final Predicate stageTesters[];
    private static final String    stageReasons[];
    static {
        stageTesters = new Predicate[6];
        stageReasons = new String[6];
        stageTesters[0] = (mr) -&gt; { return !mr.isInteresting() &amp;&amp; mr.getAge() &gt; FOREVER; };
        stageReasons[0] = &quot;Pruning unuseful older than &quot;+FOREVER;
        stageTesters[1] = (mr) -&gt; { return !mr.isInteresting() &amp;&amp; mr.getAge() &gt; FOREVER/2; };
        stageReasons[1] = &quot;Pruning unuseful older than &quot;+FOREVER/2;
        stageTesters[2] = (mr) -&gt; { return !mr.isInteresting() &amp;&amp; mr.getAge() &gt; RECENT; };
        stageReasons[2] = &quot;Pruning unuseful older than &quot;+RECENT;
        stageTesters[3] = (mr) -&gt; { return mr.getAge() &gt; FOREVER; };
        stageReasons[3] = &quot;Pruning all older than &quot;+FOREVER;
        stageTesters[4] = (mr) -&gt; { return mr.getAge() &gt; FOREVER/2; };
        stageReasons[4] = &quot;Pruning all older than &quot;+FOREVER/2;
        stageTesters[5] = (mr) -&gt; { return mr.getAge() &gt; RECENTLY_USEFUL; };
        stageReasons[5] = &quot;Pruning all older than &quot;+RECENTLY_USEFUL;
    }

    long managedSize;
    final long origTarget;
    long curTarget;
    final long maxSize;
    final ResourcePool&lt;T&gt; sharedParent;
    private final Thread managerThread;
    private WeakLinkedList&lt;T&gt; resourceHead;

    protected BaseResourcePool(long target, long max) {
        this(null, target, max);
    }

    protected BaseResourcePool(ResourcePool&lt;T&gt; parent) {
        this(parent, parent.target(), parent.max());
    }

    protected BaseResourcePool(ResourcePool&lt;T&gt; parent, long target, long max) {
        this.resourceHead = new WeakLinkedList&lt;&gt;();
        this.sharedParent = parent;
        this.origTarget = this.curTarget = target;
        this.maxSize = ((parent == null)
                        ? max
                        : Math.min(parent.max(), max));
        managerThread = Thread.currentThread();
    }

    /**
     * Clean up the resources in the indicated pool using a standard
     * algorithm until at least the specified amount of resource units
     * have been reclaimed.
     * The standard algorithm uses the following stages until it obtains
     * enough room in the pool:
     * &lt;ol&gt;
     * &lt;li&gt; Prune any resources which are already free, but have not been
     *      accounted for yet.
     * &lt;li&gt; Go through a few passes cleaning out any non-interesting resources
     *      that have not been used in a long time with decreasing cutoff
     *      limits for the maximum age of the resource.
     * &lt;li&gt; Go through more passes cleaning out even interesting resources that
     *      have not been used in a fairly long time with decreasing age limits.
     * &lt;li&gt; Attempt to grow the target to accommodate the new request.
     * &lt;li&gt; Finally, prune any resources that are not currently in the process
     *      of being used (i.e. locked or permanent).
     * &lt;/ol&gt;
     *
     * @param needed
     * @return boolean indicating if the requested space is now available
     */
    public boolean cleanup(long needed) {
        if (used() + needed &lt;= target()) return true;
        long wasused = used();
        long wanted = target() / 16;
        if (wanted &lt; needed) {
            wanted = needed;
        }
        if (PrismSettings.poolDebug) {
            System.err.printf(&quot;Need %,d (hoping for %,d) from pool: %s\n&quot;, needed, wanted, this);
            printSummary(false);
        }

        try {
            // First cleanup pass is just for previously freed resources that
            // are in the Disposer queue already or were manually freed by
            // mechanisms and are still in the accounting list.
            // The pruner predicate choose no additional resources to free.
            Disposer.cleanUp();
            if (PrismSettings.poolDebug) System.err.println(&quot;Pruning obsolete in pool: &quot;+this);
            cleanup((mr) -&gt; { return false; });
            if (used() + wanted &lt;= target()) return true;

            // Multiple stages of pruning useful and unuseful resources of
            // various ages as determined by the static initializer above.
            for (int stage = 0; stage &lt; stageTesters.length; stage++) {
                if (PrismSettings.poolDebug) {
                    System.err.println(stageReasons[stage]+&quot; in pool: &quot;+this);
                }
                cleanup(stageTesters[stage]);
                if (used() + wanted &lt;= target()) return true;
            }

            // Now look to grow the target if we can satisfy this allocation at
            // less than max().
            long rem = max() - used();
            if (wanted &gt; rem) {
                wanted = needed;
            }
            if (wanted &lt;= rem) {
                long grow = (max() - origTarget()) / 32;
                if (grow &lt; wanted) {
                    grow = wanted;
                } else if (grow &gt; rem) {
                    grow = rem;
                }
                setTarget(used() + grow);
                if (PrismSettings.poolDebug || PrismSettings.verbose) {
                    System.err.printf(&quot;Growing pool %s target to %,d\n&quot;, this, target());
                }
                return true;
            }

            // Finally, look to the garbage collector to dislodge some unreferenced
            // resources that we can free with a very aggressive age set of (0, 0)
            // which will target all unlocked/non-permanent textures.
            // Two tries, one with just a gc(), and a desperate one with a sleep...
            for (int i = 0; i &lt; 2; i++) {
                pruneLastChance(i &gt; 0);
                if (used() + needed &lt;= max()) {
                    if (used() + needed &gt; target()) {
                        setTarget(used() + needed);
                        if (PrismSettings.poolDebug || PrismSettings.verbose) {
                            System.err.printf(&quot;Growing pool %s target to %,d\n&quot;, this, target());
                        }
                    }
                    return true;
                }
            }

            // That was our last gasp, we either succeeded in making room under
            // the max() amount or we failed and need to return false.
            return false;
        } finally {
            if (PrismSettings.poolDebug) {
                System.err.printf(&quot;cleaned up %,d from pool: %s\n&quot;, wasused - used(), this);
                printSummary(false);
                System.err.println();
            }
        }
    }

    private void pruneLastChance(boolean desperate) {
        System.gc();
        if (desperate) {
            // Our alternative is to return false here and cause an allocation
            // failure which is usually bad news for any SG, so it is worth
            // sleeping on the second time around to give one last GC some time
            // to find a dead resource that was dropped on the floor...
            try { Thread.sleep(20); }
            catch (InterruptedException e) { }
        }
        Disposer.cleanUp();
        if (PrismSettings.poolDebug) {
            if (desperate) {
                System.err.print(&quot;Last chance pruning&quot;);
            } else {
                System.err.print(&quot;Pruning everything&quot;);
            }
            System.err.println(&quot; in pool: &quot;+this);
        }
        cleanup((mr) -&gt; { return true; });
    }

    private void cleanup(Predicate predicate) {
        WeakLinkedList&lt;T&gt; prev = resourceHead;
        WeakLinkedList&lt;T&gt; cur = prev.next;
        while (cur != null) {
            ManagedResource&lt;T&gt; mr = cur.getResource();
            if (ManagedResource._isgone(mr)) {
                if (PrismSettings.poolDebug) showLink(&quot;unlinking&quot;, cur, false);
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
            } else if (!mr.isPermanent() &amp;&amp;
                       !mr.isLocked() &amp;&amp;
                       predicate.test(mr))
            {
                if (PrismSettings.poolDebug) showLink(&quot;pruning&quot;, cur, true);
                mr.free();
                mr.resource = null;
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
            } else {
                prev = cur;
                cur = cur.next;
            }
        }
    }

    static void showLink(String label, WeakLinkedList&lt;?&gt; cur, boolean showAge) {
        ManagedResource&lt;?&gt; mr = cur.getResource();
        System.err.printf(&quot;%s: %s (size=%,d)&quot;, label, mr, cur.size);
        if (mr != null) {
            if (showAge) {
                System.err.printf(&quot; (age=%d)&quot;, mr.getAge());
            }
            if (mr.isPermanent())   System.err.print(&quot; perm&quot;);
            if (mr.isLocked())      System.err.print(&quot; lock&quot;);
            if (mr.isInteresting()) System.err.print(&quot; int&quot;);
        }
        System.err.println();
    }

    /**
     * Check that all resources are in the correct state for an idle condition
     * and free any resources which were disposed from a non-resource thread.
     * This method must be called on a thread that is appropriate for disposing
     * and managing resources for the resource pools.
     * The boolean {@code forgiveStaleLocks} parameter is used to indicate that
     * an exceptional condition occurred which caused the caller to abort a
     * cycle of resource usage, potentially with outstanding resource locks.
     * This method will unlock all non-permanent resources that have outstanding
     * locks if {@code forgiveStaleLocks} is {@code true}, or it will print out
     * a warning and a resource summary if that parameter is {@code false}.
     *
     * @param forgiveStaleLocks {@code true} if the caller wishes to forgive
     *         and unlock all outstanding locks on non-permanent resources
     */
    @Override
    public void freeDisposalRequestedAndCheckResources(boolean forgiveStaleLocks) {
        boolean anyLockedResources = false;
        WeakLinkedList&lt;T&gt; prev = resourceHead;
        WeakLinkedList&lt;T&gt; cur = prev.next;
        while (cur != null) {
            ManagedResource&lt;?&gt; mr = cur.getResource();
            if (ManagedResource._isgone(mr)) {
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
            } else {
                if (!mr.isPermanent()) {
                    if (mr.isLocked() &amp;&amp; !mr.wasMismatched()) {
                        if (forgiveStaleLocks) {
                            mr.unlockall();
                        } else {
                            mr.setMismatched();
                            anyLockedResources = true;
                        }
                    }
                    mr.bumpAge(FOREVER);
                }
                prev = cur;
                cur = cur.next;
            }
        }

        if (PrismSettings.poolStats || anyLockedResources) {
            if (anyLockedResources) {
                System.err.println(&quot;Outstanding resource locks detected:&quot;);
            }
            printSummary(true);
            System.err.println();
        }
    }

    static String commas(long v) {
        return String.format(&quot;%,d&quot;, v);
    }

    public void printSummary(boolean printlocksources) {
        int numgone = 0;
        int numlocked = 0;
        int numpermanent = 0;
        int numinteresting = 0;
        int nummismatched = 0;
        int numancient = 0;
        long total_age = 0;
        int total = 0;
        boolean trackLockSources = ManagedResource.trackLockSources;

        double percentUsed = used() * 100.0 / max();
        double percentTarget = target() * 100.0 / max();
        System.err.printf(&quot;%s: %,d used (%.1f%%), %,d target (%.1f%%), %,d max\n&quot;,
                          this, used(), percentUsed,
                          target(), percentTarget,
                          max());

        for (WeakLinkedList&lt;T&gt; cur = resourceHead.next; cur != null; cur = cur.next) {
            ManagedResource&lt;T&gt; mr = cur.getResource();
            total++;
            if (mr == null || !mr.isValid() || mr.isDisposalRequested()) {
                numgone++;
            } else {
                int a = mr.getAge();
                total_age += a;
                if (a &gt;= FOREVER) {
                    numancient++;
                }
                if (mr.wasMismatched()) {
                    nummismatched++;
                }
                if (mr.isPermanent()) {
                    numpermanent++;
                } else if (mr.isLocked()) {
                    numlocked++;
                    if (trackLockSources &amp;&amp; printlocksources) {
                        for (Throwable th : mr.lockedFrom) {
                            th.printStackTrace(System.err);
                        }
                        mr.lockedFrom.clear();
                    }
                }
                if (mr.isInteresting()) {
                    numinteresting++;
                }
            }
        }

        double avg_age = ((double) total_age) / total;
        System.err.println(total+&quot; total resources being managed&quot;);
        System.err.printf(&quot;average resource age is %.1f frames\n&quot;, avg_age);
        printpoolpercent(numancient, total, &quot;at maximum supported age&quot;);
        printpoolpercent(numpermanent, total, &quot;marked permanent&quot;);
        printpoolpercent(nummismatched, total, &quot;have had mismatched locks&quot;);
        printpoolpercent(numlocked, total, &quot;locked&quot;);
        printpoolpercent(numinteresting, total, &quot;contain interesting data&quot;);
        printpoolpercent(numgone, total, &quot;disappeared&quot;);
    }

    private static void printpoolpercent(int stat, int total, String desc) {
        double percent = stat * 100.0 / total;
        System.err.printf(&quot;%,d resources %s (%.1f%%)\n&quot;, stat, desc, percent);
    }

    @Override
    public boolean isManagerThread() {
        return Thread.currentThread() == managerThread;
    }

    @Override
    public final long managed() {
        return managedSize;
    }

    @Override
    public long used() {
        if (sharedParent != null) {
            return sharedParent.used();
        }
        return managedSize;
    }

    @Override
    public final long max() {
        return maxSize;
    }

    @Override
    public final long origTarget() {
        return origTarget;
    }

    @Override
    public final long target() {
        return curTarget;
    }

    @Override
    public final void setTarget(long newTarget) {
        if (newTarget &gt; maxSize) {
            throw new IllegalArgumentException(&quot;New target &quot;+newTarget+
                                               &quot; larger than max &quot;+maxSize);
        }
        if (newTarget &lt; origTarget) {
            throw new IllegalArgumentException(&quot;New target &quot;+newTarget+
                                               &quot; smaller than initial target &quot;+origTarget);
        }
        curTarget = newTarget;
    }

    @Override
    public boolean prepareForAllocation(long size) {
        return cleanup(size);
    }

    @Override
    public final void recordAllocated(long size) {
<A NAME="37"></A>        managedSize += size;
    }

    <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#37',2,'match36-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public final void resourceManaged(ManagedResource&lt;T&gt; mr) {
        long size = size(mr.resource);
        resourceHead.insert(mr, size);
        recordAllocated(size);
    }

    @Override
    public final void resourceFreed(ManagedResource&lt;T&gt; freed) {</B></FONT>
        WeakLinkedList&lt;T&gt; prev = resourceHead;
        WeakLinkedList&lt;T&gt; cur = prev.next;
        while (cur != null) {
            ManagedResource&lt;T&gt; res = cur.getResource();
            if (res == null || res == freed) {
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
                if (res == freed) {
                    return;
                }
            } else {
                prev = cur;
                cur = cur.next;
            }
        }
        throw new IllegalStateException(&quot;unmanaged resource freed from pool &quot;+this);
    }

    @Override
    public final void recordFree(long size) {
        managedSize -= size;
        if (managedSize &lt; 0) {
            throw new IllegalStateException(&quot;Negative resource amount&quot;);
        }
    }

    static class WeakLinkedList&lt;T&gt; {
        final WeakReference&lt;ManagedResource&lt;T&gt;&gt; theResourceRef;
        final long size;
        WeakLinkedList&lt;T&gt; next;

        WeakLinkedList() {
            this.theResourceRef = null;
            this.size = 0L;
        }

        WeakLinkedList(ManagedResource&lt;T&gt; mresource, long size, WeakLinkedList&lt;T&gt; next) {
            this.theResourceRef = new WeakReference&lt;&gt;(mresource);
            this.size = size;
            this.next = next;
        }

        void insert(ManagedResource&lt;T&gt; mresource, long size) {
            this.next = new WeakLinkedList&lt;&gt;(mresource, size, next);
        }

        ManagedResource&lt;T&gt; getResource() {
            return theResourceRef.get();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/J2DPrismGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d;

import java.awt.LinearGradientPaint;
import java.awt.font.GlyphVector;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.lang.ref.WeakReference;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import com.sun.glass.ui.Screen;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.font.CompositeGlyphMapper;
import com.sun.javafx.font.CompositeStrike;
import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NodePath;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.MaskTextureGraphics;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.j2d.paint.MultipleGradientPaint.ColorSpaceType;
import com.sun.prism.j2d.paint.RadialGradientPaint;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.paint.Stop;
import static java.awt.RenderingHints.KEY_ANTIALIASING;
import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_OFF;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;
import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;
import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;

public class J2DPrismGraphics
    // Do not subclass BaseGraphics without fixing drawTextureVO below...
    implements ReadbackGraphics, MaskTextureGraphics
    // Do not implement RectShadowGraphics without fixing RT-15016 (note that
    // BaseGraphics implements RectShadowGraphics).
{
    static {
        // Assuming direct translation of BasicStroke enums:
        assert(com.sun.prism.BasicStroke.CAP_BUTT == java.awt.BasicStroke.CAP_BUTT);
        assert(com.sun.prism.BasicStroke.CAP_ROUND == java.awt.BasicStroke.CAP_ROUND);
        assert(com.sun.prism.BasicStroke.CAP_SQUARE == java.awt.BasicStroke.CAP_SQUARE);
        assert(com.sun.prism.BasicStroke.JOIN_BEVEL == java.awt.BasicStroke.JOIN_BEVEL);
        assert(com.sun.prism.BasicStroke.JOIN_MITER == java.awt.BasicStroke.JOIN_MITER);
        assert(com.sun.prism.BasicStroke.JOIN_ROUND == java.awt.BasicStroke.JOIN_ROUND);
        // Assuming direct translation of PathIterator enums:
        assert(com.sun.javafx.geom.PathIterator.WIND_EVEN_ODD == java.awt.geom.PathIterator.WIND_EVEN_ODD);
        assert(com.sun.javafx.geom.PathIterator.WIND_NON_ZERO == java.awt.geom.PathIterator.WIND_NON_ZERO);
        assert(com.sun.javafx.geom.PathIterator.SEG_MOVETO == java.awt.geom.PathIterator.SEG_MOVETO);
        assert(com.sun.javafx.geom.PathIterator.SEG_LINETO == java.awt.geom.PathIterator.SEG_LINETO);
        assert(com.sun.javafx.geom.PathIterator.SEG_QUADTO == java.awt.geom.PathIterator.SEG_QUADTO);
        assert(com.sun.javafx.geom.PathIterator.SEG_CUBICTO == java.awt.geom.PathIterator.SEG_CUBICTO);
        assert(com.sun.javafx.geom.PathIterator.SEG_CLOSE == java.awt.geom.PathIterator.SEG_CLOSE);
    }
    static final LinearGradientPaint.CycleMethod LGP_CYCLE_METHODS[] = {
        LinearGradientPaint.CycleMethod.NO_CYCLE,
        LinearGradientPaint.CycleMethod.REFLECT,
        LinearGradientPaint.CycleMethod.REPEAT,
    };
    static final RadialGradientPaint.CycleMethod RGP_CYCLE_METHODS[] = {
        RadialGradientPaint.CycleMethod.NO_CYCLE,
        RadialGradientPaint.CycleMethod.REFLECT,
        RadialGradientPaint.CycleMethod.REPEAT,
    };

    private static final BasicStroke DEFAULT_STROKE =
        new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f);
    private static final Paint DEFAULT_PAINT = Color.WHITE;
    static java.awt.geom.AffineTransform J2D_IDENTITY =
        new java.awt.geom.AffineTransform();
    private int clipRectIndex;
    private boolean hasPreCullingBits = false;
    private float pixelScaleX = 1.0f;
    private float pixelScaleY = 1.0f;

    static java.awt.Color toJ2DColor(Color c) {
        return new java.awt.Color(c.getRed(),
                                  c.getGreen(),
                                  c.getBlue(),
                                  c.getAlpha());
    }

    /*
     * Ensure that no fractions are equal
     *
     * Note that the J2D objects reject equal fractions, but the FX versions
     * allow them.
     *
     * The FX version treats values with equal fractions such that as you
     * approach the fractional value from below it interpolates to the
     * first color associated with that fraction and as you interpolate
     * away from it from above it interpolates the last such color.
     *
     * To get the J2D version to exhibit the FX behavior we collapse all
     * adjacent fractional values into a pair of values that are stored
     * with a pair of immediately adjacent floating point values.  This way
     * they have unique fractions, but no fractional value can be generated
     * which fits between them.  Yet, as you approach from below it will
     * interpolate to the first of the pair of colors and as you move away
     * above it, the second value will take precedence for interpolation.
     *
     * Math.ulp() is used to generate an &quot;immediately adjacent fp value&quot;.
     */
    static int fixFractions(float fractions[], java.awt.Color colors[]) {
        float fprev = fractions[0];
        int i = 1;  // index of next incoming color/fractions we will examine
        int n = 1;  // index of next outgoing color/fraction we will store
        while (i &lt; fractions.length) {
            float f = fractions[i];
            java.awt.Color c = colors[i++];
            if (f &lt;= fprev) {
                // If we find any duplicates after we reach 1.0 we can
                // just ignore the rest of the array.  Not only is there
                // no more &quot;fraction room&quot; to assign them to, but we will
                // never generate a fraction &gt;1.0 to access them anyway
                if (f &gt;= 1.0f) break;
                // Find all fractions that are either fprev or fprev+ulp
                // and collapse them into two entries, the first at fprev
                // which is already stored, and the last matching entry
                // will be stored with fraction fprev+ulp
                f = fprev + Math.ulp(fprev);
                while (i &lt; fractions.length) {
                    if (fractions[i] &gt; f) break;
                    // We continue to remember the color of the last
                    // &quot;matching&quot; entry so it can be stored below
                    c = colors[i++];
                }
            }
            fractions[n] = fprev = f;
            colors[n++] = c;
        }
        return n;
    }

    java.awt.Paint toJ2DPaint(Paint p, java.awt.geom.Rectangle2D b) {
        if (p instanceof Color) {
            return toJ2DColor((Color) p);
        } else if (p instanceof Gradient) {
            Gradient g = (Gradient) p;
            if (g.isProportional()) {
                if (b == null) {
                    return null;
                }
            }
            List&lt;Stop&gt; stops = g.getStops();
            int n = stops.size();
            float fractions[] = new float[n];
            java.awt.Color colors[] = new java.awt.Color[n];
            float prevf = -1f;
            boolean needsFix = false;
            for (int i = 0; i &lt; n; i++) {
                Stop stop = stops.get(i);
                float f = stop.getOffset();
                needsFix = (needsFix || f &lt;= prevf);
                fractions[i] = prevf = f;
                colors[i] = toJ2DColor(stop.getColor());
            }
            if (needsFix) {
                n = fixFractions(fractions, colors);
                if (n &lt; fractions.length) {
                    float newf[] = new float[n];
                    System.arraycopy(fractions, 0, newf, 0, n);
                    fractions = newf;
                    java.awt.Color newc[] = new java.awt.Color[n];
                    System.arraycopy(colors, 0, newc, 0, n);
                    colors = newc;
                }
            }
            if (g instanceof LinearGradient) {
                LinearGradient lg = (LinearGradient) p;
                float x1 = lg.getX1();
                float y1 = lg.getY1();
                float x2 = lg.getX2();
                float y2 = lg.getY2();
                if (g.isProportional()) {
                    float x = (float) b.getX();
                    float y = (float) b.getY();
                    float w = (float) b.getWidth();
                    float h = (float) b.getHeight();
                    x1 = x + w * x1;
                    y1 = y + h * y1;
                    x2 = x + w * x2;
                    y2 = y + h * y2;
                }
                if (x1 == x2 &amp;&amp; y1 == y2) {
                    // Hardware pipelines use an inverse transform of
                    // all zeros to choose colors when the start and end
                    // point are the same so that the first color is
                    // always chosen...
                    return colors[0];
                }
                java.awt.geom.Point2D p1 =
                    new java.awt.geom.Point2D.Float(x1, y1);
                java.awt.geom.Point2D p2 =
                    new java.awt.geom.Point2D.Float(x2, y2);
                LinearGradientPaint.CycleMethod method =
                    LGP_CYCLE_METHODS[g.getSpreadMethod()];
                return new LinearGradientPaint(p1, p2, fractions, colors, method);
            } else if (g instanceof RadialGradient) {
                RadialGradient rg = (RadialGradient) g;
                float cx = rg.getCenterX();
                float cy = rg.getCenterY();
                float r = rg.getRadius();
                double fa = Math.toRadians(rg.getFocusAngle());
                float fd = rg.getFocusDistance();
                java.awt.geom.AffineTransform at = J2D_IDENTITY;
                if (g.isProportional()) {
                    float x = (float) b.getX();
                    float y = (float) b.getY();
                    float w = (float) b.getWidth();
                    float h = (float) b.getHeight();
                    float dim = Math.min(w, h);
                    float bcx = x + w * 0.5f;
                    float bcy = y + h * 0.5f;
                    cx = bcx + (cx - 0.5f) * dim;
                    cy = bcy + (cy - 0.5f) * dim;
                    r *= dim;
                    if (w != h &amp;&amp; w != 0.0 &amp;&amp; h != 0.0) {
                        at = java.awt.geom.AffineTransform.getTranslateInstance(bcx, bcy);
                        at.scale(w / dim, h / dim);
                        at.translate(-bcx, -bcy);
                    }
                }
                java.awt.geom.Point2D center =
                    new java.awt.geom.Point2D.Float(cx, cy);
                float fx = (float) (cx + fd * r * Math.cos(fa));
                float fy = (float) (cy + fd * r * Math.sin(fa));
                java.awt.geom.Point2D focus =
                    new java.awt.geom.Point2D.Float(fx, fy);
                RadialGradientPaint.CycleMethod method =
                    RGP_CYCLE_METHODS[g.getSpreadMethod()];
                return new RadialGradientPaint(center, r, focus, fractions, colors,
                                               method, ColorSpaceType.SRGB, at);
            }
        } else if (p instanceof ImagePattern) {
            ImagePattern imgpat = (ImagePattern) p;
            float x = imgpat.getX();
            float y = imgpat.getY();
            float w = imgpat.getWidth();
            float h = imgpat.getHeight();
            if (p.isProportional()) {
                if (b == null) {
                    return null;
                }
                float bx = (float) b.getX();
                float by = (float) b.getY();
                float bw = (float) b.getWidth();
                float bh = (float) b.getHeight();
                w += x;
                h += y;
                x = bx + x * bw;
                y = by + y * bh;
                w = bx + w * bw;
                h = by + h * bh;
                w -= x;
                h -= y;
            }
            Texture tex =
                getResourceFactory().getCachedTexture(imgpat.getImage(), WrapMode.REPEAT);
            java.awt.image.BufferedImage bimg = ((J2DTexture) tex).getBufferedImage();
            tex.unlock();
            return new java.awt.TexturePaint(bimg, tmpRect(x, y, w, h));
        }
        throw new UnsupportedOperationException(&quot;Paint &quot;+p+&quot; not supported yet.&quot;);
    }

    static java.awt.Stroke toJ2DStroke(BasicStroke stroke) {
        float lineWidth = stroke.getLineWidth();
        int type = stroke.getType();
        if (type != BasicStroke.TYPE_CENTERED) {
            lineWidth *= 2;
        }
        java.awt.BasicStroke bs =
                new java.awt.BasicStroke(lineWidth,
                                         stroke.getEndCap(),
                                         stroke.getLineJoin(),
                                         stroke.getMiterLimit(),
                                         stroke.getDashArray(),
                                         stroke.getDashPhase());
        if (type == BasicStroke.TYPE_INNER) {
            return new InnerStroke(bs);
        } else if (type == BasicStroke.TYPE_OUTER) {
            return new OuterStroke(bs);
        } else {
            return bs;
        }
    }

    private static ConcurrentHashMap&lt;java.awt.Font,
                                     WeakReference&lt;java.awt.Font&gt;&gt;
        fontMap = new ConcurrentHashMap&lt;java.awt.Font,
                                        WeakReference&lt;java.awt.Font&gt;&gt;();
    private static volatile int cleared = 0;

    private static java.awt.Font toJ2DFont(FontStrike strike) {
        FontResource fr = strike.getFontResource();
        java.awt.Font j2dfont;
        Object peer = fr.getPeer();
        if (peer == null &amp;&amp; fr.isEmbeddedFont()) {
            J2DFontFactory.registerFont(fr);
            peer = fr.getPeer();
        }
        if (peer != null &amp;&amp; peer instanceof java.awt.Font) {
            j2dfont = (java.awt.Font)peer;
        } else {
            if (PlatformUtil.isMac()) {
                // Looking up J2D fonts via full name is not reliable on the
                // Mac, however using the PostScript font name is. The likely
                // cause is Mac platform internals heavy reliance on PostScript
                // names for font identification.
                String psName = fr.getPSName();
                // dummy size
                j2dfont = new java.awt.Font(psName, java.awt.Font.PLAIN, 12);

                // REMIND: Due to bugs in j2d font lookup, these two workarounds
                // are required to ensure the correct font is used. Once fixed
                // in the jdk these workarounds should be removed.
                if (!j2dfont.getPSName().equals(psName)) {
                    // 1. Lookup font via family and style. This covers the
                    // case when the J2D PostScript name does not match psName
                    // in font file. For example &quot;HelveticaCYBold&quot; has the
                    // psName &quot;HelveticaCY-Bold&quot; in j2d.
                    int style = fr.isBold() ? java.awt.Font.BOLD : 0;
                    style = style | (fr.isItalic() ? java.awt.Font.ITALIC : 0);
                    j2dfont = new java.awt.Font(fr.getFamilyName(), style, 12);

                    if(!j2dfont.getPSName().equals(psName)) {
                        // 2. J2D seems to be unable to find a few fonts where
                        // psName == familyName.  Workaround is an exhaustive
                        // search of all fonts.
                        java.awt.Font[] allj2dFonts =
                                java.awt.GraphicsEnvironment.
                                getLocalGraphicsEnvironment().getAllFonts();
                        for (java.awt.Font f : allj2dFonts) {
                            if (f.getPSName().equals(psName)) {
                                j2dfont = f;
                                break;
                            }
                        }
                    }
                }
            } else {
                // dummy size
                j2dfont = new java.awt.Font(fr.getFullName(),
                                            java.awt.Font.PLAIN, 12);
            }

            // Adding j2dfont as peer is OK since fr is a decomposed
            // FontResource. Thus preventing font lookup next time we render.
            fr.setPeer(j2dfont);
        }
        // deriveFont(...) still has a bug and will cause #2 problem to occur
        j2dfont = j2dfont.deriveFont(strike.getSize()); // exact float font size
        java.awt.Font compFont = null;
        WeakReference&lt;java.awt.Font&gt; ref = fontMap.get(j2dfont);
        if (ref != null) {
            compFont = ref.get();
            if (compFont == null) {
                cleared++;
            }
        }
        if (compFont == null) {
            if (fontMap.size() &gt; 100 &amp;&amp; cleared &gt; 10) { // purge the map.
                for (java.awt.Font key : fontMap.keySet()) {
                    ref = fontMap.get(key);
                    if (ref == null || ref.get() == null) {
                        fontMap.remove(key);
                    }
                }
                cleared = 0;
            }
            compFont = J2DFontFactory.getCompositeFont(j2dfont);
            ref = new WeakReference(compFont);
            fontMap.put(j2dfont, ref);
        }
        return compFont;
    }

    public static java.awt.geom.AffineTransform
        toJ2DTransform(BaseTransform t)
    {
        return new java.awt.geom.AffineTransform(t.getMxx(), t.getMyx(),
                                                 t.getMxy(), t.getMyy(),
                                                 t.getMxt(), t.getMyt());
    }

    private static java.awt.geom.AffineTransform tmpAT =
        new java.awt.geom.AffineTransform();
    static java.awt.geom.AffineTransform tmpJ2DTransform(BaseTransform t)
    {
        tmpAT.setTransform(t.getMxx(), t.getMyx(),
                           t.getMxy(), t.getMyy(),
                           t.getMxt(), t.getMyt());
        return tmpAT;
    }

    static BaseTransform toPrTransform(java.awt.geom.AffineTransform t)
    {
        return BaseTransform.getInstance(t.getScaleX(), t.getShearY(),
                                         t.getShearX(), t.getScaleY(),
                                         t.getTranslateX(), t.getTranslateY());
    }

    static Rectangle toPrRect(java.awt.Rectangle r)
    {
        return new Rectangle(r.x, r.y, r.width, r.height);
    }

    private static java.awt.geom.Path2D tmpQuadShape =
        new java.awt.geom.Path2D.Float();
    private static java.awt.Shape tmpQuad(float x1, float y1,
                                          float x2, float y2)
    {
        tmpQuadShape.reset();
        tmpQuadShape.moveTo(x1, y1);
        tmpQuadShape.lineTo(x2, y1);
        tmpQuadShape.lineTo(x2, y2);
        tmpQuadShape.lineTo(x1, y2);
        tmpQuadShape.closePath();
        return tmpQuadShape;
    }

    private static java.awt.geom.Rectangle2D.Float tmpRect =
        new java.awt.geom.Rectangle2D.Float();
    private static java.awt.geom.Rectangle2D tmpRect(float x, float y, float w, float h) {
        tmpRect.setRect(x, y, w, h);
        return tmpRect;
    }

    private static java.awt.geom.Ellipse2D tmpEllipse =
        new java.awt.geom.Ellipse2D.Float();
    private static java.awt.Shape tmpEllipse(float x, float y, float w, float h) {
        tmpEllipse.setFrame(x, y, w, h);
        return tmpEllipse;
    }

    private static java.awt.geom.RoundRectangle2D tmpRRect =
        new java.awt.geom.RoundRectangle2D.Float();
    private static java.awt.Shape tmpRRect(float x, float y, float w, float h,
                                           float aw, float ah)
    {
        tmpRRect.setRoundRect(x, y, w, h, aw, ah);
        return tmpRRect;
    }

    private static java.awt.geom.Line2D tmpLine =
        new java.awt.geom.Line2D.Float();
    private static java.awt.Shape tmpLine(float x1, float y1, float x2, float y2) {
        tmpLine.setLine(x1, y1, x2, y2);
        return tmpLine;
    }

    private static AdaptorShape tmpAdaptor = new AdaptorShape();
    private static java.awt.Shape tmpShape(Shape s) {
        tmpAdaptor.setShape(s);
        return tmpAdaptor;
    }

    private boolean antialiasedShape = true;
    J2DPresentable target;
    java.awt.Graphics2D g2d;
    Affine2D transform;
    Rectangle clipRect;
    RectBounds devClipRect;
    RectBounds finalClipRect;
    Paint paint;
    boolean paintWasProportional;
    BasicStroke stroke;
    boolean cull;

    J2DPrismGraphics(J2DPresentable target, java.awt.Graphics2D g2d) {
        this(g2d, target.getContentWidth(), target.getContentHeight());
        this.target = target;
    }

    J2DPrismGraphics(java.awt.Graphics2D g2d, int width, int height) {
        this.g2d = g2d;
        captureTransform(g2d);
        this.transform = new Affine2D();
        this.devClipRect = new RectBounds(0, 0, width, height);
        this.finalClipRect = new RectBounds(0, 0, width, height);
        this.cull = true;

        g2d.setRenderingHint(java.awt.RenderingHints.KEY_STROKE_CONTROL,
                             java.awt.RenderingHints.VALUE_STROKE_PURE);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                              java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_INTERPOLATION,
                             java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        /* Set the text hints to those most equivalent to FX rendering.
         * Will need to revisit this since its unlikely to be sufficient.
         */
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
                           java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
                             java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);


        setTransform(BaseTransform.IDENTITY_TRANSFORM);
        setPaint(DEFAULT_PAINT);
        setStroke(DEFAULT_STROKE);
    }

    public RenderTarget getRenderTarget() {
        return target;
    }

    public Screen getAssociatedScreen() {
        return target.getAssociatedScreen();
    }

    public ResourceFactory getResourceFactory() {
        return target.getResourceFactory();
    }

    public void reset() {
    }

    public Rectangle getClipRect() {
        return clipRect == null ? null : new Rectangle(clipRect);
    }

    public Rectangle getClipRectNoClone() {
        return clipRect;
    }

    public RectBounds getFinalClipNoClone() {
        return finalClipRect;
    }

    public void setClipRect(Rectangle clipRect) {
        this.finalClipRect.setBounds(devClipRect);
        if (clipRect == null) {
            this.clipRect = null;
            g2d.setClip(null);
        } else {
            this.clipRect = new Rectangle(clipRect);
            this.finalClipRect.intersectWith(clipRect);
            setTransformG2D(J2D_IDENTITY);
            g2d.setClip(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
            setTransformG2D(tmpJ2DTransform(transform));
        }
    }

    private java.awt.AlphaComposite getAWTComposite() {
        return (java.awt.AlphaComposite) g2d.getComposite();
    }

    public float getExtraAlpha() {
        return getAWTComposite().getAlpha();
    }

    public void setExtraAlpha(float extraAlpha) {
        g2d.setComposite(getAWTComposite().derive(extraAlpha));
    }

    public CompositeMode getCompositeMode() {
        int rule = getAWTComposite().getRule();
        switch (rule) {
            case java.awt.AlphaComposite.CLEAR:
                return CompositeMode.CLEAR;
            case java.awt.AlphaComposite.SRC:
                return CompositeMode.SRC;
            case java.awt.AlphaComposite.SRC_OVER:
                return CompositeMode.SRC_OVER;
            default:
                throw new InternalError(&quot;Unrecognized AlphaCompsite rule: &quot;+rule);
        }
    }

    public void setCompositeMode(CompositeMode mode) {
        java.awt.AlphaComposite awtComp = getAWTComposite();
        switch (mode) {
            case CLEAR:
                awtComp = awtComp.derive(java.awt.AlphaComposite.CLEAR);
                break;
            case SRC:
                awtComp = awtComp.derive(java.awt.AlphaComposite.SRC);
                break;
            case SRC_OVER:
                awtComp = awtComp.derive(java.awt.AlphaComposite.SRC_OVER);
                break;
            default:
                throw new InternalError(&quot;Unrecognized composite mode: &quot;+mode);
        }
        g2d.setComposite(awtComp);
    }

    public Paint getPaint() {
        return paint;
    }

    public void setPaint(Paint paint) {
        this.paint = paint;
        java.awt.Paint j2dpaint = toJ2DPaint(paint, null);
        if (j2dpaint == null) {
            paintWasProportional = true;
        } else {
            paintWasProportional = false;
            g2d.setPaint(j2dpaint);
        }
    }

    public BasicStroke getStroke() {
        return stroke;
    }

    public void setStroke(BasicStroke stroke) {
        this.stroke = stroke;
        g2d.setStroke(toJ2DStroke(stroke));
    }

    public BaseTransform getTransformNoClone() {
        return transform;
    }

    public void translate(float tx, float ty) {
        transform.translate(tx, ty);
        g2d.translate(tx, ty);
    }

    public void scale(float sx, float sy) {
        transform.scale(sx, sy);
        g2d.scale(sx, sy);
    }

    public void transform(BaseTransform xform) {
        if (!xform.is2D()) {
            // No-op until we support 3D
            return;
        }
        transform.concatenate(xform);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void setTransform(BaseTransform xform) {
        // TODO: Modify PrEffectHelper to not pass a null... (RT-27384)
        if (xform == null) xform = BaseTransform.IDENTITY_TRANSFORM;
        transform.setTransform(xform);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void setTransform(double m00, double m10,
                             double m01, double m11,
                             double m02, double m12)
    {
        transform.setTransform(m00, m10, m01, m11, m02, m12);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void clear() {
        clear(Color.TRANSPARENT);
    }

    public void clear(Color color) {
        this.getRenderTarget().setOpaque(color.isOpaque());
        clear(toJ2DColor(color));
    }

    void clear(java.awt.Color c) {
        java.awt.Graphics2D gtmp = (java.awt.Graphics2D) g2d.create();
        gtmp.setTransform(J2D_IDENTITY);
        gtmp.setComposite(java.awt.AlphaComposite.Src);
        gtmp.setColor(c);
        gtmp.fillRect(0, 0, target.getContentWidth(), target.getContentHeight());
        gtmp.dispose();
    }

    public void clearQuad(float x1, float y1, float x2, float y2) {
        g2d.setComposite(java.awt.AlphaComposite.Clear);
        g2d.fill(tmpQuad(x1, y1, x2, y2));
    }

    void fill(java.awt.Shape shape) {
        if (paintWasProportional) {
            if (nodeBounds != null) {
                g2d.setPaint(toJ2DPaint(paint, nodeBounds));
            } else {
                g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
            }
        }
        g2d.fill(shape);
    }

    public void fill(Shape shape) {
        fill(tmpShape(shape));
    }

    public void fillRect(float x, float y, float width, float height) {
        fill(tmpRect(x, y, width, height));
    }

    public void fillRoundRect(float x, float y, float width, float height,
                              float arcw, float arch)
    {
        fill(tmpRRect(x, y, width, height, arcw, arch));
    }

    public void fillEllipse(float x, float y, float width, float height) {
        fill(tmpEllipse(x, y, width, height));
    }

    public void fillQuad(float x1, float y1, float x2, float y2) {
        fill(tmpQuad(x1, y1, x2, y2));
    }

    void draw(java.awt.Shape shape) {
        if (paintWasProportional) {
            if (nodeBounds != null) {
                g2d.setPaint(toJ2DPaint(paint, nodeBounds));
            } else {
                g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
            }
        }
        try {
            g2d.draw(shape);
        } catch (Throwable t) {
            // Workaround for JDK bug 6670624
            // We may get a Ductus PRError (extends RuntimeException)
            // or we may get an InternalError (extends Error)
            // The only common superclass of the two is Throwable...
        }
    }

    public void draw(Shape shape) {
        draw(tmpShape(shape));
    }

    public void drawLine(float x1, float y1, float x2, float y2) {
        draw(tmpLine(x1, y1, x2, y2));
    }

    public void drawRect(float x, float y, float width, float height) {
        draw(tmpRect(x, y, width, height));
    }

    public void drawRoundRect(float x, float y, float width, float height, float arcw, float arch) {
        draw(tmpRRect(x, y, width, height, arcw, arch));
    }

    public void drawEllipse(float x, float y, float width, float height) {
        draw(tmpEllipse(x, y, width, height));
    }

    Rectangle2D nodeBounds = null;

    public void setNodeBounds(RectBounds bounds) {
        nodeBounds = bounds != null ?
                new Rectangle2D.Float(bounds.getMinX(), bounds.getMinY(),
                                      bounds.getWidth(),bounds.getHeight()) :
                null;
    }

    private void drawString(GlyphList gl, int start, int end,
                            FontStrike strike, float x, float y) {
        if (start == end) return;
        int count = end - start;
        int[] glyphs = new int[count];
        for (int i = 0; i &lt; count; i++) {
            glyphs[i] = gl.getGlyphCode(start + i) &amp; CompositeGlyphMapper.GLYPHMASK;
        }
        java.awt.Font j2dfont = toJ2DFont(strike);
        GlyphVector gv = j2dfont.createGlyphVector(g2d.getFontRenderContext(), glyphs);
        java.awt.geom.Point2D pt = new java.awt.geom.Point2D.Float();
        for (int i = 0; i &lt; count; i++) {
            pt.setLocation(gl.getPosX(start + i), gl.getPosY(start + i));
            gv.setGlyphPosition(i, pt);
        }
        g2d.drawGlyphVector(gv, x, y);
    }

    public void drawString(GlyphList gl, FontStrike strike, float x, float y,
                           Color selectColor, int start, int end) {

        int count = gl.getGlyphCount();
        if (count == 0) return;

        // In JDK6, setting graphics AA disables fast text loops
        g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_OFF);

        // If the surface has Alpha, JDK will ignore the LCD loops.
        // So for this to have any effect we need to fix JDK, or
        // ensure an opaque surface type.
        if (strike.getAAMode() == FontResource.AA_LCD) {
            g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_LCD_HRGB);
        }

        if (paintWasProportional) {
            Rectangle2D rectBounds = nodeBounds;
            if (rectBounds == null) {
                Metrics m = strike.getMetrics();
                rectBounds = new Rectangle2D.Float(0,
                                                   m.getAscent(),
                                                   gl.getWidth(),
                                                   m.getLineHeight());
            }
            g2d.setPaint(toJ2DPaint(paint, rectBounds));
        }

        CompositeStrike cStrike = null;
        int slot = 0;
        if (strike instanceof CompositeStrike) {
            cStrike = (CompositeStrike)strike;
            int glyphCode = gl.getGlyphCode(0);
            slot = cStrike.getStrikeSlotForGlyph(glyphCode);
        }
        java.awt.Color sColor = null;
        java.awt.Color tColor = null;
        boolean selected = false;
        if (selectColor != null) {
            sColor = toJ2DColor(selectColor);
            tColor = g2d.getColor();
            int offset = gl.getCharOffset(0);
            selected = start &lt;= offset &amp;&amp; offset &lt; end;
        }
        int index = 0;
        if (sColor != null || cStrike != null) {
            /* Draw a segment every time selection or font changes */
            for (int i = 1; i &lt; count; i++) {
                if (sColor != null) {
                    int offset = gl.getCharOffset(i);
                    boolean glyphSelected = start &lt;= offset &amp;&amp; offset &lt; end;
                    if (selected != glyphSelected) {
                        if (cStrike != null) {
                            strike = cStrike.getStrikeSlot(slot);
                        }
                        g2d.setColor(selected ? sColor : tColor);
                        drawString(gl, index, i, strike, x, y);
                        index = i;
                        selected = glyphSelected;
                    }
                }
                if (cStrike != null) {
                    int glyphCode = gl.getGlyphCode(i);
                    int glyphSlot = cStrike.getStrikeSlotForGlyph(glyphCode);
                    if (slot != glyphSlot) {
                        strike = cStrike.getStrikeSlot(slot);
                        if (sColor != null) {
                            g2d.setColor(selected ? sColor : tColor);
                        }
                        drawString(gl, index, i, strike, x, y);
                        index = i;
                        slot = glyphSlot;
                    }
                }
            }

            /* Set strike and color to draw the last segment */
            if (cStrike != null) {
                strike = cStrike.getStrikeSlot(slot);
            }
            if (sColor != null) {
                g2d.setColor(selected ? sColor : tColor);
            }
        }
        drawString(gl, index, count, strike, x, y);

        /* Always restore the graphics to its initial color */
        if (selectColor != null) {
            g2d.setColor(tColor);
        }

        // Set hints back to the default.
        g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);
        g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
    }

    /**
     * Overridden by printing subclass to preserve the printer graphics
     * transform.
     */
    protected void setTransformG2D(java.awt.geom.AffineTransform tx) {
        g2d.setTransform(tx);
    }

    /**
     * Needed only by printing subclass, which over-rides it.
     */
    protected void captureTransform(java.awt.Graphics2D g2d) {
        return;
    }

    public void drawMappedTextureRaw(Texture tex,
                                     float dx1, float dy1, float dx2, float dy2,
                                     float tx11, float ty11, float tx21, float ty21,
                                     float tx12, float ty12, float tx22, float ty22)
    {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        float mxx = tx21-tx11;
        float myx = ty21-ty11;
        float mxy = tx12-tx11;
        float myy = ty12-ty11;
//        assert(Math.abs(mxx - (tx22-tx12)) &lt; .000001);
<A NAME="11"></A>//        assert(Math.abs(myx - (ty22-ty12)) &lt; .000001);
//        assert(Math.abs(mxy - (tx22-tx21)) &lt; .000001);
//        assert(Math.abs(myy - (ty22-ty21)) &lt; .000001);
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#11',2,'match36-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setTransformG2D(J2D_IDENTITY);
        tmpAT.setTransform(mxx, myx, mxy, myy, tx11, ty11);
        try {
            tmpAT.invert();
            g2d.translate(dx1, dy1);
            g2d.scale(dx2-dx1, dy2-dy1);
            g2d.transform(tmpAT);
            g2d.drawImage(img, 0, 0, 1, 1, null);
        } catch (NoninvertibleTransformException e) {</B></FONT>
        }
        setTransform(transform);
    }

    public void drawTexture(Texture tex, float x, float y, float w, float h) {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        g2d.drawImage(img, (int) x, (int) y, (int) (x+w), (int) (y+h), 0, 0, (int)w, (int) h, null);
    }

    public void drawTexture(Texture tex,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2)
    {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        // Simply casting the subimage coordinates to integers does not
        // produce the same behavior as the Prism hw pipelines (see RT-19270).
        g2d.drawImage(img,
                (int) dx1, (int) dy1, (int) dx2, (int) dy2,
                (int) sx1, (int) sy1, (int) sx2, (int) sy2,
                null);
    }

    @Override
    public void drawTexture3SliceH(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dh1, float dh2, float sh1, float sh2)
    {
        // Workaround for problems in NGRegion which may pass zero-width
        // source image area.
        if (sh1 + 0.1f &gt; sh2) sh2 += 1;
        drawTexture(tex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
        drawTexture(tex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
        drawTexture(tex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
    }

    @Override
    public void drawTexture3SliceV(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dv1, float dv2, float sv1, float sv2)
    {
        // Workaround for problems in NGRegion which may pass zero-height
        // source image area.
        if (sv1 +0.1f &gt; sv2) sv2 += 1;
        drawTexture(tex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
        drawTexture(tex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
        drawTexture(tex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
    }

    @Override
    public void drawTexture9Slice(Texture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2,
                                  float dh1, float dv1, float dh2, float dv2,
                                  float sh1, float sv1, float sh2, float sv2)
    {
        // Workaround for problems in NGRegion which may pass zero-width
        // or zero height source image area.
        if (sh1 + 0.1f &gt; sh2) sh2 += 1;
        if (sv1 + 0.1f &gt; sv2) sv2 += 1;
        drawTexture(tex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
        drawTexture(tex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
        drawTexture(tex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);

        drawTexture(tex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
        drawTexture(tex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
        drawTexture(tex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);

        drawTexture(tex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
        drawTexture(tex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
        drawTexture(tex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
    }

    public void drawTextureRaw(Texture tex,
                               float dx1, float dy1, float dx2, float dy2,
                               float tx1, float ty1, float tx2, float ty2)
    {
        int w = tex.getContentWidth();
        int h = tex.getContentHeight();
        tx1 *= w;
        ty1 *= h;
        tx2 *= w;
        ty2 *= h;
        drawTexture(tex, dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
    }

    public void drawTextureVO(Texture tex,
                              float topopacity, float botopacity,
                              float dx1, float dy1, float dx2, float dy2,
                              float sx1, float sy1, float sx2, float sy2)
    {
        // assert(caller is PrReflectionPeer and buffer is cleared to transparent)
        // NOTE: the assert conditions are true because that is the only
        // place where this method is used (unless we subclass BaseGraphics),
        // but there is no code here to verify that information.
        // The workarounds to do this for the general case would cost a lot
        // because they would involve creating a temporary intermediate buffer,
        // doing the operations below into the buffer, and then applying the
        // buffer to the destination.  That is not hard, but it costs a lot
        // of buffer allocation (or caching) when it is not really necessary
        // given the way this method is called currently.
        // Note that isoEdgeMask is ignored here, but since this is only ever
        // called by PrReflectionPeer and that code always uses ISOLATE_NONE
        // then we would only need to support ISOLATE_NONE.  The code below
        // does not yet verify if the results will be compatible with
        // ISOLATE_NONE, but given that the source coordinates are rounded to
        // integers in drawTexture() there is not much it can do to get exact
        // edge condition behavior until that deficiency is fixed (see
        // RT-19270 and RT-19271).
        java.awt.Paint savepaint = g2d.getPaint();
        java.awt.Composite savecomp = g2d.getComposite();
        java.awt.Color c1 = new java.awt.Color(1f, 1f, 1f, topopacity);
        java.awt.Color c2 = new java.awt.Color(1f, 1f, 1f, botopacity);
        g2d.setPaint(new java.awt.GradientPaint(0f, dy1, c1, 0f, dy2, c2, true));
        g2d.setComposite(java.awt.AlphaComposite.Src);
        int x = (int) Math.floor(Math.min(dx1, dx2));
        int y = (int) Math.floor(Math.min(dy1, dy2));
        int w = (int) Math.ceil(Math.max(dx1, dx2)) - x;
        int h = (int) Math.ceil(Math.max(dy1, dy2)) - y;
        g2d.fillRect(x, y, w, h);
        g2d.setComposite(java.awt.AlphaComposite.SrcIn);
        drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        g2d.setComposite(savecomp);
        g2d.setPaint(savepaint);
    }

    public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
                                 int dx, int dy, int dw, int dh,
                                 int ix, int iy, int mx, int my)
    {
        doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
                          dx, dy, dw, dh,
                          ix, iy, mx, my,
                          true);
    }

    public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex, int dx,
                                      int dy, int dw, int dh, int ix, int iy,
                                      int mx, int my) {
        doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
                          dx, dy, dw, dh,
                          ix, iy, mx, my,
                          false);
    }

    private void doDrawMaskTexture(J2DRTTexture imgtex, J2DRTTexture masktex,
                                   int dx, int dy, int dw, int dh,
                                   int ix, int iy, int mx, int my,
                                   boolean srcover)
    {
        int cx0 = clipRect.x;
        int cy0 = clipRect.y;
        int cx1 = cx0 + clipRect.width;
        int cy1 = cy0 + clipRect.height;

        if (dw &lt;= 0 || dh &lt;= 0) return;
        if (dx &lt; cx0) {
            int bump = cx0 - dx;
            if ((dw -= bump) &lt;= 0) return;
            ix += bump;
            mx += bump;
            dx = cx0;
        }
        if (dy &lt; cy0) {
            int bump = cy0 - dy;
            if ((dh -= bump) &lt;= 0) return;
            iy += bump;
            my += bump;
            dy = cy0;
        }
        if (dx + dw &gt; cx1 &amp;&amp; (dw = cx1 - dx) &lt;= 0) return;
        if (dy + dh &gt; cy1 &amp;&amp; (dh = cy1 - dy) &lt;= 0) return;

        int iw = imgtex.getContentWidth();
        int ih = imgtex.getContentHeight();
        if (ix &lt; 0) {
            if ((dw += ix) &lt;= 0) return;
            dx -= ix;
            mx -= ix;
            ix = 0;
        }
        if (iy &lt; 0) {
            if ((dh += iy) &lt;= 0) return;
            dy -= iy;
            my -= iy;
            iy = 0;
        }
        if (ix + dw &gt; iw &amp;&amp; (dw = iw - ix) &lt;= 0) return;
        if (iy + dh &gt; ih &amp;&amp; (dh = ih - iy) &lt;= 0) return;

        int mw = masktex.getContentWidth();
        int mh = masktex.getContentHeight();
        if (mx &lt; 0) {
            if ((dw += mx) &lt;= 0) return;
            dx -= mx;
            ix -= mx;
            mx = 0;
        }
        if (my &lt; 0) {
            if ((dh += my) &lt;= 0) return;
            dy -= my;
            iy -= my;
            my = 0;
        }
        if (mx + dw &gt; mw &amp;&amp; (dw = mw - mx) &lt;= 0) return;
        if (my + dh &gt; mh &amp;&amp; (dh = mh - my) &lt;= 0) return;

        int imgbuf[] = imgtex.getPixels();
        int maskbuf[] = masktex.getPixels();
        java.awt.image.DataBuffer db = target.getBackBuffer().getRaster().getDataBuffer();
        int dstbuf[] = ((java.awt.image.DataBufferInt) db).getData();
        int iscan = imgtex.getBufferedImage().getWidth();
        int mscan = masktex.getBufferedImage().getWidth();
        int dscan = target.getBackBuffer().getWidth();
        int ioff = iy * iscan + ix;
        int moff = my * mscan + mx;
        int doff = dy * dscan + dx;
        if (srcover) {
            for (int y = 0; y &lt; dh; y++) {
                for (int x = 0; x &lt; dw; x++) {
                    int a, r, g, b;
                    int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
                    if (maskalpha == 0) continue;
                    int imgpix = imgbuf[ioff+x];
                    a = (imgpix &gt;&gt;&gt; 24);
                    if (a == 0) continue;
                    if (maskalpha &lt; 0xff) {
                        maskalpha += (maskalpha &gt;&gt; 7);
                        a *= maskalpha;
                        r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
                        g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
                        b = ((imgpix       ) &amp; 0xff) * maskalpha;
                    } else if (a &lt; 0xff) {
                        a &lt;&lt;= 8;
                        r = ((imgpix &gt;&gt;  16) &amp; 0xff) &lt;&lt; 8;
                        g = ((imgpix &gt;&gt;   8) &amp; 0xff) &lt;&lt; 8;
                        b = ((imgpix       ) &amp; 0xff) &lt;&lt; 8;
                    } else {
                        dstbuf[doff+x] = imgpix;
                        continue;
                    }
                    maskalpha = ((a + 128) &gt;&gt; 8);
                    maskalpha += (maskalpha &gt;&gt; 7);
                    maskalpha = 256 - maskalpha;
                    imgpix = dstbuf[doff+x];
                    a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
                    r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
                    g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
                    b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
                    imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
                             ((r &gt;&gt; 8) &lt;&lt; 16) +
                             ((g &gt;&gt; 8) &lt;&lt;  8) +
                             ((b &gt;&gt; 8)      );
                    dstbuf[doff+x] = imgpix;
                }
                ioff += iscan;
                moff += mscan;
                doff += dscan;
            }
        } else {
            for (int y = 0; y &lt; dh; y++) {
                for (int x = 0; x &lt; dw; x++) {
                    int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
                    if (maskalpha == 0) continue;
                    int imgpix = imgbuf[ioff+x];
                    if (maskalpha &lt; 0xff) {
                        maskalpha += (maskalpha &gt;&gt; 7);
                        int a = ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha;
                        int r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
                        int g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
                        int b = ((imgpix       ) &amp; 0xff) * maskalpha;
                        maskalpha = 256 - maskalpha;
                        imgpix = dstbuf[doff+x];
                        a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
                        r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
                        g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
                        b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
                        imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
                                 ((r &gt;&gt; 8) &lt;&lt; 16) +
                                 ((g &gt;&gt; 8) &lt;&lt;  8) +
                                 ((b &gt;&gt; 8)      );
                    }
                    dstbuf[doff+x] = imgpix;
                }
                ioff += iscan;
                moff += mscan;
                doff += dscan;
            }
        }
    }

    public boolean canReadBack() {
        return true;
    }

    public RTTexture readBack(Rectangle view) {
        J2DRTTexture rtt = target.getReadbackBuffer();
        java.awt.Graphics2D rttg2d = rtt.createAWTGraphics2D();
        rttg2d.setComposite(java.awt.AlphaComposite.Src);
        int x0 = view.x;
        int y0 = view.y;
        int w = view.width;
        int h = view.height;
        int x1 = x0 + w;
        int y1 = y0 + h;
        rttg2d.drawImage(target.getBackBuffer(),
                          0,  0,  w,  h,
                         x0, y0, x1, y1, null);
        rttg2d.dispose();
        return rtt;
    }

    public void releaseReadBackBuffer(RTTexture view) {
        // This will be needed when we track LCD buffer locks and uses.
        // (See RT-29488)
//        target.getReadbackBuffer().unlock();
    }

    public NGCamera getCameraNoClone() {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setPerspectiveTransform(GeneralTransform3D transform) {
    }


    public boolean isDepthBuffer() {
        return false;
    }

    public boolean isDepthTest() {
        return false;
    }

    public boolean isAlphaTestShader() {
        if (PrismSettings.verbose &amp;&amp; PrismSettings.forceAlphaTestShader) {
            System.out.println(&quot;J2D pipe doesn't support shader with alpha testing&quot;);
        }
        return false;
    }

    public void setAntialiasedShape(boolean aa) {
        antialiasedShape = aa;
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                antialiasedShape ? java.awt.RenderingHints.VALUE_ANTIALIAS_ON
                        : java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
    }

    public boolean isAntialiasedShape() {
        return antialiasedShape;
    }

    public void scale(float sx, float sy, float sz) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setTransform3D(double mxx, double mxy, double mxz, double mxt,
                               double myx, double myy, double myz, double myt,
                               double mzx, double mzy, double mzz, double mzt)
    {
        if (mxz != 0.0 || myz != 0.0 ||
            mzx != 0.0 || mzy != 0.0 || mzz != 1.0 || mzt != 0.0)
        {
            throw new UnsupportedOperationException(&quot;3D transforms not supported.&quot;);
        }
        setTransform(mxx, myx, mxy, myy, mxt, myt);
    }

    public void setCamera(NGCamera camera) {
        // No-op until we support 3D
        /*
        if (!(camera instanceof PrismParallelCameraImpl)) {

            throw new UnsupportedOperationException(camera+&quot; not supported.&quot;);
        }
        */
    }

    public void setDepthBuffer(boolean depthBuffer) {
        // No-op until we support 3D
    }

    public void setDepthTest(boolean depthTest) {
        // No-op until we support 3D
    }

    public void sync() {
    }

    public void translate(float tx, float ty, float tz) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setCulling(boolean cull) {
        this.cull = cull;
    }

    public boolean isCulling() {
        return this.cull;
    }

 public void setClipRectIndex(int index) {
        this.clipRectIndex = index;
    }
    public int getClipRectIndex() {
        return this.clipRectIndex;
    }

    public void setHasPreCullingBits(boolean hasBits) {
        this.hasPreCullingBits = hasBits;
    }

    public boolean hasPreCullingBits() {
        return hasPreCullingBits;
    }

    private NodePath renderRoot;
    @Override
    public void setRenderRoot(NodePath root) {
        this.renderRoot = root;
    }

    @Override
    public NodePath getRenderRoot() {
        return renderRoot;
    }

    public void setState3D(boolean flag) {
    }

    public boolean isState3D() {
        return false;
    }

    public void setup3DRendering() {
    }

    @Override
    public void setPixelScaleFactors(float pixelScaleX, float pixelScaleY) {
        this.pixelScaleX = pixelScaleX;
        this.pixelScaleY = pixelScaleY;
    }

    @Override
    public float getPixelScaleFactorX() {
        return pixelScaleX;
    }

    @Override
    public float getPixelScaleFactorY() {
        return pixelScaleY;
    }

    @Override
    public void blit(RTTexture srcTex, RTTexture dstTex,
            int srcX0, int srcY0, int srcX1, int srcY1,
            int dstX0, int dstY0, int dstX1, int dstY1) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    private static class AdaptorShape implements java.awt.Shape {
        private Shape prshape;

        public void setShape(Shape prshape) {
            this.prshape = prshape;
        }

        public boolean contains(double x, double y) {
            return prshape.contains((float) x, (float) y);
        }

        public boolean contains(java.awt.geom.Point2D p) {
            return contains(p.getX(), p.getY());
        }

        public boolean contains(double x, double y, double w, double h) {
            return prshape.contains((float) x, (float) y, (float) w, (float) h);
        }

        public boolean contains(java.awt.geom.Rectangle2D r) {
            return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
        }

        public boolean intersects(double x, double y, double w, double h) {
            return prshape.intersects((float) x, (float) y, (float) w, (float) h);
        }

        public boolean intersects(java.awt.geom.Rectangle2D r) {
            return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
        }

        public java.awt.Rectangle getBounds() {
            return getBounds2D().getBounds();
        }

        public java.awt.geom.Rectangle2D getBounds2D() {
            RectBounds b = prshape.getBounds();
            java.awt.geom.Rectangle2D r2d =
                new java.awt.geom.Rectangle2D.Float();
            r2d.setFrameFromDiagonal(b.getMinX(), b.getMinY(), b.getMaxX(), b.getMaxY());
            return r2d;
        }

        private static AdaptorPathIterator tmpAdaptor =
                new AdaptorPathIterator();
        private static java.awt.geom.PathIterator tmpAdaptor(PathIterator pi) {
            tmpAdaptor.setIterator(pi);
            return tmpAdaptor;
        }

        public java.awt.geom.PathIterator
            getPathIterator(java.awt.geom.AffineTransform at)
        {
            BaseTransform tx = (at == null) ? null : toPrTransform(at);
            return tmpAdaptor(prshape.getPathIterator(tx));
        }

        public java.awt.geom.PathIterator
            getPathIterator(java.awt.geom.AffineTransform at,
                            double flatness)
        {
            BaseTransform tx = (at == null) ? null : toPrTransform(at);
            return tmpAdaptor(prshape.getPathIterator(tx, (float) flatness));
        }
    }

    private static class AdaptorPathIterator
        implements java.awt.geom.PathIterator
    {
        private static int NUM_COORDS[] = { 2, 2, 4, 6, 0 };
        PathIterator priterator;
        float tmpcoords[];

        public void setIterator(PathIterator priterator) {
            this.priterator = priterator;
        }

        public int currentSegment(float[] coords) {
            return priterator.currentSegment(coords);
        }

        public int currentSegment(double[] coords) {
            if (tmpcoords == null) {
                tmpcoords = new float[6];
            }
            int ret = priterator.currentSegment(tmpcoords);
            for (int i = 0; i &lt; NUM_COORDS[ret]; i++) {
                coords[i] = (double) tmpcoords[i];
            }
            return ret;
        }

        public int getWindingRule() {
            return priterator.getWindingRule();
        }

        public boolean isDone() {
            return priterator.isDone();
        }

        public void next() {
            priterator.next();
        }
    }

    static abstract class FilterStroke implements java.awt.Stroke {
        protected java.awt.BasicStroke stroke;

        FilterStroke(java.awt.BasicStroke stroke) {
            this.stroke = stroke;
        }

        abstract protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r);
        abstract protected java.awt.Shape makeStrokedShape(java.awt.Shape s);

        public java.awt.Shape createStrokedShape(java.awt.Shape p) {
            if (p instanceof java.awt.geom.Rectangle2D) {
                java.awt.Shape s = makeStrokedRect((java.awt.geom.Rectangle2D) p);
                if (s != null) {
                    return s;
                }
            }
            return makeStrokedShape(p);
        }

        // ArcIterator.btan(Math.PI/2)
        static final double CtrlVal = 0.5522847498307933;

        static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
                                                      float x0, float y0,
                                                      float xc, float yc,
                                                      float x1, float y1)
        {
            return cornerArc(gp, x0, y0, xc, yc, x1, y1, 0.5f);
        }

        static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
                                                      float x0, float y0,
                                                      float xc, float yc,
                                                      float x1, float y1, float t)
        {
            float xc0 = (float) (x0 + CtrlVal * (xc - x0));
            float yc0 = (float) (y0 + CtrlVal * (yc - y0));
            float xc1 = (float) (x1 + CtrlVal * (xc - x1));
            float yc1 = (float) (y1 + CtrlVal * (yc - y1));
            gp.curveTo(xc0, yc0, xc1, yc1, x1, y1);

            return new java.awt.geom.Point2D.Float(eval(x0, xc0, xc1, x1, t),
                                                   eval(y0, yc0, yc1, y1, t));
        }

        static float eval(float c0, float c1, float c2, float c3, float t) {
            c0 = c0 + (c1-c0) * t;
            c1 = c1 + (c2-c1) * t;
            c2 = c2 + (c3-c2) * t;
            c0 = c0 + (c1-c0) * t;
            c1 = c1 + (c2-c1) * t;
            return c0 + (c1-c0) * t;
        }
    }

    static class InnerStroke extends FilterStroke {
        InnerStroke(java.awt.BasicStroke stroke) {
            super(stroke);
        }

        protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            if (pad &gt;= r.getWidth() || pad &gt;= r.getHeight()) {
                return r;
            }
            float rx0 = (float) r.getX();
            float ry0 = (float) r.getY();
            float rx1 = rx0 + (float) r.getWidth();
            float ry1 = ry0 + (float) r.getHeight();
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx1, ry0);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx0, ry1);
            gp.closePath();
            rx0 += pad;
            ry0 += pad;
            rx1 -= pad;
            ry1 -= pad;
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx0, ry1);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx1, ry0);
            gp.closePath();
            return gp;
        }

        // NOTE: This is a work in progress, not used yet
        protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float w = (float) e.getWidth();
            float h = (float) e.getHeight();
            if (w - 2*pad &gt; h * 2 || h - 2*pad &gt; w * 2) {
                // If the inner ellipse is too &quot;squashed&quot; then we can not
                // approximate it with just a single cubic per quadrant.
                // NOTE: measure so we can relax this restriction and
                // also consider modifying the code below to insert
                // more cubics in those cases.
                return null;
            }
            if (pad &gt;= w || pad &gt;= h) {
                return e;
            }
            float x0 = (float) e.getX();
            float y0 = (float) e.getY();
            float xc = x0 + w / 2f;
            float yc = y0 + h / 2f;
            float x1 = x0 + w;
            float y1 = y0 + h;
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x1, y0, x1, yc);
            cornerArc(gp, x1, yc, x1, y1, xc, y1);
            cornerArc(gp, xc, y1, x0, y1, x0, yc);
            cornerArc(gp, x0, yc, x0, y0, xc, y0);
            gp.closePath();
            x0 += pad;
            y0 += pad;
            x1 -= pad;
            y1 -= pad;
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x0, y0, x0, yc);
            cornerArc(gp, x0, yc, x0, y1, xc, y1);
            cornerArc(gp, xc, y1, x1, y1, x1, yc);
            cornerArc(gp, x1, yc, x1, y0, xc, y0);
            gp.closePath();
            return gp;
        }

        @Override
        protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
            java.awt.Shape ss = stroke.createStrokedShape(s);
            java.awt.geom.Area b = new java.awt.geom.Area(ss);
            b.intersect(new java.awt.geom.Area(s));
            return b;
        }
    }

    static class OuterStroke extends FilterStroke {
        static double SQRT_2 = Math.sqrt(2);

        OuterStroke(java.awt.BasicStroke stroke) {
            super(stroke);
        }

        protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float rx0 = (float) r.getX();
            float ry0 = (float) r.getY();
            float rx1 = rx0 + (float) r.getWidth();
            float ry1 = ry0 + (float) r.getHeight();
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            // clockwise
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx1, ry0);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx0, ry1);
            gp.closePath();
            float ox0 = rx0 - pad;
            float oy0 = ry0 - pad;
            float ox1 = rx1 + pad;
            float oy1 = ry1 + pad;
            switch (stroke.getLineJoin()) {
            case BasicStroke.JOIN_MITER:
                // A miter limit of less than sqrt(2) bevels right angles...
                if (stroke.getMiterLimit() &gt;= SQRT_2) {
                    // counter-clockwise
                    gp.moveTo(ox0, oy0);
                    gp.lineTo(ox0, oy1);
                    gp.lineTo(ox1, oy1);
                    gp.lineTo(ox1, oy0);
                    gp.closePath();
                    break;
                }
                // NO BREAK
            case BasicStroke.JOIN_BEVEL:
                // counter-clockwise
                gp.moveTo(ox0, ry0);
                gp.lineTo(ox0, ry1);  // left edge
                gp.lineTo(rx0, oy1);  // ll corner
                gp.lineTo(rx1, oy1);  // bottom edge
                gp.lineTo(ox1, ry1);  // lr corner
                gp.lineTo(ox1, ry0);  // right edge
                gp.lineTo(rx1, oy0);  // ur corner
                gp.lineTo(rx0, oy0);  // top edge
                gp.closePath();       // ul corner
                break;
            case BasicStroke.JOIN_ROUND:
                // counter-clockwise
                gp.moveTo(ox0, ry0);
                gp.lineTo(ox0, ry1);                          // left edge
                cornerArc(gp, ox0, ry1, ox0, oy1, rx0, oy1);  // ll corner
                gp.lineTo(rx1, oy1);                          // bottom edge
                cornerArc(gp, rx1, oy1, ox1, oy1, ox1, ry1);  // lr corner
                gp.lineTo(ox1, ry0);                          // right edge
                cornerArc(gp, ox1, ry0, ox1, oy0, rx1, oy0);  // ur corner
                gp.lineTo(rx0, oy0);                          // top edge
                cornerArc(gp, rx0, oy0, ox0, oy0, ox0, ry0);  // ul corner
                gp.closePath();
                break;
            default:
                throw new InternalError(&quot;Unrecognized line join style&quot;);
            }
            return gp;
        }

        // NOTE: This is a work in progress, not used yet
        protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float w = (float) e.getWidth();
            float h = (float) e.getHeight();
            if (w &gt; h * 2 || h &gt; w * 2) {
                // If the inner ellipse is too &quot;squashed&quot; then we can not
                // approximate it with just a single cubic per quadrant.
                // NOTE: measure so we can relax this restriction and
                // also consider modifying the code below to insert
                // more cubics in those cases.
                return null;
            }
            float x0 = (float) e.getX();
            float y0 = (float) e.getY();
            float xc = x0 + w / 2f;
            float yc = y0 + h / 2f;
            float x1 = x0 + w;
            float y1 = y0 + h;
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x1, y0, x1, yc);
            cornerArc(gp, x1, yc, x1, y1, xc, y1);
            cornerArc(gp, xc, y1, x0, y1, x0, yc);
            cornerArc(gp, x0, yc, x0, y0, xc, y0);
            gp.closePath();
            x0 -= pad;
            y0 -= pad;
            x1 += pad;
            y1 += pad;
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x0, y0, x0, yc);
            cornerArc(gp, x0, yc, x0, y1, xc, y1);
            cornerArc(gp, xc, y1, x1, y1, x1, yc);
            cornerArc(gp, x1, yc, x1, y0, xc, y0);
            gp.closePath();
            return gp;
        }

        @Override
        protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
            java.awt.Shape ss = stroke.createStrokedShape(s);
            java.awt.geom.Area b = new java.awt.geom.Area(ss);
            b.subtract(new java.awt.geom.Area(s));
            return b;
        }
    }

    @Override
    public void setLights(NGLightBase[] lights) {
        // Light are not supported by J2d
    }

    @Override
    public NGLightBase[] getLights() {
        // Light are not supported by J2d
        return null;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/RendererFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl;

import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.PlatformUtil;
import com.sun.scenario.effect.FilterContext;

/**
 * A factory that produces a {@code Renderer} instance appropriate for
 * the desktop and tv stacks (either Swing or Prism based).  This class
 * dynamically locates a {@code Renderer} using the java.lang.reflect package,
 * which is not available on CLDC.  The CLDC-based mobile stack may
 * substitute their own version of this class that does not rely on reflection.
 */
class RendererFactory {

    private static String rootPkg = Renderer.rootPkg;
    private static boolean tryRSL = true;
    private static boolean trySIMD = false;
    // by default we only enable jogl hw acceleration on MacOS
    private static boolean tryJOGL = PlatformUtil.isMac();
    private static boolean tryPrism = true;

    static {
        try {
            if (&quot;false&quot;.equals(System.getProperty(&quot;decora.rsl&quot;))) {
                tryRSL = false;
            }
            if (&quot;false&quot;.equals(System.getProperty(&quot;decora.simd&quot;))) {
                trySIMD = false;
            }
            String tryJOGLProp = System.getProperty(&quot;decora.jogl&quot;);
            if (tryJOGLProp != null) {
                tryJOGL = Boolean.parseBoolean(tryJOGLProp);
            }
            if (&quot;false&quot;.equals(System.getProperty(&quot;decora.prism&quot;))) {
                tryPrism = false;
            }
        } catch (SecurityException ignore) {
        }
    }

    private static boolean isRSLFriendly(Class klass) {
        // can't use reflection here to check for sun.* class when running
        // in sandbox; however, we are allowed to walk up the tree and
        // check names of interfaces loaded by the system
        if (klass.getName().equals(&quot;sun.java2d.pipe.hw.AccelGraphicsConfig&quot;)) {
            return true;
        }
        boolean rsl = false;
        for (Class iface : klass.getInterfaces()) {
            if (isRSLFriendly(iface)) {
                rsl = true;
                break;
            }
        }
        return rsl;
    }

    private static boolean isRSLAvailable(FilterContext fctx) {
        return isRSLFriendly(fctx.getReferent().getClass());
    }

    private static Renderer createRSLRenderer(FilterContext fctx) {
        try {
            Class klass = Class.forName(rootPkg + &quot;.impl.j2d.rsl.RSLRenderer&quot;);
            Method m = klass.getMethod(&quot;createRenderer&quot;,
                                       new Class[] { FilterContext.class });
            return (Renderer)m.invoke(null, new Object[] { fctx });
        } catch (Throwable e) {}

        return null;
    }

    private static Renderer createJOGLRenderer(FilterContext fctx) {
        if (tryJOGL) {
            try {
                Class klass = Class.forName(rootPkg + &quot;.impl.j2d.jogl.JOGLRenderer&quot;);
                Method m = klass.getMethod(&quot;createRenderer&quot;,
                                           new Class[] { FilterContext.class });
                return (Renderer)m.invoke(null, new Object[] { fctx });
            } catch (Throwable e) {}
            // don't disable jogl if failed, it may be available for other config
        }
        return null;
    }

    private static Renderer createPrismRenderer(FilterContext fctx) {
        if (tryPrism) {
            try {
                Class klass = Class.forName(rootPkg + &quot;.impl.prism.PrRenderer&quot;);
                Method m = klass.getMethod(&quot;createRenderer&quot;,
                                           new Class[] { FilterContext.class });
                return (Renderer)m.invoke(null, new Object[] { fctx });
            } catch (Throwable e) {
                e.printStackTrace();
            }
            // don't disable prism if failed, it may be available for other config
        }
        return null;
    }

    private static Renderer getSSERenderer() {
        if (trySIMD) {
            try {
                Class klass = Class.forName(rootPkg + &quot;.impl.j2d.J2DSWRenderer&quot;);
                Method m = klass.getMethod(&quot;getSSEInstance&quot;, (Class[])null);
                Renderer sseRenderer = (Renderer)m.invoke(null, (Object[])null);
                if (sseRenderer != null) {
                    return sseRenderer;
                }
            } catch (Throwable e) {e.printStackTrace();}
            // don't bother trying to find SSE renderer again
            trySIMD = false;
        }
        return null;
    }

    private static Renderer getJavaRenderer() {
        try {
            Class klass = Class.forName(rootPkg + &quot;.impl.prism.sw.PSWRenderer&quot;);
            Class screenClass = Class.forName(&quot;com.sun.glass.ui.Screen&quot;);
            Method m = klass.getMethod(&quot;createJSWInstance&quot;,
                                       new Class[] { screenClass });
            Renderer jswRenderer =
                (Renderer)m.invoke(null, new Object[] { null } );
<A NAME="8"></A>            if (jswRenderer != null) {
                return jswRenderer;
            }
        <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#8',2,'match36-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} catch (Throwable e) {e.printStackTrace();}
        return null;
    }

    private static Renderer getJavaRenderer(FilterContext fctx) {</B></FONT>
        try {
            Class klass = Class.forName(rootPkg + &quot;.impl.prism.sw.PSWRenderer&quot;);
            Method m = klass.getMethod(&quot;createJSWInstance&quot;,
                                       new Class[] { FilterContext.class });
            Renderer jswRenderer =
               (Renderer)m.invoke(null, new Object[] { fctx } );
            if (jswRenderer != null) {
                return jswRenderer;
            }
        } catch (Throwable e) {}
        return null;
    }

    static Renderer getSoftwareRenderer() {
        Renderer r = getSSERenderer();
        if (r == null) {
            r = getJavaRenderer();
        }
        return r;
    }

    static Renderer createRenderer(final FilterContext fctx) {
        return AccessController.doPrivileged((PrivilegedAction&lt;Renderer&gt;) () -&gt; {
            Renderer r = null;
            // Class.getSimpleName is not available on CDC
            String klassName = fctx.getClass().getName();
            String simpleName = klassName.substring(klassName.lastIndexOf(&quot;.&quot;) + 1);

            if (simpleName.equals(&quot;PrFilterContext&quot;) &amp;&amp; tryPrism) {
                r = createPrismRenderer(fctx);
            }
            // check to see whether one of the hardware accelerated
            // Java 2D pipelines is in use and exposes the necessary
            // &quot;resource sharing layer&quot; APIs (only in Sun's JDK 6u10 and above)
            if (r == null &amp;&amp; tryRSL &amp;&amp; isRSLAvailable(fctx)) {
                // try locating an RSLRenderer (need to use reflection in case
                // certain RSL backend classes are not available;
                // this step will trigger lazy downloading of impl jars
                // via JNLP, if not already available)
                r = createRSLRenderer(fctx);
            }
            if (r == null &amp;&amp; tryJOGL) {
                // next try the JOGL renderer
                r = createJOGLRenderer(fctx);
            }
            if (r == null &amp;&amp; trySIMD) {
                // next try the SSE renderer
                r = getSSERenderer();
            }
            if (r == null) {
                // otherwise, fall back on the Java/CPU renderer
                r = getJavaRenderer(fctx);
            }
            return r;
        });
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/paint/Color.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.paint;

import javafx.animation.Interpolatable;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import com.sun.javafx.util.Utils;
import com.sun.javafx.tk.Toolkit;
import javafx.beans.NamedArg;

// NOTE: this definition, while correct, contains a lot of information which
// is irrelevant to most developers. We should get to the basic definition and
// usage patterns sooner.

/**
 * The Color class is used to encapsulate colors in the default sRGB color space.
 * Every color has an implicit alpha value of 1.0 or an explicit one provided
 * in the constructor. The alpha value defines the transparency of a color
 * and can be  represented by a double value in the range 0.0-1.0 or 0-255.
 * An alpha value of 1.0 or 255 means that the color is completely opaque
 * and an alpha value of 0 or 0.0 means that the color is completely transparent.
 * When constructing a {@code Color} with an explicit alpha or getting
 * the color/alpha components of a Color,
 * the color components are never premultiplied by the alpha component.
 *
 *
 * &lt;p&gt;{@code Color}s can be created with the constructor or with one of several
 * utility methods.  The following lines of code all create the same
 * blue color:&lt;/p&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 * {@literal
 * Color c = Color.BLUE;   //use the blue constant
 * Color c = new Color(0,0,1,1.0); // standard constructor, use 0-&gt;1.0 values, explicit alpha of 1.0
 *
 * Color c = Color.color(0,0,1.0); //use 0-&gt;1.0 values. implicit alpha of 1.0
 * Color c = Color.color(0,0,1.0,1.0); //use 0-&gt;1.0 values, explicit alpha of 1.0
 *
 * Color c = Color.rgb(0,0,255); //use 0-&gt;255 integers, implicit alpha of 1.0
 * Color c = Color.rgb(0,0,255,1.0); //use 0-&gt;255 integers, explicit alpha of 1.0
 *
 * Color c = Color.hsb(270,1.0,1.0); //hue = 270, saturation &amp; value = 1.0. inplicit alpha of 1.0
 * Color c = Color.hsb(270,1.0,1.0,1.0); //hue = 270, saturation &amp; value = 1.0, explicit alpha of 1.0
 *
 * Color c = Color.web(&quot;0x0000FF&quot;,1.0);// blue as a hex web value, explicit alpha
 * Color c = Color.web(&quot;0x0000FF&quot;);// blue as a hex web value, implicit alpha
 * Color c = Color.web(&quot;0x00F&quot;);// blue as a short hex web value, implicit alpha
 * Color c = Color.web(&quot;#0000FF&quot;,1.0);// blue as a hex web value, explicit alpha
 * Color c = Color.web(&quot;#0000FF&quot;);// blue as a hex web value, implicit alpha
 * Color c = Color.web(&quot;#00F&quot;);// blue as a short hex web value, implicit alpha
 * Color c = Color.web(&quot;0000FF&quot;,1.0);// blue as a hex web value, explicit alpha
 * Color c = Color.web(&quot;0000FF&quot;);// blue as a hex web value, implicit alpha
 * Color c = Color.web(&quot;00F&quot;);// blue as a short hex web value, implicit alpha
 * Color c = Color.web(&quot;rgba(0,0,255,1.0)&quot;);// blue as an rgb web value, explicit alpha
 * Color c = Color.web(&quot;rgb(0,0,255)&quot;);// blue as an rgb web value, implicit alpha
 * Color c = Color.web(&quot;rgba(0,0,100%,1.0)&quot;);// blue as an rgb percent web value, explicit alpha
 * Color c = Color.web(&quot;rgb(0,0,100%)&quot;);// blue as an rgb percent web value, implicit alpha
 * Color c = Color.web(&quot;hsla(270,100%,100%,1.0)&quot;);// blue as an hsl web value, explicit alpha
 * Color c = Color.web(&quot;hsl(270,100%,100%)&quot;);// blue as an hsl web value, implicit alpha
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * The creation of a {@code Color} will throw {@code IllegalArgumentException} if any
 * of the values are out of range.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * For example:
 * &lt;pre&gt;{@code
 * Rectangle rec1 = new Rectangle(5, 5, 50, 40);
 * rec1.setFill(Color.RED);
 * rec1.setStroke(Color.GREEN);
 * rec1.setStrokeWidth(3);
 *
 * Rectangle rec2 = new Rectangle(65, 5, 50, 40);
 * rec2.setFill(Color.rgb(91, 127, 255));
 * rec2.setStroke(Color.hsb(40, 0.7, 0.8));
 * rec2.setStrokeWidth(3);
 * }&lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
public final class Color extends Paint implements Interpolatable&lt;Color&gt; {

    /**
     * Brightness change factor for darker() and brighter() methods.
     */
    private static final double DARKER_BRIGHTER_FACTOR = 0.7;

    /**
     * Saturation change factor for saturate() and desaturate() methods.
     */
    private static final double SATURATE_DESATURATE_FACTOR = 0.7;

    /**
     * Creates an sRGB color with the specified red, green and blue values
     * in the range {@code 0.0-1.0}, and a given opacity.
     *
     * @param red the red component, in the range {@code 0.0-1.0}
     * @param green the green component, in the range {@code 0.0-1.0}
     * @param blue the blue component, in the range {@code 0.0-1.0}
     * @param opacity the opacity component, in the range {@code 0.0-1.0}
     * @return the {@code Color}
     * @throws IllegalArgumentException if any value is out of range
     */
    public static Color color(double red, double green, double blue, double opacity) {
        return new Color(red, green, blue, opacity);
    }

    /**
     * Creates an opaque sRGB color with the specified red, green and blue values
     * in the range {@code 0.0-1.0}.
     *
     * @param red the red component, in the range {@code 0.0-1.0}
     * @param green the green component, in the range {@code 0.0-1.0}
     * @param blue the blue component, in the range {@code 0.0-1.0}
     * @return the {@code Color}
     * @throws IllegalArgumentException if any value is out of range
     */
    public static Color color(double red, double green, double blue) {
        return new Color(red, green, blue, 1);
    }

    /**
     * Creates an sRGB color with the specified RGB values in the range {@code 0-255},
     * and a given opacity.
     *
     * @param red the red component, in the range {@code 0-255}
     * @param green the green component, in the range {@code 0-255}
     * @param blue the blue component, in the range {@code 0-255}
     * @param opacity the opacity component, in the range {@code 0.0-1.0}
     * @return the {@code Color}
     * @throws IllegalArgumentException if any value is out of range
     */
    public static Color rgb(int red, int green, int blue, double opacity) {
        checkRGB(red, green, blue);
        return new Color(
            red / 255.0,
            green / 255.0,
            blue / 255.0,
            opacity);
    }

    /**
     * Creates an opaque sRGB color with the specified RGB values in the range {@code 0-255}.
     *
     * @param red the red component, in the range {@code 0-255}
     * @param green the green component, in the range {@code 0-255}
     * @param blue the blue component, in the range {@code 0-255}
     * @return the {@code Color}
     * @throws IllegalArgumentException if any value is out of range
     */
    public static Color rgb(int red, int green, int blue) {
        checkRGB(red, green, blue);
        return new Color(
            red / 255.0,
            green / 255.0,
            blue / 255.0,
            1.0);
    }


    /**
     * This is a shortcut for {@code rgb(gray, gray, gray)}.
     * @param gray the gray component, in the range {@code 0-255}
     * @return the {@code Color}
     */
    public static Color grayRgb(int gray) {
        return rgb(gray, gray, gray);
    }

    /**
     * This is a shortcut for {@code rgb(gray, gray, gray, opacity)}.
     * @param gray the gray component, in the range {@code 0-255}
     * @param opacity the opacity component, in the range {@code 0.0-1.0}
     * @return the {@code Color}
     */
    public static Color grayRgb(int gray, double opacity) {
        return rgb(gray, gray, gray, opacity);
    }

    /**
     * Creates a grey color.
     * @param gray color on gray scale in the range
     *             {@code 0.0} (black) - {@code 1.0} (white).
     * @param opacity the opacity component, in the range {@code 0.0-1.0}
     * @return the {@code Color}
     * @throws IllegalArgumentException if any value is out of range
     */
    public static Color gray(double gray, double opacity) {
        return new Color(gray, gray, gray, opacity);
    }

    /**
     * Creates an opaque grey color.
     * @param gray color on gray scale in the range
     *             {@code 0.0} (black) - {@code 1.0} (white).
     * @return the {@code Color}
     * @throws IllegalArgumentException if any value is out of range
     */
    public static Color gray(double gray) {
        return gray(gray, 1.0);
    }

    private static void checkRGB(int red, int green, int blue) {
        if (red &lt; 0 || red &gt; 255) {
            throw new IllegalArgumentException(&quot;Color.rgb's red parameter (&quot; + red + &quot;) expects color values 0-255&quot;);
        }
        if (green &lt; 0 || green &gt; 255) {
            throw new IllegalArgumentException(&quot;Color.rgb's green parameter (&quot; + green + &quot;) expects color values 0-255&quot;);
        }
        if (blue &lt; 0 || blue &gt; 255) {
            throw new IllegalArgumentException(&quot;Color.rgb's blue parameter (&quot; + blue + &quot;) expects color values 0-255&quot;);
        }
    }

    /**
     * Creates a {@code Color} based on the specified values in the HSB color model,
     * and a given opacity.
     *
     * @param hue the hue, in degrees
     * @param saturation the saturation, {@code 0.0 to 1.0}
     * @param brightness the brightness, {@code 0.0 to 1.0}
     * @param opacity the opacity, {@code 0.0 to 1.0}
     * @return the {@code Color}
     * @throws IllegalArgumentException if {@code saturation}, {@code brightness} or
     *         {@code opacity} are out of range
     */
    public static Color hsb(double hue, double saturation, double brightness, double opacity) {
        checkSB(saturation, brightness);
        double[] rgb = Utils.HSBtoRGB(hue, saturation, brightness);
        Color result = new Color(rgb[0], rgb[1], rgb[2], opacity);
        return result;
    }

    /**
     * Creates an opaque {@code Color} based on the specified values in the HSB color model.
     *
     * @param hue the hue, in degrees
     * @param saturation the saturation, {@code 0.0 to 1.0}
     * @param brightness the brightness, {@code 0.0 to 1.0}
     * @return the {@code Color}
     * @throws IllegalArgumentException if {@code saturation} or {@code brightness} are
     *         out of range
     */
    public static Color hsb(double hue, double saturation, double brightness) {
        return hsb(hue, saturation, brightness, 1.0);
    }

    private static void checkSB(double saturation, double brightness) {
        if (saturation &lt; 0.0 || saturation &gt; 1.0) {
            throw new IllegalArgumentException(&quot;Color.hsb's saturation parameter (&quot; + saturation + &quot;) expects values 0.0-1.0&quot;);
        }
        if (brightness &lt; 0.0 || brightness &gt; 1.0) {
            throw new IllegalArgumentException(&quot;Color.hsb's brightness parameter (&quot; + brightness + &quot;) expects values 0.0-1.0&quot;);
        }
    }

    /**
     * Creates an RGB color specified with an HTML or CSS attribute string.
     *
     * &lt;p&gt;
     * This method supports the following formats:
     * &lt;ul&gt;
     * &lt;li&gt;Any standard HTML color name
     * &lt;li&gt;An HTML long or short format hex string with an optional hex alpha
     * channel.
     * Hexadecimal values may be preceded by either {@code &quot;0x&quot;} or {@code &quot;#&quot;}
     * and can either be 2 digits in the range {@code 00} to {@code 0xFF} or a
     * single digit in the range {@code 0} to {@code F}.
     * &lt;li&gt;An {@code rgb(r,g,b)} or {@code rgba(r,g,b,a)} format string.
     * Each of the {@code r}, {@code g}, or {@code b} values can be an integer
     * from 0 to 255 or a floating point percentage value from 0.0 to 100.0
     * followed by the percent ({@code %}) character.
     * The alpha component, if present, is a
     * floating point value from 0.0 to 1.0.  Spaces are allowed before or
     * after the numbers and between the percentage number and its percent
     * sign ({@code %}).
     * &lt;li&gt;An {@code hsl(h,s,l)} or {@code hsla(h,s,l,a)} format string.
     * The {@code h} value is a floating point number from 0.0 to 360.0
     * representing the hue angle on a color wheel in degrees with
     * {@code 0.0} or {@code 360.0} representing red, {@code 120.0}
     * representing green, and {@code 240.0} representing blue.  The
     * {@code s} value is the saturation of the desired color represented
     * as a floating point percentage from gray ({@code 0.0}) to
     * the fully saturated color ({@code 100.0}) and the {@code l} value
     * is the desired lightness or brightness of the desired color represented
     * as a floating point percentage from black ({@code 0.0}) to the full
     * brightness of the color ({@code 100.0}).
     * The alpha component, if present, is a floating
     * point value from 0.0 to 1.0.  Spaces are allowed before or
     * after the numbers and between the percentage number and its percent
     * sign ({@code %}).
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For formats without an alpha component and for named colors, opacity
     * is set according to the {@code opacity} argument. For colors specified
     * with an alpha component, the resulting opacity is a combination of the
     * parsed alpha component and the {@code opacity} argument, so a
     * transparent color becomes more transparent by specifying opacity.&lt;/p&gt;
     *
     * &lt;p&gt;Examples:&lt;/p&gt;
     * &lt;div class=&quot;classUseContainer&quot;&gt;
     * &lt;table class=&quot;overviewSummary&quot;&gt;
     * &lt;caption&gt;Web Color Format Table&lt;/caption&gt;
     * &lt;tr&gt;
     * &lt;th scope=&quot;col&quot; class=&quot;colFirst&quot;&gt;Web Format String&lt;/th&gt;
     * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot;&gt;Equivalent constructor or factory call&lt;/th&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;orange&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0xA5/255.0, 0.0, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;0xff66cc33&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.4, 0.8, 0.1)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;0xff66cc&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.4, 0.8, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;#ff66cc&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.4, 0.8, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;#f68&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.4, 0.8, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;rgb(255,102,204)&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.4, 0.8, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;rgb(100%,50%,50%)&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.5, 0.5, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;rgb(255,50%,50%,0.25)&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;new Color(1.0, 0.5, 0.5, 0.125)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;hsl(240,100%,100%)&quot;, 0.5);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.hsb(240.0, 1.0, 1.0, 0.5)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; style=&quot;border-bottom:1px solid&quot; class=&quot;colFirst&quot;&gt;
     *     &lt;code&gt;Color.web(&quot;hsla(120,0%,0%,0.25)&quot;, 0.5);&lt;/code&gt;
     * &lt;/th&gt;
     * &lt;td style=&quot;border-bottom:1px solid&quot; class=&quot;colLast&quot;&gt;
     *     &lt;code&gt;Color.hsb(120.0, 0.0, 0.0, 0.125)&lt;/code&gt;
     * &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     * &lt;/div&gt;
     *
     * @param colorString the name or numeric representation of the color
     *                    in one of the supported formats
     * @param opacity the opacity component in range from 0.0 (transparent)
     *                to 1.0 (opaque)
     * @return the RGB color specified with the colorString
     * @throws NullPointerException if {@code colorString} is {@code null}
     * @throws IllegalArgumentException if {@code colorString} specifies
     *      an unsupported color name or contains an illegal numeric value
     */
    public static Color web(String colorString, double opacity) {
        if (colorString == null) {
            throw new NullPointerException(
                    &quot;The color components or name must be specified&quot;);
        }
        if (colorString.isEmpty()) {
            throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
        }

        String color = colorString.toLowerCase(Locale.ROOT);

        if (color.startsWith(&quot;#&quot;)) {
            color = color.substring(1);
        } else if (color.startsWith(&quot;0x&quot;)) {
            color = color.substring(2);
        } else if (color.startsWith(&quot;rgb&quot;)) {
            if (color.startsWith(&quot;(&quot;, 3)) {
                return parseRGBColor(color, 4, false, opacity);
            } else if (color.startsWith(&quot;a(&quot;, 3)) {
                return parseRGBColor(color, 5, true, opacity);
            }
        } else if (color.startsWith(&quot;hsl&quot;)) {
            if (color.startsWith(&quot;(&quot;, 3)) {
                return parseHSLColor(color, 4, false, opacity);
            } else if (color.startsWith(&quot;a(&quot;, 3)) {
                return parseHSLColor(color, 5, true, opacity);
            }
        } else {
            Color col = NamedColors.get(color);
            if (col != null) {
                if (opacity == 1.0) {
                    return col;
                } else {
                    return Color.color(col.red, col.green, col.blue, opacity);
                }
            }
        }

        int len = color.length();

        try {
            int r;
            int g;
            int b;
            int a;

            if (len == 3) {
                r = Integer.parseInt(color.substring(0, 1), 16);
                g = Integer.parseInt(color.substring(1, 2), 16);
                b = Integer.parseInt(color.substring(2, 3), 16);
                return Color.color(r / 15.0, g / 15.0, b / 15.0, opacity);
            } else if (len == 4) {
                r = Integer.parseInt(color.substring(0, 1), 16);
                g = Integer.parseInt(color.substring(1, 2), 16);
                b = Integer.parseInt(color.substring(2, 3), 16);
                a = Integer.parseInt(color.substring(3, 4), 16);
                return Color.color(r / 15.0, g / 15.0, b / 15.0,
                        opacity * a / 15.0);
            } else if (len == 6) {
                r = Integer.parseInt(color.substring(0, 2), 16);
                g = Integer.parseInt(color.substring(2, 4), 16);
                b = Integer.parseInt(color.substring(4, 6), 16);
                return Color.rgb(r, g, b, opacity);
            } else if (len == 8) {
                r = Integer.parseInt(color.substring(0, 2), 16);
                g = Integer.parseInt(color.substring(2, 4), 16);
                b = Integer.parseInt(color.substring(4, 6), 16);
                a = Integer.parseInt(color.substring(6, 8), 16);
                return Color.rgb(r, g, b, opacity * a / 255.0);
            }
        } catch (NumberFormatException nfe) {}

        throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
    }

    private static Color parseRGBColor(String color, int roff,
                                       boolean hasAlpha, double a)
    {
        try {
            int rend = color.indexOf(',', roff);
            int gend = rend &lt; 0 ? -1 : color.indexOf(',', rend+1);
            int bend = gend &lt; 0 ? -1 : color.indexOf(hasAlpha ? ',' : ')', gend+1);
            int aend = hasAlpha ? (bend &lt; 0 ? -1 : color.indexOf(')', bend+1)) : bend;
            if (aend &gt;= 0) {
                double r = parseComponent(color, roff, rend, PARSE_COMPONENT);
                double g = parseComponent(color, rend+1, gend, PARSE_COMPONENT);
                double b = parseComponent(color, gend+1, bend, PARSE_COMPONENT);
                if (hasAlpha) {
                    a *= parseComponent(color, bend+1, aend, PARSE_ALPHA);
                }
                return new Color(r, g, b, a);
            }
        } catch (NumberFormatException nfe) {}

        throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
    }

    private static Color parseHSLColor(String color, int hoff,
                                       boolean hasAlpha, double a)
    {
        try {
            int hend = color.indexOf(',', hoff);
            int send = hend &lt; 0 ? -1 : color.indexOf(',', hend+1);
            int lend = send &lt; 0 ? -1 : color.indexOf(hasAlpha ? ',' : ')', send+1);
            int aend = hasAlpha ? (lend &lt; 0 ? -1 : color.indexOf(')', lend+1)) : lend;
            if (aend &gt;= 0) {
                double h = parseComponent(color, hoff, hend, PARSE_ANGLE);
                double s = parseComponent(color, hend+1, send, PARSE_PERCENT);
                double l = parseComponent(color, send+1, lend, PARSE_PERCENT);
                if (hasAlpha) {
                    a *= parseComponent(color, lend+1, aend, PARSE_ALPHA);
                }
                return Color.hsb(h, s, l, a);
            }
        } catch (NumberFormatException nfe) {}

        throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
    }

    private static final int PARSE_COMPONENT = 0; // percent, or clamped to [0,255] =&gt; [0,1]
    private static final int PARSE_PERCENT = 1; // clamped to [0,100]% =&gt; [0,1]
    private static final int PARSE_ANGLE = 2; // clamped to [0,360]
    private static final int PARSE_ALPHA = 3; // clamped to [0.0,1.0]
    private static double parseComponent(String color, int off, int end, int type) {
        color = color.substring(off, end).trim();
        if (color.endsWith(&quot;%&quot;)) {
            if (type &gt; PARSE_PERCENT) {
                throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
            }
            type = PARSE_PERCENT;
            color = color.substring(0, color.length()-1).trim();
        } else if (type == PARSE_PERCENT) {
            throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
        }
        double c = ((type == PARSE_COMPONENT)
                    ? Integer.parseInt(color)
                    : Double.parseDouble(color));
        switch (type) {
            case PARSE_ALPHA:
                return (c &lt; 0.0) ? 0.0 : ((c &gt; 1.0) ? 1.0 : c);
            case PARSE_PERCENT:
                return (c &lt;= 0.0) ? 0.0 : ((c &gt;= 100.0) ? 1.0 : (c / 100.0));
            case PARSE_COMPONENT:
                return (c &lt;= 0.0) ? 0.0 : ((c &gt;= 255.0) ? 1.0 : (c / 255.0));
            case PARSE_ANGLE:
                return ((c &lt; 0.0)
                        ? ((c % 360.0) + 360.0)
                        : ((c &gt; 360.0)
                            ? (c % 360.0)
                            : c));
        }

        throw new IllegalArgumentException(&quot;Invalid color specification&quot;);
    }

    /**
     * Creates an RGB color specified with an HTML or CSS attribute string.
     *
     * &lt;p&gt;
     * This method supports the following formats:
     * &lt;ul&gt;
     * &lt;li&gt;Any standard HTML color name
     * &lt;li&gt;An HTML long or short format hex string with an optional hex alpha
     * channel.
     * Hexadecimal values may be preceded by either {@code &quot;0x&quot;} or {@code &quot;#&quot;}
     * and can either be 2 digits in the range {@code 00} to {@code 0xFF} or a
     * single digit in the range {@code 0} to {@code F}.
     * &lt;li&gt;An {@code rgb(r,g,b)} or {@code rgba(r,g,b,a)} format string.
     * Each of the {@code r}, {@code g}, or {@code b} values can be an integer
     * from 0 to 255 or a floating point percentage value from 0.0 to 100.0
     * followed by the percent ({@code %}) character.
     * The alpha component, if present, is a
     * floating point value from 0.0 to 1.0.  Spaces are allowed before or
     * after the numbers and between the percentage number and its percent
     * sign ({@code %}).
     * &lt;li&gt;An {@code hsl(h,s,l)} or {@code hsla(h,s,l,a)} format string.
     * The {@code h} value is a floating point number from 0.0 to 360.0
     * representing the hue angle on a color wheel in degrees with
     * {@code 0.0} or {@code 360.0} representing red, {@code 120.0}
     * representing green, and {@code 240.0} representing blue.  The
     * {@code s} value is the saturation of the desired color represented
     * as a floating point percentage from gray ({@code 0.0}) to
     * the fully saturated color ({@code 100.0}) and the {@code l} value
     * is the desired lightness or brightness of the desired color represented
     * as a floating point percentage from black ({@code 0.0}) to the full
     * brightness of the color ({@code 100.0}).
     * The alpha component, if present, is a floating
     * point value from 0.0 to 1.0.  Spaces are allowed before or
     * after the numbers and between the percentage number and its percent
     * sign ({@code %}).
     * &lt;/ul&gt;
     *
     * &lt;p&gt;Examples:&lt;/p&gt;
     * &lt;div class=&quot;classUseContainer&quot;&gt;
     * &lt;table class=&quot;overviewSummary&quot;&gt;
     * &lt;caption&gt;Web Color Format Table&lt;/caption&gt;
     * &lt;tr&gt;
     * &lt;th scope=&quot;col&quot; class=&quot;colFirst&quot;&gt;Web Format String&lt;/th&gt;
     * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot;&gt;Equivalent constant or factory call&lt;/th&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;orange&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.ORANGE&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;0xff668840&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 102, 136, 0.25)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;0xff6688&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 102, 136, 1.0)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;#ff6688&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 102, 136, 1.0)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;#f68&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 102, 136, 1.0)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;rgb(255,102,136)&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 102, 136, 1.0)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;rgb(100%,50%,50%)&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 128, 128, 1.0)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;rgb(255,50%,50%,0.25)&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.rgb(255, 128, 128, 0.25)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;rowColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; class=&quot;colFirst&quot;&gt;&lt;code&gt;Color.web(&quot;hsl(240,100%,100%)&quot;);&lt;/code&gt;&lt;/th&gt;
     * &lt;td class=&quot;colLast&quot;&gt;&lt;code&gt;Color.hsb(240.0, 1.0, 1.0, 1.0)&lt;/code&gt;&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr class=&quot;altColor&quot;&gt;
     * &lt;th scope=&quot;row&quot; style=&quot;border-bottom:1px solid&quot; class=&quot;colFirst&quot;&gt;
     *     &lt;code&gt;Color.web(&quot;hsla(120,0%,0%,0.25)&quot;);&lt;/code&gt;
     * &lt;/th&gt;
     * &lt;td style=&quot;border-bottom:1px solid&quot; class=&quot;colLast&quot;&gt;
     *     &lt;code&gt;Color.hsb(120.0, 0.0, 0.0, 0.25)&lt;/code&gt;
     * &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     * &lt;/div&gt;
     *
     * @param colorString the name or numeric representation of the color
     *                    in one of the supported formats
     * @return an RGB color
     * @throws NullPointerException if {@code colorString} is {@code null}
     * @throws IllegalArgumentException if {@code colorString} specifies
     *      an unsupported color name or contains an illegal numeric value
     */
    public static Color web(String colorString) {
        return web(colorString, 1.0);
    }

    /**
     * Creates a color value from a string representation. The format
     * of the string representation is the same as in {@link #web(String)}.
     *
     * @param value the string to convert
     * @throws NullPointerException if the {@code value} is {@code null}
     * @throws IllegalArgumentException if the {@code value} specifies
     *      an unsupported color name or illegal hexadecimal value
     * @return a {@code Color} object holding the value represented
     * by the string argument
     * @see #web(String)
     * @since JavaFX 2.1
     */
    public static Color valueOf(String value) {
        if (value == null) {
            throw new NullPointerException(&quot;color must be specified&quot;);
        }

        return web(value);
    }

    private static int to32BitInteger(int red, int green, int blue, int alpha) {
        int i = red;
        i = i &lt;&lt; 8;
        i = i | green;
        i = i &lt;&lt; 8;
        i = i | blue;
        i = i &lt;&lt; 8;
        i = i | alpha;
        return i;
    }

    /**
     * Gets the hue component of this {@code Color}.
     * @return Hue value in the range in the range {@code 0.0-360.0}.
     */
    public double getHue() {
        return Utils.RGBtoHSB(red, green, blue)[0];
    }

    /**
     * Gets the saturation component of this {@code Color}.
     * @return Saturation value in the range in the range {@code 0.0-1.0}.
     */
    public double getSaturation() {
        return Utils.RGBtoHSB(red, green, blue)[1];
    }

    /**
     * Gets the brightness component of this {@code Color}.
     * @return Brightness value in the range in the range {@code 0.0-1.0}.
     */
    public double getBrightness() {
        return Utils.RGBtoHSB(red, green, blue)[2];
    }

    /**
     * Creates a new {@code Color} based on this {@code Color} with hue,
     * saturation, brightness and opacity values altered. Hue is shifted
     * about the given value and normalized into its natural range, the
     * other components' values are multiplied by the given factors and
     * clipped into their ranges.
     *
     * Increasing brightness of black color is allowed by using an arbitrary,
     * very small source brightness instead of zero.
     * @param hueShift the hue shift
     * @param saturationFactor the saturation factor
     * @param brightnessFactor the brightness factor
     * @param opacityFactor the opacity factor
     * @return a {@code Color} based based on this {@code Color} with hue,
     * saturation, brightness and opacity values altered.
     */
    public Color deriveColor(double hueShift, double saturationFactor,
                             double brightnessFactor, double opacityFactor) {

        double[] hsb = Utils.RGBtoHSB(red, green, blue);

        /* Allow brightness increase of black color */
        double b = hsb[2];
        if (b == 0 &amp;&amp; brightnessFactor &gt; 1.0) {
            b = 0.05;
        }

        /* the tail &quot;+ 360) % 360&quot; solves shifts into negative numbers */
        double h = (((hsb[0] + hueShift) % 360) + 360) % 360;
        double s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);
        b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);
        double a = Math.max(Math.min(opacity * opacityFactor, 1.0), 0.0);
        return hsb(h, s, b, a);
    }

    /**
     * Creates a new Color that is a brighter version of this Color.
     * @return a Color that is a brighter version of this Color
     */
    public Color brighter() {
        return deriveColor(0, 1.0, 1.0 / DARKER_BRIGHTER_FACTOR, 1.0);
    }

    /**
     * Creates a new Color that is a darker version of this Color.
     * @return a Color that is a darker version of this Color
     */
    public Color darker() {
        return deriveColor(0, 1.0, DARKER_BRIGHTER_FACTOR, 1.0);
    }

    /**
     * Creates a new Color that is a more saturated version of this Color.
     * @return a Color that is a more saturated version of this Color
     */
    public Color saturate() {
        return deriveColor(0, 1.0 / SATURATE_DESATURATE_FACTOR, 1.0, 1.0);
    }

    /**
     * Creates a new Color that is a less saturated version of this Color.
     * @return a Color that is a less saturated version of this Color
     */
    public Color desaturate() {
        return deriveColor(0, SATURATE_DESATURATE_FACTOR, 1.0, 1.0);
    }

    /**
     * Creates a new Color that is grayscale equivalent of this Color.
     * Opacity is preserved.
     * @return a Color that is grayscale equivalent of this Color
     */
    public Color grayscale() {
        double gray = 0.21 * red + 0.71 * green + 0.07 * blue;
        return Color.color(gray, gray, gray, opacity);
    }

    /**
     * Creates a new Color that is inversion of this Color.
     * Opacity is preserved.
     * @return a Color that is inversion of this Color
     */
    public Color invert() {
        return Color.color(1.0 - red, 1.0 - green, 1.0 - blue, opacity);
    }

    /**
     * A fully transparent color with an ARGB value of #00000000.
     */
    public static final Color TRANSPARENT          = new Color(0f, 0f, 0f, 0f);

    /**
     * The color alice blue with an RGB value of #F0F8FF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F0F8FF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ALICEBLUE = new Color(0.9411765f, 0.972549f, 1.0f);

    /**
     * The color antique white with an RGB value of #FAEBD7
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FAEBD7;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ANTIQUEWHITE = new Color(0.98039216f, 0.92156863f, 0.84313726f);

    /**
     * The color aqua with an RGB value of #00FFFF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00FFFF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color AQUA = new Color(0.0f, 1.0f, 1.0f);

    /**
     * The color aquamarine with an RGB value of #7FFFD4
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#7FFFD4;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color AQUAMARINE = new Color(0.49803922f, 1.0f, 0.83137256f);

    /**
     * The color azure with an RGB value of #F0FFFF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F0FFFF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color AZURE = new Color(0.9411765f, 1.0f, 1.0f);

    /**
     * The color beige with an RGB value of #F5F5DC
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F5F5DC;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BEIGE = new Color(0.9607843f, 0.9607843f, 0.8627451f);

    /**
     * The color bisque with an RGB value of #FFE4C4
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFE4C4;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BISQUE = new Color(1.0f, 0.89411765f, 0.76862746f);

    /**
     * The color black with an RGB value of #000000
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#000000;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BLACK = new Color(0.0f, 0.0f, 0.0f);

    /**
     * The color blanched almond with an RGB value of #FFEBCD
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFEBCD;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BLANCHEDALMOND = new Color(1.0f, 0.92156863f, 0.8039216f);

    /**
     * The color blue with an RGB value of #0000FF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#0000FF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BLUE = new Color(0.0f, 0.0f, 1.0f);

    /**
     * The color blue violet with an RGB value of #8A2BE2
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#8A2BE2;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BLUEVIOLET = new Color(0.5411765f, 0.16862746f, 0.8862745f);

    /**
     * The color brown with an RGB value of #A52A2A
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#A52A2A;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BROWN = new Color(0.64705884f, 0.16470589f, 0.16470589f);

    /**
     * The color burly wood with an RGB value of #DEB887
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DEB887;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color BURLYWOOD = new Color(0.87058824f, 0.72156864f, 0.5294118f);

    /**
     * The color cadet blue with an RGB value of #5F9EA0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#5F9EA0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CADETBLUE = new Color(0.37254903f, 0.61960787f, 0.627451f);

    /**
     * The color chartreuse with an RGB value of #7FFF00
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#7FFF00;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CHARTREUSE = new Color(0.49803922f, 1.0f, 0.0f);

    /**
     * The color chocolate with an RGB value of #D2691E
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#D2691E;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CHOCOLATE = new Color(0.8235294f, 0.4117647f, 0.11764706f);

    /**
     * The color coral with an RGB value of #FF7F50
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF7F50;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CORAL = new Color(1.0f, 0.49803922f, 0.3137255f);

    /**
     * The color cornflower blue with an RGB value of #6495ED
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#6495ED;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CORNFLOWERBLUE = new Color(0.39215687f, 0.58431375f, 0.92941177f);

    /**
     * The color cornsilk with an RGB value of #FFF8DC
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFF8DC;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CORNSILK = new Color(1.0f, 0.972549f, 0.8627451f);

    /**
     * The color crimson with an RGB value of #DC143C
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DC143C;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CRIMSON = new Color(0.8627451f, 0.078431375f, 0.23529412f);

    /**
     * The color cyan with an RGB value of #00FFFF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00FFFF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color CYAN = new Color(0.0f, 1.0f, 1.0f);

    /**
     * The color dark blue with an RGB value of #00008B
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00008B;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKBLUE = new Color(0.0f, 0.0f, 0.54509807f);

    /**
     * The color dark cyan with an RGB value of #008B8B
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#008B8B;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKCYAN = new Color(0.0f, 0.54509807f, 0.54509807f);

    /**
     * The color dark goldenrod with an RGB value of #B8860B
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#B8860B;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKGOLDENROD = new Color(0.72156864f, 0.5254902f, 0.043137256f);

    /**
     * The color dark gray with an RGB value of #A9A9A9
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#A9A9A9;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKGRAY = new Color(0.6627451f, 0.6627451f, 0.6627451f);

    /**
     * The color dark green with an RGB value of #006400
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#006400;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKGREEN = new Color(0.0f, 0.39215687f, 0.0f);

    /**
     * The color dark grey with an RGB value of #A9A9A9
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#A9A9A9;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKGREY             = DARKGRAY;

    /**
     * The color dark khaki with an RGB value of #BDB76B
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#BDB76B;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKKHAKI = new Color(0.7411765f, 0.7176471f, 0.41960785f);

    /**
     * The color dark magenta with an RGB value of #8B008B
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#8B008B;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKMAGENTA = new Color(0.54509807f, 0.0f, 0.54509807f);

    /**
     * The color dark olive green with an RGB value of #556B2F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#556B2F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKOLIVEGREEN = new Color(0.33333334f, 0.41960785f, 0.18431373f);

    /**
     * The color dark orange with an RGB value of #FF8C00
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF8C00;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKORANGE = new Color(1.0f, 0.54901963f, 0.0f);

    /**
     * The color dark orchid with an RGB value of #9932CC
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#9932CC;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKORCHID = new Color(0.6f, 0.19607843f, 0.8f);

    /**
     * The color dark red with an RGB value of #8B0000
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#8B0000;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKRED = new Color(0.54509807f, 0.0f, 0.0f);

    /**
     * The color dark salmon with an RGB value of #E9967A
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#E9967A;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKSALMON = new Color(0.9137255f, 0.5882353f, 0.47843137f);

    /**
     * The color dark sea green with an RGB value of #8FBC8F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#8FBC8F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKSEAGREEN = new Color(0.56078434f, 0.7372549f, 0.56078434f);

    /**
     * The color dark slate blue with an RGB value of #483D8B
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#483D8B;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKSLATEBLUE = new Color(0.28235295f, 0.23921569f, 0.54509807f);

    /**
     * The color dark slate gray with an RGB value of #2F4F4F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#2F4F4F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKSLATEGRAY = new Color(0.18431373f, 0.30980393f, 0.30980393f);

    /**
     * The color dark slate grey with an RGB value of #2F4F4F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#2F4F4F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKSLATEGREY        = DARKSLATEGRAY;

    /**
     * The color dark turquoise with an RGB value of #00CED1
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00CED1;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKTURQUOISE = new Color(0.0f, 0.80784315f, 0.81960785f);

    /**
     * The color dark violet with an RGB value of #9400D3
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#9400D3;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DARKVIOLET = new Color(0.5803922f, 0.0f, 0.827451f);

    /**
     * The color deep pink with an RGB value of #FF1493
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF1493;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DEEPPINK = new Color(1.0f, 0.078431375f, 0.5764706f);

    /**
     * The color deep sky blue with an RGB value of #00BFFF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00BFFF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DEEPSKYBLUE = new Color(0.0f, 0.7490196f, 1.0f);

    /**
     * The color dim gray with an RGB value of #696969
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#696969;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DIMGRAY = new Color(0.4117647f, 0.4117647f, 0.4117647f);

    /**
     * The color dim grey with an RGB value of #696969
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#696969;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DIMGREY              = DIMGRAY;

    /**
     * The color dodger blue with an RGB value of #1E90FF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#1E90FF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color DODGERBLUE = new Color(0.11764706f, 0.5647059f, 1.0f);

    /**
     * The color firebrick with an RGB value of #B22222
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#B22222;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color FIREBRICK = new Color(0.69803923f, 0.13333334f, 0.13333334f);

    /**
     * The color floral white with an RGB value of #FFFAF0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFAF0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color FLORALWHITE = new Color(1.0f, 0.98039216f, 0.9411765f);

    /**
     * The color forest green with an RGB value of #228B22
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#228B22;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color FORESTGREEN = new Color(0.13333334f, 0.54509807f, 0.13333334f);

    /**
     * The color fuchsia with an RGB value of #FF00FF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF00FF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color FUCHSIA = new Color(1.0f, 0.0f, 1.0f);

    /**
     * The color gainsboro with an RGB value of #DCDCDC
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DCDCDC;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GAINSBORO = new Color(0.8627451f, 0.8627451f, 0.8627451f);

    /**
     * The color ghost white with an RGB value of #F8F8FF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F8F8FF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GHOSTWHITE = new Color(0.972549f, 0.972549f, 1.0f);

    /**
     * The color gold with an RGB value of #FFD700
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFD700;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GOLD = new Color(1.0f, 0.84313726f, 0.0f);

    /**
     * The color goldenrod with an RGB value of #DAA520
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DAA520;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GOLDENROD = new Color(0.85490197f, 0.64705884f, 0.1254902f);

    /**
     * The color gray with an RGB value of #808080
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#808080;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GRAY = new Color(0.5019608f, 0.5019608f, 0.5019608f);

    /**
     * The color green with an RGB value of #008000
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#008000;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GREEN = new Color(0.0f, 0.5019608f, 0.0f);

    /**
     * The color green yellow with an RGB value of #ADFF2F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#ADFF2F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GREENYELLOW = new Color(0.6784314f, 1.0f, 0.18431373f);

    /**
     * The color grey with an RGB value of #808080
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#808080;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color GREY                 = GRAY;

    /**
     * The color honeydew with an RGB value of #F0FFF0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F0FFF0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color HONEYDEW = new Color(0.9411765f, 1.0f, 0.9411765f);

    /**
     * The color hot pink with an RGB value of #FF69B4
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF69B4;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color HOTPINK = new Color(1.0f, 0.4117647f, 0.7058824f);

    /**
     * The color indian red with an RGB value of #CD5C5C
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#CD5C5C;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color INDIANRED = new Color(0.8039216f, 0.36078432f, 0.36078432f);

    /**
     * The color indigo with an RGB value of #4B0082
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#4B0082;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color INDIGO = new Color(0.29411766f, 0.0f, 0.50980395f);

    /**
     * The color ivory with an RGB value of #FFFFF0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFFF0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color IVORY = new Color(1.0f, 1.0f, 0.9411765f);

    /**
     * The color khaki with an RGB value of #F0E68C
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F0E68C;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color KHAKI = new Color(0.9411765f, 0.9019608f, 0.54901963f);

    /**
     * The color lavender with an RGB value of #E6E6FA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#E6E6FA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LAVENDER = new Color(0.9019608f, 0.9019608f, 0.98039216f);

    /**
     * The color lavender blush with an RGB value of #FFF0F5
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFF0F5;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LAVENDERBLUSH = new Color(1.0f, 0.9411765f, 0.9607843f);

    /**
     * The color lawn green with an RGB value of #7CFC00
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#7CFC00;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LAWNGREEN = new Color(0.4862745f, 0.9882353f, 0.0f);

    /**
     * The color lemon chiffon with an RGB value of #FFFACD
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFACD;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LEMONCHIFFON = new Color(1.0f, 0.98039216f, 0.8039216f);

    /**
     * The color light blue with an RGB value of #ADD8E6
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#ADD8E6;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTBLUE = new Color(0.6784314f, 0.84705883f, 0.9019608f);

    /**
     * The color light coral with an RGB value of #F08080
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F08080;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTCORAL = new Color(0.9411765f, 0.5019608f, 0.5019608f);

    /**
     * The color light cyan with an RGB value of #E0FFFF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#E0FFFF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTCYAN = new Color(0.8784314f, 1.0f, 1.0f);

    /**
     * The color light goldenrod yellow with an RGB value of #FAFAD2
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FAFAD2;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTGOLDENRODYELLOW = new Color(0.98039216f, 0.98039216f, 0.8235294f);

    /**
     * The color light gray with an RGB value of #D3D3D3
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#D3D3D3;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTGRAY = new Color(0.827451f, 0.827451f, 0.827451f);

    /**
     * The color light green with an RGB value of #90EE90
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#90EE90;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTGREEN = new Color(0.5647059f, 0.93333334f, 0.5647059f);

    /**
     * The color light grey with an RGB value of #D3D3D3
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#D3D3D3;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTGREY            = LIGHTGRAY;

    /**
     * The color light pink with an RGB value of #FFB6C1
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFB6C1;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTPINK = new Color(1.0f, 0.7137255f, 0.75686276f);

    /**
     * The color light salmon with an RGB value of #FFA07A
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFA07A;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTSALMON = new Color(1.0f, 0.627451f, 0.47843137f);

    /**
     * The color light sea green with an RGB value of #20B2AA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#20B2AA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTSEAGREEN = new Color(0.1254902f, 0.69803923f, 0.6666667f);

    /**
     * The color light sky blue with an RGB value of #87CEFA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#87CEFA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTSKYBLUE = new Color(0.5294118f, 0.80784315f, 0.98039216f);

    /**
     * The color light slate gray with an RGB value of #778899
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#778899;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTSLATEGRAY = new Color(0.46666667f, 0.53333336f, 0.6f);

    /**
     * The color light slate grey with an RGB value of #778899
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#778899;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTSLATEGREY       = LIGHTSLATEGRAY;

    /**
     * The color light steel blue with an RGB value of #B0C4DE
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#B0C4DE;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTSTEELBLUE = new Color(0.6901961f, 0.76862746f, 0.87058824f);

    /**
     * The color light yellow with an RGB value of #FFFFE0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFFE0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIGHTYELLOW = new Color(1.0f, 1.0f, 0.8784314f);

    /**
     * The color lime with an RGB value of #00FF00
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00FF00;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIME = new Color(0.0f, 1.0f, 0.0f);

    /**
     * The color lime green with an RGB value of #32CD32
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#32CD32;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LIMEGREEN = new Color(0.19607843f, 0.8039216f, 0.19607843f);

    /**
     * The color linen with an RGB value of #FAF0E6
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FAF0E6;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color LINEN = new Color(0.98039216f, 0.9411765f, 0.9019608f);

    /**
     * The color magenta with an RGB value of #FF00FF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF00FF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MAGENTA = new Color(1.0f, 0.0f, 1.0f);

    /**
     * The color maroon with an RGB value of #800000
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#800000;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MAROON = new Color(0.5019608f, 0.0f, 0.0f);

    /**
     * The color medium aquamarine with an RGB value of #66CDAA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#66CDAA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMAQUAMARINE = new Color(0.4f, 0.8039216f, 0.6666667f);

    /**
     * The color medium blue with an RGB value of #0000CD
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#0000CD;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMBLUE = new Color(0.0f, 0.0f, 0.8039216f);

    /**
     * The color medium orchid with an RGB value of #BA55D3
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#BA55D3;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMORCHID = new Color(0.7294118f, 0.33333334f, 0.827451f);

    /**
     * The color medium purple with an RGB value of #9370DB
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#9370DB;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMPURPLE = new Color(0.5764706f, 0.4392157f, 0.85882354f);

    /**
     * The color medium sea green with an RGB value of #3CB371
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#3CB371;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMSEAGREEN = new Color(0.23529412f, 0.7019608f, 0.44313726f);

    /**
     * The color medium slate blue with an RGB value of #7B68EE
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#7B68EE;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMSLATEBLUE = new Color(0.48235294f, 0.40784314f, 0.93333334f);

    /**
     * The color medium spring green with an RGB value of #00FA9A
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00FA9A;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMSPRINGGREEN = new Color(0.0f, 0.98039216f, 0.6039216f);

    /**
     * The color medium turquoise with an RGB value of #48D1CC
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#48D1CC;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMTURQUOISE = new Color(0.28235295f, 0.81960785f, 0.8f);

    /**
     * The color medium violet red with an RGB value of #C71585
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#C71585;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MEDIUMVIOLETRED = new Color(0.78039217f, 0.08235294f, 0.52156866f);

    /**
     * The color midnight blue with an RGB value of #191970
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#191970;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MIDNIGHTBLUE = new Color(0.09803922f, 0.09803922f, 0.4392157f);

    /**
     * The color mint cream with an RGB value of #F5FFFA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F5FFFA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MINTCREAM = new Color(0.9607843f, 1.0f, 0.98039216f);

    /**
     * The color misty rose with an RGB value of #FFE4E1
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFE4E1;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MISTYROSE = new Color(1.0f, 0.89411765f, 0.88235295f);

    /**
     * The color moccasin with an RGB value of #FFE4B5
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFE4B5;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color MOCCASIN = new Color(1.0f, 0.89411765f, 0.70980394f);

    /**
     * The color navajo white with an RGB value of #FFDEAD
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFDEAD;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color NAVAJOWHITE = new Color(1.0f, 0.87058824f, 0.6784314f);

    /**
     * The color navy with an RGB value of #000080
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#000080;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color NAVY = new Color(0.0f, 0.0f, 0.5019608f);

    /**
     * The color old lace with an RGB value of #FDF5E6
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FDF5E6;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color OLDLACE = new Color(0.99215686f, 0.9607843f, 0.9019608f);

    /**
     * The color olive with an RGB value of #808000
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#808000;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color OLIVE = new Color(0.5019608f, 0.5019608f, 0.0f);

    /**
     * The color olive drab with an RGB value of #6B8E23
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#6B8E23;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color OLIVEDRAB = new Color(0.41960785f, 0.5568628f, 0.13725491f);

    /**
     * The color orange with an RGB value of #FFA500
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFA500;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ORANGE = new Color(1.0f, 0.64705884f, 0.0f);

    /**
     * The color orange red with an RGB value of #FF4500
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF4500;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ORANGERED = new Color(1.0f, 0.27058825f, 0.0f);

    /**
     * The color orchid with an RGB value of #DA70D6
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DA70D6;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ORCHID = new Color(0.85490197f, 0.4392157f, 0.8392157f);

    /**
     * The color pale goldenrod with an RGB value of #EEE8AA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#EEE8AA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PALEGOLDENROD = new Color(0.93333334f, 0.9098039f, 0.6666667f);

    /**
     * The color pale green with an RGB value of #98FB98
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#98FB98;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PALEGREEN = new Color(0.59607846f, 0.9843137f, 0.59607846f);

    /**
     * The color pale turquoise with an RGB value of #AFEEEE
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#AFEEEE;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PALETURQUOISE = new Color(0.6862745f, 0.93333334f, 0.93333334f);

    /**
     * The color pale violet red with an RGB value of #DB7093
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DB7093;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PALEVIOLETRED = new Color(0.85882354f, 0.4392157f, 0.5764706f);

    /**
     * The color papaya whip with an RGB value of #FFEFD5
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFEFD5;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PAPAYAWHIP = new Color(1.0f, 0.9372549f, 0.8352941f);

    /**
     * The color peach puff with an RGB value of #FFDAB9
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFDAB9;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PEACHPUFF = new Color(1.0f, 0.85490197f, 0.7254902f);

    /**
     * The color peru with an RGB value of #CD853F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#CD853F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PERU = new Color(0.8039216f, 0.52156866f, 0.24705882f);

    /**
     * The color pink with an RGB value of #FFC0CB
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFC0CB;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PINK = new Color(1.0f, 0.7529412f, 0.79607844f);

    /**
     * The color plum with an RGB value of #DDA0DD
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#DDA0DD;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PLUM = new Color(0.8666667f, 0.627451f, 0.8666667f);

    /**
     * The color powder blue with an RGB value of #B0E0E6
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#B0E0E6;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color POWDERBLUE = new Color(0.6901961f, 0.8784314f, 0.9019608f);

    /**
     * The color purple with an RGB value of #800080
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#800080;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color PURPLE = new Color(0.5019608f, 0.0f, 0.5019608f);

    /**
     * The color red with an RGB value of #FF0000
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF0000;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color RED = new Color(1.0f, 0.0f, 0.0f);

    /**
     * The color rosy brown with an RGB value of #BC8F8F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#BC8F8F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ROSYBROWN = new Color(0.7372549f, 0.56078434f, 0.56078434f);

    /**
     * The color royal blue with an RGB value of #4169E1
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#4169E1;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color ROYALBLUE = new Color(0.25490198f, 0.4117647f, 0.88235295f);

    /**
     * The color saddle brown with an RGB value of #8B4513
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#8B4513;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SADDLEBROWN = new Color(0.54509807f, 0.27058825f, 0.07450981f);

    /**
     * The color salmon with an RGB value of #FA8072
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FA8072;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SALMON = new Color(0.98039216f, 0.5019608f, 0.44705883f);

    /**
     * The color sandy brown with an RGB value of #F4A460
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F4A460;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SANDYBROWN = new Color(0.95686275f, 0.6431373f, 0.3764706f);

    /**
     * The color sea green with an RGB value of #2E8B57
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#2E8B57;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SEAGREEN = new Color(0.18039216f, 0.54509807f, 0.34117648f);

    /**
     * The color sea shell with an RGB value of #FFF5EE
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFF5EE;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SEASHELL = new Color(1.0f, 0.9607843f, 0.93333334f);

    /**
     * The color sienna with an RGB value of #A0522D
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#A0522D;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SIENNA = new Color(0.627451f, 0.32156864f, 0.1764706f);

    /**
     * The color silver with an RGB value of #C0C0C0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#C0C0C0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SILVER = new Color(0.7529412f, 0.7529412f, 0.7529412f);

    /**
     * The color sky blue with an RGB value of #87CEEB
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#87CEEB;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SKYBLUE = new Color(0.5294118f, 0.80784315f, 0.92156863f);

    /**
     * The color slate blue with an RGB value of #6A5ACD
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#6A5ACD;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SLATEBLUE = new Color(0.41568628f, 0.3529412f, 0.8039216f);

    /**
     * The color slate gray with an RGB value of #708090
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#708090;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SLATEGRAY = new Color(0.4392157f, 0.5019608f, 0.5647059f);

    /**
     * The color slate grey with an RGB value of #708090
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#708090;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SLATEGREY            = SLATEGRAY;

    /**
     * The color snow with an RGB value of #FFFAFA
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFAFA;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SNOW = new Color(1.0f, 0.98039216f, 0.98039216f);

    /**
     * The color spring green with an RGB value of #00FF7F
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#00FF7F;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color SPRINGGREEN = new Color(0.0f, 1.0f, 0.49803922f);

    /**
     * The color steel blue with an RGB value of #4682B4
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#4682B4;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color STEELBLUE = new Color(0.27450982f, 0.50980395f, 0.7058824f);

    /**
     * The color tan with an RGB value of #D2B48C
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#D2B48C;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color TAN = new Color(0.8235294f, 0.7058824f, 0.54901963f);

    /**
     * The color teal with an RGB value of #008080
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#008080;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color TEAL = new Color(0.0f, 0.5019608f, 0.5019608f);

    /**
     * The color thistle with an RGB value of #D8BFD8
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#D8BFD8;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color THISTLE = new Color(0.84705883f, 0.7490196f, 0.84705883f);

    /**
     * The color tomato with an RGB value of #FF6347
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FF6347;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color TOMATO = new Color(1.0f, 0.3882353f, 0.2784314f);

    /**
     * The color turquoise with an RGB value of #40E0D0
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#40E0D0;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color TURQUOISE = new Color(0.2509804f, 0.8784314f, 0.8156863f);

    /**
     * The color violet with an RGB value of #EE82EE
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#EE82EE;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color VIOLET = new Color(0.93333334f, 0.50980395f, 0.93333334f);

    /**
     * The color wheat with an RGB value of #F5DEB3
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F5DEB3;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color WHEAT = new Color(0.9607843f, 0.87058824f, 0.7019608f);

    /**
     * The color white with an RGB value of #FFFFFF
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFFFF;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color WHITE = new Color(1.0f, 1.0f, 1.0f);

    /**
     * The color white smoke with an RGB value of #F5F5F5
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#F5F5F5;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color WHITESMOKE = new Color(0.9607843f, 0.9607843f, 0.9607843f);

    /**
     * The color yellow with an RGB value of #FFFF00
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#FFFF00;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color YELLOW = new Color(1.0f, 1.0f, 0.0f);

    /**
     * The color yellow green with an RGB value of #9ACD32
     * &lt;div style=&quot;border:1px solid black;width:40px;height:20px;background-color:#9ACD32;float:right;margin: 0 10px 0 0&quot;&gt;&lt;/div&gt;
     */
    public static final Color YELLOWGREEN = new Color(0.6039216f, 0.8039216f, 0.19607843f);

    /*
     * Named colors moved to nested class to initialize them only when they
     * are needed.
     */
    private static final class NamedColors {
        private static final Map&lt;String, Color&gt; namedColors =
                createNamedColors();

        private NamedColors() {
<A NAME="42"></A>        }

        private static Color get(String name) {
            return <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#42',2,'match36-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>namedColors.get(name);
        }

        private static Map&lt;String, Color&gt; createNamedColors() {
            Map&lt;String, Color&gt; colors = new HashMap&lt;String,Color&gt;(256);

            colors.put(&quot;aliceblue&quot;,            ALICEBLUE);
            colors.put(&quot;antiquewhite&quot;,         ANTIQUEWHITE);
            colors.put(&quot;aqua&quot;,                 AQUA);
            colors.put(&quot;aquamarine&quot;,           AQUAMARINE);
            colors.put(&quot;azure&quot;,                AZURE);
            colors.put(&quot;beige&quot;,                BEIGE);
            colors.put(&quot;bisque&quot;,               BISQUE);
            colors.put(&quot;black&quot;,                BLACK);
            colors.put(&quot;blanchedalmond&quot;,       BLANCHEDALMOND);
            colors.put</B></FONT>(&quot;blue&quot;,                 BLUE);
            colors.put(&quot;blueviolet&quot;,           BLUEVIOLET);
            colors.put(&quot;brown&quot;,                BROWN);
            colors.put(&quot;burlywood&quot;,            BURLYWOOD);
            colors.put(&quot;cadetblue&quot;,            CADETBLUE);
            colors.put(&quot;chartreuse&quot;,           CHARTREUSE);
            colors.put(&quot;chocolate&quot;,            CHOCOLATE);
            colors.put(&quot;coral&quot;,                CORAL);
            colors.put(&quot;cornflowerblue&quot;,       CORNFLOWERBLUE);
            colors.put(&quot;cornsilk&quot;,             CORNSILK);
            colors.put(&quot;crimson&quot;,              CRIMSON);
            colors.put(&quot;cyan&quot;,                 CYAN);
            colors.put(&quot;darkblue&quot;,             DARKBLUE);
            colors.put(&quot;darkcyan&quot;,             DARKCYAN);
            colors.put(&quot;darkgoldenrod&quot;,        DARKGOLDENROD);
            colors.put(&quot;darkgray&quot;,             DARKGRAY);
            colors.put(&quot;darkgreen&quot;,            DARKGREEN);
            colors.put(&quot;darkgrey&quot;,             DARKGREY);
            colors.put(&quot;darkkhaki&quot;,            DARKKHAKI);
            colors.put(&quot;darkmagenta&quot;,          DARKMAGENTA);
            colors.put(&quot;darkolivegreen&quot;,       DARKOLIVEGREEN);
            colors.put(&quot;darkorange&quot;,           DARKORANGE);
            colors.put(&quot;darkorchid&quot;,           DARKORCHID);
            colors.put(&quot;darkred&quot;,              DARKRED);
            colors.put(&quot;darksalmon&quot;,           DARKSALMON);
            colors.put(&quot;darkseagreen&quot;,         DARKSEAGREEN);
            colors.put(&quot;darkslateblue&quot;,        DARKSLATEBLUE);
            colors.put(&quot;darkslategray&quot;,        DARKSLATEGRAY);
            colors.put(&quot;darkslategrey&quot;,        DARKSLATEGREY);
            colors.put(&quot;darkturquoise&quot;,        DARKTURQUOISE);
            colors.put(&quot;darkviolet&quot;,           DARKVIOLET);
            colors.put(&quot;deeppink&quot;,             DEEPPINK);
            colors.put(&quot;deepskyblue&quot;,          DEEPSKYBLUE);
            colors.put(&quot;dimgray&quot;,              DIMGRAY);
            colors.put(&quot;dimgrey&quot;,              DIMGREY);
            colors.put(&quot;dodgerblue&quot;,           DODGERBLUE);
            colors.put(&quot;firebrick&quot;,            FIREBRICK);
            colors.put(&quot;floralwhite&quot;,          FLORALWHITE);
            colors.put(&quot;forestgreen&quot;,          FORESTGREEN);
            colors.put(&quot;fuchsia&quot;,              FUCHSIA);
            colors.put(&quot;gainsboro&quot;,            GAINSBORO);
            colors.put(&quot;ghostwhite&quot;,           GHOSTWHITE);
            colors.put(&quot;gold&quot;,                 GOLD);
            colors.put(&quot;goldenrod&quot;,            GOLDENROD);
            colors.put(&quot;gray&quot;,                 GRAY);
            colors.put(&quot;green&quot;,                GREEN);
            colors.put(&quot;greenyellow&quot;,          GREENYELLOW);
            colors.put(&quot;grey&quot;,                 GREY);
            colors.put(&quot;honeydew&quot;,             HONEYDEW);
            colors.put(&quot;hotpink&quot;,              HOTPINK);
            colors.put(&quot;indianred&quot;,            INDIANRED);
            colors.put(&quot;indigo&quot;,               INDIGO);
            colors.put(&quot;ivory&quot;,                IVORY);
            colors.put(&quot;khaki&quot;,                KHAKI);
            colors.put(&quot;lavender&quot;,             LAVENDER);
            colors.put(&quot;lavenderblush&quot;,        LAVENDERBLUSH);
            colors.put(&quot;lawngreen&quot;,            LAWNGREEN);
            colors.put(&quot;lemonchiffon&quot;,         LEMONCHIFFON);
            colors.put(&quot;lightblue&quot;,            LIGHTBLUE);
            colors.put(&quot;lightcoral&quot;,           LIGHTCORAL);
            colors.put(&quot;lightcyan&quot;,            LIGHTCYAN);
            colors.put(&quot;lightgoldenrodyellow&quot;, LIGHTGOLDENRODYELLOW);
            colors.put(&quot;lightgray&quot;,            LIGHTGRAY);
            colors.put(&quot;lightgreen&quot;,           LIGHTGREEN);
            colors.put(&quot;lightgrey&quot;,            LIGHTGREY);
            colors.put(&quot;lightpink&quot;,            LIGHTPINK);
            colors.put(&quot;lightsalmon&quot;,          LIGHTSALMON);
            colors.put(&quot;lightseagreen&quot;,        LIGHTSEAGREEN);
            colors.put(&quot;lightskyblue&quot;,         LIGHTSKYBLUE);
            colors.put(&quot;lightslategray&quot;,       LIGHTSLATEGRAY);
            colors.put(&quot;lightslategrey&quot;,       LIGHTSLATEGREY);
            colors.put(&quot;lightsteelblue&quot;,       LIGHTSTEELBLUE);
            colors.put(&quot;lightyellow&quot;,          LIGHTYELLOW);
            colors.put(&quot;lime&quot;,                 LIME);
            colors.put(&quot;limegreen&quot;,            LIMEGREEN);
            colors.put(&quot;linen&quot;,                LINEN);
            colors.put(&quot;magenta&quot;,              MAGENTA);
            colors.put(&quot;maroon&quot;,               MAROON);
            colors.put(&quot;mediumaquamarine&quot;,     MEDIUMAQUAMARINE);
            colors.put(&quot;mediumblue&quot;,           MEDIUMBLUE);
            colors.put(&quot;mediumorchid&quot;,         MEDIUMORCHID);
            colors.put(&quot;mediumpurple&quot;,         MEDIUMPURPLE);
            colors.put(&quot;mediumseagreen&quot;,       MEDIUMSEAGREEN);
            colors.put(&quot;mediumslateblue&quot;,      MEDIUMSLATEBLUE);
            colors.put(&quot;mediumspringgreen&quot;,    MEDIUMSPRINGGREEN);
            colors.put(&quot;mediumturquoise&quot;,      MEDIUMTURQUOISE);
            colors.put(&quot;mediumvioletred&quot;,      MEDIUMVIOLETRED);
            colors.put(&quot;midnightblue&quot;,         MIDNIGHTBLUE);
            colors.put(&quot;mintcream&quot;,            MINTCREAM);
            colors.put(&quot;mistyrose&quot;,            MISTYROSE);
            colors.put(&quot;moccasin&quot;,             MOCCASIN);
            colors.put(&quot;navajowhite&quot;,          NAVAJOWHITE);
            colors.put(&quot;navy&quot;,                 NAVY);
            colors.put(&quot;oldlace&quot;,              OLDLACE);
            colors.put(&quot;olive&quot;,                OLIVE);
            colors.put(&quot;olivedrab&quot;,            OLIVEDRAB);
            colors.put(&quot;orange&quot;,               ORANGE);
            colors.put(&quot;orangered&quot;,            ORANGERED);
            colors.put(&quot;orchid&quot;,               ORCHID);
            colors.put(&quot;palegoldenrod&quot;,        PALEGOLDENROD);
            colors.put(&quot;palegreen&quot;,            PALEGREEN);
            colors.put(&quot;paleturquoise&quot;,        PALETURQUOISE);
            colors.put(&quot;palevioletred&quot;,        PALEVIOLETRED);
            colors.put(&quot;papayawhip&quot;,           PAPAYAWHIP);
            colors.put(&quot;peachpuff&quot;,            PEACHPUFF);
            colors.put(&quot;peru&quot;,                 PERU);
            colors.put(&quot;pink&quot;,                 PINK);
            colors.put(&quot;plum&quot;,                 PLUM);
            colors.put(&quot;powderblue&quot;,           POWDERBLUE);
            colors.put(&quot;purple&quot;,               PURPLE);
            colors.put(&quot;red&quot;,                  RED);
            colors.put(&quot;rosybrown&quot;,            ROSYBROWN);
            colors.put(&quot;royalblue&quot;,            ROYALBLUE);
            colors.put(&quot;saddlebrown&quot;,          SADDLEBROWN);
            colors.put(&quot;salmon&quot;,               SALMON);
            colors.put(&quot;sandybrown&quot;,           SANDYBROWN);
            colors.put(&quot;seagreen&quot;,             SEAGREEN);
            colors.put(&quot;seashell&quot;,             SEASHELL);
            colors.put(&quot;sienna&quot;,               SIENNA);
            colors.put(&quot;silver&quot;,               SILVER);
            colors.put(&quot;skyblue&quot;,              SKYBLUE);
            colors.put(&quot;slateblue&quot;,            SLATEBLUE);
            colors.put(&quot;slategray&quot;,            SLATEGRAY);
            colors.put(&quot;slategrey&quot;,            SLATEGREY);
            colors.put(&quot;snow&quot;,                 SNOW);
            colors.put(&quot;springgreen&quot;,          SPRINGGREEN);
            colors.put(&quot;steelblue&quot;,            STEELBLUE);
            colors.put(&quot;tan&quot;,                  TAN);
            colors.put(&quot;teal&quot;,                 TEAL);
            colors.put(&quot;thistle&quot;,              THISTLE);
            colors.put(&quot;tomato&quot;,               TOMATO);
            colors.put(&quot;transparent&quot;,          TRANSPARENT);
            colors.put(&quot;turquoise&quot;,            TURQUOISE);
            colors.put(&quot;violet&quot;,               VIOLET);
            colors.put(&quot;wheat&quot;,                WHEAT);
            colors.put(&quot;white&quot;,                WHITE);
            colors.put(&quot;whitesmoke&quot;,           WHITESMOKE);
            colors.put(&quot;yellow&quot;,               YELLOW);
            colors.put(&quot;yellowgreen&quot;,          YELLOWGREEN);

            return colors;
        }
    }

    /**
     * The red component of the {@code Color}, in the range {@code 0.0-1.0}.
     *
     * @return the red component of the {@code Color}, in the range {@code 0.0-1.0}
     * @defaultValue 0.0
     */
    public final double getRed() { return red; }
    private float red;

    /**
     * The green component of the {@code Color}, in the range {@code 0.0-1.0}.
     *
     * @return the green component of the {@code Color}, in the range {@code 0.0-1.0}
     * @defaultValue 0.0
     */
    public final double getGreen() { return green; }
    private float green;

    /**
     * The blue component of the {@code Color}, in the range {@code 0.0-1.0}.
     *
     * @return the blue component of the {@code Color}, in the range {@code 0.0-1.0}
     * @defaultValue 0.0
     */
    public final double getBlue() { return blue; }
    private float blue;

    /**
     * The opacity of the {@code Color}, in the range {@code 0.0-1.0}.
     *
     * @return the opacity of the {@code Color}, in the range {@code 0.0-1.0}
     * @defaultValue 1.0
     */
    public final double getOpacity() { return opacity; }
    private float opacity = 1;

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override public final boolean isOpaque() {
        return opacity &gt;= 1f;
    }

    private Object platformPaint;

    /**
     * Creates a new instance of color
     * @param red red component ranging from {@code 0} to {@code 1}
     * @param green green component ranging from {@code 0} to {@code 1}
     * @param blue blue component ranging from {@code 0} to {@code 1}
     * @param opacity opacity ranging from {@code 0} to {@code 1}
     */
    public Color(@NamedArg(&quot;red&quot;) double red, @NamedArg(&quot;green&quot;) double green, @NamedArg(&quot;blue&quot;) double blue, @NamedArg(value=&quot;opacity&quot;, defaultValue=&quot;1&quot;) double opacity) {
        if (red &lt; 0 || red &gt; 1) {
            throw new IllegalArgumentException(&quot;Color's red value (&quot; + red + &quot;) must be in the range 0.0-1.0&quot;);
        }
        if (green &lt; 0 || green &gt; 1) {
            throw new IllegalArgumentException(&quot;Color's green value (&quot; + green + &quot;) must be in the range 0.0-1.0&quot;);
        }
        if (blue &lt; 0 || blue &gt; 1) {
            throw new IllegalArgumentException(&quot;Color's blue value (&quot; + blue + &quot;) must be in the range 0.0-1.0&quot;);
        }
        if (opacity &lt; 0 || opacity &gt; 1) {
            throw new IllegalArgumentException(&quot;Color's opacity value (&quot; + opacity + &quot;) must be in the range 0.0-1.0&quot;);
        }

        this.red = (float) red;
        this.green = (float) green;
        this.blue = (float) blue;
        this.opacity = (float) opacity;
    }

    /**
     * Creates a new instance of color. This constructor performs no integrity
     * checks, and thus should ONLY be used by internal code in Color which
     * knows that the hard-coded values are correct.
     *
     * @param red red component ranging from {@code 0} to {@code 1}
     * @param green green component ranging from {@code 0} to {@code 1}
     * @param blue blue component ranging from {@code 0} to {@code 1}
     * @param opacity opacity ranging from {@code 0} to {@code 1}
     */
    private Color(float red, float green, float blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }

    @Override
    Object acc_getPlatformPaint() {
        if (platformPaint == null) {
            platformPaint = Toolkit.getToolkit().getPaint(this);
        }
        return platformPaint;
    }

    /**
     * {@inheritDoc}
     */
    @Override public Color interpolate(Color endValue, double t) {
        if (t &lt;= 0.0) return this;
        if (t &gt;= 1.0) return endValue;
        float ft = (float) t;
        return new Color(
            red     + (endValue.red     - red)     * ft,
            green   + (endValue.green   - green)   * ft,
            blue    + (endValue.blue    - blue)    * ft,
            opacity + (endValue.opacity - opacity) * ft
        );
    }

    /**
     * Indicates whether some other object is &quot;equal to&quot; this one.
     * @param obj the reference object with which to compare.
     * @return {@code true} if this object is equal to the {@code obj} argument; {@code false} otherwise.
     */
    @Override public boolean equals(Object obj) {
        if (obj == this) return true;
        if (obj instanceof Color) {
            Color other = (Color) obj;
            return red == other.red
                &amp;&amp; green == other.green
                &amp;&amp; blue == other.blue
                &amp;&amp; opacity == other.opacity;
        } else return false;
    }

    /**
     * Returns a hash code for this {@code Color} object.
     * @return a hash code for this {@code Color} object.
     */
    @Override public int hashCode() {
        // construct the 32bit integer representation of this color
        int r = (int)Math.round(red * 255.0);
        int g = (int)Math.round(green * 255.0);
        int b = (int)Math.round(blue * 255.0);
        int a = (int)Math.round(opacity * 255.0);
        return to32BitInteger(r, g, b, a);
    }

    /**
     * Returns a string representation of this {@code Color}.
     * This method is intended to be used only for informational purposes.
     * The content and format of the returned string might vary between implementations.
     * The returned string might be empty but cannot be {@code null}.
     *
     * @return the string representation
     */
    @Override public String toString() {
        int r = (int)Math.round(red * 255.0);
        int g = (int)Math.round(green * 255.0);
        int b = (int)Math.round(blue * 255.0);
        int o = (int)Math.round(opacity * 255.0);
        return String.format(&quot;0x%02x%02x%02x%02x&quot; , r, g, b, o);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/HLineTo.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.geom.Path2D;
import com.sun.javafx.scene.shape.HLineToHelper;
import com.sun.javafx.sg.prism.NGPath;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;


/**
 * Creates a horizontal line path element from the current point to x.
 *
 * &lt;p&gt;For more information on path elements see the {@link Path} and
 * {@link PathElement} classes.
 *
 * &lt;p&gt;Example:
 *
&lt;PRE&gt;
import javafx.scene.shape.*;

Path path = new Path();
path.getElements().add(new MoveTo(0.0f, 0.0f));
path.getElements().add(new HLineTo(80.0f));
&lt;/PRE&gt;
 * @since JavaFX 2.0
 */
public class HLineTo extends PathElement {
    static {
        HLineToHelper.setHLineToAccessor(new HLineToHelper.HLineToAccessor() {
            @Override
            public void doAddTo(PathElement pathElement, Path2D path) {
                ((HLineTo) pathElement).doAddTo(path);
            }
        });
    }

    /**
     * Creates an empty instance of HLineTo.
     */
    public HLineTo() {
        HLineToHelper.initHelper(this);
    }

    /**
     * Creates an instance of HLineTo.
     * @param x the horizontal coordinate to line to
     */
    public HLineTo(double x) {
        setX(x);
        HLineToHelper.initHelper(this);
    }

    /**
     * Defines the X coordinate.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty x = new DoublePropertyBase() {

        @Override
        public void invalidated() {
            u();
        }

        @Override
        public Object getBean() {
            return HLineTo.this;
        }

        @Override
        public String getName() {
            return &quot;x&quot;;
        }
    };


    public final void setX(double value) {
        x.set(value);
    }

    public final double getX() {
        return x.get();
    }
<A NAME="35"></A>
    public final DoubleProperty xProperty() {
        return x;
    <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#35',2,'match36-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    void addTo(NGPath pgPath) {
        if (isAbsolute()) {
            pgPath.addLineTo((float)getX(), pgPath.getCurrentY());
        }</B></FONT> else {
            pgPath.addLineTo((float)(pgPath.getCurrentX() + getX()), pgPath.getCurrentY());
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doAddTo(Path2D path) {
        if (isAbsolute()) {
            path.lineTo((float)getX(), path.getCurrentY());
        } else {
            path.lineTo((float)(path.getCurrentX() + getX()), path.getCurrentY());
        }
    }

    /**
     * Returns a string representation of this {@code HLineTo} object.
     * @return a string representation of this {@code HLineTo} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;HLineTo[&quot;);
        sb.append(&quot;x=&quot;).append(getX());
        return sb.append(&quot;]&quot;).toString();
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/LineTo.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.geom.Path2D;
import com.sun.javafx.scene.shape.CubicCurveToHelper;
import com.sun.javafx.scene.shape.LineToHelper;
import com.sun.javafx.sg.prism.NGPath;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;


/**
 * Creates a line path element by drawing a straight line
 * from the current coordinate to the new coordinates.
 *
 * &lt;p&gt;For more information on path elements see the {@link Path} and
 * {@link PathElement} classes.
 *
 * &lt;p&gt;Example:
 *
&lt;PRE&gt;
import javafx.scene.shape.*;

Path path = new Path();
path.getElements().add(new MoveTo(0.0f, 50.0f));
path.getElements().add(new LineTo(100.0f, 100.0f));
&lt;/PRE&gt;
 * @since JavaFX 2.0
 */
public class LineTo extends PathElement {
    static {
        LineToHelper.setLineToAccessor(new LineToHelper.LineToAccessor() {
            @Override
            public void doAddTo(PathElement pathElement, Path2D path) {
                ((LineTo) pathElement).doAddTo(path);
            }
        });
    }

    /**
     * Creates an empty instance of LineTo.
     */
    public LineTo() {
        LineToHelper.initHelper(this);
    }

    /**
     * Creates a new isntance of LineTo.
     * @param x the horizontal coordinate of the line end point
     * @param y the vertical coordinate of the line end point
     */
    public LineTo(double x, double y) {
        setX(x);
        setY(y);
        LineToHelper.initHelper(this);
    }

    /**
     * Defines the X coordinate.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty x;



    public final void setX(double value) {
        if (x != null || value != 0.0) {
            xProperty().set(value);
        }
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    u();
                }

                @Override
                public Object getBean() {
                    return LineTo.this;
                }

                @Override
                public String getName() {
                    return &quot;x&quot;;
                }
            };
        }
        return x;
    }

    /**
     * Defines the Y coordinate.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty y;

    public final void setY(double value) {
        if (y != null || value != 0.0) {
            yProperty().set(value);
        }
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    u();
                }

                @Override
                public Object getBean() {
                    return LineTo.this;
                }

                @Override
                public String getName() {
                    return &quot;y&quot;;
<A NAME="16"></A>                }
            };
        }
        <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#16',2,'match36-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return y;
    }

    @Override
    void addTo(NGPath pgPath) {
        if (isAbsolute()) {
            pgPath.addLineTo((float)getX(), (float)getY());
        }</B></FONT> else {
            pgPath.addLineTo((float)(pgPath.getCurrentX() + getX()),
                             (float)(pgPath.getCurrentY() + getY()));
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doAddTo(Path2D path) {
        if (isAbsolute()) {
            path.lineTo((float)getX(), (float)getY());
        } else {
            path.lineTo((float)(path.getCurrentX() + getX()),
                        (float)(path.getCurrentY() + getY()));
        }
    }

    /**
     * Returns a string representation of this {@code LineTo} object.
     * @return a string representation of this {@code LineTo} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;LineTo[&quot;);
        sb.append(&quot;x=&quot;).append(getX());
        sb.append(&quot;, y=&quot;).append(getY());
        return sb.append(&quot;]&quot;).toString();
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Rotate.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.geometry.Point3D;

import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.geometry.Point2D;


/**
 * This class represents an {@code Affine} object that rotates coordinates
 * around an anchor point. This operation is equivalent to translating the
 * coordinates so that the anchor point is at the origin (S1), then rotating them
 * about the new origin (S2), and finally translating so that the
 * intermediate origin is restored to the coordinates of the original
 * anchor point (S3).
 * &lt;p&gt;
 * The matrix representing the rotation transformation around an axis {@code (x,y,z)}
 * by an angle {@code t} is as follows:
 * &lt;pre&gt;
 *              [   cos(t)   -sin(t)   0   x-x*cos(t)+y*sin(t)   ]
 *              [   sin(t)    cos(t)   0   y-x*sin(t)-y*cos(t)   ]
 *              [     0         0      1           z             ]
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For example, to rotate a text 30 degrees around the Z-axis at
 * anchor point of (50,30):
 * &lt;pre&gt;{@code
 * Text text = new Text(&quot;This is a test&quot;);
 * text.setX(10);
 * text.setY(50);
 * text.setFont(new Font(20));
 *
 * text.getTransforms().add(new Rotate(30, 50, 30));
 * }&lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */

public class Rotate extends Transform {

    /**
     * Specifies the X-axis as the axis of rotation.
     */
    public static final Point3D X_AXIS = new Point3D(1,0,0);

    /**
     * Specifies the Y-axis as the axis of rotation.
     */
    public static final Point3D Y_AXIS = new Point3D(0,1,0);

    /**
     * Specifies the Z-axis as the axis of rotation.
     */
    public static final Point3D Z_AXIS = new Point3D(0,0,1);

    /**
     * Avoids lot of repeated computation.
     * @see #MatrixCache
     */
    private MatrixCache cache;

    /**
     * Avoids lot of repeated computation.
     * @see #MatrixCache
     */
    private MatrixCache inverseCache;

    /**
     * Creates a default Rotate transform (identity).
     */
    public Rotate() {
    }

    /**
     * Creates a two-dimensional Rotate transform.
     * The pivot point is set to (0,0)
     * @param angle the angle of rotation measured in degrees
     */
    public Rotate(double angle) {
        setAngle(angle);
    }

    /**
     * Creates a three-dimensional Rotate transform.
     * The pivot point is set to (0,0,0)
     * @param angle the angle of rotation measured in degrees
     * @param axis the axis of rotation
     */
    public Rotate(double angle, Point3D axis) {
        setAngle(angle);
        setAxis(axis);
    }

    /**
     * Creates a two-dimensional Rotate transform with pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     */
    public Rotate(double angle, double pivotX, double pivotY) {
        setAngle(angle);
        setPivotX(pivotX);
        setPivotY(pivotY);
    }

    /**
     * Creates a simple Rotate transform with three-dimensional pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     */
    public Rotate(double angle, double pivotX, double pivotY, double pivotZ) {
        this(angle, pivotX, pivotY);
        setPivotZ(pivotZ);
    }

    /**
     * Creates a three-dimensional Rotate transform with pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the axis of rotation
     */
    public Rotate(double angle, double pivotX, double pivotY, double pivotZ, Point3D axis) {
        this(angle, pivotX, pivotY);
        setPivotZ(pivotZ);
        setAxis(axis);
    }

    /**
     * Defines the angle of rotation measured in degrees.
     */
    private DoubleProperty angle;


    public final void setAngle(double value) {
        angleProperty().set(value);
    }

    public final double getAngle() {
        return angle == null ? 0.0 : angle.get();
    }

    public final DoubleProperty angleProperty() {
        if (angle == null) {
            angle = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;angle&quot;;
                }
            };
        }
        return angle;
    }

    /**
     * Defines the X coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotX;


    public final void setPivotX(double value) {
        pivotXProperty().set(value);
    }

    public final double getPivotX() {
        return pivotX == null ? 0.0 : pivotX.get();
    }

    public final DoubleProperty pivotXProperty() {
        if (pivotX == null) {
            pivotX = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotX&quot;;
                }
            };
        }
        return pivotX;
    }

    /**
     * Defines the Y coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotY;


    public final void setPivotY(double value) {
        pivotYProperty().set(value);
    }

    public final double getPivotY() {
        return pivotY == null ? 0.0 : pivotY.get();
    }

    public final DoubleProperty pivotYProperty() {
        if (pivotY == null) {
            pivotY = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotY&quot;;
                }
            };
        }
        return pivotY;
    }

    /**
     * Defines the Z coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotZ;


    public final void setPivotZ(double value) {
        pivotZProperty().set(value);
    }

    public final double getPivotZ() {
        return pivotZ == null ? 0.0 : pivotZ.get();
    }

    public final DoubleProperty pivotZProperty() {
        if (pivotZ == null) {
            pivotZ = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotZ&quot;;
                }
            };
        }
        return pivotZ;
    }

    /**
     * Defines the axis of rotation at the pivot point.
     */
    private ObjectProperty&lt;Point3D&gt; axis;


    public final void setAxis(Point3D value) {
        axisProperty().set(value);
    }

    public final Point3D getAxis() {
        return axis == null ? Z_AXIS : axis.get();
    }

    public final ObjectProperty&lt;Point3D&gt; axisProperty() {
        if (axis == null) {
            axis = new ObjectPropertyBase&lt;Point3D&gt;(Z_AXIS) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;axis&quot;;
                }
            };
        }
        return axis;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    public double getMxx() {
        updateCache();
        return cache.mxx;
    }

    @Override
    public double getMxy() {
        updateCache();
        return cache.mxy;
    }

    @Override
    public double getMxz() {
        updateCache();
        return cache.mxz;
    }

    @Override
    public double getTx() {
        updateCache();
        return cache.tx;
    }

    @Override
    public double getMyx() {
        updateCache();
        return cache.myx;
    }

    @Override
    public double getMyy() {
        updateCache();
        return cache.myy;
    }

    @Override
    public double getMyz() {
        updateCache();
        return cache.myz;
    }

    @Override
    public double getTy() {
        updateCache();
        return cache.ty;
    }

    @Override
    public double getMzx() {
        updateCache();
        return cache.mzx;
    }

    @Override
    public double getMzy() {
        updateCache();
        return cache.mzy;
    }

    @Override
    public double getMzz() {
        updateCache();
        return cache.mzz;
    }

    @Override
    public double getTz() {
        updateCache();
        return cache.tz;
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        final Point3D a = getAxis();
        return (a.getX() == 0.0 &amp;&amp; a.getY() == 0.0) || getAngle() == 0;
    }

    @Override
    boolean computeIsIdentity() {
        if (getAngle() == 0.0) {
            return true;
        }

        final Point3D a = getAxis();
        return a.getX() == 0 &amp;&amp; a.getY() == 0 &amp;&amp; a.getZ() == 0.0;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    void fill2DArray(double[] array) {
        updateCache();
        array[0] = cache.mxx;
        array[1] = cache.mxy;
        array[2] = cache.tx;
        array[3] = cache.myx;
        array[4] = cache.myy;
        array[5] = cache.ty;
    }

    @Override
    void fill3DArray(double[] array) {
        updateCache();
        array[0] = cache.mxx;
        array[1] = cache.mxy;
        array[2] = cache.mxz;
        array[3] = cache.tx;
        array[4] = cache.myx;
        array[5] = cache.myy;
        array[6] = cache.myz;
        array[7] = cache.ty;
        array[8] = cache.mzx;
        array[9] = cache.mzy;
        array[10] = cache.mzz;
        array[11] = cache.tz;
        return;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        if (transform instanceof Rotate) {
            Rotate r = (Rotate) transform;
            final double px = getPivotX();
            final double py = getPivotY();
            final double pz = getPivotZ();

            if ((r.getAxis() == getAxis() ||
                        r.getAxis().normalize().equals(getAxis().normalize())) &amp;&amp;
                    px == r.getPivotX() &amp;&amp;
                    py == r.getPivotY() &amp;&amp;
                    pz == r.getPivotZ()) {
                return new Rotate(getAngle() + r.getAngle(), px, py, pz, getAxis());
            }
        }

        if (transform instanceof Affine) {
            Affine a = (Affine) transform.clone();
            a.prepend(this);
            return a;
        }

        return super.createConcatenation(transform);
    }

    @Override
    public Transform createInverse() throws NonInvertibleTransformException {
        return new Rotate(-getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    @Override
    public Rotate clone() {
        return new Rotate(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        updateCache();

        return new Point2D(
            cache.mxx * x + cache.mxy * y + cache.tx,
            cache.myx * x + cache.myy * y + cache.ty);
    }

    @Override
    public Point3D transform(double x, double y, double z) {
        updateCache();

        return new Point3D(
            cache.mxx * x + cache.mxy * y + cache.mxz * z + cache.tx,
            cache.myx * x + cache.myy * y + cache.myz * z + cache.ty,
            cache.mzx * x + cache.mzy * y + cache.mzz * z + cache.tz);
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        updateCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = cache.mxx * x + cache.mxy * y + cache.tx;
            dstPts[dstOff++] = cache.myx * x + cache.myy * y + cache.ty;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        updateCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = cache.mxx * x + cache.mxy * y + cache.mxz * z + cache.tx;
            dstPts[dstOff++] = cache.myx * x + cache.myy * y + cache.myz * z + cache.ty;
            dstPts[dstOff++] = cache.mzx * x + cache.mzy * y + cache.mzz * z + cache.tz;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateCache();

        return new Point2D(
            cache.mxx * x + cache.mxy * y,
            cache.myx * x + cache.myy * y);
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        updateCache();

        return new Point3D(
            cache.mxx * x + cache.mxy * y + cache.mxz * z,
            cache.myx * x + cache.myy * y + cache.myz * z,
            cache.mzx * x + cache.mzy * y + cache.mzz * z);
    }

    @Override
    public Point2D inverseTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateInverseCache();

        return new Point2D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.tx,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.ty);
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z) {
        updateInverseCache();

        return new Point3D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.mxz * z
                + inverseCache.tx,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.myz * z
                + inverseCache.ty,
            inverseCache.mzx * x + inverseCache.mzy * y + inverseCache.mzz * z
                + inverseCache.tz);
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        updateInverseCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = inverseCache.mxx * x + inverseCache.mxy * y
                    + inverseCache.tx;
            dstPts[dstOff++] = inverseCache.myx * x + inverseCache.myy * y
                    + inverseCache.ty;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        updateInverseCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = inverseCache.mxx * x + inverseCache.mxy * y
                    + inverseCache.mxz * z + inverseCache.tx;
            dstPts[dstOff++] = inverseCache.myx * x + inverseCache.myy * y
                    + inverseCache.myz * z + inverseCache.ty;
            dstPts[dstOff++] = inverseCache.mzx * x + inverseCache.mzy * y
                    + inverseCache.mzz * z + inverseCache.tz;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateInverseCache();

        return new Point2D(
            inverseCache.mxx * x + inverseCache.mxy * y,
            inverseCache.myx * x + inverseCache.myy * y);
    }

    @Override
    public Point3D inverseDeltaTransform(double x, double y, double z) {
        updateInverseCache();

        return new Point3D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.mxz * z,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.myz * z,
            inverseCache.mzx * x + inverseCache.mzy * y + inverseCache.mzz * z);
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Rotate} object.
     * @return a string representation of this {@code Rotate} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Rotate [&quot;);

        sb.append(&quot;angle=&quot;).append(getAngle());
        sb.append(&quot;, pivotX=&quot;).append(getPivotX());
        sb.append(&quot;, pivotY=&quot;).append(getPivotY());
        sb.append(&quot;, pivotZ=&quot;).append(getPivotZ());
        sb.append(&quot;, axis=&quot;).append(getAxis());

        return sb.append(&quot;]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    @Override
    void apply(final Affine3D trans) {
        double localPivotX = getPivotX();
        double localPivotY = getPivotY();
        double localPivotZ = getPivotZ();
        double localAngle = getAngle();

        if (localPivotX != 0 || localPivotY != 0 || localPivotZ != 0) {
            trans.translate(localPivotX, localPivotY, localPivotZ);
            trans.rotate(Math.toRadians(localAngle),
                         getAxis().getX(),getAxis().getY(), getAxis().getZ());
<A NAME="20"></A>            trans.translate(-localPivotX, -localPivotY, -localPivotZ);
        } else {
            trans.rotate(Math.toRadians(localAngle),
                         getAxis().getX(), <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#20',2,'match36-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getAxis().getY(), getAxis().getZ());
        }
    }

    @Override
    BaseTransform derive(BaseTransform trans) {
        if (isIdentity()) {</B></FONT>
            return trans;
        }

        double localPivotX = getPivotX();
        double localPivotY = getPivotY();
        double localPivotZ = getPivotZ();
        double localAngle = getAngle();

        if (localPivotX != 0 || localPivotY != 0 || localPivotZ != 0) {
            trans = trans.deriveWithTranslation(localPivotX, localPivotY, localPivotZ);
            trans = trans.deriveWithRotation(Math.toRadians(localAngle),
                         getAxis().getX(),getAxis().getY(), getAxis().getZ());
            return trans.deriveWithTranslation(-localPivotX, -localPivotY, -localPivotZ);
        } else {
            return trans.deriveWithRotation(Math.toRadians(localAngle),
                         getAxis().getX(), getAxis().getY(), getAxis().getZ());
        }
    }

    @Override
    void validate() {
        getAxis();
        getAngle();
        getPivotX();
        getPivotY();
        getPivotZ();
    }

    @Override
    protected void transformChanged() {
        if (cache != null) {
            cache.invalidate();
        }
        super.transformChanged();
    }

    @Override
    void appendTo(Affine a) {
        a.appendRotation(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    @Override
    void prependTo(Affine a) {
        a.prependRotation(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    /**
     * Updates the matrix cache
     */
    private void updateCache() {
        if (cache == null) {
            cache = new MatrixCache();
        }

        if (!cache.valid) {
            cache.update(getAngle(), getAxis(),
                    getPivotX(), getPivotY(), getPivotZ());
        }
    }

    /**
     * Updates the inverse matrix cache
     */
    private void updateInverseCache() {
        if (inverseCache == null) {
            inverseCache = new MatrixCache();
        }

        if (!inverseCache.valid) {
            inverseCache.update(-getAngle(), getAxis(),
                    getPivotX(), getPivotY(), getPivotZ());
        }
    }

    /**
     * Matrix cache. Computing single transformation matrix elements for
     * a general rotation is quite expensive. Also each of those partial
     * computations need some common operations to be made (compute sin
     * and cos, normalize axis). Therefore with the direct element computations
     * if all the getters for the elements are called to get the matrix,
     * the result is slow.
     *
     * If a matrix element is asked for, we can reasonably anticipate that
     * some other elements will be asked for as well. So when any element
     * needs to be computed, we compute the entire matrix, cache it,
     * and use the stored values until the transform changes.
     */
    private static class MatrixCache {
        boolean valid = false;
        boolean is3D = false;

        double mxx, mxy, mxz, tx,
               myx, myy, myz, ty,
               mzx, mzy, mzz, tz;

        public MatrixCache() {
            // to have the 3D part right when using 2D-only
            mzz = 1.0;
        }

        public void update(double angle, Point3D axis,
                double px, double py, double pz) {

            final double rads = Math.toRadians(angle);
            final double sin = Math.sin(rads);
            final double cos = Math.cos(rads);

            if (axis == Z_AXIS ||
                    (axis.getX() == 0.0 &amp;&amp;
                     axis.getY() == 0.0 &amp;&amp;
                     axis.getZ() &gt; 0.0)) {
                // 2D case
                mxx = cos;
                mxy = -sin;
                tx = px * (1 - cos) + py * sin;
                myx = sin;
                myy = cos;
                ty = py * (1 - cos) - px * sin;

                if (is3D) {
                    // Was 3D, needs to set the 3D values
                    mxz = 0.0;
                    myz = 0.0;
                    mzx = 0.0;
                    mzy = 0.0;
                    mzz = 1.0;
                    tz = 0.0;
                    is3D = false;
                }
                valid = true;
                return;
            }
            // 3D case
            is3D = true;

            double axisX, axisY, axisZ;

            if (axis == X_AXIS || axis == Y_AXIS || axis == Z_AXIS) {
                axisX = axis.getX();
                axisY = axis.getY();
                axisZ = axis.getZ();
            } else {
                // normalize
                final double mag = Math.sqrt(axis.getX() * axis.getX() +
                        axis.getY() * axis.getY() + axis.getZ() * axis.getZ());

                if (mag == 0.0) {
                    mxx = 1; mxy = 0; mxz = 0; tx = 0;
                    myx = 0; myy = 1; myz = 0; ty = 0;
                    mzx = 0; mzy = 0; mzz = 1; tz = 0;
                    valid = true;
                    return;
                } else {
                    axisX = axis.getX() / mag;
                    axisY = axis.getY() / mag;
                    axisZ = axis.getZ() / mag;
                }
            }

            mxx = cos + axisX * axisX * (1 - cos);
            mxy = axisX * axisY * (1 - cos) - axisZ * sin;
            mxz = axisX * axisZ * (1 - cos) + axisY * sin;
            tx = px * (1 - mxx) - py * mxy - pz * mxz;

            myx = axisY * axisX * (1 - cos) + axisZ * sin;
            myy = cos + axisY * axisY * (1 - cos);
            myz = axisY * axisZ * (1 - cos) - axisX * sin;
            ty = py * (1 - myy) - px * myx - pz * myz;

            mzx = axisZ * axisX * (1 - cos) - axisY * sin;
            mzy = axisZ * axisY * (1 - cos) + axisX * sin;
            mzz = cos + axisZ * axisZ * (1 - cos);
            tz = pz * (1 - mzz) - px * mzx - py * mzy;

            valid = true;
        }

        public void invalidate() {
            valid = false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Scale.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;

import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;


/**
 * This class represents an {@code Affine} object that scales coordinates
 * by the specified factors. The matrix representing the scaling transformation
 * around a pivot point {@code (pivotX, pivotY, pivotZ)} with scaling factors
 * {@code x}, {@code y} and {@code z} is as follows:
 * &lt;pre&gt;
 *              [   x   0   0   (1-x)*pivotX   ]
 *              [   0   y   0   (1-y)*pivotY   ]
 *              [   0   0   z   (1-z)*pivotZ   ]
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Scale extends Transform {
    /**
     * Creates a default Scale (identity).
     */
    public Scale() {
    }

    /**
     * Creates a two-dimensional Scale.
     * The pivot point is set to (0,0)
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     */
    public Scale(double x, double y) {
        setX(x);
        setY(y);
    }

    /**
     * Creates a two-dimensional Scale with pivot.
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     * @param pivotX the X coordinate about which point the scale occurs
     * @param pivotY the Y coordinate about which point the scale occurs
     */
    public Scale(double x, double y, double pivotX, double pivotY) {
        this(x, y);
        setPivotX(pivotX);
        setPivotY(pivotY);
    }

    /**
     * Creates a three-dimensional Scale.
     * The pivot point is set to (0,0,0)
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     * @param z the factor by which coordinates are scaled along the Z axis
     */
    public Scale(double x, double y, double z) {
        this(x, y);
        setZ(z);
    }

    /**
     * Creates a three-dimensional Scale with pivot.
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     * @param z the factor by which coordinates are scaled along the Z axis
     * @param pivotX the X coordinate about which point the scale occurs
     * @param pivotY the Y coordinate about which point the scale occurs
     * @param pivotZ the Z coordinate about which point the scale occurs
     */
    public Scale(double x, double y, double z, double pivotX, double pivotY, double pivotZ) {
        this(x, y, pivotX, pivotY);
        setZ(z);
        setPivotZ(pivotZ);
    }

    /**
     * Defines the factor by which coordinates are scaled
     * along the X axis direction. The default value is {@code 1.0}.
     */
    private DoubleProperty x;


    public final void setX(double value) {
        xProperty().set(value);
    }

    public final double getX() {
        return x == null ? 1.0F : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase(1.0F) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;x&quot;;
                }
            };
        }
        return x;
    }

    /**
     * Defines the factor by which coordinates are scaled
     * along the Y axis direction. The default value is {@code 1.0}.
     */
    private DoubleProperty y;


    public final void setY(double value) {
        yProperty().set(value);
    }

    public final double getY() {
        return y == null ? 1.0F : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase(1.0F) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;y&quot;;
                }
            };
        }
        return y;
    }

    /**
     * Defines the factor by which coordinates are scaled
     * along the Z axis direction. The default value is {@code 1.0}.
     */
    private DoubleProperty z;


    public final void setZ(double value) {
        zProperty().set(value);
    }

    public final double getZ() {
        return z == null ? 1.0F : z.get();
    }

    public final DoubleProperty zProperty() {
        if (z == null) {
            z = new DoublePropertyBase(1.0F) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;z&quot;;
                }
            };
        }
        return z;
    }

    /**
     * Defines the X coordinate about which point the scale occurs.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotX;


    public final void setPivotX(double value) {
        pivotXProperty().set(value);
    }

    public final double getPivotX() {
        return pivotX == null ? 0.0 : pivotX.get();
    }

    public final DoubleProperty pivotXProperty() {
        if (pivotX == null) {
            pivotX = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotX&quot;;
                }
            };
        }
        return pivotX;
    }

    /**
     * Defines the Y coordinate about which point the scale occurs.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotY;


    public final void setPivotY(double value) {
        pivotYProperty().set(value);
    }

    public final double getPivotY() {
        return pivotY == null ? 0.0 : pivotY.get();
    }

    public final DoubleProperty pivotYProperty() {
        if (pivotY == null) {
            pivotY = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotY&quot;;
                }
            };
        }
        return pivotY;
    }

    /**
     * Defines the Z coordinate about which point the scale occurs.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotZ;


    public final void setPivotZ(double value) {
        pivotZProperty().set(value);
    }

    public final double getPivotZ() {
        return pivotZ == null ? 0.0 : pivotZ.get();
    }

    public final DoubleProperty pivotZProperty() {
        if (pivotZ == null) {
            pivotZ = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotZ&quot;;
                }
            };
        }
        return pivotZ;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    public double getMxx() {
        return getX();
    }

    @Override
    public double getMyy() {
        return getY();
    }

    @Override
    public double getMzz() {
        return getZ();
    }

    @Override
    public double getTx() {
        return (1-getX()) * getPivotX();
    }

    @Override
    public double getTy() {
        return (1-getY()) * getPivotY();
    }

    @Override
    public double getTz() {
        return (1-getZ()) * getPivotZ();
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        return getZ() == 1.0;
    }

    @Override
    boolean computeIsIdentity() {
        return getX() == 1.0 &amp;&amp; getY() == 1.0 &amp;&amp; getZ() == 1.0;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    void fill2DArray(double[] array) {
        final double sx = getX();
        final double sy = getY();

        array[0] = sx;
        array[1] = 0.0;
        array[2] = (1-sx) * getPivotX();
        array[3] = 0.0;
        array[4] = sy;
        array[5] = (1-sy) * getPivotY();
    }

    @Override
    void fill3DArray(double[] array) {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        array[0] = sx;
        array[1] = 0.0;
        array[2] = 0.0;
        array[3] = (1-sx) * getPivotX();
        array[4] = 0.0;
        array[5] = sy;
        array[6] = 0.0;
        array[7] = (1-sy) * getPivotY();
        array[8] = 0.0;
        array[9] = 0.0;
        array[10] = sz;
        array[11] = (1-sz) * getPivotZ();
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (transform instanceof Scale) {
            final Scale other = (Scale) transform;
            if (other.getPivotX() == getPivotX()
                    &amp;&amp; other.getPivotY() == getPivotY()
                    &amp;&amp; other.getPivotZ() == getPivotZ()) {
                return new Scale(
                        sx * other.getX(),
                        sy * other.getY(),
                        sz * other.getZ(),
                        getPivotX(), getPivotY(), getPivotZ());
            }
        }

        if (transform instanceof Translate) {
            final Translate t = (Translate) transform;

            final double tx = t.getX();
            final double ty = t.getY();
            final double tz = t.getZ();

            if ((tx == 0.0 || (sx != 1.0 &amp;&amp; sx != 0.0)) &amp;&amp;
                    (ty == 0.0 || (sy != 1.0 &amp;&amp; sy != 0.0)) &amp;&amp;
                    (tz == 0.0 || (sz != 1.0 &amp;&amp; sz != 0.0))) {
                return new Scale(
                        sx, sy, sz,
                        (sx != 1.0 ? sx * tx / (1 - sx) : 0) + getPivotX(),
                        (sy != 1.0 ? sy * ty / (1 - sy) : 0) + getPivotY(),
                        (sz != 1.0 ? sz * tz / (1 - sz) : 0) + getPivotZ());
            }
        }

        if (transform instanceof Affine) {
            Affine a = (Affine) transform.clone();
            a.prepend(this);
            return a;
        }

        final double txx = transform.getMxx();
        final double txy = transform.getMxy();
        final double txz = transform.getMxz();
        final double ttx = transform.getTx();
        final double tyx = transform.getMyx();
        final double tyy = transform.getMyy();
        final double tyz = transform.getMyz();
        final double tty = transform.getTy();
        final double tzx = transform.getMzx();
        final double tzy = transform.getMzy();
        final double tzz = transform.getMzz();
        final double ttz = transform.getTz();
        return new Affine(
                sx * txx, sx * txy, sx * txz, sx * ttx + (1 - sx) * getPivotX(),
                sy * tyx, sy * tyy, sy * tyz, sy * tty + (1 - sy) * getPivotY(),
                sz * tzx, sz * tzy, sz * tzz, sz * ttz + (1 - sz) * getPivotZ());
    }

    @Override
    public Scale createInverse() throws NonInvertibleTransformException {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        return new Scale(1.0 / sx, 1.0 / sy, 1.0 / sz,
                getPivotX(), getPivotY(), getPivotZ());
    }

    @Override
    public Scale clone() {
        return new Scale(getX(), getY(), getZ(),
                getPivotX(), getPivotY(), getPivotZ());
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        final double mxx = getX();
        final double myy = getY();

        return new Point2D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY());
    }

    @Override
    public Point3D transform(double x, double y, double z) {

        final double mxx = getX();
        final double myy = getY();
        final double mzz = getZ();

        return new Point3D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY(),
            mzz * z + (1 - mzz) * getPivotZ());
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getX();
        final double yy = getY();
        final double px = getPivotX();
        final double py = getPivotY();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + (1 - xx) * px;
            dstPts[dstOff++] = yy * y + (1 - yy) * py;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getX();
        final double yy = getY();
        final double zz = getZ();
        final double px = getPivotX();
        final double py = getPivotY();
        final double pz = getPivotZ();

        while (--numPts &gt;= 0) {
            dstPts[dstOff++] = xx * srcPts[srcOff++] + (1 - xx) * px;
            dstPts[dstOff++] = yy * srcPts[srcOff++] + (1 - yy) * py;
            dstPts[dstOff++] = zz * srcPts[srcOff++] + (1 - zz) * pz;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
                getX() * x,
                getY() * y);
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        return new Point3D(
                getX() * x,
                getY() * y,
                getZ() * z);
    }

    @Override
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        final double sx = getX();
        final double sy = getY();

        if (sx == 0.0 || sy == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double mxx = 1.0 / sx;
        final double myy = 1.0 / sy;

        return new Point2D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY());
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double mxx = 1.0 / sx;
        final double myy = 1.0 / sy;
        final double mzz = 1.0 / sz;

        return new Point3D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY(),
            mzz * z + (1 - mzz) * getPivotZ());
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {
        final double sx = getX();
        final double sy = getY();

        if (sx == 0.0 || sy == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double xx = 1.0 / sx;
        final double yy = 1.0 / sy;
        final double px = getPivotX();
        final double py = getPivotY();

        while (--numPts &gt;= 0) {
            dstPts[dstOff++] = xx * srcPts[srcOff++] + (1 - xx) * px;
            dstPts[dstOff++] = yy * srcPts[srcOff++] + (1 - yy) * py;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double xx = 1.0 / sx;
        final double yy = 1.0 / sy;
        final double zz = 1.0 / sz;
        final double px = getPivotX();
        final double py = getPivotY();
        final double pz = getPivotZ();

        while (--numPts &gt;= 0) {
            dstPts[dstOff++] = xx * srcPts[srcOff++] + (1 - xx) * px;
            dstPts[dstOff++] = yy * srcPts[srcOff++] + (1 - yy) * py;
            dstPts[dstOff++] = zz * srcPts[srcOff++] + (1 - zz) * pz;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        final double sx = getX();
        final double sy = getY();

        if (sx == 0.0 || sy == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        return new Point2D(
            (1.0 / sx) * x,
            (1.0 / sy) * y);
    }

    @Override
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        return new Point3D(
            (1.0 / sx) * x,
            (1.0 / sy) * y,
            (1.0 / sz) * z);
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Scale} object.
     * @return a string representation of this {@code Scale} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Scale [&quot;);

        sb.append(&quot;x=&quot;).append(getX());
        sb.append(&quot;, y=&quot;).append(getY());
        sb.append(&quot;, z=&quot;).append(getZ());
        sb.append(&quot;, pivotX=&quot;).append(getPivotX());
        sb.append(&quot;, pivotY=&quot;).append(getPivotY());
        sb.append(&quot;, pivotZ=&quot;).append(getPivotZ());

        return sb.append(&quot;]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    @Override
    void apply(final Affine3D trans) {
        if (getPivotX() != 0 || getPivotY() != 0 || getPivotZ() != 0) {
            trans.translate(getPivotX(), getPivotY(), getPivotZ());
<A NAME="21"></A>            trans.scale(getX(), getY(), getZ());
            trans.translate(-getPivotX(), -getPivotY(), -getPivotZ());
        } else {
            trans.scale(<FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#21',2,'match36-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getX(), getY(), getZ());
        }
    }

    @Override
    BaseTransform derive(BaseTransform trans) {
        if (isIdentity()) {</B></FONT>
            return trans;
        }
        if (getPivotX() != 0 || getPivotY() != 0 || getPivotZ() != 0) {
            trans = trans.deriveWithTranslation(getPivotX(), getPivotY(), getPivotZ());
            trans = trans.deriveWithScale(getX(), getY(), getZ());
            return trans.deriveWithTranslation(-getPivotX(), -getPivotY(), -getPivotZ());
        } else {
            return trans.deriveWithScale(getX(), getY(), getZ());
        }
    }
<A NAME="36"></A>
    @Override
    void validate() {
        <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#36',2,'match36-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getX(); getPivotX();
        getY(); getPivotY();
        getZ(); getPivotZ();
    }

    @Override
    void appendTo(Affine a) {
        a.appendScale(getX(), getY(), getZ(),
                getPivotX(), getPivotY(), getPivotZ());
    }

    @Override
    void prependTo(Affine a) {
        a.prependScale(getX(), getY(), getZ(),
                getPivotX(), getPivotY(), getPivotZ());
    }</B></FONT>
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/NativeMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

<A NAME="0"></A>package com.sun.media.jfxmediaimpl;

import java.lang.annotation.Native;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#0',2,'match36-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.media.jfxmedia.Media;
import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmedia.MediaException;
import com.sun.media.jfxmedia.MediaPlayer;
import com.sun.media.jfxmedia.control.VideoRenderControl;
import com.sun.media.jfxmedia.effects.AudioEqualizer;
import com.sun.media.jfxmedia.effects.AudioSpectrum;
import com.sun.media.jfxmedia.events.AudioSpectrumEvent;
import com.sun.media.jfxmedia.events.AudioSpectrumListener;
import com.sun.media.jfxmedia.events.BufferListener;
import com.sun.media.jfxmedia.events.BufferProgressEvent;
import com.sun.media.jfxmedia.events.MarkerEvent;
import com.sun.media.jfxmedia.events.MarkerListener;
import com.sun.media.jfxmedia.events.MediaErrorListener;
import com.sun.media.jfxmedia.events.NewFrameEvent;
import com.sun.media.jfxmedia.events.PlayerEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent.PlayerState;
import com.sun.media.jfxmedia.events.PlayerStateListener;
import com.sun.media.jfxmedia.events.PlayerTimeListener;
import com.sun.media.jfxmedia.events.VideoFrameRateListener;
import com.sun.media.jfxmedia.events.VideoRendererListener;
import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
import com.sun.media.jfxmedia.logging.Logger;
import com.sun.media.jfxmedia.track.AudioTrack;
import com.sun.media.jfxmedia.track.SubtitleTrack;
import com.sun.media.jfxmedia.track.Track;
import com.sun.media.jfxmedia.track.Track.Encoding;
import com.sun.media.jfxmedia.track.VideoResolution;
import com.sun.media.jfxmedia.track.VideoTrack;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Base implementation of a
 * &lt;code&gt;MediaPlayer&lt;/code&gt;.
 */
public abstract class NativeMediaPlayer implements MediaPlayer, MarkerStateListener {
    //***** Event IDs for PlayerStateEvent.  IDs sent from native JNI layer.

    @Native public final static int eventPlayerUnknown = 100;
    @Native public final static int eventPlayerReady = 101;
    @Native public final static int eventPlayerPlaying = 102;
    @Native public final static int eventPlayerPaused = 103;
    @Native public final static int eventPlayerStopped = 104;
    @Native public final static int eventPlayerStalled = 105;
    @Native public final static int eventPlayerFinished = 106</B></FONT>;
    @Native public final static int eventPlayerError = 107;
    // Nominal video frames per second.
    @Native private static final int NOMINAL_VIDEO_FPS = 30;
    // Nanoseconds per second.
    @Native public static final long ONE_SECOND = 1000000000L;

    /**
     * The
     * &lt;code&gt;Media&lt;/code&gt; corresponding to the media source.
     */
    private NativeMedia media;
    private VideoRenderControl videoRenderControl;
    private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerStateListener&gt;&gt; playerStateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; playerTimeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; videoTrackSizeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoRendererListener&gt;&gt; videoUpdateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; videoFrameRateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;MarkerListener&gt;&gt; markerListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;BufferListener&gt;&gt; bufferListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; audioSpectrumListeners = new ArrayList&lt;&gt;();
    private final List&lt;PlayerStateEvent&gt; cachedStateEvents = new ArrayList&lt;&gt;();
    private final List&lt;PlayerTimeEvent&gt; cachedTimeEvents = new ArrayList&lt;&gt;();
    private final List&lt;BufferProgressEvent&gt; cachedBufferEvents = new ArrayList&lt;&gt;();
    private final List&lt;MediaErrorEvent&gt; cachedErrorEvents = new ArrayList&lt;&gt;();
    private boolean isFirstFrame = true;
    private NewFrameEvent firstFrameEvent = null;
    private double firstFrameTime;
    private final Object firstFrameLock = new Object();
    private EventQueueThread eventLoop = new EventQueueThread();
    private int frameWidth = -1;
    private int frameHeight = -1;
    private final AtomicBoolean isMediaPulseEnabled = new AtomicBoolean(false);
    private final Lock mediaPulseLock = new ReentrantLock();
    private Timer mediaPulseTimer;
    private final Lock markerLock = new ReentrantLock();
    private boolean checkSeek = false;
    private double timeBeforeSeek = 0.0;
    private double timeAfterSeek = 0.0;
    private double previousTime = 0.0;
    private double firedMarkerTime = -1.0;
    private double startTime = 0.0;
    private double stopTime = Double.POSITIVE_INFINITY;
    private boolean isStartTimeUpdated = false;
    private boolean isStopTimeSet = false;

    // --- Begin decoded frame rate fields
    private double encodedFrameRate = 0.0;
    private boolean recomputeFrameRate = true;
    private double previousFrameTime;
    private long numFramesSincePlaying;
    private double meanFrameDuration;
    private double decodedFrameRate;
    // --- End decoded frame rate fields
    private PlayerState playerState = PlayerState.UNKNOWN;
    private final Lock disposeLock = new ReentrantLock();
    private boolean isDisposed = false;
    private Runnable onDispose;

    //**************************************************************************
    //***** Constructors
    //**************************************************************************
    /**
     * Construct a NativeMediaPlayer for the referenced clip.
     *
     * @param clip Media object
     * @throws IllegalArgumentException if
     * &lt;code&gt;clip&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    protected NativeMediaPlayer(NativeMedia clip) {
        if (clip == null) {
            throw new IllegalArgumentException(&quot;clip == null!&quot;);
        }
        media = clip;
        videoRenderControl = new VideoRenderer();
    }

    /**
     * Initialization method which must be called after construction to
     * initialize the internal state of the player. This method should be
     * invoked directly after the player is constructed.
     */
    protected void init() {
        media.addMarkerStateListener(this);
        eventLoop.start();
    }

    /**
     * Set a callback to invoke when the player is disposed.
     *
     * @param onDispose object on which to invoke {@link Runnable#run()} in
     * {@link #dispose()}.
     */
    void setOnDispose(Runnable onDispose) {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                this.onDispose = onDispose;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    /**
     * Event to be posted to any registered {@link MediaErrorListener}s.
     */
    private static class WarningEvent extends PlayerEvent {

        private final Object source;
        private final String message;

        WarningEvent(Object source, String message) {
            this.source = source;
            this.message = message;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return message;
        }
    }

    /**
     * Event to be posted to any registered (@link MediaErrorListener)s
     */
    public static class MediaErrorEvent extends PlayerEvent {

        private final Object source;
        private final MediaError error;

        public MediaErrorEvent(Object source, MediaError error) {
            this.source = source;
            this.error = error;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return error.description();
        }

        public int getErrorCode() {
            return error.code();
        }
    }

    private static class PlayerTimeEvent extends PlayerEvent {

        private final double time;

        public PlayerTimeEvent(double time) {
            this.time = time;
        }

        public double getTime() {
            return time;
        }
    }

    /**
     * Event to be posted to any registered {@link PlayerStateListener}s.
     */
    private static class TrackEvent extends PlayerEvent {

        private final Track track;

        TrackEvent(Track track) {
            this.track = track;
        }

        public Track getTrack() {
            return this.track;
        }
    }

    /**
     * Event to be posted to any registered {@link VideoTrackSizeListener}s.
     */
    private static class FrameSizeChangedEvent extends PlayerEvent {

        private final int width;
        private final int height;

        public FrameSizeChangedEvent(int width, int height) {
            if (width &gt; 0) {
                this.width = width;
            } else {
                this.width = 0;
            }

            if (height &gt; 0) {
                this.height = height;
            } else {
                this.height = 0;
            }
        }

        public int getWidth() {
            return width;
        }

        public int getHeight() {
            return height;
        }
    }

    /**
     * Helper class which managers {@link VideoRendererListener}s. This allows
     * any registered listeners, specifically AWT and Prism, to receive video
     * frames.
     */
    private class VideoRenderer implements VideoRenderControl {

        /**
         * adds the listener to the player's videoUpdate. The listener will be
         * called whenever a new frame of video is ready to be painted or
         * fetched by getData()
         *
         * @param listener the object which provides the VideoUpdateListener
         * callback interface
         */
        @Override
        public void addVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                synchronized (firstFrameLock) {
                    // If the first frame is cached, post it to the listener
                    // directly. The lock is obtained first so the cached
                    // frame is not cleared between the non-null test and
                    // posting the event.
                    if (firstFrameEvent != null) {
                        listener.videoFrameUpdated(firstFrameEvent);
                    }
                }
                videoUpdateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        /**
         * removes the listener from the player.
         *
         * @param listener to be removed from the player
         */
        @Override
        public void removeVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                    VideoRendererListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public void addVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                videoFrameRateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        @Override
        public void removeVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                    VideoFrameRateListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public int getFrameWidth() {
            return frameWidth;
        }

        @Override
        public int getFrameHeight() {
            return frameHeight;
        }
    }

    //***** EventQueueThread Helper Class -- Provides event handling.
    /**
     * Thread for media player event processing. The thread maintains an
     * internal queue of
     * &lt;code&gt;PlayerEvent&lt;/code&gt;s to which callers post using
     * &lt;code&gt;postEvent()&lt;/code&gt;. The thread blocks until an event becomes
     * available on the queue, and then removes the event from the queue and
     * posts it to any registered listeners appropriate to the type of event.
     */
    private class EventQueueThread extends Thread {

        private final BlockingQueue&lt;PlayerEvent&gt; eventQueue =
                new LinkedBlockingQueue&lt;&gt;();
        private volatile boolean stopped = false;

        EventQueueThread() {
            setName(&quot;JFXMedia Player EventQueueThread&quot;);
            setDaemon(true);
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    // trying to take an event from the queue.
                    // this method will block until an event becomes available.
                    PlayerEvent evt = eventQueue.take();

                    if (!stopped) {
                        if (evt instanceof NewFrameEvent) {
                            try {
                                HandleRendererEvents((NewFrameEvent) evt);
                            } catch (Throwable t) {
                                if (Logger.canLog(Logger.ERROR)) {
                                    Logger.logMsg(Logger.ERROR, &quot;Caught exception in HandleRendererEvents: &quot; + t.toString());
                                }
                            }
                        } else if (evt instanceof PlayerStateEvent) {
                            HandleStateEvents((PlayerStateEvent) evt);
                        } else if (evt instanceof FrameSizeChangedEvent) {
                            HandleFrameSizeChangedEvents((FrameSizeChangedEvent) evt);
                        } else if (evt instanceof TrackEvent) {
                            HandleTrackEvents((TrackEvent) evt);
                        } else if (evt instanceof MarkerEvent) {
                            HandleMarkerEvents((MarkerEvent) evt);
                        } else if (evt instanceof WarningEvent) {
                            HandleWarningEvents((WarningEvent) evt);
                        } else if (evt instanceof PlayerTimeEvent) {
                            HandlePlayerTimeEvents((PlayerTimeEvent) evt);
                        } else if (evt instanceof BufferProgressEvent) {
                            HandleBufferEvents((BufferProgressEvent) evt);
                        } else if (evt instanceof AudioSpectrumEvent) {
                            HandleAudioSpectrumEvents((AudioSpectrumEvent) evt);
                        } else if (evt instanceof MediaErrorEvent) {
                            HandleErrorEvents((MediaErrorEvent) evt);
                        }
                    }
                } catch (Exception e) {
                    // eventQueue.take() can throw InterruptedException,
                    // also in rare case it can throw wrong
                    // IllegalMonitorStateException
                    // so we catch Exception
                    // nothing to do, restart the loop unless it was properly stopped.
                }
            }

            eventQueue.clear();
        }

        private void HandleRendererEvents(NewFrameEvent evt) {
            if (isFirstFrame) {
                // Cache first frame. Frames are delivered time-sequentially
                // so there should be no thread contention problem here.
                isFirstFrame = false;
                synchronized (firstFrameLock) {
                    firstFrameEvent = evt;
                    firstFrameTime = firstFrameEvent.getFrameData().getTimestamp();
                    firstFrameEvent.getFrameData().holdFrame(); // hold as long as we cache it, else we'll crash
                }
            } else if (firstFrameEvent != null
                    &amp;&amp; firstFrameTime != evt.getFrameData().getTimestamp()) {
                // If this branch is entered then it cannot be the first frame.
                // This means that the player must be in the PLAYING state as
                // the first frame will arrive upon completion of prerolling.
                // When playing, listeners should receive the current frame,
                // not the first frame in the stream.

                // Clear the cached first frame. Obtain the lock first to avoid
                // a race condition with a listener newly being added.
                synchronized (firstFrameLock) {
                    firstFrameEvent.getFrameData().releaseFrame();
                    firstFrameEvent = null;
                }
            }

            // notify videoUpdateListeners
            for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                VideoRendererListener l = it.next().get();
                if (l != null) {
                    l.videoFrameUpdated(evt);
                } else {
                    it.remove();
                }
            }
            // done with the frame, we can release our hold now
            evt.getFrameData().releaseFrame();

            if (!videoFrameRateListeners.isEmpty()) {
                // Decoded frame rate calculations.
                double currentFrameTime = System.nanoTime() / (double) ONE_SECOND;

                if (recomputeFrameRate) {
                    // First frame in new computation sequence.
                    recomputeFrameRate = false;
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying = 1;
                } else {
                    boolean fireFrameRateEvent = false;

                    if (numFramesSincePlaying == 1) {
                        // Second frame. Estimate the initial frame rate and
                        // set event flag.
                        meanFrameDuration = currentFrameTime - previousFrameTime;
                        if (meanFrameDuration &gt; 0.0) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    } else {
                        // Update decoded frame rate estimate using a moving
                        // average over encodedFrameRate frames.
                        double previousMeanFrameDuration = meanFrameDuration;

                        // Determine moving average length.
                        int movingAverageLength = encodedFrameRate != 0.0
                                ? ((int) (encodedFrameRate + 0.5)) : NOMINAL_VIDEO_FPS;

                        // Claculate number of frames in current average.
                        long numFrames = numFramesSincePlaying &lt; movingAverageLength
                                ? numFramesSincePlaying : movingAverageLength;

                        // Update the mean frame duration.
                        meanFrameDuration = ((numFrames - 1) * previousMeanFrameDuration
                                + currentFrameTime - previousFrameTime) / numFrames;

                        // If mean frame duration changed by more than 0.5 set
                        // event flag.
                        if (meanFrameDuration &gt; 0.0
                                &amp;&amp; Math.abs(decodedFrameRate - 1.0 / meanFrameDuration) &gt; 0.5) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    }

                    if (fireFrameRateEvent) {
                        // Fire event.
                        for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                            VideoFrameRateListener l = it.next().get();
                            if (l != null) {
                                l.onFrameRateChanged(decodedFrameRate);
                            } else {
                                it.remove();
                            }
                        }
                    }

                    // Update running values.
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying++;
                }
            }
        }

        private void HandleStateEvents(PlayerStateEvent evt) {
            playerState = evt.getState();

            recomputeFrameRate = PlayerState.PLAYING == evt.getState();

            switch (playerState) {
                case READY:
                    onNativeInit();
                    sendFakeBufferProgressEvent();
                    break;
                case PLAYING:
                    isMediaPulseEnabled.set(true);
                    break;
                case STOPPED:
                case FINISHED:
                    // Force a time update here to catch the time going to
                    // zero for STOPPED and any trailing markers for FINISHED.
                    doMediaPulseTask();
                case PAUSED:
                case STALLED:
                case HALTED:
                    isMediaPulseEnabled.set(false);
                    break;
                default:
                    break;
            }

            synchronized (cachedStateEvents) {
                if (playerStateListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedStateEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener listener = it.next().get();
                if (listener != null) {
                    switch (playerState) {
                        case READY:
                            onNativeInit();
                            sendFakeBufferProgressEvent();
                            listener.onReady(evt);
                            break;

                        case PLAYING:
                            listener.onPlaying(evt);
                            break;

                        case PAUSED:
                            listener.onPause(evt);
                            break;

                        case STOPPED:
                            listener.onStop(evt);
                            break;

                        case STALLED:
                            listener.onStall(evt);
                            break;

                        case FINISHED:
                            listener.onFinish(evt);
                            break;

                        case HALTED:
                            listener.onHalt(evt);
                            break;

                        default:
                            break;
                    }
                } else {
                    it.remove();
                }
            }
        }

        private void HandlePlayerTimeEvents(PlayerTimeEvent evt) {
            synchronized (cachedTimeEvents) {
                if (playerTimeListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedTimeEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener listener = it.next().get();
                if (listener != null) {
                    listener.onDurationChanged(evt.getTime());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleFrameSizeChangedEvents(FrameSizeChangedEvent evt) {
            frameWidth = evt.getWidth();
            frameHeight = evt.getHeight();
            Logger.logMsg(Logger.DEBUG, &quot;** Frame size changed (&quot; + frameWidth + &quot;, &quot; + frameHeight + &quot;)&quot;);
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener listener = it.next().get();
                if (listener != null) {
                    listener.onSizeChanged(frameWidth, frameHeight);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleTrackEvents(TrackEvent evt) {
            media.addTrack(evt.getTrack());

            if (evt.getTrack() instanceof VideoTrack) {
                encodedFrameRate = ((VideoTrack) evt.getTrack()).getEncodedFrameRate();
            }
        }

        private void HandleMarkerEvents(MarkerEvent evt) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener listener = it.next().get();
                if (listener != null) {
                    listener.onMarker(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleWarningEvents(WarningEvent evt) {
            Logger.logMsg(Logger.WARNING, evt.getSource() + evt.getMessage());
        }

        private void HandleErrorEvents(MediaErrorEvent evt) {
            Logger.logMsg(Logger.ERROR, evt.getMessage());

            synchronized (cachedErrorEvents) {
                if (errorListeners.isEmpty()) {
                    // cache error events until at least one listener is added
                    cachedErrorEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l != null) {
                    l.onError(evt.getSource(), evt.getErrorCode(), evt.getMessage());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleBufferEvents(BufferProgressEvent evt) {
            synchronized (cachedBufferEvents) {
                if (bufferListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedBufferEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener listener = it.next().get();
                if (listener != null) {
                    listener.onBufferProgress(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleAudioSpectrumEvents(AudioSpectrumEvent evt) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener listener = it.next().get();
                if (listener != null) {
                    listener.onAudioSpectrumEvent(evt);
                } else {
                    it.remove();
                }
            }
        }

        /**
         * Puts an event to the EventQuery.
         */
        public void postEvent(PlayerEvent event) {
            if (eventQueue != null) {
                eventQueue.offer(event);
            }
        }

        /**
         * Signals the thread to terminate.
         */
        public void terminateLoop() {
            stopped = true;
            // put an event to unblock eventQueue.take()
            try {
                eventQueue.put(new PlayerEvent());
            } catch(InterruptedException ex) {}
        }

        private void sendFakeBufferProgressEvent() {
            // Send fake 100% buffer progress event for HLS or !http protcol
            String contentType = media.getLocator().getContentType();
            String protocol = media.getLocator().getProtocol();
            if ((contentType != null &amp;&amp; (contentType.equals(MediaUtils.CONTENT_TYPE_M3U) || contentType.equals(MediaUtils.CONTENT_TYPE_M3U8)))
                    || (protocol != null &amp;&amp; !protocol.equals(&quot;http&quot;) &amp;&amp; !protocol.equals(&quot;https&quot;))) {
                HandleBufferEvents(new BufferProgressEvent(getDuration(), 0, 1, 1));
            }
        }
    }

    /**
     * Internal function to get called when the native player is ready.
     */
    private synchronized void onNativeInit() {
        try {
            playerInit();
        } catch (MediaException me) {
            sendPlayerMediaErrorEvent(me.getMediaError().code());
        }
    }

    //**************************************************************************
    //***** MediaPlayer implementation
    //**************************************************************************
    //***** Listener (un)registration.
    @Override
    public void addMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            this.errorListeners.add(new WeakReference&lt;&gt;(listener));

            synchronized (cachedErrorEvents) {
                if (!cachedErrorEvents.isEmpty() &amp;&amp; !errorListeners.isEmpty()) {
                    cachedErrorEvents.stream().forEach((evt) -&gt; {
                        sendPlayerEvent(evt);
                    });
                    cachedErrorEvents.clear();
                }
            }
        }
    }

    @Override
    public void removeMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            synchronized (cachedStateEvents) {
                if (!cachedStateEvents.isEmpty() &amp;&amp; playerStateListeners.isEmpty()) {
                    // Forward all cached state events to first listener to register.
                    Iterator&lt;PlayerStateEvent&gt; events = cachedStateEvents.iterator();
                    while (events.hasNext()) {
                        PlayerStateEvent evt = events.next();
                        switch (evt.getState()) {
                            case READY:
                                listener.onReady(evt);
                                break;
                            case PLAYING:
                                listener.onPlaying(evt);
                                break;
                            case PAUSED:
                                listener.onPause(evt);
                                break;
                            case STOPPED:
                                listener.onStop(evt);
                                break;
                            case STALLED:
                                listener.onStall(evt);
                                break;
                            case FINISHED:
                                listener.onFinish(evt);
                                break;
                            case HALTED:
                                listener.onHalt(evt);
                                break;
                            default:
                                break;
                        }
                    }

                    // Clear state event cache.
                    cachedStateEvents.clear();
                }

                playerStateListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            synchronized (cachedTimeEvents) {
                if (!cachedTimeEvents.isEmpty() &amp;&amp; playerTimeListeners.isEmpty()) {
                    // Forward all cached time events to first listener to register.
                    Iterator&lt;PlayerTimeEvent&gt; events = cachedTimeEvents.iterator();
                    while (events.hasNext()) {
                        PlayerTimeEvent evt = events.next();
                        listener.onDurationChanged(evt.getTime());
                    }

                    // Clear time event cache.
                    cachedTimeEvents.clear();
                } else {
                    // Let listener to know about duration
                    double duration = getDuration();
                    if (duration != Double.POSITIVE_INFINITY) {
                        listener.onDurationChanged(duration);
                    }
                }

                playerTimeListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            if (frameWidth != -1 &amp;&amp; frameHeight != -1) {
                listener.onSizeChanged(frameWidth, frameHeight);
            }
            videoTrackSizeListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMarkerListener(MarkerListener listener) {
        if (listener != null) {
            markerListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeMarkerListener(MarkerListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addBufferListener(BufferListener listener) {
        if (listener != null) {
            synchronized (cachedBufferEvents) {
                if (!cachedBufferEvents.isEmpty() &amp;&amp; bufferListeners.isEmpty()) {
                    cachedBufferEvents.stream().forEach((evt) -&gt; {
                        listener.onBufferProgress(evt);
                    });
                    // Clear buffer event cache.
                    cachedBufferEvents.clear();
                }

                bufferListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeBufferListener(BufferListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            audioSpectrumListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    //***** Control functions
    @Override
    public VideoRenderControl getVideoRenderControl() {
        return videoRenderControl;
    }

    @Override
    public Media getMedia() {
        return media;
    }

    @Override
    public void setAudioSyncDelay(long delay) {
        try {
            playerSetAudioSyncDelay(delay);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public long getAudioSyncDelay() {
        try {
            return playerGetAudioSyncDelay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void play() {
        try {
            if (isStartTimeUpdated) {
                playerSeek(startTime);
            }
            isMediaPulseEnabled.set(true);
            playerPlay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public void stop() {
        try {
            playerStop();
            playerSeek(startTime);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;stop() failed!&quot;);
        }
    }

    @Override
    public void pause() {
        try {
            playerPause();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getRate() {
        try {
            return playerGetRate();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    //***** Public properties
    @Override
    public void setRate(float rate) {
        try {
            playerSetRate(rate);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;setRate(&quot; + rate + &quot;) failed!&quot;);
        }
    }

    @Override
    public double getPresentationTime() {
        try {
            return playerGetPresentationTime();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return -1.0;
    }

    @Override
    public float getVolume() {
        try {
            return playerGetVolume();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setVolume(float vol) {
        if (vol &lt; 0.0F) {
            vol = 0.0F;
        } else if (vol &gt; 1.0F) {
            vol = 1.0F;
        }

        try {
            playerSetVolume(vol);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public boolean getMute() {
        try {
            return playerGetMute();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return false;
    }

    /**
     * Enables/disable mute. If mute is enabled then disabled, the previous
     * volume goes into effect.
     */
    @Override
    public void setMute(boolean enable) {
        try {
            playerSetMute(enable);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getBalance() {
        try {
            return playerGetBalance();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setBalance(float bal) {
        if (bal &lt; -1.0F) {
            bal = -1.0F;
        } else if (bal &gt; 1.0F) {
            bal = 1.0F;
        }

        try {
            playerSetBalance(bal);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public abstract AudioEqualizer getEqualizer();

    @Override
    public abstract AudioSpectrum getAudioSpectrum();

    @Override
    public double getDuration() {
        try {
            return playerGetDuration();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return Double.POSITIVE_INFINITY;
    }

    /**
     * Gets the time within the duration of the media to start playing.
     */
    @Override
    public double getStartTime() {
        return startTime;
    }

    /**
     * Sets the start time within the media to play.
     */
    @Override
    public void setStartTime(double startTime) {
        try {
            markerLock.lock();
            this.startTime = startTime;
            if (playerState != PlayerState.PLAYING &amp;&amp; playerState != PlayerState.FINISHED &amp;&amp; playerState != PlayerState.STOPPED) {
                playerSeek(startTime);
            } else if (playerState == PlayerState.STOPPED) {
                isStartTimeUpdated = true;
            }
        } finally {
            markerLock.unlock();
        }
    }

    /**
     * Gets the time within the duration of the media to stop playing.
     */
    @Override
    public double getStopTime() {
        return stopTime;
    }

    /**
     * Sets the stop time within the media to stop playback.
     */
    @Override
    public void setStopTime(double stopTime) {
        try {
            markerLock.lock();
            this.stopTime = stopTime;
            isStopTimeSet = true;
            createMediaPulse();
        } finally {
            markerLock.unlock();
        }
    }

    @Override
    public void seek(double streamTime) {
        if (playerState == PlayerState.STOPPED) {
            return; // No seek in stopped state
        }

        if (streamTime &lt; 0.0) {
            streamTime = 0.0;
        } else {
            double duration = getDuration();
            if (duration &gt;= 0.0 &amp;&amp; streamTime &gt; duration) {
                streamTime = duration;
            }
        }

        if (!isMediaPulseEnabled.get()) {
            if ((playerState == PlayerState.PLAYING
                    || playerState == PlayerState.PAUSED
                    || playerState == PlayerState.FINISHED)
                    &amp;&amp; getStartTime() &lt;= streamTime &amp;&amp; streamTime &lt;= getStopTime()) {
                isMediaPulseEnabled.set(true);
            }
        }

        markerLock.lock();
        try {
            timeBeforeSeek = getPresentationTime();
            timeAfterSeek = streamTime;
            checkSeek = timeBeforeSeek != timeAfterSeek;
            previousTime = streamTime;
            firedMarkerTime = -1.0;
//            System.out.println(&quot;seek @ &quot;+System.currentTimeMillis());
//            System.out.println(&quot;seek to &quot;+streamTime+&quot; previousTime &quot;+previousTime);

            try {
                playerSeek(streamTime);
            } catch (MediaException me) {
                //sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
                MediaUtils.warning(this, &quot;seek(&quot; + streamTime + &quot;) failed!&quot;);
            }
        } finally {
            markerLock.unlock();
        }
    }

    protected abstract long playerGetAudioSyncDelay() throws MediaException;

    protected abstract void playerSetAudioSyncDelay(long delay) throws MediaException;

    protected abstract void playerPlay() throws MediaException;

    protected abstract void playerStop() throws MediaException;

    protected abstract void playerPause() throws MediaException;

    protected abstract void playerFinish() throws MediaException;

    protected abstract float playerGetRate() throws MediaException;

    protected abstract void playerSetRate(float rate) throws MediaException;

    protected abstract double playerGetPresentationTime() throws MediaException;

    protected abstract boolean playerGetMute() throws MediaException;

    protected abstract void playerSetMute(boolean state) throws MediaException;

    protected abstract float playerGetVolume() throws MediaException;

    protected abstract void playerSetVolume(float volume) throws MediaException;

    protected abstract float playerGetBalance() throws MediaException;

    protected abstract void playerSetBalance(float balance) throws MediaException;

    protected abstract double playerGetDuration() throws MediaException;

    protected abstract void playerSeek(double streamTime) throws MediaException;

    protected abstract void playerInit() throws MediaException;

    protected abstract void playerDispose();

    /**
     * Retrieves the current {@link PlayerState state} of the player.
     *
     * @return the current player state.
     */
    @Override
    public PlayerState getState() {
        return playerState;
    }

    @Override
    final public void dispose() {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                // Terminate event firing
                destroyMediaPulse();

                if (eventLoop != null) {
                    eventLoop.terminateLoop();
                    eventLoop = null;
                }

                synchronized (firstFrameLock) {
                    if (firstFrameEvent != null) {
                        firstFrameEvent.getFrameData().releaseFrame();
                        firstFrameEvent = null;
                    }
                }

                // Terminate native layer
                playerDispose();

                // Dispose media object and clear reference
                if (media != null) {
                    media.dispose();
                    media = null;
                }

                if (videoUpdateListeners != null) {
                    for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                        VideoRendererListener l = it.next().get();
                        if (l != null) {
                            l.releaseVideoFrames();
                        } else {
                            it.remove();
                        }
                    }

                    videoUpdateListeners.clear();
                }

                if (playerStateListeners != null) {
                    playerStateListeners.clear();
                }

                if (videoTrackSizeListeners != null) {
                    videoTrackSizeListeners.clear();
                }

                if (videoFrameRateListeners != null) {
                    videoFrameRateListeners.clear();
                }

                if (cachedStateEvents != null) {
                    cachedStateEvents.clear();
                }

                if (cachedTimeEvents != null) {
                    cachedTimeEvents.clear();
                }

                if (cachedBufferEvents != null) {
                    cachedBufferEvents.clear();
                }

                if (errorListeners != null) {
                    errorListeners.clear();
                }

                if (playerTimeListeners != null) {
                    playerTimeListeners.clear();
                }

                if (markerListeners != null) {
                    markerListeners.clear();
                }

                if (bufferListeners != null) {
                    bufferListeners.clear();
                }

                if (audioSpectrumListeners != null) {
                    audioSpectrumListeners.clear();
                }

                if (videoRenderControl != null) {
                    videoRenderControl = null;
                }

                if (onDispose != null) {
                    onDispose.run();
                }

                isDisposed = true;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    //**************************************************************************
    //***** Non-JNI methods called by the native layer. These methods are called
    //***** from the native layer via the invocation API. Their purpose is to
    //***** dispatch certain events to the Java layer. Each of these methods
    //***** posts an event on the &lt;code&gt;EventQueueThread&lt;/code&gt; which in turn
    //***** forwards the event to any registered listeners.
    //**************************************************************************
    protected void sendWarning(int warningCode, String warningMessage) {
        if (eventLoop != null) {
            String message = String.format(MediaUtils.NATIVE_MEDIA_WARNING_FORMAT,
                    warningCode);
            if (warningMessage != null) {
                message += &quot;: &quot; + warningMessage;
            }
            eventLoop.postEvent(new WarningEvent(this, message));
        }
    }

    protected void sendPlayerEvent(PlayerEvent evt) {
        if (eventLoop != null) {
            eventLoop.postEvent(evt);
        }
    }

    protected void sendPlayerHaltEvent(String message, double time) {
        // Log the error.  Since these are most likely playback engine message (e.g. GStreamer or PacketVideo),
        // it makes no sense to propogate it above.
        Logger.logMsg(Logger.ERROR, message);

        if (eventLoop != null) {
            eventLoop.postEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.HALTED, time, message));
        }
    }

    protected void sendPlayerMediaErrorEvent(int errorCode) {
        sendPlayerEvent(new MediaErrorEvent(this, MediaError.getFromCode(errorCode)));
    }

    protected void sendPlayerStateEvent(int eventID, double time) {
        switch (eventID) {
            case eventPlayerReady:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.READY, time));
                break;
            case eventPlayerPlaying:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PLAYING, time));
                break;
            case eventPlayerPaused:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PAUSED, time));
                break;
            case eventPlayerStopped:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STOPPED, time));
                break;
            case eventPlayerStalled:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STALLED, time));
                break;
            case eventPlayerFinished:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.FINISHED, time));
                break;
            default:
                break;
        }
    }

    protected void sendNewFrameEvent(long nativeRef) {
        NativeVideoBuffer newFrameData = NativeVideoBuffer.createVideoBuffer(nativeRef);
        // createVideoBuffer puts a hold on the frame
        // we need to keep that hold until the event thread can process this event
        sendPlayerEvent(new NewFrameEvent(newFrameData));
    }

    protected void sendFrameSizeChangedEvent(int width, int height) {
        sendPlayerEvent(new FrameSizeChangedEvent(width, height));
    }

    protected void sendAudioTrack(boolean enabled, long trackID, String name, int encoding,
            String language, int numChannels,
            int channelMask, float sampleRate) {
        Locale locale = null;
        if (!language.equals(&quot;und&quot;)) {
            locale = new Locale(language);
        }

        Track track = new AudioTrack(enabled, trackID, name,
                locale, Encoding.toEncoding(encoding),
                numChannels, channelMask, sampleRate);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendVideoTrack(boolean enabled, long trackID, String name, int encoding,
            int width, int height, float frameRate,
            boolean hasAlphaChannel) {
        // No locale (currently) for video, so pass null
        Track track = new VideoTrack(enabled, trackID, name, null,
                Encoding.toEncoding(encoding),
                new VideoResolution(width, height), frameRate, hasAlphaChannel);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendSubtitleTrack(boolean enabled, long trackID, String name,
            int encoding, String language)
    {
        Locale locale = null;
        if (null != language) {
            locale = new Locale(language);
        }
        Track track = new SubtitleTrack(enabled, trackID, name, locale,
                Encoding.toEncoding(encoding));

        sendPlayerEvent(new TrackEvent(track));
    }

    protected void sendMarkerEvent(String name, double time) {
        sendPlayerEvent(new MarkerEvent(name, time));
    }

    protected void sendDurationUpdateEvent(double duration) {
        sendPlayerEvent(new PlayerTimeEvent(duration));
    }

    protected void sendBufferProgressEvent(double clipDuration, long bufferStart, long bufferStop, long bufferPosition) {
        sendPlayerEvent(new BufferProgressEvent(clipDuration, bufferStart, bufferStop, bufferPosition));
    }

    protected void sendAudioSpectrumEvent(double timestamp, double duration) {
        sendPlayerEvent(new AudioSpectrumEvent(getAudioSpectrum(), timestamp, duration));
    }

    @Override
    public void markerStateChanged(boolean hasMarkers) {
        if (hasMarkers) {
            markerLock.lock();
            try {
                previousTime = getPresentationTime();
            } finally {
                markerLock.unlock();
            }
            createMediaPulse();
        } else {
            if (!isStopTimeSet) {
                destroyMediaPulse();
            }
        }
    }

    private void createMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer == null) {
                mediaPulseTimer = new Timer(true);
                mediaPulseTimer.scheduleAtFixedRate(new MediaPulseTask(this), 0, 40 /*
                         * period ms
                         */);
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    private void destroyMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer != null) {
                mediaPulseTimer.cancel();
                mediaPulseTimer = null;
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    boolean doMediaPulseTask() {
        if (this.isMediaPulseEnabled.get()) {
            disposeLock.lock();

            if (isDisposed) {
                disposeLock.unlock();
                return false;
            }

            double thisTime = getPresentationTime();

            markerLock.lock();

            try {
                //System.out.println(&quot;Media pulse @ pts &quot;+thisTime+&quot; previous &quot;+previousTime);

                if (checkSeek) {
                    if (timeAfterSeek &gt; timeBeforeSeek) {
                        // Forward seek
                        if (thisTime &gt;= timeAfterSeek) {
//                        System.out.println(&quot;bail 1&quot;);
                            checkSeek = false;
                        } else {
                            return true;
                        }
                    } else if (timeAfterSeek &lt; timeBeforeSeek) {
                        // Backward seek
                        if (thisTime &gt;= timeBeforeSeek) {
//                        System.out.println(&quot;bail 2&quot;);
                            return true;
                        } else {
                            checkSeek = false;
                        }
                    }
                }

                Map.Entry&lt;Double, String&gt; marker = media.getNextMarker(previousTime, true);
//                System.out.println(&quot;marker &quot;+marker);
//                System.out.println(&quot;Checking: &quot; + previousTime + &quot; &quot; + thisTime + &quot; &quot;
//                        + getStartTime() + &quot; &quot; + getStopTime() + &quot; &quot;
//                        + marker.getKey());

                while (marker != null) {
                    double nextMarkerTime = marker.getKey();
                    if (nextMarkerTime &gt; thisTime) {
                        break;
                    } else if (nextMarkerTime != firedMarkerTime
                            &amp;&amp; nextMarkerTime &gt;= previousTime
                            &amp;&amp; nextMarkerTime &gt;= getStartTime()
                            &amp;&amp; nextMarkerTime &lt;= getStopTime()) {
//                            System.out.println(&quot;Firing: &quot;+previousTime+&quot; &quot;+thisTime+&quot; &quot;+
//                                    getStartTime()+&quot; &quot;+getStopTime()+&quot; &quot;+
//                                    nextMarkerTime);
                        MarkerEvent evt = new MarkerEvent(marker.getValue(), nextMarkerTime);
                        for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                            MarkerListener listener = it.next().get();
                            if (listener != null) {
                                listener.onMarker(evt);
                            } else {
                                it.remove();
                            }
                        }
                        firedMarkerTime = nextMarkerTime;
                    }
                    marker = media.getNextMarker(nextMarkerTime, false);
                }

                previousTime = thisTime;

                // Do stopTime
                if (isStopTimeSet &amp;&amp; thisTime &gt;= stopTime) {
                    playerFinish();
                }
            } finally {
                disposeLock.unlock();
                markerLock.unlock();
            }
        }

        return true;
    }

    /* Audio EQ and spectrum creation, used by sub-classes */
    protected AudioEqualizer createNativeAudioEqualizer(long nativeRef) {
        return new NativeAudioEqualizer(nativeRef);
    }

    protected AudioSpectrum createNativeAudioSpectrum(long nativeRef) {
        return new NativeAudioSpectrum(nativeRef);
    }
}

class MediaPulseTask extends TimerTask {

    WeakReference&lt;NativeMediaPlayer&gt; playerRef;

    MediaPulseTask(NativeMediaPlayer player) {
        playerRef = new WeakReference&lt;&gt;(player);
    }

    @Override
    public void run() {
        final NativeMediaPlayer player = playerRef.get();
        if (player != null) {
            if (!player.doMediaPulseTask()) {
                cancel(); // Stop if doMediaPulseTask() returns false. False means doMediaPulseTask() cannot continue (like after dispose).cy
            }
        } else {
            cancel();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/javafx/embed/swing/JFXPanel.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.embed.swing;

import java.awt.AlphaComposite;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Window;
import java.awt.Insets;
import java.awt.EventQueue;
import java.awt.SecondaryLoop;
import java.awt.GraphicsEnvironment;
import java.awt.event.AWTEventListener;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.HierarchyEvent;
import java.awt.event.InputEvent;
import java.awt.event.InputMethodEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.InvocationEvent;
import java.awt.im.InputMethodRequests;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.nio.IntBuffer;
import java.util.concurrent.atomic.AtomicInteger;
import java.security.AccessController;
import java.security.PrivilegedAction;
import javax.swing.JComponent;
import javax.swing.SwingUtilities;

import javafx.application.Platform;
import javafx.scene.Scene;

import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.stage.EmbeddedWindow;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.PlatformUtil;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.embed.AbstractEvents;
import com.sun.javafx.embed.EmbeddedSceneInterface;
import com.sun.javafx.embed.EmbeddedStageInterface;
import com.sun.javafx.embed.HostInterface;

import com.sun.javafx.embed.swing.InteropFactory;
import com.sun.javafx.embed.swing.SwingDnD;
import com.sun.javafx.embed.swing.SwingEvents;
import com.sun.javafx.embed.swing.SwingCursors;
import com.sun.javafx.embed.swing.SwingNodeHelper;
import com.sun.javafx.embed.swing.JFXPanelInterop;

/**
* {@code JFXPanel} is a component to embed JavaFX content into
 * Swing applications. The content to be displayed is specified
 * with the {@link #setScene} method that accepts an instance of
 * JavaFX {@code Scene}. After the scene is assigned, it gets
 * repainted automatically. All the input and focus events are
 * forwarded to the scene transparently to the developer.
 * &lt;p&gt;
 * There are some restrictions related to {@code JFXPanel}. As a
 * Swing component, it should only be accessed from the event
 * dispatch thread, except the {@link #setScene} method, which can
 * be called either on the event dispatch thread or on the JavaFX
 * application thread.
 * &lt;p&gt;
 * Here is a typical pattern how {@code JFXPanel} can used:
 * &lt;pre&gt;
 *     public class Test {
 *
 *         private static void initAndShowGUI() {
 *             // This method is invoked on Swing thread
 *             JFrame frame = new JFrame(&quot;FX&quot;);
 *             final JFXPanel fxPanel = new JFXPanel();
 *             frame.add(fxPanel);
 *             frame.setVisible(true);
 *
 *             Platform.runLater(new Runnable() {
 *                 &amp;#064;Override
 *                 public void run() {
 *                     initFX(fxPanel);
 *                 }
 *             });
 *         }
 *
 *         private static void initFX(JFXPanel fxPanel) {
 *             // This method is invoked on JavaFX thread
 *             Scene scene = createScene();
 *             fxPanel.setScene(scene);
 *         }
 *
 *         public static void main(String[] args) {
 *             SwingUtilities.invokeLater(new Runnable() {
 *                 &amp;#064;Override
 *                 public void run() {
 *                     initAndShowGUI();
 *                 }
 *             });
 *         }
 *     }
 * &lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
public class JFXPanel extends JComponent {

    private final static PlatformLogger log = PlatformLogger.getLogger(JFXPanel.class.getName());

    private static AtomicInteger instanceCount = new AtomicInteger(0);
    private static PlatformImpl.FinishListener finishListener;

    private transient HostContainer hostContainer;

    private transient volatile EmbeddedWindow stage;
    private transient volatile Scene scene;

    // Accessed on EDT only
    private transient SwingDnD dnd;

    private transient EmbeddedStageInterface stagePeer;
    private transient EmbeddedSceneInterface scenePeer;

    // The logical size of the FX content
    private int pWidth;
    private int pHeight;

    // The scale factor, used to translate b/w the logical (the FX content dimension)
    // and physical (the back buffer's dimension) coordinate spaces
    private double scaleFactorX = 1.0;
    private double scaleFactorY = 1.0;

    // Preferred size set from FX
    private volatile int pPreferredWidth = -1;
    private volatile int pPreferredHeight = -1;

    // Cached copy of this component's location on screen to avoid
    // calling getLocationOnScreen() under the tree lock on FX thread
    private volatile int screenX = 0;
    private volatile int screenY = 0;

    // Accessed on EDT only
    private BufferedImage pixelsIm;

    private volatile float opacity = 1.0f;

    // Indicates how many times setFxEnabled(false) has been called.
    // A value of 0 means the component is enabled.
    private AtomicInteger disableCount = new AtomicInteger(0);

    private boolean isCapturingMouse = false;

    private static boolean fxInitialized;

    private static InteropFactory iopFactoryInstance = null;
    private JFXPanelInterop jfxPanelIOP;

    static {
        try {
            iopFactoryInstance = InteropFactory.getInstance();
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }

    private synchronized void registerFinishListener() {
        if (instanceCount.getAndIncrement() &gt; 0) {
            // Already registered
            return;
        }
        // Need to install a finish listener to catch calls to Platform.exit
        finishListener = new PlatformImpl.FinishListener() {
            @Override public void idle(boolean implicitExit) {
            }
            @Override public void exitCalled() {
            }
        };
        PlatformImpl.addListener(finishListener);
    }

    private synchronized void deregisterFinishListener() {
        if (instanceCount.decrementAndGet() &gt; 0) {
            // Other JFXPanels still alive
            return;
        }
        PlatformImpl.removeListener(finishListener);
        finishListener = null;
    }

    // Initialize FX runtime when the JFXPanel instance is constructed
    private synchronized static void initFx() {
        // Note that calling PlatformImpl.startup more than once is OK
        if (fxInitialized) {
            return;
        }
        EventQueue eventQueue = AccessController.doPrivileged(
                                (PrivilegedAction&lt;EventQueue&gt;) java.awt.Toolkit
                                .getDefaultToolkit()::getSystemEventQueue);
        if (eventQueue.isDispatchThread()) {
            // We won't block EDT by FX initialization
            SecondaryLoop secondaryLoop = eventQueue.createSecondaryLoop();
            final Throwable[] th = {null};
            new Thread(() -&gt; {
                try {
                    PlatformImpl.startup(() -&gt; {});
                } catch (Throwable t) {
                    th[0] = t;
                } finally {
                    secondaryLoop.exit();
                }
            }).start();
            secondaryLoop.enter();
            if (th[0] != null) {
                if (th[0] instanceof RuntimeException) {
                    throw (RuntimeException) th[0];
                } else if (th[0] instanceof Error) {
                    throw (Error) th[0];
                }
                throw new RuntimeException(&quot;FX initialization failed&quot;, th[0]);
            }
        } else {
            PlatformImpl.startup(() -&gt; {});
        }
        fxInitialized = true;
    }

    /**
     * Creates a new {@code JFXPanel} object.
     * &lt;p&gt;
     * &lt;b&gt;Implementation note&lt;/b&gt;: when the first {@code JFXPanel} object
     * is created, it implicitly initializes the JavaFX runtime. This is the
     * preferred way to initialize JavaFX in Swing.
     */
    public JFXPanel() {
        super();

        jfxPanelIOP = iopFactoryInstance.createJFXPanelImpl();
        initFx();

        hostContainer = new HostContainer();

        enableEvents(InputEvent.COMPONENT_EVENT_MASK |
                     InputEvent.FOCUS_EVENT_MASK |
                     InputEvent.HIERARCHY_BOUNDS_EVENT_MASK |
                     InputEvent.HIERARCHY_EVENT_MASK |
                     InputEvent.MOUSE_EVENT_MASK |
                     InputEvent.MOUSE_MOTION_EVENT_MASK |
                     InputEvent.MOUSE_WHEEL_EVENT_MASK |
                     InputEvent.KEY_EVENT_MASK |
                     InputEvent.INPUT_METHOD_EVENT_MASK);

        setFocusable(true);
        setFocusTraversalKeysEnabled(false);
    }

    /**
     * Returns the JavaFX scene attached to this {@code JFXPanel}.
     *
     * @return the {@code Scene} attached to this {@code JFXPanel}
     */
    public Scene getScene() {
        return scene;
    }

    /**
     * Attaches a {@code Scene} object to display in this {@code
     * JFXPanel}. This method can be called either on the event
     * dispatch thread or the JavaFX application thread.
     *
     * @param newScene a scene to display in this {@code JFXpanel}
     *
     * @see java.awt.EventQueue#isDispatchThread()
     * @see javafx.application.Platform#isFxApplicationThread()
     */
    public void setScene(final Scene newScene) {
        if (Toolkit.getToolkit().isFxUserThread()) {
            setSceneImpl(newScene);
        } else {
            EventQueue eventQueue = AccessController.doPrivileged(
                    (PrivilegedAction&lt;EventQueue&gt;) java.awt.Toolkit
                            .getDefaultToolkit()::getSystemEventQueue);
            SecondaryLoop secondaryLoop = eventQueue.createSecondaryLoop();
            if (secondaryLoop.enter()) {
                Platform.runLater(() -&gt; {
                    setSceneImpl(newScene);
                });
                secondaryLoop.exit();
            }
        }
    }

    /*
     * Called on JavaFX app thread.
     */
    private void setSceneImpl(Scene newScene) {
        if ((stage != null) &amp;&amp; (newScene == null)) {
            stage.hide();
            stage = null;
        }
        scene = newScene;
        if ((stage == null) &amp;&amp; (newScene != null)) {
            stage = new EmbeddedWindow(hostContainer);
        }
        if (stage != null) {
            stage.setScene(newScene);
            if (!stage.isShowing()) {
                stage.show();
            }
        }
    }

    /**
     * {@code JFXPanel}'s opacity is controlled by the JavaFX content
     * which is displayed in this component, so this method overrides
     * {@link javax.swing.JComponent#setOpaque(boolean)} to only accept a
     * {@code false} value. If this method is called with a {@code true}
     * value, no action is performed.
     *
     * @param opaque must be {@code false}
     */
    @Override
    public final void setOpaque(boolean opaque) {
        // Don't let user control opacity
        if (!opaque) {
            super.setOpaque(opaque);
        }
    }

    /**
     * {@code JFXPanel}'s opacity is controlled by the JavaFX content
     * which is displayed in this component, so this method overrides
     * {@link javax.swing.JComponent#isOpaque()} to always return a
     * {@code false} value.
     *
     * @return a {@code false} value
     */
    @Override
    public final boolean isOpaque() {
        return false;
    }

    private void sendMouseEventToFX(MouseEvent e) {
        if (scenePeer == null || !isFxEnabled()) {
            return;
        }

        // FX only supports 3 buttons so don't send the event for other buttons
        switch (e.getID()) {
            case MouseEvent.MOUSE_DRAGGED:
            case MouseEvent.MOUSE_PRESSED:
            case MouseEvent.MOUSE_RELEASED:
                if (e.getButton() &gt; 3)  return;
                break;
        }

        int extModifiers = e.getModifiersEx();
        // Fix for RT-15457: we should report no mouse button upon mouse release, so
        // *BtnDown values are calculated based on extMofifiers, not e.getButton()
        boolean primaryBtnDown = (extModifiers &amp; MouseEvent.BUTTON1_DOWN_MASK) != 0;
        boolean middleBtnDown = (extModifiers &amp; MouseEvent.BUTTON2_DOWN_MASK) != 0;
        boolean secondaryBtnDown = (extModifiers &amp; MouseEvent.BUTTON3_DOWN_MASK) != 0;
        // Fix for RT-16558: if a PRESSED event is consumed, e.g. by a Swing Popup,
        // subsequent DRAGGED and RELEASED events should not be sent to FX as well
        if (e.getID() == MouseEvent.MOUSE_DRAGGED) {
            if (!isCapturingMouse) {
                return;
            }
        } else if (e.getID() == MouseEvent.MOUSE_PRESSED) {
            isCapturingMouse = true;
        } else if (e.getID() == MouseEvent.MOUSE_RELEASED) {
            if (!isCapturingMouse) {
                return;
            }
            isCapturingMouse = primaryBtnDown || middleBtnDown || secondaryBtnDown;
        } else if (e.getID() == MouseEvent.MOUSE_CLICKED) {
            // Don't send click events to FX, as they are generated in Scene
            return;
        }
        // A workaround until JDK-8065131 is fixed.
        boolean popupTrigger = false;
        if (e.getID() == MouseEvent.MOUSE_PRESSED || e.getID() == MouseEvent.MOUSE_RELEASED) {
            popupTrigger = e.isPopupTrigger();
        }

        if(e.getID() == MouseEvent.MOUSE_WHEEL) {
            scenePeer.scrollEvent(AbstractEvents.MOUSEEVENT_VERTICAL_WHEEL,
                    0, -SwingEvents.getWheelRotation(e),
                    0, 0, // total scroll
                    40, 40, // multiplier
                    e.getX(), e.getY(),
                    e.getXOnScreen(), e.getYOnScreen(),
                    (extModifiers &amp; MouseEvent.SHIFT_DOWN_MASK) != 0,
                    (extModifiers &amp; MouseEvent.CTRL_DOWN_MASK) != 0,
                    (extModifiers &amp; MouseEvent.ALT_DOWN_MASK) != 0,
                    (extModifiers &amp; MouseEvent.META_DOWN_MASK) != 0, false);
        } else {
            scenePeer.mouseEvent(
                    SwingEvents.mouseIDToEmbedMouseType(e.getID()),
                    SwingEvents.mouseButtonToEmbedMouseButton(e.getButton(), extModifiers),
                    primaryBtnDown, middleBtnDown, secondaryBtnDown,
                    e.getX(), e.getY(), e.getXOnScreen(), e.getYOnScreen(),
                    (extModifiers &amp; MouseEvent.SHIFT_DOWN_MASK) != 0,
                    (extModifiers &amp; MouseEvent.CTRL_DOWN_MASK) != 0,
                    (extModifiers &amp; MouseEvent.ALT_DOWN_MASK) != 0,
                    (extModifiers &amp; MouseEvent.META_DOWN_MASK) != 0,
<A NAME="30"></A>                    popupTrigger);
        }
        if (e.isPopupTrigger()) {
            scenePeer.menuEvent(e.getX(), <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#30',2,'match36-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>e.getY(), e.getXOnScreen(), e.getYOnScreen(), false);
        }
    }

    /**
     * Overrides the {@link java.awt.Component#processMouseEvent(MouseEvent)}
     * method to dispatch the mouse event to the JavaFX scene attached to this
     * {@code JFXPanel}.
     *
     * @param e the mouse event to dispatch to the JavaFX scene
     */
    @Override
    protected void processMouseEvent(MouseEvent e) {
        if ((e.getID</B></FONT>() == MouseEvent.MOUSE_PRESSED) &amp;&amp;
            (e.getButton() == MouseEvent.BUTTON1)) {
            if (isFocusable() &amp;&amp; !hasFocus()) {
                requestFocus();
                // this focus request event goes to eventqueue and will be
                // asynchronously handled so MOUSE_PRESSED event will not be
                // honoured by FX immediately due to lack of focus in fx
                // component. Fire the same MOUSE_PRESSED event after
                // requestFocus() so that 2nd mouse press will be honoured
                // since now fx have focus
                jfxPanelIOP.postEvent(this, e);
            }
        }

        sendMouseEventToFX(e);
        super.processMouseEvent(e);
    }

    /**
     * Overrides the {@link java.awt.Component#processMouseMotionEvent(MouseEvent)}
     * method to dispatch the mouse motion event to the JavaFX scene attached to
     * this {@code JFXPanel}.
     *
     * @param e the mouse motion event to dispatch to the JavaFX scene
     */
    @Override
    protected void processMouseMotionEvent(MouseEvent e) {
        sendMouseEventToFX(e);
        super.processMouseMotionEvent(e);
    }

    /**
     * Overrides the
     * {@link java.awt.Component#processMouseWheelEvent(MouseWheelEvent)}
     * method to dispatch the mouse wheel event to the JavaFX scene attached
     * to this {@code JFXPanel}.
     *
     * @param e the mouse wheel event to dispatch to the JavaFX scene
     */
    @Override
    protected void processMouseWheelEvent(MouseWheelEvent e) {
        sendMouseEventToFX(e);
        super.processMouseWheelEvent(e);
    }

    private void sendKeyEventToFX(final KeyEvent e) {
        if (scenePeer == null || !isFxEnabled()) {
            return;
        }

        char[] chars = (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED)
                       ? new char[] {}
                       : new char[] { SwingEvents.keyCharToEmbedKeyChar(e.getKeyChar()) };

        scenePeer.keyEvent(
                SwingEvents.keyIDToEmbedKeyType(e.getID()),
                e.getKeyCode(), chars,
                SwingEvents.keyModifiersToEmbedKeyModifiers(e.getModifiersEx()));
    }

    /**
     * Overrides the {@link java.awt.Component#processKeyEvent(KeyEvent)}
     * method to dispatch the key event to the JavaFX scene attached to this
     * {@code JFXPanel}.
     *
     * @param e the key event to dispatch to the JavaFX scene
     */
    @Override
    protected void processKeyEvent(KeyEvent e) {
        sendKeyEventToFX(e);
        super.processKeyEvent(e);
    }

    private void sendResizeEventToFX() {
        if (stagePeer != null) {
            stagePeer.setSize(pWidth, pHeight);
        }
        if (scenePeer != null) {
            scenePeer.setSize(pWidth, pHeight);
        }
    }

    /**
     * Overrides the
     * {@link java.awt.Component#processComponentEvent(ComponentEvent)}
     * method to dispatch {@link java.awt.event.ComponentEvent#COMPONENT_RESIZED}
     * events to the JavaFX scene attached to this {@code JFXPanel}. The JavaFX
     * scene object is then resized to match the {@code JFXPanel} size.
     *
     * @param e the component event to dispatch to the JavaFX scene
     */
    @Override
    protected void processComponentEvent(ComponentEvent e) {
        switch (e.getID()) {
            case ComponentEvent.COMPONENT_RESIZED: {
                updateComponentSize();
                break;
            }
            case ComponentEvent.COMPONENT_MOVED: {
                if (updateScreenLocation()) {
                    sendMoveEventToFX();
                }
                break;
            }
            default: {
                break;
            }
        }
        super.processComponentEvent(e);
    }

    // called on EDT only
    private void updateComponentSize() {
        int oldWidth = pWidth;
        int oldHeight = pHeight;
        // It's quite possible to get negative values here, this is not
        // what JavaFX embedded scenes/stages are ready to
        pWidth = Math.max(0, getWidth());
        pHeight = Math.max(0, getHeight());
        if (getBorder() != null) {
            Insets i = getBorder().getBorderInsets(this);
            pWidth -= (i.left + i.right);
            pHeight -= (i.top + i.bottom);
        }
        double newScaleFactorX = scaleFactorX;
        double newScaleFactorY = scaleFactorY;
        Graphics g = getGraphics();
        newScaleFactorX = GraphicsEnvironment.getLocalGraphicsEnvironment().
                          getDefaultScreenDevice().getDefaultConfiguration().
                          getDefaultTransform().getScaleX();
        newScaleFactorY = GraphicsEnvironment.getLocalGraphicsEnvironment().
                          getDefaultScreenDevice().getDefaultConfiguration().
                          getDefaultTransform().getScaleY();
        if (oldWidth != pWidth || oldHeight != pHeight ||
            newScaleFactorX != scaleFactorX || newScaleFactorY != scaleFactorY)
        {
            createResizePixelBuffer(newScaleFactorX, newScaleFactorY);
            if (scenePeer != null) {
                scenePeer.setPixelScaleFactors((float) newScaleFactorX,
                                               (float) newScaleFactorY);
            }
            scaleFactorX = newScaleFactorX;
            scaleFactorY = newScaleFactorY;
            sendResizeEventToFX();
        }
    }

    // This methods should only be called on EDT
    private boolean updateScreenLocation() {
        synchronized (getTreeLock()) {
            if (isShowing()) {
                Point p = getLocationOnScreen();
                screenX = p.x;
                screenY = p.y;
                return true;
            }
        }
        return false;
    }

    private void sendMoveEventToFX() {
        if (stagePeer == null) {
            return;
        }

        stagePeer.setLocation(screenX, screenY);
    }

    /**
     * Overrides the
     * {@link java.awt.Component#processHierarchyBoundsEvent(HierarchyEvent)}
     * method to process {@link java.awt.event.HierarchyEvent#ANCESTOR_MOVED}
     * events and update the JavaFX scene location to match the {@code
     * JFXPanel} location on the screen.
     *
     * @param e the hierarchy bounds event to process
     */
    @Override
    protected void processHierarchyBoundsEvent(HierarchyEvent e) {
        if (e.getID() == HierarchyEvent.ANCESTOR_MOVED) {
            if (updateScreenLocation()) {
                sendMoveEventToFX();
            }
        }
        super.processHierarchyBoundsEvent(e);
    }

    @Override
    protected void processHierarchyEvent(HierarchyEvent e) {
        if ((e.getChangeFlags() &amp; HierarchyEvent.SHOWING_CHANGED) != 0) {
            if (updateScreenLocation()) {
                sendMoveEventToFX();
            }
        }
        super.processHierarchyEvent(e);
    }

    private void sendFocusEventToFX(final FocusEvent e) {
        if ((stage == null) || (stagePeer == null) || !isFxEnabled()) {
            return;
        }

        boolean focused = (e.getID() == FocusEvent.FOCUS_GAINED);
        int focusCause = (focused ? AbstractEvents.FOCUSEVENT_ACTIVATED :
                                      AbstractEvents.FOCUSEVENT_DEACTIVATED);

        if (focused) {
            if (e.getCause() == FocusEvent.Cause.TRAVERSAL_FORWARD) {
                focusCause = AbstractEvents.FOCUSEVENT_TRAVERSED_FORWARD;
            } else if (e.getCause() == FocusEvent.Cause.TRAVERSAL_BACKWARD) {
                focusCause = AbstractEvents.FOCUSEVENT_TRAVERSED_BACKWARD;
            }
        }
        stagePeer.setFocused(focused, focusCause);
    }

    /**
     * Overrides the
     * {@link java.awt.Component#processFocusEvent(FocusEvent)}
     * method to dispatch focus events to the JavaFX scene attached to this
     * {@code JFXPanel}.
     *
     * @param e the focus event to dispatch to the JavaFX scene
     */
    @Override
    protected void processFocusEvent(FocusEvent e) {
        sendFocusEventToFX(e);
        super.processFocusEvent(e);
    }

    // called on EDT only
    private void createResizePixelBuffer(double newScaleFactorX, double newScaleFactorY) {
        if (scenePeer == null || pWidth &lt;= 0 || pHeight &lt;= 0) {
            pixelsIm = null;
        } else {
            BufferedImage oldIm = pixelsIm;
            int newPixelW = (int) Math.ceil(pWidth * newScaleFactorX);
            int newPixelH = (int) Math.ceil(pHeight * newScaleFactorY);
            pixelsIm = new BufferedImage(newPixelW, newPixelH,
                                         SwingFXUtils.getBestBufferedImageType(
                                             scenePeer.getPixelFormat(), null, false));
            if (oldIm != null) {
                double ratioX = newScaleFactorX / scaleFactorX;
                double ratioY = newScaleFactorY / scaleFactorY;
                // Transform old size to the new coordinate space.
                int oldW = (int)Math.round(oldIm.getWidth() * ratioX);
                int oldH = (int)Math.round(oldIm.getHeight() * ratioY);

                Graphics g = pixelsIm.getGraphics();
                try {
                    g.drawImage(oldIm, 0, 0, oldW, oldH, null);
                } finally {
                    g.dispose();
                }
            }
        }
    }

    @Override
    protected void processInputMethodEvent(InputMethodEvent e) {
        if (e.getID() == InputMethodEvent.INPUT_METHOD_TEXT_CHANGED) {
            sendInputMethodEventToFX(e);
        }
        super.processInputMethodEvent(e);
    }

    private void sendInputMethodEventToFX(InputMethodEvent e) {
        String t = InputMethodSupport.getTextForEvent(e);

        int insertionIndex = 0;
        if (e.getCaret() != null) {
            insertionIndex = e.getCaret().getInsertionIndex();
        }
        scenePeer.inputMethodEvent(
                javafx.scene.input.InputMethodEvent.INPUT_METHOD_TEXT_CHANGED,
                InputMethodSupport.inputMethodEventComposed(t, e.getCommittedCharacterCount()),
                t.substring(0, e.getCommittedCharacterCount()),
                insertionIndex);
    }

    /**
     * Overrides the {@link javax.swing.JComponent#paintComponent(Graphics)}
     * method to paint the content of the JavaFX scene attached to this
     * {@code JFXpanel}.
     *
     * @param g the Graphics context in which to paint
     *
     * @see #isOpaque()
     */
    @Override
    protected void paintComponent(Graphics g) {
        if (scenePeer == null) {
            return;
        }
        if (pixelsIm == null) {
            createResizePixelBuffer(scaleFactorX, scaleFactorY);
            if (pixelsIm == null) {
                return;
            }
        }
        DataBufferInt dataBuf = (DataBufferInt)pixelsIm.getRaster().getDataBuffer();
        int[] pixelsData = dataBuf.getData();
        IntBuffer buf = IntBuffer.wrap(pixelsData);
        if (!scenePeer.getPixels(buf, pWidth, pHeight)) {
            // In this case we just render what we have so far in the buffer.
        }

        Graphics gg = null;
        try {
            gg = g.create();
            if ((opacity &lt; 1.0f) &amp;&amp; (gg instanceof Graphics2D)) {
                Graphics2D g2d = (Graphics2D)gg;
                AlphaComposite c = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, opacity);
                g2d.setComposite(c);
            }
            if (getBorder() != null) {
                Insets i = getBorder().getBorderInsets(this);
                gg.translate(i.left, i.top);
            }
            gg.drawImage(pixelsIm, 0, 0, pWidth, pHeight, null);

            double newScaleFactorX = scaleFactorX;
            double newScaleFactorY = scaleFactorY;
            newScaleFactorX = GraphicsEnvironment.getLocalGraphicsEnvironment().
                              getDefaultScreenDevice().getDefaultConfiguration().
                              getDefaultTransform().getScaleX();
            newScaleFactorY = GraphicsEnvironment.getLocalGraphicsEnvironment().
                              getDefaultScreenDevice().getDefaultConfiguration().
                              getDefaultTransform().getScaleY();
            if (scaleFactorX != newScaleFactorX || scaleFactorY != newScaleFactorY) {
                createResizePixelBuffer(newScaleFactorX, newScaleFactorY);
                // The scene will request repaint.
                scenePeer.setPixelScaleFactors((float) newScaleFactorX,
                                               (float) newScaleFactorY);
                scaleFactorX = newScaleFactorX;
                scaleFactorY = newScaleFactorY;
            }
        } catch (Throwable th) {
            th.printStackTrace();
        } finally {
            if (gg != null) {
                gg.dispose();
            }
        }
    }

    /**
     * Returns the preferred size of this {@code JFXPanel}, either
     * previously set with {@link #setPreferredSize(Dimension)} or
     * based on the content of the JavaFX scene attached to this {@code
     * JFXPanel}.
     *
     * @return prefSize this {@code JFXPanel} preferred size
     */
    @Override
    public Dimension getPreferredSize() {
        if (isPreferredSizeSet() || scenePeer == null) {
            return super.getPreferredSize();
        }
        return new Dimension(pPreferredWidth, pPreferredHeight);
    }

    private boolean isFxEnabled() {
        return this.disableCount.get() == 0;
    }

    private void setFxEnabled(boolean enabled) {
        if (!enabled) {
            if (disableCount.incrementAndGet() == 1) {
                if (dnd != null) {
                    dnd.removeNotify();
                }
            }
        } else {
            if (disableCount.get() == 0) {
                //should report a warning about an extra enable call ?
                return;
            }
            if (disableCount.decrementAndGet() == 0) {
                if (dnd != null) {
                    dnd.addNotify();
                }
            }
        }
    }

    private transient  AWTEventListener ungrabListener = event -&gt; {
        if (jfxPanelIOP.isUngrabEvent(event)) {
            SwingNodeHelper.runOnFxThread(() -&gt; {
                if (JFXPanel.this.stagePeer != null &amp;&amp;
                        getScene() != null &amp;&amp;
                        getScene().getFocusOwner() != null &amp;&amp;
                        getScene().getFocusOwner().isFocused()) {
                    JFXPanel.this.stagePeer.focusUngrab();
                }
            });
        }
        if (event instanceof MouseEvent) {
            // Synthesize FOCUS_UNGRAB if user clicks the AWT top-level window
            // that contains the JFXPanel.
            if (event.getID() == MouseEvent.MOUSE_PRESSED &amp;&amp; event.getSource() instanceof Component) {
                final Window jfxPanelWindow = SwingUtilities.getWindowAncestor(JFXPanel.this);
                final Component source = (Component)event.getSource();
                final Window eventWindow = source instanceof Window ? (Window)source : SwingUtilities.getWindowAncestor(source);

                if (jfxPanelWindow == eventWindow) {
                    SwingNodeHelper.runOnFxThread(() -&gt; {
                        if (JFXPanel.this.stagePeer != null) {
                            // No need to check if grab is active or not.
                            // NoAutoHide popups don't request the grab and
                            // ignore the Ungrab event anyway.
                            // AutoHide popups actually should be hidden when
                            // user clicks some non-FX content, even if for
                            // some reason they didn't install the grab when
                            // they were shown.
                            JFXPanel.this.stagePeer.focusUngrab();
                        }
                    });
                }
            }
        }
    };

    /**
     * Notifies this component that it now has a parent component. When this
     * method is invoked, the chain of parent components is set up with
     * KeyboardAction event listeners.
     */
    @Override
    public void addNotify() {
        super.addNotify();

        registerFinishListener();

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            JFXPanel.this.getToolkit().addAWTEventListener(ungrabListener,
                                               jfxPanelIOP.getMask());
            return null;
        });
        updateComponentSize(); // see RT-23603
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if ((stage != null) &amp;&amp; !stage.isShowing()) {
                stage.show();
                sendMoveEventToFX();
            }
        });
    }

    @Override
    public InputMethodRequests getInputMethodRequests() {
        EmbeddedSceneInterface scene = scenePeer;
        if (scene == null) {
            return null;
        }
        return new InputMethodSupport.InputMethodRequestsAdapter(scene.getInputMethodRequests());
    }

    /**
     * Notifies this component that it no longer has a parent component.
     * When this method is invoked, any KeyboardActions set up in the the
     * chain of parent components are removed.
     */
    @Override public void removeNotify() {
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if ((stage != null) &amp;&amp; stage.isShowing()) {
                stage.hide();
            }
        });

        pixelsIm = null;
        pWidth = 0;
        pHeight = 0;

        super.removeNotify();

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            JFXPanel.this.getToolkit().removeAWTEventListener(ungrabListener);
            return null;
        });

        /* see CR 4867453 */
        getInputContext().removeNotify(this);

        deregisterFinishListener();
    }

    private void invokeOnClientEDT(Runnable r) {
        jfxPanelIOP.postEvent(this, new InvocationEvent(this, r));
    }

    private class HostContainer implements HostInterface {

        @Override
        public void setEmbeddedStage(EmbeddedStageInterface embeddedStage) {
            stagePeer = embeddedStage;
            if (stagePeer == null) {
                return;
            }
            if (pWidth &gt; 0 &amp;&amp; pHeight &gt; 0) {
                stagePeer.setSize(pWidth, pHeight);
            }
            invokeOnClientEDT(() -&gt; {
                if (stagePeer != null &amp;&amp; JFXPanel.this.isFocusOwner()) {
                    stagePeer.setFocused(true, AbstractEvents.FOCUSEVENT_ACTIVATED);
                }
            });
            sendMoveEventToFX();
        }

        @Override
        public void setEmbeddedScene(EmbeddedSceneInterface embeddedScene) {
            if (scenePeer == embeddedScene) {
                return;
            }
            scenePeer = embeddedScene;
            if (scenePeer == null) {
                invokeOnClientEDT(() -&gt; {
                    if (dnd != null) {
                        dnd.removeNotify();
                        dnd = null;
                    }
                });
                return;
            }
            if (pWidth &gt; 0 &amp;&amp; pHeight &gt; 0) {
                scenePeer.setSize(pWidth, pHeight);
            }
            scenePeer.setPixelScaleFactors((float) scaleFactorX, (float) scaleFactorY);

            invokeOnClientEDT(() -&gt; {
                dnd = new SwingDnD(JFXPanel.this, scenePeer);
                dnd.addNotify();
                if (scenePeer != null) {
                    scenePeer.setDragStartListener(dnd.getDragStartListener());
                }
            });
        }

        @Override
        public boolean requestFocus() {
            return requestFocusInWindow();
        }

        @Override
        public boolean traverseFocusOut(boolean forward) {
            KeyboardFocusManager kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            if (forward) {
                kfm.focusNextComponent(JFXPanel.this);
            } else {
                kfm.focusPreviousComponent(JFXPanel.this);
            }
            return true;
        }

        @Override
        public void setPreferredSize(final int width, final int height) {
            invokeOnClientEDT(() -&gt; {
                JFXPanel.this.pPreferredWidth = width;
                JFXPanel.this.pPreferredHeight = height;
                JFXPanel.this.revalidate();
            });
        }

        @Override
        public void repaint() {
            invokeOnClientEDT(() -&gt; {
                JFXPanel.this.repaint();
            });
        }

        @Override
        public void setEnabled(final boolean enabled) {
            JFXPanel.this.setFxEnabled(enabled);
        }

        @Override
        public void setCursor(CursorFrame cursorFrame) {
            final Cursor cursor = getPlatformCursor(cursorFrame);
            invokeOnClientEDT(() -&gt; {
                JFXPanel.this.setCursor(cursor);
            });
        }

        private Cursor getPlatformCursor(final CursorFrame cursorFrame) {
            final Cursor cachedPlatformCursor =
                    cursorFrame.getPlatformCursor(Cursor.class);
            if (cachedPlatformCursor != null) {
                // platform cursor already cached
                return cachedPlatformCursor;
            }

            // platform cursor not cached yet
            final Cursor platformCursor =
                    SwingCursors.embedCursorToCursor(cursorFrame);
            cursorFrame.setPlatforCursor(Cursor.class, platformCursor);

            return platformCursor;
        }

        @Override
        public boolean grabFocus() {
            // On X11 grab is limited to a single XDisplay connection,
            // so we can't delegate it to another GUI toolkit.
            if (PlatformUtil.isLinux()) return true;

            invokeOnClientEDT(() -&gt; {
                Window window = SwingUtilities.getWindowAncestor(JFXPanel.this);
                if (window != null) {
                    jfxPanelIOP.grab(JFXPanel.this.getToolkit(), window);
                }
            });

            return true; // Oh, well...
        }

        @Override
        public void ungrabFocus() {
            // On X11 grab is limited to a single XDisplay connection,
            // so we can't delegate it to another GUI toolkit.
            if (PlatformUtil.isLinux()) return;

            invokeOnClientEDT(() -&gt; {
                Window window = SwingUtilities.getWindowAncestor(JFXPanel.this);
                if (window != null) {
                    jfxPanelIOP.ungrab(JFXPanel.this.getToolkit(), window);
                }
            });
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/drt/UIClientImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.drt;

import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.UIClient;
import com.sun.webkit.WebPage;
import com.sun.webkit.graphics.WCImage;
import com.sun.webkit.graphics.WCRectangle;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * {@link UIClient} implementation for DRT tests.
 */
final class UIClientImpl implements UIClient {

    private WebPage webPage;
    private final List&lt;UIClient&gt; clients = new ArrayList&lt;UIClient&gt;();

    private WCRectangle bounds = new WCRectangle(0, 0, 800, 600);

    UIClientImpl() {
    }

    void setWebPage(WebPage webPage) {
        this.webPage = webPage;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public WebPage createPage(boolean menu, boolean status, boolean toolbar,
            boolean resizable)
    {
        UIClientImpl client = new UIClientImpl();
        final WebPage page = new WebPage(null, client, null, null, new DumpRenderTree.ThemeClientImplStub(), false);
        client.setWebPage(page);

        page.setBounds(0, 0, 800, 600);
//        webPage.setUsePageCache(true);

        page.addLoadListenerClient(new LoadListenerClient() {
            @Override
            public void dispatchLoadEvent(long frame, int state, String url, String contentType, double progress, int errorCode) {
                if (state == DOCUMENT_AVAILABLE) {
                    DumpRenderTree.drt.dumpUnloadListeners(page, frame);
                }
            }
            @Override
            public void dispatchResourceLoadEvent(long frame, int state, String url, String contentType, double progress, int errorCode) {
            }
        });

        // This call is needed to add the main frame to WebPage.frames list.
        // TODO: investigate why it's not added automatically (via WebPage.fwkFrameCreated) and fix.
        page.getMainFrame();

        clients.add(client);
        return client.webPage;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void closePage() {
        Iterator&lt;UIClient&gt; it = clients.iterator();
        while (it.hasNext()) {
            it.next().closePage();
            it.remove();
        }
        if (webPage.getMainFrame() != 0) {
            webPage.dispose();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void showView() {
        // look, I'm showing!
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public WCRectangle getViewBounds() {
        return bounds;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setViewBounds(WCRectangle bounds) {
        this.bounds = bounds;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setStatusbarText(String text) {
    }

    /**
     * {@inheritDoc}
     */
<A NAME="34"></A>    @Override
    public void alert(String text) {
        if (!DumpRenderTree.drt.complete()) {
            <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#34',2,'match36-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>DumpRenderTree.out.printf(&quot;ALERT: %s\n&quot;, text);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean confirm(String text) {
        if (!DumpRenderTree.drt.complete()) {
            DumpRenderTree.out.printf</B></FONT>(&quot;CONFIRM: %s\n&quot;, text);
        }
        return false;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String prompt(String text, String defaultValue) {
        if (!DumpRenderTree.drt.complete()) {
            DumpRenderTree.out.printf(&quot;PROMPT: %s, default text: %s\n&quot;, text, defaultValue);
        }
        return defaultValue;
    }

    @Override
    public boolean canRunBeforeUnloadConfirmPanel() {
        return true;
    }

    @Override
    public boolean runBeforeUnloadConfirmPanel(String message) {
        if (!DumpRenderTree.drt.complete()) {
            DumpRenderTree.out.printf(&quot;CONFIRM NAVIGATION: %s\n&quot;, message);
        }
        return !DumpRenderTree.drt.shouldStayOnPageAfterHandlingBeforeUnload();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String[] chooseFile(String initialFileName, boolean multiple, String mimeFilters) {
        throw new UnsupportedOperationException(&quot;Not supported yet&quot;);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void print() {
        throw new UnsupportedOperationException(&quot;Not supported yet&quot;);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void startDrag(WCImage frame, int imageOffsetX, int imageOffsetY,
            int eventPosX, int eventPosY, String[] mimeTypes, Object[] values, boolean isImageSource)
    {
        throw new UnsupportedOperationException(&quot;Not supported yet&quot;);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void confirmStartDrag() {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isDragConfirmed() {
        return false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/PrismInvoker.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.locks.ReentrantLock;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.tk.RenderJob;
import com.sun.javafx.tk.Toolkit;
import com.sun.webkit.Invoker;

public final class PrismInvoker extends Invoker {

    public PrismInvoker() {
    }

    /*
     * No synchronization b/w Event (User) &amp; Render threads is required
     * because FX synchronizes pulse and render operations itself.
     */
    @Override protected boolean lock(ReentrantLock lock) {
        return false;
    }

    @Override protected boolean unlock(ReentrantLock lock) {
        return false;
    }

    @Override protected boolean isEventThread() {
        return isEventThreadPrivate();
    }

    private static boolean isEventThreadPrivate() {
        return Toolkit.getToolkit().isFxUserThread();
<A NAME="38"></A>    }

    @Override public void checkEventThread() {
        <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#38',2,'match36-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Toolkit.getToolkit().checkFxUserThread();
    }

    @Override public void invokeOnEventThread(final Runnable r) {
        if (isEventThread()) {
            r.run();
        } else {
            PlatformImpl.runLater(r);
        }
    }

    @Override public void postOnEventThread(final Runnable r</B></FONT>) {
        PlatformImpl.runLater(r);
    }

    static void invokeOnRenderThread(final Runnable r) {
        Toolkit.getToolkit().addRenderJob(new RenderJob(r));
    }

    static void runOnRenderThread(final Runnable r) {
        if (Thread.currentThread().getName().startsWith(&quot;QuantumRenderer&quot;)) {
            r.run();
        } else {
            FutureTask&lt;Void&gt; f = new FutureTask&lt;Void&gt;(r, null);
            Toolkit.getToolkit().addRenderJob(new RenderJob(f));
            try {
                // block until job is complete
                f.get();
            } catch (ExecutionException ex) {
                throw new AssertionError(ex);
            } catch (InterruptedException ex) {
                // ignore; recovery is impossible
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import com.sun.glass.ui.Screen;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PGFont;
import com.sun.javafx.geom.*;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.scene.text.TextLayout;
import com.sun.javafx.sg.prism.*;
import com.sun.javafx.text.TextRun;
import com.sun.prism.*;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.*;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.webkit.graphics.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import static com.sun.scenario.effect.Blend.Mode.*;
import com.sun.scenario.effect.impl.Renderer;
import com.sun.scenario.effect.impl.prism.PrRenderer;

class WCGraphicsPrismContext extends WCGraphicsContext {

    public enum Type {
        /**
         * Base context associated with the topmost page buffer.
         * Created and disposed during a single render pass.
         */
        PRIMARY,

        /**
         * A context associated with a dedicated buffer representing
         * a separate render target like canvas, buffered image etc.
         * Its life cycle is not limited to a single render pass.
         */
        DEDICATED
    }

    private final static PlatformLogger log =
            PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
    private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
            AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
            System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));

    Graphics baseGraphics;
    private BaseTransform baseTransform;

    private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();

    private ContextState state = new ContextState();

    // Cache for getPlatformGraphics
    private Graphics cachedGraphics = null;

    private int fontSmoothingType;
    private boolean isRootLayerValid = false;

    WCGraphicsPrismContext(Graphics g) {
        state.setClip(g.getClipRect());
        state.setAlpha(g.getExtraAlpha());
        baseGraphics = g;
        initBaseTransform(g.getTransformNoClone());
    }

    WCGraphicsPrismContext() {
    }

    public Type type() {
        return Type.PRIMARY;
    }

    final void initBaseTransform(BaseTransform t) {
        baseTransform = new Affine3D(t);
        state.setTransform((Affine3D)baseTransform);
    }

    private void resetCachedGraphics() {
        cachedGraphics = null;
    }

    @Override
    public Object getPlatformGraphics() {
        return getGraphics(false);
    }

    Graphics getGraphics(boolean checkClip) {
        if (cachedGraphics == null) {
            Layer l = state.getLayerNoClone();
            cachedGraphics = (l != null)
                    ? l.getGraphics()
                    : baseGraphics;

            state.apply(cachedGraphics);

            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
                         cachedGraphics);
            }
        }

        Rectangle clip = cachedGraphics.getClipRectNoClone();
        return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
            ? null
            : cachedGraphics;
    }

    public void saveState()
    {
        state.markAsRestorePoint();
        saveStateInternal();
    }

    private void saveStateInternal()
    {
        states.add(state);
        state = state.clone();
    }

    private void startNewLayer(Layer layer) {
        saveStateInternal();

        // layer has the same bounds as clip, so we have to translate
        Rectangle clip = state.getClipNoClone();

        //left-side (post-) translate.
        //NB! an order of transforms is essential!
        Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
                -clip.x,
                -clip.y));
        newTr.concatenate(state.getTransformNoClone());

        //move clip to (0, 0) - start of texture
        clip.x = 0;
        clip.y = 0;
        //no-clone - no-set!

        Graphics g = getGraphics(true);
        if (g != null &amp;&amp; g != baseGraphics) {
            layer.init(g);
        }

        state.setTransform(newTr);
        state.setLayer(layer);

        resetCachedGraphics();
    }

    private void renderLayer(final Layer layer) {
        WCTransform cur = getTransform();

        //translate to (layer.getX(), layer.getY())
        setTransform(new WCTransform(
            1.0, 0.0,
            0.0, 1.0,
            layer.getX(), layer.getY()));

        // composite drawing delegated to the layer rendering
        Graphics g = getGraphics(true);
        if (g != null) {
            layer.render(g);
        }

        //restore transform
        setTransform(cur);
    }

    private void restoreStateInternal() {
        int size = states.size();
        if (size == 0) {
            assert false: &quot;Unbalanced restoreState&quot;;
            return;
        }

        Layer layer = state.getLayerNoClone();
        state = states.remove(size - 1);
        if (layer != state.getLayerNoClone()) {
            renderLayer(layer);
            layer.dispose();
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;Popped layer &quot; + layer);
            }
        } else {
            resetCachedGraphics();
        }
    }

    public void restoreState()
    {
        log.fine(&quot;restoring state&quot;);
        do {
            restoreStateInternal();
        } while ( !state.isRestorePoint() );
    }

    /**
     *  Renders all layers to the underlaying Graphics, but preserves the
     *  current state and the states stack
     */
    private void flushAllLayers() {
        if (state == null) {
            // context disposed
            return;
        }

        if (isRootLayerValid) {
            log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
            return;
        }

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;FlushAllLayers&quot;);
        }

        ContextState currentState = state;

        for (int i = states.size() - 1; i &gt;=0; i--) {
            Layer layer = state.getLayerNoClone();
            state = states.get(i);
            if (layer != state.getLayerNoClone()) {
                renderLayer(layer);
            } else {
                resetCachedGraphics();
            }
        }

        Layer layer = state.getLayerNoClone();
        if (layer != null) {
            renderLayer(layer);
        }

        state = currentState;
        isRootLayerValid = true;
    }


    public void dispose() {
        if (!states.isEmpty()) {
            log.fine(&quot;Unbalanced saveState/restoreState&quot;);
        }
        for (ContextState state: states) {
            if (state.getLayerNoClone() != null) {
                state.getLayerNoClone().dispose();
            }
        }
        states.clear();

        if (state != null &amp;&amp; state.getLayerNoClone() != null) {
            state.getLayerNoClone().dispose();
        }
        state = null;
    }


    public void setClip(WCPath path, boolean isOut) {
        Affine3D tr = new Affine3D(state.getTransformNoClone());
        path.transform(
                tr.getMxx(), tr.getMyx(),
                tr.getMxy(), tr.getMyy(),
                tr.getMxt(), tr.getMyt());
        //path now is in node coordinates, as well as clip

        if (!isOut) {
            WCRectangle pathBounds = path.getBounds();

            // path bounds could be fractional so 'inclusive' rounding
            // is used for determining clip rectangle
            int pixelX = (int) Math.floor(pathBounds.getX());
            int pixelY = (int) Math.floor(pathBounds.getY());
            int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
            int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;

            state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
        }

        Rectangle clip = state.getClipNoClone();

        if (isOut) {
            path.addRect(clip.x, clip.y, clip.width, clip.height);
            //Out clip path is always EVENODD.
        }

        path.translate(-clip.x, -clip.y);

        Layer layer = new ClipLayer(
            getGraphics(false), clip, path, type() == Type.DEDICATED);

        startNewLayer(layer);

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
            log.fine(&quot;Pushed layer &quot; + layer);
        }
    }

    private Rectangle transformClip(Rectangle localClip) {
        if (localClip==null) {
            return null;
        }

        float[] points = new float[] {
            localClip.x, localClip.y,
            localClip.x + localClip.width, localClip.y,
            localClip.x, localClip.y + localClip.height,
            localClip.x  + localClip.width, localClip.y + localClip.height};
        state.getTransformNoClone().transform(points, 0, points, 0, 4);
        float minX = Math.min(
               points[0], Math.min(
               points[2], Math.min(
               points[4], points[6])));
        float maxX = Math.max(
               points[0], Math.max(
               points[2], Math.max(
               points[4], points[6])));
        float minY = Math.min(
               points[1], Math.min(
               points[3], Math.min(
               points[5], points[7])));
        float maxY = Math.max(
               points[1], Math.max(
               points[3], Math.max(
               points[5], points[7])));
        return new Rectangle(new RectBounds(minX, minY, maxX, maxY));

/* #1 loose rotate
        state.getTransformNoClone().transform(localClip, localClip);
*/
/* #2 problem with negative coordinates
        RectBounds rb = TransformedShape.transformedShape(
            new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
            state.getTransformNoClone()).getBounds();
        return rb.isEmpty()
            ? null
            : new Rectangle(rb);
 */
    }

    private void setClip(Rectangle shape) {
        Affine3D tr = state.getTransformNoClone();
        if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
         &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
         &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
            //There is no rotation here: scale + translation.
            //Fast &amp; easy!
            state.clip(transformClip(shape));
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;setClip({0})&quot;, shape);
            }
            if (DEBUG_DRAW_CLIP_SHAPE) {
                //Draw clip shape
                Rectangle rc = state.getClipNoClone();
                if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
                    WCTransform cur = getTransform();
                    //translate to (layer.getX(), layer.getY())
                    setTransform(new WCTransform(
                        1.0, 0.0,
                        0.0, 1.0,
                        0.0, 0.0));

                    Graphics g2d = getGraphics(true);
                    if (g2d != null) {
                        float fbase = (float)Math.random();
                        g2d.setPaint(new Color(
                                fbase,
                                1f - fbase,
                                0.5f,
                                0.1f));
                        g2d.setStroke(new BasicStroke());
                        g2d.fillRect(rc.x, rc.y, rc.width, rc.height);

                        g2d.setPaint(new Color(
                                1f - fbase,
                                fbase,
                                0.5f,
                                1f));
                        g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
                    }
                    //restore transform
                    setTransform(cur);
                    state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
                }
            }
            if (cachedGraphics != null) {
                cachedGraphics.setClipRect(state.getClipNoClone());
            }
        } else {
            //twisted axis set
            WCPath path = new WCPathImpl();
            path.addRect(shape.x, shape.y, shape.width, shape.height);
            setClip(path, false);
        }
    }

    public void setClip(int cx, int cy, int cw, int ch) {
        setClip(new Rectangle(cx, cy, cw, ch));
    }

    public void setClip(WCRectangle c) {
        setClip(new Rectangle((int)c.getX(), (int)c.getY(),
                              (int)c.getWidth(), (int)c.getHeight()));
    }

    public WCRectangle getClip() {
        Rectangle r = state.getClipNoClone();
        return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
    }

    protected Rectangle getClipRectNoClone() {
        return state.getClipNoClone();
    }

    protected Affine3D getTransformNoClone() {
        return state.getTransformNoClone();
    }

    public void translate(float x, float y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
        }
        state.translate(x, y);
        if (cachedGraphics != null) {
            cachedGraphics.translate(x, y);
        }
    }

    public void scale(float sx, float sy) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
        }
        state.scale(sx, sy);
        if (cachedGraphics != null) {
            cachedGraphics.scale(sx, sy);
        }
    }

    public void rotate(float radians) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
        }
        state.rotate(radians);
        if (cachedGraphics != null) {
            cachedGraphics.setTransform(state.getTransformNoClone());
        }
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderRect(float x, float y, float w, float h,
                                       DropShadow shadow, BasicStroke stroke)
    {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldCalculateIntersection() {
        return false;
    }

    @Override
    public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = (rgba != null)
                    ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
                    : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
            log.fine(String.format(format, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
                DropShadow shadow = state.getShadowNoClone();
                // TextureMapperJava::drawSolidColor calls fillRect with perspective
                // projection.
                if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, 0, 0);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void fillRoundedRect(final float x, final float y, final float w, final float h,
        final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
        final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
        final int rgba)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
                    + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
                    x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
                    bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                // Prism only supports single arcWidth/Height.
                // We work around by calculating average width and height here

                float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
                float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;

                Paint paint = createColor(rgba);
                DropShadow shadow = state.getShadowNoClone();
                if (shadow != null) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, arcW, arcH);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRoundRect(x, y, w, h, arcW, arcH);
                }
            }
        }.paint();
    }

    @Override
    public void clearRect(final float x, final float y, final float w, final float h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
        }
        if (shouldCalculateIntersection()) {
            // No intersection is applicable for clearRect.
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.clearQuad(x, y, x + w, y + h);
            }
        }.paint();
    }

    @Override
    public void setFillColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
        }
        state.setPaint(createColor(rgba));
    }

    @Override
    public void setFillGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setTextMode(boolean fill, boolean stroke, boolean clip) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
        }
        state.setTextMode(fill, stroke, clip);
    }

    @Override
    public void setFontSmoothingType(int fontSmoothingType) {
        this.fontSmoothingType = fontSmoothingType;
    }

    @Override
    public int getFontSmoothingType() {
        return fontSmoothingType;
    }

    @Override
    public void setStrokeStyle(int style) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeStyle({0})&quot;, style);
        }
        state.getStrokeNoClone().setStyle(style);
    }

    @Override
    public void setStrokeColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
        }
        state.getStrokeNoClone().setPaint(createColor(rgba));
    }

    @Override
    public void setStrokeWidth(float width) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
        }
        state.getStrokeNoClone().setThickness(width);
    }

    @Override
    public void setStrokeGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setLineDash(float offset, float... sizes) {
        if (log.isLoggable(Level.FINE)) {
            StringBuilder s = new StringBuilder(&quot;[&quot;);
            for (int i=0; i &lt; sizes.length; i++) {
                s.append(sizes[i]).append(',');
            }
            s.append(']');
            log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
        }
        state.getStrokeNoClone().setDashOffset(offset);
        if (sizes != null) {
            boolean allZero = true;
            for (int i = 0; i &lt; sizes.length; i++) {
                if (sizes[i] != 0) {
                    allZero = false;
                    break;
                }
            }
            if (allZero) {
                sizes = null;
            }
        }
        state.getStrokeNoClone().setDashSizes(sizes);
    }

    @Override
    public void setLineCap(int lineCap) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineCap(lineCap);
    }

    @Override
    public void setLineJoin(int lineJoin) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineJoin(lineJoin);
    }

    @Override
    public void setMiterLimit(float miterLimit) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
        }
        state.getStrokeNoClone().setMiterLimit(miterLimit);
    }

    @Override
    public void setShadow(float dx, float dy, float blur, int rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
            log.fine(String.format(format, dx, dy, blur, rgba));
        }
        state.setShadow(createShadow(dx, dy, blur, rgba));
    }

    @Override
    public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPolygon({0})&quot;,
                    new Object[] {shouldAntialias});
        }
        if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
                                state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Path2D p2d = (Path2D) path.getPlatformPath();
                g.setPaint(state.getPaintNoClone());
                g.fill(p2d);
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(p2d);
                }
            }
        }.paint();
    }

    @Override
    public void drawLine(final int x0, final int y0, final int x1, final int y1) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
                    new Object[] {x0, y0, x1, y1});
        }
        Line2D line = new Line2D(x0, y0, x1, y1);
        if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawLine(x0, y0, x1, y1);
                }
            }
        }.paint();
    }

    @Override
    public void drawPattern(
        final WCImage texture,
        final WCRectangle srcRect,
        final WCTransform patternTransform,
        final WCPoint phase,
        final WCRectangle destRect)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
                    new Object[] {destRect.getIntX(), destRect.getIntY(),
                                  destRect.getIntWidth(),
                                  destRect.getIntHeight()});
        }
        if (!shouldRenderRect(destRect.getX(), destRect.getY(),
                              destRect.getWidth(), destRect.getHeight(), null, null))
        {
            return;
        }
        if (texture != null) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    // The handling of pattern transform is modeled after the WebKit
                    // ImageCG.cpp's Image::drawPattern()
                    float adjustedX = phase.getX()
                            + srcRect.getX() * (float) patternTransform.getMatrix()[0];
                    float adjustedY = phase.getY()
                            + srcRect.getY() * (float) patternTransform.getMatrix()[3];
                    float scaledTileWidth =
                            srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
                    float scaledTileHeight =
                            srcRect.getHeight() * (float) patternTransform.getMatrix()[3];

                    Image img = ((PrismImage)texture).getImage();

                    // Create subImage only if srcRect doesn't fit the texture bounds. See RT-20193.
                    if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {

                        img = img.createSubImage(srcRect.getIntX(),
                                                 srcRect.getIntY(),
                                                 (int)Math.ceil(srcRect.getWidth()),
                                                 (int)Math.ceil(srcRect.getHeight()));
                    }
                    g.setPaint(new ImagePattern(
                               img,
                               adjustedX, adjustedY,
                               scaledTileWidth, scaledTileHeight,
                               false, false));

                    g.fillRect(destRect.getX(), destRect.getY(),
                               destRect.getWidth(), destRect.getHeight());
                }
            }.paint();
        }
    }

    @Override
    public void drawImage(final WCImage img,
                          final float dstx, final float dsty, final float dstw, final float dsth,
                          final float srcx, final float srcy, final float srcw, final float srch)
    {
        if (log.isLoggable(Level.FINE)){
            log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
                    &quot;src({4},{5},{6},{7}))&quot;,
                    new Object[] {dstx, dsty, dstw, dsth,
                                  srcx, srcy, srcw, srch});
        }
        if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
            return;
        }
        if (img instanceof PrismImage) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    PrismImage pi = (PrismImage) img;
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        NGImageView node = new NGImageView();
                        node.setImage(pi.getImage());
                        node.setX(dstx);
                        node.setY(dsty);
                        node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
                        node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
                        render(g, shadow, null, null, node);
                    } else {
                        pi.draw(g,
                                (int) dstx, (int) dsty,
                                (int) (dstx + dstw), (int) (dsty + dsth),
                                (int) srcx, (int) srcy,
                                (int) (srcx + srcw), (int) (srcy + srch));
                    }
                }
            }.paint();
        }
    }

    @Override
    public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
        if (!shouldRenderRect(x, y, w, h, null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                image.order(ByteOrder.nativeOrder());
                Image img = Image.fromByteBgraPreData(image, w, h);
                ResourceFactory rf = g.getResourceFactory();
                Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
                g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
                txt.dispose();
            }
        }.paint();
    }

    @Override
    public void drawIcon(WCIcon icon, int x, int y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
                    new Object[] {x, y});
        }
    }

    @Override
    public void drawRect(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
                    new Object[]{x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint c = state.getPaintNoClone();
                if (c != null &amp;&amp; c.isOpaque()) {
                    g.setPaint(c);
                    g.fillRect(x, y, w, h);
                }

                if (state.getStrokeNoClone().apply(g)) {
                    g.drawRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void drawString(final WCFont f, final int[] glyphs,
                           final float[] advances, final float x, final float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
                    glyphs.length, x, y));
        }
        PGFont font = (PGFont)f.getPlatformFont();
        TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);

        DropShadow shadow = state.getShadowNoClone();
        BasicStroke stroke = state.isTextStroke()
                ? state.getStrokeNoClone().getPlatformStroke()
                : null;

        final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
        if (shouldCalculateIntersection()) {
            Metrics m = strike.getMetrics();
            gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
            if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
                return;
            }
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = state.isTextFill()
                        ? state.getPaintNoClone()
                        : null;
                if (shadow != null) {
                    final NGText span = new NGText();
                    span.setGlyphs(new GlyphList[] {gl});
                    span.setFont(font);
                    span.setFontSmoothingType(fontSmoothingType);
                    render(g, shadow, paint, stroke, span);
                } else {
                    if (paint != null) {
                        g.setPaint(paint);
                        g.drawString(gl, strike, x, y, null, 0, 0);
                    }
                    if (stroke != null) {
                        paint = state.getStrokeNoClone().getPaint();
                        if (paint != null) {
                            g.setPaint(paint);
                            g.setStroke(stroke);
                            g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
                        }
                    }
                }
            }
        }.paint();
    }

    @Override public void drawString(WCFont f, String str, boolean rtl,
            int from, int to, float x, float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;str='%s' (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
                    str, str.length(), from, to, rtl, x, y));
        }
        TextLayout layout = TextUtilities.createLayout(
                str.substring(from, to), f.getPlatformFont());
        int count = 0;
        GlyphList[] runs = layout.getRuns();
        for (GlyphList run: runs) {
            count += run.getGlyphCount();
        }

        int[] glyphs = new int[count];
        float[] adv = new float[count];
        count = 0;
        for (GlyphList run: layout.getRuns()) {
            int gc = run.getGlyphCount();
            for (int i = 0; i &lt; gc; i++) {
                glyphs[count] = run.getGlyphCode(i);
                adv[count] = run.getPosX(i + 1) - run.getPosX(i);
                count++;
            }
        }

        // adjust x coordinate (see RT-29908)
        if (rtl) {
            x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
                  layout.getBounds().getWidth());
        } else {
            x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
        }
        drawString(f, glyphs, adv, x, y);
    }

    @Override
    public void setComposite(int composite) {
        log.fine(&quot;setComposite({0})&quot;, composite);
        state.setCompositeOperation(composite);
    }

    @Override
    public void drawEllipse(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
                    new Object[] { x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(state.getPaintNoClone());
                g.fillEllipse(x, y, w, h);
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawEllipse(x, y, w, h);
                }
            }
        }.paint();
    }

    private final static BasicStroke focusRingStroke =
        new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
                         BasicStroke.JOIN_ROUND, 0.0f,
                         new float[] {1.0f}, 0.0f);

    @Override
    public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(createColor(rgba));
                BasicStroke stroke = g.getStroke();
                g.setStroke(focusRingStroke);
                g.drawRoundRect(x, y, w, h, 4, 4);
                g.setStroke(stroke);
            }
        }.paint();
    }

    public void setAlpha(float alpha) {
        log.fine(&quot;setAlpha({0})&quot;, alpha);

        state.setAlpha(alpha);

        if (null != cachedGraphics) {
            cachedGraphics.setExtraAlpha(state.getAlpha());
        }
    }

    public float getAlpha() {
        return state.getAlpha();
    }

    @Override public void beginTransparencyLayer(float opacity) {
        TransparencyLayer layer = new TransparencyLayer(
                getGraphics(false), state.getClipNoClone(), opacity);

        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
        }

        //[saveStateIntertal] will work as [saveState]
        state.markAsRestorePoint();

        startNewLayer(layer);
    }

    @Override public void endTransparencyLayer() {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
        }

        //pair to [startNewLayer] that works as [saveState] call
        restoreState();
    }

    @Override
    public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
            }
        }.paint();
    }

    @Override
    public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
                              int pressedPart, int hoveredPart)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
        }

        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
            }
        }.paint();
    }

    private static Rectangle intersect(Rectangle what, Rectangle with) {
        if (what == null) {
            return with;
        }
        RectBounds b = what.toRectBounds();
        b.intersectWith(with);
        what.setBounds(b);
        return what;
    }

    static Color createColor(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color(r, g, b, a);
    }

    private static Color4f createColor4f(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color4f(r, g, b, a);
    }

    private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
        if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
            return null;
        }
        DropShadow shadow = new DropShadow();
        shadow.setOffsetX((int) dx);
        shadow.setOffsetY((int) dy);
        shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
        shadow.setColor(createColor4f(rgba));
        return shadow;
    }

    private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
        if (node instanceof NGShape) {
            NGShape shape = (NGShape) node;
            Shape realShape = shape.getShape();
            Paint strokePaint = state.getStrokeNoClone().getPaint();
            if ((stroke != null) &amp;&amp; (strokePaint != null)) {
                realShape = stroke.createStrokedShape(realShape);
                shape.setDrawStroke(stroke);
                shape.setDrawPaint(strokePaint);
                shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
            } else {
                shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
            }
            shape.setFillPaint(paint);
            shape.setContentBounds(realShape.getBounds());
        }
        boolean culling = g.hasPreCullingBits();
        g.setHasPreCullingBits(false);
        node.setEffect(effect);
        node.render(g);
        g.setHasPreCullingBits(culling);
    }

    private static final class ContextState {
        private final WCStrokeImpl stroke = new WCStrokeImpl();
        private Rectangle clip;
        private Paint paint;
        private float alpha;

        private boolean textFill = true;
        private boolean textStroke = false;
        private boolean textClip = false;
        private boolean restorePoint = false;

        private DropShadow shadow;
        private Affine3D xform;
        private GeneralTransform3D perspectiveTransform;
        private Layer layer;
        private int compositeOperation;

        private ContextState() {
            clip = null;
<A NAME="2"></A>            paint = Color.BLACK;
            stroke.setPaint(Color.BLACK);
            alpha = 1.0f;
            <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#2',2,'match36-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>xform = new Affine3D();
            perspectiveTransform = new GeneralTransform3D();
            compositeOperation = COMPOSITE_SOURCE_OVER;
        }

        private ContextState(ContextState state) {</B></FONT>
            stroke.copyFrom(state.getStrokeNoClone());
            setPaint(state.getPaintNoClone());
            clip = state.getClipNoClone();
            if (clip != null) {
                clip = new Rectangle(clip);
            }
            xform = new Affine3D(state.getTransformNoClone());
            perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
            setShadow(state.getShadowNoClone());
            setLayer(state.getLayerNoClone());
            setAlpha(state.getAlpha());
            setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
            setCompositeOperation(state.getCompositeOperation());
        }

        @Override
        protected ContextState clone() {
            return new ContextState(this);
        }

        private void apply(Graphics g) {
            g.setTransform(getTransformNoClone());
            g.setPerspectiveTransform(getPerspectiveTransformNoClone());
            g.setClipRect(getClipNoClone());
            g.setExtraAlpha(getAlpha());
        }

        private int getCompositeOperation() {
            return compositeOperation;
        }

        private void setCompositeOperation(int compositeOperation) {
            this.compositeOperation = compositeOperation;
        }

        private WCStrokeImpl getStrokeNoClone() {
            return stroke;
        }

        private Paint getPaintNoClone() {
            return paint;
        }

        private void setPaint(Paint paint) {
            this.paint = paint;
        }

        private Rectangle getClipNoClone() {
            return clip;
        }

        private Layer getLayerNoClone() {
            return layer;
        }

        private void setLayer(Layer layer) {
            this.layer = layer;
        }

        private void setClip(Rectangle area) {
            clip = area;
        }

        private void clip(Rectangle area) {
            if (null == clip) {
                clip = area;
            } else {
                clip.intersectWith(area);
            }
        }

        private void setAlpha(float alpha) {
            this.alpha = alpha;
        }

        private float getAlpha() {
            return alpha;
        }

        private void setTextMode(boolean fill, boolean stroke, boolean clip) {
            textFill = fill;
            textStroke = stroke;
            textClip = clip;
        }

        private boolean isTextFill() {
            return textFill;
        }

        private boolean isTextStroke() {
            return textStroke;
        }

        private boolean isTextClip() {
            return textClip;
        }

        private void markAsRestorePoint() {
            restorePoint = true;
        }

        private boolean isRestorePoint() {
            return restorePoint;
        }

        private void setShadow(DropShadow shadow) {
            this.shadow = shadow;
        }

        private DropShadow getShadowNoClone() {
            return shadow;
        }

        private Affine3D getTransformNoClone() {
            return xform;
        }

        private GeneralTransform3D getPerspectiveTransformNoClone() {
            return perspectiveTransform;
        }

        private void setTransform(final Affine3D at) {
            this.xform.setTransform(at);
        }

        private void setPerspectiveTransform(final GeneralTransform3D gt) {
            this.perspectiveTransform.set(gt);
        }

        private void concatTransform(Affine3D at) {
            xform.concatenate(at);
        }

        private void translate(double dx, double dy) {
            xform.translate(dx, dy);
        }

        private void scale(double sx, double sy) {
            xform.scale(sx,sy);
        }

        private void rotate(double radians) {
            xform.rotate(radians);
        }
    }

    private abstract static class Layer {
        FilterContext fctx;
        PrDrawable buffer;
        Graphics graphics;
        final Rectangle bounds;
        boolean permanent;

        Layer(Graphics g, Rectangle bounds, boolean permanent) {
            this.bounds = new Rectangle(bounds);
            this.permanent = permanent;

            // avoid creating zero-size drawable, see also RT-21410
            int w = Math.max(bounds.width, 1);
            int h = Math.max(bounds.height, 1);
            fctx = getFilterContext(g);
            if (permanent) {
                ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
                RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
                rtt.makePermanent();
                buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
            } else {
                buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
            }
        }

        Graphics getGraphics() {
            if (graphics == null) {
                graphics = buffer.createGraphics();
            }
            return graphics;
        }

        abstract void init(Graphics g);

        abstract void render(Graphics g);

        private void dispose() {
            if (buffer != null) {
                if (permanent) {
                    buffer.flush(); // releases the resource
                } else {
                    Effect.releaseCompatibleImage(fctx, buffer);
                }
                fctx = null;
                buffer = null;
            }
        }

        private double getX() { return (double) bounds.x; }
        private double getY() { return (double) bounds.y; }
    }

    private final class TransparencyLayer extends Layer {
        private final float opacity;

        private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
            super(g, bounds, false);
            this.opacity = opacity;
        }

        @Override void init(Graphics g) {
            state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
        }

        @Override void render(Graphics g) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    float op = g.getExtraAlpha();
                    g.setExtraAlpha(opacity);
                    Affine3D tx = new Affine3D(g.getTransformNoClone());
                    g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                    g.drawTexture(buffer.getTextureObject(),
                            bounds.x, bounds.y, bounds.width, bounds.height);
                    g.setTransform(tx);
                    g.setExtraAlpha(op);
                }
            }.paint(g);
        }

        @Override public String toString() {
            return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
                bounds.x, bounds.y, bounds.width, bounds.height, opacity);
        }
    }

    private static final class ClipLayer extends Layer {
        private final WCPath normalizedToClipPath;
        private boolean srcover;

        private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
                          boolean permanent)
        {
            super(g, bounds, permanent);
            this.normalizedToClipPath = normalizedToClipPath;
            srcover = true;
        }

        @Override void init(Graphics g) {
            RTTexture texture = null;
            ReadbackGraphics readbackGraphics = null;
            try {
                readbackGraphics = (ReadbackGraphics) g;
                texture = readbackGraphics.readBack(bounds);
                getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
            } finally {
                if (readbackGraphics != null &amp;&amp; texture != null) {
                    readbackGraphics.releaseReadBackBuffer(texture);
                }
            }
            srcover = false;
        }

        @Override void render(Graphics g) {
            Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();

            // render normalizedToClipPath to a drawable
            PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
                    fctx, bounds.width, bounds.height);
            Graphics bufferGraphics = bufferImg.createGraphics();

            bufferGraphics.setPaint(Color.BLACK);
            bufferGraphics.fill(p2d);

            // blend buffer and clipImg onto |g|
            if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
                MaskTextureGraphics mg = (MaskTextureGraphics) g;
                if (srcover) {
                    mg.drawPixelsMasked(buffer.getTextureObject(),
                                        bufferImg.getTextureObject(),
                                        bounds.x, bounds.y, bounds.width, bounds.height,
                                        0, 0, 0, 0);
                } else {
                    mg.maskInterpolatePixels(buffer.getTextureObject(),
                                             bufferImg.getTextureObject(),
                                             bounds.x, bounds.y, bounds.width, bounds.height,
                                             0, 0, 0, 0);
                }
            } else {
                Blend blend = new Blend(Blend.Mode.SRC_IN,
                        new PassThrough(bufferImg, bounds.width, bounds.height),
                        new PassThrough(buffer, bounds.width, bounds.height));
                Affine3D tx = new Affine3D(g.getTransformNoClone());
                g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
                g.setTransform(tx);
            }

            Effect.releaseCompatibleImage(fctx, bufferImg);
        }

        @Override public String toString() {
            return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
                    bounds.x, bounds.y, bounds.width, bounds.height,
                    normalizedToClipPath);
        }
    }

    private abstract class Composite {
        abstract void doPaint(Graphics g);

        void paint() {
            paint(getGraphics(true));
        }

        void paint(Graphics g) {
            if (g != null) {
                CompositeMode oldCompositeMode = g.getCompositeMode();
                switch (state.getCompositeOperation()) {
                    // decode operations that don't require Blend first
                    case COMPOSITE_COPY:
                        g.setCompositeMode(CompositeMode.SRC);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    case COMPOSITE_SOURCE_OVER:
                        g.setCompositeMode(CompositeMode.SRC_OVER);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    default:
                        // other operations require usage of Blend
                        blend(g);
                        break;
                }
                isRootLayerValid = false;
            }
        }

        private void blend(Graphics g) {
            FilterContext fctx = getFilterContext(g);
            PrDrawable dstImg = null;
            PrDrawable srcImg = null;
            ReadbackGraphics readBackGraphics = null;
            RTTexture texture = null;
            Rectangle clip = state.getClipNoClone();
            WCImage image = getImage();
            try {
                if (image != null &amp;&amp; image instanceof PrismImage) {
                    // blending on canvas
                    dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                    Graphics dstG = dstImg.createGraphics();
                    ((PrismImage) image).draw(dstG,
                            0, 0, clip.width, clip.height,
                            clip.x, clip.y, clip.width, clip.height);
                } else {
                    // blending on page
                    readBackGraphics = (ReadbackGraphics) g;
                    texture = readBackGraphics.readBack(clip);
                    dstImg = PrDrawable.create(fctx, texture);
                }

                srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                Graphics srcG = srcImg.createGraphics();
                state.apply(srcG);
                doPaint(srcG);

                g.clear();
                PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);

            } finally {
                if (srcImg != null) {
                    Effect.releaseCompatibleImage(fctx, srcImg);
                }
                if (dstImg != null) {
                    if (readBackGraphics != null &amp;&amp; texture != null) {
                        readBackGraphics.releaseReadBackBuffer(texture);
                    } else {
                        Effect.releaseCompatibleImage(fctx, dstImg);
                    }
                }
            }
        }

        // provides some syntax sugar for createEffect()
        private Effect createBlend(Blend.Mode mode,
                                   PrDrawable dstImg,
                                   PrDrawable srcImg,
                                   int width,
                                   int height)
        {
            return new Blend(
                    mode,
                    new PassThrough(dstImg, width, height),
                    new PassThrough(srcImg, width, height));
        }

        private Effect createEffect(PrDrawable dstImg,
                                    PrDrawable srcImg,
                                    int width,
                                    int height)
        {
            switch (state.getCompositeOperation()) {
                case COMPOSITE_CLEAR: // same as xor
                case COMPOSITE_XOR:
                    return new Blend(
                            SRC_OVER,
                            createBlend(SRC_OUT, dstImg, srcImg, width, height),
                            createBlend(SRC_OUT, srcImg, dstImg, width, height)
                    );
                case COMPOSITE_SOURCE_IN:
                    return createBlend(SRC_IN, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_OUT:
                    return createBlend(SRC_OUT, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_ATOP:
                    return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
                case COMPOSITE_DESTINATION_OVER:
                    return createBlend(SRC_OVER, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_IN:
                    return createBlend(SRC_IN, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_OUT:
                    return createBlend(SRC_OUT, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_ATOP:
                    return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
                case COMPOSITE_HIGHLIGHT:
                    return createBlend(ADD, dstImg, srcImg, width, height);
                default:
                    return createBlend(SRC_OVER, dstImg, srcImg, width, height);
            }
        }
    }

    private static final class PassThrough extends Effect {
        private final PrDrawable img;
        private final int width;
        private final int height;

        private PassThrough(PrDrawable img, int width, int height) {
            this.img = img;
            this.width = width;
            this.height = height;
        }

        @Override public ImageData filter(
                FilterContext fctx,
                BaseTransform transform,
                Rectangle outputClip,
                Object renderHelper,
                Effect defaultInput) {
            // We have an unpaired lock() here, because unlocking is done
            // internally by ImageData. See RT-33625 for details.
            img.lock();
            ImageData imgData = new ImageData(fctx, img, new Rectangle(
                                              (int) transform.getMxt(),
                                              (int) transform.getMyt(),
                                              width, height));
            imgData.setReusable(true);
            return imgData;
        }

        @Override public RectBounds getBounds(
                BaseTransform transform,
                Effect defaultInput) {
            return null;
        }

        @Override public AccelType getAccelType(FilterContext fctx) {
            return AccelType.INTRINSIC;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null;
        }
    }

    private static FilterContext getFilterContext(Graphics g) {
        Screen screen = g.getAssociatedScreen();
        if (screen == null) {
            ResourceFactory factory = g.getResourceFactory();
            return PrFilterContext.getPrinterContext(factory);
        } else {
            return PrFilterContext.getInstance(screen);
        }
    }

    @Override
    public void strokeArc(final int x, final int y, final int w, final int h,
                          final int startAngle, final int angleSpan)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
                                   x, y, w, h, startAngle, angleSpan));
        }
        Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
        if (state.getStrokeNoClone().isApplicable() &amp;&amp;
            !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(arc);
                }
            }
        }.paint();
    }

    @Override
    public WCImage getImage() {
        return null;
    }

    @Override
    public void strokeRect(final float x, final float y, final float w, final float h,
                           final float lineWidth) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
                                   x, y, w, h, lineWidth));
        }
        BasicStroke stroke = new BasicStroke(
            lineWidth,
            BasicStroke.CAP_BUTT,
            BasicStroke.JOIN_MITER,
            Math.max(1.0f, lineWidth),
            state.getStrokeNoClone().getDashSizes(),
            state.getStrokeNoClone().getDashOffset());

        if (!shouldRenderRect(x, y, w, h, null, stroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setStroke(stroke);
                Paint paint = state.getStrokeNoClone().getPaint();
                if (paint == null) {
                    paint = state.getPaintNoClone();
                }
                g.setPaint(paint);
                g.drawRect(x, y, w, h);
            }
        }.paint();
    }

    @Override
    public void strokePath(final WCPath path) {
        log.fine(&quot;strokePath&quot;);
        if (path != null) {
            final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
            final DropShadow shadow = state.getShadowNoClone();
            final Path2D p2d = (Path2D)path.getPlatformPath();

            if ((stroke == null &amp;&amp; shadow == null) ||
                !shouldRenderShape(p2d, shadow, stroke))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, null, stroke, node);
                    } else if (stroke != null) {
                        Paint paint = state.getStrokeNoClone().getPaint();
                        if (paint == null) {
                            paint = state.getPaintNoClone();
                        }
                        g.setPaint(paint);
                        g.setStroke(stroke);
                        g.draw(p2d);
                    }
                }
            }.paint();
        }
    }

    @Override
    public void fillPath(final WCPath path) {
        log.fine(&quot;fillPath&quot;);
        if (path != null) {
            if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
                                   state.getShadowNoClone(), null))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    Path2D p2d = (Path2D) path.getPlatformPath();
                    Paint paint = state.getPaintNoClone();
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, paint, null, node);
                    } else {
                        g.setPaint(paint);
                        g.fill(p2d);
                    }
                }
            }.paint();
        }
    }

    public void setPerspectiveTransform(WCTransform tm) {
        final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
        state.setPerspectiveTransform(at);
        resetCachedGraphics();
    }

    public void setTransform(WCTransform tm) {
        final double m[] = tm.getMatrix();
        final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        if (state.getLayerNoClone() == null) {
            at.preConcatenate(baseTransform);
        }
        state.setTransform(at);
        resetCachedGraphics();
    }

    public WCTransform getTransform() {
        Affine3D xf = state.getTransformNoClone();
        return new WCTransform(xf.getMxx(), xf.getMyx(),
                               xf.getMxy(), xf.getMyy(),
                               xf.getMxt(), xf.getMyt());
    }

    public void concatTransform(WCTransform tm) {
        double m[] = tm.getMatrix();
        Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        state.concatTransform(at);
        resetCachedGraphics();
    }

    @Override
    public void flush() {
        flushAllLayers();
    }

    @Override
    public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
        return new WCLinearGradient(p1, p2);
    }

    @Override
    public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
        return new WCRadialGradient(p1, r1, p2, r2);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/WCImageDecoderImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import com.sun.javafx.iio.ImageFrame;
import com.sun.javafx.iio.ImageLoadListener;
import com.sun.javafx.iio.ImageLoader;
import com.sun.javafx.iio.ImageMetadata;
import com.sun.javafx.iio.ImageStorage;
import com.sun.javafx.iio.ImageStorageException;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.graphics.WCImage;
import com.sun.webkit.graphics.WCImageDecoder;
import com.sun.webkit.graphics.WCImageFrame;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

final class WCImageDecoderImpl extends WCImageDecoder {

    private final static PlatformLogger log;

    private Service&lt;ImageFrame[]&gt; loader;

    private int imageWidth = 0;
    private int imageHeight = 0;
    private ImageFrame[] frames;
    private int frameCount = 0; // keeps frame count when decoded frames are temporarily destroyed
    private boolean fullDataReceived = false;
    private boolean framesDecoded = false; // guards frames from repeated decoding
    private PrismImage[] images;
    private volatile byte[] data;
    private volatile int dataSize = 0;
    private String fileNameExtension;

    static {
        log = PlatformLogger.getLogger(WCImageDecoderImpl.class.getName());
    }

    /*
     * This method is supposed to be called from ImageSource::clear() method
     * when either the decoded data or the image decoder itself are to be destroyed.
     * It should free all complex object on the java layer and explicitely
     * destroy objects which has native resources.
     */
    @Override protected synchronized void destroy() {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;%X Destroy image decoder&quot;, hashCode()));
        }

        destroyLoader();
        frames = null;
        images = null;
        framesDecoded = false;
    }

    @Override protected String getFilenameExtension() {
        return &quot;.&quot; + fileNameExtension;
    }

    private boolean imageSizeAvilable() {
        return imageWidth &gt; 0 &amp;&amp; imageHeight &gt; 0;
    }

    @Override protected void addImageData(byte[] dataPortion) {
        if (dataPortion != null) {
            fullDataReceived = false;
            if (data == null) {
                data = Arrays.copyOf(dataPortion, dataPortion.length * 2);
                dataSize = dataPortion.length;
            } else {
                int newDataSize = dataSize + dataPortion.length;
                if (newDataSize &gt; data.length) {
                    resizeDataArray(Math.max(newDataSize, data.length * 2));
                }
                System.arraycopy(dataPortion, 0, data, dataSize, dataPortion.length);
                dataSize = newDataSize;
            }
            // Try to decode the partial data until we get image size.
            if (!imageSizeAvilable()) {
                loadFrames();
            }
        } else if (data != null &amp;&amp; !fullDataReceived) {
            // null dataPortion means data completion
            if (data.length &gt; dataSize) {
                resizeDataArray(dataSize);
            }
            fullDataReceived = true;
        }
    }

    private void destroyLoader() {
        if (loader != null) {
            loader.cancel();
            loader = null;
        }
    }

    private void startLoader() {
        if (this.loader == null) {
            this.loader = new Service&lt;ImageFrame[]&gt;() {
                protected Task&lt;ImageFrame[]&gt; createTask() {
                    return new Task&lt;ImageFrame[]&gt;() {
                        protected ImageFrame[] call() throws Exception {
                            return loadFrames();
                        }
                    };
                }
            };
            this.loader.valueProperty().addListener((ov, old, frames) -&gt; {
                if ((frames != null) &amp;&amp; (loader != null)) {
                    setFrames(frames);
                }
            });
        }
        if (!this.loader.isRunning()) {
            this.loader.restart();
        }
    }

    private void resizeDataArray(int newDataSize) {
<A NAME="17"></A>        byte[] newData = new byte[newDataSize];
        System.arraycopy(data, 0, newData, 0, dataSize);
        data = newData;
    <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#17',2,'match36-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override protected void loadFromResource(String name) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;%X Load image from resource '%s'&quot;, hashCode(), name));
        }</B></FONT>

        String resourceName = WCGraphicsManager.getResourceName(name);
        InputStream in = getClass().getResourceAsStream(resourceName);
        if (in == null) {
            if (log.isLoggable(Level.FINE)) {
                log.fine(String.format(
                        &quot;%X Unable to open resource '%s'&quot;, hashCode(), resourceName));
            }
            return;
        }

        setFrames(loadFrames(in));
    }

    private synchronized ImageFrame[] loadFrames(InputStream in) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;%X Decoding frames&quot;, hashCode()));
        }
        try {
            return ImageStorage.loadAll(in, readerListener, 0, 0, true, 1.0f, false);
        } catch (ImageStorageException e) {
            return null; // consider image missing
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }

    private ImageFrame[] loadFrames() {
        return loadFrames(new ByteArrayInputStream(this.data, 0, this.dataSize));
    }

    private final ImageLoadListener readerListener = new ImageLoadListener() {
        @Override public void imageLoadProgress(ImageLoader l, float p) {
        }
        @Override public void imageLoadWarning(ImageLoader l, String warning) {
        }
        @Override public void imageLoadMetaData(ImageLoader l, ImageMetadata metadata) {
            if (log.isLoggable(Level.FINE)) {
                log.fine(String.format(&quot;%X Image size %dx%d&quot;,
                        hashCode(), metadata.imageWidth, metadata.imageHeight));
            }
            // The following lines is a workaround for RT-13475,
            // because image decoder does not report valid image size
            if (imageWidth &lt; metadata.imageWidth) {
                imageWidth = metadata.imageWidth;
            }
            if (imageHeight &lt; metadata.imageHeight) {
                imageHeight = metadata.imageHeight;
            }
            fileNameExtension = l.getFormatDescription().getExtensions().get(0);
        }
    };

    @Override protected int[] getImageSize() {
        final int[] size = THREAD_LOCAL_SIZE_ARRAY.get();
        size[0] = imageWidth;
        size[1] = imageHeight;
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;%X image size = %dx%d&quot;, hashCode(), size[0], size[1]));
        }
        return size;
    }

    private static final class Frame extends WCImageFrame {
        private WCImage image;

        private Frame(WCImage image, String extension) {
            this.image = image;
            this.image.setFileExtension(extension);
        }

        @Override public WCImage getFrame() {
            return image;
        }

        @Override public int[] getSize() {
            final int[] size = THREAD_LOCAL_SIZE_ARRAY.get();
            size[0] = image.getWidth();
            size[1] = image.getHeight();
            return size;
        }

        @Override protected void destroyDecodedData() {
            image = null;
        }
    }

    private synchronized void setFrames(ImageFrame[] frames) {
        this.frames = frames;
        this.images = null;
        frameCount = frames == null ? 0 : frames.length;
    }

    @Override protected int getFrameCount() {
        // Initiate full decode to get frame count.
        // NOTE: This method will be called just before
        // rendering the given image, so there will not
        // be any performance degrade while initiating a
        // full decode.
        if (fullDataReceived) {
            getImageFrame(0);
        }
        return frameCount;
    }

    // Avoid redundant decoding by async decoder threads, currently we don't
    // support per frame decoding.
    @Override protected synchronized WCImageFrame getFrame(int idx) {
        ImageFrame frame = getImageFrame(idx);
        if (frame != null) {
            if (log.isLoggable(Level.FINE)) {
                ImageStorage.ImageType type = frame.getImageType();
                log.fine(String.format(&quot;%X getFrame(%d): image type = %s&quot;,
                        hashCode(), idx, type));
            }
            PrismImage img = getPrismImage(idx, frame);
            return new Frame(img, fileNameExtension);
        }
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;%X FAILED getFrame(%d)&quot;, hashCode(), idx));
        }
        return null;
    }

    private synchronized ImageMetadata getFrameMetadata(int idx) {
        return frames != null &amp;&amp; frames.length &gt; idx &amp;&amp; frames[idx] != null ? frames[idx].getMetadata() : null;
    }

    @Override protected int getFrameDuration(int idx) {
        final ImageMetadata meta = getFrameMetadata(idx);
        int dur = (meta == null || meta.delayTime == null) ? 0 : meta.delayTime;
        // Many annoying ads try to animate too fast.
        // See RT-13535 or &lt;http://webkit.org/b/36082&gt;.
        if (dur &lt; 11) dur = 100;
        return dur;
    }

    // Per thread array cache to avoid repeated creation of int[]
    private static final ThreadLocal&lt;int[]&gt; THREAD_LOCAL_SIZE_ARRAY =
        new ThreadLocal&lt;int[]&gt; () {
            @Override protected int[] initialValue() {
                return new int[2];
            }
    };

    @Override protected int[] getFrameSize(int idx) {
        final ImageMetadata meta = getFrameMetadata(idx);
        if (meta == null) {
            return null;
        }
        final int[] size = THREAD_LOCAL_SIZE_ARRAY.get();
        size[0] = meta.imageWidth;
        size[1] = meta.imageHeight;
        return size;
    }

    @Override protected synchronized boolean getFrameCompleteStatus(int idx) {
        // For GIF images there is no better way to find whether a given frame
        // is completely decoded or not. As of now relying on framesDecoded
        // which will wait for all the frames to decode.
        return getFrameMetadata(idx) != null &amp;&amp; framesDecoded;
    }

    private synchronized ImageFrame getImageFrame(int idx) {
        if (!fullDataReceived) {
            startLoader();
        } else if (fullDataReceived &amp;&amp; !framesDecoded) {
            destroyLoader();
            setFrames(loadFrames()); // re-decode frames if they have been destroyed
            framesDecoded = true;
        }
        return (idx &gt;= 0) &amp;&amp; (this.frames != null) &amp;&amp; (this.frames.length &gt; idx)
                ? this.frames[idx]
                : null;
    }

    private synchronized PrismImage getPrismImage(int idx, ImageFrame frame) {
        if (this.images == null) {
            this.images = new PrismImage[this.frames.length];
        }
        if (this.images[idx] == null) {
            this.images[idx] = new WCImageImpl(frame);
        }
        return this.images[idx];
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/perf/PerfLogger.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.perf;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

public final class PerfLogger {
    private static Thread shutdownHook;
    private static Map&lt;PlatformLogger, PerfLogger&gt; loggers;

    private final HashMap&lt;String, ProbeStat&gt; probes =
            new HashMap&lt;String, ProbeStat&gt;();
    private final PlatformLogger log;
    private final boolean isEnabled; // needed at shutdown time

    /**
     * Finds or creates a logger with the given {@code log}.
     * In order the logger be enabled the {@code log} should be loggable.
     *
     * @param log associated {@code Logger}
     */
    public synchronized static PerfLogger getLogger(PlatformLogger log) {
        if (loggers == null) {
            loggers = new HashMap&lt;PlatformLogger, PerfLogger&gt;();
        }
        PerfLogger l = loggers.get(log);
        if (l == null) {
            l = new PerfLogger(log);
            loggers.put(log, l);
        }
        // Add the hook if at least one logger is enabled.
        if (l.isEnabled() &amp;&amp; shutdownHook == null) {
            shutdownHook = new Thread() {
                @Override
                public void run() {
                    for (PerfLogger l: loggers.values()) {
                        if (!l.isEnabled()) continue;
                        // Using stdout as logging might be off at shutdown time.
                        l.log(false);
                    }
                }
            };
            Runtime.getRuntime().addShutdownHook(shutdownHook);
        }
        return l;
    }

    /**
     * Finds or creates a logger with {@code Logger} named
     * com.sun.webkit.perf.{@code name}.
     *
     * @param name the {@code PerfLogger} short name
     */
    public synchronized static PerfLogger getLogger(String name) {
        return getLogger(PlatformLogger.getLogger(&quot;com.sun.webkit.perf.&quot; + name));
    }

    private PerfLogger(PlatformLogger log) {
        this.log = log;
        this.isEnabled = log.isLoggable(Level.FINE);
        startCount(&quot;TOTALTIME&quot;);
    }

    /**
     * The class contains perf statistics for a registered probe.
     */
    public static final class ProbeStat {
        private final String probe;
        private int count;
        private long totalTime;
        private long startTime;
        private boolean isRunning = false;

        private ProbeStat(String probe) {
            this.probe = probe;
        }

        public String getProbe() {
            return probe;
        }

        public int getCount() {
            return count;
        }

        public long getTotalTime() {
            return totalTime;
        }

        private void reset() {
            count = 0;
            totalTime = startTime = 0;
        }

        private void suspend() {
            if (isRunning) {
                totalTime += System.currentTimeMillis() - startTime;
                isRunning = false;
            }
        }

        private void resume() {
            isRunning = true;
            count++;
            startTime = System.currentTimeMillis();
        }

        private void snapshot() {
            if (isRunning) {
                totalTime += System.currentTimeMillis() - startTime;
                startTime = System.currentTimeMillis();
            }
        }

        @Override
        public String toString() {
            return super.toString() + &quot;[count=&quot; + count + &quot;, time=&quot; + totalTime + &quot;]&quot;;
        }
    }

    public boolean isEnabled() {
        return isEnabled;
    }

    private synchronized String fullName(String probe) {
        return log.getName() + &quot;.&quot; + probe;
    }

    private final Comparator timeComparator = (arg0, arg1) -&gt; {
        long t0 = probes.get((String)arg0).totalTime;
        long t1 = probes.get((String)arg1).totalTime;
        if (t0 &gt; t1) {
            return 1;
        } else if (t0 &lt; t1) {
            return -1;
        }
        return 0;
    };

    private final Comparator countComparator = (arg0, arg1) -&gt; {
        long c0 = probes.get((String)arg0).count;
        long c1 = probes.get((String)arg1).count;
        if (c0 &gt; c1) {
            return 1;
        } else if (c0 &lt; c1) {
            return -1;
        }
        return 0;
    };

    /**
     * Resets perf statistics.
     */
    public synchronized void reset() {
        for (Map.Entry&lt;String, ProbeStat&gt; entry: probes.entrySet()) {
            entry.getValue().reset();
        }
        startCount(&quot;TOTALTIME&quot;);
    }

    public synchronized static void resetAll() {
        for (PerfLogger l: loggers.values()) {
            l.reset();
        }
    }

    private synchronized ProbeStat registerProbe(String probe) {
        String p = probe.intern();
        if (probes.containsKey(p)) {
            log.fine(&quot;Warning: \&quot;&quot; + fullName(p) + &quot;\&quot; probe already exists&quot;);
        } else {
            log.fine(&quot;Registering \&quot;&quot; + fullName(p) + &quot;\&quot; probe&quot;);
        }
        ProbeStat stat = new ProbeStat(p);
        probes.put(p, stat);
        return stat;
    }

    public synchronized ProbeStat getProbeStat(String probe) {
        String p = probe.intern();
        ProbeStat s = probes.get(p);
        if (s != null) {
            s.snapshot();
        }
        return s;
    }

    /**
     * Starts count statistics for the probe with zero initial data.
     */
    public synchronized void startCount(String probe) {
        if (!isEnabled()) {
            return;
        }
        String p = probe.intern();
        ProbeStat stat = probes.get(p);
        if (stat == null) {
            stat = registerProbe(p);
        }
        stat.reset();
        stat.resume();
    }

    /**
     * Suspends count statistics for the probe.
     */
    public synchronized void suspendCount(String probe) {
        if (!isEnabled()) {
            return;
        }
        String p = probe.intern();
        ProbeStat stat = probes.get(p);
        if (stat != null) {
            stat.suspend();
        } else {
            log.fine(&quot;Warning: \&quot;&quot; + fullName(p) + &quot;\&quot; probe is not registered&quot;);
        }
    }

    /**
     * Resumes count statistics for the probe, or starts if it's not yet started.
     */
    public synchronized void resumeCount(String probe) {
        if (!isEnabled()) {
            return;
        }
        String p = probe.intern();
        ProbeStat stat = probes.get(p);
        if (stat == null) {
            stat = registerProbe(p);
        }
        stat.resume();
    }

    /**
     * Prints perf statistics to the buffer.
     */
    public synchronized void log(StringBuffer buf) {
        if (!isEnabled()) {
            return;
        }
        buf.append(&quot;=========== Performance Statistics =============\n&quot;);

        ProbeStat total = getProbeStat(&quot;TOTALTIME&quot;);

        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.addAll(probes.keySet());

        buf.append(&quot;\nTime:\n&quot;);
        Collections.sort(list, timeComparator);
        for (String p: list) {
            ProbeStat s = getProbeStat(p);
            buf.append(String.format(&quot;%s: %dms&quot;, fullName(p), s.totalTime));
            if (total.totalTime &gt; 0){
                buf.append(String.format(&quot;, %.2f%%%n&quot;, (float)100*s.totalTime/total.totalTime));
            } else {
                buf.append(&quot;\n&quot;);
            }
<A NAME="40"></A>        }

        buf.append(&quot;\nInvocations count:\n&quot;);
        <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#40',2,'match36-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Collections.sort(list, countComparator);
        for (String p: list) {
            buf.append(String.format(&quot;%s: %d%n&quot;, fullName(p), getProbeStat(p).count));
        }
        buf.append(&quot;================================================\n&quot;);
    }

    /**
     * Logs perf statistics.
     */
    pub</B></FONT>lic synchronized void log() {
        log(true);
    }

    private synchronized void log(boolean useLogger) {
        StringBuffer buf = new StringBuffer();
        log(buf);
        if (useLogger) {
            log.fine(buf.toString());
        } else {
            System.out.println(buf.toString());
            System.out.flush();
        }
    }

    /**
     * Logs perf statistics of all loggers.
     */
    public synchronized static void logAll() {
        for (PerfLogger l: loggers.values()) {
            l.log();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/javafx/scene/web/WebEngine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.web;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.scene.web.Debugger;
import com.sun.javafx.scene.web.Printable;
import com.sun.javafx.tk.TKPulseListener;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.webkit.*;
import com.sun.javafx.webkit.prism.PrismGraphicsManager;
import com.sun.javafx.webkit.prism.PrismInvoker;
import com.sun.javafx.webkit.prism.theme.PrismRenderer;
import com.sun.javafx.webkit.theme.RenderThemeImpl;
import com.sun.javafx.webkit.theme.Renderer;
import com.sun.webkit.*;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.network.URLs;
import com.sun.webkit.network.Util;
import javafx.animation.AnimationTimer;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.property.*;
import javafx.concurrent.Worker;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Rectangle2D;
import javafx.print.PageLayout;
import javafx.print.PrinterJob;
import javafx.scene.Node;
import javafx.util.Callback;
import org.w3c.dom.Document;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import static java.lang.String.format;
import java.lang.ref.WeakReference;
import java.net.MalformedURLException;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.PosixFilePermissions;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Objects;

import static com.sun.webkit.LoadListenerClient.*;

/**
 * {@code WebEngine} is a non-visual object capable of managing one Web page
 * at a time. It loads Web pages, creates their document models, applies
 * styles as necessary, and runs JavaScript on pages. It provides access
 * to the document model of the current page, and enables two-way
 * communication between a Java application and JavaScript code of the page.
 *
 * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
 * {@code WebEngine} object:
 * &lt;ul&gt;
 * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
 *     the {@code java.net} package for network access and protocol handling.
 * &lt;li&gt;From an in-memory String using the
 *     {@link #loadContent(java.lang.String, java.lang.String)} and
 *     {@link #loadContent(java.lang.String)} methods.
 * &lt;/ul&gt;
 * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
 * loading return immediately after scheduling a background job. To track
 * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
 * instance available from the {@link #getLoadWorker} method.
 *
 * &lt;p&gt;The following example changes the stage title when loading completes
 * successfully:
 * &lt;pre&gt;{@code
    import javafx.concurrent.Worker.State;
    final Stage stage;
    webEngine.getLoadWorker().stateProperty().addListener(
        new ChangeListener&lt;State&gt;() {
            public void changed(ObservableValue ov, State oldState, State newState) {
                if (newState == State.SUCCEEDED) {
                    stage.setTitle(webEngine.getLocation());
                }
            }
        });
    webEngine.load(&quot;http://javafx.com&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;A number of user interface callbacks may be registered with a
 * {@code WebEngine} object. These callbacks are invoked when a script running
 * on the page requests a user interface operation to be performed, for
 * example, opens a popup window or changes status text. A {@code WebEngine}
 * object cannot handle such requests internally, so it passes the request to
 * the corresponding callbacks. If no callback is defined for a specific
 * operation, the request is silently ignored.
 *
 * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 * with their corresponding {@code WebEngine} callbacks:
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 * &lt;tr&gt;
 *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;The following example shows a callback that resizes a browser window:
 * &lt;pre&gt;{@code
    Stage stage;
    webEngine.setOnResized(
        new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
            public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
                Rectangle2D r = ev.getData();
                stage.setWidth(r.getWidth());
                stage.setHeight(r.getHeight());
            }
        });
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 * (DOM) for their Web pages. The model can be accessed and modified using
 * Java DOM Core classes. The {@link #getDocument()} method provides access
 * to the root of the model. Additionally DOM Event specification is supported
 * to define event handlers in Java code.
 *
 * &lt;p&gt;The following example attaches a Java event listener to an element of
 * a Web page. Clicking on the element causes the application to exit:
 * &lt;pre&gt;{@code
    EventListener listener = new EventListener() {
        public void handleEvent(Event ev) {
            Platform.exit();
        }
    };

    Document doc = webEngine.getDocument();
    Element el = doc.getElementById(&quot;exit-app&quot;);
    ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 * the current page using the {@link #executeScript} method. For example:
 * &lt;pre&gt;{@code
    webEngine.executeScript(&quot;history.back()&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;The execution result is returned to the caller,
 * as described in the next section.
 *
 * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 *
 * JavaScript values are represented using the obvious Java classes:
 * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 * and a string becomes a {@code java.lang.String}.
 * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 * depending.
 * The undefined value maps to a specific unique String
 * object whose value is {@code &quot;undefined&quot;}.
 * &lt;p&gt;
 * If the result is a
 * JavaScript object, it is wrapped as an instance of the
 * {@link netscape.javascript.JSObject} class.
 * (As a special case, if the JavaScript object is
 * a {@code JavaRuntimeObject} as discussed in the next section,
 * then the original Java object is extracted instead.)
 * The {@code JSObject} class is a proxy that provides access to
 * methods and properties of its underlying JavaScript object.
 * The most commonly used {@code JSObject} methods are
 * {@link netscape.javascript.JSObject#getMember getMember}
 * (to read a named property),
 * {@link netscape.javascript.JSObject#setMember setMember}
 * (to set or define a property),
 * and {@link netscape.javascript.JSObject#call call}
 * (to call a function-valued property).
 * &lt;p&gt;
 * A DOM {@code Node} is mapped to an object that both extends
 * {@code JSObject} and implements the appropriate DOM interfaces.
 * To get a {@code JSObject} object for a {@code Node} just do a cast:
 * &lt;pre&gt;
 * JSObject jdoc = (JSObject) webEngine.getDocument();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In some cases the context provides a specific Java type that guides
 * the conversion.
 * For example if setting a Java {@code String} field from a JavaScript
 * expression, then the JavaScript value is converted to a string.
 *
 * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 *
 * The arguments of the {@code JSObject} methods {@code setMember} and
 * {@code call} pass Java objects to the JavaScript environment.
 * This is roughly the inverse of the JavaScript-to-Java mapping
 * described above:
 * Java {@code String},  {@code Number}, or {@code Boolean} objects
 * are converted to the obvious JavaScript values. A  {@code JSObject}
 * object is converted to the original wrapped JavaScript object.
 * Otherwise a {@code JavaRuntimeObject} is created.  This is
 * a JavaScript object that acts as a proxy for the Java object,
 * in that accessing properties of the {@code JavaRuntimeObject}
 * causes the Java field or method with the same name to be accessed.
 * &lt;p&gt; Note that the Java objects bound using
 * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 * {@link netscape.javascript.JSObject#call JSObject.call}
 * are implemented using weak references. This means that the Java object
 * can be garbage collected, causing subsequent accesses to the JavaScript
 * objects to have no effect.
 *
 * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 * method is useful to enable upcalls from JavaScript
 * into Java code, as illustrated by the following example. The Java code
 * establishes a new JavaScript object named {@code app}. This object has one
 * public member, the method {@code exit}.
 * &lt;pre&gt;&lt;code&gt;
public class JavaApplication {
    public void exit() {
        Platform.exit();
    }
}
...
JavaApplication javaApp = new JavaApplication();
JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
window.setMember(&quot;app&quot;, javaApp);
 * &lt;/code&gt;&lt;/pre&gt;
 * You can then refer to the object and the method from your HTML page:
 * &lt;pre&gt;{@code
    &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 * }&lt;/pre&gt;
 * &lt;p&gt;When a user clicks the link the application is closed.
 * &lt;p&gt;
 * Note that in the above example, the application holds a reference
 * to the {@code JavaApplication} instance. This is required for the callback
 * from JavaScript to execute the desired method.
 * &lt;p&gt; In the following example, the application does not hold a reference
 * to the Java object:
 * &lt;pre&gt;&lt;code&gt;
 * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 * window.setMember(&quot;app&quot;, new JavaApplication());
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 * the value may be garbage collected in next GC cycle.
 * &lt;p&gt;
 * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 * &lt;p&gt;
 * If there are multiple Java methods with the given name,
 * then the engine selects one matching the number of parameters
 * in the call.  (Varargs are not handled.) An unspecified one is
 * chosen if there are multiple ones with the correct number of parameters.
 * &lt;p&gt;
 * You can pick a specific overloaded method by listing the
 * parameter types in an &quot;extended method name&quot;, which has the
 * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you'd write the JavaScript expression:
 * &lt;pre&gt;
 * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The Java class and method must both be declared public.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * If any Java class passed to JavaScript is in a named module, then it must
 * be reflectively accessible to the {@code javafx.web} module.
 * A class is reflectively accessible if the module
 * {@link Module#isOpen(String,Module) opens} the containing package to at
 * least the {@code javafx.web} module.
 * Otherwise, the method will not be called, and no error or
 * warning will be produced.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 * the {@code module-info.java} might
 * look like this:
 * &lt;/p&gt;
 *
&lt;pre&gt;{@code module foo.app {
    opens com.foo to javafx.web;
}}&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Alternatively, a class is reflectively accessible if the module
 * {@link Module#isExported(String) exports} the containing package
 * unconditionally.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 * objects obtained from the {@code WebEngine} object.
 * @since JavaFX 2.0
 */
final public class WebEngine {
    static {
        Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());

        Invoker.setInvoker(new PrismInvoker());
        Renderer.setRenderer(new PrismRenderer());
        WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
        CursorManager.setCursorManager(new CursorManagerImpl());
        com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
        ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
        Utilities.setUtilities(new UtilitiesImpl());
    }

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(WebEngine.class.getName());

    /**
     * The number of instances of this class.
     * Used to start and stop the pulse timer.
     */
    private static int instanceCount = 0;

    /**
     * The node associated with this engine. There is a one-to-one correspondence
     * between the WebView and its WebEngine (although not all WebEngines have
     * a WebView, every WebView has one and only one WebEngine).
     */
    private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);

    /**
     * The Worker which shows progress of the web engine as it loads pages.
     */
    private final LoadWorker loadWorker = new LoadWorker();

    /**
     * The object that provides interaction with the native webkit core.
     */
    private final WebPage page;

    private final SelfDisposer disposer;

    private final DebuggerImpl debugger = new DebuggerImpl();

    private boolean userDataDirectoryApplied = false;


    /**
     * Returns a {@link javafx.concurrent.Worker} object that can be used to
     * track loading progress.
     *
     * @return the {@code Worker} object
     */
    public final Worker&lt;Void&gt; getLoadWorker() {
        return loadWorker;
    }


    /*
     * The final document. This may be null if no document has been loaded.
     */
    private final DocumentProperty document = new DocumentProperty();

    public final Document getDocument() { return document.getValue(); }

    /**
     * Document object for the current Web page. The value is {@code null}
     * if the Web page failed to load.
     *
     * @return the document property
     */
    public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
        return document;
    }


    /*
     * The location of the current page. This may return null.
     */
    private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);

    public final String getLocation() { return location.getValue(); }

    /**
     * URL of the current Web page. If the current page has no URL,
     * the value is an empty String.
     *
     * @return the location property
     */
    public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }

    private void updateLocation(String value) {
        this.location.set(value);
        this.document.invalidate(false);
        this.title.set(null);
    }


    /*
     * The page title.
     */
    private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);

    public final String getTitle() { return title.getValue(); }

    /**
     * Title of the current Web page. If the current page has no title,
     * the value is {@code null}.
     *
     * @return the title property
     */
    public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

    private void updateTitle() {
        title.set(page.getTitle(page.getMainFrame()));
    }

    //
    // Settings

    /**
     * Specifies whether JavaScript execution is enabled.
     *
     * @defaultValue true
     * @since JavaFX 2.2
     */
    private BooleanProperty javaScriptEnabled;

    public final void setJavaScriptEnabled(boolean value) {
        javaScriptEnabledProperty().set(value);
    }

    public final boolean isJavaScriptEnabled() {
        return javaScriptEnabled == null ? true : javaScriptEnabled.get();
    }

    public final BooleanProperty javaScriptEnabledProperty() {
        if (javaScriptEnabled == null) {
            javaScriptEnabled = new BooleanPropertyBase(true) {
                @Override public void invalidated() {
                    checkThread();
                    page.setJavaScriptEnabled(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;javaScriptEnabled&quot;;
                }
            };
        }
        return javaScriptEnabled;
    }

    /**
     * Location of the user stylesheet as a string URL.
     *
     * &lt;p&gt;This should be a local URL, i.e. either {@code 'data:'},
     * {@code 'file:'}, or {@code 'jar:'}. Remote URLs are not allowed
     * for security reasons.
     *
     * @defaultValue null
     * @since JavaFX 2.2
     */
    private StringProperty userStyleSheetLocation;

    public final void setUserStyleSheetLocation(String value) {
        userStyleSheetLocationProperty().set(value);
    }

    public final String getUserStyleSheetLocation() {
        return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
    }

    private byte[] readFully(BufferedInputStream in) throws IOException {
        final int BUF_SIZE = 4096;
        int outSize = 0;
        final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
        byte[] buffer = new byte[BUF_SIZE];

        while (true) {
            int nBytes = in.read(buffer);
            if (nBytes &lt; 0) break;

            byte[] chunk;
            if (nBytes == buffer.length) {
                chunk = buffer;
                buffer = new byte[BUF_SIZE];
            } else {
                chunk = new byte[nBytes];
                System.arraycopy(buffer, 0, chunk, 0, nBytes);
            }
            outList.add(chunk);
            outSize += nBytes;
        }

        final byte[] out = new byte[outSize];
        int outPos = 0;
        for (byte[] chunk : outList) {
            System.arraycopy(chunk, 0, out, outPos, chunk.length);
            outPos += chunk.length;
        }

        return out;
    }

    public final StringProperty userStyleSheetLocationProperty() {
        if (userStyleSheetLocation == null) {
            userStyleSheetLocation = new StringPropertyBase(null) {
                private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;

                @Override public void invalidated() {
                    checkThread();
                    String url = get();
                    String dataUrl;
                    if (url == null || url.length() &lt;= 0) {
                        dataUrl = null;
                    } else if (url.startsWith(DATA_PREFIX)) {
                        dataUrl = url;
                    } else if (url.startsWith(&quot;file:&quot;) ||
                               url.startsWith(&quot;jar:&quot;)  ||
                               url.startsWith(&quot;data:&quot;))
                    {
                        try {
                            URLConnection conn = URLs.newURL(url).openConnection();
                            conn.connect();

                            BufferedInputStream in =
                                    new BufferedInputStream(conn.getInputStream());
                            byte[] inBytes = readFully(in);
                            String out = Base64.getMimeEncoder().encodeToString(inBytes);
                            dataUrl = DATA_PREFIX + out;
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } else {
                        throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
                    }
                    page.setUserStyleSheetLocation(dataUrl);
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userStyleSheetLocation&quot;;
                }
            };
        }
        return userStyleSheetLocation;
    }

    /**
     * Specifies the directory to be used by this {@code WebEngine}
     * to store local user data.
     *
     * &lt;p&gt;If the value of this property is not {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in the respective directory.
     * If the value of this property is {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in an automatically selected system-dependent user- and
     * application-specific directory.
     *
     * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
     * page or executing a script for the first time, it checks whether
     * it can actually use the directory specified by this property.
     * If the check fails for some reason, the {@code WebEngine} invokes
     * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
     * if any, with a {@link WebErrorEvent} describing the reason.
     * If the invoked event handler modifies the {@code userDataDirectory}
     * property, the {@code WebEngine} retries with the new value as soon
     * as the handler returns. If the handler does not modify the
     * {@code userDataDirectory} property (which is the default),
     * the {@code WebEngine} continues without local user data.
     *
     * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
     * executing a script, changes made to this property have no effect
     * on where the {@code WebEngine} stores or will store local user
     * data.
     *
     * &lt;p&gt;Currently, the directory specified by this property is used
     * only to store the data that backs the {@code window.localStorage}
     * objects. In the future, more types of data can be added.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;File&gt; userDataDirectory =
            new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);

    public final File getUserDataDirectory() {
        return userDataDirectory.get();
    }

    public final void setUserDataDirectory(File value) {
        userDataDirectory.set(value);
    }

    public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
        return userDataDirectory;
    }

    /**
     * Specifies user agent ID string. This string is the value of the
     * {@code User-Agent} HTTP header.
     *
     * @defaultValue system dependent
     * @since JavaFX 8.0
     */
    private StringProperty userAgent;

    public final void setUserAgent(String value) {
        userAgentProperty().set(value);
    }

    public final String getUserAgent() {
        return userAgent == null ? page.getUserAgent() : userAgent.get();
    }

    public final StringProperty userAgentProperty() {
        if (userAgent == null) {
            userAgent = new StringPropertyBase(page.getUserAgent()) {
                @Override public void invalidated() {
                    checkThread();
                    page.setUserAgent(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userAgent&quot;;
                }
            };
        }
        return userAgent;
    }

    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }

    public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }

    /**
     * JavaScript {@code alert} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code alert} function.
     * @return the onAlert property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }

    public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }

    /**
     * JavaScript status handler property. This handler is invoked when
     * a script running on the Web page sets {@code window.status} property.
     * @return the onStatusChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);

    public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }

    public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }

    /**
     * JavaScript window resize handler property. This handler is invoked
     * when a script running on the Web page moves or resizes the
     * {@code window} object.
     * @return the onResized property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }

    public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }

    /**
     * JavaScript window visibility handler property. This handler is invoked
     * when a script running on the Web page changes visibility of the
     * {@code window} object.
     * @return the onVisibilityChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }


    private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
            = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
            p -&gt; WebEngine.this);

    public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }

    public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }

    /**
     * JavaScript popup handler property. This handler is invoked when a script
     * running on the Web page requests a popup to be created.
     * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
     * attach a visibility handler and optionally a resize handler, and return
     * the newly created engine. To block the popup, a handler should return
     * {@code null}.
     * &lt;p&gt;By default, a popup handler is installed that opens popups in this
     * {@code WebEngine}.
     *
     * @return the createPopupHandler property
     *
     * @see PopupFeatures
     */
    public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }


    private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
            = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);

    public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }

    public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }

    /**
     * JavaScript {@code confirm} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code confirm} function.
     * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
     * and return the user's choice.
     *
     * @return the confirmHandler property
     */
    public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }


    private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
            = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);

    public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }

    public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }

    /**
     * JavaScript {@code prompt} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code prompt} function.
     * &lt;p&gt;An implementation may display a dialog box with an text field,
     * and return the user's input.
     *
     * @return the promptHandler property
     * @see PromptData
     */
    public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }

    /**
     * The event handler called when an error occurs.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
            new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);

    public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
        return onError.get();
    }

    public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
        onError.set(handler);
    }

    public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
        return onError;
    }


    /**
     * Creates a new engine.
     */
    public WebEngine() {
        this(null, false);
    }

    /**
     * Creates a new engine and loads a Web page into it.
     *
     * @param url the URL of the web page to load
     */
    public WebEngine(String url) {
        this(url, true);
    }

    private WebEngine(String url, boolean callLoad) {
        checkThread();
        Accessor accessor = new AccessorImpl(this);
        page = new WebPage(
            new WebPageClientImpl(accessor),
            new UIClientImpl(accessor),
            null,
            new InspectorClientImpl(this),
            new ThemeClientImpl(accessor),
            false);
        page.addLoadListenerClient(new PageLoadListener(this));

        history = new WebHistory(page);

        disposer = new SelfDisposer(page);
        Disposer.addRecord(this, disposer);

        if (callLoad) {
            load(url);
        }

        if (instanceCount == 0 &amp;&amp;
            Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
        {
            PulseTimer.start();
        }
        instanceCount++;
    }

    /**
     * Loads a Web page into this engine. This method starts asynchronous
     * loading and returns immediately.
     * @param url URL of the web page to load
     */
    public void load(String url) {
        checkThread();
        loadWorker.cancelAndReset();

        if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
            url = &quot;&quot;;
        } else {
            // verify and, if possible, adjust the url on the Java
            // side, otherwise it may crash native code
            try {
                url = Util.adjustUrlForWebKit(url);
            } catch (MalformedURLException e) {
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        PAGE_STARTED, url, null, 0.0, 0);
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
                return;
            }
        }
        applyUserDataDirectory();
        page.open(page.getMainFrame(), url);
    }

    /**
     * Loads the given HTML content directly. This method is useful when you have an HTML
     * String composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the HTML text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous.
     *
     * @param content the HTML content to load
     */
    public void loadContent(String content) {
        loadContent(content, &quot;text/html&quot;);
    }

    /**
     * Loads the given content directly. This method is useful when you have content
     * composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the SVG text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous. This method also allows you to
     * specify the content type of the string being loaded, and so may optionally support
     * other types besides just HTML.
     *
     * @param content the HTML content to load
     * @param contentType the type of content to load
     */
    public void loadContent(String content, String contentType) {
        checkThread();
        loadWorker.cancelAndReset();
        applyUserDataDirectory();
        page.load(page.getMainFrame(), content, contentType);
    }

    /**
     * Reloads the current page, whether loaded from URL or directly from a String in
     * one of the {@code loadContent} methods.
     */
    public void reload() {
        // TODO what happens if this is called while currently loading a page?
        checkThread();
        page.refresh(page.getMainFrame());
    }

    private final WebHistory history;

    /**
     * Returns the session history object.
     *
     * @return history object
     * @since JavaFX 2.2
     */
    public WebHistory getHistory() {
        return history;
    }

    /**
     * Executes a script in the context of the current page.
     *
     * @param script the script
     * @return execution result, converted to a Java object using the following
     * rules:
     * &lt;ul&gt;
     * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
     * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
     * &lt;li&gt;JavaScript string to {@code java.lang.String}
     * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
     * &lt;li&gt;JavaScript {@code null} to {@code null}
     * &lt;li&gt;Most JavaScript objects get wrapped as
     *     {@code netscape.javascript.JSObject}
     * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
     *     {@code netscape.javascript.JSObject}, that also implement
     *     {@code org.w3c.dom.Node}
     * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
     *     which is used to wrap a Java object as a JavaScript value - in this
     *     case we just extract the original Java value.
     * &lt;/ul&gt;
     */
    public Object executeScript(String script) {
        checkThread();
        applyUserDataDirectory();
        return page.executeScript(page.getMainFrame(), script);
    }

    private long getMainFrame() {
        return page.getMainFrame();
    }

    WebPage getPage() {
        return page;
    }

    void setView(WebView view) {
        this.view.setValue(view);
    }

    private void stop() {
        checkThread();
        page.stop(page.getMainFrame());
    }

    private void applyUserDataDirectory() {
        if (userDataDirectoryApplied) {
            return;
        }
        userDataDirectoryApplied = true;
        File nominalUserDataDir = getUserDataDirectory();
        while (true) {
            File userDataDir;
            String displayString;
            if (nominalUserDataDir == null) {
                userDataDir = defaultUserDataDirectory();
                displayString = format(&quot;null (%s)&quot;, userDataDir);
            } else {
                userDataDir = nominalUserDataDir;
                displayString = userDataDir.toString();
            }
            logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
            String errorMessage;
            EventType&lt;WebErrorEvent&gt; errorType;
            Throwable error;
            try {
                userDataDir = DirectoryLock.canonicalize(userDataDir);
                File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
                File[] dirs = new File[] {
                    userDataDir,
                    localStorageDir,
                };
                for (File dir : dirs) {
                    createDirectories(dir);
                    // Additional security check to make sure the caller
                    // has permission to write to the target directory
                    File test = new File(dir, &quot;.test&quot;);
                    if (test.createNewFile()) {
                        test.delete();
                    }
                }
                disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);

                page.setLocalStorageDatabasePath(localStorageDir.getPath());
                page.setLocalStorageEnabled(true);

                logger.fine(&quot;User data directory [{0}] has &quot;
                        + &quot;been applied successfully&quot;, displayString);
                return;

            } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
                errorMessage = &quot;User data directory [%s] is already in use&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
                error = ex;
            } catch (IOException ex) {
                errorMessage = &quot;An I/O error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
                error = ex;
            } catch (SecurityException ex) {
                errorMessage = &quot;A security error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
                error = ex;
            }

            errorMessage = format(errorMessage, displayString);
            logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
            File oldNominalUserDataDir = nominalUserDataDir;
            fireError(errorType, errorMessage, error);
            nominalUserDataDir = getUserDataDirectory();
            if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
                logger.fine(&quot;Error handler did not modify user data directory, &quot;
                        + &quot;continuing without user data directory&quot;);
                return;
            } else {
                logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
                        + &quot;retrying&quot;, nominalUserDataDir);
                continue;
            }
        }
    }

    private static File defaultUserDataDirectory() {
        return new File(
                com.sun.glass.ui.Application.GetApplication()
                        .getDataDirectory(),
                &quot;webview&quot;);
    }

<A NAME="14"></A>    private static void createDirectories(File directory) throws IOException {
        Path path = directory.toPath();
        try {
            <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match36-0.html#14',2,'match36-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
                    PosixFilePermissions.fromString(&quot;rwx------&quot;)));
        } catch (UnsupportedOperationException ex) {
            Files.createDirectories(path);
        }
    }

    private v</B></FONT>oid fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
                           Throwable exception)
    {
        EventHandler&lt;WebErrorEvent&gt; handler = getOnError();
        if (handler != null) {
            handler.handle(new WebErrorEvent(this, eventType,
                                             message, exception));
        }
    }

    // for testing purposes only
    void dispose() {
        disposer.dispose();
    }

    private static final class SelfDisposer implements DisposerRecord {
        private WebPage page;
        private DirectoryLock userDataDirectoryLock;

        private SelfDisposer(WebPage page) {
            this.page = page;
        }

        @Override public void dispose() {
            if (page == null) {
                return;
            }
            page.dispose();
            page = null;
            if (userDataDirectoryLock != null) {
                userDataDirectoryLock.close();
            }
            instanceCount--;
            if (instanceCount == 0 &amp;&amp;
                Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
            {
                PulseTimer.stop();
            }
        }
    }

    private static final class AccessorImpl extends Accessor {
        private final WeakReference&lt;WebEngine&gt; engine;

        private AccessorImpl(WebEngine w) {
            this.engine = new WeakReference&lt;WebEngine&gt;(w);
        }

        @Override public WebEngine getEngine() {
            return engine.get();
        }

        @Override public WebPage getPage() {
            WebEngine w = getEngine();
            return w == null ? null : w.page;
        }

        @Override public WebView getView() {
            WebEngine w = getEngine();
            return w == null ? null : w.view.get();
        }

        @Override public void addChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().add(child);
            }
        }

        @Override public void removeChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().remove(child);
            }
        }

        @Override public void addViewListener(InvalidationListener l) {
            WebEngine w = getEngine();
            if (w != null) {
                w.view.addListener(l);
            }
        }
    }

    /**
     * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
     */
    private static final class PulseTimer {

        // Used just to guarantee constant pulse activity. See RT-14433.
        private static final AnimationTimer animation =
            new AnimationTimer() {
                @Override public void handle(long l) {}
            };

        private static final TKPulseListener listener =
                () -&gt; {
                    // Note, the timer event is executed right in the notifyTick(),
                    // that is during the pulse event. This makes the timer more
                    // repsonsive, though prolongs the pulse. So far it causes no
                    // problems but nevertheless it should be kept in mind.

                    // Execute notifyTick in runLater to run outside of pulse so
                    // that events will run in order and be able to display dialogs
                    // or call other methods that require a nested event loop.
                    Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
                };

        private static void start(){
            Toolkit.getToolkit().addSceneTkPulseListener(listener);
            animation.start();
        }

        private static void stop() {
            Toolkit.getToolkit().removeSceneTkPulseListener(listener);
            animation.stop();
        }
    }

    static void checkThread() {
        Toolkit.getToolkit().checkFxUserThread();
    }


    /**
     * The page load event listener. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class PageLoadListener implements LoadListenerClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private PageLoadListener(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override public void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double progress, int errorCode)
        {
            WebEngine w = engine.get();
            if (w != null) {
                w.loadWorker.dispatchLoadEvent(frame, state, url,
                        contentType, progress, errorCode);
            }
        }

        @Override public void dispatchResourceLoadEvent(long frame,
                int state, String url, String contentType, double progress,
                int errorCode)
        {
        }
    }


    private final class LoadWorker implements Worker&lt;Void&gt; {

        private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
        @Override public final State getState() { checkThread(); return state.get(); }
        @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
        private void updateState(State value) {
            checkThread();
            this.state.set(value);
            running.set(value == State.SCHEDULED || value == State.RUNNING);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
        @Override public final Void getValue() { checkThread(); return value.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
        @Override public final Throwable getException() { checkThread(); return exception.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
        @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
        @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
        @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
        @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
        @Override public final double getProgress() { checkThread(); return progress.get(); }
        @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
        private void updateProgress(double p) {
            totalWorkToBeDone.set(100.0);
            workDone.set(p * 100.0);
            progress.set(p);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
        @Override public final boolean isRunning() { checkThread(); return running.get(); }
        @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
        @Override public final String getMessage() { return message.get(); }
        @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
        @Override public final String getTitle() { return title.get(); }
        @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

        /**
         * Cancels the loading of the page. If called after the page has already
         * been loaded, then this call takes no effect.
         */
        @Override public boolean cancel() {
            if (isRunning()) {
                stop(); // this call indirectly sets state
                return true;
            } else {
                return false;
            }
        }

        private void cancelAndReset() {
            cancel();
            exception.set(null);
            message.set(&quot;&quot;);
            totalWorkToBeDone.set(-1);
            workDone.set(-1);
            progress.set(-1);
            updateState(State.READY);
            running.set(false);
        }

        private void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double workDone, int errorCode)
        {
            if (frame != getMainFrame()) {
                return;
            }
            switch (state) {
                case PAGE_STARTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    updateProgress(0.0);
                    updateState(State.SCHEDULED);
                    updateState(State.RUNNING);
                    break;
                case PAGE_REDIRECTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    break;
                case PAGE_REPLACED:
                    message.set(&quot;Replaced &quot; + url);
                    // Update only the location, don't change title or document.
                    WebEngine.this.location.set(url);
                    break;
                case PAGE_FINISHED:
                    message.set(&quot;Loading complete&quot;);
                    updateProgress(1.0);
                    updateState(State.SUCCEEDED);
                    break;
                case LOAD_FAILED:
                    message.set(&quot;Loading failed&quot;);
                    exception.set(describeError(errorCode));
                    updateState(State.FAILED);
                    break;
                case LOAD_STOPPED:
                    message.set(&quot;Loading stopped&quot;);
                    updateState(State.CANCELLED);
                    break;
                case PROGRESS_CHANGED:
                    updateProgress(workDone);
                    break;
                case TITLE_RECEIVED:
                    updateTitle();
                    break;
                case DOCUMENT_AVAILABLE:
                    if (this.state.get() != State.RUNNING) {
                        // We have empty load; send a synthetic event (RT-32097)
                        dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
                    }
                    document.invalidate(true);
                    break;
            }
        }

        private Throwable describeError(int errorCode) {
            String reason = &quot;Unknown error&quot;;

            switch (errorCode) {
                case UNKNOWN_HOST:
                    reason = &quot;Unknown host&quot;;
                    break;
                case MALFORMED_URL:
                    reason = &quot;Malformed URL&quot;;
                    break;
                case SSL_HANDSHAKE:
                    reason = &quot;SSL handshake failed&quot;;
                    break;
                case CONNECTION_REFUSED:
                    reason = &quot;Connection refused by server&quot;;
                    break;
                case CONNECTION_RESET:
                    reason = &quot;Connection reset by server&quot;;
                    break;
                case NO_ROUTE_TO_HOST:
                    reason = &quot;No route to host&quot;;
                    break;
                case CONNECTION_TIMED_OUT:
                    reason = &quot;Connection timed out&quot;;
                    break;
                case PERMISSION_DENIED:
                    reason = &quot;Permission denied&quot;;
                    break;
                case INVALID_RESPONSE:
                    reason = &quot;Invalid response from server&quot;;
                    break;
                case TOO_MANY_REDIRECTS:
                    reason = &quot;Too many redirects&quot;;
                    break;
                case FILE_NOT_FOUND:
                    reason = &quot;File not found&quot;;
                    break;
            }
            return new Throwable(reason);
        }
    }


    private final class DocumentProperty
            extends ReadOnlyObjectPropertyBase&lt;Document&gt; {

        private boolean available;
        private Document document;

        private void invalidate(boolean available) {
            if (this.available || available) {
                this.available = available;
                this.document = null;
                fireValueChangedEvent();
            }
        }

        public Document get() {
            if (!this.available) {
                return null;
            }
            if (this.document == null) {
                this.document = page.getDocument(page.getMainFrame());
                if (this.document == null) {
                    this.available = false;
                }
            }
            return this.document;
        }

        public Object getBean() {
            return WebEngine.this;
        }

        public String getName() {
            return &quot;document&quot;;
        }
    }


    /*
     * Returns the debugger associated with this web engine.
     * The debugger is an object that can be used to debug
     * the web page currently loaded into the web engine.
     * &lt;p&gt;
     * All methods of the debugger must be called on
     * the JavaFX Application Thread.
     * The message callback object registered with the debugger
     * is always called on the JavaFX Application Thread.
     * @return the debugger associated with this web engine.
     *         The return value cannot be {@code null}.
     */
    Debugger getDebugger() {
        return debugger;
    }

    /**
     * The debugger implementation.
     */
    private final class DebuggerImpl implements Debugger {

        private boolean enabled;
        private Callback&lt;String,Void&gt; messageCallback;


        @Override
        public boolean isEnabled() {
            checkThread();
            return enabled;
        }

        @Override
        public void setEnabled(boolean enabled) {
            checkThread();
            if (enabled != this.enabled) {
                if (enabled) {
                    page.setDeveloperExtrasEnabled(true);
                    page.connectInspectorFrontend();
                } else {
                    page.disconnectInspectorFrontend();
                    page.setDeveloperExtrasEnabled(false);
                }
                this.enabled = enabled;
            }
        }

        @Override
        public void sendMessage(String message) {
            checkThread();
            if (!enabled) {
                throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
            }
            if (message == null) {
                throw new NullPointerException(&quot;message is null&quot;);
            }
            page.dispatchInspectorMessageFromFrontend(message);
        }

        @Override
        public Callback&lt;String,Void&gt; getMessageCallback() {
            checkThread();
            return messageCallback;
        }

        @Override
        public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
            checkThread();
            messageCallback = callback;
        }
    }

    /**
     * The inspector client implementation. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class InspectorClientImpl implements InspectorClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private InspectorClientImpl(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override
        public boolean sendMessageToFrontend(final String message) {
            boolean result = false;
            WebEngine webEngine = engine.get();
            if (webEngine != null) {
                final Callback&lt;String,Void&gt; messageCallback =
                        webEngine.debugger.messageCallback;
                if (messageCallback != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        messageCallback.call(message);
                        return null;
                    }, webEngine.page.getAccessControlContext());
                    result = true;
                }
            }
            return result;
        }
    }

    private static final boolean printStatusOK(PrinterJob job) {
        switch (job.getJobStatus()) {
            case NOT_STARTED:
            case PRINTING:
                return true;
            default:
                return false;
        }
    }

    /**
     * Prints the current Web page using the given printer job.
     * &lt;p&gt;This method does not modify the state of the job, nor does it call
     * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
     *
     * @param job printer job used for printing
     * @since JavaFX 8.0
     */
    public void print(PrinterJob job) {
        if (!printStatusOK(job)) {
            return;
        }

        PageLayout pl = job.getJobSettings().getPageLayout();
        float width = (float) pl.getPrintableWidth();
        float height = (float) pl.getPrintableHeight();
        int pageCount = page.beginPrinting(width, height);

        for (int i = 0; i &lt; pageCount; i++) {
            if (printStatusOK(job)) {
                Node printable = new Printable(page, i, width);
                job.printPage(printable);
            }
        }
        page.endPrinting();
    }
}
</PRE>

</BODY>
</HTML>
