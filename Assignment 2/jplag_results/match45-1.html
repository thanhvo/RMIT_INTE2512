<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/com/sun/javafx/logging/PrintLogger.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="16"></A> * questions.
 */

<FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#16',2,'match45-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.logging;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Logs information on a per-pulse basis. When doing performance analysis, a very
 * easy thing to start with is to run with the PulseLogger enabled, such that various
 * statistics related to the scene graph and the pulse are recorded and dumped to
 * the log.
 * &lt;p&gt;
 * The pulse logger is designed in such a way as to gather all of the pulse statistics
 * together even though half of the pulse occurs on the FX thread and half on the
 * render thread, and therefore two sets of pulse data are being accumulated
 * concurrently. The {@code pulseStart}, {@code pulseEnd}, {@code renderStart},
 * and {@code renderEnd} methods must be called appropriately by the runtime
 * to ensure that the logging system works correctly.
 */
class PrintLogger extends Logger {

    /**
     * A reference to the pulse logger. This will be null if pulse logging
     * is not enabled.
     */
    private static PrintLogger printLogger;

    /**
     * A time in milliseconds which defines the threshold. If a pulse lasts &lt;em&gt;longer&lt;/em&gt; than
     * the threshold, then it is logged, otherwise an abbreviated representation including
     * only the time of the pulse is logged.
     */
    private static long THRESHOLD = (long)
            AccessController.doPrivileged</B></FONT>((PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;javafx.pulseLogger.threshold&quot;, 17));

    /**
     * Optionally exit after a given number of pulses
     */
    private static final int EXIT_ON_PULSE =
            AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;javafx.pulseLogger.exitOnPulse&quot;, 0));

    /**
     * We have a simple counter that keeps track of the current pulse number.
     * INTER_PULSE_DATA is used to mark data that comes between pulses.
     */
    private int pulseCount = 1;
    private static final int INTER_PULSE_DATA = -1;

    /**
     * When printing the truncated form of the pulse, we just print one truncated
     * form after another, such as:
     *
     * [5][2][4]
     *
     * This way we don't cause the console to scroll far vertically in the case of fast
     * pulses. We do this so that relevant information (pulses that exceed the threshold)
     * is easy to find and remains visible as long as possible in the console. However,
     * we don't want to scroll too far off to the right either, so we keep track of
     * how many &quot;quick pulses&quot; have happened in a row. When we've exceeded some fixed
     * number (20, say) then we will insert a newline into the log.
     */
    private volatile int wrapCount = 0;

    /**
     * References to PulseData for the FX thread (fxData) and the Render thread (renderData).
     */
    private volatile PulseData fxData, renderData;

    /**
     * Keeps track of the start of the previous pulse, such that we can print out
     * the time interval between the start of pulses.
     */
    private long lastPulseStartTime;

    class ThreadLocalData {
        String  phaseName;
        long    phaseStart;
    }

    private Thread fxThread;
    private final ThreadLocal&lt;ThreadLocalData&gt; phaseData =
        new ThreadLocal() {
            @Override
            public ThreadLocalData initialValue() {
                return new ThreadLocalData();
            }
        };


    /**
     * The queue of all PulseData objects, both available and those in use.
     * New PulseData objects are allocated from head if the state is AVAILABLE.
     * They are re-linked at tail with the state INCOMPLETE. Once fully processed
     * they will change their state back to AVAILABLE and will become ready for reuse.
     */
    private PulseData head;
    private PulseData tail;

    /**
     * A synchronization object for printing arbitrage.
     */
    private AtomicInteger active;

    /**
     * PulseData object states
     */
    private static final int AVAILABLE = 0;
    private static final int INCOMPLETE = 1;
    private static final int COMPLETE = 2;

    /**
     * Disallow instantiation.
     */
    private PrintLogger() {
        head = new PulseData();
        tail = new PulseData();
        head.next = tail;
        active = new AtomicInteger(0);
    }

    public static Logger getInstance() {
        if (printLogger == null) {
            boolean enabled = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.pulseLogger&quot;));
            if (enabled) {
                printLogger = new PrintLogger();
            }
        }
        return printLogger;
    }

    /**
     * Allocate and initialize a PulseData object
     */
    private PulseData allocate(int n) {
        PulseData res;
        if (head != tail &amp;&amp; head.state == AVAILABLE) {
            res = head;
            head = head.next;
            res.next = null;
        }
        else {
            res = new PulseData();
        }
        tail.next = res;
        tail = res;
        res.init(n);
        return res;
    }

    /**
     * &lt;strong&gt;MUST&lt;/strong&gt; be called at the start of every pulse.
     * This method will initialize the fxData buffer so that subsequent
     * calls to fxMessage will write to this buffer.
     */
    @Override
    public void pulseStart() {
        if (fxThread == null) {
            fxThread = Thread.currentThread();
        }
        if (fxData != null) {
            // Inter pulse data
            fxData.state = COMPLETE;
            if (active.incrementAndGet() == 1) {
                fxData.printAndReset();
                active.decrementAndGet();
            }
        }
        fxData = allocate(pulseCount++);
        if (lastPulseStartTime &gt; 0) {
            fxData.interval = (fxData.startTime - lastPulseStartTime)/1000000L;
        }
        lastPulseStartTime = fxData.startTime;
    }

    /**
     * &lt;strong&gt;Must&lt;/strong&gt; be called before any set of render jobs
     * for a given pulse begin. This method will initialize the
     * renderData buffer so that subsequent calls to renderMessage
     * will write to this buffer. I have found that sometimes renderMessage
     * is called without a pulse being started. Such cases are exceptional
     * and appear to happen only at startup, and such cases are simply not
     * logged.
     */
    @Override
    public void renderStart() {
        newPhase(null); // finish the current phase on the FX thread
        fxData.pushedRender = true;
        renderData = fxData;
        active.incrementAndGet();
    }

    /**
     * &lt;strong&gt;Must&lt;/strong&gt; be called at the end of the pulse. If
     * there was no rendering started during this pulse, then this
     * method will cause the pulse data to be logged. Otherwise, the
     * pulse data is logged when rendering is ended. However, as soon
     * as pulseEnd is called, we are ready for another call to pulseStart.
     */
    @Override
    public void pulseEnd() {
        if (fxData != null &amp;&amp; !fxData.pushedRender) {
            fxData.state = COMPLETE;
            if (active.incrementAndGet() == 1) {
                fxData.printAndReset();
                active.decrementAndGet();
            }
        }
        fxData = null;
    }

    /**
     * &lt;strong&gt;Must&lt;/strong&gt; be called at the end of rendering, if a previous
     * call to {@link #renderStart()} had been made. This will cause the pulse
     * data to be logged.
     */
    @Override
    public void renderEnd() {
        newPhase(null); // finish the current phase on the render thread
        renderData.state = COMPLETE;
        for (;;) {
            renderData.printAndReset();
            if (active.decrementAndGet() == 0) {
                break;
            }
            renderData = renderData.next;
        }
        renderData = null;
    }

    /**
     * Adds a message to the log for the pulse.
     * @param message The message to log. A newline will be added automatically.
     */
    @Override
    public void addMessage(String message) {
        PulseData pulseData;
        if (fxThread == null || Thread.currentThread() == fxThread) {
            if (fxData == null) {
                fxData = allocate(INTER_PULSE_DATA);
            }
            pulseData = fxData;
        }
        else {
            pulseData = renderData;
        }
        if (pulseData == null) {
            return;
        }
        pulseData.message
            .append(&quot;T&quot;)
            .append(Thread.currentThread().getId())
            .append(&quot; : &quot;)
            .append(message)
            .append(&quot;\n&quot;);
    }

    /**
     * Increments the given named per-pulse counter.
     * @param counter The name for the counter.
     */
    @Override
    public void incrementCounter(String counter) {
        PulseData pulseData;
        if (fxThread == null || Thread.currentThread() == fxThread) {
            if (fxData == null) {
                fxData = allocate(INTER_PULSE_DATA);
            }
            pulseData = fxData;
        }
        else {
            pulseData = renderData;
        }
        if (pulseData == null) {
            return;
        }
        Map&lt;String,Counter&gt; counters = pulseData.counters;
        Counter cval = counters.get(counter);
        if (cval == null) {
            cval = new Counter();
            counters.put(counter, cval);
        }
        cval.value += 1;
    }

    @Override
    public void newPhase(String name) {
        long curTime = System.nanoTime();

        ThreadLocalData curPhase = phaseData.get();
        if (curPhase.phaseName != null) {
            PulseData pulseData = Thread.currentThread() == fxThread ? fxData : renderData;
            if (pulseData != null) {
                pulseData.message
                    .append(&quot;T&quot;)
                    .append(Thread.currentThread().getId())
                    .append(&quot; (&quot;).append((curPhase.phaseStart-pulseData.startTime)/1000000L)
                    .append(&quot; +&quot;).append((curTime - curPhase.phaseStart)/1000000L).append(&quot;ms): &quot;)
                    .append(curPhase.phaseName)
                    .append(&quot;\n&quot;);
            }
        }
        curPhase.phaseName = name;
        curPhase.phaseStart = curTime;
    }

    /**
     *  A mutable integer to be used in the counter map
     */
    private static class Counter {
        int     value;
    }

    /**
     * The data we collect per pulse. We store the pulse number
     * associated with this pulse, along with what time it
     * started at and the interval since the previous pulse.
     * We also maintain the message buffer and counters.
     */
    private final class PulseData {
        PulseData next;
        volatile int state = AVAILABLE;
        long startTime;
        long interval;
        int pulseCount;
        boolean pushedRender;
        StringBuffer message = new StringBuffer();
        Map&lt;String,Counter&gt; counters = new ConcurrentHashMap();

        void init(int n) {
            state = INCOMPLETE;
            pulseCount = n;
            startTime = System.nanoTime();
            interval = 0;
            pushedRender = false;
        }

        void printAndReset() {
            long endTime = System.nanoTime();
            long totalTime = (endTime - startTime)/1000000L;

            if (state != COMPLETE) {
                System.err.println(&quot;\nWARNING: logging incomplete state&quot;);
            }

            if (totalTime &lt;= THRESHOLD) {
                // Don't print inter pulse data
                if (pulseCount != INTER_PULSE_DATA) {
                    System.err.print((wrapCount++ % 10 == 0 ? &quot;\n[&quot; : &quot;[&quot;) + pulseCount+ &quot; &quot; + interval + &quot;ms:&quot; + totalTime + &quot;ms]&quot;);
                }
            }
            else {
                if (pulseCount == INTER_PULSE_DATA) {
                    System.err.println(&quot;\n\nINTER PULSE LOG DATA&quot;);
                }
                else {
                    System.err.print(&quot;\n\nPULSE: &quot; + pulseCount +
                            &quot; [&quot; + interval + &quot;ms:&quot; + totalTime + &quot;ms]&quot;);
                    if (!pushedRender) {
                        System.err.print(&quot; Required No Rendering&quot;);
                    }
                    System.err.println();
                }
                System.err.print(message);
                if (!counters.isEmpty()) {
                    System.err.println(&quot;Counters:&quot;);
                    List&lt;Map.Entry&lt;String,Counter&gt;&gt; entries = new ArrayList(counters.entrySet());
                    Collections.sort(entries, (a, b) -&gt; a.getKey().compareTo(b.getKey()));
                    for (Map.Entry&lt;String, Counter&gt; entry : entries) {
                        System.err.println(&quot;\t&quot; + entry.getKey() + &quot;: &quot; + entry.getValue().value);
                    }
                }
                wrapCount = 0;
            }

            // Reset the state
            message.setLength(0);
            counters.clear();
            state = AVAILABLE;
            if (EXIT_ON_PULSE &gt; 0 &amp;&amp; pulseCount &gt;= EXIT_ON_PULSE) {
                System.err.println(&quot;Exiting after pulse #&quot; + pulseCount);
                System.exit(0);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/property/ReadOnlyMapPropertyBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.beans.property;

import com.sun.javafx.binding.MapExpressionHelper;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableMap;

/**
 * Base class for all readonly properties wrapping an {@link javafx.collections.ObservableMap}.
 * This class provides a default implementation to attach listener.
 *
 * @see ReadOnlyMapProperty
 * @since JavaFX 2.1
 */
public abstract class ReadOnlyMapPropertyBase&lt;K, V&gt; extends ReadOnlyMapProperty&lt;K, V&gt; {

    private MapExpressionHelper&lt;K, V&gt; helper;

    @Override
    public void addListener(InvalidationListener listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(InvalidationListener listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    @Override
    public void addListener(ChangeListener&lt;? super ObservableMap&lt;K, V&gt;&gt; listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(ChangeListener&lt;? super ObservableMap&lt;K, V&gt;&gt; listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    @Override
    public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    /**
     * This method needs to be called if the reference to the
     * {@link javafx.collections.ObservableList} changes.
     *
     * It sends notifications to all attached
     * {@link javafx.beans.InvalidationListener InvalidationListeners},
     * {@link javafx.beans.value.ChangeListener ChangeListeners}, and
     * {@link javafx.collections.ListChangeListener}.
     *
<A NAME="6"></A>     * This method needs to be called, if the value of this property changes.
     */
    protected void fireValueChangedEvent() {
        <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#6',2,'match45-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MapExpressionHelper.fireValueChangedEvent(helper);
    }

    /**
     * This method needs to be called if the content of the referenced
     * {@link javafx.collections.ObservableList} changes.
     *
     * Sends notifications to all attached
     * {@link javafx.beans.InvalidationListener InvalidationListeners},
     * {@link javafx.beans.value.ChangeListener ChangeListeners}, and
     * {@link javafx.collections.ListChangeListener}.
     *
     * This method is called when the content of the list changes.
     *
     * @param change the change that needs to be propagated
     */
    protected void fireValueChangedEvent(MapChangeListener.Change&lt;? extends K, ? extends V&gt; change) {
        MapExpressionHelper.fireValueChangedEvent(helper, change);
    }



}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/ContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Direction;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.*;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.stage.Window;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * This is a the SkinBase for ContextMenu based controls so that the CSS parts
 * work right, because otherwise we would have to copy the Keys from there to here.
 */
public class ContextMenuContent extends Region {

    private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;

    private ContextMenu contextMenu;

    /***************************************************************************
     * UI subcomponents
     **************************************************************************/

    private double maxGraphicWidth = 0; // we keep this margin to left for graphic
    private double maxRightWidth = 0;
    private double maxLabelWidth = 0;
    private double maxRowHeight = 0;
    private double maxLeftWidth = 0;
    private double oldWidth = 0;

    private Rectangle clipRect;
    MenuBox itemsContainer;
    private ArrowMenuItem upArrow;
    private ArrowMenuItem downArrow;

    /*
     * We maintain a current focused index which is used
     * in keyboard navigation of menu items.
     */
    private int currentFocusedIndex = -1;

    private boolean itemsDirty = true;
    private InvalidationListener popupShowingListener = arg0 -&gt; {
        updateItems();
    };
    private WeakInvalidationListener weakPopupShowingListener =
            new WeakInvalidationListener(popupShowingListener);


    /***************************************************************************
     * Constructors
     **************************************************************************/
    public ContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        clipRect = new Rectangle();
         clipRect.setSmooth(false);
        itemsContainer = new MenuBox();
//        itemsContainer = new VBox();
        itemsContainer.setClip(clipRect);

        upArrow = new ArrowMenuItem(this);
        upArrow.setUp(true);
        upArrow.setFocusTraversable(false);

        downArrow = new ArrowMenuItem(this);
        downArrow.setUp(false);
        downArrow.setFocusTraversable(false);
        getChildren().add(itemsContainer);
        getChildren().add(upArrow);
        getChildren().add(downArrow);
        initialize();
        setUpBinds();
        updateItems();
        // RT-20197 add menuitems only on first show.
        popupMenu.showingProperty().addListener(weakPopupShowingListener);

        /*
        ** only add this if we're on an embedded
        ** platform that supports 5-button navigation
        */
        if (Utils.isTwoLevelFocus()) {
            new TwoLevelFocusPopupBehavior(this);
        }
    }

    //For access from controls
    public VBox getItemsContainer() {
        return itemsContainer;
    }
    //For testing purpose only
    int getCurrentFocusIndex() {
        return currentFocusedIndex;
    }
    //For testing purpose only
    void setCurrentFocusedIndex(int index) {
        if (index &lt; itemsContainer.getChildren().size()) {
            currentFocusedIndex = index;
        }
    }

    private void updateItems() {
        if (itemsDirty) {
            updateVisualItems();
            itemsDirty = false;
        }
    }

    private void computeVisualMetrics() {
        maxRightWidth = 0;
        maxLabelWidth = 0;
        maxRowHeight = 0;
        maxGraphicWidth = 0;
        maxLeftWidth = 0;

        for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node child = itemsContainer.getChildren().get(i);
            if (child instanceof MenuItemContainer) {
                final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);

                if (! menuItemContainer.isVisible()) continue;

                double alt = -1;
                Node n = menuItemContainer.left;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.graphic;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.label;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) {
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.right;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }
            }
        }

        // Fix for RT-38838.
        // This fixes the issue where CSS is applied to a menu after it has been
        // showing, resulting in its bounds changing. In this case, we need to
        // shift the submenu such that it is properly aligned with its parent menu.
        //
        // To do this, we must firstly determine if the open submenu is shifted
        // horizontally to appear on the other side of this menu, as this is the
        // only situation where shifting has to happen. If so, we need to check
        // if we should shift the submenu due to changes in width.
        //
        // We need to get the parent menu of this contextMenu, so that we only
        // modify the X value in the following conditions:
        // 1) There exists a parent menu
        // 2) The parent menu is in the correct position (i.e. to the left of this
        //    menu in normal LTR systems).
        final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
        Window ownerWindow = contextMenu.getOwnerWindow();
        if (ownerWindow instanceof ContextMenu) {
            if (contextMenu.getX() &lt; ownerWindow.getX()) {
                if (oldWidth != newWidth) {
                    contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
                }
            }
        }

        oldWidth = newWidth;
    }

    private void updateVisualItems() {
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();

        disposeVisualItems();

        for (int row = 0; row &lt; getItems().size(); row++) {
            final MenuItem item = getItems().get(row);
            if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
                continue;
            }

            if (item instanceof SeparatorMenuItem) {
                // we don't want the hover highlight for separators, so for
                // now this is the simplest approach - just remove the
                // background entirely. This may cause issues if people
                // intend to style the background differently.
                Node node = ((CustomMenuItem) item).getContent();
                node.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(node);
                // Add the (separator) menu item to properties map of this node.
                // Special casing this for separator :
                // This allows associating this container with SeparatorMenuItem.
                node.getProperties().put(MenuItem.class, item);
            } else {
                MenuItemContainer menuItemContainer = new MenuItemContainer(item);
                menuItemContainer.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(menuItemContainer);
            }
        }

        // Add the Menu to properties map of this skin. Used by QA for testing
        // This enables associating a parent menu for this skin showing menu items.
        if (getItems().size() &gt; 0) {
            final MenuItem item = getItems().get(0);
            getProperties().put(Menu.class, item.getParentMenu());
        }

        // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
        NodeHelper.reapplyCSS(this);
    }

    private void disposeVisualItems() {
        // clean up itemsContainer
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
        for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
            Node n = itemsContainerChilder.get(i);

            if (n instanceof MenuItemContainer) {
                MenuItemContainer container = (MenuItemContainer) n;
                container.visibleProperty().unbind();
                container.dispose();
            }
        }
        itemsContainerChilder.clear();
    }

    /**
     * Can be called by Skins when they need to clean up the content of any
     * ContextMenu instances they might have created. This ensures that contents
     * of submenus if any, also get cleaned up.
     */
    public void dispose() {
        disposeBinds();
        disposeVisualItems();

        disposeContextMenu(submenu);
        submenu = null;
        openSubmenu = null;
        selectedBackground = null;
        if (contextMenu != null) {
            contextMenu.getItems().clear();
            contextMenu = null;
        }
    }

    public void disposeContextMenu(ContextMenu menu) {
        if (menu == null) return;

        Skin&lt;?&gt; skin = menu.getSkin();
        if (skin == null) return;

        ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
        if (cmContent == null) return;

        cmContent.dispose(); // recursive call to dispose submenus.
    }

    @Override protected void layoutChildren() {
        if (itemsContainer.getChildren().size() == 0) return;
        final double x = snappedLeftInset();
        final double y = snappedTopInset();
        final double w = getWidth() - x - snappedRightInset();
        final double h = getHeight() - y - snappedBottomInset();
        final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);

        itemsContainer.resize(w,contentHeight);
        itemsContainer.relocate(x, y);

        if (isFirstShow &amp;&amp; ty == 0) {
            upArrow.setVisible(false);
            isFirstShow = false;
        } else {
            upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
        }
        downArrow.setVisible(ty + contentHeight &gt; (y + h));

        clipRect.setX(0);
        clipRect.setY(0);
        clipRect.setWidth(w);
        clipRect.setHeight(h);

        if (upArrow.isVisible()) {
            final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
            clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
            upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
            positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }

        if (downArrow.isVisible()) {
            final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
            downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
            positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }
    }

     @Override protected double computePrefWidth(double height) {
         computeVisualMetrics();
         double prefWidth = 0;
         if (itemsContainer.getChildren().size() == 0) return 0;
         for (Node n : itemsContainer.getChildren()) {
             if (! n.isVisible()) continue;
             prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
         }
         return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
    }

    @Override protected double computePrefHeight(double width) {
        if (itemsContainer.getChildren().size() == 0) return 0;
        final double screenHeight = getScreenHeight();
        final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
        double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
        // the pref height of this menu is the smaller value of the
        // actual pref height and the height of the screens _visual_ bounds.
        double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
        return prefHeight;
    }

    @Override protected double computeMinHeight(double width) {
        return 0.0;
    }

    @Override protected double computeMaxHeight(double height) {
        return getScreenHeight();
    }

    private double getScreenHeight() {
        if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
                contextMenu.getOwnerWindow().getScene() == null) {
            return -1;
        }
        return snapSizeY(com.sun.javafx.util.Utils.getScreen(
            contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());

    }

    private double getContentHeight() {
        double h = 0.0d;
        for (Node i : itemsContainer.getChildren()) {
            if (i.isVisible()) {
               h += snapSizeY(i.prefHeight(-1));
            }
        }
        return h;
    }

    // This handles shifting ty when doing keyboard navigation.
    private void ensureFocusedMenuItemIsVisible(Node node) {
        if (node == null) return;

        final Bounds nodeBounds = node.getBoundsInParent();
        final Bounds clipBounds = clipRect.getBoundsInParent();

        if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
            // this is for moving down the menu
            scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
        } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
            // this is for moving up the menu
            scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
        }
    }

    protected ObservableList&lt;MenuItem&gt; getItems() {
        return contextMenu.getItems();
    }

    /**
     * Finds the index of currently focused item.
     */
    private int findFocusedIndex() {
         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node n = itemsContainer.getChildren().get(i);
            if (n.isFocused()) {
                return i;
            }
        }
        return -1;
    }

    private boolean isFirstShow = true;
    private double ty;

    private void initialize() {
        // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
        contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
            currentFocusedIndex = -1;
            for (Node child : itemsContainer.getChildren()) {
                if (child instanceof MenuItemContainer) {
                    final MenuItem item = ((MenuItemContainer)child).item;
                    // When the choiceBox popup is shown, if this menu item is selected
                    // do a requestFocus so CSS kicks in and the item is highlighted.
                    if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
                        if (((RadioMenuItem)item).isSelected()) {
                            child.requestFocus();
                            break;
                        }
                    }
                }

            }
        });

//        // FIXME For some reason getSkinnable()Behavior traversal functions don't
//        // get called as expected, so I've just put the important code below.
        // We use setOnKeyPressed here as we are not adding a listener to a public
        // event type (ContextMenuContent is not public API), and without this
        // we get the issue shown in RT-34429
        setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent ke) {
                switch (ke.getCode()) {
                    case LEFT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processRightKey(ke);
                        } else {
                            processLeftKey(ke);
                        }
                        break;
                    case RIGHT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processLeftKey(ke);
                        } else {
                            processRightKey(ke);
                        }
                        break;
                    case CANCEL:
                        ke.consume();
                        break;
                    case ESCAPE:
                        // if the owner is not a menubar button, just close the
                        // menu - this will move focus up to the parent menu
                        // as required. In the case of the parent being a
                        // menubar button we special case in the conditional code
                        // beneath this switch statement. See RT-34429 for more context.
                        final Node ownerNode = contextMenu.getOwnerNode();
                        if (! (ownerNode instanceof MenuBarButton)) {
                            contextMenu.hide();
                            ke.consume();
                        }
                        break;
                    case DOWN:
                        // move to the next sibling
                        move(Direction.NEXT);
                        ke.consume();
                        break;
                    case UP:
                        // move to previous sibling
                        move(Direction.PREVIOUS);
                        ke.consume();
                        break;
                    case SPACE:
                    case ENTER:
                        // select the menuitem
                        selectMenuItem();
                        ke.consume();
                        break;
                    default:
                        break;
                }

                if (!ke.isConsumed()) {
                    final Node ownerNode = contextMenu.getOwnerNode();
                    if (ownerNode instanceof MenuItemContainer) {
                        // Forward to parent menu
                        Parent parent = ownerNode.getParent();
                        while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
                            parent = parent.getParent();
                        }
                        if (parent instanceof ContextMenuContent) {
                            parent.getOnKeyPressed().handle(ke);
                        }
                    } else if (ownerNode instanceof MenuBarButton) {
                        // the following code no longer appears necessary, but
                        // leaving in intact for now...
//                        // This is a top-level MenuBar Menu, so forward event to MenuBar
//                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
//                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
//                            mbs.getKeyEventHandler().handle(ke);
//                        }
                    }
                }
            }
        });

        addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            /*
             * we'll only scroll if the arrows are visible in the direction
             * that we're going, otherwise we go into empty space.
             */
            final double textDeltaY = event.getTextDeltaY();
            final double deltaY = event.getDeltaY();
            if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
                (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {

                switch(event.getTextDeltaYUnits()) {
                  case LINES:
                      /*
                      ** scroll lines, use the row height of selected row,
                      ** or row 0 if none selected
                      */
                      int focusedIndex = findFocusedIndex();
                      if (focusedIndex == -1) {
                          focusedIndex = 0;
                      }
                      double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
                      scroll(textDeltaY * rowHeight);
                      break;
                  case PAGES:
                      /*
                      ** page scroll, scroll the menu height
                      */
                      scroll(textDeltaY * itemsContainer.getHeight());
                      break;
                  case NONE:
                      /*
                      ** pixel scroll
                      */
                      scroll(deltaY);
                      break;
                }
                event.consume();
            }
        });
    }

    private Optional&lt;Node&gt; getFocusedNode() {
        final List&lt;Node&gt; children = itemsContainer.getChildren();
        final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
        return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
    }

    private void processLeftKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;

                    // if the submenu for this menu is showing, hide it
                    if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        hideSubmenu();
                        ke.consume();
                    }
                }
            }
        });
    }

    private void processRightKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);

                    // RT-15103
                    // if submenu for this menu is already showing then do nothing
                    // Menubar will process the right key and move to the next menu
                    if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        return;
                    }

                    showMenu(menu);
                    ke.consume();
                }
            }
        });
    }

    private void showMenu(Menu menu) {
        menu.show();
        // request focus on the first item of the submenu after it is shown
        ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
        if (cmContent != null) {
           if (cmContent.itemsContainer.getChildren().size() &gt; 0) {
               cmContent.itemsContainer.getChildren().get(0).requestFocus();
               cmContent.currentFocusedIndex = 0;
           } else {
               cmContent.requestFocus();
           }
        }
    }

    private void selectMenuItem() {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);
                    menu.show();
                } else {
                    ((MenuItemContainer)n).doSelect();
                }
            }
        });
    }

    private void move(Direction dir) {
        int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
        requestFocusOnIndex(findSibling(dir, startIndex));
    }

    private int findSibling(final Direction dir, final int startIndex) {
        final int childCount = itemsContainer.getChildren().size();
        int i = startIndex;
        do {
            if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
                // loop to zero
                i = 0;
            } else if (!dir.isForward() &amp;&amp; i == 0) {
                // loop to end
                i = childCount - 1;
            } else {
                i += (dir.isForward() ? 1 : -1);
            }

            Node n = itemsContainer.getChildren().get(i);
            if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
                return i;
            }
        } while (i != startIndex);
        return -1;
    }

    public void requestFocusOnIndex(int index) {
        currentFocusedIndex = index;
        Node n = itemsContainer.getChildren().get(index);
        selectedBackground = ((MenuItemContainer)n);
        n.requestFocus();
        ensureFocusedMenuItemIsVisible(n);
    }

    /*
     * Get the Y offset from the top of the popup to the menu item whose index
     * is given.
     */
    public double getMenuYOffset(int menuIndex) {
        double offset = 0;
        if (itemsContainer.getChildren().size() &gt; menuIndex) {
            offset = snappedTopInset();
            Node menuitem = itemsContainer.getChildren().get(menuIndex);
            offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
        }
        return offset;
    }

    private void setUpBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), true);
        contextMenu.getItems().addListener(contextMenuItemsListener);
    }

    private void disposeBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), false);
        contextMenu.getItems().removeListener(contextMenuItemsListener);
    }

    private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
        ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
        Menu menu = (Menu) isShowingProperty.getBean();

        if (wasShowing &amp;&amp; ! isShowing) {
            // hide the submenu popup
            hideSubmenu();
        } else if (! wasShowing &amp;&amp; isShowing) {
            // show the submenu popup
            showSubmenu(menu);
        }
    };

    private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
        // Add listeners to the showing property of all menus that have
        // been added, and remove listeners from menus that have been removed
        // FIXME this is temporary - we should be adding and removing
        // listeners such that they use the one listener defined above
        // - but that can't be done until we have the bean in the
        // ObservableValue
        while (c.next()) {
            updateMenuShowingListeners(c.getRemoved(), false);
            updateMenuShowingListeners(c.getAddedSubList(), true);
        }

        // Listener to items in PopupMenu to update items in PopupMenuContent
        itemsDirty = true;
        updateItems(); // RT-29761
    };

    private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
        // re layout as item's visibility changed
        requestLayout();
    };

    private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
        for (MenuItem item : items) {
            if (item instanceof Menu) {
                final Menu menu = (Menu) item;

                if (addListeners) {
                    menu.showingProperty().addListener(menuShowingListener);
                } else {
                    menu.showingProperty().removeListener(menuShowingListener);
                }
            }

             // listen to menu items's visible property.
            if (addListeners) {
                item.visibleProperty().addListener(menuItemVisibleListener);
            } else {
                item.visibleProperty().removeListener(menuItemVisibleListener);
            }
        }
    }

    // For test purpose only
    ContextMenu getSubMenu() {
        return submenu;
    }

    Menu getOpenSubMenu() {
        return openSubmenu;
    }

    private void createSubmenu() {
        if (submenu == null) {
            submenu = new ContextMenu();
            submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
                @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
                                              Boolean oldValue, Boolean newValue) {
                    if (!submenu.isShowing()) {
                        // Maybe user clicked outside or typed ESCAPE.
                        // Make sure menus are in sync.
                        for (Node node : itemsContainer.getChildren()) {
                            if (node instanceof MenuItemContainer
                                  &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
                                Menu menu = (Menu)((MenuItemContainer)node).item;
                                if (menu.isShowing()) {
                                    menu.hide();
                                }
                            }
                        }
                    }
                }
            });
        }
    }

    private void showSubmenu(Menu menu) {
        openSubmenu = menu;
        createSubmenu();
        submenu.getItems().setAll(menu.getItems());
        submenu.show(selectedBackground, Side.RIGHT, 0, 0);
    }

    private void hideSubmenu() {
        if (submenu == null) return;

        submenu.hide();
        openSubmenu = null;

        // Fix for RT-37022 - we dispose content so that we do not process CSS
        // on hidden submenus
        disposeContextMenu(submenu);
        submenu = null;

        // Fix for JDK-8158679 - we put the focus on the menu, and then back
        // on the menu item, so that screen readers can properly speak out
        // the menu item.
        getFocusedNode().ifPresent(n -&gt; {
            requestFocus();
            n.requestFocus();
        });
    }

    private void hideAllMenus(MenuItem item) {
        if (contextMenu != null) contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    private Menu openSubmenu;
    private ContextMenu submenu;

    // FIXME: HACKY. We use this so that a submenu knows where to open from
    // but this will only work for mouse hovers currently - and won't work
    // programmatically.
    // package protected for testing only!
    Region selectedBackground;

    void scroll(double delta) {
        double newTy = ty + delta;
        if (ty == newTy) return;

        // translation should never be positive (this would mean the top of the
        // menu content is detaching from the top of the menu!)
        if (newTy &gt; 0.0) {
            newTy = 0.0;
        }

        // translation should never be greater than the preferred height of the
        // menu content (otherwise the menu content will be detaching from the
        // bottom of the menu).
        // RT-37185: We check the direction of the scroll, to prevent it locking
        // up when scrolling upwards from the very bottom (using the on-screen
        // up arrow).
        if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
            newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
        }

        ty = newTy;
        itemsContainer.requestLayout();
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/
    @Override public Styleable getStyleableParent() {
        return contextMenu;
    }

    private static class StyleableProperties {

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());

            //
            // SkinBase only has Region's unique StlyleableProperty's, none of Nodes
            // So, we need to add effect back in. The effect property is in a
            // private inner class, so get the property from Node the hard way.
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
            for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
                CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
                if (&quot;effect&quot;.equals(styleable.getProperty())) {
                    styleables.add(styleable);
                    break;
                }
            }
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    public Label getLabelAt(int index) {
        return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
    }

    /**
     * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
     * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
     * timeline when mouse is over up/down arrow.
     */
    class MenuBox extends VBox {
        MenuBox() {
            setAccessibleRole(AccessibleRole.CONTEXT_MENU);
        }

        @Override protected void layoutChildren() {
            double yOffset = ty;
            for (Node n : getChildren()) {
                if (n.isVisible()) {
                    final double prefHeight = snapSizeY(n.prefHeight(-1));
                    n.resize(snapSizeX(getWidth()), prefHeight);
                    n.relocate(snappedLeftInset(), yOffset);
                    yOffset += prefHeight;
                }
            }
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case VISIBLE: return contextMenu.isShowing();
                case PARENT_MENU: return contextMenu.getOwnerNode();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }
    }

    class ArrowMenuItem extends StackPane {
         private StackPane upDownArrow;
         private ContextMenuContent popupMenuContent;
         private boolean up = false;
         public final boolean isUp() { return up; }
         public void setUp(boolean value) {
            up = value;
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
        }

        // used to automatically scroll through menu items when the user performs
        // certain interactions, e.g. pressing and holding the arrow buttons
        private Timeline scrollTimeline;

        public ArrowMenuItem(ContextMenuContent pmc) {
            getStyleClass().setAll(&quot;scroll-arrow&quot;);
            upDownArrow = new StackPane();
            this.popupMenuContent = pmc;
            upDownArrow.setMouseTransparent(true);
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
    //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
            addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
                if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
                    return;
                }
                startTimeline();
            });
            addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
                stopTimeline();
            });
            setVisible(false);
            setManaged(false);
            getChildren().add(upDownArrow);
        }

        @Override protected double computePrefWidth(double height) {
//            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
            return itemsContainer.getWidth();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double w = snapSizeX(upDownArrow.prefWidth(-1));
            double h = snapSizeY(upDownArrow.prefHeight(-1));

            upDownArrow.resize(w, h);
            positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }

        private void adjust() {
            if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
        }

        private void startTimeline() {
            scrollTimeline = new Timeline();
            scrollTimeline.setCycleCount(Timeline.INDEFINITE);
            KeyFrame kf = new KeyFrame(
                Duration.millis(60),
                    event -&gt; {
                        adjust();
                    }
            );
            scrollTimeline.getKeyFrames().clear();
            scrollTimeline.getKeyFrames().add(kf);
            scrollTimeline.play();
        }

        private void stopTimeline() {
            scrollTimeline.stop();
            scrollTimeline = null;
        }
    }

    /*
     * Container responsible for laying out a single row in the menu - in other
     * words, this contains and lays out a single MenuItem, regardless of it's
     * specific subtype.
     */
    public class MenuItemContainer extends Region {

        private final MenuItem item;

        private Node left;
        private Node graphic;
        private Node label;
        private Node right;

        private final LambdaMultiplePropertyChangeListenerHandler listener =
            new LambdaMultiplePropertyChangeListenerHandler();

        private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
        private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;

        private EventHandler&lt;ActionEvent&gt; actionEventHandler;

        protected Label getLabel(){
            return (Label) label;
        }

        public MenuItem getItem() {
            return item;
        }

        public MenuItemContainer(MenuItem item){
            if (item == null) {
                throw new NullPointerException(&quot;MenuItem can not be null&quot;);
            }

            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            setFocusTraversable(!(item instanceof CustomMenuItem));
            this.item = item;

            createChildren();

            // listen to changes in the state of certain MenuItem types
            ReadOnlyBooleanProperty pseudoProperty;
            if (item instanceof Menu) {
                pseudoProperty = ((Menu)item).showingProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.MENU);
            } else if (item instanceof RadioMenuItem) {
                pseudoProperty = ((RadioMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
            } else if (item instanceof CheckMenuItem) {
                pseudoProperty = ((CheckMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
            } else {
                setAccessibleRole(AccessibleRole.MENU_ITEM);
            }

            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
            listener.registerChangeListener(item.disableProperty(),
                    e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));

            // Add the menu item to properties map of this node. Used by QA for testing
            // This allows associating this container with corresponding MenuItem.
            getProperties().put(MenuItem.class, item);

            listener.registerChangeListener(item.graphicProperty(), e -&gt; {
                createChildren();
                computeVisualMetrics();
            });

            actionEventHandler = e -&gt; {
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }

                    selectedBackground = MenuItemContainer.this;
                    showMenu(menu);
                } else {
                    doSelect();
                }
            };
            addEventHandler(ActionEvent.ACTION, actionEventHandler);
        }

        public void dispose() {
            if (item instanceof CustomMenuItem) {
                Node node = ((CustomMenuItem)item).getContent();
                if (node != null) {
                    node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
                }
            }

            listener.dispose();
            removeEventHandler(ActionEvent.ACTION, actionEventHandler);

            if (label != null) {
                ((Label)label).textProperty().unbind();
                label.styleProperty().unbind();
                label.idProperty().unbind();

                ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
                if (itemStyleClassListener != null) {
                    item.getStyleClass().removeListener(itemStyleClassListener);
                }
            }

            left = null;
            graphic = null;
            label = null;
            right = null;
        }

        private void createChildren() {
            getChildren().clear();

            // draw background region for hover effects. All content (other
            // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
            // this background also acts as the receiver of user input
            if (item instanceof CustomMenuItem) {
                createNodeMenuItemChildren((CustomMenuItem)item);

                if (mouseEnteredEventHandler == null) {
                    mouseEnteredEventHandler = event -&gt; {
                        requestFocus(); // request Focus on hover
                    };
                } else {
                    removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                }
                addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
            } else {
                // --- add check / radio to left column
                Node leftNode = getLeftGraphic(item);
                if (leftNode != null) {
                    StackPane leftPane = new StackPane();
                    leftPane.getStyleClass().add(&quot;left-container&quot;);
                    leftPane.getChildren().add(leftNode);
                    left = leftPane;
                    getChildren().add(left);
                    left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
                }
                // -- add graphic to graphic pane
                if (item.getGraphic() != null) {
                    Node graphicNode = item.getGraphic();
                    StackPane graphicPane = new StackPane();
                    graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
                    graphicPane.getChildren().add(graphicNode);
                    graphic = graphicPane;
                    getChildren().add(graphic);
                }

                // --- add text to center column
                label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()

                // set up bindings from the MenuItem into the Label
                ((Label)label).textProperty().bind(item.textProperty());
                label.styleProperty().bind(item.styleProperty());
                label.idProperty().bind(item.styleProperty());

                // we want to ensure that any styleclasses set on the menuitem are applied to the
                // label (so we can style appropriately), but we can't just do a binding such as this:
                // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
                // Because that means we overwrite the 'label' style class on the Label.
                // What we really want is to ensure all style classes in the MenuItem are _copied_
                // into the label, which is what we do below
                ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
                    while (c.next()) {
                        label.getStyleClass().removeAll(c.getRemoved());
                        label.getStyleClass().addAll(c.getAddedSubList());
                    }
                };
                item.getStyleClass().addListener(itemStyleClassListener);
                item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);


                label.setMouseTransparent(true);
                getChildren().add(label);

                listener.unregisterChangeListeners(focusedProperty());
                // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
                // e.g this happens when you press the Right key to open a submenu; the first
                // menuitem is focused.
                listener.registerChangeListener(focusedProperty(), e -&gt; {
                    if (isFocused()) {
                        currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
                    }
                });

                // --- draw in right column - this depends on whether we are
                // a Menu or not. A Menu gets an arrow, whereas other MenuItems
                // get the ability to draw an accelerator
                if (item instanceof Menu) {
                    // --- add arrow / accelerator / mnemonic to right column
                    Region rightNode = new Region();
                    rightNode.setMouseTransparent(true);
                    rightNode.getStyleClass().add(&quot;arrow&quot;);

                    StackPane rightPane = new StackPane();
                    rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
                    rightPane.setMouseTransparent(true);
                    rightPane.getStyleClass().add(&quot;right-container&quot;);
                    rightPane.getChildren().add(rightNode);
                    right = rightPane;
                    getChildren().add(rightPane);

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null &amp;&amp; item != openSubmenu) {
                                // if a submenu of a different menu is already
                                // open then close it (RT-15049)
                                hideSubmenu();
                            }

                            selectedBackground = MenuItemContainer.this;
                            requestFocus();  // request Focus on hover
                            final Menu menu = (Menu) item;
                            if (menu.isDisable()) return;
                            menu.show();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            item.fire();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    // show submenu when the menu is hovered over
                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                } else { // normal MenuItem
                    // remove old listeners
                    listener.unregisterChangeListeners(item.acceleratorProperty());

                    // accelerator support
                    updateAccelerator();

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null) {
                                openSubmenu.hide();
                            }
                            requestFocus();  // request Focus on hover
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            doSelect();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);

                    listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
                }
            }
        }

        private void updateAccelerator() {
            if (item.getAccelerator() != null) {
                if (right != null) {
                    getChildren().remove(right);
                }

                String text = item.getAccelerator().getDisplayText();
                right = new Label(text);
<A NAME="32"></A>                right.setStyle(item.getStyle());
                right.getStyleClass().add(&quot;accelerator-text&quot;);
                getChildren().add(right);
            } else <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#32',2,'match45-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                getChildren().remove(right);
            }
        }

        void doSelect() {
            // don't do anything on disabled menu items
            if (item.isDisable()) return;</B></FONT>
            // toggle state of check or radio items
            if (item instanceof CheckMenuItem) {
                CheckMenuItem checkItem = (CheckMenuItem)item;
                checkItem.setSelected(!checkItem.isSelected());
            } else if (item instanceof RadioMenuItem) {
                // this is a radio button. If there is a toggleGroup specified, we
                // simply set selected to true. If no toggleGroup is specified, we
                // toggle the selected state, as there is no assumption of mutual
                // exclusivity when no toggleGroup is set.
                final RadioMenuItem radioItem = (RadioMenuItem) item;
                radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
            }

            // fire the action before hiding the menu
            item.fire();

            if (item instanceof CustomMenuItem) {
                CustomMenuItem customMenuItem = (CustomMenuItem) item;
                if (customMenuItem.isHideOnClick()) {
                    hideAllMenus(item);
                }
            } else {
                hideAllMenus(item);
            }
        }

        private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;

        private void createNodeMenuItemChildren(final CustomMenuItem item) {
            Node node = item.getContent();
            getChildren().add(node);

            // handle hideOnClick
            customMenuItemMouseClickedHandler = event -&gt; {
                if (item == null || item.isDisable()) return;

                item.fire();
                if (item.isHideOnClick()) {
                    hideAllMenus(item);
                }
            };
            node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
        }

        @Override protected void layoutChildren() {
            double xOffset;

            final double prefHeight = prefHeight(-1);
            if (left != null) {
                xOffset = snappedLeftInset();
                left.resize(left.prefWidth(-1), left.prefHeight(-1));
                positionInArea(left, xOffset, 0,
                        maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }
            if (graphic != null) {
                xOffset = snappedLeftInset() + maxLeftWidth;
                graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
                positionInArea(graphic, xOffset, 0,
                        maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (label != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
                label.resize(label.prefWidth(-1), label.prefHeight(-1));
                positionInArea(label, xOffset, 0,
                        maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (right != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
                right.resize(right.prefWidth(-1), right.prefHeight(-1));
                positionInArea(right, xOffset, 0,
                    maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
            }

            if ( item instanceof CustomMenuItem) {
                Node n = ((CustomMenuItem) item).getContent();
                if (item instanceof SeparatorMenuItem) {
                    double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
                    n.resize(width, n.prefHeight(-1));
                    positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                } else {
                    n.resize(n.prefWidth(-1), n.prefHeight(-1));
                    //the node should be left aligned
                    positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                }
            }
        }

        @Override protected double computePrefHeight(double width) {
            double prefHeight = 0;
            if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
                prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
            } else {
                prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
            }
             return snappedTopInset() + prefHeight + snappedBottomInset();
        }

        @Override protected double computePrefWidth(double height) {
            double nodeMenuItemWidth = 0;
            if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
                nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
                        snappedRightInset();
            }
            return Math.max(nodeMenuItemWidth,
                    snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
                    maxLabelWidth + maxRightWidth + snappedRightInset());
        }

        // Responsible for returning a graphic (if necessary) to position in the
        // left column of the menu. This may be a Node from the MenuItem.graphic
        // property, or it may be a check/radio item if necessary.
        private Node getLeftGraphic(MenuItem item) {
            if (item instanceof RadioMenuItem) {
                 final Region _graphic = new Region();
                _graphic.getStyleClass().add(&quot;radio&quot;);
                return _graphic;
            } else if (item instanceof CheckMenuItem) {
                final StackPane _graphic = new StackPane();
                _graphic.getStyleClass().add(&quot;check&quot;);
                return _graphic;
            }

            return null;
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case SELECTED:
                    if (item instanceof CheckMenuItem) {
                        return ((CheckMenuItem)item).isSelected();
                    }
                    if (item instanceof RadioMenuItem) {
                        return ((RadioMenuItem) item).isSelected();
                    }
                    return false;
                case ACCELERATOR: return item.getAccelerator();
                case TEXT: {
                    String title = &quot;&quot;;
                    if (graphic != null) {
                        String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    final Label label = getLabel();
                    if (label != null) {
                        String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    if (item instanceof CustomMenuItem) {
                        Node content = ((CustomMenuItem) item).getContent();
                        if (content != null) {
                            String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                            if (t != null) title += t;
                        }
                    }
                    return title;
                }
                case MNEMONIC: {
                    final Label label = getLabel();
                    if (label != null) {
                        String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
                        if (mnemonic != null) return mnemonic;
                    }
                    return null;
                }
                case DISABLED: return item.isDisable();
                case SUBMENU:
                    createSubmenu();
                    // Accessibility might need to see the menu node before the window
                    // is visible (i.e. before the skin is applied).
                    if (submenu.getSkin() == null) {
                        submenu.getStyleableNode().applyCss();
                    }
                    ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
                    return cmContent.itemsContainer;
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case SHOW_MENU:{
                    if (item instanceof Menu) {
                        final Menu menuItem = (Menu) item;
                        if (menuItem.isShowing()) {
                            menuItem.hide();
                        } else {
                            menuItem.show();
                        }
                    }
                    break;
                }
                case FIRE:
                    doSelect();
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }


    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;checked&quot;);

    private class MenuLabel extends Label {

        public MenuLabel(MenuItem item, MenuItemContainer mic) {
            super(item.getText());
            setMnemonicParsing(item.isMnemonicParsing());
            setLabelFor(mic);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/CustomColorDialog.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.control.IntegerField;
import com.sun.javafx.scene.control.WebColorField;
import com.sun.javafx.scene.control.skin.IntegerFieldSkin;
import com.sun.javafx.scene.control.skin.WebColorFieldSkin;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.*;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.*;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.ObjectBinding;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.input.KeyEvent;
import javafx.stage.Screen;
import javafx.stage.WindowEvent;

/**
 *
 */
public class CustomColorDialog extends HBox {

    private final Stage dialog = new Stage();
    private ColorRectPane colorRectPane;
    private ControlsPane controlsPane;

    private ObjectProperty&lt;Color&gt; currentColorProperty = new SimpleObjectProperty&lt;&gt;(Color.WHITE);
    private ObjectProperty&lt;Color&gt; customColorProperty = new SimpleObjectProperty&lt;&gt;(Color.TRANSPARENT);
    private Runnable onSave;
    private Runnable onUse;
    private Runnable onCancel;

    private WebColorField webField = null;
    private Scene customScene;

    // JDK-8161449
    private String saveBtnText;
    private boolean showUseBtn = true;
    private boolean showOpacitySlider = true;

    public CustomColorDialog(Window owner) {
        getStyleClass().add(&quot;custom-color-dialog&quot;);
        if (owner != null) dialog.initOwner(owner);
        dialog.setTitle(Properties.getColorPickerString(&quot;customColorDialogTitle&quot;));
        dialog.initModality(Modality.APPLICATION_MODAL);
        dialog.initStyle(StageStyle.UTILITY);
        dialog.setResizable(false);

        dialog.addEventHandler(KeyEvent.ANY, keyEventListener);

        customScene = new Scene(this);
        final Scene ownerScene = owner.getScene();
        if (ownerScene != null) {
            if (ownerScene.getUserAgentStylesheet() != null) {
                customScene.setUserAgentStylesheet(ownerScene.getUserAgentStylesheet());
            }
            customScene.getStylesheets().addAll(ownerScene.getStylesheets());
        }

        buildUI();

        dialog.setScene(customScene);
    }

    private void buildUI() {
        colorRectPane = new ColorRectPane();
        controlsPane = new ControlsPane();
        setHgrow(controlsPane, Priority.ALWAYS);
        getChildren().setAll(colorRectPane, controlsPane);
    }

    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        switch (e.getCode()) {
            case ESCAPE:
                dialog.setScene(null);
                dialog.close();
            default:
                break;
        }
    };

    public void setCurrentColor(Color currentColor) {
        this.currentColorProperty.set(currentColor);
    }

    public final Color getCurrentColor() {
        return currentColorProperty.get();
    }

    public final ObjectProperty&lt;Color&gt; customColorProperty() {
        return customColorProperty;
    }

    public final void setCustomColor(Color color) {
        customColorProperty.set(color);
    }

    public final Color getCustomColor() {
        return customColorProperty.get();
    }

    public Runnable getOnSave() {
        return onSave;
    }

    public void setOnSave(Runnable onSave) {
        this.onSave = onSave;
    }

    // JDK-8161449
    public void setSaveBtnToOk() {
        this.saveBtnText = Properties.getColorPickerString(&quot;OK&quot;);
        buildUI();
    }

    public Runnable getOnUse() {
        return onUse;
    }

    public void setOnUse(Runnable onUse) {
        this.onUse = onUse;
    }

    // JDK-8161449
    public void setShowUseBtn(boolean showUseBtn) {
        this.showUseBtn = showUseBtn;
        buildUI();
    }

    // JDK-8161449
    public void setShowOpacitySlider(boolean showOpacitySlider) {
        this.showOpacitySlider = showOpacitySlider;
        buildUI();
    }

    public Runnable getOnCancel() {
        return onCancel;
    }

    public void setOnCancel(Runnable onCancel) {
        this.onCancel = onCancel;
    }

    public void setOnHidden(EventHandler&lt;WindowEvent&gt; onHidden) {
        dialog.setOnHidden(onHidden);
    }

    public Stage getDialog() {
        return dialog;
    }

    public void show() {
        if (dialog.getOwner() != null) {
            // Workaround of RT-29871: Instead of just invoking fixPosition()
            // here need to use listener that fixes dialog position once both
            // width and height are determined
            dialog.widthProperty().addListener(positionAdjuster);
            dialog.heightProperty().addListener(positionAdjuster);
            positionAdjuster.invalidated(null);
        }
        if (dialog.getScene() == null) dialog.setScene(customScene);
        colorRectPane.updateValues();
        dialog.show();
    }

    public void hide() {
        if (dialog.getOwner() != null) {
            dialog.hide();
        }
    }

    private InvalidationListener positionAdjuster = new InvalidationListener() {

        @Override
        public void invalidated(Observable ignored) {
            if (Double.isNaN(dialog.getWidth()) || Double.isNaN(dialog.getHeight())) {
                return;
            }
            dialog.widthProperty().removeListener(positionAdjuster);
            dialog.heightProperty().removeListener(positionAdjuster);
            fixPosition();
        }

    };

    private void fixPosition() {
        Window w = dialog.getOwner();
        Screen s = com.sun.javafx.util.Utils.getScreen(w);
        Rectangle2D sb = s.getBounds();
        double xR = w.getX() + w.getWidth();
        double xL = w.getX() - dialog.getWidth();
        double x, y;
        if (sb.getMaxX() &gt;= xR + dialog.getWidth()) {
            x = xR;
        } else if (sb.getMinX() &lt;= xL) {
            x = xL;
        } else {
            x = Math.max(sb.getMinX(), sb.getMaxX() - dialog.getWidth());
        }
        y = Math.max(sb.getMinY(), Math.min(sb.getMaxY() - dialog.getHeight(), w.getY()));
        dialog.setX(x);
        dialog.setY(y);
    }

    @Override
    public void layoutChildren() {
        super.layoutChildren();
        if (dialog.getMinWidth() &gt; 0 &amp;&amp; dialog.getMinHeight() &gt; 0) {
            // don't recalculate min size once it's set
            return;
        }

        // Math.max(0, ...) added for RT-34704 to ensure the dialog is at least 0 x 0
        double minWidth = Math.max(0, computeMinWidth(getHeight()) + (dialog.getWidth() - customScene.getWidth()));
        double minHeight = Math.max(0, computeMinHeight(getWidth()) + (dialog.getHeight() - customScene.getHeight()));
        dialog.setMinWidth(minWidth);
        dialog.setMinHeight(minHeight);
    }

    /* ------------------------------------------------------------------------*/

    private class ColorRectPane extends HBox {

        private Pane colorRect;
        private Pane colorBar;
        private Pane colorRectOverlayOne;
        private Pane colorRectOverlayTwo;
        private Region colorRectIndicator;
        private Region colorBarIndicator;

        private boolean changeIsLocal = false;
        private DoubleProperty hue = new SimpleDoubleProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateHSBColor();
                    changeIsLocal = false;
                }
            }
        };
        private DoubleProperty sat = new SimpleDoubleProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateHSBColor();
                    changeIsLocal = false;
                }
            }
        };
        private DoubleProperty bright = new SimpleDoubleProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateHSBColor();
                    changeIsLocal = false;
                }
            }
        };
        private IntegerProperty red = new SimpleIntegerProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateRGBColor();
                    changeIsLocal = false;
                }
            }
        };

        private IntegerProperty green = new SimpleIntegerProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateRGBColor();
                    changeIsLocal = false;
                }
            }
        };

        private IntegerProperty blue = new SimpleIntegerProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateRGBColor();
                    changeIsLocal = false;
                }
            }
        };

        private DoubleProperty alpha = new SimpleDoubleProperty(100) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    setCustomColor(new Color(
                            getCustomColor().getRed(),
                            getCustomColor().getGreen(),
                            getCustomColor().getBlue(),
                            clamp(alpha.get() / 100)));
                    changeIsLocal = false;
                }
            }
        };

        private void updateRGBColor() {
            Color newColor = Color.rgb(red.get(), green.get(), blue.get(), clamp(alpha.get() / 100));
            hue.set(newColor.getHue());
            sat.set(newColor.getSaturation() * 100);
            bright.set(newColor.getBrightness() * 100);
            setCustomColor(newColor);
        }

        private void updateHSBColor() {
            Color newColor = Color.hsb(hue.get(), clamp(sat.get() / 100),
                    clamp(bright.get() / 100), clamp(alpha.get() / 100));
            red.set(doubleToInt(newColor.getRed()));
            green.set(doubleToInt(newColor.getGreen()));
            blue.set(doubleToInt(newColor.getBlue()));
            setCustomColor(newColor);
        }

        private void colorChanged() {
            if (!changeIsLocal) {
                changeIsLocal = true;
                hue.set(getCustomColor().getHue());
                sat.set(getCustomColor().getSaturation() * 100);
                bright.set(getCustomColor().getBrightness() * 100);
                red.set(doubleToInt(getCustomColor().getRed()));
                green.set(doubleToInt(getCustomColor().getGreen()));
                blue.set(doubleToInt(getCustomColor().getBlue()));
                changeIsLocal = false;
            }
        }

        public ColorRectPane() {

            getStyleClass().add(&quot;color-rect-pane&quot;);

            customColorProperty().addListener((ov, t, t1) -&gt; {
                colorChanged();
            });

            colorRectIndicator = new Region();
            colorRectIndicator.setId(&quot;color-rect-indicator&quot;);
            colorRectIndicator.setManaged(false);
            colorRectIndicator.setMouseTransparent(true);
            colorRectIndicator.setCache(true);

            final Pane colorRectOpacityContainer = new StackPane();

            colorRect = new StackPane() {
                // This is an implementation of square control that chooses its
                // size to fill the available height
                @Override
                public Orientation getContentBias() {
                    return Orientation.VERTICAL;
                }

                @Override
                protected double computePrefWidth(double height) {
                    return height;
                }

                @Override
                protected double computeMaxWidth(double height) {
                    return height;
                }
            };
            colorRect.getStyleClass().addAll(&quot;color-rect&quot;, &quot;transparent-pattern&quot;);

            Pane colorRectHue = new Pane();
            colorRectHue.backgroundProperty().bind(new ObjectBinding&lt;Background&gt;() {

                {
                    bind(hue);
                }

                @Override
                protected Background computeValue() {
                    return new Background(new BackgroundFill(
                            Color.hsb(hue.getValue(), 1.0, 1.0),
                            CornerRadii.EMPTY, Insets.EMPTY));
                }
            });

            colorRectOverlayOne = new Pane();
            colorRectOverlayOne.getStyleClass().add(&quot;color-rect&quot;);
            colorRectOverlayOne.setBackground(new Background(new BackgroundFill(
                    new LinearGradient(0, 0, 1, 0, true, CycleMethod.NO_CYCLE,
                            new Stop(0, Color.rgb(255, 255, 255, 1)),
                            new Stop(1, Color.rgb(255, 255, 255, 0))),
                    CornerRadii.EMPTY, Insets.EMPTY)));

            EventHandler&lt;MouseEvent&gt; rectMouseHandler = event -&gt; {
                final double x = event.getX();
                final double y = event.getY();
                sat.set(clamp(x / colorRect.getWidth()) * 100);
                bright.set(100 - (clamp(y / colorRect.getHeight()) * 100));
            };

            colorRectOverlayTwo = new Pane();
            colorRectOverlayTwo.getStyleClass().addAll(&quot;color-rect&quot;);
            colorRectOverlayTwo.setBackground(new Background(new BackgroundFill(
                    new LinearGradient(0, 0, 0, 1, true, CycleMethod.NO_CYCLE,
                            new Stop(0, Color.rgb(0, 0, 0, 0)), new Stop(1, Color.rgb(0, 0, 0, 1))),
                    CornerRadii.EMPTY, Insets.EMPTY)));
            colorRectOverlayTwo.setOnMouseDragged(rectMouseHandler);
            colorRectOverlayTwo.setOnMousePressed(rectMouseHandler);

            Pane colorRectBlackBorder = new Pane();
            colorRectBlackBorder.setMouseTransparent(true);
            colorRectBlackBorder.getStyleClass().addAll(&quot;color-rect&quot;, &quot;color-rect-border&quot;);

            colorBar = new Pane();
            colorBar.getStyleClass().add(&quot;color-bar&quot;);
            colorBar.setBackground(new Background(new BackgroundFill(createHueGradient(),
                    CornerRadii.EMPTY, Insets.EMPTY)));

            colorBarIndicator = new Region();
            colorBarIndicator.setId(&quot;color-bar-indicator&quot;);
            colorBarIndicator.setMouseTransparent(true);
            colorBarIndicator.setCache(true);

            colorRectIndicator.layoutXProperty().bind(sat.divide(100).multiply(colorRect.widthProperty()));
            colorRectIndicator.layoutYProperty().bind(Bindings.subtract(1, bright.divide(100)).multiply(colorRect.heightProperty()));
            colorBarIndicator.layoutYProperty().bind(hue.divide(360).multiply(colorBar.heightProperty()));
            colorRectOpacityContainer.opacityProperty().bind(alpha.divide(100));

            EventHandler&lt;MouseEvent&gt; barMouseHandler = event -&gt; {
                final double y = event.getY();
                hue.set(clamp(y / colorRect.getHeight()) * 360);
            };

            colorBar.setOnMouseDragged(barMouseHandler);
            colorBar.setOnMousePressed(barMouseHandler);

            colorBar.getChildren().setAll(colorBarIndicator);
            colorRectOpacityContainer.getChildren().setAll(colorRectHue, colorRectOverlayOne, colorRectOverlayTwo);
            colorRect.getChildren().setAll(colorRectOpacityContainer, colorRectBlackBorder, colorRectIndicator);
            HBox.setHgrow(colorRect, Priority.SOMETIMES);
            getChildren().addAll(colorRect, colorBar);
        }

        private void updateValues() {
            if (getCurrentColor() == null) {
                setCurrentColor(Color.TRANSPARENT);
            }
            changeIsLocal = true;
            //Initialize hue, sat, bright, color, red, green and blue
            hue.set(getCurrentColor().getHue());
            sat.set(getCurrentColor().getSaturation() * 100);
            bright.set(getCurrentColor().getBrightness() * 100);
            alpha.set(getCurrentColor().getOpacity() * 100);
            setCustomColor(Color.hsb(hue.get(), clamp(sat.get() / 100), clamp(bright.get() / 100),
                    clamp(alpha.get() / 100)));
            red.set(doubleToInt(getCustomColor().getRed()));
            green.set(doubleToInt(getCustomColor().getGreen()));
            blue.set(doubleToInt(getCustomColor().getBlue()));
            changeIsLocal = false;
        }

        @Override
        protected void layoutChildren() {
            super.layoutChildren();

            // to maintain default size
            colorRectIndicator.autosize();
            // to maintain square size
            double size = Math.min(colorRect.getWidth(), colorRect.getHeight());
            colorRect.resize(size, size);
            colorBar.resize(colorBar.getWidth(), size);
        }
    }

    /* ------------------------------------------------------------------------*/

    private class ControlsPane extends VBox {

        private Label currentColorLabel;
        private Label newColorLabel;
        private Region currentColorRect;
        private Region newColorRect;
        private Region currentTransparent; // for opacity
        private GridPane currentAndNewColor;
        private Region currentNewColorBorder;
        private ToggleButton hsbButton;
        private ToggleButton rgbButton;
        private ToggleButton webButton;
        private HBox hBox;

        private Label labels[] = new Label[4];
        private Slider sliders[] = new Slider[4];
        private IntegerField fields[] = new IntegerField[4];
        private Label units[] = new Label[4];
        private HBox buttonBox;
        private Region whiteBox;

        private GridPane settingsPane = new GridPane();

        public ControlsPane() {
            getStyleClass().add(&quot;controls-pane&quot;);

            currentNewColorBorder = new Region();
            currentNewColorBorder.setId(&quot;current-new-color-border&quot;);

            currentTransparent = new Region();
            currentTransparent.getStyleClass().addAll(&quot;transparent-pattern&quot;);

            currentColorRect = new Region();
            currentColorRect.getStyleClass().add(&quot;color-rect&quot;);
            currentColorRect.setId(&quot;current-color&quot;);
            currentColorRect.backgroundProperty().bind(new ObjectBinding&lt;Background&gt;() {
                {
                    bind(currentColorProperty);
                }

                @Override
                protected Background computeValue() {
                    return new Background(new BackgroundFill(currentColorProperty.get(), CornerRadii.EMPTY, Insets.EMPTY));
                }
            });

            newColorRect = new Region();
            newColorRect.getStyleClass().add(&quot;color-rect&quot;);
            newColorRect.setId(&quot;new-color&quot;);
            newColorRect.backgroundProperty().bind(new ObjectBinding&lt;Background&gt;() {
                {
                    bind(customColorProperty);
                }

                @Override
                protected Background computeValue() {
                    return new Background(new BackgroundFill(customColorProperty.get(), CornerRadii.EMPTY, Insets.EMPTY));
                }
            });

            currentColorLabel = new Label(Properties.getColorPickerString(&quot;currentColor&quot;));
            newColorLabel = new Label(Properties.getColorPickerString(&quot;newColor&quot;));

            whiteBox = new Region();
            whiteBox.getStyleClass().add(&quot;customcolor-controls-background&quot;);

            hsbButton = new ToggleButton(Properties.getColorPickerString(&quot;colorType.hsb&quot;));
            hsbButton.getStyleClass().add(&quot;left-pill&quot;);
            rgbButton = new ToggleButton(Properties.getColorPickerString(&quot;colorType.rgb&quot;));
            rgbButton.getStyleClass().add(&quot;center-pill&quot;);
            webButton = new ToggleButton(Properties.getColorPickerString(&quot;colorType.web&quot;));
            webButton.getStyleClass().add(&quot;right-pill&quot;);
            final ToggleGroup group = new ToggleGroup();

            hBox = new HBox();
            hBox.setAlignment(Pos.CENTER);
            hBox.getChildren().addAll(hsbButton, rgbButton, webButton);

            Region spacer1 = new Region();
            spacer1.setId(&quot;spacer1&quot;);
            Region spacer2 = new Region();
            spacer2.setId(&quot;spacer2&quot;);
            Region leftSpacer = new Region();
            leftSpacer.setId(&quot;spacer-side&quot;);
            Region rightSpacer = new Region();
            rightSpacer.setId(&quot;spacer-side&quot;);
            Region bottomSpacer = new Region();
            bottomSpacer.setId(&quot;spacer-bottom&quot;);

            currentAndNewColor = new GridPane();
            currentAndNewColor.getColumnConstraints().addAll(new ColumnConstraints(), new ColumnConstraints());
            currentAndNewColor.getColumnConstraints().get(0).setHgrow(Priority.ALWAYS);
            currentAndNewColor.getColumnConstraints().get(1).setHgrow(Priority.ALWAYS);
            currentAndNewColor.getRowConstraints().addAll(new RowConstraints(), new RowConstraints(), new RowConstraints());
            currentAndNewColor.getRowConstraints().get(2).setVgrow(Priority.ALWAYS);
            VBox.setVgrow(currentAndNewColor, Priority.ALWAYS);

            currentAndNewColor.getStyleClass().add(&quot;current-new-color-grid&quot;);
            currentAndNewColor.add(currentColorLabel, 0, 0);
            currentAndNewColor.add(newColorLabel, 1, 0);
            currentAndNewColor.add(spacer1, 0, 1, 2, 1);
            currentAndNewColor.add(currentTransparent, 0, 2, 2, 1);
            currentAndNewColor.add(currentColorRect, 0, 2);
            currentAndNewColor.add(newColorRect, 1, 2);
            currentAndNewColor.add(currentNewColorBorder, 0, 2, 2, 1);
            currentAndNewColor.add(spacer2, 0, 3, 2, 1);

            settingsPane = new GridPane();
            settingsPane.setId(&quot;settings-pane&quot;);
            settingsPane.getColumnConstraints().addAll(new ColumnConstraints(),
                    new ColumnConstraints(), new ColumnConstraints(),
                    new ColumnConstraints(), new ColumnConstraints(),
                    new ColumnConstraints());
            settingsPane.getColumnConstraints().get(0).setHgrow(Priority.NEVER);
            settingsPane.getColumnConstraints().get(2).setHgrow(Priority.ALWAYS);
            settingsPane.getColumnConstraints().get(3).setHgrow(Priority.NEVER);
            settingsPane.getColumnConstraints().get(4).setHgrow(Priority.NEVER);
            settingsPane.getColumnConstraints().get(5).setHgrow(Priority.NEVER);
            settingsPane.add(whiteBox, 0, 0, 6, 5);
            settingsPane.add(hBox, 0, 0, 6, 1);
            settingsPane.add(leftSpacer, 0, 0);
            settingsPane.add(rightSpacer, 5, 0);
            settingsPane.add(bottomSpacer, 0, 4);

            webField = new WebColorField();
            webField.getStyleClass().add(&quot;web-field&quot;);
            webField.setSkin(new WebColorFieldSkin(webField));
            webField.valueProperty().bindBidirectional(customColorProperty);
            webField.visibleProperty().bind(group.selectedToggleProperty().isEqualTo(webButton));
            settingsPane.add(webField, 2, 1);

            // Color settings Grid Pane
            for (int i = 0; i &lt; 4; i++) {
                labels[i] = new Label();
                labels[i].getStyleClass().add(&quot;settings-label&quot;);

                sliders[i] = new Slider();

                fields[i] = new IntegerField();
                fields[i].getStyleClass().add(&quot;color-input-field&quot;);
                fields[i].setSkin(new IntegerFieldSkin(fields[i]));

                units[i] = new Label(i == 0 ? &quot;\u00B0&quot; : &quot;%&quot;);
                units[i].getStyleClass().add(&quot;settings-unit&quot;);

                if (i &gt; 0 &amp;&amp; i &lt; 3) {
                    // first row and opacity labels are always visible
                    // second and third row labels are not visible in Web page
                    labels[i].visibleProperty().bind(group.selectedToggleProperty().isNotEqualTo(webButton));
                }
                if (i &lt; 3) {
                    // sliders and fields shouldn't be visible in Web page
                    sliders[i].visibleProperty().bind(group.selectedToggleProperty().isNotEqualTo(webButton));
                    fields[i].visibleProperty().bind(group.selectedToggleProperty().isNotEqualTo(webButton));
                    units[i].visibleProperty().bind(group.selectedToggleProperty().isEqualTo(hsbButton));
                }
                int row = 1 + i;
                if (i == 3) {
                    // opacity row is shifted one gridPane row down
                    row++;
                }

                // JDK-8161449 - hide the opacity slider
                if (i == 3 &amp;&amp; !showOpacitySlider) {
                    continue;
                }

                settingsPane.add(labels[i], 1, row);
                settingsPane.add(sliders[i], 2, row);
                settingsPane.add(fields[i], 3, row);
                settingsPane.add(units[i], 4, row);
            }

            set(3, Properties.getColorPickerString(&quot;opacity_colon&quot;), 100, colorRectPane.alpha);

            hsbButton.setToggleGroup(group);
            rgbButton.setToggleGroup(group);
            webButton.setToggleGroup(group);
            group.selectedToggleProperty().addListener((observable, oldValue, newValue) -&gt; {
                if (newValue == null) {
                    group.selectToggle(oldValue);
                } else {
                    if (newValue == hsbButton) {
                        showHSBSettings();
                    } else if (newValue == rgbButton) {
                        showRGBSettings();
                    } else {
                        showWebSettings();
                    }
                }
            });
            group.selectToggle(hsbButton);

            buttonBox = new HBox();
            buttonBox.setId(&quot;buttons-hbox&quot;);

            Button saveButton = new Button(saveBtnText != null &amp;&amp; !saveBtnText.isEmpty() ? saveBtnText : Properties.getColorPickerString(&quot;Save&quot;));
            saveButton.setDefaultButton(true);
            saveButton.setOnAction(t -&gt; {
                if (onSave != null) {
                    onSave.run();
                }
                dialog.hide();
            });

            Button useButton = new Button(Properties.getColorPickerString(&quot;Use&quot;));
            useButton.setOnAction(t -&gt; {
                if (onUse != null) {
                    onUse.run();
                }
                dialog.hide();
            });

            Button cancelButton = new Button(Properties.getColorPickerString(&quot;Cancel&quot;));
            cancelButton.setCancelButton(true);
            cancelButton.setOnAction(e -&gt; {
                customColorProperty.set(getCurrentColor());
                if (onCancel != null) {
                    onCancel.run();
                }
                dialog.hide();
            });

            if (showUseBtn) {
                buttonBox.getChildren().addAll(saveButton, useButton, cancelButton);
            } else {
                buttonBox.getChildren().addAll(saveButton, cancelButton);
            }

            getChildren().addAll(currentAndNewColor, settingsPane, buttonBox);
        }

        private void showHSBSettings() {
            set(0, Properties.getColorPickerString(&quot;hue_colon&quot;), 360, colorRectPane.hue);
            set(1, Properties.getColorPickerString(&quot;saturation_colon&quot;), 100, colorRectPane.sat);
            set(2, Properties.getColorPickerString(&quot;brightness_colon&quot;), 100, colorRectPane.bright);
        }

        private void showRGBSettings() {
            set(0, Properties.getColorPickerString(&quot;red_colon&quot;), 255, colorRectPane.red);
            set(1, Properties.getColorPickerString(&quot;green_colon&quot;), 255, colorRectPane.green);
            set(2, Properties.getColorPickerString(&quot;blue_colon&quot;), 255, colorRectPane.blue);
        }

        private void showWebSettings() {
            labels[0].setText(Properties.getColorPickerString(&quot;web_colon&quot;));
        }

        private Property&lt;Number&gt;[] bindedProperties = new Property[4];

        private void set(int row, String caption, int maxValue, Property&lt;Number&gt; prop) {
            labels[row].setText(caption);
            if (bindedProperties[row] != null) {
                sliders[row].valueProperty().unbindBidirectional(bindedProperties[row]);
                fields[row].valueProperty().unbindBidirectional(bindedProperties[row]);
            }
            sliders[row].setMax(maxValue);
            sliders[row].valueProperty().bindBidirectional(prop);
            labels[row].setLabelFor(sliders[row]);
            fields[row].setMaxValue(maxValue);
            fields[row].valueProperty().bindBidirectional(prop);
            bindedProperties[row] = prop;
        }
    }
<A NAME="18"></A>
    static double clamp(double value) {
        return value &lt; 0 ? 0 : value &gt; 1 ? 1 : value;
    <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#18',2,'match45-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private static LinearGradient createHueGradient() {
        double offset;
        Stop[] stops = new Stop[255];
        for (int y = 0; y &lt; 255; y++) {</B></FONT>
            offset = (double) (1 - (1.0 / 255) * y);
            int h = (int) ((y / 255.0) * 360);
            stops[y] = new Stop(offset, Color.hsb(h, 1.0, 1.0));
        }
        return new LinearGradient(0f, 1f, 0f, 0f, true, CycleMethod.NO_CYCLE, stops);
    }

    private static int doubleToInt(double value) {
        return (int) (value * 255 + 0.5); // Adding 0.5 for rounding only
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/VirtualScrollBar.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="12"></A> * questions.
 */

<FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#12',2,'match45-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.scene.control;

import com.sun.javafx.util.Utils;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.skin.VirtualFlow;

/**
 * This custom ScrollBar is used to map the increment &amp; decrement features
 * to pixel based scrolling rather than thumb/track based scrolling, if the
 * &quot;virtual&quot; attribute is true.
 */
public class VirtualScrollBar extends ScrollBar {

    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    private final VirtualFlow flow;

    private boolean adjusting;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new VirtualScrollBar, for use by the VirtualFlow control.
     */
    public VirtualScrollBar(final VirtualFlow flow) {</B></FONT>
        this.flow = flow;

        super.valueProperty().addListener(valueModel -&gt; {
            if (isVirtual()/* &amp;&amp; oldValue != newValue*/) {
                if (adjusting) {
                    // no-op
                } else {
                    flow.setPosition(getValue());
                }
            }
        });
    }



    /**************************************************************************
     *
     * Properties
     *
     **************************************************************************/

    // --- virtual
    private BooleanProperty virtual = new SimpleBooleanProperty(this, &quot;virtual&quot;);
    public final void setVirtual(boolean value) {
        virtual.set(value);
    }

    public final boolean isVirtual() {
        return virtual.get();
    }

    public final BooleanProperty virtualProperty() {
        return virtual;
    }


    /**************************************************************************
     *
     * Public API
     *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void decrement() {
        if (isVirtual()) {
            flow.scrollPixels(-10);
        } else {
            super.decrement();
        }
    }

    /** {@inheritDoc} */
    @Override public void increment() {
        if (isVirtual()) {
            flow.scrollPixels(10);
        } else {
            super.increment();
        }
    }

    // this method is called when the user clicks in the scrollbar track, so
    // we special-case it to allow for page-up and page-down clicking to work
    // as expected.
    /** {@inheritDoc} */
    @Override public void adjustValue(double pos) {
        if (isVirtual()) {
            adjusting = true;
            double oldValue = flow.getPosition();

            double newValue = ((getMax() - getMin()) * Utils.clamp(0, pos, 1))+getMin();
            if (newValue &lt; oldValue) {
                IndexedCell cell = flow.getFirstVisibleCell();
                if (cell == null) return;
                flow.scrollToBottom(cell);
            } else if (newValue &gt; oldValue) {
                IndexedCell cell = flow.getLastVisibleCell();
                if (cell == null) return;
                flow.scrollToTop(cell);
            }

            adjusting = false;
        } else {
            super.adjustValue(pos);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ScrollBarBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.util.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Orientation;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.Skin;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.util.Duration;

import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.KEY_RELEASED;

/**
 * A Behavior implementation for ScrollBars.
 *
 */

public class ScrollBarBehavior extends BehaviorBase&lt;ScrollBar&gt; {

    private final InputMap&lt;ScrollBar&gt; inputMap;

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public ScrollBarBehavior(ScrollBar scrollBar) {
        super(scrollBar);

        // create a map for scrollbar-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // scrollbar-specific mappings for key and mouse input
        addDefaultMapping(inputMap,
            new InputMap.KeyMapping(HOME, KEY_RELEASED, e -&gt; home()),
            new InputMap.KeyMapping(END, KEY_RELEASED, e -&gt; end())
        );

        // create two child input maps for horizontal and vertical scrollbars
        InputMap&lt;ScrollBar&gt; horizontalInputMap = new InputMap&lt;&gt;(scrollBar);
        horizontalInputMap.setInterceptor(e -&gt; scrollBar.getOrientation() != Orientation.HORIZONTAL);
        horizontalInputMap.getMappings().addAll(
            new InputMap.KeyMapping(LEFT, e -&gt; rtl(scrollBar, this::incrementValue, this::decrementValue)),
            new InputMap.KeyMapping(KP_LEFT, e -&gt; rtl(scrollBar, this::incrementValue, this::decrementValue)),
            new InputMap.KeyMapping(RIGHT, e -&gt; rtl(scrollBar, this::decrementValue, this::incrementValue)),
            new InputMap.KeyMapping(KP_RIGHT, e -&gt; rtl(scrollBar, this::decrementValue, this::incrementValue))
        );
        addDefaultChildMap(inputMap, horizontalInputMap);

        InputMap&lt;ScrollBar&gt; verticalInputMap = new InputMap&lt;&gt;(scrollBar);
        verticalInputMap.setInterceptor(e -&gt; scrollBar.getOrientation() != Orientation.VERTICAL);
        verticalInputMap.getMappings().addAll(
                new InputMap.KeyMapping(UP, e -&gt; decrementValue()),
                new InputMap.KeyMapping(KP_UP, e -&gt; decrementValue()),
                new InputMap.KeyMapping(DOWN, e -&gt; incrementValue()),
                new InputMap.KeyMapping(KP_DOWN, e -&gt; incrementValue())
        );
        addDefaultChildMap(inputMap, verticalInputMap);
    }

    /***************************************************************************
     *                                                                         *
     * Functions                                                               *
     *                                                                         *
     **************************************************************************/


    @Override public InputMap&lt;ScrollBar&gt; getInputMap() {
<A NAME="29"></A>        return inputMap;
    }
    private void home() {
        <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#29',2,'match45-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getNode().setValue(getNode().getMin());
    }

    private void decrementValue() {
        getNode().adjustValue(0);
    }

    private void end() {</B></FONT>
        getNode().setValue(getNode().getMax());
    }

    private void incrementValue() {
        getNode().adjustValue(1);
    }


    /***************************************************************************
     *                                                                         *
     * Mouse event handling                                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * This timeline is used to adjust the value of the bar when the
     * track has been pressed but not released.
     */
    Timeline timeline;

    /**
     * Invoked by the ScrollBar {@link Skin} implementation whenever a mouse
     * press occurs on the &quot;track&quot; of the bar. This will cause the thumb to
     * be moved by some amount.
     *
     * @param position The mouse position on track with 0.0 being beginning of track and 1.0 being the end
     */
    public void trackPress(double position) {

        /* We can get a press if someone presses an end button.  In that
         * case, we don't want to start a timeline because the end button
         * will have already done so.  We can detect that because the timeline
         * will not be null.
         */
        if (timeline != null) return;

        // determine the percentage of the way between min and max
        // represented by this mouse event
        final ScrollBar bar = getNode();
        if (!bar.isFocused() &amp;&amp; bar.isFocusTraversable()) bar.requestFocus();
        final double pos = position;
        final boolean incrementing = (pos &gt; ((bar.getValue() - bar.getMin())/(bar.getMax() - bar.getMin())));
        timeline = new Timeline();
        timeline.setCycleCount(Timeline.INDEFINITE);

        final EventHandler&lt;ActionEvent&gt; step =
                event -&gt; {
                    boolean i = (pos &gt; ((bar.getValue() - bar.getMin())/(bar.getMax() - bar.getMin())));
                    if (incrementing == i) {
                        // we started incrementing and still are, or we
                        // started decrementing and still are
                        bar.adjustValue(pos);
                    }
                    else {
                        stopTimeline();
                    }
                };

        final KeyFrame kf = new KeyFrame(Duration.millis(200), step);
        timeline.getKeyFrames().add(kf);
        // do the first step immediately
        timeline.play();
        step.handle(null);
    }

    /**
     */
    public void trackRelease() {
        stopTimeline();
    }

    /**
     * Invoked by the ScrollBar {@link Skin} implementation whenever a mouse
     * press occurs on the decrement button of the bar.
     */
    public void decButtonPressed() {
        final ScrollBar bar = getNode();
        if (!bar.isFocused() &amp;&amp; bar.isFocusTraversable()) bar.requestFocus();
        stopTimeline();
        timeline = new Timeline();
        timeline.setCycleCount(Timeline.INDEFINITE);

        final EventHandler&lt;ActionEvent&gt; dec =
                event -&gt; {
                    if (bar.getValue() &gt; bar.getMin()) {
                        bar.decrement();
                    }
                    else {
                        stopTimeline();
                    }
                };

        final KeyFrame kf = new KeyFrame(Duration.millis(200), dec);
        timeline.getKeyFrames().add(kf);
        // do the first step immediately
        timeline.play();
        dec.handle(null);
    }

    /**
     */
    public void decButtonReleased() {
        stopTimeline();
    }

    /**
     * Invoked by the ScrollBar {@link Skin} implementation whenever a mouse
     * press occurs on the increment button of the bar.
     */
    public void incButtonPressed() {
        final ScrollBar bar = getNode();
        if (!bar.isFocused() &amp;&amp; bar.isFocusTraversable()) bar.requestFocus();
        stopTimeline();
        timeline = new Timeline();
        timeline.setCycleCount(Timeline.INDEFINITE);

        final EventHandler&lt;ActionEvent&gt; inc =
                event -&gt; {
                    if (bar.getValue() &lt; bar.getMax()) {
                        bar.increment();
                    }
                    else {
                        stopTimeline();
                    }
                };

        final KeyFrame kf = new KeyFrame(Duration.millis(200), inc);
        timeline.getKeyFrames().add(kf);
        // do the first step immediately
        timeline.play();
        inc.handle(null);
    }

    /**
     */
    public void incButtonReleased() {
        stopTimeline();
    }

    /**
     * @param position The mouse position on track with 0.0 being begining of track and 1.0 being the end
     */
    //public function thumbPressed(e:MouseEvent, position:Number):Void {
    //}

    /**
     * @param position The mouse position on track with 0.0 being begining of track and 1.0 being the end
     */
    public void thumbDragged(double position) {
        final ScrollBar scrollbar = getNode();

        // Stop the timeline for continuous increments as drags take precedence
        stopTimeline();

        if (!scrollbar.isFocused() &amp;&amp; scrollbar.isFocusTraversable()) scrollbar.requestFocus();
        double newValue = (position * (scrollbar.getMax() - scrollbar.getMin())) + scrollbar.getMin();
        if (!Double.isNaN(newValue)) {
            scrollbar.setValue(Utils.clamp(scrollbar.getMin(), newValue, scrollbar.getMax()));
        }
    }

    private void stopTimeline() {
        if (timeline != null) {
            timeline.stop();
            timeline = null;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/Chart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.scene.control.skin.Utils;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.ObservableList;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;

import com.sun.javafx.charts.ChartLayoutAnimator;
import com.sun.javafx.charts.Legend;
import com.sun.javafx.scene.NodeHelper;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Base class for all charts. It has 3 parts the title, legend and chartContent. The chart content is populated by the
 * specific subclass of Chart.
 *
 * @since JavaFX 2.0
 */
public abstract class Chart extends Region {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------

    private static final int MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT = 200;
    private static final int MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT = 150;

    /** Title Label */
    private final Label titleLabel = new Label();
    /**
     * This is the Pane that Chart subclasses use to contain the chart content,
     * It is sized to be inside the chart area leaving space for the title and legend.
     */
    private final Pane chartContent = new Pane() {
        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double left = snappedLeftInset();
            final double bottom = snappedBottomInset();
            final double right = snappedRightInset();
            final double width = getWidth();
            final double height = getHeight();
            final double contentWidth = snapSizeX(width - (left + right));
            final double contentHeight = snapSizeY(height - (top + bottom));
            layoutChartChildren(snapPositionY(top), snapPositionX(left), contentWidth, contentHeight);
        }
        @Override public boolean usesMirroring() {
            return useChartContentMirroring;
        }
    };
    // Determines if chart content should be mirrored if node orientation is right-to-left.
    boolean useChartContentMirroring = true;

    /** Animator for animating stuff on the chart */
    private final ChartLayoutAnimator animator = new ChartLayoutAnimator(chartContent);

    // -------------- PUBLIC PROPERTIES --------------------------------------------------------------------------------

    /** The chart title */
    private StringProperty title = new StringPropertyBase() {
        @Override protected void invalidated() {
            titleLabel.setText(get());
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;title&quot;;
        }
    };
    public final String getTitle() { return title.get(); }
    public final void setTitle(String value) { title.set(value); }
    public final StringProperty titleProperty() { return title; }

    /**
     * The side of the chart where the title is displayed
     * @defaultValue Side.TOP
     */
    private ObjectProperty&lt;Side&gt; titleSide = new StyleableObjectProperty&lt;Side&gt;(Side.TOP) {
        @Override protected void invalidated() {
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Side&gt; getCssMetaData() {
            return StyleableProperties.TITLE_SIDE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;titleSide&quot;;
        }
    };
    public final Side getTitleSide() { return titleSide.get(); }
    public final void setTitleSide(Side value) { titleSide.set(value); }
    public final ObjectProperty&lt;Side&gt; titleSideProperty() { return titleSide; }

    /**
     * The node to display as the Legend. Subclasses can set a node here to be displayed on a side as the legend. If
     * no legend is wanted then this can be set to null
     */
    private final ObjectProperty&lt;Node&gt; legend = new ObjectPropertyBase&lt;Node&gt;() {
        private Node old = null;
        @Override protected void invalidated() {
            Node newLegend = get();
            if (old != null) getChildren().remove(old);
            if (newLegend != null) {
                getChildren().add(newLegend);
                newLegend.setVisible(isLegendVisible());
            }
            old = newLegend;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legend&quot;;
        }
    };
    protected final Node getLegend() { return legend.getValue(); }
    protected final void setLegend(Node value) { legend.setValue(value); }
    protected final ObjectProperty&lt;Node&gt; legendProperty() { return legend; }

    /**
     * When true the chart will display a legend if the chart implementation supports a legend.
     */
    private final BooleanProperty legendVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LEGEND_VISIBLE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legendVisible&quot;;
        }
    };
    public final boolean isLegendVisible() { return legendVisible.getValue(); }
    public final void setLegendVisible(boolean value) { legendVisible.setValue(value); }
    public final BooleanProperty legendVisibleProperty() { return legendVisible; }

    /**
     * The side of the chart where the legend should be displayed
     *
     * @defaultValue Side.BOTTOM
     */
    private ObjectProperty&lt;Side&gt; legendSide = new StyleableObjectProperty&lt;Side&gt;(Side.BOTTOM) {
        @Override protected void invalidated() {
            final Side legendSide = get();
            final Node legend = getLegend();
            if(legend instanceof Legend) ((Legend)legend).setVertical(Side.LEFT.equals(legendSide) || Side.RIGHT.equals(legendSide));
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Side&gt; getCssMetaData() {
            return StyleableProperties.LEGEND_SIDE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legendSide&quot;;
        }
    };
    public final Side getLegendSide() { return legendSide.get(); }
    public final void setLegendSide(Side value) { legendSide.set(value); }
    public final ObjectProperty&lt;Side&gt; legendSideProperty() { return legendSide; }

    /** When true any data changes will be animated. */
    private BooleanProperty animated = new SimpleBooleanProperty(this, &quot;animated&quot;, true);

    /**
     * Indicates whether data changes will be animated or not.
     *
     * @return true if data changes will be animated and false otherwise.
     */
    public final boolean getAnimated() { return animated.get(); }
    public final void setAnimated(boolean value) { animated.set(value); }
    public final BooleanProperty animatedProperty() { return animated; }

    // -------------- PROTECTED PROPERTIES -----------------------------------------------------------------------------

    /**
     * Modifiable and observable list of all content in the chart. This is where implementations of Chart should add
     * any nodes they use to draw their chart. This excludes the legend and title which are looked after by this class.
     *
     * @return Observable list of plot children
     */
    protected ObservableList&lt;Node&gt; getChartChildren() {
        return chartContent.getChildren();
    }

    // -------------- CONSTRUCTOR --------------------------------------------------------------------------------------

    /**
     * Creates a new default Chart instance.
     */
    public Chart() {
        titleLabel.setAlignment(Pos.CENTER);
<A NAME="13"></A>        titleLabel.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
        getChildren().addAll(titleLabel, chartContent);
        getStyleClass().add(&quot;chart&quot;);
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#13',2,'match45-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>titleLabel.getStyleClass().add(&quot;chart-title&quot;);
        chartContent.getStyleClass().add(&quot;chart-content&quot;);
        // mark chartContent as unmanaged because any changes to its preferred size shouldn't cause a relayout
        chartContent.setManaged(false);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * Play a animation involving the given keyframes. On every frame of the animation the chart will be relayed out
     *
     * @param keyFrames Array of KeyFrames to play
     */
    void animate(KeyFrame...keyFrames) { animator.animate(keyFrames); }

    /**
     * Play the given animation on every frame of the animation the chart will be relayed out until the animation
     * finishes. So to add a animation to a chart, create a animation on data model, during layoutChartContent() map
     * data model to nodes then call this method with the animation.
     *
     * @param animation The animation to play
     */
    protected void animate(Animation animation) {</B></FONT> animator.animate(animation); }

    /** Call this when you know something has changed that needs the chart to be relayed out. */
    protected void requestChartLayout() {
        chartContent.requestLayout();
    }

    /**
     * This is used to check if any given animation should run. It returns true if animation is enabled and the node
     * is visible and in a scene.
     * @return true if animation is enabled and the node is visible and in a scene
     */
    protected final boolean shouldAnimate(){
        return getAnimated() &amp;&amp; NodeHelper.isTreeShowing(this);
    }

    /**
     * Called to update and layout the chart children available from getChartChildren()
     *
     * @param top The top offset from the origin to account for any padding on the chart content
     * @param left The left offset from the origin to account for any padding on the chart content
     * @param width The width of the area to layout the chart within
     * @param height The height of the area to layout the chart within
     */
    protected abstract void layoutChartChildren(double top, double left, double width, double height);

    /**
     * Invoked during the layout pass to layout this chart and all its content.
     */
    @Override protected void layoutChildren() {
        double top = snappedTopInset();
        double left = snappedLeftInset();
        double bottom = snappedBottomInset();
        double right = snappedRightInset();
        final double width = getWidth();
        final double height = getHeight();
        // layout title
        if (getTitle() != null) {
            titleLabel.setVisible(true);
            if (getTitleSide().equals(Side.TOP)) {
                final double titleHeight = snapSizeY(titleLabel.prefHeight(width-left-right));
                titleLabel.resizeRelocate(left,top,width-left-right,titleHeight);
                top += titleHeight;
            } else if (getTitleSide().equals(Side.BOTTOM)) {
                final double titleHeight = snapSizeY(titleLabel.prefHeight(width-left-right));
                titleLabel.resizeRelocate(left,height-bottom-titleHeight,width-left-right,titleHeight);
                bottom += titleHeight;
            } else if (getTitleSide().equals(Side.LEFT)) {
                final double titleWidth = snapSizeX(titleLabel.prefWidth(height-top-bottom));
                titleLabel.resizeRelocate(left,top,titleWidth,height-top-bottom);
                left += titleWidth;
            } else if (getTitleSide().equals(Side.RIGHT)) {
                final double titleWidth = snapSizeX(titleLabel.prefWidth(height-top-bottom));
                titleLabel.resizeRelocate(width-right-titleWidth,top,titleWidth,height-top-bottom);
                right += titleWidth;
            }
        } else {
            titleLabel.setVisible(false);
        }
        // layout legend
        final Node legend = getLegend();
        if (legend != null) {
            boolean shouldShowLegend = isLegendVisible();
            if (shouldShowLegend) {
                if (getLegendSide() == Side.TOP) {
                    final double legendHeight = snapSizeY(legend.prefHeight(width-left-right));
                    final double legendWidth = Utils.boundedSize(snapSizeX(legend.prefWidth(legendHeight)), 0, width - left - right);
                    legend.resizeRelocate(left + (((width - left - right)-legendWidth)/2), top, legendWidth, legendHeight);
                    if ((height - bottom - top - legendHeight) &lt; MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        top += legendHeight;
                    }
                } else if (getLegendSide() == Side.BOTTOM) {
                    final double legendHeight = snapSizeY(legend.prefHeight(width-left-right));
                    final double legendWidth = Utils.boundedSize(snapSizeX(legend.prefWidth(legendHeight)), 0, width - left - right);
                    legend.resizeRelocate(left + (((width - left - right)-legendWidth)/2), height-bottom-legendHeight, legendWidth, legendHeight);
                    if ((height - bottom - top - legendHeight) &lt; MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        bottom += legendHeight;
                    }
                } else if (getLegendSide() == Side.LEFT) {
                    final double legendWidth = snapSizeX(legend.prefWidth(height-top-bottom));
                    final double legendHeight = Utils.boundedSize(snapSizeY(legend.prefHeight(legendWidth)), 0, height - top - bottom);
                    legend.resizeRelocate(left,top +(((height-top-bottom)-legendHeight)/2),legendWidth,legendHeight);
                    if ((width - left - right - legendWidth) &lt; MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        left += legendWidth;
                    }
                } else if (getLegendSide() == Side.RIGHT) {
                    final double legendWidth = snapSizeX(legend.prefWidth(height-top-bottom));
                    final double legendHeight = Utils.boundedSize(snapSizeY(legend.prefHeight(legendWidth)), 0, height - top - bottom);
                    legend.resizeRelocate(width-right-legendWidth,top +(((height-top-bottom)-legendHeight)/2),legendWidth,legendHeight);
                    if ((width - left - right - legendWidth) &lt; MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        right += legendWidth;
                    }
                }
            }
            legend.setVisible(shouldShowLegend);
        }
        // whats left is for the chart content
        chartContent.resizeRelocate(left,top,width-left-right,height-top-bottom);
    }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So minimum
     * height is a constant 150.
     */
    @Override protected double computeMinHeight(double width) { return 150; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So minimum
     * width is a constant 200.
     */
    @Override protected double computeMinWidth(double height) { return 200; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So preferred
     * width is a constant 500.
     */
    @Override protected double computePrefWidth(double height) { return 500.0; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So preferred
     * height is a constant 400.
     */
    @Override protected double computePrefHeight(double width) { return 400.0; }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;Chart,Side&gt; TITLE_SIDE =
            new CssMetaData&lt;Chart,Side&gt;(&quot;-fx-title-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class),
                Side.TOP) {

            @Override
            public boolean isSettable(Chart node) {
                return node.titleSide == null || !node.titleSide.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)node.titleSideProperty();
            }
        };

        private static final CssMetaData&lt;Chart,Side&gt; LEGEND_SIDE =
            new CssMetaData&lt;Chart,Side&gt;(&quot;-fx-legend-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class),
                Side.BOTTOM) {

            @Override
            public boolean isSettable(Chart node) {
                return node.legendSide == null || !node.legendSide.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)node.legendSideProperty();
            }
        };

        private static final CssMetaData&lt;Chart,Boolean&gt; LEGEND_VISIBLE =
            new CssMetaData&lt;Chart,Boolean&gt;(&quot;-fx-legend-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Chart node) {
                return node.legendVisible == null || !node.legendVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.legendVisibleProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(TITLE_SIDE);
            styleables.add(LEGEND_VISIBLE);
            styleables.add(LEGEND_SIDE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/PieChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Side;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcTo;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.ClosePath;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.text.Text;
import javafx.scene.transform.Scale;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend;
import com.sun.javafx.charts.Legend.LegendItem;
import com.sun.javafx.collections.NonIterableChange;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.SizeConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Displays a PieChart. The chart content is populated by pie slices based on
 * data set on the PieChart.
 * &lt;p&gt; The clockwise property is set to true by default, which means slices are
 * placed in the clockwise order. The labelsVisible property is used to either display
 * pie slice labels or not.
 *
 * @since JavaFX 2.0
 */
public class PieChart extends Chart {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------
    private static final int MIN_PIE_RADIUS = 25;
    private static final double LABEL_TICK_GAP = 6;
    private static final double LABEL_BALL_RADIUS = 2;
    private BitSet colorBits = new BitSet(8);
    private double pieRadius;
    private Data begin = null;
    private final Path labelLinePath = new Path() {
        @Override public boolean usesMirroring() {
            return false;
        }
    };
    private List&lt;LabelLayoutInfo&gt; labelLayoutInfos = null;
    private Legend legend = new Legend();
    private Data dataItemBeingRemoved = null;
    private Timeline dataRemoveTimeline = null;
    private final ListChangeListener&lt;Data&gt; dataChangeListener = c -&gt; {
        while (c.next()) {
            // RT-28090 Probably a sort happened, just reorder the pointers.
            if (c.wasPermutated()) {
                Data ptr = begin;
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                    if (i == 0) {
                        begin = item;
                        ptr = begin;
                        begin.next = null;
                    } else {
                        ptr.next = item;
                        item.next = null;
                        ptr = item;
                    }
                }
                updateLegend();
                requestChartLayout();
                return;
            }
            // recreate linked list &amp; set chart on new data
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                item.setChart(PieChart.this);
                if (begin == null) {
                    begin = item;
                    begin.next = null;
                } else {
                    if (i == 0) {
                        item.next = begin;
                        begin = item;
                    } else {
                        Data ptr = begin;
                        for (int j = 0; j &lt; i -1 ; j++) {
                            ptr = ptr.next;
                        }
                        item.next = ptr.next;
                        ptr.next = item;
                    }
                }
            }
            // call data added/removed methods
            for (Data item : c.getRemoved()) {
                dataItemRemoved(item);
            }
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                // assign default color to the added slice
                // TODO: check nearby colors
                item.defaultColorIndex = colorBits.nextClearBit(0);
                colorBits.set(item.defaultColorIndex);
                dataItemAdded(item, i);
            }
            if (c.wasRemoved() || c.wasAdded()) {
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                }
                updateLegend();
            }
        }
        // re-layout everything
        requestChartLayout();
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** PieCharts data */
    private ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; data = new ObjectPropertyBase&lt;ObservableList&lt;Data&gt;&gt;() {
        private ObservableList&lt;Data&gt; old;
        @Override protected void invalidated() {
            final ObservableList&lt;Data&gt; current = getValue();
            // add remove listeners
            if(old != null) old.removeListener(dataChangeListener);
            if(current != null) current.addListener(dataChangeListener);
            // fire data change event if series are added or removed
            if(old != null || current != null) {
                final List&lt;Data&gt; removed = (old != null) ? old : Collections.&lt;Data&gt;emptyList();
                final int toIndex = (current != null) ? current.size() : 0;
                // let data listener know all old data have been removed and new data that has been added
                if (toIndex &gt; 0 || !removed.isEmpty()) {
                    dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, toIndex, current){
                        @Override public List&lt;Data&gt; getRemoved() { return removed; }
                        @Override public boolean wasPermutated() { return false; }
                        @Override protected int[] getPermutation() {
                            return new int[0];
                        }
                    });
                }
            } else if (old != null &amp;&amp; old.size() &gt; 0) {
                // let series listener know all old series have been removed
                dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, 0, current){
                    @Override public List&lt;Data&gt; getRemoved() { return old; }
                    @Override public boolean wasPermutated() { return false; }
                    @Override protected int[] getPermutation() {
                        return new int[0];
                    }
                });
            }
            old = current;
        }

        public Object getBean() {
            return PieChart.this;
        }

        public String getName() {
            return &quot;data&quot;;
        }
    };
    public final ObservableList&lt;Data&gt; getData() { return data.getValue(); }
    public final void setData(ObservableList&lt;Data&gt; value) { data.setValue(value); }
    public final ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; dataProperty() { return data; }

    /** The angle to start the first pie slice at */
    private DoubleProperty startAngle = new StyleableDoubleProperty(0) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;startAngle&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.START_ANGLE;
        }
    };
    public final double getStartAngle() { return startAngle.getValue(); }
    public final void setStartAngle(double value) { startAngle.setValue(value); }
    public final DoubleProperty startAngleProperty() { return startAngle; }

    /** When true we start placing slices clockwise from the startAngle */
    private BooleanProperty clockwise = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;clockwise&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CLOCKWISE;
        }
    };
    public final void setClockwise(boolean value) { clockwise.setValue(value);}
    public final boolean isClockwise() { return clockwise.getValue(); }
    public final BooleanProperty clockwiseProperty() { return clockwise; }


    /** The length of the line from the outside of the pie to the slice labels. */
    private DoubleProperty labelLineLength = new StyleableDoubleProperty(20d) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelLineLength&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.LABEL_LINE_LENGTH;
        }
    };
    public final double getLabelLineLength() { return labelLineLength.getValue(); }
    public final void setLabelLineLength(double value) { labelLineLength.setValue(value); }
    public final DoubleProperty labelLineLengthProperty() { return labelLineLength; }

    /** When true pie slice labels are drawn */
    private BooleanProperty labelsVisible = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelsVisible&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LABELS_VISIBLE;
        }
    };
    public final void setLabelsVisible(boolean value) { labelsVisible.setValue(value);}

    /**
     * Indicates whether pie slice labels are drawn or not
     * @return true if pie slice labels are visible and false otherwise.
     */
    public final boolean getLabelsVisible() { return labelsVisible.getValue(); }
    public final BooleanProperty labelsVisibleProperty() { return labelsVisible; }

    // -------------- CONSTRUCTOR ----------------------------------------------

    /**
     * Construct a new empty PieChart.
     */
    public PieChart() {
        this(FXCollections.&lt;Data&gt;observableArrayList());
    }

    /**
     * Construct a new PieChart with the given data
     *
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public PieChart(ObservableList&lt;PieChart.Data&gt; data) {
        getChartChildren().add(labelLinePath);
        labelLinePath.getStyleClass().add(&quot;chart-pie-label-line&quot;);
        setLegend(legend);
        setData(data);
        // set chart content mirroring to be always false i.e. chartContent mirrorring is not done
        // when  node orientation is right-to-left for PieChart.
        useChartContentMirroring = false;
    }

    // -------------- METHODS --------------------------------------------------

    private void dataNameChanged(Data item) {
        item.textNode.setText(item.getName());
        requestChartLayout();
        updateLegend();
    }

    private void dataPieValueChanged(Data item) {
        if (shouldAnimate()) {
            animate(
                new KeyFrame(Duration.ZERO, new KeyValue(item.currentPieValueProperty(),
                        item.getCurrentPieValue())),
                new KeyFrame(Duration.millis(500),new KeyValue(item.currentPieValueProperty(),
                        item.getPieValue(), Interpolator.EASE_BOTH))
            );
        } else {
            item.setCurrentPieValue(item.getPieValue());
            requestChartLayout(); // RT-23091
        }
    }

    private Node createArcRegion(Data item) {
        Node arcRegion = item.getNode();
        // check if symbol has already been created
        if (arcRegion == null) {
            arcRegion = new Region();
            arcRegion.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
            arcRegion.setPickOnBounds(false);
            item.setNode(arcRegion);
        }
        return arcRegion;
    }

    private Text createPieLabel(Data item) {
        Text text = item.textNode;
        text.setText(item.getName());
        return text;
    }

    private void updateDataItemStyleClass(final Data item, int index) {
        Node node = item.getNode();
        if (node != null) {
            // Note: not sure if we want to add or check, ie be more careful and efficient here
            node.getStyleClass().setAll(&quot;chart-pie&quot;, &quot;data&quot; + index,
                    &quot;default-color&quot; + item.defaultColorIndex % 8);
            if (item.getPieValue() &lt; 0) {
                node.getStyleClass().add(&quot;negative&quot;);
            }
        }
    }

    private void dataItemAdded(final Data item, int index) {
        // create shape
        Node shape = createArcRegion(item);
        final Text text = createPieLabel(item);
        item.getChart().getChartChildren().add(shape);
        if (shouldAnimate()) {
            // if the same data item is being removed, first stop the remove animation,
            // remove the item and then start the add animation.
            if (dataRemoveTimeline != null &amp;&amp; dataRemoveTimeline.getStatus().equals(Animation.Status.RUNNING)) {
                if (dataItemBeingRemoved == item) {
                    dataRemoveTimeline.stop();
                    dataRemoveTimeline = null;
                    getChartChildren().remove(item.textNode);
                    getChartChildren().remove(shape);
                    removeDataItemRef(item);
                }
            }
            animate(
                new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            text.setOpacity(0);
                            // RT-23597 : item's chart might have been set to null if
                            // this item is added and removed before its add animation finishes.
                            if (item.getChart() == null) item.setChart(PieChart.this);
                            item.getChart().getChartChildren().add(text);
                            FadeTransition ft = new FadeTransition(Duration.millis(150),text);
                            ft.setToValue(1);
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), item.getPieValue(), Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 1, Interpolator.EASE_BOTH))
            );
        } else {
            getChartChildren().add(text);
            item.setRadiusMultiplier(1);
            item.setCurrentPieValue(item.getPieValue());
        }

        // we sort the text nodes to always be at the end of the children list, so they have a higher z-order
        // (Fix for RT-34564)
        for (int i = 0; i &lt; getChartChildren().size(); i++) {
            Node n = getChartChildren().get(i);
<A NAME="19"></A>            if (n instanceof Text) {
                n.toFront();
            }
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#19',2,'match45-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    }

    private void removeDataItemRef(Data item) {
        if (begin == item) {
            b</B></FONT>egin = item.next;
        } else {
            Data ptr = begin;
            while(ptr != null &amp;&amp; ptr.next != item) {
                ptr = ptr.next;
            }
            if(ptr != null) ptr.next = item.next;
        }
    }

    private Timeline createDataRemoveTimeline(final Data item) {
        final Node shape = item.getNode();
        Timeline t = new Timeline();
        t.getKeyFrames().addAll(new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            // removing item
                            colorBits.clear(item.defaultColorIndex);
                            getChartChildren().remove(shape);
                            // fade out label
                            FadeTransition ft = new FadeTransition(Duration.millis(150),item.textNode);
                            ft.setFromValue(1);
                            ft.setToValue(0);
                            ft.setOnFinished(new EventHandler&lt;ActionEvent&gt;() {
                                 @Override public void handle(ActionEvent actionEvent) {
                                     getChartChildren().remove(item.textNode);
                                     // remove chart references from old data - RT-22553
                                     item.setChart(null);
                                     removeDataItemRef(item);
                                     item.textNode.setOpacity(1.0);
                                 }
                            });
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), 0, Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 0))
                );
        return t;
    }

    private void dataItemRemoved(final Data item) {
        final Node shape = item.getNode();
        if (shouldAnimate()) {
            dataRemoveTimeline = createDataRemoveTimeline(item);
            dataItemBeingRemoved = item;
            animate(dataRemoveTimeline);
        } else {
            colorBits.clear(item.defaultColorIndex);
            getChartChildren().remove(item.textNode);
            getChartChildren().remove(shape);
            // remove chart references from old data
            item.setChart(null);
            removeDataItemRef(item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChartChildren(double top, double left, double contentWidth, double contentHeight) {
        double total = 0.0;
        for (Data item = begin; item != null; item = item.next) {
            total+= Math.abs(item.getCurrentPieValue());
        }
        double scale = (total != 0) ? 360 / total : 0;

         // calculate combined bounds of all labels &amp; pie radius
        double[] labelsX = null;
        double[] labelsY = null;
        double[] labelAngles = null;
        double labelScale = 1;
        List&lt;LabelLayoutInfo&gt; fullPie = null;
        boolean shouldShowLabels = getLabelsVisible();
        if (shouldShowLabels) {
            double xPad = 0d;
            double yPad = 0d;

            labelsX = new double[getDataSize()];
            labelsY = new double[getDataSize()];
            labelAngles = new double[getDataSize()];
            fullPie = new ArrayList&lt;&gt;();
            int index = 0;
            double start = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                // remove any scale on the text node
                item.textNode.getTransforms().clear();

                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                labelAngles[index] = normalizeAngle(start + (size / 2));
                final double sproutX = calcX(labelAngles[index], getLabelLineLength(), 0);
                final double sproutY = calcY(labelAngles[index], getLabelLineLength(), 0);
                labelsX[index] = sproutX;
                labelsY[index] = sproutY;
                xPad = Math.max(xPad, 2 * (item.textNode.getLayoutBounds().getWidth() + LABEL_TICK_GAP + Math.abs(sproutX)));
                if (sproutY &gt; 0) { // on bottom
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY+item.textNode.getLayoutBounds().getMaxY()));
                } else { // on top
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY + item.textNode.getLayoutBounds().getMinY()));
                }
                start+= size;
                index++;
            }
            pieRadius = Math.min(contentWidth - xPad, contentHeight - yPad) / 2;
            // check if this makes the pie too small
            if (pieRadius &lt; MIN_PIE_RADIUS ) {
                // calculate scale for text to fit labels in
                final double roomX = contentWidth-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                final double roomY = contentHeight-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                labelScale = Math.min(
                        roomX/xPad,
                        roomY/yPad
                );
                // hide labels if pie radius is less than minimum
                if ((begin == null &amp;&amp; labelScale &lt; 0.7) || ((begin.textNode.getFont().getSize()*labelScale) &lt; 9)) {
                    shouldShowLabels = false;
                    labelScale = 1;
                } else {
                    // set pieRadius to minimum
                    pieRadius = MIN_PIE_RADIUS;
                    // apply scale to all label positions
                    for(int i=0; i&lt; labelsX.length; i++) {
                        labelsX[i] =  labelsX[i] * labelScale;
                        labelsY[i] =  labelsY[i] * labelScale;
                    }
                }
            }
        }

        if (!shouldShowLabels) {
            pieRadius = Math.min(contentWidth,contentHeight) / 2;
            labelLinePath.getElements().clear();
        }

        if (getChartChildren().size() &gt; 0) {
            double centerX = contentWidth / 2 + left;
            double centerY = contentHeight / 2 + top;
            int index = 0;
            for (Data item = begin; item != null; item = item.next) {
                // layout labels for pie slice
                item.textNode.setVisible(shouldShowLabels);
                if (shouldShowLabels) {
                    double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                    final boolean isLeftSide = !(labelAngles[index] &gt; -90 &amp;&amp; labelAngles[index] &lt; 90);

                    double sliceCenterEdgeX = calcX(labelAngles[index], pieRadius, centerX);
                    double sliceCenterEdgeY = calcY(labelAngles[index], pieRadius, centerY);
                    double xval = isLeftSide ?
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMaxX() - LABEL_TICK_GAP) :
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMinX() + LABEL_TICK_GAP);
                    double yval = labelsY[index] + sliceCenterEdgeY - (item.textNode.getLayoutBounds().getMinY()/2) -2;

                    // do the line (Path)for labels
                    double lineEndX = sliceCenterEdgeX +labelsX[index];
                    double lineEndY = sliceCenterEdgeY +labelsY[index];
                    LabelLayoutInfo info = new LabelLayoutInfo(sliceCenterEdgeX,
                            sliceCenterEdgeY,lineEndX, lineEndY, xval, yval, item.textNode, Math.abs(size));
                    fullPie.add(info);

                    // set label scales
                    if (labelScale &lt; 1) {
                        item.textNode.getTransforms().add(
                            new Scale(
                                    labelScale, labelScale,
                                    isLeftSide ? item.textNode.getLayoutBounds().getWidth() : 0, 0
                            )
                        );
                    }
                }
                index++;
            }

            // update/draw pie slices
            double sAngle = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                Node node = item.getNode();
                Arc arc = null;
                if (node != null) {
                    if (node instanceof Region) {
                        Region arcRegion = (Region)node;
                        if (arcRegion.getShape() == null) {
                            arc = new Arc();
                            arcRegion.setShape(arc);
                        } else {
                            arc = (Arc)arcRegion.getShape();
                        }
                        arcRegion.setScaleShape(false);
                        arcRegion.setCenterShape(false);
                        arcRegion.setCacheShape(false);
                    }
                }
                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                // update slice arc size
                arc.setStartAngle(sAngle);
                arc.setLength(size);
                arc.setType(ArcType.ROUND);
                arc.setRadiusX(pieRadius * item.getRadiusMultiplier());
                arc.setRadiusY(pieRadius * item.getRadiusMultiplier());
                node.setLayoutX(centerX);
                node.setLayoutY(centerY);
                sAngle += size;
            }
            // finally draw the text and line
            if (fullPie != null) {
                // Check for collision and resolve by hiding the label of the smaller pie slice
                resolveCollision(fullPie);

                if (!fullPie.equals(labelLayoutInfos)) {
                    labelLinePath.getElements().clear();
                    for (LabelLayoutInfo info : fullPie) {
                        if (info.text.isVisible()) drawLabelLinePath(info);
                    }
                    labelLayoutInfos = fullPie;
                }
            }
        }
    }

    // We check for pie slice label collision and if collision is detected, we then
    // compare the size of the slices, and hide the label of the smaller slice.
    private void resolveCollision(List&lt;LabelLayoutInfo&gt; list) {
        int boxH = (begin != null) ? (int)begin.textNode.getLayoutBounds().getHeight() : 0;
        for (int i = 0; i &lt; list.size(); i++ ) {
            for (int j = i+1; j &lt; list.size(); j++ ) {
                LabelLayoutInfo box1 = list.get(i);
                LabelLayoutInfo box2 = list.get(j);
                if ((box1.text.isVisible() &amp;&amp; box2.text.isVisible()) &amp;&amp;
                        (fuzzyGT(box2.textY, box1.textY) ? fuzzyLT((box2.textY - boxH - box1.textY), 2) :
                                fuzzyLT((box1.textY - boxH - box2.textY), 2)) &amp;&amp;
                        (fuzzyGT(box1.textX, box2.textX) ? fuzzyLT((box1.textX - box2.textX), box2.text.prefWidth(-1)) :
                                fuzzyLT((box2.textX - box1.textX), box1.text.prefWidth(-1)))) {
                    if (fuzzyLT(box1.size, box2.size)) {
                        box1.text.setVisible(false);
                    } else {
                        box2.text.setVisible(false);
                    }
                }
            }
        }
    }

    private int fuzzyCompare(double o1, double o2) {
       double fuzz = 0.00001;
       return (((Math.abs(o1 - o2)) &lt; fuzz) ? 0 : ((o1 &lt; o2) ? -1 : 1));
    }

    private boolean fuzzyGT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == 1;
    }

    private boolean fuzzyLT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == -1;
    }

    private void drawLabelLinePath(LabelLayoutInfo info) {
        info.text.setLayoutX(info.textX);
        info.text.setLayoutY(info.textY);
        labelLinePath.getElements().add(new MoveTo(info.startX, info.startY));
        labelLinePath.getElements().add(new LineTo(info.endX, info.endY));

        labelLinePath.getElements().add(new MoveTo(info.endX-LABEL_BALL_RADIUS,info.endY));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY-LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX+LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY+LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX-LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ClosePath());
    }
    /**
     * This is called whenever a series is added or removed and the legend needs to be updated
     */
    private void updateLegend() {
        Node legendNode = getLegend();
        if (legendNode != null &amp;&amp; legendNode != legend) return; // RT-23596 dont update when user has set legend.
        legend.setVertical(getLegendSide().equals(Side.LEFT) || getLegendSide().equals(Side.RIGHT));
        List&lt;Legend.LegendItem&gt; legendList = new ArrayList&lt;&gt;();
        if (getData() != null) {
            for (Data item : getData()) {
                LegendItem legenditem = new LegendItem(item.getName());
                legenditem.getSymbol().getStyleClass().addAll(item.getNode().getStyleClass());
                legenditem.getSymbol().getStyleClass().add(&quot;pie-legend-symbol&quot;);
                legendList.add(legenditem);
            }
        }
        legend.getItems().setAll(legendList);
        if (legendList.size() &gt; 0) {
            if (legendNode == null) {
                setLegend(legend);
            }
        } else {
            setLegend(null);
        }
    }

    private int getDataSize() {
        int count = 0;
        for (Data d = begin; d != null; d = d.next) {
            count++;
        }
        return count;
    }

    private static double calcX(double angle, double radius, double centerX) {
        return (double)(centerX + radius * Math.cos(Math.toRadians(-angle)));
    }

    private static double calcY(double angle, double radius, double centerY) {
        return (double)(centerY + radius * Math.sin(Math.toRadians(-angle)));
    }

     /** Normalize any angle into -180 to 180 deg range */
    private static double normalizeAngle(double angle) {
        double a = angle % 360;
        if (a &lt;= -180) a += 360;
        if (a &gt; 180) a -= 360;
        return a;
    }

    // -------------- INNER CLASSES --------------------------------------------

    // Class holding label line layout info for collision detection and removal
    private final static class LabelLayoutInfo {
        double startX;
        double startY;
        double endX;
        double endY;
        double textX;
        double textY;
        Text text;
        double size;

        LabelLayoutInfo(double startX, double startY, double endX, double endY,
                double textX, double textY, Text text, double size) {
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
            this.textX = textX;
            this.textY = textY;
            this.text = text;
            this.size = size;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            LabelLayoutInfo that = (LabelLayoutInfo) o;
            return Double.compare(that.startX, startX) == 0 &amp;&amp;
                    Double.compare(that.startY, startY) == 0 &amp;&amp;
                    Double.compare(that.endX, endX) == 0 &amp;&amp;
                    Double.compare(that.endY, endY) == 0 &amp;&amp;
                    Double.compare(that.textX, textX) == 0 &amp;&amp;
                    Double.compare(that.textY, textY) == 0 &amp;&amp;
                    Double.compare(that.size, size) == 0;
        }

        @Override
        public int hashCode() {
            return Objects.hash(startX, startY, endX, endY, textX, textY, size);
        }
    }

    /**
     * PieChart Data Item, represents one slice in the PieChart
     *
     * @since JavaFX 2.0
     */
    public final static class Data {

        private Text textNode = new Text();
        /**
         * Next pointer for the next data item : so we can do animation on data delete.
         */
        private Data next = null;

        /**
         * Default color index for this slice.
         */
        private int defaultColorIndex;

        // -------------- PUBLIC PROPERTIES ------------------------------------

        /**
         * The chart which this data belongs to.
         */
        private ReadOnlyObjectWrapper&lt;PieChart&gt; chart = new ReadOnlyObjectWrapper&lt;PieChart&gt;(this, &quot;chart&quot;);

        public final PieChart getChart() {
            return chart.getValue();
        }

        private void setChart(PieChart value) {
            chart.setValue(value);
        }

        public final ReadOnlyObjectProperty&lt;PieChart&gt; chartProperty() {
            return chart.getReadOnlyProperty();
        }

        /**
         * The name of the pie slice
         */
        private StringProperty name = new StringPropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataNameChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;name&quot;;
            }
        };

        public final void setName(java.lang.String value) {
            name.setValue(value);
        }

        public final java.lang.String getName() {
            return name.getValue();
        }

        public final StringProperty nameProperty() {
            return name;
        }

        /**
         * The value of the pie slice
         */
        private DoubleProperty pieValue = new DoublePropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataPieValueChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;pieValue&quot;;
            }
        };

        public final double getPieValue() {
            return pieValue.getValue();
        }

        public final void setPieValue(double value) {
            pieValue.setValue(value);
        }

        public final DoubleProperty pieValueProperty() {
            return pieValue;
        }

        /**
         * The current pie value, used during animation. This will be the last data value, new data value or
         * anywhere in between
         */
        private DoubleProperty currentPieValue = new SimpleDoubleProperty(this, &quot;currentPieValue&quot;);

        private double getCurrentPieValue() {
            return currentPieValue.getValue();
        }

        private void setCurrentPieValue(double value) {
            currentPieValue.setValue(value);
        }

        private DoubleProperty currentPieValueProperty() {
            return currentPieValue;
        }

        /**
         * Multiplier that is used to animate the radius of the pie slice
         */
        private DoubleProperty radiusMultiplier = new SimpleDoubleProperty(this, &quot;radiusMultiplier&quot;);

        private double getRadiusMultiplier() {
            return radiusMultiplier.getValue();
        }

        private void setRadiusMultiplier(double value) {
            radiusMultiplier.setValue(value);
        }

        private DoubleProperty radiusMultiplierProperty() {
            return radiusMultiplier;
        }

        /**
         * Readonly access to the node that represents the pie slice. You can use this to add mouse event listeners etc.
         */
        private ReadOnlyObjectWrapper&lt;Node&gt; node = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;node&quot;);

        /**
         * Returns the node that represents the pie slice. You can use this to
         * add mouse event listeners etc.
         * @return the node that represents the pie slice
         */
        public Node getNode() {
            return node.getValue();
        }

        private void setNode(Node value) {
            node.setValue(value);
        }

        public ReadOnlyObjectProperty&lt;Node&gt; nodeProperty() {
            return node.getReadOnlyProperty();
        }

        // -------------- CONSTRUCTOR -------------------------------------------------

        /**
         * Constructs a PieChart.Data object with the given name and value.
         *
         * @param name  name for Pie
         * @param value pie value
         */
        public Data(java.lang.String name, double value) {
            setName(name);
            setPieValue(value);
            textNode.getStyleClass().addAll(&quot;text&quot;, &quot;chart-pie-label&quot;);
            textNode.setAccessibleRole(AccessibleRole.TEXT);
            textNode.setAccessibleRoleDescription(&quot;slice&quot;);
            textNode.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            textNode.accessibleTextProperty().bind( new StringBinding() {
                {bind(nameProperty(), currentPieValueProperty());}
                @Override protected String computeValue() {
                    return getName() + &quot; represents &quot; + getCurrentPieValue() + &quot; percent&quot;;
                }
            });
        }

        // -------------- PUBLIC METHODS ----------------------------------------------

        /**
         * Returns a string representation of this {@code Data} object.
         *
         * @return a string representation of this {@code Data} object.
         */
        @Override
        public java.lang.String toString() {
            return &quot;Data[&quot; + getName() + &quot;,&quot; + getPieValue() + &quot;]&quot;;
        }
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;PieChart,Boolean&gt; CLOCKWISE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-clockwise&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.clockwise == null || !node.clockwise.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.clockwiseProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Boolean&gt; LABELS_VISIBLE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-pie-label-visible&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelsVisible == null || !node.labelsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.labelsVisibleProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; LABEL_LINE_LENGTH =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-label-line-length&quot;,
                 SizeConverter.getInstance(), 20d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelLineLength == null || !node.labelLineLength.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.labelLineLengthProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; START_ANGLE =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-start-angle&quot;,
                 SizeConverter.getInstance(), 0d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.startAngle == null || !node.startAngle.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.startAngleProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Chart.getClassCssMetaData());
            styleables.add(CLOCKWISE);
            styleables.add(LABELS_VISIBLE);
            styleables.add(LABEL_LINE_LENGTH);
            styleables.add(START_ANGLE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ChoiceBox.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.util.StringConverter;
import javafx.css.PseudoClass;

import javafx.scene.control.skin.ChoiceBoxSkin;

import javafx.beans.DefaultProperty;

/**
 * The ChoiceBox is used for presenting the user with a relatively small set of
 * predefined choices from which they may choose. The ChoiceBox, when &quot;showing&quot;,
 * will display to the user these choices and allow them to pick exactly one
 * choice. When not showing, the current choice is displayed.
 * &lt;p&gt;
 * By default, the ChoiceBox has no item selected unless otherwise specified.
 * Although the ChoiceBox will only allow a user to select from the predefined
 * list, it is possible for the developer to specify the selected item to be
 * something other than what is available in the predefined list. This is
 * required for several important use cases.
 * &lt;p&gt;
 * It means configuration of the ChoiceBox is order independent. You
 * may either specify the items and then the selected item, or you may
 * specify the selected item and then the items. Either way will function
 * correctly.
 * &lt;p&gt;
 * ChoiceBox item selection is handled by
 * {@link javafx.scene.control.SelectionModel SelectionModel}
 * As with ListView and ComboBox, it is possible to modify the
 * {@link javafx.scene.control.SelectionModel SelectionModel} that is used,
 * although this is likely to be rarely changed. ChoiceBox supports only a
 * single selection model, hence the default used is a {@link SingleSelectionModel}.
 *
 * &lt;pre&gt;
 * import javafx.scene.control.ChoiceBox;
 *
 * ChoiceBox cb = new ChoiceBox();
 * cb.getItems().addAll(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;);
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;items&quot;)
public class ChoiceBox&lt;T&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Called prior to the ChoiceBox showing its popup after the user
     * has clicked or otherwise interacted with the ChoiceBox.
     * @since JavaFX 8u60
     */
    public static final EventType&lt;Event&gt; ON_SHOWING =
            new EventType&lt;Event&gt;(Event.ANY, &quot;CHOICE_BOX_ON_SHOWING&quot;);

    /**
     * Called after the ChoiceBox has shown its popup.
     * @since JavaFX 8u60
     */
    public static final EventType&lt;Event&gt; ON_SHOWN =
            new EventType&lt;Event&gt;(Event.ANY, &quot;CHOICE_BOX_ON_SHOWN&quot;);

    /**
     * Called when the ChoiceBox popup &lt;b&gt;will&lt;/b&gt; be hidden.
     * @since JavaFX 8u60
     */
    public static final EventType&lt;Event&gt; ON_HIDING =
            new EventType&lt;Event&gt;(Event.ANY, &quot;CHOICE_BOX_ON_HIDING&quot;);

    /**
     * Called when the ChoiceBox popup has been hidden.
     * @since JavaFX 8u60
     */
    public static final EventType&lt;Event&gt; ON_HIDDEN =
            new EventType&lt;Event&gt;(Event.ANY, &quot;CHOICE_BOX_ON_HIDDEN&quot;);



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Create a new ChoiceBox which has an empty list of items.
     */
    public ChoiceBox() {
        this(FXCollections.&lt;T&gt;observableArrayList());
    }

    /**
     * Create a new ChoiceBox with the given set of items. Since it is observable,
     * the content of this list may change over time and the ChoiceBox will
     * be updated accordingly.
     * @param items the set of items
     */
    public ChoiceBox(ObservableList&lt;T&gt; items) {
        getStyleClass().setAll(&quot;choice-box&quot;);
        setAccessibleRole(AccessibleRole.COMBO_BOX);
        setItems(items);
        setSelectionModel(new ChoiceBoxSelectionModel&lt;T&gt;(this));

        // listen to the value property, if the value is
        // set to something that exists in the items list, update the
        // selection model to indicate that this is the selected item
        valueProperty().addListener((ov, t, t1) -&gt; {
            if (getItems() == null) return;
            int index = getItems().indexOf(t1);
            if (index &gt; -1) {
                getSelectionModel().select(index);
            }
        });
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The selection model for the ChoiceBox. Only a single choice can be made,
     * hence, the ChoiceBox supports only a SingleSelectionModel. Generally, the
     * main interaction with the selection model is to explicitly set which item
     * in the items list should be selected, or to listen to changes in the
     * selection to know which item has been chosen.
     */
    private ObjectProperty&lt;SingleSelectionModel&lt;T&gt;&gt; selectionModel =
            new SimpleObjectProperty&lt;SingleSelectionModel&lt;T&gt;&gt;(this, &quot;selectionModel&quot;) {
         private SelectionModel&lt;T&gt; oldSM = null;
        @Override protected void invalidated() {
            if (oldSM != null) {
                oldSM.selectedItemProperty().removeListener(selectedItemListener);
            }
            SelectionModel&lt;T&gt; sm = get();
            oldSM = sm;
            if (sm != null) {
                sm.selectedItemProperty().addListener(selectedItemListener);
                if (sm.getSelectedItem() != null &amp;&amp; ! valueProperty().isBound()) {
                    ChoiceBox.this.setValue(sm.getSelectedItem());
                }
            }
        }
    };

    private ChangeListener&lt;T&gt; selectedItemListener = (ov, t, t1) -&gt; {
        if (! valueProperty().isBound()) {
            setValue(t1);
        }
    };


    public final void setSelectionModel(SingleSelectionModel&lt;T&gt; value) { selectionModel.set(value); }
    public final SingleSelectionModel&lt;T&gt; getSelectionModel() { return selectionModel.get(); }
    public final ObjectProperty&lt;SingleSelectionModel&lt;T&gt;&gt; selectionModelProperty() { return selectionModel; }


    /**
     * Indicates whether the drop down is displaying the list of choices to the
     * user. This is a readonly property which should be manipulated by means of
     * the #show and #hide methods.
     */
    private ReadOnlyBooleanWrapper showing = new ReadOnlyBooleanWrapper() {
        @Override protected void invalidated() {
            pseudoClassStateChanged(SHOWING_PSEUDOCLASS_STATE, get());
            notifyAccessibleAttributeChanged(AccessibleAttribute.EXPANDED);
        }

        @Override
        public Object getBean() {
            return ChoiceBox.this;
        }

        @Override
        public String getName() {
            return &quot;showing&quot;;
        }
    };
    public final boolean isShowing() { return showing.get(); }
    public final ReadOnlyBooleanProperty showingProperty() { return showing.getReadOnlyProperty(); }
    private void setShowing(boolean value) {
        // these events will not fire if the showing property is bound
        Event.fireEvent(this, value ? new Event(ON_SHOWING) :
                new Event(ON_HIDING));
        showing.set(value);
        Event.fireEvent(this, value ? new Event(ON_SHOWN) :
                new Event(ON_HIDDEN));
    }

    /**
     * The items to display in the choice box. The selected item (as indicated in the
     * selection model) must always be one of these items.
     */
    private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items = new ObjectPropertyBase&lt;ObservableList&lt;T&gt;&gt;() {
        ObservableList&lt;T&gt; old;
        @Override protected void invalidated() {
            final ObservableList&lt;T&gt; newItems = get();
            if (old != newItems) {
                // Add and remove listeners
                if (old != null) old.removeListener(itemsListener);
                if (newItems != null) newItems.addListener(itemsListener);
                // Clear the selection model
                final SingleSelectionModel&lt;T&gt; sm = getSelectionModel();
                if (sm != null) {
                    if (newItems != null &amp;&amp; newItems.isEmpty()) {
                        // RT-29433 - clear selection.
                        sm.clearSelection();
                    } else if (sm.getSelectedIndex() == -1 &amp;&amp; sm.getSelectedItem() != null) {
                        int newIndex = getItems().indexOf(sm.getSelectedItem());
                        if (newIndex != -1) {
                            sm.setSelectedIndex(newIndex);
                        }
                    } else sm.clearSelection();
                }
//                if (sm != null) sm.setSelectedIndex(-1);
                // Save off the old items
                old = newItems;
            }
        }

        @Override
        public Object getBean() {
            return ChoiceBox.this;
        }

        @Override
        public String getName() {
            return &quot;items&quot;;
        }
    };
    public final void setItems(ObservableList&lt;T&gt; value) { items.set(value); }
    public final ObservableList&lt;T&gt; getItems() { return items.get(); }
    public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() { return items; }

    private final ListChangeListener&lt;T&gt; itemsListener = c -&gt; {
        final SingleSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm!= null) {
            if (getItems() == null || getItems().isEmpty()) {
                sm.clearSelection();
            } else {
                int newIndex = getItems().indexOf(sm.getSelectedItem());
                sm.setSelectedIndex(newIndex);
            }
        }
        if (sm != null) {

            // Look for the selected item as having been removed. If it has been,
            // then we need to clear the selection in the selection model.
            final T selectedItem = sm.getSelectedItem();
            while (c.next()) {
                if (selectedItem != null &amp;&amp; c.getRemoved().contains(selectedItem)) {
                    sm.clearSelection();
                    break;
                    }
            }
        }
    };

    /**
     * Allows a way to specify how to represent objects in the items list. When
     * a StringConverter is set, the object toString method is not called and
     * instead its toString(object T) is called, passing the objects in the items list.
     * This is useful when using domain objects in a ChoiceBox as this property
     * allows for customization of the representation. Also, any of the pre-built
     * Converters available in the {@link javafx.util.converter} package can be set.
     * @return the string converter property
     * @since JavaFX 2.1
     */
    public ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() { return converter; }
    private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter =
            new SimpleObjectProperty&lt;StringConverter&lt;T&gt;&gt;(this, &quot;converter&quot;, null);
    public final void setConverter(StringConverter&lt;T&gt; value) { converterProperty().set(value); }
    public final StringConverter&lt;T&gt; getConverter() {return converterProperty().get(); }

    /**
     * The value of this ChoiceBox is defined as the selected item in the ChoiceBox
     * selection model. The valueProperty is synchronized with the selectedItem.
     * This property allows for bi-directional binding of external properties to the
     * ChoiceBox and updates the selection model accordingly.
     * @return the value property
     * @since JavaFX 2.1
     */
    public ObjectProperty&lt;T&gt; valueProperty() { return value; }
    private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;T&gt;(this, &quot;value&quot;) {
        @Override protected void invalidated() {
            super.invalidated();
            fireEvent(new ActionEvent());
            // Update selection
            final SingleSelectionModel&lt;T&gt; sm = getSelectionModel();
            if (sm != null) {
                sm.select(super.getValue());
            }
            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        }
    };
    public final void setValue(T value) { valueProperty().set(value); }
    public final T getValue() { return valueProperty().get(); }


    // --- On Action
    /**
     * The ChoiceBox action, which is invoked whenever the ChoiceBox
     * {@link #valueProperty() value} property is changed. This
     * may be due to the value property being programmatically changed or when the
     * user selects an item in a popup menu.
     *
     * @return the on action property
     * @since JavaFX 8u60
     */
    public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onActionProperty() { return onAction; }
    public final void setOnAction(EventHandler&lt;ActionEvent&gt; value) { onActionProperty().set(value); }
    public final EventHandler&lt;ActionEvent&gt; getOnAction() { return onActionProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onAction = new ObjectPropertyBase&lt;EventHandler&lt;ActionEvent&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ActionEvent.ACTION, get());
        }

        @Override
        public Object getBean() {
            return ChoiceBox.this;
        }

        @Override
        public String getName() {
            return &quot;onAction&quot;;
        }
    };


    // --- On Showing
    /**
     * Called just prior to the {@code ChoiceBox} popup being shown.
     * @return the on showing property
     * @since JavaFX 8u60
     */
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShowingProperty() { return onShowing; }
    public final void setOnShowing(EventHandler&lt;Event&gt; value) { onShowingProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnShowing() { return onShowingProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShowing = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_SHOWING, get());
        }

        @Override public Object getBean() {
            return ChoiceBox.this;
        }

        @Override public String getName() {
            return &quot;onShowing&quot;;
        }
    };


    // -- On Shown
    /**
     * Called just after the {@link ChoiceBox} popup is shown.
     * @return the on shown property
     * @since JavaFX 8u60
     */
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShownProperty() { return onShown; }
    public final void setOnShown(EventHandler&lt;Event&gt; value) { onShownProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnShown() { return onShownProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShown = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_SHOWN, get());
        }

        @Override public Object getBean() {
            return ChoiceBox.this;
        }

        @Override public String getName() {
            return &quot;onShown&quot;;
        }
    };


    // --- On Hiding
    /**
     * Called just prior to the {@link ChoiceBox} popup being hidden.
     * @return the on hiding property
     * @since JavaFX 8u60
     */
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHidingProperty() { return onHiding; }
    public final void setOnHiding(EventHandler&lt;Event&gt; value) { onHidingProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnHiding() { return onHidingProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHiding = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_HIDING, get());
        }

        @Override public Object getBean() {
            return ChoiceBox.this;
        }

        @Override public String getName() {
            return &quot;onHiding&quot;;
        }
    };


    // --- On Hidden
    /**
     * Called just after the {@link ChoiceBox} popup has been hidden.
     * @return the on hidden property
     * @since JavaFX 8u60
     */
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHiddenProperty() { return onHidden; }
    public final void setOnHidden(EventHandler&lt;Event&gt; value) { onHiddenProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnHidden() { return onHiddenProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHidden = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_HIDDEN, get());
        }

        @Override public Object getBean() {
            return ChoiceBox.this;
        }

        @Override public String getName() {
            return &quot;onHidden&quot;;
        }
    };

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Opens the list of choices.
     */
    public void show() {
        if (!isDisabled()) setShowing(true);
    }

    /**
     * Closes the list of choices.
     */
    public void hide() {
        setShowing(false);
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new ChoiceBoxSkin&lt;T&gt;(this);
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final PseudoClass SHOWING_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;showing&quot;);

    // package for testing
    static class ChoiceBoxSelectionModel&lt;T&gt; extends SingleSelectionModel&lt;T&gt; {
        private final ChoiceBox&lt;T&gt; choiceBox;

        public ChoiceBoxSelectionModel(final ChoiceBox&lt;T&gt; cb) {
            if (cb == null) {
                throw new NullPointerException(&quot;ChoiceBox can not be null&quot;);
            }
            this.choiceBox = cb;

            /*
             * The following two listeners are used in conjunction with
             * SelectionModel.select(T obj) to allow for a developer to select
             * an item that is not actually in the data model. When this occurs,
             * we actively try to find an index that matches this object, going
             * so far as to actually watch for all changes to the items list,
             * rechecking each time.
             */

            // watching for changes to the items list content
            final ListChangeListener&lt;T&gt; itemsContentObserver = c -&gt; {
                if (choiceBox.getItems() == null || choiceBox.getItems().isEmpty()) {
                    setSelectedIndex(-1);
                } else if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() != null) {
                    int newIndex = choiceBox.getItems().indexOf(getSelectedItem());
                    if (newIndex != -1) {
                        setSelectedIndex(newIndex);
                    }
                }
            };
            if (this.choiceBox.getItems() != null) {
                this.choiceBox.getItems().addListener(itemsContentObserver);
            }

            // watching for changes to the items list
            ChangeListener&lt;ObservableList&lt;T&gt;&gt; itemsObserver = (valueModel, oldList, newList) -&gt; {
                if (oldList != null) {
                    oldList.removeListener(itemsContentObserver);
                }
                if (newList != null) {
                    newList.addListener(itemsContentObserver);
                }
                setSelectedIndex(-1);
                if (getSelectedItem() != null) {
                    int newIndex = choiceBox.getItems().indexOf(getSelectedItem());
                    if (newIndex != -1) {
                        setSelectedIndex(newIndex);
<A NAME="30"></A>                    }
                }
            };
            <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#30',2,'match45-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.choiceBox.itemsProperty().addListener(itemsObserver);
        }

        // API Implementation
        @Override protected T getModelItem(int index) {
            final ObservableList&lt;T&gt; items = choiceBox.getItems();
            if</B></FONT> (items == null) return null;
            if (index &lt; 0 || index &gt;= items.size()) return null;
            return items.get(index);
        }

        @Override protected int getItemCount() {
            final ObservableList&lt;T&gt; items = choiceBox.getItems();
            return items == null ? 0 : items.size();
        }

        /**
         * Selects the given row. Since the SingleSelectionModel can only support having
         * a single row selected at a time, this also causes any previously selected
         * row to be unselected.
         * This method is overridden here so that we can move past a Separator
         * in a ChoiceBox and select the next valid menuitem.
         */
        @Override public void select(int index) {
            // this does not sound right, we should let the superclass handle it.
            super.select(index);

            if (choiceBox.isShowing()) {
                choiceBox.hide();
            }
        }

        /** {@inheritDoc} */
        @Override public void selectPrevious() {
            // overridden to properly handle Separators
            int index = getSelectedIndex() - 1;
            while (index &gt;= 0) {
                final T value = getModelItem(index);
                if (value instanceof Separator) {
                    index--;
                } else {
                    select(index);
                    break;
                }
            }
        }

        /** {@inheritDoc} */
        @Override public void selectNext() {
            // overridden to properly handle Separators
            int index = getSelectedIndex() + 1;
            while (index &lt; getItemCount()) {
                final T value = getModelItem(index);
                if (value instanceof Separator) {
                    index++;
                } else {
                    select(index);
                    break;
                }
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch(attribute) {
            case TEXT:
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                //let the skin first.
                Object title = super.queryAccessibleAttribute(attribute, parameters);
                if (title != null) return title;
                StringConverter&lt;T&gt; converter = getConverter();
                if (converter == null) {
                    return getValue() != null ? getValue().toString() : &quot;&quot;;
                }
                return converter.toString(getValue());
            case EXPANDED: return isShowing();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case COLLAPSE: hide(); break;
            case EXPAND: show(); break;
            default: super.executeAccessibleAction(action); break;
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TableView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;

import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.control.Logging;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.SelectedCellsMap;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import com.sun.javafx.scene.control.behavior.TableCellBehavior;
import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
import javafx.beans.*;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.Property;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.collections.transformation.SortedList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.util.Callback;

import com.sun.javafx.collections.MappingChange;
import com.sun.javafx.collections.NonIterableChange;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;
import javafx.scene.control.skin.TableViewSkin;

/**
 * The TableView control is designed to visualize an unlimited number of rows
 * of data, broken out into columns. A TableView is therefore very similar to the
 * {@link ListView} control, with the addition of support for columns. For an
 * example on how to create a TableView, refer to the 'Creating a TableView'
 * control section below.
 *
 * &lt;p&gt;The TableView control has a number of features, including:
 * &lt;ul&gt;
 * &lt;li&gt;Powerful {@link TableColumn} API:
 *   &lt;ul&gt;
 *   &lt;li&gt;Support for {@link TableColumn#cellFactoryProperty() cell factories} to
 *      easily customize {@link Cell cell} contents in both rendering and editing
 *      states.
 *   &lt;li&gt;Specification of {@link TableColumn#minWidthProperty() minWidth}/
 *      {@link TableColumn#prefWidthProperty() prefWidth}/
 *      {@link TableColumn#maxWidthProperty() maxWidth},
 *      and also {@link TableColumn#resizableProperty() fixed width columns}.
 *   &lt;li&gt;Width resizing by the user at runtime.
 *   &lt;li&gt;Column reordering by the user at runtime.
 *   &lt;li&gt;Built-in support for {@link TableColumn#getColumns() column nesting}
 *   &lt;/ul&gt;
 * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 *      dictate what happens when the user resizes columns.
 * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 *      the column header (hold down Shift keyboard key whilst clicking on a
 *      header to sort by multiple columns).
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note that TableView is intended to be used to visualize data - it is not
 * intended to be used for laying out your user interface. If you want to lay
 * your user interface out in a grid-like fashion, consider the
 * {@link javafx.scene.layout.GridPane} layout instead.&lt;/p&gt;
 *
 * &lt;h2&gt;Creating a TableView&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Creating a TableView is a multi-step process, and also depends on the
 * underlying data model needing to be represented. For this example we'll use
 * an {@literal ObservableList&lt;Person&gt;}, as it is the simplest way of showing data in a
 * TableView. The {@code Person} class will consist of a first
 * name and last name properties. That is:
 *
 * &lt;pre&gt;
 * {@code
 * public class Person {
 *     private StringProperty firstName;
 *     public void setFirstName(String value) { firstNameProperty().set(value); }
 *     public String getFirstName() { return firstNameProperty().get(); }
 *     public StringProperty firstNameProperty() {
 *         if (firstName == null) firstName = new SimpleStringProperty(this, &quot;firstName&quot;);
 *         return firstName;
 *     }
 *
 *     private StringProperty lastName;
 *     public void setLastName(String value) { lastNameProperty().set(value); }
 *     public String getLastName() { return lastNameProperty().get(); }
 *     public StringProperty lastNameProperty() {
 *         if (lastName == null) lastName = new SimpleStringProperty(this, &quot;lastName&quot;);
 *         return lastName;
 *     }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;Firstly, a TableView instance needs to be defined, as such:
 *
 * &lt;pre&gt;
 * {@code
 * TableView&lt;Person&gt; table = new TableView&lt;&gt;();}&lt;/pre&gt;
 *
 * &lt;p&gt;With the basic table defined, we next focus on the data model. As mentioned,
 * for this example, we'll be using an {@literal ObservableList&lt;Person&gt;}. We can immediately
 * set such a list directly in to the TableView, as such:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = getTeamMembers();
 * table.setItems(teamMembers);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the items set as such, TableView will automatically update whenever
 * the &lt;code&gt;teamMembers&lt;/code&gt; list changes. If the items list is available
 * before the TableView is instantiated, it is possible to pass it directly into
 * the constructor.
 *
 * &lt;p&gt;At this point we now have a TableView hooked up to observe the
 * &lt;code&gt;teamMembers&lt;/code&gt; observableList. The missing ingredient
 * now is the means of splitting out the data contained within the model and
 * representing it in one or more {@link TableColumn TableColumn} instances. To
 * create a two-column TableView to show the firstName and lastName properties,
 * we extend the last code sample as follows:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = ...;
 * table.setItems(teamMembers);
 *
 * TableColumn&lt;Person,String&gt; firstNameCol = new TableColumn&lt;&gt;(&quot;First Name&quot;);
 * firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
 * TableColumn&lt;Person,String&gt; lastNameCol = new TableColumn&lt;&gt;(&quot;Last Name&quot;);
 * lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;lastName&quot;));
 *
 * table.getColumns().setAll(firstNameCol, lastNameCol);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the code shown above we have fully defined the minimum properties
 * required to create a TableView instance. Running this code (assuming the
 * people ObservableList is appropriately created) will result in a TableView being
 * shown with two columns for firstName and lastName. Any other properties of the
 * Person class will not be shown, as no TableColumns are defined.
 *
 * &lt;h3&gt;TableView support for classes that don't contain properties&lt;/h3&gt;
 *
 * &lt;p&gt;The code shown above is the shortest possible code for creating a TableView
 * when the domain objects are designed with JavaFX properties in mind
 * (additionally, {@link javafx.scene.control.cell.PropertyValueFactory} supports
 * normal JavaBean properties too, although there is a caveat to this, so refer
 * to the class documentation for more information). When this is not the case,
 * it is necessary to provide a custom cell value factory. More information
 * about cell value factories can be found in the {@link TableColumn} API
 * documentation, but briefly, here is how a TableColumn could be specified:
 *
 * &lt;pre&gt;
 * {@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the Person instance for a particular TableView row
 *         return p.getValue().firstNameProperty();
 *     }
 * });
 *
 * // or with a lambda expression:
 * firstNameCol.setCellValueFactory(p -&gt; p.getValue().firstNameProperty());
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;TableView Selection / Focus APIs&lt;/h3&gt;
 * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 * {@link SelectionModel} and {@link FocusModel} classes. A TableView has at most
 * one instance of each of these classes, available from
 * {@link #selectionModelProperty() selectionModel} and
 * {@link #focusModelProperty() focusModel} properties respectively.
 * Whilst it is possible to use this API to set a new selection model, in
 * most circumstances this is not necessary - the default selection and focus
 * models should work in most circumstances.
 *
 * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TableView is
 * an implementation of the {@link MultipleSelectionModel} abstract class.
 * However, as noted in the API documentation for
 * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property, the default value is {@link SelectionMode#SINGLE}. To enable
 * multiple selection in a default TableView instance, it is therefore necessary
 * to do the following:
 *
 * &lt;pre&gt;
 * {@code
 * tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 *
 * &lt;h3&gt;Customizing TableView Visuals&lt;/h3&gt;
 * &lt;p&gt;The visuals of the TableView can be entirely customized by replacing the
 * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 * generate {@link TableRow} instances, which are used to represent an entire
 * row in the TableView.
 *
 * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 * the case that cells be customized on a per-column basis, not a per-row basis.
 * It is therefore important to note that a {@link TableRow} is not a
 * {@link TableCell}. A  {@link TableRow} is simply a container for zero or more
 * {@link TableCell}, and in most circumstances it is more likely that you'll
 * want to create custom TableCells, rather than TableRows. The primary use case
 * for creating custom TableRow instances would most probably be to introduce
 * some form of column spanning support.
 *
 * &lt;p&gt;You can create custom {@link TableCell} instances per column by assigning
 * the appropriate function to the TableColumn
 * {@link TableColumn#cellFactoryProperty() cell factory} property.
 *
 * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 * description of how to write custom Cells.
 *
 * &lt;h3&gt;Sorting&lt;/h3&gt;
 * &lt;p&gt;Prior to JavaFX 8.0, the TableView control would treat the
 * {@link #getItems() items} list as the view model, meaning that any changes to
 * the list would be immediately reflected visually. TableView would also modify
 * the order of this list directly when a user initiated a sort. This meant that
 * (again, prior to JavaFX 8.0) it was not possible to have the TableView return
 * to an unsorted state (after iterating through ascending and descending
 * orders).&lt;/p&gt;
 *
 * &lt;p&gt;Starting with JavaFX 8.0 (and the introduction of {@link SortedList}), it
 * is now possible to have the collection return to the unsorted state when
 * there are no columns as part of the TableView
 * {@link #getSortOrder() sort order}. To do this, you must create a SortedList
 * instance, and bind its
 * {@link javafx.collections.transformation.SortedList#comparatorProperty() comparator}
 * property to the TableView {@link #comparatorProperty() comparator} property,
 * list so:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code
 * // create a SortedList based on the provided ObservableList
 * SortedList sortedList = new SortedList(FXCollections.observableArrayList(2, 1, 3));
 *
 * // create a TableView with the sorted list set as the items it will show
 * final TableView&lt;Integer&gt; tableView = new TableView&lt;&gt;(sortedList);
 *
 * // bind the sortedList comparator to the TableView comparator
 * sortedList.comparatorProperty().bind(tableView.comparatorProperty());
 *
 * // Don't forget to define columns!
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 *
 * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 * than when a cell is not being edited. This is the responsibility of the
 * {@link Cell} implementation being used. For TableView, it is highly
 * recommended that editing be
 * {@link javafx.scene.control.TableColumn#cellFactoryProperty() per-TableColumn},
 * rather than {@link #rowFactoryProperty() per row}, as more often than not
 * you want users to edit each column value differently, and this approach allows
 * for editors specific to each column. It is your choice whether the cell is
 * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 * or to switch to a different UI when editing begins (e.g. when a double-click
 * is received on a cell).&lt;/p&gt;
 *
 * &lt;p&gt;To know when editing has been requested on a cell,
 * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 * appropriate (e.g. set the text to null and set the graphic to be a
 * {@link TextField}). Additionally, you should also override
 * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 * when the editing concludes. In both cases it is important that you also
 * ensure that you call the super method to have the cell perform all duties it
 * must do to enter or exit its editing mode.&lt;/p&gt;
 *
 * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 * interested in is how to commit or cancel the editing that is taking place. This is your
 * responsibility as the cell factory provider. Your cell implementation will know
 * when the editing is over, based on the user input (e.g. when the user presses
 * the Enter or ESC keys on their keyboard). When this happens, it is your
 * responsibility to call {@link Cell#commitEdit(Object)} or
 * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 *
 * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 * TableView, which you can observe by adding an {@link EventHandler} via
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 * you can also observe edit events for
 * {@link TableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 * and {@link TableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 *
 * &lt;p&gt;By default the TableColumn edit commit handler is non-null, with a default
 * handler that attempts to overwrite the property value for the
 * item in the currently-being-edited row. It is able to do this as the
 * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 * is passed along to the edit commit handler via the
 * {@link javafx.scene.control.TableColumn.CellEditEvent CellEditEvent} that is
 * fired. It is simply a matter of calling
 * {@link javafx.scene.control.TableColumn.CellEditEvent#getNewValue()} to
 * retrieve this value.
 *
 * &lt;p&gt;It is very important to note that if you call
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 * {@link EventHandler}, then you will be removing the default handler. Unless
 * you then handle the writeback to the property (or the relevant data source),
 * nothing will happen. You can work around this by using the
 * {@link TableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 * method to add a {@link TableColumn#editCommitEvent()} {@link EventType} with
 * your desired {@link EventHandler} as the second argument. Using this method,
 * you will not replace the default implementation, but you will be notified when
 * an edit commit has occurred.&lt;/p&gt;
 *
 * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 * Fortunately, JavaFX ships with a number of pre-built cell factories that
 * handle all the editing requirements on your behalf. You can find these
 * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 *
 * @see TableColumn
 * @see TablePosition
 * @param &lt;S&gt; The type of the objects contained within the TableView items list.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;items&quot;)
public class TableView&lt;S&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    // strings used to communicate via the TableView properties map between
    // the control and the skin. Because they are private here, the strings
    // are also duplicated in the TableViewSkin class - so any changes to these
    // strings must also be duplicated there
    static final String SET_CONTENT_WIDTH = &quot;TableView.contentWidth&quot;;

    /**
     * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
     * provided delta and shifts all other columns (to the right of the given column)
     * further to the right (when the delta is positive) or to the left (when the
     * delta is negative).
     *
     * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
     * or subtracting the removed space, evenly between all immediate children columns.
     * Of course, the immediate children may themselves be nested, and they would
     * then use this policy on their children.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {
        @Override public String toString() {
            return &quot;unconstrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
            return Double.compare(result, 0.0) == 0;
        }
    };

    /**
     * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
     * this table sum up to equal the width of the table itself.
     *
     * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
     * adjusts the width of the right hand side columns. When the user increases a
     * column width, the table decreases the width of the rightmost column until it
     * reaches its minimum width. Then it decreases the width of the second
     * rightmost column until it reaches minimum width and so on. When all right
     * hand side columns reach minimum size, the user cannot increase the size of
     * resized column any more.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {

        private boolean isFirstRun = true;

        @Override public String toString() {
            return &quot;constrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            TableView&lt;?&gt; table = prop.getTable();
            List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
            Boolean result = TableUtil.constrainedResize(prop,
                                               isFirstRun,
                                               table.contentWidth,
                                               visibleLeafColumns);
            isFirstRun = ! isFirstRun ? false : ! result;
            return result;
        }
    };

    /**
     * The default {@link #sortPolicyProperty() sort policy} that this TableView
     * will use if no other policy is specified. The sort policy is a simple
     * {@link Callback} that accepts a TableView as the sole argument and expects
     * a Boolean response representing whether the sort succeeded or not. A Boolean
     * response of true represents success, and a response of false (or null) will
     * be considered to represent failure.
     * @since JavaFX 8.0
     */
    public static final Callback&lt;TableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TableView, Boolean&gt;() {
        @Override public Boolean call(TableView table) {
            try {
                ObservableList&lt;?&gt; itemsList = table.getItems();
                if (itemsList instanceof SortedList) {
                    // it is the responsibility of the SortedList to bind to the
                    // comparator provided by the TableView. However, we don't
                    // want to fail the sort (which would put the UI in an
                    // inconsistent state), so we return true here, but only if
                    // the SortedList has its comparator bound to the TableView
                    // comparator property.
                    SortedList sortedList = (SortedList) itemsList;
                    boolean comparatorsBound = sortedList.comparatorProperty().
                            isEqualTo(table.comparatorProperty()).get();

                    if (! comparatorsBound) {
                        // this isn't a good situation to be in, so lets log it
                        // out in case the developer is unaware
                        if (Logging.getControlsLogger().isLoggable(Level.INFO)) {
                            String s = &quot;TableView items list is a SortedList, but the SortedList &quot; +
                                    &quot;comparator should be bound to the TableView comparator for &quot; +
                                    &quot;sorting to be enabled (e.g. &quot; +
                                    &quot;sortedList.comparatorProperty().bind(tableView.comparatorProperty());).&quot;;
                            Logging.getControlsLogger().info(s);
                        }
                    }
                    return comparatorsBound;
                } else {
                    if (itemsList == null || itemsList.isEmpty()) {
                        // sorting is not supported on null or empty lists
                        return true;
                    }

                    Comparator comparator = table.getComparator();
                    if (comparator == null) {
                        return true;
                    }

                    // otherwise we attempt to do a manual sort, and if successful
                    // we return true
                    FXCollections.sort(itemsList, comparator);
                    return true;
                }
            } catch (UnsupportedOperationException e) {
                // TODO might need to support other exception types including:
                // ClassCastException - if the class of the specified element prevents it from being added to this list
                // NullPointerException - if the specified element is null and this list does not permit null elements
                // IllegalArgumentException - if some property of this element prevents it from being added to this list

                // If we are here the list does not support sorting, so we gracefully
                // fail the sort request and ensure the UI is put back to its previous
                // state. This is handled in the code that calls the sort policy.

                return false;
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TableView control with no content.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     */
    public TableView() {
        this(FXCollections.&lt;S&gt;observableArrayList());
    }

    /**
     * Creates a TableView with the content provided in the items ObservableList.
     * This also sets up an observer such that any changes to the items list
     * will be immediately reflected in the TableView itself.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     *
     * @param items The items to insert into the TableView, and the list to watch
     *          for changes (to automatically show in the TableView).
     */
    public TableView(ObservableList&lt;S&gt; items) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TABLE_VIEW);

        // we quite happily accept items to be null here
        setItems(items);

        // install default selection and focus models
        // it's unlikely this will be changed by many users.
        setSelectionModel(new TableViewArrayListSelectionModel&lt;S&gt;(this));
        setFocusModel(new TableViewFocusModel&lt;S&gt;(this));

        // we watch the columns list, such that when it changes we can update
        // the leaf columns and visible leaf columns lists (which are read-only).
        getColumns().addListener(weakColumnsObserver);

        // watch for changes to the sort order list - and when it changes run
        // the sort method.
        getSortOrder().addListener((ListChangeListener&lt;TableColumn&lt;S, ?&gt;&gt;) c -&gt; {
            doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
        });

        // We're watching for changes to the content width such
        // that the resize policy can be run if necessary. This comes from
        // TreeViewSkin.
        getProperties().addListener(new MapChangeListener&lt;Object, Object&gt;() {
            @Override
            public void onChanged(Change&lt;? extends Object, ? extends Object&gt; c) {
                if (c.wasAdded() &amp;&amp; SET_CONTENT_WIDTH.equals(c.getKey())) {
                    if (c.getValueAdded() instanceof Number) {
                        setContentWidth((Double) c.getValueAdded());
                    }
                    getProperties().remove(SET_CONTENT_WIDTH);
                }
            }
        });

        isInited = true;
    }



    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // this is the only publicly writable list for columns. This represents the
    // columns as they are given initially by the developer.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();

    // Finally, as convenience, we also have an observable list that contains
    // only the leaf columns that are currently visible.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);


    // Allows for multiple column sorting based on the order of the TableColumns
    // in this observableArrayList. Each TableColumn is responsible for whether it is
    // sorted using ascending or descending order.
    private ObservableList&lt;TableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();

    // width of VirtualFlow minus the vbar width
    private double contentWidth;

    // Used to minimise the amount of work performed prior to the table being
    // completely initialised. In particular it reduces the amount of column
    // resize operations that occur, which slightly improves startup time.
    private boolean isInited = false;



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;() {
        @Override public void onChanged(Change&lt;? extends TableColumn&lt;S,?&gt;&gt; c) {
            final List&lt;TableColumn&lt;S,?&gt;&gt; columns = getColumns();

            // Fix for RT-39822 - don't allow the same column to be installed twice
            while (c.next()) {
                if (c.wasAdded()) {
                    List&lt;TableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
                    for (TableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
                        if (addedColumn == null) continue;

                        int count = 0;
                        for (TableColumn&lt;S,?&gt; column : columns) {
                            if (addedColumn == column) {
                                count++;
                            }
                        }

                        if (count &gt; 1) {
                            duplicates.add(addedColumn);
                        }
                    }

                    if (!duplicates.isEmpty()) {
                        String titleList = &quot;&quot;;
                        for (TableColumn&lt;S,?&gt; dupe : duplicates) {
                            titleList += &quot;'&quot; + dupe.getText() + &quot;', &quot;;
                        }
                        throw new IllegalStateException(&quot;Duplicate TableColumns detected in TableView columns list with titles &quot; + titleList);
                    }
                }
            }
            c.reset();

            // Fix for RT-15194: Need to remove removed columns from the
            // sortOrder list.
            List&lt;TableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;&gt;();
            while (c.next()) {
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();

                if (c.wasRemoved()) {
                    toRemove.addAll(removed);
                    for (TableColumn&lt;S,?&gt; tc : removed) {
                        tc.setTableView(null);
                    }
                }

                if (c.wasAdded()) {
                    toRemove.removeAll(added);
                    for (TableColumn&lt;S,?&gt; tc : added) {
                        tc.setTableView(TableView.this);
                    }
                }

                // set up listeners
                TableUtil.removeColumnsListener(removed, weakColumnsObserver);
                TableUtil.addColumnsListener(added, weakColumnsObserver);

                TableUtil.removeTableColumnListener(c.getRemoved(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
                TableUtil.addTableColumnListener(c.getAddedSubList(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
            }

            // We don't maintain a bind for leafColumns, we simply call this update
            // function behind the scenes in the appropriate places.
            updateVisibleLeafColumns();

            sortOrder.removeAll(toRemove);

            // Fix for RT-38892.
            final TableViewFocusModel&lt;S&gt; fm = getFocusModel();
            final TableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
            c.reset();

            // we need to collect together all removed and all added columns, because
            // the code below works on the actually removed columns. If we perform
            // the code within this while loop, we'll be deselecting columns that
            // should be deselected (because they have just moved place, for example).
            List&lt;TableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
            List&lt;TableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
            while (c.next()) {
                if (c.wasRemoved()) {
                    removed.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    added.addAll(c.getAddedSubList());
                }
            }
            removed.removeAll(added);

            // Fix for focus - we simply move focus to a cell to the left
            // of the focused cell if the focused cell was located within
            // a column that has been removed.
            if (fm != null) {
                TablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
                boolean match = false;
                for (TableColumn&lt;S, ?&gt; tc : removed) {
                    match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
                    if (match) {
                        break;
                    }
                }

                if (match) {
                    int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
                    int newFocusColumnIndex =
                            matchingColumnIndex == 0 ? 0 :
                            Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
                    fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
                }
            }

            // Fix for selection - we remove selection from all cells that
            // were within the removed column.
            if (sm != null) {
                List&lt;TablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
                for (TablePosition selectedCell : selectedCells) {
                    boolean match = false;
                    for (TableColumn&lt;S, ?&gt; tc : removed) {
                        match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
                        if (match) break;
                    }

                    if (match) {
                        // we can't just use the selectedCell.getTableColumn(), as that
                        // column no longer exists and therefore its index is not correct.
                        int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
                        if (matchingColumnIndex == -1) continue;

                        if (sm instanceof TableViewArrayListSelectionModel) {
                            // Also, because the table column no longer exists in the columns
                            // list at this point, we can't just call:
                            // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                            // as the tableColumn would map to an index of -1, which means that
                            // selection will not be cleared. Instead, we have to create
                            // a new TablePosition with a fixed column index and use that.
                            TablePosition&lt;S,?&gt; fixedTablePosition =
                                    new TablePosition&lt;&gt;(TableView.this,
                                            selectedCell.getRow(),
                                            selectedCell.getTableColumn());
                            fixedTablePosition.fixedColumnIndex = matchingColumnIndex;

                            ((TableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
                        } else {
                            sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                        }
                    }
                }
            }


            // update the lastKnownColumnIndex map
            lastKnownColumnIndex.clear();
            for (TableColumn&lt;S,?&gt; tc : getColumns()) {
                int index = getVisibleLeafIndex(tc);
                if (index &gt; -1) {
                    lastKnownColumnIndex.put(tc, index);
                }
            }
        }
    };

    private final WeakHashMap&lt;TableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();

    private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
        updateVisibleLeafColumns();
    };

    private final InvalidationListener columnSortableObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
    };

    private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
    };

    private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
    };

    /* proxy pseudo-class state change from selectionModel's cellSelectionEnabledProperty */
    private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
        final boolean isCellSelection = ((BooleanProperty)o).get();
        pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
        pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
    };


    private final WeakInvalidationListener weakColumnVisibleObserver =
            new WeakInvalidationListener(columnVisibleObserver);

    private final WeakInvalidationListener weakColumnSortableObserver =
            new WeakInvalidationListener(columnSortableObserver);

    private final WeakInvalidationListener weakColumnSortTypeObserver =
            new WeakInvalidationListener(columnSortTypeObserver);

    private final WeakInvalidationListener weakColumnComparatorObserver =
            new WeakInvalidationListener(columnComparatorObserver);

    private final WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
            new WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;(columnsObserver);

    private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
            new WeakInvalidationListener(cellSelectionModelInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/


    // --- Items
    /**
     * The underlying data model for the TableView. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return the items property
     */
    public final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty() { return items; }
    private ObjectProperty&lt;ObservableList&lt;S&gt;&gt; items =
        new SimpleObjectProperty&lt;ObservableList&lt;S&gt;&gt;(this, &quot;items&quot;) {
            WeakReference&lt;ObservableList&lt;S&gt;&gt; oldItemsRef;

            @Override protected void invalidated() {
                final ObservableList&lt;S&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
                final ObservableList&lt;S&gt; newItems = getItems();

                // Fix for RT-36425
                if (newItems != null &amp;&amp; newItems == oldItems) {
                    return;
                }

                // Fix for RT-35763
                if (! (newItems instanceof SortedList)) {
                    getSortOrder().clear();
                }

                oldItemsRef = new WeakReference&lt;&gt;(newItems);
            }
        };
    public final void setItems(ObservableList&lt;S&gt; value) { itemsProperty().set(value); }
    public final ObservableList&lt;S&gt; getItems() {return items.get(); }


    // --- Table menu button visible
    private BooleanProperty tableMenuButtonVisible;
    /**
     * This controls whether a menu button is available when the user clicks
     * in a designated space within the TableView, within which is a radio menu
     * item for each TableColumn in this table. This menu allows for the user to
     * show and hide all TableColumns easily.
     * @return the tableMenuButtonVisible property
     */
    public final BooleanProperty tableMenuButtonVisibleProperty() {
        if (tableMenuButtonVisible == null) {
            tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
        }
        return tableMenuButtonVisible;
    }
    public final void setTableMenuButtonVisible (boolean value) {
        tableMenuButtonVisibleProperty().set(value);
    }
    public final boolean isTableMenuButtonVisible() {
        return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
    }


    // --- Column Resize Policy
    private ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
    public final void setColumnResizePolicy(Callback&lt;ResizeFeatures, Boolean&gt; callback) {
        columnResizePolicyProperty().set(callback);
    }
    public final Callback&lt;ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
        return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
    }

    /**
     * This is the function called when the user completes a column-resize
     * operation. The two most common policies are available as static functions
     * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
     * {@link #CONSTRAINED_RESIZE_POLICY}.
     * @return columnResizePolicy property
     */
    public final ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
        if (columnResizePolicy == null) {
            columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
                private Callback&lt;ResizeFeatures, Boolean&gt; oldPolicy;

                @Override protected void invalidated() {
                    if (isInited) {
                        get().call(new ResizeFeatures(TableView.this, null, 0.0));

                        if (oldPolicy != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
                            pseudoClassStateChanged(state, false);
                        }
                        if (get() != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(get().toString());
                            pseudoClassStateChanged(state, true);
                        }
                        oldPolicy = get();
                    }
                }
            };
        }
        return columnResizePolicy;
    }


    // --- Row Factory
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactory;

    /**
     * A function which produces a TableRow. The system is responsible for
     * reusing TableRows. Return from this function a TableRow which
     * might be usable for representing a single row in a TableView.
     * &lt;p&gt;
     * Note that a TableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TableRow is
     * simply a container for a TableCell, and in most circumstances it is more
     * likely that you'll want to create custom TableCells, rather than
     * TableRows. The primary use case for creating custom TableRow
     * instances would most probably be to introduce some form of column
     * spanning support.
     * &lt;p&gt;
     * You can create custom TableCell instances per column by assigning the
     * appropriate function to the cellFactory property in the TableColumn class.
     * @return rowFactory property
     */
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
        if (rowFactory == null) {
            rowFactory = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
        }
        return rowFactory;
    }
    public final void setRowFactory(Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; value) {
        rowFactoryProperty().set(value);
    }
    public final Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; getRowFactory() {
        return rowFactory == null ? null : rowFactory.get();
    }


    // --- Placeholder Node
    private ObjectProperty&lt;Node&gt; placeholder;
    /**
     * This Node is shown to the user when the table has no content to show.
     * This may be the case because the table model has no data in the first
     * place, that a filter has been applied to the table model, resulting
     * in there being nothing to show the user, or that there are no currently
     * visible columns.
     * @return placeholder property
     */
    public final ObjectProperty&lt;Node&gt; placeholderProperty() {
        if (placeholder == null) {
            placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
        }
        return placeholder;
    }
    public final void setPlaceholder(Node value) {
        placeholderProperty().set(value);
    }
    public final Node getPlaceholder() {
        return placeholder == null ? null : placeholder.get();
    }


    // --- Selection Model
    private ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModel
            = new SimpleObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {

        TableViewSelectionModel&lt;S&gt; oldValue = null;

        @Override protected void invalidated() {

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);

                if (oldValue instanceof TableViewArrayListSelectionModel) {
                    ((TableViewArrayListSelectionModel)oldValue).dispose();
                }
            }

            oldValue = get();

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
                // fake an invalidation to ensure updated pseudo-class state
                weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
            }
        }
    };

    /**
     * The SelectionModel provides the API through which it is possible
     * to select single or multiple items within a TableView, as  well as inspect
     * which items have been selected by the user. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return selectionModel property
     */
    public final ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
        return selectionModel;
    }
    public final void setSelectionModel(TableViewSelectionModel&lt;S&gt; value) {
        selectionModelProperty().set(value);
    }

    public final TableViewSelectionModel&lt;S&gt; getSelectionModel() {
        return selectionModel.get();
    }


    // --- Focus Model
    private ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModel;
    public final void setFocusModel(TableViewFocusModel&lt;S&gt; value) {
        focusModelProperty().set(value);
    }
    public final TableViewFocusModel&lt;S&gt; getFocusModel() {
        return focusModel == null ? null : focusModel.get();
    }
    /**
     * Represents the currently-installed {@link TableViewFocusModel} for this
     * TableView. Under almost all circumstances leaving this as the default
     * focus model will suffice.
     * @return focusModel property
     */
    public final ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
        if (focusModel == null) {
            focusModel = new SimpleObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
        }
        return focusModel;
    }


//    // --- Span Model
//    private ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModel
//            = new SimpleObjectProperty&lt;SpanModel&lt;S&gt;&gt;(this, &quot;spanModel&quot;) {
//
//        @Override protected void invalidated() {
//            ObservableList&lt;String&gt; styleClass = getStyleClass();
//            if (getSpanModel() == null) {
//                styleClass.remove(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            } else if (! styleClass.contains(CELL_SPAN_TABLE_VIEW_STYLE_CLASS)) {
//                styleClass.add(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            }
//        }
//    };
//
//    public final ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModelProperty() {
//        return spanModel;
//    }
//    public final void setSpanModel(SpanModel&lt;S&gt; value) {
//        spanModelProperty().set(value);
//    }
//
//    public final SpanModel&lt;S&gt; getSpanModel() {
//        return spanModel.get();
//    }

    // --- Editable
    private BooleanProperty editable;
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }
    public final boolean isEditable() {
        return editable == null ? false : editable.get();
    }
    /**
     * Specifies whether this TableView is editable - only if the TableView, the
     * TableColumn (if applicable) and the TableCells within it are both
     * editable will a TableCell be able to go into their editing state.
     * @return the editable property
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
        }
        return editable;
    }


    // --- Fixed cell size
    private DoubleProperty fixedCellSize;

    /**
     * Sets the new fixed cell size for this control. Any value greater than
     * zero will enable fixed cell size mode, whereas a zero or negative value
     * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
     * mode.
     *
     * @param value The new fixed cell size value, or a value less than or equal
     *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
     * @since JavaFX 8.0
     */
    public final void setFixedCellSize(double value) {
        fixedCellSizeProperty().set(value);
    }

    /**
     * Returns the fixed cell size value. A value less than or equal to zero is
     * used to represent that fixed cell size mode is disabled, and a value
     * greater than zero represents the size of all cells in this control.
     *
     * @return A double representing the fixed cell size of this control, or a
     *      value less than or equal to zero if fixed cell size mode is disabled.
     * @since JavaFX 8.0
     */
    public final double getFixedCellSize() {
        return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
    }
    /**
     * Specifies whether this control has cells that are a fixed height (of the
     * specified value). If this value is less than or equal to zero,
     * then all cells are individually sized and positioned. This is a slow
     * operation. Therefore, when performance matters and developers are not
     * dependent on variable cell sizes it is a good idea to set the fixed cell
     * size value. Generally cells are around 24px, so setting a fixed cell size
     * of 24 is likely to result in very little difference in visuals, but a
     * improvement to performance.
     *
     * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
     * This should not be confused with the -fx-cell-size property. The difference
     * between these two CSS properties is that -fx-cell-size will size all
     * cells to the specified size, but it will not enforce that this is the
     * only size (thus allowing for variable cell sizes, and preventing the
     * performance gains from being possible). Therefore, when performance matters
     * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
     * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
     *
     * @return fixedCellSize property
     * @since JavaFX 8.0
     */
    public final DoubleProperty fixedCellSizeProperty() {
        if (fixedCellSize == null) {
            fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
                @Override public CssMetaData&lt;TableView&lt;?&gt;,Number&gt; getCssMetaData() {
                    return StyleableProperties.FIXED_CELL_SIZE;
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;fixedCellSize&quot;;
                }
            };
        }
        return fixedCellSize;
    }


    // --- Editing Cell
    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCell;
    private void setEditingCell(TablePosition&lt;S,?&gt; value) {
        editingCellPropertyImpl().set(value);
    }
    public final TablePosition&lt;S,?&gt; getEditingCell() {
        return editingCell == null ? null : editingCell.get();
    }

    /**
     * Represents the current cell being edited, or null if
     * there is no cell being edited.
     * @return the editingCell property
     */
    public final ReadOnlyObjectProperty&lt;TablePosition&lt;S,?&gt;&gt; editingCellProperty() {
        return editingCellPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
        if (editingCell == null) {
            editingCell = new ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
        }
        return editingCell;
    }


    // --- Comparator (built via sortOrder list, so read-only)
    /**
     * The comparator property is a read-only property that is representative of the
     * current state of the {@link #getSortOrder() sort order} list. The sort
     * order list contains the columns that have been added to it either programmatically
     * or via a user clicking on the headers themselves.
     * @since JavaFX 8.0
     */
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparator;
    private void setComparator(Comparator&lt;S&gt; value) {
        comparatorPropertyImpl().set(value);
    }
    public final Comparator&lt;S&gt; getComparator() {
        return comparator == null ? null : comparator.get();
    }
    public final ReadOnlyObjectProperty&lt;Comparator&lt;S&gt;&gt; comparatorProperty() {
        return comparatorPropertyImpl().getReadOnlyProperty();
    }
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparatorPropertyImpl() {
        if (comparator == null) {
            comparator = new ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt;(this, &quot;comparator&quot;);
        }
        return comparator;
    }


    // --- sortPolicy
    /**
     * The sort policy specifies how sorting in this TableView should be performed.
     * For example, a basic sort policy may just call
     * {@code FXCollections.sort(tableView.getItems())}, whereas a more advanced
     * sort policy may call to a database to perform the necessary sorting on the
     * server-side.
     *
     * &lt;p&gt;TableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
     * sort policy} that does precisely as mentioned above: it simply attempts
     * to sort the items list in-place.
     *
     * &lt;p&gt;It is recommended that rather than override the {@link TableView#sort() sort}
     * method that a different sort policy be provided instead.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
    public final void setSortPolicy(Callback&lt;TableView&lt;S&gt;, Boolean&gt; callback) {
        sortPolicyProperty().set(callback);
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Callback&lt;TableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
        return sortPolicy == null ?
                (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
                sortPolicy.get();
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
        if (sortPolicy == null) {
            sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt;(
                    this, &quot;sortPolicy&quot;, (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
                @Override protected void invalidated() {
                    sort();
                }
            };
        }
        return sortPolicy;
    }


    // onSort
    /**
     * Called when there's a request to sort the control.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSort;

    public void setOnSort(EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; value) {
        onSortProperty().set(value);
    }

    public EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; getOnSort() {
        if( onSort != null ) {
            return onSort.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
        if( onSort == null ) {
            onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
                    EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventHandler = get();
                    setEventHandler(eventType, eventHandler);
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onSort&quot;;
                }
            };
        }
        return onSort;
    }


    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/
    /**
     * The TableColumns that are part of this TableView. As the user reorders
     * the TableView columns, this list will be updated to reflect the current
     * visual ordering.
     *
     * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
     * TableColumn in this ObservableList.&lt;/p&gt;
     * @return the columns
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getColumns() {
        return columns;
    }

    /**
     * The sortOrder list defines the order in which {@link TableColumn} instances
     * are sorted. An empty sortOrder list means that no sorting is being applied
     * on the TableView. If the sortOrder list has one TableColumn within it,
     * the TableView will be sorted using the
     * {@link TableColumn#sortTypeProperty() sortType} and
     * {@link TableColumn#comparatorProperty() comparator} properties of this
     * TableColumn (assuming
     * {@link TableColumn#sortableProperty() TableColumn.sortable} is true).
     * If the sortOrder list contains multiple TableColumn instances, then
     * the TableView is firstly sorted based on the properties of the first
     * TableColumn. If two elements are considered equal, then the second
     * TableColumn in the list is used to determine ordering. This repeats until
     * the results from all TableColumn comparators are considered, if necessary.
     *
     * @return An ObservableList containing zero or more TableColumn instances.
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getSortOrder() {
        return sortOrder;
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param index The index of an item that should be visible to the user.
     */
    public void scrollTo(int index) {
       ControlUtils.scrollToIndex(this, index);
    }

    /**
     * Scrolls the TableView so that the given object is visible within the viewport.
     * @param object The object that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollTo(S object) {
        if( getItems() != null ) {
            int idx = getItems().indexOf(object);
            if( idx &gt;= 0 ) {
                ControlUtils.scrollToIndex(this, idx);
            }
        }
    }

    /**
     * Called when there's a request to scroll an index into view using {@link #scrollTo(int)}
     * or {@link #scrollTo(Object)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;

    public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
        onScrollToProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
        if( onScrollTo != null ) {
            return onScrollTo.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
        if( onScrollTo == null ) {
            onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
                @Override
                protected void invalidated() {
                    setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
                }
                @Override
                public Object getBean() {
                    return TableView.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollTo&quot;;
                }
            };
        }
        return onScrollTo;
    }

    /**
     * Scrolls the TableView so that the given column is visible within the viewport.
     * @param column The column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumn(TableColumn&lt;S, ?&gt; column) {
        ControlUtils.scrollToColumn(this, column);
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param columnIndex The index of a column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumnIndex(int columnIndex) {
        if( getColumns() != null ) {
            ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
        }
    }

    /**
     * Called when there's a request to scroll a column into view using {@link #scrollToColumn(TableColumn)}
     * or {@link #scrollToColumnIndex(int)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;

    public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; value) {
        onScrollToColumnProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
        if( onScrollToColumn != null ) {
            return onScrollToColumn.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
        if( onScrollToColumn == null ) {
            onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
                    setEventHandler(type, get());
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onScrollToColumn&quot;;
                }
            };
        }
        return onScrollToColumn;
    }

    /**
     * Applies the currently installed resize policy against the given column,
     * resizing it based on the delta value provided.
     * @param column the column
     * @param delta the delta
     * @return true if column resize is allowed
     */
    public boolean resizeColumn(TableColumn&lt;S,?&gt; column, double delta) {
        if (column == null || Double.compare(delta, 0.0) == 0) return false;

        boolean allowed = getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, column, delta));
        if (!allowed) return false;

        return true;
    }

    /**
     * Causes the cell at the given row/column view indexes to switch into
     * its editing state, if it is not already in it, and assuming that the
     * TableView and column are also editable.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method will cancel editing if the given row
     * value is less than zero and the given column is null.&lt;/p&gt;
     * @param row the row
     * @param column the column
     */
    public void edit(int row, TableColumn&lt;S,?&gt; column) {
        if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
            return;
        }

        if (row &lt; 0 &amp;&amp; column == null) {
            setEditingCell(null);
        } else {
            setEditingCell(new TablePosition&lt;&gt;(this, row, column));
        }
    }

    /**
     * Returns an unmodifiable list containing the currently visible leaf columns.
     * @return an unmodifiable list containing the currently visible leaf columns
     */
    public ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
        return unmodifiableVisibleLeafColumns;
    }

    /**
     * Returns the position of the given column, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the position of the given column, relative to all other
     * visible leaf columns
     */
    public int getVisibleLeafIndex(TableColumn&lt;S,?&gt; column) {
        return visibleLeafColumns.indexOf(column);
    }

    /**
     * Returns the TableColumn in the given column index, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the TableColumn in the given column index, relative to all other
     * visible leaf columns
     */
    public TableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
        if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
        return visibleLeafColumns.get(column);
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TableViewSkin&lt;S&gt;(this);
    }

    /**
     * The sort method forces the TableView to re-run its sorting algorithm. More
     * often than not it is not necessary to call this method directly, as it is
     * automatically called when the {@link #getSortOrder() sort order},
     * {@link #sortPolicyProperty() sort policy}, or the state of the
     * TableColumn {@link TableColumn#sortTypeProperty() sort type} properties
     * change. In other words, this method should only be called directly when
     * something external changes and a sort is required.
     * @since JavaFX 8.0
     */
    public void sort() {
        final ObservableList&lt;? extends TableColumnBase&lt;S,?&gt;&gt; sortOrder = getSortOrder();

        // update the Comparator property
        final Comparator&lt;S&gt; oldComparator = getComparator();
        setComparator(sortOrder.isEmpty() ? null : new TableColumnComparator(sortOrder));

        // fire the onSort event and check if it is consumed, if
        // so, don't run the sort
        SortEvent&lt;TableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TableView.this, TableView.this);
        fireEvent(sortEvent);
        if (sortEvent.isConsumed()) {
            // if the sort is consumed we could back out the last action (the code
            // is commented out right below), but we don't as we take it as a
            // sign that the developer has decided to handle the event themselves.

            // sortLock = true;
            // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            // sortLock = false;
            return;
        }

        final List&lt;TablePosition&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
        final int itemCount = prevState.size();

        // we set makeAtomic to true here, so that we don't fire intermediate
        // sort events - instead we send a single permutation event at the end
        // of this method.
        getSelectionModel().startAtomic();

        // get the sort policy and run it
        Callback&lt;TableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
        if (sortPolicy == null) return;
        Boolean success = sortPolicy.call(this);

        getSelectionModel().stopAtomic();

        if (success == null || ! success) {
            // the sort was a failure. Need to backout if possible
            sortLock = true;
            TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            setComparator(oldComparator);
            sortLock = false;
        } else {
            // sorting was a success, now we possibly fire an event on the
            // selection model that the items list has 'permutated' to a new ordering

            // FIXME we should support alternative selection model implementations!
            if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {
                final TableViewArrayListSelectionModel&lt;S&gt; sm = (TableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
                final ObservableList&lt;TablePosition&lt;S,?&gt;&gt; newState = (ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)sm.getSelectedCells();

                List&lt;TablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; itemCount; i++) {
                    TablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
                    if (!newState.contains(prevItem)) {
                        removed.add(prevItem);
                    }
                }

                if (!removed.isEmpty()) {
                    // the sort operation effectively permutates the selectedCells list,
                    // but we cannot fire a permutation event as we are talking about
                    // TablePosition's changing (which may reside in the same list
                    // position before and after the sort). Therefore, we need to fire
                    // a single add/remove event to cover the added and removed positions.
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
                    sm.fireCustomSelectedCellsListChangeEvent(c);
                }
            }
        }
    }

    /**
     * Calling {@code refresh()} forces the TableView control to recreate and
     * repopulate the cells necessary to populate the visual bounds of the control.
     * In other words, this forces the TableView to update what it is showing to
     * the user. This is useful in cases where the underlying data source has
     * changed in a way that is not observed by the TableView itself.
     *
     * @since JavaFX 8u60
     */
    public void refresh() {
        getProperties().put(Properties.RECREATE, Boolean.TRUE);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean sortLock = false;
    private TableUtil.SortEventType lastSortEventType = null;
    private Object[] lastSortEventSupportInfo = null;

    private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
        if (sortLock) {
            return;
        }

        this.lastSortEventType = sortEventType;
        this.lastSortEventSupportInfo = supportInfo;
        sort();
        this.lastSortEventType = null;
        this.lastSortEventSupportInfo = null;
    }


    // --- Content width
    private void setContentWidth(double contentWidth) {
        this.contentWidth = contentWidth;
        if (isInited) {
            // sometimes the current column resize policy will have to modify the
            // column width of all columns in the table if the table width changes,
            // so we short-circuit the resize function and just go straight there
            // with a null TableColumn, which indicates to the resize policy function
            // that it shouldn't actually do anything specific to one column.
            getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
        }
    }

    /**
     * Recomputes the currently visible leaf columns in this TableView.
     */
    private void updateVisibleLeafColumns() {
        // update visible leaf columns list
        List&lt;TableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TableColumn&lt;S,?&gt;&gt;();
        buildVisibleLeafColumns(getColumns(), cols);
        visibleLeafColumns.setAll(cols);

        // sometimes the current column resize policy will have to modify the
        // column width of all columns in the table if the table width changes,
        // so we short-circuit the resize function and just go straight there
        // with a null TableColumn, which indicates to the resize policy function
        // that it shouldn't actually do anything specific to one column.
        getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
    }

    private void buildVisibleLeafColumns(List&lt;TableColumn&lt;S,?&gt;&gt; cols, List&lt;TableColumn&lt;S,?&gt;&gt; vlc) {
        for (TableColumn&lt;S,?&gt; c : cols) {
            if (c == null) continue;

            boolean hasChildren = ! c.getColumns().isEmpty();

            if (hasChildren) {
                buildVisibleLeafColumns(c.getColumns(), vlc);
            } else if (c.isVisible()) {
                vlc.add(c);
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;table-view&quot;;

    private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
            PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
    private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
            PseudoClass.getPseudoClass(&quot;row-selection&quot;);

    private static class StyleableProperties {
        private static final CssMetaData&lt;TableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
                new CssMetaData&lt;TableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
                                                    SizeConverter.getInstance(),
                                                    Region.USE_COMPUTED_SIZE) {

                    @Override public Double getInitialValue(TableView&lt;?&gt; node) {
                        return node.getFixedCellSize();
                    }

                    @Override public boolean isSettable(TableView&lt;?&gt; n) {
                        return n.fixedCellSize == null || !n.fixedCellSize.isBound();
                    }

                    @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TableView&lt;?&gt; n) {
                        return (StyleableProperty&lt;Number&gt;) n.fixedCellSizeProperty();
                    }
                };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FIXED_CELL_SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case COLUMN_COUNT: return getVisibleLeafColumns().size();
            case ROW_COUNT: return getItems().size();
            case SELECTED_ITEMS: {
                // TableViewSkin returns TableRows back to TableView.
                // TableRowSkin returns TableCells back to TableRow.
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;TableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                for (TableRow&lt;S&gt; row : rows) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
                    if (cells != null) selection.addAll(cells);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: {
                Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
                if (row == null) return null;
                Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
                /* cell equals to null means the row is a placeholder node */
                return cell != null ?  cell : row;
            }
            case CELL_AT_ROW_COLUMN: {
                @SuppressWarnings(&quot;unchecked&quot;)
                TableRow&lt;S&gt; row = (TableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
                return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
            }
            case MULTIPLE_SELECTION: {
                MultipleSelectionModel&lt;S&gt; sm = getSelectionModel();
                return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Support Interfaces                                                      *
     *                                                                         *
     **************************************************************************/

     /**
      * An immutable wrapper class for use in the TableView
     * {@link TableView#columnResizePolicyProperty() column resize} functionality.
      * @since JavaFX 2.0
      */
     public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;S&gt; {
        private TableView&lt;S&gt; table;

        /**
         * Creates an instance of this class, with the provided TableView,
         * TableColumn and delta values being set and stored in this immutable
         * instance.
         *
         * @param table The TableView upon which the resize operation is occurring.
         * @param column The column upon which the resize is occurring, or null
         *      if this ResizeFeatures instance is being created as a result of a
         *      TableView resize operation.
         * @param delta The amount of horizontal space added or removed in the
         *      resize operation.
         */
        public ResizeFeatures(TableView&lt;S&gt; table, TableColumn&lt;S,?&gt; column, Double delta) {
            super(column, delta);
            this.table = table;
        }

        /**
         * Returns the column upon which the resize is occurring, or null
         * if this ResizeFeatures instance was created as a result of a
         * TableView resize operation.
         */
        @Override public TableColumn&lt;S,?&gt; getColumn() {
            return (TableColumn&lt;S,?&gt;) super.getColumn();
        }

        /**
         * Returns the TableView upon which the resize operation is occurring.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTable() {
            return table;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/


    /**
     * A simple extension of the {@link SelectionModel} abstract class to
     * allow for special support for TableView controls.
     * @since JavaFX 2.0
     */
    public static abstract class TableViewSelectionModel&lt;S&gt; extends TableSelectionModel&lt;S&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/

        private final TableView&lt;S&gt; tableView;

        boolean blockFocusCall = false;



        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Builds a default TableViewSelectionModel instance with the provided
         * TableView.
         * @param tableView The TableView upon which this selection model should
         *      operate.
         * @throws NullPointerException TableView can not be null.
         */
        public TableViewSelectionModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
        }



        /***********************************************************************
         *                                                                     *
         * Abstract API                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * A read-only ObservableList representing the currently selected cells
         * in this TableView. Rather than directly modify this list, please
         * use the other methods provided in the TableViewSelectionModel.
         * @return a read-only ObservableList representing the currently
         * selected cells in this TableView
         */
        public abstract ObservableList&lt;TablePosition&gt; getSelectedCells();


        /***********************************************************************
         *                                                                     *
         * Generic (type erasure) bridging                                     *
         *                                                                     *
         **********************************************************************/

        // --- isSelected
        /** {@inheritDoc} */
        @Override public boolean isSelected(int row, TableColumnBase&lt;S, ?&gt; column) {
            return isSelected(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Convenience function which tests whether the given row and column index
         * is currently selected in this table instance.
         * @param row the row
         * @param column the column
         * @return true if row and column index is currently selected
         */
        public abstract boolean isSelected(int row, TableColumn&lt;S, ?&gt; column);


        // --- select
        /** {@inheritDoc} */
        @Override public void select(int row, TableColumnBase&lt;S, ?&gt; column) {
            select(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Selects the cell at the given row/column intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void select(int row, TableColumn&lt;S, ?&gt; column);


        // --- clearAndSelect
        /** {@inheritDoc} */
        @Override public void clearAndSelect(int row, TableColumnBase&lt;S,?&gt; column) {
            clearAndSelect(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Clears all selection, and then selects the cell at the given row/column
         * intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void clearAndSelect(int row, TableColumn&lt;S,?&gt; column);


        // --- clearSelection
        /** {@inheritDoc} */
        @Override public void clearSelection(int row, TableColumnBase&lt;S,?&gt; column) {
            clearSelection(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Removes selection from the specified row/column position (in view indexes).
         * If this particular cell (or row if the column value is -1) is not selected,
         * nothing happens.
         * @param row the row
         * @param column the column
         */
        public abstract void clearSelection(int row, TableColumn&lt;S, ?&gt; column);

        /** {@inheritDoc} */
        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            for (int _row = minRow; _row &lt;= maxRow; _row++) {
                for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
                    select(_row, tableView.getVisibleLeafColumn(_col));
                }
            }
        }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Returns the TableView instance that this selection model is installed in.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTableView() {
            return tableView;
        }

        /**
         * Convenience method that returns getTableView().getItems().
         * @return The items list of the current TableView.
         */
        protected List&lt;S&gt; getTableModel()  {
            return tableView.getItems();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) return null;
            return tableView.getItems().get(index);
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return getTableModel().size();
        }

        /** {@inheritDoc} */
        @Override public void focus(int row) {
            focus(row, null);
        }

        /** {@inheritDoc} */
        @Override public int getFocusedIndex() {
            return getFocusedCell().getRow();
        }



        /***********************************************************************
         *                                                                     *
         * Private implementation                                              *
         *                                                                     *
         **********************************************************************/

        void focus(int row, TableColumn&lt;S,?&gt; column) {
            focus(new TablePosition&lt;&gt;(getTableView(), row, column));
            getTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        void focus(TablePosition&lt;S,?&gt; pos) {
            if (blockFocusCall) return;
            if (getTableView().getFocusModel() == null) return;

            getTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
        }

        TablePosition&lt;S,?&gt; getFocusedCell() {
            if (getTableView().getFocusModel() == null) {
                return new TablePosition&lt;&gt;(getTableView(), -1, null);
            }
            return getTableView().getFocusModel().getFocusedCell();
        }
    }



    /**
     * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
     * selected indices.
     */
    // package for testing
    static class TableViewArrayListSelectionModel&lt;S&gt; extends TableViewSelectionModel&lt;S&gt; {

        private int itemCount = 0;

        private final MappingChange.Map&lt;TablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        public TableViewArrayListSelectionModel(final TableView&lt;S&gt; tableView) {
            super(tableView);
            this.tableView = tableView;

            this.itemsPropertyListener = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());

                    ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(itemsPropertyListener);

            selectedCellsMap = new SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
                @Override public boolean isCellSelectionEnabled() {
                    return TableViewArrayListSelectionModel.this.isCellSelectionEnabled();
                }
            };

            selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt;() {
                @Override public TablePosition&lt;S,?&gt; get(int i) {
                    return selectedCellsMap.get(i);
                }

                @Override public int size() {
                    return selectedCellsMap.size();
                }
            };
//            selectedCellsSeq.addListener((ListChangeListener&lt;? super TablePosition&lt;S,?&gt;&gt;) c -&gt; {
//                ControlUtils.updateSelectedIndices(this, c);
//            });


            /*
             * The following listener is used in conjunction with
             * SelectionModel.select(T obj) to allow for a developer to select
             * an item that is not actually in the data model. When this occurs,
             * we actively try to find an index that matches this object, going
             * so far as to actually watch for all changes to the items list,
             * rechecking each time.
             */

            // watching for changes to the items list content
            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(items);
                items.addListener(weakItemsContentListener);
            }


            updateItemCount();

            updateDefaultSelection();

            cellSelectionEnabledProperty().addListener(o -&gt; {
                updateDefaultSelection();
                TableCellBehaviorBase.setAnchor(tableView, getFocusedCell(), true);
            });
        }

        private void dispose() {
            this.tableView.itemsProperty().removeListener(itemsPropertyListener);

            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                items.removeListener(weakItemsContentListener);
            }
        }

        private final TableView&lt;S&gt; tableView;

        final InvalidationListener itemsPropertyListener;

        final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            updateItemCount();

            List&lt;S&gt; items1 = getTableModel();
            boolean doSelectionUpdate = true;

            while (c.next()) {
                if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                    this.selectedItemChange = c;
                    updateDefaultSelection();
                    this.selectedItemChange = null;
                    return;
                }

                final S selectedItem = getSelectedItem();
                final int selectedIndex = getSelectedIndex();

                if (items1 == null || items1.isEmpty()) {
                    clearSelection();
                } else if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() != null) {
                    int newIndex = items1.indexOf(getSelectedItem());
                    if (newIndex != -1) {
                        setSelectedIndex(newIndex);
                        doSelectionUpdate = false;
                    }
                } else if (c.wasRemoved() &amp;&amp;
                        c.getRemovedSize() == 1 &amp;&amp;
                        ! c.wasAdded() &amp;&amp;
                        selectedItem != null &amp;&amp;
                        selectedItem.equals(c.getRemoved().get(0))) {
                    // Bug fix for RT-28637
                    if (getSelectedIndex() &lt; getItemCount()) {
                        final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
                        S newSelectedItem = getModelItem(previousRow);
                        if (! selectedItem.equals(newSelectedItem)) {
                            clearAndSelect(previousRow);
                        }
                    }
                }
            }

            if (doSelectionUpdate) {
                updateSelection(c);
            }
        };

        final WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);



        /***********************************************************************
         *                                                                     *
         * Observable properties (and getters/setters)                         *
         *                                                                     *
         **********************************************************************/

        // the only 'proper' internal data structure, selectedItems and selectedIndices
        // are both 'read-only and unbacked'.
        private final SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsMap;

        // we create a ReadOnlyUnbackedObservableList of selectedCells here so
        // that we can fire custom list change events.
        private final ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
        @Override public ObservableList&lt;TablePosition&gt; getSelectedCells() {
            return (ObservableList&lt;TablePosition&gt;)(Object)selectedCellsSeq;
        }



        /***********************************************************************
         *                                                                     *
         * Internal properties                                                 *
         *                                                                     *
         **********************************************************************/

        private int previousModelSize = 0;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the selected indices list to refer to the
        // new indices.
        private void updateSelection(ListChangeListener.Change&lt;? extends S&gt; c) {
            c.reset();

            int shift = 0;
            int startRow = -1;
            while (c.next()) {
                if (c.wasReplaced()) {
                    if (c.getList().isEmpty()) {
                        // the entire items list was emptied - clear selection
                        clearSelection();
                    } else {
                        int index = getSelectedIndex();

                        if (previousModelSize == c.getRemovedSize()) {
                            // all items were removed from the model
                            clearSelection();
                        } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
                            // Fix for RT-18969: the list had setAll called on it
                            // Use of makeAtomic is a fix for RT-20945
                            startAtomic();
                            clearSelection(index);
                            stopAtomic();
                            select(index);
                        } else {
                            // Fix for RT-22079
                            clearSelection();
                        }
                    }
                } else if (c.wasAdded() || c.wasRemoved()) {
                    startRow = c.getFrom();
                    shift += c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
                } else if (c.wasPermutated()) {
                    // General approach:
                    //   -- detected a sort has happened
                    //   -- Create a permutation lookup map (1)
                    //   -- dump all the selected indices into a list (2)
                    //   -- create a list containing the new indices (3)
                    //   -- for each previously-selected index (4)
                    //     -- if index is in the permutation lookup map
                    //       -- add the new index to the new indices list
                    //   -- Perform batch selection (5)

                    startAtomic();

                    final int oldSelectedIndex = getSelectedIndex();

                    // (1)
                    int length = c.getTo() - c.getFrom();
                    HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);
                    for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                        pMap.put(i, c.getPermutation(i));
                    }

                    // (2)
                    List&lt;TablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;((ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)getSelectedCells());

                    // (3)
                    List&lt;TablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());

                    // (4)
                    boolean selectionIndicesChanged = false;
                    for (int i = 0; i &lt; selectedIndices.size(); i++) {
                        final TablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);
                        final int oldRow = oldIndex.getRow();

                        if (pMap.containsKey(oldRow)) {
                            int newIndex = pMap.get(oldRow);

                            selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;

                            newIndices.add(new TablePosition&lt;&gt;(oldIndex.getTableView(), newIndex, oldIndex.getTableColumn()));
                        }
                    }

                    if (selectionIndicesChanged) {
                        // (5)
                        quietClearSelection();
                        stopAtomic();

                        selectedCellsMap.setAll(newIndices);

                        if (oldSelectedIndex &gt;= 0 &amp;&amp; oldSelectedIndex &lt; itemCount) {
                            int newIndex = c.getPermutation(oldSelectedIndex);
                            setSelectedIndex(newIndex);
                            focus(newIndex);
                        }
                    } else {
                        stopAtomic();
                    }
                }
            }

            TablePosition&lt;S,?&gt; anchor = TableCellBehavior.getAnchor(tableView, null);
            if (shift != 0 &amp;&amp; startRow &gt;= 0 &amp;&amp; anchor != null &amp;&amp; (c.wasRemoved() || c.wasAdded())) {
                if (isSelected(anchor.getRow(), anchor.getTableColumn())) {
                    TablePosition&lt;S,?&gt; newAnchor = new TablePosition&lt;&gt;(tableView, anchor.getRow() + shift, anchor.getTableColumn());
                    TableCellBehavior.setAnchor(tableView, newAnchor, false);
                }
            }

            shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
                @Override public Void call(ShiftParams param) {

                    // we make the shifts atomic, as otherwise listeners to
                    // the items / indices lists get a lot of intermediate
                    // noise. They eventually get the summary event fired
                    // from within shiftSelection, so this is ok.
                    startAtomic();

                    final int clearIndex = param.getClearIndex();
                    final int setIndex = param.getSetIndex();
                    TablePosition&lt;S,?&gt; oldTP = null;
                    if (clearIndex &gt; -1) {
                        for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
                            TablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
                            if (tp.getRow() == clearIndex) {
                                oldTP = tp;
                                selectedCellsMap.remove(tp);
                            } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
                                selectedCellsMap.remove(tp);
                            }
                        }
                    }

                    if (oldTP != null &amp;&amp; param.isSelected()) {
                        TablePosition&lt;S,?&gt; newTP = new TablePosition&lt;&gt;(
                                tableView, param.getSetIndex(), oldTP.getTableColumn());

                        selectedCellsMap.add(newTP);
                    }

                    stopAtomic();

                    return null;
                }
            });

            previousModelSize = getItemCount();
        }

        /***********************************************************************
         *                                                                     *
         * Public selection API                                                *
         *                                                                     *
         **********************************************************************/

        @Override public void clearAndSelect(int row) {
            clearAndSelect(row, null);
        }

        @Override public void clearAndSelect(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            final TablePosition&lt;S,?&gt; newTablePosition = new TablePosition&lt;&gt;(getTableView(), row, column);
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            // replace the anchor
            TableCellBehavior.setAnchor(tableView, newTablePosition, false);

            // firstly we make a copy of the selection, so that we can send out
            // the correct details in the selection change event.
            List&lt;TablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());

            // secondly we check if we can short-circuit out of here because the new selection
            // equals the current selection
            final boolean wasSelected = isSelected(row, column);
            if (wasSelected &amp;&amp; previousSelection.size() == 1) {
                // before we return, we double-check that the selected item
                // is equal to the item in the given index
                TablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
                if (getSelectedItem() == getModelItem(row)) {
                    if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
                        return;
                    }
                }
            }

            // RT-32411 We used to call quietClearSelection() here, but this
            // resulted in the selectedItems and selectedIndices lists never
            // reporting that they were empty.
            // makeAtomic toggle added to resolve RT-32618
            startAtomic();

            // then clear the current selection
            clearSelection();

            // and select the new cell
            select(row, column);

            stopAtomic();


            // We remove the new selection from the list seeing as it is not removed.
            if (isCellSelectionEnabled) {
                previousSelection.remove(newTablePosition);
            } else {
                for (TablePosition&lt;S,?&gt; tp : previousSelection) {
                    if (tp.getRow() == row) {
                        previousSelection.remove(tp);
                        break;
                    }
                }
            }

            // fire off a single add/remove/replace notification (rather than
            // individual remove and add notifications) - see RT-33324
            ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; change;

            /*
             * getFrom() documentation:
             *   If wasAdded is true, the interval contains all the values that were added.
             *   If wasPermutated is true, the interval marks the values that were permutated.
             *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
             *   return the same number - the place where the removed elements were positioned in the list.
             */
            if (wasSelected) {
                change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
            } else {
                final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
                final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
                change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                        changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
//                selectedCellsSeq._beginChange();
//                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
//                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
//                selectedCellsSeq._endChange();
            }
            fireCustomSelectedCellsListChangeEvent(change);
        }

        @Override public void select(int row) {
            select(row, null);
        }

        @Override
        public void select(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            // if I'm in cell selection mode but the column is null, select each
            // of the contained cells individually
            if (isCellSelectionEnabled() &amp;&amp; column == null) {
                List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                for (int i = 0; i &lt; columns.size(); i++) {
                    select(row, columns.get(i));
                }
                return;
            }

            if (TableCellBehavior.hasDefaultAnchor(tableView)) {
                TableCellBehavior.removeAnchor(tableView);
            }

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }
            selectedCellsMap.add(new TablePosition&lt;&gt;(getTableView(), row, column));

            updateSelectedIndex(row);
            focus(row, column);
        }

        @Override public void select(S obj) {
            if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
                clearSelection();
                return;
            }

            // We have no option but to iterate through the model and select the
            // first occurrence of the given object. Once we find the first one, we
            // don't proceed to select any others.
            S rowObj = null;
            for (int i = 0; i &lt; getItemCount(); i++) {
                rowObj = getModelItem(i);
                if (rowObj == null) continue;

                if (rowObj.equals(obj)) {
                    if (isSelected(i)) {
                        return;
                    }

                    if (getSelectionMode() == SelectionMode.SINGLE) {
                        quietClearSelection();
                    }

                    select(i);
                    return;
                }
            }

            // if we are here, we did not find the item in the entire data model.
            // Even still, we allow for this item to be set to the give object.
            // We expect that in concrete subclasses of this class we observe the
            // data model such that we check to see if the given item exists in it,
            // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
            setSelectedIndex(-1);
            setSelectedItem(obj);
        }

        @Override public void selectIndices(int row, int... rows) {
            if (rows == null) {
                select(row);
                return;
            }

            /*
             * Performance optimisation - if multiple selection is disabled, only
             * process the end-most row index.
             */
            int rowCount = getItemCount();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();

                for (int i = rows.length - 1; i &gt;= 0; i--) {
                    int index = rows[i];
                    if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                        select(index);
                        break;
                    }
                }

                if (selectedCellsMap.isEmpty()) {
                    if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                        select(row);
                    }
                }
            } else {
                int lastIndex = -1;
                Set&lt;TablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();

                // --- firstly, we special-case the non-varargs 'row' argument
                if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
                    // if I'm in cell selection mode, we want to select each
                    // of the contained cells individually
                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(row, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), row, columns.get(column)));
                                lastIndex = row;
                            }
                        }
                    } else {
                        boolean match = selectedCellsMap.isSelected(row, -1);
                        if (!match) {
                            positions.add(new TablePosition&lt;&gt;(getTableView(), row, null));
                        }
                    }

                    lastIndex = row;
                }

                // --- now we iterate through all varargs values
                for (int i = 0; i &lt; rows.length; i++) {
                    int index = rows[i];
                    if (index &lt; 0 || index &gt;= rowCount) continue;
                    lastIndex = index;

                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(index, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), index, columns.get(column)));
                                lastIndex = index;
                            }
                        }
                    } else {
                        if (! selectedCellsMap.isSelected(index, -1)) {
                            // if we are here then we have successfully gotten through the for-loop above
                            positions.add(new TablePosition&lt;&gt;(getTableView(), index, null));
                        }
                    }
                }

                selectedCellsMap.addAll(positions);

                if (lastIndex != -1) {
                    select(lastIndex);
                }
            }
        }

        @Override public void selectAll() {
            if (getSelectionMode() == SelectionMode.SINGLE) return;

            if (isCellSelectionEnabled()) {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                TableColumn&lt;S,?&gt; column;
                TablePosition&lt;S,?&gt; tp = null;
                for (int col = 0; col &lt; getTableView().getVisibleLeafColumns().size(); col++) {
                    column = getTableView().getVisibleLeafColumns().get(col);
                    for (int row = 0; row &lt; getItemCount(); row++) {
                        tp = new TablePosition&lt;&gt;(getTableView(), row, column);
                        indices.add(tp);
                    }
                }
                selectedCellsMap.setAll(indices);

                if (tp != null) {
                    select(tp.getRow(), tp.getTableColumn());
                    focus(tp.getRow(), tp.getTableColumn());
                }
            } else {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; getItemCount(); i++) {
                    indices.add(new TablePosition&lt;&gt;(getTableView(), i, null));
                }
                selectedCellsMap.setAll(indices);

                int focusedIndex = getFocusedIndex();
                if (focusedIndex == -1) {
                    final int itemCount = getItemCount();
                    if (itemCount &gt; 0) {
                        select(itemCount - 1);
                        focus(indices.get(indices.size() - 1));
                    }
                } else {
                    select(focusedIndex);
                    focus(focusedIndex);
                }
            }
        }

        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
                select(maxRow, maxColumn);
                return;
            }

            startAtomic();

            final int itemCount = getItemCount();
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
            final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);

            final int _minRow = Math.min(minRow, maxRow);
            final int _maxRow = Math.max(minRow, maxRow);

            List&lt;TablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();

            for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
                // begin copy/paste of select(int, column) method (with some
                // slight modifications)
                if (_row &lt; 0 || _row &gt;= itemCount) continue;

                if (! isCellSelectionEnabled) {
                    cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, (TableColumn&lt;S,?&gt;)minColumn));
                } else {
                    for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
                        final TableColumn&lt;S, ?&gt; column = tableView.getVisibleLeafColumn(_col);

                        // if I'm in cell selection mode but the column is null, I don't want
                        // to select the whole row instead...
                        if (column == null &amp;&amp; isCellSelectionEnabled) continue;

                        cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, column));
                        // end copy/paste
                    }
                }
            }

            // to prevent duplication we remove all currently selected cells from
            // our list of cells to select.
            cellsToSelect.removeAll(getSelectedCells());

            selectedCellsMap.addAll(cellsToSelect);
            stopAtomic();

            // fire off events.
            // Note that focus and selection always goes to maxRow, not _maxRow.
            updateSelectedIndex(maxRow);
            focus(maxRow, (TableColumn&lt;S,?&gt;)maxColumn);

            final TableColumn&lt;S,?&gt; startColumn = (TableColumn&lt;S,?&gt;)minColumn;
            final TableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TableColumn&lt;S,?&gt;)maxColumn : startColumn;
            final int startChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, minRow, startColumn));
            final int endChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, maxRow, endColumn));

            if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
                final int startIndex = Math.min(startChangeIndex, endChangeIndex);
                final int endIndex = Math.max(startChangeIndex, endChangeIndex);

                ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
                fireCustomSelectedCellsListChangeEvent(c);
//                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
            }
        }

        @Override public void clearSelection(int index) {
            clearSelection(index, null);
        }

        @Override
        public void clearSelection(int row, TableColumn&lt;S,?&gt; column) {
            clearSelection(new TablePosition&lt;&gt;(getTableView(), row, column));
        }

        private void clearSelection(TablePosition&lt;S,?&gt; tp) {
            final boolean csMode = isCellSelectionEnabled();
            final int row = tp.getRow();
            final boolean columnIsNull = tp.getTableColumn() == null;

            List&lt;TablePosition&gt; toRemove = new ArrayList&lt;&gt;();
            for (TablePosition pos : getSelectedCells()) {
                if (!csMode) {
                    if (pos.getRow() == row) {
                        toRemove.add(pos);
                        break;
                    }
                } else {
                    if (columnIsNull &amp;&amp; pos.getRow() == row) {
                        // if we are in cell selection mode and the column is null,
                        // we remove all items in the row
                        toRemove.add(pos);
                    } else if (pos.equals(tp)) {
                        toRemove.add(tp);
                        break;
                    }
                }
            }
            toRemove.stream().forEach(selectedCellsMap::remove);

            if (isEmpty() &amp;&amp; ! isAtomic()) {
                updateSelectedIndex(-1);
                selectedCellsMap.clear();
            }
        }

        @Override public void clearSelection() {
            final List&lt;TablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());

<A NAME="20"></A>            quietClearSelection();

            if (! isAtomic()) {
                <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#20',2,'match45-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>updateSelectedIndex(-1);
                focus(-1);

                if (!removed.isEmpty()) {
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
                        @Override public List&lt;TablePosition&lt;S, ?&gt;&gt; getRemoved() {</B></FONT>
                            return removed;
                        }
                    };
                    fireCustomSelectedCellsListChangeEvent(c);
//                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
                }
            }
        }

        private void quietClearSelection() {
            startAtomic();
            selectedCellsMap.clear();
            stopAtomic();
        }

        @Override public boolean isSelected(int index) {
            return isSelected(index, null);
        }

        @Override
        public boolean isSelected(int row, TableColumn&lt;S,?&gt; column) {
            // When in cell selection mode, if the column is null, then we interpret
            // the users query to be asking if _all_ of the cells in the row are selected,
            // rather than if _any_ of the cells in the row are selected.
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();
            if (isCellSelectionEnabled &amp;&amp; column == null) {
                int columnCount = tableView.getVisibleLeafColumns().size();
                for (int col = 0; col &lt; columnCount; col++) {
                    if (!selectedCellsMap.isSelected(row, col)) {
                        return false;
                    }
                }
                return true;
            } else {
                int columnIndex = !isCellSelectionEnabled || column == null ? -1 : tableView.getVisibleLeafIndex(column);
                return selectedCellsMap.isSelected(row, columnIndex);
            }
        }

        @Override public boolean isEmpty() {
            return selectedCellsMap.isEmpty();
        }

        @Override public void selectPrevious() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // right-to-left, and then wrapping to the end of the previous line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() - 1 &gt;= 0) {
                    // go to previous row
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to end of previous row
                    select(pos.getRow() - 1, getTableColumn(getTableView().getVisibleLeafColumns().size() - 1));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(getItemCount() - 1);
                } else if (focusIndex &gt; 0) {
                    select(focusIndex - 1);
                }
            }
        }

        @Override public void selectNext() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // left-to-right, and then wrapping to the start of the next line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                    // go to next column
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to start of next row
                    select(pos.getRow() + 1, getTableColumn(0));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(0);
                } else if (focusIndex &lt; getItemCount() -1) {
                    select(focusIndex + 1);
                }
            }
        }

        @Override public void selectAboveCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getRow() == -1) {
                select(getItemCount() - 1);
            } else if (pos.getRow() &gt; 0) {
                select(pos.getRow() - 1, pos.getTableColumn());
            }
        }

        @Override public void selectBelowCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();

            if (pos.getRow() == -1) {
                select(0);
            } else if (pos.getRow() &lt; getItemCount() -1) {
                select(pos.getRow() + 1, pos.getTableColumn());
            }
        }

        @Override public void selectFirst() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            if (getItemCount() &gt; 0) {
                if (isCellSelectionEnabled()) {
                    select(0, focusedCell.getTableColumn());
                } else {
                    select(0);
                }
            }
        }

        @Override public void selectLast() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            int numItems = getItemCount();
            if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
                if (isCellSelectionEnabled()) {
                    select(numItems - 1, focusedCell.getTableColumn());
                } else {
                    select(numItems - 1);
                }
            }
        }

        @Override
        public void selectLeftCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() - 1 &gt;= 0) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
            }
        }

        @Override
        public void selectRightCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
            }
        }



        /***********************************************************************
         *                                                                     *
         * Support code                                                        *
         *                                                                     *
         **********************************************************************/

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) {
                oldList.removeListener(weakItemsContentListener);
            }
            if (newList != null) {
                newList.addListener(weakItemsContentListener);
            }

            updateItemCount();
            updateDefaultSelection();
        }

        private void updateDefaultSelection() {
            // when the items list totally changes, we should clear out
            // the selection
            int newSelectionIndex = -1;
            if (tableView.getItems() != null) {
                S selectedItem = getSelectedItem();
                if (selectedItem != null) {
                    newSelectionIndex = tableView.getItems().indexOf(selectedItem);
                }
            }

            clearSelection();
            select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
        }

        private TableColumn&lt;S,?&gt; getTableColumn(int pos) {
            return getTableView().getVisibleLeafColumn(pos);
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = getTableView().getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return getTableView().getVisibleLeafColumn(newColumnIndex);
        }

        private void updateSelectedIndex(int row) {
            setSelectedIndex(row);
            setSelectedItem(getModelItem(row));
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return itemCount;
        }

        private void updateItemCount() {
            if (tableView == null) {
                itemCount = -1;
            } else {
                List&lt;S&gt; items = getTableModel();
                itemCount = items == null ? -1 : items.size();
            }
        }

        private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TablePosition&lt;S,?&gt;&gt; c) {
            ControlUtils.updateSelectedIndices(this, c);

            if (isAtomic()) {
                return;
            }

            selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
        }
    }




    /**
     * A {@link FocusModel} with additional functionality to support the requirements
     * of a TableView control.
     *
     * @see TableView
     * @since JavaFX 2.0
     */
    public static class TableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;S, TableColumn&lt;S, ?&gt;&gt; {

        private final TableView&lt;S&gt; tableView;

        private final TablePosition&lt;S,?&gt; EMPTY_CELL;

        /**
         * Creates a default TableViewFocusModel instance that will be used to
         * manage focus of the provided TableView control.
         *
         * @param tableView The tableView upon which this focus model operates.
         * @throws NullPointerException The TableView argument can not be null.
         */
        public TableViewFocusModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
            this.EMPTY_CELL = new TablePosition&lt;&gt;(tableView, -1, null);

            itemsObserver = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
            if (tableView.getItems() != null) {
                this.tableView.getItems().addListener(weakItemsContentListener);
            }

            updateDefaultFocus();

            focusedCellProperty().addListener(o -&gt; {
                tableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
            });
        }

        private final InvalidationListener itemsObserver;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the focused index to refer to the new indices.
        private final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            c.next();

            if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                updateDefaultFocus();
                return;
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            final int focusedIndex = focusedCell.getRow();
            if (focusedIndex == -1 || c.getFrom() &gt; focusedIndex) {
                return;
            }

            c.reset();
            boolean added = false;
            boolean removed = false;
            int addedSize = 0;
            int removedSize = 0;
            while (c.next()) {
                added |= c.wasAdded();
                removed |= c.wasRemoved();
                addedSize += c.getAddedSize();
                removedSize += c.getRemovedSize();
            }

            if (added &amp;&amp; ! removed) {
                if (addedSize &lt; c.getList().size()) {
                    final int newFocusIndex = Math.min(getItemCount() - 1, getFocusedIndex() + addedSize);
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            } else if (!added &amp;&amp; removed) {
                final int newFocusIndex = Math.max(0, getFocusedIndex() - removedSize);
                if (newFocusIndex &lt; 0) {
                    focus(0, focusedCell.getTableColumn());
                } else {
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            }
        };

        private WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the tableview items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) oldList.removeListener(weakItemsContentListener);
            if (newList != null) newList.addListener(weakItemsContentListener);

            updateDefaultFocus();
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            if (tableView.getItems() == null) return -1;
            return tableView.getItems().size();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (tableView.getItems() == null) return null;

            if (index &lt; 0 || index &gt;= getItemCount()) return null;

            return tableView.getItems().get(index);
        }

        /**
         * The position of the current item in the TableView which has the focus.
         */
        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCell;
        public final ReadOnlyObjectProperty&lt;TablePosition&gt; focusedCellProperty() {
            return focusedCellPropertyImpl().getReadOnlyProperty();
        }
        private void setFocusedCell(TablePosition value) { focusedCellPropertyImpl().set(value);  }
        public final TablePosition getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }

        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCellPropertyImpl() {
            if (focusedCell == null) {
                focusedCell = new ReadOnlyObjectWrapper&lt;TablePosition&gt;(EMPTY_CELL) {
                    private TablePosition old;
                    @Override protected void invalidated() {
                        if (get() == null) return;

                        if (old == null || !old.equals(get())) {
                            setFocusedIndex(get().getRow());
                            setFocusedItem(getModelItem(getValue().getRow()));

                            old = get();
                        }
                    }

                    @Override
                    public Object getBean() {
                        return TableViewFocusModel.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;focusedCell&quot;;
                    }
                };
            }
            return focusedCell;
        }


        /**
         * Causes the item at the given index to receive the focus.
         *
         * @param row The row index of the item to give focus to.
         * @param column The column of the item to give focus to. Can be null.
         */
        @Override public void focus(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                TablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
                TablePosition&lt;S,?&gt; newFocusCell = new TablePosition&lt;&gt;(tableView, row, column);
                setFocusedCell(newFocusCell);

                if (newFocusCell.equals(oldFocusCell)) {
                    // manually update the focus properties to ensure consistency
                    setFocusedIndex(row);
                    setFocusedItem(getModelItem(row));
                }
            }
        }

        /**
         * Convenience method for setting focus on a particular row or cell
         * using a {@link TablePosition}.
         *
         * @param pos The table position where focus should be set.
         */
        public void focus(TablePosition pos) {
            if (pos == null) return;
            focus(pos.getRow(), pos.getTableColumn());
        }


        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Tests whether the row / cell at the given location currently has the
         * focus within the TableView.
         */
        @Override public boolean isFocused(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return false;

            TablePosition cell = getFocusedCell();
            boolean columnMatch = column == null || column.equals(cell.getTableColumn());

            return cell.getRow() == row &amp;&amp; columnMatch;
        }

        /**
         * Causes the item at the given index to receive the focus. This does not
         * cause the current selection to change. Updates the focusedItem and
         * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
         * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
         *
         * @param index The index of the item to get focus.
         */
        @Override public void focus(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                setFocusedCell(new TablePosition&lt;&gt;(tableView, index, null));
            }
        }

        /**
         * Attempts to move focus to the cell above the currently focused cell.
         */
        @Override public void focusAboveCell() {
            TablePosition cell = getFocusedCell();

            if (getFocusedIndex() == -1) {
                focus(getItemCount() - 1, cell.getTableColumn());
            } else if (getFocusedIndex() &gt; 0) {
                focus(getFocusedIndex() - 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell below the currently focused cell.
         */
        @Override public void focusBelowCell() {
            TablePosition cell = getFocusedCell();
            if (getFocusedIndex() == -1) {
                focus(0, cell.getTableColumn());
            } else if (getFocusedIndex() != getItemCount() -1) {
                focus(getFocusedIndex() + 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell to the left of the currently focused cell.
         */
        @Override public void focusLeftCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() &lt;= 0) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
        }

        /**
         * Attempts to move focus to the cell to the right of the the currently focused cell.
         */
        @Override public void focusRightCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() == getColumnCount() - 1) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
        }

        /** {@inheritDoc} */
        @Override public void focusPrevious() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() &gt; 0) {
                focusAboveCell();
            }
        }

        /** {@inheritDoc} */
        @Override public void focusNext() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() != getItemCount() -1) {
                focusBelowCell();
            }
        }

        /***********************************************************************
         *                                                                     *
         * Private Implementation                                              *
         *                                                                     *
         **********************************************************************/

        private void updateDefaultFocus() {
            // when the items list totally changes, we should clear out
            // the focus
            int newValueIndex = -1;
            if (tableView.getItems() != null) {
                S focusedItem = getFocusedItem();
                if (focusedItem != null) {
                    newValueIndex = tableView.getItems().indexOf(focusedItem);
                }

                // we put focus onto the first item, if there is at least
                // one item in the list
                if (newValueIndex == -1) {
                    newValueIndex = tableView.getItems().size() &gt; 0 ? 0 : -1;
                }
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            TableColumn&lt;S,?&gt; focusColumn = focusedCell != null &amp;&amp; !EMPTY_CELL.equals(focusedCell) ?
               focusedCell.getTableColumn() : tableView.getVisibleLeafColumn(0);

            focus(newValueIndex, focusColumn);
        }

        private int getColumnCount() {
            return tableView.getVisibleLeafColumns().size();
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = tableView.getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return tableView.getVisibleLeafColumn(newColumnIndex);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextInputControl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.text.Font;

import java.text.BreakIterator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.util.Utils;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.scene.NodeHelper;
import javafx.util.StringConverter;

/**
 * Abstract base class for text input controls.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public abstract class TextInputControl extends Control {
    /**
     * Interface representing a text input's content. Since it is an ObservableStringValue,
     * you can also bind to, or observe the content.
     * @since JavaFX 2.0
     */
    protected interface Content extends ObservableStringValue {
        /**
         * Retrieves a subset of the content.
         *
         * @param start the start
         * @param end the end
         * @return a subset of the content
         */
        public String get(int start, int end);

        /**
         * Inserts a sequence of characters into the content.
         *
         * @param index the index
         * @param text the text string
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void insert(int index, String text, boolean notifyListeners);

        /**
         * Removes a sequence of characters from the content.
         *
         * @param start the start
         * @param end the end
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void delete(int start, int end, boolean notifyListeners);

        /**
         * Returns the number of characters represented by the content.
         * @return the number of characters
         */
        public int length();
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TextInputControl. The content is an immutable property and
     * must be specified (as non-null) at the time of construction.
     *
     * @param content a non-null implementation of Content.
     */
    protected TextInputControl(final Content content) {
        this.content = content;

        // Add a listener so that whenever the Content is changed, we notify
        // listeners of the text property that it is invalid.
        content.addListener(observable -&gt; {
            if (content.length() &gt; 0) {
                text.textIsNull = false;
            }
            text.controlContentHasChanged();
        });

        // Bind the length to be based on the length of the text property
        length.bind(new IntegerBinding() {
            { bind(text); }
            @Override protected int computeValue() {
                String txt = text.get();
                return txt == null ? 0 : txt.length();
            }
        });

        // Bind the selected text to be based on the selection and text properties
        selectedText.bind(new StringBinding() {
            { bind(selection, text); }
            @Override protected String computeValue() {
                String txt = text.get();
                IndexRange sel = selection.get();
                if (txt == null || sel == null) return &quot;&quot;;

                int start = sel.getStart();
                int end = sel.getEnd();
                int length = txt.length();
                if (end &gt; start + length) end = length;
                if (start &gt; length-1) start = end = 0;
                return txt.substring(start, end);
            }
        });

        focusedProperty().addListener((ob, o, n) -&gt; {
            if (n) {
                if (getTextFormatter() != null) {
                    updateText(getTextFormatter());
                }
            } else {
                commitValue();
            }
        });

        // Specify the default style class
        getStyleClass().add(&quot;text-input&quot;);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The default font to use for text in the TextInputControl. If the TextInputControl's text is
     * rich text then this font may or may not be used depending on the font
     * information embedded in the rich text, but in any case where a default
     * font is required, this font will be used.
     * @return the font property
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Font&gt; fontProperty() {
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {


                private boolean fontSetByCss = false;

                @Override
                public void applyStyle(StyleOrigin newOrigin, Font value) {

                    //
                    // RT-20727 - if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS
                    //
                    try {
                        // super.applyStyle calls set which might throw if value is bound.
                        // Have to make sure fontSetByCss is reset.
                        fontSetByCss = true;
                        super.applyStyle(newOrigin, value);
                    } catch(Exception e) {
                        throw e;
                    } finally {
                        fontSetByCss = false;
                    }

                }


                @Override
                public void set(Font value) {
                    final Font oldValue = get();
                    if (value == null ? oldValue == null : value.equals(oldValue)) {
                        return;
                    }
                    super.set(value);
                }

                @Override
                protected void invalidated() {
                    // RT-20727 - if font is changed by calling setFont, then
                    // css might need to be reapplied since font size affects
                    // calculated values for styles with relative values
                    if(fontSetByCss == false) {
                        NodeHelper.reapplyCSS(TextInputControl.this);
                    }
                }

                @Override
                public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }

                @Override
                public Object getBean() {
                    return TextInputControl.this;
                }

                @Override
                public String getName() {
                    return &quot;font&quot;;
                }
            };
        }
        return font;
    }

    private ObjectProperty&lt;Font&gt; font;
    public final void setFont(Font value) { fontProperty().setValue(value); }
    public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }

    /**
     * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
     * prompt text is displayed.
     *
     * @defaultValue An empty String
     * @since JavaFX 2.2
     */
    private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
        @Override protected void invalidated() {
            // Strip out newlines
            String txt = get();
            if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
                txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
                set(txt);
            }
        }
    };
    public final StringProperty promptTextProperty() { return promptText; }
    public final String getPromptText() { return promptText.get(); }
    public final void setPromptText(String value) { promptText.set(value); }


    /**
     * The property contains currently attached {@link TextFormatter}.
     * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
     *
     * @defaultValue null
     * @since JavaFX 8u40
     */
    private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {

        private TextFormatter&lt;?&gt; oldFormatter = null;

        @Override
        public Object getBean() {
            return TextInputControl.this;
        }

        @Override
        public String getName() {
            return &quot;textFormatter&quot;;
        }

        @Override
        protected void invalidated() {
            final TextFormatter&lt;?&gt; formatter = get();
            try {
                if (formatter != null) {
                    try {
                        formatter.bindToControl(f -&gt; updateText(f));
                    } catch (IllegalStateException e) {
                        if (isBound()) {
                            unbind();
                        }
                        set(null);
                        throw e;
                    }
                    if (!isFocused()) {
                        updateText(get());
                    }
                }

                if (oldFormatter != null) {
                    oldFormatter.unbindFromControl();
                }
            } finally {
                oldFormatter = formatter;
            }
        }
    };
    public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
    public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
    public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }

    private final Content content;
    /**
     * Returns the text input's content model.
     * @return the text input's content model
     */
    protected final Content getContent() {
        return content;
    }

    /**
     * The textual content of this TextInputControl.
     */
    private TextProperty text = new TextProperty();
    public final String getText() { return text.get(); }
    public final void setText(String value) { text.set(value); }
    public final StringProperty textProperty() { return text; }

    /**
     * The number of characters in the text input.
     */
    private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
    public final int getLength() { return length.get(); }
    public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }

    /**
     * Indicates whether this TextInputControl can be edited by the user.
     */
    private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
        }
    };
    public final boolean isEditable() { return editable.getValue(); }
    public final void setEditable(boolean value) { editable.setValue(value); }
    public final BooleanProperty editableProperty() { return editable; }

    /**
     * The current selection.
     */
    private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
    public final IndexRange getSelection() { return selection.getValue(); }
    public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }

    /**
     * Defines the characters in the TextInputControl which are selected
     */
    private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
    public final String getSelectedText() { return selectedText.get(); }
    public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }

    /**
     * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the anchor might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
    public final int getAnchor() { return anchor.get(); }
    public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }

    /**
     * The current position of the caret within the text.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the caretPosition might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
    public final int getCaretPosition() { return caretPosition.get(); }
    public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }

    private UndoRedoChange undoChangeHead = new UndoRedoChange();
    private UndoRedoChange undoChange = undoChangeHead;
    private boolean createNewUndoRecord = false;

    /**
     * The property describes if it's currently possible to undo the latest change of the content that was done.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
    public final boolean isUndoable() { return undoable.get(); }
    public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }


    /**
     * The property describes if it's currently possible to redo the latest change of the content that was undone.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
    public final boolean isRedoable() { return redoable.get(); }
    public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a subset of the text input's content.
     *
     * @param start must be a value between 0 and end - 1.
     * @param end must be less than or equal to the length
     * @return the subset of the text input's content
     */
    public String getText(int start, int end) {
        if (start &gt; end) {
            throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        return getContent().get(start, end);
    }

    /**
     * Appends a sequence of characters to the content.
     *
     * @param text a non null String
     */
    public void appendText(String text) {
        insertText(getLength(), text);
    }

    /**
     * Inserts a sequence of characters into the content.
     *
     * @param index The location to insert the text.
     * @param text The text to insert.
     */
    public void insertText(int index, String text) {
        replaceText(index, index, text);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param range The range of text to delete. The range object must not be null.
     *
     * @see #deleteText(int, int)
     */
    public void deleteText(IndexRange range) {
        replaceText(range, &quot;&quot;);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     */
    public void deleteText(int start, int end) {
        replaceText(start, end, &quot;&quot;);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param range The range of text to replace. The range object must not be null.
     * @param text The text that is to replace the range. This must not be null.
     *
     * @see #replaceText(int, int, String)
     */
    public void replaceText(IndexRange range, String text) {
        final int start = range.getStart();
        final int end = start + range.getLength();
        replaceText(start, end, text);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param text The text that is to replace the range. This must not be null.
     */
    public void replaceText(final int start, final int end, final String text) {
        if (start &gt; end) {
            throw new IllegalArgumentException();
        }

        if (text == null) {
            throw new NullPointerException();
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        if (!this.text.isBound()) {
            final int oldLength = getLength();
            TextFormatter&lt;?&gt; formatter = getTextFormatter();
            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
            if (formatter != null &amp;&amp; formatter.getFilter() != null) {
                change = formatter.getFilter().apply(change);
                if (change == null) {
                    return;
                }
            }

            // Update the content
            updateContent(change, oldLength == 0);

        }
    }

    private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
        final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
        String oldText = getText(change.start, change.end);
        int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
        if (newText.equals(oldText)) {
            // Undo record not required as there is no change in the text.
            return;
        }

        /*
         * A new undo record is created, if
         * 1. createNewUndoRecord is true, currently it is set to true for paste operation
         * 2. Text is selected and a character is typed
         * 3. This is the first operation to be added to undo record
         * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
         * 5. Space character is typed
         * 6. 2500 milliseconds are elapsed since the undo record was created
         * 7. Cursor position is changed and a character is typed
         * 8. A range of text is replaced programmatically using replaceText()
         * Otherwise, the last undo record is updated or discarded.
         */

        int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
        boolean isNewSpaceChar = false;
        if (newText.equals(&quot; &quot;)) {
            if (!UndoRedoChange.isSpaceCharSequence()) {
                isNewSpaceChar = true;
                UndoRedoChange.setSpaceCharSequence(true);
            }
        } else {
            UndoRedoChange.setSpaceCharSequence(false);
        }
        if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
                isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
                (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
            undoChange = undoChange.add(change.start, oldText, newText);
        } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
            // I know I am deleting, and am located at the end of the range of the current undo record
            if (undoChange.newText.length() &gt; 0) {
                undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
                if (undoChange.newText.isEmpty()) {
                    // throw away this undo change record
                    undoChange = undoChange.discard();
                }
            } else {
                if (change.start == endOfUndoChange) {
                    undoChange.oldText += oldText;
                } else { // end == endOfUndoChange
                    undoChange.oldText = oldText + undoChange.oldText;
                    undoChange.start--;
                }
            }
        } else {
            // I know I am adding, and am located at the end of the range of the current undo record
            undoChange.newText += newText;
        }
        updateUndoRedoState();
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * removing the current selection.
     */
    public void cut() {
        copy();
        IndexRange selection = getSelection();
        deleteText(selection.getStart(), selection.getEnd());
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * leaving the current selection.
     */
     public void copy() {
        final String selectedText = getSelectedText();
        if (selectedText.length() &gt; 0) {
            final ClipboardContent content = new ClipboardContent();
            content.putString(selectedText);
            Clipboard.getSystemClipboard().setContent(content);
        }
    }

    /**
     * Transfers the contents in the clipboard into this text,
     * replacing the current selection.  If there is no selection, the contents
     * in the clipboard is inserted at the current caret position.
     */
    public void paste() {
        final Clipboard clipboard = Clipboard.getSystemClipboard();
        if (clipboard.hasString()) {
            final String text = clipboard.getString();
            if (text != null) {
                createNewUndoRecord = true;
                try {
                    replaceSelection(text);
                } finally {
                    createNewUndoRecord = false;
                }
            }
        }
    }

    /**
     * Moves the selection backward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caretPosition.
     */
    public void selectBackward() {
        if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
            // because the anchor stays put, by moving the caret to the left
            // we ensure that a selection is registered and that it is correct
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
        }
    }

    /**
     * Moves the selection forward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caret forward.
     */
    public void selectForward() {
        final int textLength = getLength();
        if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.following(getCaretPosition()));
        }
    }

    /**
     * The break iterator instances for navigation over words and complex characters.
     */
    private BreakIterator charIterator;
    private BreakIterator wordIterator;

    /**
     * Moves the caret to the beginning of previous word. This function
     * also has the effect of clearing the selection.
     */
    public void previousWord() {
        previousWord(false);
    }

    /**
     * Moves the caret to the beginning of next word. This function
     * also has the effect of clearing the selection.
     */
    public void nextWord() {
        nextWord(false);
    }

    /**
     * Moves the caret to the end of the next word. This function
<A NAME="8"></A>     * also has the effect of clearing the selection.
     */
    public void endOfNextWord() {
        <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#8',2,'match45-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>endOfNextWord(false);
    }

    /**
     * Moves the caret to the beginning of previous word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of previous word.
     */
    public void selectPreviousWord() {
        previousWord(true);
    }

    /**
     * Moves the caret to the beginning of next word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of next word.
     */
    public void selectNextWord() {
        nextWord(true);
    }

    /**
     * Moves the caret to the end of the next word. This does not cause
     * the selection to be cleared.
     */
    public void selectEndOfNextWord() {
        endOfNextWord(true);
    }

    private void previousWord(boolean select) {
        final int textLength = getLength()</B></FONT>;
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));

        // Skip the non-word region, then move/select to the beginning of the word.
        while (pos != BreakIterator.DONE &amp;&amp;
               !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
            pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
        }

        // move/select
        selectRange(select ? getAnchor() : pos, pos);
    }

    private void nextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
        int current = wordIterator.next();

        // Skip whitespace characters to the beginning of next word, but
        // stop at newline. Then move the caret or select a range.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                char ch = text.charAt(Utils.clamp(0, p, textLength-1));
                // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
                // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
                if (ch != ' ' &amp;&amp; ch != '\t') {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    private void endOfNextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
        int current = wordIterator.next();

        // skip the non-word region, then move/select to the end of the word.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    /**
     * Selects all text in the text input.
     */
    public void selectAll() {
        selectRange(0, getLength());
    }

    /**
     * Moves the caret to before the first char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void home() {
        // user wants to go to start
        selectRange(0, 0);
    }

    /**
     * Moves the caret to after the last char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void end() {
        // user wants to go to end
        final int textLength = getLength();
        if (textLength &gt; 0) {
            selectRange(textLength, textLength);
        }
    }

    /**
     * Moves the caret to before the first char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to before the first char.
     */
    public void selectHome() {
        selectRange(getAnchor(), 0);
    }

    /**
     * Moves the caret to after the last char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to after the last char.
     */
    public void selectEnd() {
        final int textLength = getLength();
        if (textLength &gt; 0) selectRange(getAnchor(), textLength);
    }

    /**
     * Deletes the character that precedes the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deletePreviousChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (dot &gt; 0) {
                // The caret is not at the beginning, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                // Note: Do not use charIterator here, because we do want to
                // break up clusters when deleting backwards.
                int p = Character.offsetByCodePoints(text, dot, -1);
                deleteText(p, dot);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Deletes the character that follows the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deleteNextChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final int textLength = getLength();
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
                // The caret is not at the end, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                if (charIterator == null) {
                    charIterator = BreakIterator.getCharacterInstance();
                }
                charIterator.setText(text);
                int p = charIterator.following(dot);
                deleteText(dot, p);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Moves the caret position forward. If there is no selection, then the
     * caret position is moved one character forward. If there is a selection,
     * then the caret position is moved to the end of the selection and
     * the selection cleared.
     */
    public void forward() {
        // user has moved caret to the right
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.max(dot, mark);
            selectRange(pos, pos);
        } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.following(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Moves the caret position backward. If there is no selection, then the
     * caret position is moved one character backward. If there is a selection,
     * then the caret position is moved to the beginning of the selection and
     * the selection cleared.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void backward() {
        // user has moved caret to the left
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.min(dot, mark);
            selectRange(pos, pos);
        } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.preceding(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Positions the caret to the position indicated by {@code pos}. This
     * function will also clear the selection.
     * @param pos the position
     */
    public void positionCaret(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        selectRange(p, p);
    }

    /**
     * Positions the caret to the position indicated by {@code pos} and extends
     * the selection, if there is one. If there is no selection, then a
     * selection is formed where the anchor is at the current caret position
     * and the caretPosition is moved to pos.
     * @param pos the position
     */
    public void selectPositionCaret(int pos) {
        selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
    }

    /**
     * Positions the anchor and caretPosition explicitly.
     * @param anchor the anchor
     * @param caretPosition the caretPosition
     */
    public void selectRange(int anchor, int caretPosition) {
        caretPosition = Utils.clamp(0, caretPosition, getLength());
        anchor = Utils.clamp(0, anchor, getLength());

        TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        if (formatter != null &amp;&amp; formatter.getFilter() != null) {
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return;
            }
        }

        updateContent(change, false);
    }

    private void doSelectRange(int anchor, int caretPosition) {
        this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
        this.anchor.set(Utils.clamp(0, anchor, getLength()));
        this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
        notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
    }

    /**
     * This function will extend the selection to include the specified pos.
     * This is different from selectPositionCaret in that it does not simply
     * move the caret. Rather, it will reposition the caret and anchor as necessary
     * to ensure that pos becomes the new caret and the far other end of the
     * selection becomes the anchor.
     * @param pos the position
     */
    public void extendSelection(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        int start = Math.min(dot, mark);
        int end = Math.max(dot, mark);
        if (p &lt; start) {
            selectRange(end, p);
        } else {
            selectRange(start, p);
        }
    }

    /**
     * Clears the text.
     */
    public void clear() {
        deselect();
        if (!text.isBound()) {
            setText(&quot;&quot;);
        }
    }

    /**
     * Clears the selection.
     */
    public void deselect() {
        // set the anchor equal to the caret position, which clears the selection
        // while also preserving the caret position
        selectRange(getCaretPosition(), getCaretPosition());
    }

    /**
     * Replaces the selection with the given replacement String. If there is
     * no selection, then the replacement text is simply inserted at the current
     * caret position. If there was a selection, then the selection is cleared
     * and the given replacement text inserted.
     * @param replacement the replacement string
     */
    public void replaceSelection(String replacement) {
        replaceText(getSelection(), replacement);
    }

    /**
     * If possible, undoes the last modification. If {@link #isUndoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void undo() {
        if (isUndoable()) {
            // Apply reverse change here
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (newText != null) {
                getContent().delete(start, start + newText.length(), oldText.isEmpty());
            }

            if (oldText != null) {
                getContent().insert(start, oldText, true);
                doSelectRange(start, start + oldText.length());
            } else {
                doSelectRange(start, start + newText.length());
            }

            undoChange = undoChange.prev;
        }
        updateUndoRedoState();
    }

    /**
     * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void redo() {
        if (isRedoable()) {
            // Apply change here
            undoChange = undoChange.next;
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (oldText != null) {
                getContent().delete(start, start + oldText.length(), newText.isEmpty());
            }

            if (newText != null) {
                getContent().insert(start, newText, true);
                doSelectRange(start + newText.length(), start + newText.length());
            } else {
                doSelectRange(start, start);
            }
        }
        updateUndoRedoState();
        // else beep ?
    }

    // Used by TextArea, although there are probably other better ways of
    // doing this.
    void textUpdated() { }

    private void resetUndoRedoState() {
        undoChange = undoChangeHead;
        undoChange.next = null;
        updateUndoRedoState();
    }

    private void updateUndoRedoState() {
        undoable.set(undoChange != undoChangeHead);
        redoable.set(undoChange.next != null);
    }

    private boolean filterAndSet(String value) {
        // Send the new value through the textFormatter, if one exists.
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        int length = content.length();
        if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
            TextFormatter.Change change = new TextFormatter.Change(
                    TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return false;
            }
            replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        } else {
            replaceText(0, length, value, 0, 0);
        }
        return true;
    }

    /**
     * This is what is ultimately called by every code path that will update
     * the content (except for undo / redo). The input into this method has
     * already run through the textFormatter where appropriate.
     *
     * @param start            The start index into the existing text which
     *                         will be replaced by the new value
     * @param end              The end index into the existing text which will
     *                         be replaced by the new value. As with
     *                         String.replace this is a lastIndex+1 value
     * @param value            The new text value
     * @param anchor           The new selection anchor after the change is made
     * @param caretPosition    The new selection caretPosition after the change
     *                         is made.
     * @return The amount of adjustment made to the end / anchor / caretPosition to
     *         accommodate for subsequent filtering (such as the filtering of
     *         new lines by the TextField)
     */
    private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
        // RT-16566: Need to take into account stripping of chars into the
        // final anchor &amp; caret position
        int length = getLength();
        int adjustmentAmount = 0;
        if (end != start) {
            getContent().delete(start, end, value.isEmpty());
            length -= (end - start);
        }
        if (value != null) {
            getContent().insert(start, value, true);
            adjustmentAmount = value.length() - (getLength() - length);
            anchor -= adjustmentAmount;
            caretPosition -= adjustmentAmount;
        }
        doSelectRange(anchor, caretPosition);
        return adjustmentAmount;
    }

    private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
        T value = formatter.getValue();
        StringConverter&lt;T&gt; converter = formatter.getValueConverter();
        if (converter != null) {
            String text = converter.toString(value);
            if (text == null) text = &quot;&quot;;
            replaceText(0, getLength(), text, text.length(), text.length());
        }
    }

    /**
     * Commit the current text and convert it to a value.
     * @since JavaFX 8u40
     */
    public final void commitValue() {
        if (getTextFormatter() != null) {
            getTextFormatter().updateValue(getText());
        }
    }

    /**
     * If the field is currently being edited, this call will set text to the last commited value.
     * @since JavaFX 8u40
     */
    public final void cancelEdit() {
        if (getTextFormatter() != null) {
            updateText(getTextFormatter());
        }
    }

    private FormatterAccessor accessor;

    private FormatterAccessor getFormatterAccessor() {
        if (accessor == null) {
            accessor = new TextInputControlFromatterAccessor();
        }
        return accessor;
    }


    /**
     * A little utility method for stripping out unwanted characters.
     *
     * @param txt
     * @param stripNewlines
     * @param stripTabs
     * @return The string after having the unwanted characters stripped out.
     */
    static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
        // Most of the time, when text is inserted, there are no illegal
        // characters. So we'll do a &quot;cheap&quot; check for illegal characters.
        // If we find one, we'll do a longer replace algorithm. In the
        // case of illegal characters, this may at worst be an O(2n) solution.
        // Strip out any characters that are outside the printed range
        if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
            StringBuilder s = new StringBuilder(txt.length());
            for (int i=0; i&lt;txt.length(); i++) {
                final char c = txt.charAt(i);
                if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
                    s.append(c);
                }
            }
            txt = s.toString();
        }
        return txt;
    }

    static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
        for (int i=0; i&lt;txt.length(); i++) {
            final char c = txt.charAt(i);
            if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
        }
        return false;
    }

    private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
        if (c == 0x7F) return true;
        if (c == 0xA) return newlineIllegal;
        if (c == 0x9) return tabIllegal;
        if (c &lt; 0x20) return true;
        return false;
    }

    // It can be bound, in which case we will force it to be an eager
    // binding so that we update the content eagerly
    // It can be bidirectionally bound, which basically will just work
    // If somebody changes the content directly, it will be notified and
    // send an invalidation event.
    private class TextProperty extends StringProperty {
        // This is used only when the property is bound
        private ObservableValue&lt;? extends String&gt; observable = null;
        // Added to the observable when bound
        private InvalidationListener listener = null;
        // Used for event handling
        private ExpressionHelper&lt;String&gt; helper = null;
        // The developer my set the Text property to null. Although
        // the Content must be given an empty String, we must still
        // treat the value as though it were null, so that a subsequent
        // getText() will return null.
        private boolean textIsNull = false;

        @Override public String get() {
            // Since we force eager binding and content is always up to date,
            // we just need to get it from content and not through the binding
            return textIsNull ? null : content.get();
        }

        @Override public void set(String value) {
            if (isBound()) {
                throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
            }
            doSet(value);
            markInvalid();
        }

        /**
         * Called whenever the content on the control has changed (as determined
         * by a listener on the content).
         */
        private void controlContentHasChanged() {
            markInvalid();
            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        }

        @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
            if (observable == null) {
                throw new NullPointerException(&quot;Cannot bind to null&quot;);
            }
            if (!observable.equals(this.observable)) {
                unbind();
                this.observable = observable;
                if (listener == null) {
                    listener = new Listener();
                }
                this.observable.addListener(listener);
                markInvalid();
                doSet(observable.getValue());
            }
        }

        @Override public void unbind() {
            if (observable != null) {
                doSet(observable.getValue());
                observable.removeListener(listener);
                observable = null;
            }
        }

        @Override public boolean isBound() {
            return observable != null;
        }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public Object getBean() {
            return TextInputControl.this;
        }

        @Override public String getName() {
            return &quot;text&quot;;
        }

        private void fireValueChangedEvent() {
            ExpressionHelper.fireValueChangedEvent(helper);
        }

        private void markInvalid() {
            fireValueChangedEvent();
        }

        /**
         * doSet is called whenever the setText() method was called directly
         * on the TextInputControl, or when the text property was bound,
         * unbound, or reacted to a binding invalidation. It is *not* called
         * when modifications to the content happened indirectly, such as
         * through the replaceText / replaceSelection methods.
         *
         * @param value The new value
         */
        private void doSet(String value) {
            // Guard against the null value.
            textIsNull = value == null;
            if (value == null) value = &quot;&quot;;

            if (!filterAndSet(value)) return;

            if (getTextFormatter() != null) {
                getTextFormatter().updateValue(getText());
            }

            textUpdated();

            // If the programmer has directly manipulated the text property
            // or has it bound up, then we will clear out any modifications
            // from the undo manager as we must suppose that the control is
            // being reused, for example, between forms.
            resetUndoRedoState();
        }

        private class Listener implements InvalidationListener {
            @Override
            public void invalidated(Observable valueModel) {
                // We now need to force it to be eagerly recomputed
                // because we need to push these changes to the
                // content model. Because changing the model ends
                // up calling invalidate and markInvalid, the
                // listeners will all be notified.
                doSet(observable.getValue());
            }
        }
    }

    /**
     * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
     * records the old and new text, and the start index. It also has
     * the links to the previous and next Changes in the chain. There
     * are two special UndoRedoChange objects in this chain representing the
     * head and the tail so we can have beforeFirst and afterLast
     * behavior as necessary.
     */
    static class UndoRedoChange {
        static long prevRecordTime;
        static final long CHANGE_DURATION = 2500; // milliseconds
        static boolean spaceCharSequence = false;
        int start;
        String oldText;
        String newText;
        UndoRedoChange prev;
        UndoRedoChange next;

        UndoRedoChange() { }

        public UndoRedoChange add(int start, String oldText, String newText) {
            UndoRedoChange c = new UndoRedoChange();
            c.start = start;
            c.oldText = oldText;
            c.newText = newText;
            c.prev = this;
            next = c;
            prevRecordTime = System.currentTimeMillis();
            return c;
        }

        static boolean hasChangeDurationElapsed() {
            return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
        }

        static void setSpaceCharSequence(boolean value) {
            spaceCharSequence = value;
        }
        static boolean isSpaceCharSequence() {
            return spaceCharSequence;
        }

        public UndoRedoChange discard() {
            prev.next = next;
            return prev;
        }

        // Handy to use when debugging, just put it in undo or redo
        // method or replaceText to see what is happening to the undo
        // history as it occurs.
        void debugPrint() {
            UndoRedoChange c = this;
            System.out.print(&quot;[&quot;);
            while (c != null) {
                System.out.print(c.toString());
                if (c.next != null) System.out.print(&quot;, &quot;);
                c = c.next;
            }
            System.out.println(&quot;]&quot;);
        }

        @Override public String toString() {
            if (oldText == null &amp;&amp; newText == null) {
                return &quot;head&quot;;
            }
            if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;added '&quot; + newText + &quot;' at index &quot; + start;
            } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;replaced '&quot; + oldText + &quot;' with '&quot; + newText + &quot;' at index &quot; + start;
            } else {
                return &quot;deleted '&quot; + oldText + &quot;' at index &quot; + start;
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/


    private static final PseudoClass PSEUDO_CLASS_READONLY
            = PseudoClass.getPseudoClass(&quot;readonly&quot;);

    private static class StyleableProperties {
        private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
            new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(TextInputControl n) {
                return n.font == null || !n.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
                return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FONT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                String text = getText();
                if (text == null || text.isEmpty()) {
                    text = getPromptText();
                }
                return text;
            }
            case EDITABLE: return isEditable();
            case SELECTION_START: return getSelection().getStart();
            case SELECTION_END: return getSelection().getEnd();
            case CARET_OFFSET: return getCaretPosition();
            case FONT: return getFont();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SET_TEXT: {
                String value = (String) parameters[0];
                if (value != null) setText(value);
                break;
            }
            case SET_TEXT_SELECTION: {
                Integer start = (Integer) parameters[0];
                Integer end = (Integer) parameters[1];
                if (start != null &amp;&amp; end != null) {
                    selectRange(start,  end);
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }

    private class TextInputControlFromatterAccessor implements FormatterAccessor {
        @Override
        public int getTextLength() {
            return TextInputControl.this.getLength();
        }

        @Override
        public String getText(int begin, int end) {
            return TextInputControl.this.getText(begin, end);
        }

        @Override
        public int getCaret() {
            return TextInputControl.this.getCaretPosition();
        }

        @Override
        public int getAnchor() {
            return TextInputControl.this.getAnchor();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
<A NAME="22"></A>                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#22',2,'match45-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1))</B></FONT>;
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextAreaSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.geometry.VerticalDirection;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import javafx.util.Duration;

import java.util.List;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;

/**
 * Default skin implementation for the {@link TextArea} control.
 *
 * @see TextArea
 * @since 9
 */
public class TextAreaSkin extends TextInputControlSkin&lt;TextArea&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /** A shared helper object, used only by downLines(). */
    private static final Path tmpCaretPath = new Path();



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    final private TextArea textArea;

    // *** NOTE: Multiple node mode is not yet fully implemented *** //
    private static final boolean USE_MULTIPLE_NODES = false;

    private final TextAreaBehavior behavior;

    private double computedMinWidth = Double.NEGATIVE_INFINITY;
    private double computedMinHeight = Double.NEGATIVE_INFINITY;
    private double computedPrefWidth = Double.NEGATIVE_INFINITY;
    private double computedPrefHeight = Double.NEGATIVE_INFINITY;
    private double widthForComputedPrefHeight = Double.NEGATIVE_INFINITY;
    private double characterWidth;
    private double lineHeight;

    private ContentView contentView = new ContentView();
    private Group paragraphNodes = new Group();

    private Text promptNode;
    private ObservableBooleanValue usePromptText;

    private ObservableIntegerValue caretPosition;
    private Group selectionHighlightGroup = new Group();

    private ScrollPane scrollPane;
    private Bounds oldViewportBounds;

    private VerticalDirection scrollDirection = null;

    private Path characterBoundingPath = new Path();

    private Timeline scrollSelectionTimeline = new Timeline();
    private EventHandler&lt;ActionEvent&gt; scrollSelectionHandler = event -&gt; {
        switch (scrollDirection) {
            case UP: {
                // TODO Get previous offset
                break;
            }

            case DOWN: {
                // TODO Get next offset
                break;
            }
        }
    };

    private double pressX, pressY; // For dragging handles on embedded
    private boolean handlePressed;

    /**
     * Remembers horizontal position when traversing up / down.
     */
    double targetCaretX = -1;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextAreaSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextAreaSkin(final TextArea control) {
        super(control);

        // install default input map for the text area control
        this.behavior = new TextAreaBehavior(control);
        this.behavior.setTextAreaSkin(this);
//        control.setInputMap(behavior.getInputMap());

        this.textArea = control;

        caretPosition = new IntegerBinding() {
            { bind(control.caretPositionProperty()); }
            @Override protected int computeValue() {
                return control.getCaretPosition();
            }
        };
        caretPosition.addListener((observable, oldValue, newValue) -&gt; {
            targetCaretX = -1;
            if (control.getWidth() &gt; 0) {
                setForwardBias(true);
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
            }
        });

//        setManaged(false);

        // Initialize content
        scrollPane = new ScrollPane();
        scrollPane.setFitToWidth(control.isWrapText());
        scrollPane.setContent(contentView);
        getChildren().add(scrollPane);

        getSkinnable().addEventFilter(ScrollEvent.ANY, event -&gt; {
            if (event.isDirect() &amp;&amp; handlePressed) {
                event.consume();
            }
        });

        // Add selection
        selectionHighlightGroup.setManaged(false);
        selectionHighlightGroup.setVisible(false);
        contentView.getChildren().add(selectionHighlightGroup);

        // Add content view
        paragraphNodes.setManaged(false);
        contentView.getChildren().add(paragraphNodes);

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());
        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        contentView.getChildren().add(caretPath);

        if (SHOW_HANDLES) {
            contentView.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
        }

        scrollPane.hvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollLeft(newValue.doubleValue() * getScrollLeftMax());
        });

        scrollPane.vvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollTop(newValue.doubleValue() * getScrollTopMax());
        });

        // Initialize the scroll selection timeline
        scrollSelectionTimeline.setCycleCount(Timeline.INDEFINITE);
        List&lt;KeyFrame&gt; scrollSelectionFrames = scrollSelectionTimeline.getKeyFrames();
        scrollSelectionFrames.clear();
        scrollSelectionFrames.add(new KeyFrame(Duration.millis(350), scrollSelectionHandler));

        // Add initial text content
        for (int i = 0, n = USE_MULTIPLE_NODES ? control.getParagraphs().size() : 1; i &lt; n; i++) {
            CharSequence paragraph = (n == 1) ? control.textProperty().getValueSafe() : control.getParagraphs().get(i);
            addParagraphNode(i, paragraph.toString());
        }

        control.selectionProperty().addListener((observable, oldValue, newValue) -&gt; {
            // TODO Why do we need two calls here?
            control.requestLayout();
            contentView.requestLayout();
        });

        control.wrapTextProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            scrollPane.setFitToWidth(newValue);
        });

        control.prefColumnCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportWidth();
        });

        control.prefRowCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportHeight();
        });

        updateFontMetrics();
        fontMetrics.addListener(valueModel -&gt; {
            updateFontMetrics();
        });

        contentView.paddingProperty().addListener(valueModel -&gt; {
            updatePrefViewportWidth();
            updatePrefViewportHeight();
        });

        scrollPane.viewportBoundsProperty().addListener(valueModel -&gt; {
            if (scrollPane.getViewportBounds() != null) {
                // ScrollPane creates a new Bounds instance for each
                // layout pass, so we need to check if the width/height
                // have really changed to avoid infinite layout requests.
                Bounds newViewportBounds = scrollPane.getViewportBounds();
                if (oldViewportBounds == null ||
                    oldViewportBounds.getWidth() != newViewportBounds.getWidth() ||
                    oldViewportBounds.getHeight() != newViewportBounds.getHeight()) {

                    invalidateMetrics();
                    oldViewportBounds = newViewportBounds;
                    contentView.requestLayout();
                }
            }
        });

        control.scrollTopProperty().addListener((observable, oldValue, newValue) -&gt; {
            double vValue = (newValue.doubleValue() &lt; getScrollTopMax())
                               ? (newValue.doubleValue() / getScrollTopMax()) : 1.0;
            scrollPane.setVvalue(vValue);
        });

        control.scrollLeftProperty().addListener((observable, oldValue, newValue) -&gt; {
            double hValue = (newValue.doubleValue() &lt; getScrollLeftMax())
                               ? (newValue.doubleValue() / getScrollLeftMax()) : 1.0;
            scrollPane.setHvalue(hValue);
        });

        if (USE_MULTIPLE_NODES) {
            control.getParagraphs().addListener((ListChangeListener.Change&lt;? extends CharSequence&gt; change) -&gt; {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends CharSequence&gt; removed = change.getRemoved();
                    if (from &lt; to) {

                        if (removed.isEmpty()) {
                            // This is an add
                            for (int i = from, n = to; i &lt; n; i++) {
                                addParagraphNode(i, change.getList().get(i).toString());
                            }
                        } else {
                            // This is an update
                            for (int i = from, n = to; i &lt; n; i++) {
                                Node node = paragraphNodes.getChildren().get(i);
                                Text paragraphNode = (Text) node;
                                paragraphNode.setText(change.getList().get(i).toString());
                            }
                        }
                    } else {
                        // This is a remove
                        paragraphNodes.getChildren().subList(from, from + removed.size()).clear();
                    }
                }
            });
        } else {
            control.textProperty().addListener(observable -&gt; {
                invalidateMetrics();
                ((Text)paragraphNodes.getChildren().get(0)).setText(control.textProperty().getValueSafe());
                contentView.requestLayout();
            });
        }

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(), control.promptTextProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty());
            }
        };

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        updateHighlightFill();
        updatePrefViewportWidth();
        updatePrefViewportHeight();
        if (control.isFocused()) setCaretAnimating(true);

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                handlePressed = true;
                e.consume();
            };

            EventHandler&lt;MouseEvent&gt; handleReleaseHandler = event -&gt; {
                handlePressed = false;
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseReleased(handleReleaseHandler);
            selectionHandle1.setOnMouseReleased(handleReleaseHandler);
            selectionHandle2.setOnMouseReleased(handleReleaseHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + caretHandle.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle1.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY + selectionHandle1.getHeight() + 5);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &lt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &gt;= control1.getAnchor()) {
                        pos = control1.getAnchor();
                    }
                }
                positionCaret(hit, true);
                e.consume();
            });

            selectionHandle2.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle2.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &gt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &lt;= control1.getAnchor() + 1) {
                        pos = Math.min(control1.getAnchor() + 2, control1.getLength());
                    }
                    positionCaret(hit, true);
                }
                e.consume();
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void invalidateMetrics() {
        computedMinWidth = Double.NEGATIVE_INFINITY;
        computedMinHeight = Double.NEGATIVE_INFINITY;
        computedPrefWidth = Double.NEGATIVE_INFINITY;
        computedPrefHeight = Double.NEGATIVE_INFINITY;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        scrollPane.resizeRelocate(contentX, contentY, contentWidth, contentHeight);
    }

    /** {@inheritDoc} */
    @Override protected void updateHighlightFill() {
        for (Node node : selectionHighlightGroup.getChildren()) {
            Path selectionHighlightPath = (Path)node;
            selectionHighlightPath.setFill(highlightFillProperty().get());
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Text textNode = getTextNode();
        Point2D p = new Point2D(x - textNode.getLayoutX(), y - getTextTranslateY());
        HitInfo hit = textNode.hitTest(translateCaretPosition(p));
        return hit;
    };

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case LINE:
                switch (dir) {
                    case UP:
                        previousLine(select);
                        break;
                    case DOWN:
                        nextLine(select);
                        break;
                    case BEGINNING:
                        lineStart(select, select &amp;&amp; isMac());
                        break;
                    case END:
                        lineEnd(select, select &amp;&amp; isMac());
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PAGE:
                switch (dir) {
                    case UP:
                        previousPage(select);
                        break;
                    case DOWN:
                        nextPage(select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PARAGRAPH:
                switch (dir) {
                    case UP:
                        paragraphStart(true, select);
                        break;
                    case DOWN:
                        paragraphEnd(true, select);
                        break;
                    case BEGINNING:
                        paragraphStart(false, select);
                        break;
                    case END:
                        paragraphEnd(false, select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
            positionCaret(hit.getInsertionIndex(), leading, false, false);
        } else {
            // We're at beginning or end of line. Try moving up / down.
            int dot = textArea.getCaretPosition();
            targetCaretX = moveRight ? 0 : Double.MAX_VALUE;
            // TODO: Use Bidi sniffing instead of assuming right means forward here?
            downLines(moveRight ? 1 : -1, false, false);
            targetCaretX = -1;
            if (dot == textArea.getCaretPosition()) {
                if (moveRight) {
                    textArea.forward();
                } else {
                    textArea.backward();
                }
            }
        }
    }

    private void downLines(int nLines, boolean select, boolean extendSelection) {
        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();

        // The middle y coordinate of the the line we want to go to.
        double targetLineMidY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2 + nLines * lineHeight;
        if (targetLineMidY &lt; 0) {
            targetLineMidY = 0;
        }

        // The target x for the caret. This may have been set during a
        // previous call.
        double x = (targetCaretX &gt;= 0) ? targetCaretX : (caretBounds.getMaxX());

        // Find a text position for the target x,y.
        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));
        int pos = hit.getCharIndex();

        // Save the old pos temporarily while testing the new one.
        int oldPos = textNode.getCaretPosition();
        boolean oldBias = textNode.isCaretBias();
        textNode.setCaretBias(hit.isLeading());
        textNode.setCaretPosition(pos);
        tmpCaretPath.getElements().clear();
        tmpCaretPath.getElements().addAll(textNode.getCaretShape());
        tmpCaretPath.setLayoutX(textNode.getLayoutX());
        tmpCaretPath.setLayoutY(textNode.getLayoutY());
        Bounds tmpCaretBounds = tmpCaretPath.getLayoutBounds();
        // The y for the middle of the row we found.
        double foundLineMidY = (tmpCaretBounds.getMinY() + tmpCaretBounds.getMaxY()) / 2;
        textNode.setCaretBias(oldBias);
        textNode.setCaretPosition(oldPos);

        // Test if the found line is in the correct direction and move
        // the caret.
        if (nLines == 0 ||
                (nLines &gt; 0 &amp;&amp; foundLineMidY &gt; caretBounds.getMaxY()) ||
                (nLines &lt; 0 &amp;&amp; foundLineMidY &lt; caretBounds.getMinY())) {

<A NAME="33"></A>            positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, extendSelection);
            targetCaretX = x;
        }
    <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#33',2,'match45-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void previousLine(boolean select) {
        downLines(-1, select, false);
    }

    private void nextLine(boolean select) {
        downLines(1, select, false);
    }

    private void previousPage(boolean select) {
        downLines(-(int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void nextPage(boolean select) {
        downLines((int)(scrollPane.getViewportBounds</B></FONT>().getHeight() / lineHeight),
                select, false);
    }

    private void lineStart(boolean select, boolean extendSelection) {
        targetCaretX = 0;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }

    private void lineEnd(boolean select, boolean extendSelection) {
        targetCaretX = Double.MAX_VALUE;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }


    private void paragraphStart(boolean previousIfAtStart, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();

        if (pos &gt; 0) {
            if (previousIfAtStart &amp;&amp; text.codePointAt(pos-1) == 0x0a) {
                // We are at the beginning of a paragraph.
                // Back up to the previous paragraph.
                pos--;
            }
            // Back up to the beginning of this paragraph
            while (pos &gt; 0 &amp;&amp; text.codePointAt(pos-1) != 0x0a) {
                pos--;
            }
            if (select) {
<A NAME="21"></A>                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
                <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#21',2,'match45-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setForwardBias(true);
            }
        }
    }

    private void paragraphEnd(boolean goPastInitialNewline, boolean select) {
        TextArea textArea = getSkinnable()</B></FONT>;
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();
        int len = text.length();
        boolean wentPastInitialNewline = false;
        boolean goPastTrailingNewline = isWindows();

        if (pos &lt; len) {
            if (goPastInitialNewline &amp;&amp; text.codePointAt(pos) == 0x0a) {
                // We are at the end of a paragraph, start by moving to the
                // next paragraph.
                pos++;
                wentPastInitialNewline = true;
            }
            if (!(goPastTrailingNewline &amp;&amp; wentPastInitialNewline)) {
                // Go to the end of this paragraph
                while (pos &lt; len &amp;&amp; text.codePointAt(pos) != 0x0a) {
                    pos++;
                }
                if (goPastTrailingNewline &amp;&amp; pos &lt; len) {
                    // We are at the end of a paragraph, finish by moving to
                    // the beginning of the next paragraph (Windows behavior).
                    pos++;
                }
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.underlineShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.rangeShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        int pStart = 0;
        Text paragraphNode = null;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                paragraphNode = p;
                break;
            }
            pStart = pEnd + 1;
        }

        if (paragraphNode != null) {
            for (Node node : nodes) {
                node.setLayoutX(paragraphNode.getLayoutX());
                node.setLayoutY(paragraphNode.getLayoutY());
            }
        }
        contentView.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        contentView.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        contentView.layoutChildren();
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - contentView.snappedLeftInset() - getSkinnable().getScrollLeft()),
                    Math.max(0, p.getY() - contentView.snappedTopInset() - getSkinnable().getScrollTop()));
        }
        return p;
    }

    // Public for FXVKSkin
    /**
     * Gets the {@code Bounds} of the caret of the skinned {@code TextArea}.
     * @return the {@code Bounds} of the caret shape, relative to the {@code TextArea}.
     */
    public Bounds getCaretBounds() {
        return getSkinnable().sceneToLocal(caretPath.localToScene(caretPath.getBoundsInLocal()));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case LINE_FOR_OFFSET:
            case LINE_START:
            case LINE_END:
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                Text text = getTextNode();
                return text.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }

        // TODO Unregister listeners on text editor, paragraph list
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Text firstParagraph = (Text) paragraphNodes.getChildren().get(0);
        return Utils.getAscent(getSkinnable().getFont(), firstParagraph.getBoundsType())
                + contentView.snappedTopInset() + textArea.snappedTopInset();
    }

    private char getCharacter(int index) {
        int n = paragraphNodes.getChildren().size();

        int paragraphIndex = 0;
        int offset = index;

        String paragraph = null;
        while (paragraphIndex &lt; n) {
            Text paragraphNode = (Text)paragraphNodes.getChildren().get(paragraphIndex);
            paragraph = paragraphNode.getText();
            int count = paragraph.length() + 1;

            if (offset &lt; count) {
                break;
            }

            offset -= count;
            paragraphIndex++;
        }

        return offset == paragraph.length() ? '\n' : paragraph.charAt(offset);
    }

    /** {@inheritDoc} */
    @Override protected int getInsertionPoint(double x, double y) {
        TextArea textArea = getSkinnable();

        int n = paragraphNodes.getChildren().size();
        int index = -1;

        if (n &gt; 0) {
            if (y &lt; contentView.snappedTopInset()) {
                // Select the character at x in the first row
                Text paragraphNode = (Text)paragraphNodes.getChildren().get(0);
                index = getNextInsertionPoint(paragraphNode, x, -1, VerticalDirection.DOWN);
            } else if (y &gt; contentView.snappedTopInset() + contentView.getHeight()) {
                // Select the character at x in the last row
                int lastParagraphIndex = n - 1;
                Text lastParagraphView = (Text)paragraphNodes.getChildren().get(lastParagraphIndex);

                index = getNextInsertionPoint(lastParagraphView, x, -1, VerticalDirection.UP)
                        + (textArea.getLength() - lastParagraphView.getText().length());
            } else {
                // Select the character at x in the row at y
                int paragraphOffset = 0;
                for (int i = 0; i &lt; n; i++) {
                    Text paragraphNode = (Text)paragraphNodes.getChildren().get(i);

                    Bounds bounds = paragraphNode.getBoundsInLocal();
                    double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();
                    if (y &gt;= paragraphViewY
                            &amp;&amp; y &lt; paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {
                        index = getInsertionPoint(paragraphNode,
                                x - paragraphNode.getLayoutX(),
                                y - paragraphNode.getLayoutY()) + paragraphOffset;
                        break;
                    }

                    paragraphOffset += paragraphNode.getText().length() + 1;
                }
            }
        }

        return index;
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, false);
    }

    private void positionCaret(int pos, boolean leading, boolean select, boolean extendSelection) {
        boolean isNewLine =
                (pos &gt; 0 &amp;&amp;
                        pos &lt;= getSkinnable().getLength() &amp;&amp;
                        getSkinnable().getText().codePointAt(pos-1) == 0x0a);

        // special handling for a new line
        if (!leading &amp;&amp; isNewLine) {
            leading = true;
            pos -= 1;
        }

        if (select) {
            if (extendSelection) {
                getSkinnable().extendSelection(pos);
            } else {
                getSkinnable().selectPositionCaret(pos);
            }
        } else {
            getSkinnable().positionCaret(pos);
        }

        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        TextArea textArea = getSkinnable();

        int paragraphIndex = paragraphNodes.getChildren().size();
        int paragraphOffset = textArea.getLength() + 1;

        Text paragraphNode = null;
        do {
            paragraphNode = (Text)paragraphNodes.getChildren().get(--paragraphIndex);
            paragraphOffset -= paragraphNode.getText().length() + 1;
        } while (index &lt; paragraphOffset);

        int characterIndex = index - paragraphOffset;
        boolean terminator = false;

        if (characterIndex == paragraphNode.getText().length()) {
            characterIndex--;
            terminator = true;
        }

        characterBoundingPath.getElements().clear();
        characterBoundingPath.getElements().addAll(paragraphNode.rangeShape(characterIndex, characterIndex + 1));
        characterBoundingPath.setLayoutX(paragraphNode.getLayoutX());
        characterBoundingPath.setLayoutY(paragraphNode.getLayoutY());

        Bounds bounds = characterBoundingPath.getBoundsInLocal();

        double x = bounds.getMinX() + paragraphNode.getLayoutX() - textArea.getScrollLeft();
        double y = bounds.getMinY() + paragraphNode.getLayoutY() - textArea.getScrollTop();

        // Sometimes the bounds is empty, in which case we must ignore the width/height
        double width = bounds.isEmpty() ? 0 : bounds.getWidth();
        double height = bounds.isEmpty() ? 0 : bounds.getHeight();

        if (terminator) {
            x += width;
            width = 0;
        }

        return new Rectangle2D(x, y, width, height);
    }

    /** {@inheritDoc} */
    @Override protected void scrollCharacterToVisible(final int index) {
        // TODO We queue a callback because when characters are added or
        // removed the bounds are not immediately updated; is this really
        // necessary?

        Platform.runLater(() -&gt; {
            if (getSkinnable().getLength() == 0) {
                return;
            }
            Rectangle2D characterBounds = getCharacterBounds(index);
            scrollBoundsToVisible(characterBounds);
        });
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextAreaBehavior getBehavior() {
        return behavior;
    }

    private void createPromptNode() {
        if (promptNode == null &amp;&amp; usePromptText.get()) {
            promptNode = new Text();
            contentView.getChildren().add(0, promptNode);
            promptNode.setManaged(false);
            promptNode.getStyleClass().add(&quot;text&quot;);
            promptNode.visibleProperty().bind(usePromptText);
            promptNode.fontProperty().bind(getSkinnable().fontProperty());
            promptNode.textProperty().bind(getSkinnable().promptTextProperty());
            promptNode.fillProperty().bind(promptTextFillProperty());
        }
    }

    private void addParagraphNode(int i, String string) {
        final TextArea textArea = getSkinnable();
        Text paragraphNode = new Text(string);
        paragraphNode.setTextOrigin(VPos.TOP);
        paragraphNode.setManaged(false);
        paragraphNode.getStyleClass().add(&quot;text&quot;);
        paragraphNode.boundsTypeProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updateFontMetrics();
        });
        paragraphNodes.getChildren().add(i, paragraphNode);

        paragraphNode.fontProperty().bind(textArea.fontProperty());
        paragraphNode.fillProperty().bind(textFillProperty());
        paragraphNode.selectionFillProperty().bind(highlightTextFillProperty());
    }

    private double getScrollTopMax() {
        return Math.max(0, contentView.getHeight() - scrollPane.getViewportBounds().getHeight());
    }

    private double getScrollLeftMax() {
        return Math.max(0, contentView.getWidth() - scrollPane.getViewportBounds().getWidth());
    }

    private int getInsertionPoint(Text paragraphNode, double x, double y) {
        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));
        return hitInfo.getInsertionIndex();
    }

    private int getNextInsertionPoint(Text paragraphNode, double x, int from,
        VerticalDirection scrollDirection) {
        // TODO
        return 0;
    }

    private void scrollCaretToVisible() {
        TextArea textArea = getSkinnable();
        Bounds bounds = caretPath.getLayoutBounds();
        double x = bounds.getMinX() - textArea.getScrollLeft();
        double y = bounds.getMinY() - textArea.getScrollTop();
        double w = bounds.getWidth();
        double h = bounds.getHeight();

        if (SHOW_HANDLES) {
            if (caretHandle.isVisible()) {
                h += caretHandle.getHeight();
            } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
                x -= selectionHandle1.getWidth() / 2;
                y -= selectionHandle1.getHeight();
                w += selectionHandle1.getWidth() / 2 + selectionHandle2.getWidth() / 2;
                h += selectionHandle1.getHeight() + selectionHandle2.getHeight();
            }
        }

        if (w &gt; 0 &amp;&amp; h &gt; 0) {
            scrollBoundsToVisible(new Rectangle2D(x, y, w, h));
        }
    }

    private void scrollBoundsToVisible(Rectangle2D bounds) {
        TextArea textArea = getSkinnable();
        Bounds viewportBounds = scrollPane.getViewportBounds();

        double viewportWidth = viewportBounds.getWidth();
        double viewportHeight = viewportBounds.getHeight();
        double scrollTop = textArea.getScrollTop();
        double scrollLeft = textArea.getScrollLeft();
        double slop = 6.0;

        if (bounds.getMinY() &lt; 0) {
            double y = scrollTop + bounds.getMinY();
            if (y &lt;= contentView.snappedTopInset()) {
                y = 0;
            }
            textArea.setScrollTop(y);
        } else if (contentView.snappedTopInset() + bounds.getMaxY() &gt; viewportHeight) {
            double y = scrollTop + contentView.snappedTopInset() + bounds.getMaxY() - viewportHeight;
            if (y &gt;= getScrollTopMax() - contentView.snappedBottomInset()) {
                y = getScrollTopMax();
            }
            textArea.setScrollTop(y);
        }


        if (bounds.getMinX() &lt; 0) {
            double x = scrollLeft + bounds.getMinX() - slop;
            if (x &lt;= contentView.snappedLeftInset() + slop) {
                x = 0;
            }
            textArea.setScrollLeft(x);
        } else if (contentView.snappedLeftInset() + bounds.getMaxX() &gt; viewportWidth) {
            double x = scrollLeft + contentView.snappedLeftInset() + bounds.getMaxX() - viewportWidth + slop;
            if (x &gt;= getScrollLeftMax() - contentView.snappedRightInset() - slop) {
                x = getScrollLeftMax();
            }
            textArea.setScrollLeft(x);
        }
    }

    private void updatePrefViewportWidth() {
        int columnCount = getSkinnable().getPrefColumnCount();
        scrollPane.setPrefViewportWidth(columnCount * characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
        scrollPane.setMinViewportWidth(characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
    }

    private void updatePrefViewportHeight() {
        int rowCount = getSkinnable().getPrefRowCount();
        scrollPane.setPrefViewportHeight(rowCount * lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
        scrollPane.setMinViewportHeight(lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
    }

    private void updateFontMetrics() {
        Text firstParagraph = (Text)paragraphNodes.getChildren().get(0);
        lineHeight = Utils.getLineHeight(getSkinnable().getFont(), firstParagraph.getBoundsType());
        characterWidth = fontMetrics.get().getCharWidth('W');
    }

    private double getTextTranslateX() {
        return contentView.snappedLeftInset();
    }

    private double getTextTranslateY() {
        return contentView.snappedTopInset();
    }

    private double getTextLeft() {
        return 0;
    }

    private Point2D translateCaretPosition(Point2D p) {
        return p;
    }

    private Text getTextNode() {
        if (USE_MULTIPLE_NODES) {
            throw new IllegalArgumentException(&quot;Multiple node traversal is not yet implemented.&quot;);
        }
        return (Text)paragraphNodes.getChildren().get(0);
    }

    private void updateTextNodeCaretPos(int pos) {
        Text textNode = getTextNode();
        if (isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }



    /**************************************************************************
     *
     * Support classes
     *
     **************************************************************************/

    private class ContentView extends Region {
        {
            getStyleClass().add(&quot;content&quot;);

            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                behavior.mousePressed(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                behavior.mouseReleased(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_DRAGGED, event -&gt; {
                behavior.mouseDragged(event);
                event.consume();
            });
        }

        @Override protected ObservableList&lt;Node&gt; getChildren() {
            return super.getChildren();
        }

        @Override public Orientation getContentBias() {
            return Orientation.HORIZONTAL;
        }

        @Override protected double computePrefWidth(double height) {
            if (computedPrefWidth &lt; 0) {
                double prefWidth = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefWidth = Math.max(prefWidth,
                            Utils.computeTextWidth(paragraphNode.getFont(),
                                    paragraphNode.getText(), 0));
                }

                prefWidth += snappedLeftInset() + snappedRightInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefWidth = Math.max(prefWidth, (viewPortBounds != null) ? viewPortBounds.getWidth() : 0);
            }
            return computedPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            if (width != widthForComputedPrefHeight) {
                invalidateMetrics();
                widthForComputedPrefHeight = width;
            }

            if (computedPrefHeight &lt; 0) {
                double wrappingWidth;
                if (width == -1) {
                    wrappingWidth = 0;
                } else {
                    wrappingWidth = Math.max(width - (snappedLeftInset() + snappedRightInset()), 0);
                }

                double prefHeight = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefHeight += Utils.computeTextHeight(
                            paragraphNode.getFont(),
                            paragraphNode.getText(),
                            wrappingWidth,
                            paragraphNode.getBoundsType());
                }

                prefHeight += snappedTopInset() + snappedBottomInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefHeight = Math.max(prefHeight, (viewPortBounds != null) ? viewPortBounds.getHeight() : 0);
            }
            return computedPrefHeight;
        }

        @Override protected double computeMinWidth(double height) {
            if (computedMinWidth &lt; 0) {
                double hInsets = snappedLeftInset() + snappedRightInset();
                computedMinWidth = Math.min(characterWidth + hInsets, computePrefWidth(height));
            }
            return computedMinWidth;
        }

        @Override protected double computeMinHeight(double width) {
            if (computedMinHeight &lt; 0) {
                double vInsets = snappedTopInset() + snappedBottomInset();
                computedMinHeight = Math.min(lineHeight + vInsets, computePrefHeight(width));
            }
            return computedMinHeight;
        }

        @Override public void layoutChildren() {
            TextArea textArea = getSkinnable();
            double width = getWidth();

            // Lay out paragraphs
            final double topPadding = snappedTopInset();
            final double leftPadding = snappedLeftInset();

            double wrappingWidth = Math.max(width - (leftPadding + snappedRightInset()), 0);

            double y = topPadding;

            final List&lt;Node&gt; paragraphNodesChildren = paragraphNodes.getChildren();

            for (int i = 0; i &lt; paragraphNodesChildren.size(); i++) {
                Node node = paragraphNodesChildren.get(i);
                Text paragraphNode = (Text)node;
                paragraphNode.setWrappingWidth(wrappingWidth);

                Bounds bounds = paragraphNode.getBoundsInLocal();
                paragraphNode.setLayoutX(leftPadding);
                paragraphNode.setLayoutY(y);

                y += bounds.getHeight();
            }

            if (promptNode != null) {
                promptNode.setLayoutX(leftPadding);
                promptNode.setLayoutY(topPadding + promptNode.getBaselineOffset());
                promptNode.setWrappingWidth(wrappingWidth);
            }

            // Update the selection
            IndexRange selection = textArea.getSelection();
            Bounds oldCaretBounds = caretPath.getBoundsInParent();

            selectionHighlightGroup.getChildren().clear();

            int caretPos = textArea.getCaretPosition();
            int anchorPos = textArea.getAnchor();

            if (SHOW_HANDLES) {
                // Install and resize the handles for caret and anchor.
                if (selection.getLength() &gt; 0) {
                    selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                            selectionHandle1.prefHeight(-1));
                    selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                            selectionHandle2.prefHeight(-1));
                } else {
                    caretHandle.resize(caretHandle.prefWidth(-1),
                            caretHandle.prefHeight(-1));
                }

                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the actual caret.
                if (selection.getLength() &gt; 0) {
                    int paragraphIndex = paragraphNodesChildren.size();
                    int paragraphOffset = textArea.getLength() + 1;
                    Text paragraphNode = null;
                    do {
                        paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                        paragraphOffset -= paragraphNode.getText().length() + 1;
                    } while (anchorPos &lt; paragraphOffset);

                    updateTextNodeCaretPos(anchorPos - paragraphOffset);
                    caretPath.getElements().clear();
                    caretPath.getElements().addAll(paragraphNode.getCaretShape());
                    caretPath.setLayoutX(paragraphNode.getLayoutX());
                    caretPath.setLayoutY(paragraphNode.getLayoutY());

                    Bounds b = caretPath.getBoundsInParent();
                    if (caretPos &lt; anchorPos) {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    } else {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    }
                }
            }

            {
                // Position caret
                int paragraphIndex = paragraphNodesChildren.size();
                int paragraphOffset = textArea.getLength() + 1;

                Text paragraphNode = null;
                do {
                    paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                    paragraphOffset -= paragraphNode.getText().length() + 1;
                } while (caretPos &lt; paragraphOffset);

                updateTextNodeCaretPos(caretPos - paragraphOffset);

                caretPath.getElements().clear();
                caretPath.getElements().addAll(paragraphNode.getCaretShape());

                caretPath.setLayoutX(paragraphNode.getLayoutX());

                // TODO: Remove this temporary workaround for RT-27533
                paragraphNode.setLayoutX(2 * paragraphNode.getLayoutX() - paragraphNode.getBoundsInParent().getMinX());

                caretPath.setLayoutY(paragraphNode.getLayoutY());
                if (oldCaretBounds == null || !oldCaretBounds.equals(caretPath.getBoundsInParent())) {
                    scrollCaretToVisible();
                }
            }

            // Update selection fg and bg
            int start = selection.getStart();
            int end = selection.getEnd();
            for (int i = 0, max = paragraphNodesChildren.size(); i &lt; max; i++) {
                Node paragraphNode = paragraphNodesChildren.get(i);
                Text textNode = (Text)paragraphNode;
                int paragraphLength = textNode.getText().length() + 1;
                if (end &gt; start &amp;&amp; start &lt; paragraphLength) {
                    textNode.setSelectionStart(start);
                    textNode.setSelectionEnd(Math.min(end, paragraphLength));

                    Path selectionHighlightPath = new Path();
                    selectionHighlightPath.setManaged(false);
                    selectionHighlightPath.setStroke(null);
                    PathElement[] selectionShape = textNode.getSelectionShape();
                    if (selectionShape != null) {
                        selectionHighlightPath.getElements().addAll(selectionShape);
                    }
                    selectionHighlightGroup.getChildren().add(selectionHighlightPath);
                    selectionHighlightGroup.setVisible(true);
                    selectionHighlightPath.setLayoutX(textNode.getLayoutX());
                    selectionHighlightPath.setLayoutY(textNode.getLayoutY());
                    updateHighlightFill();
                } else {
                    textNode.setSelectionStart(-1);
                    textNode.setSelectionEnd(-1);
                    selectionHighlightGroup.setVisible(false);
                }
                start = Math.max(0, start - paragraphLength);
                end   = Math.max(0, end   - paragraphLength);
            }

            if (SHOW_HANDLES) {
                // Position handle for the caret. This could be handle1 or handle2 when
                // a selection is active.
                Bounds b = caretPath.getBoundsInParent();
                if (selection.getLength() &gt; 0) {
                    if (caretPos &lt; anchorPos) {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    } else {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    }
                } else {
                    caretHandle.setLayoutX(b.getMinX() - caretHandle.getWidth() / 2 + 1);
                    caretHandle.setLayoutY(b.getMaxY());
                }
            }

            if (scrollPane.getPrefViewportWidth() == 0
                    || scrollPane.getPrefViewportHeight() == 0) {
                updatePrefViewportWidth();
                updatePrefViewportHeight();
                if (getParent() != null &amp;&amp; scrollPane.getPrefViewportWidth() &gt; 0
                        || scrollPane.getPrefViewportHeight() &gt; 0) {
                    // Force layout of viewRect in ScrollPaneSkin
                    getParent().requestLayout();
                }
            }

            // RT-36454: Fit to width/height only if smaller than viewport.
            // That is, grow to fit but don't shrink to fit.
            Bounds viewportBounds = scrollPane.getViewportBounds();
            boolean wasFitToWidth = scrollPane.isFitToWidth();
            boolean wasFitToHeight = scrollPane.isFitToHeight();
            boolean setFitToWidth = textArea.isWrapText() || computePrefWidth(-1) &lt;= viewportBounds.getWidth();
            boolean setFitToHeight = computePrefHeight(width) &lt;= viewportBounds.getHeight();
            if (wasFitToWidth != setFitToWidth || wasFitToHeight != setFitToHeight) {
                Platform.runLater(() -&gt; {
                    scrollPane.setFitToWidth(setFitToWidth);
                    scrollPane.setFitToHeight(setFitToHeight);
                });
                getParent().requestLayout();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Platform.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Locale;

final class Platform {

    public static final String MAC = &quot;Mac&quot;;
    public static final String WINDOWS = &quot;Win&quot;;
    public static final String GTK = &quot;Gtk&quot;;
    public static final String IOS = &quot;Ios&quot;;
    public static final String UNKNOWN = &quot;unknown&quot;;

    static private String type = null;

    static public synchronized String determinePlatform() {
        if (type == null) {

            // Provide for a runtime override, allowing EGL for example
            String userPlatform =
                AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;glass.platform&quot;));

            if (userPlatform != null) {
                if (userPlatform.equals(&quot;macosx&quot;))
                   type = MAC;
                else if (userPlatform.equals(&quot;windows&quot;))
<A NAME="5"></A>                   type = WINDOWS;
                else if (userPlatform.equals(&quot;linux&quot;))
                   type = GTK;
                else <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#5',2,'match45-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (userPlatform.equals(&quot;gtk&quot;))
                   type = GTK;
                else if (userPlatform.equals(&quot;ios&quot;))
                   type = IOS;
                else
                   type = userPlatform;</B></FONT>
                return type;
            }

            String osName = System.getProperty(&quot;os.name&quot;);
            String osNameLowerCase = osName.toLowerCase(Locale.ROOT);
            if (osNameLowerCase.startsWith(&quot;mac&quot;) || osNameLowerCase.startsWith(&quot;darwin&quot;)) {
                type = MAC;
            } else if (osNameLowerCase.startsWith(&quot;wind&quot;)) {
                type = WINDOWS;
            } else if (osNameLowerCase.startsWith(&quot;linux&quot;)) {
                type = GTK;
            }
        }

        return type;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/application/LauncherImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.application;

import javafx.application.Application;
import javafx.application.Preloader;
import javafx.application.Preloader.ErrorNotification;
import javafx.application.Preloader.PreloaderNotification;
import javafx.application.Preloader.StateChangeNotification;
import javafx.stage.Stage;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.Base64;
import java.util.Optional;
import com.sun.javafx.stage.StageHelper;


public class LauncherImpl {
    /**
     * When passed as launchMode to launchApplication, tells the method that
     * launchName is the name of the JavaFX application class to launch.
     */
    public static final String LAUNCH_MODE_CLASS = &quot;LM_CLASS&quot;;

    /**
     * When passed as launchMode to launchApplication, tells the method that
     * launchName is a path to a JavaFX application jar file to be launched.
     */
    public static final String LAUNCH_MODE_JAR = &quot;LM_JAR&quot;;

    /**
     * When passed as launchMode to launchApplication, tells the method that
     * launchName is the name of the JavaFX application class within a module
     * to be launched. Either the class name will be provided or the main class
     * will be defined in the module's descriptor.
     */
    public static final String LAUNCH_MODE_MODULE = &quot;LM_MODULE&quot;;

    // set to true to debug launch issues from Java launcher
    private static final boolean trace = false;

    // set system property javafx.verbose to true to make the launcher noisy
    private static final boolean verbose;

    private static final String MF_MAIN_CLASS = &quot;Main-Class&quot;;
    private static final String MF_JAVAFX_MAIN = &quot;JavaFX-Application-Class&quot;;
    private static final String MF_JAVAFX_PRELOADER = &quot;JavaFX-Preloader-Class&quot;;
    private static final String MF_JAVAFX_CLASS_PATH = &quot;JavaFX-Class-Path&quot;;
    private static final String MF_JAVAFX_ARGUMENT_PREFIX = &quot;JavaFX-Argument-&quot;;
    private static final String MF_JAVAFX_PARAMETER_NAME_PREFIX = &quot;JavaFX-Parameter-Name-&quot;;
    private static final String MF_JAVAFX_PARAMETER_VALUE_PREFIX = &quot;JavaFX-Parameter-Value-&quot;;

    // Set to true to simulate a slow download progress
    private static final boolean simulateSlowProgress = false;

    // Ensure that launchApplication method is only called once
    private static AtomicBoolean launchCalled = new AtomicBoolean(false);

    // Flag indicating that the toolkit has been started
    private static final AtomicBoolean toolkitStarted = new AtomicBoolean(false);

    // Exception found during launching
    private static volatile RuntimeException launchException = null;

    // The current preloader, used for notification in the standalone
    // launcher mode
    private static Preloader currentPreloader = null;

    // Saved preloader class from the launchApplicationWithArgs method (called
    // from the Java 8 launcher). It is used in the case where we call main,
    // which is turn calls into launchApplication.
    private static Class&lt;? extends Preloader&gt; savedPreloaderClass = null;

    // The following is used to determine whether the main() method
    // has set the CCL in the case where main is called after the FX toolkit
    // is started.
    private static ClassLoader savedMainCcl = null;

    static {
        verbose = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
                Boolean.getBoolean(&quot;javafx.verbose&quot;));
    }

    /**
     * This method is called by the Application.launch method.
     * It must not be called more than once or an exception will be thrown.
     *
     * Note that it is always called on a thread other than the FX application
     * thread, since that thread is only created at startup.
     *
     * @param appClass application class
     * @param args command line arguments
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void launchApplication(final Class&lt;? extends Application&gt; appClass,
            final String[] args) {

        Class&lt;? extends Preloader&gt; preloaderClass = savedPreloaderClass;

        if (preloaderClass == null) {
            String preloaderByProperty = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
                    System.getProperty(&quot;javafx.preloader&quot;));
            if (preloaderByProperty != null) {
                try {
                    preloaderClass = (Class&lt;? extends Preloader&gt;) Class.forName(preloaderByProperty,
                            false, appClass.getClassLoader());
                } catch (Exception e) {
                    System.err.printf(&quot;Could not load preloader class '&quot; + preloaderByProperty +
                            &quot;', continuing without preloader.&quot;);
                    e.printStackTrace();
                }
            }
        }

        launchApplication(appClass, preloaderClass, args);
    }

    /**
     * This method is called by the standalone launcher.
     * It must not be called more than once or an exception will be thrown.
     *
     * Note that it is always called on a thread other than the FX application
     * thread, since that thread is only created at startup.
     *
     * @param appClass application class
     * @param preloaderClass preloader class, may be null
     * @param args command line arguments
     */
    public static void launchApplication(final Class&lt;? extends Application&gt; appClass,
            final Class&lt;? extends Preloader&gt; preloaderClass,
            final String[] args) {

        if (launchCalled.getAndSet(true)) {
            throw new IllegalStateException(&quot;Application launch must not be called more than once&quot;);
        }

        if (! Application.class.isAssignableFrom(appClass)) {
            throw new IllegalArgumentException(&quot;Error: &quot; + appClass.getName()
                    + &quot; is not a subclass of javafx.application.Application&quot;);
        }

        if (preloaderClass != null &amp;&amp; ! Preloader.class.isAssignableFrom(preloaderClass)) {
            throw new IllegalArgumentException(&quot;Error: &quot; + preloaderClass.getName()
                    + &quot; is not a subclass of javafx.application.Preloader&quot;);
        }

//        System.err.println(&quot;launch standalone app: preloader class = &quot;
//                + preloaderClass);

        // Create a new Launcher thread and then wait for that thread to finish
        final CountDownLatch launchLatch = new CountDownLatch(1);
        Thread launcherThread = new Thread(() -&gt; {
            try {
                launchApplication1(appClass, preloaderClass, args);
            } catch (RuntimeException rte) {
                launchException = rte;
            } catch (Exception ex) {
                launchException =
                    new RuntimeException(&quot;Application launch exception&quot;, ex);
            } catch (Error err) {
                launchException =
                    new RuntimeException(&quot;Application launch error&quot;, err);
            } finally {
                launchLatch.countDown();
            }
        });
        launcherThread.setName(&quot;JavaFX-Launcher&quot;);
        launcherThread.start();

        // Wait for FX launcher thread to finish before returning to user
        try {
            launchLatch.await();
        } catch (InterruptedException ex) {
            throw new RuntimeException(&quot;Unexpected exception: &quot;, ex);
        }

        if (launchException != null) {
            throw launchException;
        }
    }

    /**
     * This method is called by the Java launcher. This allows us to be launched
     * directly from the command line via &quot;java -jar fxapp.jar&quot;,
     * &quot;java -cp path some.fx.App&quot;, or &quot;java -m module/some.fx.App&quot;. The launchMode
     * argument must be one of &quot;LM_CLASS&quot;, &quot;LM_JAR&quot;, or &quot;LM_MODULE&quot; or execution will
     * abort with an error.
     *
     * @param launchName The path to a jar file, the application class name to launch,
     * or the module and optional class name to launch
     * @param launchMode The method of launching the application, one of LM_JAR,
     * LM_CLASS, or LM_MODULE
     * @param args Application arguments from the command line
     */
    public static void launchApplication(final String launchName,
            final String launchMode,
            final String[] args) {

        if (verbose) {
            System.err.println(&quot;JavaFX launchApplication method: launchMode=&quot;
                    + launchMode);
        }

        /*
         * For now, just open the jar and get JavaFX-Application-Class and
         * JavaFX-Preloader and pass them to launchApplication. In the future
         * we'll need to load requested jar files
         */
        String mainClassName = null;
        String preloaderClassName = null;
        String[] appArgs = args;
        ClassLoader appLoader = null;
        ModuleAccess mainModule = null;

        if (launchMode.equals(LAUNCH_MODE_JAR)) {
            Attributes jarAttrs = getJarAttributes(launchName);
            if (jarAttrs == null) {
                abort(null, &quot;Can't get manifest attributes from jar&quot;);
            }

            // If we ever need to check JavaFX-Version, do that here...

            // Support JavaFX-Class-Path, but warn that it's deprecated if used
            String fxClassPath = jarAttrs.getValue(MF_JAVAFX_CLASS_PATH);
            if (fxClassPath != null) {
                if (fxClassPath.trim().length() == 0) {
                    fxClassPath = null;
                } else {
                    if (verbose) {
                        System.err.println(&quot;WARNING: Application jar uses deprecated JavaFX-Class-Path attribute.&quot;
                               +&quot; Please use Class-Path instead.&quot;);
                    }

                    /*
                     * create a new ClassLoader to pull in the requested jar files
                     * OK if it returns null, that just means we didn't need to load
                     * anything
                     */
                    appLoader = setupJavaFXClassLoader(new File(launchName), fxClassPath);
                }
            }

            // process arguments and parameters if no args have been passed by the launcher
            if (args.length == 0) {
                appArgs = getAppArguments(jarAttrs);
            }

            // grab JavaFX-Application-Class
            mainClassName = jarAttrs.getValue(MF_JAVAFX_MAIN);
            if (mainClassName == null) {
                // fall back on Main-Class if no JAC
                mainClassName = jarAttrs.getValue(MF_MAIN_CLASS);
                if (mainClassName == null) {
                    // Should not happen as the launcher enforces the presence of Main-Class
                    abort(null, &quot;JavaFX jar manifest requires a valid JavaFX-Appliation-Class or Main-Class entry&quot;);
                }
            }
            mainClassName = mainClassName.trim();

            // grab JavaFX-Preloader-Class
            preloaderClassName = jarAttrs.getValue(MF_JAVAFX_PRELOADER);
            if (preloaderClassName != null) {
                preloaderClassName = preloaderClassName.trim();
            }
        } else if (launchMode.equals(LAUNCH_MODE_CLASS)) {
            mainClassName = launchName;
        } else if (launchMode.equals(LAUNCH_MODE_MODULE)) {
            // This is largely copied from java.base/sun.launcher.LauncherHelper
            int i = launchName.indexOf('/');
            String moduleName;
            if (i == -1) {
                moduleName = launchName;
                mainClassName = null;
            } else {
                moduleName = launchName.substring(0, i);
                mainClassName = launchName.substring(i+1);
            }

            mainModule = ModuleAccess.load(moduleName);

            // get main class from module descriptor
            if (mainClassName == null) {
                Optional&lt;String&gt; omc = mainModule.getDescriptor().mainClass();
                if (!omc.isPresent()) {
                    abort(null, &quot;Module %1$s does not have a MainClass attribute, use -m &lt;module&gt;/&lt;main-class&gt;&quot;,
                            moduleName);
                }
                mainClassName = omc.get();
            }
        } else {
            abort(new IllegalArgumentException(
                    &quot;The launchMode argument must be one of LM_CLASS, LM_JAR or LM_MODULE&quot;),
                    &quot;Invalid launch mode: %1$s&quot;, launchMode);
        }

        // fall back if no MF_JAVAFX_PRELOADER attribute, or not launching using -jar
        if (preloaderClassName == null) {
            preloaderClassName = System.getProperty(&quot;javafx.preloader&quot;);
        }

        if (mainClassName == null) {
            abort(null, &quot;No main JavaFX class to launch&quot;);
        }

        // check if we have to load through a custom classloader
        if (appLoader != null) {
            try {
                // reload this class through the app classloader
                Class&lt;?&gt; launcherClass = appLoader.loadClass(LauncherImpl.class.getName());

                // then invoke the second part of this launcher using reflection
                Method lawa = launcherClass.getMethod(&quot;launchApplicationWithArgs&quot;,
                        new Class[] { ModuleAccess.class, String.class, String.class, (new String[0]).getClass()});

                // set the thread context class loader before we continue, or it won't load properly
                Thread.currentThread().setContextClassLoader(appLoader);
                lawa.invoke(null, new Object[] {null, mainClassName, preloaderClassName, appArgs});
            } catch (Exception e) {
                abort(e, &quot;Exception while launching application&quot;);
            }
        } else {
            launchApplicationWithArgs(mainModule, mainClassName, preloaderClassName, appArgs);
        }
    }

    // wrapper for Class.forName that handles cases where diacritical marks in the name
    // cause the class to not be loaded, also largely copied from LauncherHelper.java
    // this method returns null if the class cannot be loaded
    private static Class&lt;?&gt; loadClass(final ModuleAccess mainModule, final String className) {
        Class&lt;?&gt; clz = null;
        final ClassLoader loader = Thread.currentThread().getContextClassLoader();

        // loader is ignored for modular mode
        // the only time we need to use a separate loader is LM_JAR with
        // a MF_JAVAFX_CLASS_PATH attribute which is deprecated

        if (mainModule != null) {
            clz = mainModule.classForName(className);
        } else {
            try {
                clz = Class.forName(className, true, loader);
            } catch (ClassNotFoundException | NoClassDefFoundError cnfe) {}
        }

        if (clz == null &amp;&amp; System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
                    &amp;&amp; Normalizer.isNormalized(className, Normalizer.Form.NFD)) {
            // macOS may have decomposed diacritical marks in mainClassName
            // recompose them and try again
            String cn = Normalizer.normalize(className, Normalizer.Form.NFC);

            if (mainModule != null) {
                clz = mainModule.classForName(cn);
            } else {
                try {
                    clz = Class.forName(cn, true, loader);
                } catch (ClassNotFoundException | NoClassDefFoundError cnfe) {}
            }
        }

        return clz;
    }

    // Must be public since we could be called from a different class loader
    public static void launchApplicationWithArgs(final ModuleAccess mainModule,
            final String mainClassName,
            final String preloaderClassName, String[] args) {
        try {
            startToolkit();
        } catch (InterruptedException ex) {
            abort(ex, &quot;Toolkit initialization error&quot;, mainClassName);
        }

        Class&lt;? extends Application&gt; appClass;
        Class&lt;? extends Preloader&gt; preClass = null;
        Class&lt;?&gt; tempAppClass = null;

        final AtomicReference&lt;Class&lt;?&gt;&gt; tmpClassRef = new AtomicReference&lt;&gt;();
        final AtomicReference&lt;Class&lt;? extends Preloader&gt;&gt; preClassRef = new AtomicReference&lt;&gt;();
        PlatformImpl.runAndWait(() -&gt; {
            Class&lt;?&gt; clz = loadClass(mainModule, mainClassName);
            if (clz == null) {
                if (mainModule != null) {
                    abort(null, &quot;Missing JavaFX application class %1$s in module %2$s&quot;,
                            mainClassName, mainModule.getName());
                } else {
                    abort(null, &quot;Missing JavaFX application class %1$s&quot;, mainClassName);
                }
            }

            tmpClassRef.set(clz);

            if (preloaderClassName != null) {
                // TODO: modular preloader?
                clz = loadClass(null, preloaderClassName);
                if (clz == null) {
                    abort(null, &quot;Missing JavaFX preloader class %1$s&quot;, preloaderClassName);
                }

                if (!Preloader.class.isAssignableFrom(clz)) {
                    abort(null, &quot;JavaFX preloader class %1$s does not extend javafx.application.Preloader&quot;, clz.getName());
                }
                preClassRef.set(clz.asSubclass(Preloader.class));
            }
        });
        preClass = preClassRef.get();
        tempAppClass = tmpClassRef.get();

        // Save the preloader class in a static field for later use when
        // main calls back into launchApplication.
        savedPreloaderClass = preClass;

        // If there is a public static void main(String[]) method then call it
        // otherwise just hand off to the other launchApplication method

        Exception theEx = null;
        try {
            Method mainMethod = tempAppClass.getMethod(&quot;main&quot;,
                    new Class[] { (new String[0]).getClass() });
            if (verbose) {
                System.err.println(&quot;Calling main(String[]) method&quot;);
            }
            savedMainCcl = Thread.currentThread().getContextClassLoader();
            mainMethod.invoke(null, new Object[] { args });
            return;
        } catch (NoSuchMethodException | IllegalAccessException ex) {
            theEx = ex;
            savedPreloaderClass = null;
            if (verbose) {
                System.err.println(&quot;WARNING: Cannot access application main method: &quot; + ex);
            }
        } catch (InvocationTargetException ex) {
            ex.printStackTrace();
            abort(null, &quot;Exception running application %1$s&quot;, tempAppClass.getName());
            return;
        }

        // Verify appClass extends Application
        if (!Application.class.isAssignableFrom(tempAppClass)) {
            abort(theEx, &quot;JavaFX application class %1$s does not extend javafx.application.Application&quot;, tempAppClass.getName());
        }
        appClass = tempAppClass.asSubclass(Application.class);

        if (verbose) {
            System.err.println(&quot;Launching application directly&quot;);
        }
        launchApplication(appClass, preClass, args);
    }

    private static URL fileToURL(File file) throws IOException {
        return file.getCanonicalFile().toURI().toURL();
    }

    private static ClassLoader setupJavaFXClassLoader(File appJar, String fxClassPath) {
        try {
            File baseDir = appJar.getParentFile();
            ArrayList jcpList = new ArrayList();

            // Add in the jars from the JavaFX-Class-Path entry
            // TODO: should check current classpath for duplicate entries and ignore them
            String cp = fxClassPath;
            if (cp != null) {
                // these paths are relative to baseDir, which should be the
                // directory containing the app jar file
                while (cp.length() &gt; 0) {
                    int pathSepIdx = cp.indexOf(&quot; &quot;);
                    if (pathSepIdx &lt; 0) {
                        String pathElem = cp;
                        File f = (baseDir == null) ?
                                new File(pathElem) : new File(baseDir, pathElem);
                        if (f.exists()) {
                            jcpList.add(fileToURL(f));
                        } else if (verbose) {
                            System.err.println(&quot;Class Path entry \&quot;&quot;+pathElem
                                    +&quot;\&quot; does not exist, ignoring&quot;);
                        }
                        break;
                    } else if (pathSepIdx &gt; 0) {
                        String pathElem = cp.substring(0, pathSepIdx);
                        File f = (baseDir == null) ?
                                new File(pathElem) : new File(baseDir, pathElem);
                        if (f.exists()) {
                            jcpList.add(fileToURL(f));
                        } else if (verbose) {
                            System.err.println(&quot;Class Path entry \&quot;&quot;+pathElem
                                    +&quot;\&quot; does not exist, ignoring&quot;);
                        }
                    }
                    cp = cp.substring(pathSepIdx + 1);
                }
            }

            // don't bother if there's nothing to add
            if (!jcpList.isEmpty()) {
                ArrayList&lt;URL&gt; urlList = new ArrayList&lt;URL&gt;();

                // prepend the existing classpath
                // this will already have the app jar, so no need to worry about it
                cp = System.getProperty(&quot;java.class.path&quot;);
                if (cp != null) {
                    while (cp.length() &gt; 0) {
                        int pathSepIdx = cp.indexOf(File.pathSeparatorChar);
                        if (pathSepIdx &lt; 0) {
                            String pathElem = cp;
                            urlList.add(fileToURL(new File(pathElem)));
                            break;
                        } else if (pathSepIdx &gt; 0) {
                            String pathElem = cp.substring(0, pathSepIdx);
                            urlList.add(fileToURL(new File(pathElem)));
                        }
                        cp = cp.substring(pathSepIdx + 1);
                    }
                }

                // and finally append the JavaFX-Class-Path entries
                urlList.addAll(jcpList);

                URL[] urls = (URL[])urlList.toArray(new URL[0]);
                if (verbose) {
                    System.err.println(&quot;===== URL list&quot;);
                    for (int i = 0; i &lt; urls.length; i++) {
                        System.err.println(&quot;&quot; + urls[i]);
                    }
                    System.err.println(&quot;=====&quot;);
                }
                return new URLClassLoader(urls, ClassLoader.getPlatformClassLoader());
            }
        } catch (Exception ex) {
            if (trace) {
                System.err.println(&quot;Exception creating JavaFX class loader: &quot;+ex);
                ex.printStackTrace();
            }
        }
        return null;
    }

    private static String decodeBase64(String inp) throws IOException {
        return new String(Base64.getDecoder().decode(inp));
    }

    private static String[] getAppArguments(Attributes attrs) {
        List args = new LinkedList();

        try {
            int idx = 1;
            String argNamePrefix = MF_JAVAFX_ARGUMENT_PREFIX;
            while (attrs.getValue(argNamePrefix + idx) != null) {
                args.add(decodeBase64(attrs.getValue(argNamePrefix + idx)));
                idx++;
            }

            String paramNamePrefix = MF_JAVAFX_PARAMETER_NAME_PREFIX;
            String paramValuePrefix = MF_JAVAFX_PARAMETER_VALUE_PREFIX;
            idx = 1;
            while (attrs.getValue(paramNamePrefix + idx) != null) {
                String k = decodeBase64(attrs.getValue(paramNamePrefix + idx));
                String v = null;
                if (attrs.getValue(paramValuePrefix + idx) != null) {
                    v = decodeBase64(attrs.getValue(paramValuePrefix + idx));
                }
                args.add(&quot;--&quot; + k + &quot;=&quot; + (v != null ? v : &quot;&quot;));
                idx++;
            }
        } catch (IOException ioe) {
            if (verbose) {
                System.err.println(&quot;Failed to extract application parameters&quot;);
            }
            ioe.printStackTrace();
        }

        return (String[]) args.toArray(new String[0]);
    }

    // FIXME: needs localization, since these are presented to the user
    private static void abort(final Throwable cause, final String fmt, final Object... args) {
        String msg = String.format(fmt, args);
        if (msg != null) {
            System.err.println(msg);
        }

        if (trace) {
            if (cause != null) {
                cause.printStackTrace();
            } else {
                Thread.dumpStack();
            }
        }
        System.exit(1);
    }

    private static Attributes getJarAttributes(String jarPath) {
        JarFile jarFile = null;
        try {
            jarFile = new JarFile(jarPath);
            Manifest manifest = jarFile.getManifest();
            if (manifest == null) {
                abort(null, &quot;No manifest in jar file %1$s&quot;, jarPath);
            }
            return manifest.getMainAttributes();
        } catch (IOException ioe) {
            abort(ioe, &quot;Error launching jar file %1%s&quot;, jarPath);
        } finally {
            try {
                jarFile.close();
            } catch (IOException ioe) {}
        }
        return null;
    }

    private static void startToolkit() throws InterruptedException {
        if (toolkitStarted.getAndSet(true)) {
            return;
        }

        final CountDownLatch startupLatch = new CountDownLatch(1);

        // Note, this method is called on the FX Application Thread
        PlatformImpl.startup(() -&gt; startupLatch.countDown());

        // Wait for FX platform to start
        startupLatch.await();
    }

    private static volatile boolean error = false;
    private static volatile Throwable pConstructorError = null;
    private static volatile Throwable pInitError = null;
    private static volatile Throwable pStartError = null;
    private static volatile Throwable pStopError = null;
    private static volatile Throwable constructorError = null;
    private static volatile Throwable initError = null;
    private static volatile Throwable startError = null;
    private static volatile Throwable stopError = null;

    private static void launchApplication1(final Class&lt;? extends Application&gt; appClass,
            final Class&lt;? extends Preloader&gt; preloaderClass,
            final String[] args) throws Exception {

        startToolkit();

        if (savedMainCcl != null) {
            /*
             * The toolkit was already started by the java launcher, and the
             * main method of the application class was called. Check to see
             * whether the CCL has been changed. If so, then we need
             * to pass the context class loader to the FX app thread so that it
             * correctly picks up the current setting.
             */
            final ClassLoader ccl = Thread.currentThread().getContextClassLoader();
            if (ccl != null &amp;&amp; ccl != savedMainCcl) {
                PlatformImpl.runLater(() -&gt; {
                    Thread.currentThread().setContextClassLoader(ccl);
                });
            }
        }

        final AtomicBoolean pStartCalled = new AtomicBoolean(false);
        final AtomicBoolean startCalled = new AtomicBoolean(false);
        final AtomicBoolean exitCalled = new AtomicBoolean(false);
        final AtomicBoolean pExitCalled = new AtomicBoolean(false);
        final CountDownLatch shutdownLatch = new CountDownLatch(1);
        final CountDownLatch pShutdownLatch = new CountDownLatch(1);

        final PlatformImpl.FinishListener listener = new PlatformImpl.FinishListener() {
            @Override public void idle(boolean implicitExit) {
                if (!implicitExit) {
                    return;
                }

//                System.err.println(&quot;JavaFX Launcher: system is idle&quot;);
                if (startCalled.get()) {
                    shutdownLatch.countDown();
                } else if (pStartCalled.get()) {
                    pShutdownLatch.countDown();
                }
            }

            @Override public void exitCalled() {
//                System.err.println(&quot;JavaFX Launcher: received exit notification&quot;);
                exitCalled.set(true);
                shutdownLatch.countDown();
            }
        };
        PlatformImpl.addListener(listener);

        try {
            final AtomicReference&lt;Preloader&gt; pldr = new AtomicReference&lt;&gt;();
            if (preloaderClass != null) {
                // Construct an instance of the preloader on the FX thread, then
                // call its init method on this (launcher) thread. Then call
                // the start method on the FX thread.
<A NAME="11"></A>                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        Constructor&lt;? extends Preloader&gt; c = preloaderClass.getConstructor();
                        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#11',2,'match45-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>pldr.set(c.newInstance());
                        // Set startup parameters
                        ParametersImpl.registerParameters(pldr.get(), new ParametersImpl(args));
                    } catch (Throwable t) {
                        System.err.println</B></FONT>(&quot;Exception in Preloader constructor&quot;);
                        pConstructorError = t;
                        error = true;
                    }
                });
            }
            currentPreloader = pldr.get();

            // Call init method unless exit called or error detected
            if (currentPreloader != null &amp;&amp; !error &amp;&amp; !exitCalled.get()) {
                try {
                    // Call the application init method (on the Launcher thread)
                    currentPreloader.init();
                } catch (Throwable t) {
                    System.err.println(&quot;Exception in Preloader init method&quot;);
                    pInitError = t;
                    error = true;
                }
            }

            // Call start method unless exit called or error detected
            if (currentPreloader != null &amp;&amp; !error &amp;&amp; !exitCalled.get()) {
                // Call the application start method on FX thread
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        pStartCalled.set(true);

                        // Create primary stage and call preloader start method
                        final Stage primaryStage = new Stage();
                        StageHelper.setPrimary(primaryStage, true);
                        currentPreloader.start(primaryStage);
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Preloader start method&quot;);
                        pStartError = t;
                        error = true;
                    }
                });

                // Notify preloader of progress
                if (!error &amp;&amp; !exitCalled.get()) {
                    notifyProgress(currentPreloader, 0.0);
                }
            }

            // Construct an instance of the application on the FX thread, then
            // call its init method on this (launcher) thread. Then call
            // the start method on the FX thread.
            final AtomicReference&lt;Application&gt; app = new AtomicReference&lt;&gt;();
            if (!error &amp;&amp; !exitCalled.get()) {
                if (currentPreloader != null) {
                    if (simulateSlowProgress) {
                        for (int i = 0; i &lt; 100; i++) {
                            notifyProgress(currentPreloader, (double)i / 100.0);
                            Thread.sleep(10);
                        }
                    }
                    notifyProgress(currentPreloader, 1.0);
                    notifyStateChange(currentPreloader,
                            StateChangeNotification.Type.BEFORE_LOAD, null);
                }

                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        Constructor&lt;? extends Application&gt; c = appClass.getConstructor();
                        app.set(c.newInstance());
                        // Set startup parameters
                        ParametersImpl.registerParameters(app.get(), new ParametersImpl(args));
                        PlatformImpl.setApplicationName(appClass);
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Application constructor&quot;);
                        constructorError = t;
                        error = true;
                    }
                });
            }
            final Application theApp = app.get();

            // Call init method unless exit called or error detected
            if (!error &amp;&amp; !exitCalled.get()) {
                if (currentPreloader != null) {
                    notifyStateChange(currentPreloader,
                            StateChangeNotification.Type.BEFORE_INIT, theApp);
                }

                try {
                    // Call the application init method (on the Launcher thread)
                    theApp.init();
                } catch (Throwable t) {
                    System.err.println(&quot;Exception in Application init method&quot;);
                    initError = t;
                    error = true;
                }
            }

            // Call start method unless exit called or error detected
            if (!error &amp;&amp; !exitCalled.get()) {
                if (currentPreloader != null) {
                    notifyStateChange(currentPreloader,
                            StateChangeNotification.Type.BEFORE_START, theApp);
                }
                // Call the application start method on FX thread
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        startCalled.set(true);

                        // Create primary stage and call application start method
                        final Stage primaryStage = new Stage();
                        StageHelper.setPrimary(primaryStage, true);
                        theApp.start(primaryStage);
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Application start method&quot;);
                        startError = t;
                        error = true;
                    }
                });
            }

            if (!error) {
                shutdownLatch.await();
//                System.err.println(&quot;JavaFX Launcher: time to call stop&quot;);
            }

            // Call stop method if start was called
            if (startCalled.get()) {
                // Call Application stop method on FX thread
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        theApp.stop();
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Application stop method&quot;);
                        stopError = t;
                        error = true;
                    }
                });
            }

            if (error) {
                if (pConstructorError != null) {
                    throw new RuntimeException(&quot;Unable to construct Preloader instance: &quot;
                            + appClass, pConstructorError);
                } else if (pInitError != null) {
                    throw new RuntimeException(&quot;Exception in Preloader init method&quot;,
                            pInitError);
                } else if(pStartError != null) {
                    throw new RuntimeException(&quot;Exception in Preloader start method&quot;,
                            pStartError);
                } else if (pStopError != null) {
                    throw new RuntimeException(&quot;Exception in Preloader stop method&quot;,
                            pStopError);
                } else if (constructorError != null) {
                    String msg = &quot;Unable to construct Application instance: &quot; + appClass;
                    if (!notifyError(msg, constructorError)) {
                        throw new RuntimeException(msg, constructorError);
                    }
                } else if (initError != null) {
                    String msg = &quot;Exception in Application init method&quot;;
                    if (!notifyError(msg, initError)) {
                        throw new RuntimeException(msg, initError);
                    }
                } else if(startError != null) {
                    String msg = &quot;Exception in Application start method&quot;;
                    if (!notifyError(msg, startError)) {
                        throw new RuntimeException(msg, startError);
                    }
                } else if (stopError != null) {
                    String msg = &quot;Exception in Application stop method&quot;;
                    if (!notifyError(msg, stopError)) {
                        throw new RuntimeException(msg, stopError);
                    }
                }
            }
        } finally {
            PlatformImpl.removeListener(listener);
            PlatformImpl.tkExit();
        }
    }

    private static void notifyStateChange(final Preloader preloader,
            final StateChangeNotification.Type type,
            final Application app) {

        PlatformImpl.runAndWait(() -&gt; preloader.handleStateChangeNotification(
            new StateChangeNotification(type, app)));
    }

    private static void notifyProgress(final Preloader preloader, final double d) {
        PlatformImpl.runAndWait(() -&gt; preloader.handleProgressNotification(
                new Preloader.ProgressNotification(d)));
    }

    private static boolean notifyError(final String msg, final Throwable constructorError) {
        final AtomicBoolean result = new AtomicBoolean(false);
        PlatformImpl.runAndWait(() -&gt; {
            if (currentPreloader != null) {
                try {
                    ErrorNotification evt = new ErrorNotification(null, msg, constructorError);
                    boolean rval = currentPreloader.handleErrorNotification(evt);
                    result.set(rval);
                } catch (Throwable t) {
                    t.printStackTrace();
                }
            }
        });

        return result.get();
    }

    private static void notifyCurrentPreloader(final PreloaderNotification pe) {
        PlatformImpl.runAndWait(() -&gt; {
            if (currentPreloader != null) {
                currentPreloader.handleApplicationNotification(pe);
            }
        });
    }

    public static void notifyPreloader(Application app, final PreloaderNotification info) {
        if (launchCalled.get()) {
            // Standalone launcher mode
            notifyCurrentPreloader(info);
            return;
        }
    }

    // Not an instantiable class.
    private LauncherImpl() {
        // Should never get here.
        throw new InternalError();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/Area.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom;

import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.util.Vector;
import com.sun.javafx.geom.transform.BaseTransform;


/**
 * An &lt;code&gt;Area&lt;/code&gt; object stores and manipulates a
 * resolution-independent description of an enclosed area of
 * 2-dimensional space.
 * &lt;code&gt;Area&lt;/code&gt; objects can be transformed and can perform
 * various Constructive Area Geometry (CAG) operations when combined
 * with other &lt;code&gt;Area&lt;/code&gt; objects.
 * The CAG operations include area
 * {@link #add addition}, {@link #subtract subtraction},
 * {@link #intersect intersection}, and {@link #exclusiveOr exclusive or}.
 * See the linked method documentation for examples of the various
 * operations.
 * &lt;p&gt;
 * The &lt;code&gt;Area&lt;/code&gt; class implements the &lt;code&gt;Shape&lt;/code&gt;
 * interface and provides full support for all of its hit-testing
 * and path iteration facilities, but an &lt;code&gt;Area&lt;/code&gt; is more
 * specific than a generalized path in a number of ways:
 * &lt;ul&gt;
 * &lt;li&gt;Only closed paths and sub-paths are stored.
 *     &lt;code&gt;Area&lt;/code&gt; objects constructed from unclosed paths
 *     are implicitly closed during construction as if those paths
 *     had been filled by the &lt;code&gt;Graphics2D.fill&lt;/code&gt; method.
 * &lt;li&gt;The interiors of the individual stored sub-paths are all
 *     non-empty and non-overlapping.  Paths are decomposed during
 *     construction into separate component non-overlapping parts,
 *     empty pieces of the path are discarded, and then these
 *     non-empty and non-overlapping properties are maintained
 *     through all subsequent CAG operations.  Outlines of different
 *     component sub-paths may touch each other, as long as they
 *     do not cross so that their enclosed areas overlap.
 * &lt;li&gt;The geometry of the path describing the outline of the
 *     &lt;code&gt;Area&lt;/code&gt; resembles the path from which it was
 *     constructed only in that it describes the same enclosed
 *     2-dimensional area, but may use entirely different types
 *     and ordering of the path segments to do so.
 * &lt;/ul&gt;
 * Interesting issues which are not always obvious when using
 * the &lt;code&gt;Area&lt;/code&gt; include:
 * &lt;ul&gt;
 * &lt;li&gt;Creating an &lt;code&gt;Area&lt;/code&gt; from an unclosed (open)
 *     &lt;code&gt;Shape&lt;/code&gt; results in a closed outline in the
 *     &lt;code&gt;Area&lt;/code&gt; object.
 * &lt;li&gt;Creating an &lt;code&gt;Area&lt;/code&gt; from a &lt;code&gt;Shape&lt;/code&gt;
 *     which encloses no area (even when &quot;closed&quot;) produces an
 *     empty &lt;code&gt;Area&lt;/code&gt;.  A common example of this issue
 *     is that producing an &lt;code&gt;Area&lt;/code&gt; from a line will
 *     be empty since the line encloses no area.  An empty
 *     &lt;code&gt;Area&lt;/code&gt; will iterate no geometry in its
 *     &lt;code&gt;PathIterator&lt;/code&gt; objects.
 * &lt;li&gt;A self-intersecting &lt;code&gt;Shape&lt;/code&gt; may be split into
 *     two (or more) sub-paths each enclosing one of the
 *     non-intersecting portions of the original path.
 * &lt;li&gt;An &lt;code&gt;Area&lt;/code&gt; may take more path segments to
 *     describe the same geometry even when the original
 *     outline is simple and obvious.  The analysis that the
 *     &lt;code&gt;Area&lt;/code&gt; class must perform on the path may
 *     not reflect the same concepts of &quot;simple and obvious&quot;
 *     as a human being perceives.
 * &lt;/ul&gt;
 */
public class Area extends Shape {

    private static final Vector EmptyCurves = new Vector();

    private Vector curves;

    /**
     * Default constructor which creates an empty area.
     */
    public Area() {
        curves = EmptyCurves;
    }

    /**
     * The &lt;code&gt;Area&lt;/code&gt; class creates an area geometry from the
     * specified {@link Shape} object.  The geometry is explicitly
     * closed, if the &lt;code&gt;Shape&lt;/code&gt; is not already closed.  The
     * fill rule (even-odd or winding) specified by the geometry of the
     * &lt;code&gt;Shape&lt;/code&gt; is used to determine the resulting enclosed area.
     * @param s  the &lt;code&gt;Shape&lt;/code&gt; from which the area is constructed
     * @throws NullPointerException if &lt;code&gt;s&lt;/code&gt; is null
     */
    public Area(Shape s) {
        if (s instanceof Area) {
            curves = ((Area) s).curves;
        } else {
            curves = pathToCurves(s.getPathIterator(null));
        }
    }

    public Area(PathIterator iter) {
        curves = pathToCurves(iter);
    }

    private static Vector pathToCurves(PathIterator pi) {
        Vector curves = new Vector();
        int windingRule = pi.getWindingRule();
        // coords array is big enough for holding:
        //     coordinates returned from currentSegment (6)
        //     OR
        //         two subdivided quadratic curves (2+4+4=10)
        //         AND
        //             0-1 horizontal splitting parameters
        //             OR
        //             2 parametric equation derivative coefficients
        //     OR
        //         three subdivided cubic curves (2+6+6+6=20)
        //         AND
        //             0-2 horizontal splitting parameters
        //             OR
        //             3 parametric equation derivative coefficients
        float coords[] = new float[6];
        double tmp[] = new double[23];
        double movx = 0, movy = 0;
        double curx = 0, cury = 0;
        double newx, newy;
        while (!pi.isDone()) {
            switch (pi.currentSegment(coords)) {
            case PathIterator.SEG_MOVETO:
                Curve.insertLine(curves, curx, cury, movx, movy);
                curx = movx = coords[0];
                cury = movy = coords[1];
                Curve.insertMove(curves, movx, movy);
                break;
            case PathIterator.SEG_LINETO:
                newx = coords[0];
                newy = coords[1];
                Curve.insertLine(curves, curx, cury, newx, newy);
                curx = newx;
                cury = newy;
                break;
            case PathIterator.SEG_QUADTO:
                newx = coords[2];
                newy = coords[3];
                Curve.insertQuad(curves, tmp,
                                 curx, cury,
                                 coords[0], coords[1],
                                 coords[2], coords[3]);
                curx = newx;
                cury = newy;
                break;
            case PathIterator.SEG_CUBICTO:
                newx = coords[4];
                newy = coords[5];
                Curve.insertCubic(curves, tmp,
                                  curx, cury,
                                  coords[0], coords[1],
                                  coords[2], coords[3],
                                  coords[4], coords[5]);
                curx = newx;
                cury = newy;
                break;
            case PathIterator.SEG_CLOSE:
                Curve.insertLine(curves, curx, cury, movx, movy);
                curx = movx;
                cury = movy;
                break;
            }
            pi.next();
        }
        Curve.insertLine(curves, curx, cury, movx, movy);
        AreaOp operator;
        if (windingRule == PathIterator.WIND_EVEN_ODD) {
            operator = new AreaOp.EOWindOp();
        } else {
            operator = new AreaOp.NZWindOp();
        }
        return operator.calculate(curves, EmptyCurves);
    }

    /**
     * Adds the shape of the specified &lt;code&gt;Area&lt;/code&gt; to the
     * shape of this &lt;code&gt;Area&lt;/code&gt;.
     * The resulting shape of this &lt;code&gt;Area&lt;/code&gt; will include
     * the union of both shapes, or all areas that were contained
     * in either this or the specified &lt;code&gt;Area&lt;/code&gt;.
     * &lt;pre&gt;
     *     // Example:
     *     Area a1 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 0,8]);
     *     Area a2 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 8,8]);
     *     a1.add(a2);
     *
     *        a1(before)     +         a2         =     a1(after)
     *
     *     ################     ################     ################
     *     ##############         ##############     ################
     *     ############             ############     ################
     *     ##########                 ##########     ################
     *     ########                     ########     ################
     *     ######                         ######     ######    ######
     *     ####                             ####     ####        ####
     *     ##                                 ##     ##            ##
     * &lt;/pre&gt;
     * @param   rhs  the &lt;code&gt;Area&lt;/code&gt; to be added to the
     *          current shape
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public void add(Area rhs) {
        curves = new AreaOp.AddOp().calculate(this.curves, rhs.curves);
        invalidateBounds();
    }

    /**
     * Subtracts the shape of the specified &lt;code&gt;Area&lt;/code&gt; from the
     * shape of this &lt;code&gt;Area&lt;/code&gt;.
     * The resulting shape of this &lt;code&gt;Area&lt;/code&gt; will include
     * areas that were contained only in this &lt;code&gt;Area&lt;/code&gt;
     * and not in the specified &lt;code&gt;Area&lt;/code&gt;.
     * &lt;pre&gt;
     *     // Example:
     *     Area a1 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 0,8]);
     *     Area a2 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 8,8]);
     *     a1.subtract(a2);
     *
     *        a1(before)     -         a2         =     a1(after)
     *
     *     ################     ################
     *     ##############         ##############     ##
     *     ############             ############     ####
     *     ##########                 ##########     ######
     *     ########                     ########     ########
     *     ######                         ######     ######
     *     ####                             ####     ####
     *     ##                                 ##     ##
     * &lt;/pre&gt;
     * @param   rhs  the &lt;code&gt;Area&lt;/code&gt; to be subtracted from the
     *          current shape
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public void subtract(Area rhs) {
        curves = new AreaOp.SubOp().calculate(this.curves, rhs.curves);
        invalidateBounds();
    }

    /**
     * Sets the shape of this &lt;code&gt;Area&lt;/code&gt; to the intersection of
     * its current shape and the shape of the specified &lt;code&gt;Area&lt;/code&gt;.
     * The resulting shape of this &lt;code&gt;Area&lt;/code&gt; will include
     * only areas that were contained in both this &lt;code&gt;Area&lt;/code&gt;
     * and also in the specified &lt;code&gt;Area&lt;/code&gt;.
     * &lt;pre&gt;
     *     // Example:
     *     Area a1 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 0,8]);
     *     Area a2 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 8,8]);
     *     a1.intersect(a2);
     *
     *      a1(before)   intersect     a2         =     a1(after)
     *
     *     ################     ################     ################
     *     ##############         ##############       ############
     *     ############             ############         ########
     *     ##########                 ##########           ####
     *     ########                     ########
     *     ######                         ######
     *     ####                             ####
     *     ##                                 ##
     * &lt;/pre&gt;
     * @param   rhs  the &lt;code&gt;Area&lt;/code&gt; to be intersected with this
     *          &lt;code&gt;Area&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public void intersect(Area rhs) {
        curves = new AreaOp.IntOp().calculate(this.curves, rhs.curves);
        invalidateBounds();
    }

    /**
     * Sets the shape of this &lt;code&gt;Area&lt;/code&gt; to be the combined area
     * of its current shape and the shape of the specified &lt;code&gt;Area&lt;/code&gt;,
     * minus their intersection.
     * The resulting shape of this &lt;code&gt;Area&lt;/code&gt; will include
     * only areas that were contained in either this &lt;code&gt;Area&lt;/code&gt;
     * or in the specified &lt;code&gt;Area&lt;/code&gt;, but not in both.
     * &lt;pre&gt;
     *     // Example:
     *     Area a1 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 0,8]);
     *     Area a2 = new Area([triangle 0,0 =&amp;gt; 8,0 =&amp;gt; 8,8]);
     *     a1.exclusiveOr(a2);
     *
     *        a1(before)    xor        a2         =     a1(after)
     *
     *     ################     ################
     *     ##############         ##############     ##            ##
     *     ############             ############     ####        ####
     *     ##########                 ##########     ######    ######
     *     ########                     ########     ################
     *     ######                         ######     ######    ######
     *     ####                             ####     ####        ####
     *     ##                                 ##     ##            ##
     * &lt;/pre&gt;
     * @param   rhs  the &lt;code&gt;Area&lt;/code&gt; to be exclusive ORed with this
     *          &lt;code&gt;Area&lt;/code&gt;.
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public void exclusiveOr(Area rhs) {
        curves = new AreaOp.XorOp().calculate(this.curves, rhs.curves);
        invalidateBounds();
    }

    /**
     * Removes all of the geometry from this &lt;code&gt;Area&lt;/code&gt; and
<A NAME="9"></A>     * restores it to an empty area.
     */
    public void reset() {
        <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#9',2,'match45-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>curves = new Vector();
        invalidateBounds();
    }

    /**
     * Tests whether this &lt;code&gt;Area&lt;/code&gt; object encloses any area.
     * @return    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Area&lt;/code&gt; object
     * represents an empty area; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isEmpty() {
        return (curves.size() == 0);
    }</B></FONT>

    /**
     * Tests whether this &lt;code&gt;Area&lt;/code&gt; consists entirely of
     * straight edged polygonal geometry.
     * @return    &lt;code&gt;true&lt;/code&gt; if the geometry of this
     * &lt;code&gt;Area&lt;/code&gt; consists entirely of line segments;
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isPolygonal() {
        Enumeration enum_ = curves.elements();
        while (enum_.hasMoreElements()) {
            if (((Curve) enum_.nextElement()).getOrder() &gt; 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Tests whether this &lt;code&gt;Area&lt;/code&gt; is rectangular in shape.
     * @return    &lt;code&gt;true&lt;/code&gt; if the geometry of this
     * &lt;code&gt;Area&lt;/code&gt; is rectangular in shape; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public boolean isRectangular() {
        int size = curves.size();
        if (size == 0) {
            return true;
        }
        if (size &gt; 3) {
            return false;
        }
        Curve c1 = (Curve) curves.get(1);
        Curve c2 = (Curve) curves.get(2);
        if (c1.getOrder() != 1 || c2.getOrder() != 1) {
            return false;
        }
        if (c1.getXTop() != c1.getXBot() || c2.getXTop() != c2.getXBot()) {
            return false;
        }
        if (c1.getYTop() != c2.getYTop() || c1.getYBot() != c2.getYBot()) {
            // One might be able to prove that this is impossible...
            return false;
        }
        return true;
    }

    /**
     * Tests whether this &lt;code&gt;Area&lt;/code&gt; is comprised of a single
     * closed subpath.  This method returns &lt;code&gt;true&lt;/code&gt; if the
     * path contains 0 or 1 subpaths, or &lt;code&gt;false&lt;/code&gt; if the path
     * contains more than 1 subpath.  The subpaths are counted by the
     * number of {@link PathIterator#SEG_MOVETO SEG_MOVETO}  segments
     * that appear in the path.
     * @return    &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Area&lt;/code&gt; is comprised
     * of a single basic geometry; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isSingular() {
        if (curves.size() &lt; 3) {
            return true;
        }
        Enumeration enum_ = curves.elements();
        enum_.nextElement(); // First Order0 &quot;moveto&quot;
        while (enum_.hasMoreElements()) {
            if (((Curve) enum_.nextElement()).getOrder() == 0) {
                return false;
            }
        }
        return true;
    }

    private RectBounds cachedBounds;
    private void invalidateBounds() {
        cachedBounds = null;
    }
    private RectBounds getCachedBounds() {
        if (cachedBounds != null) {
            return cachedBounds;
        }
        RectBounds r = new RectBounds();
        if (curves.size() &gt; 0) {
            Curve c = (Curve) curves.get(0);
            // First point is always an order 0 curve (moveto)
            r.setBounds((float) c.getX0(), (float) c.getY0(), 0, 0);
            for (int i = 1; i &lt; curves.size(); i++) {
                ((Curve) curves.get(i)).enlarge(r);
            }
        }
        return (cachedBounds = r);
    }

    /**
     * Returns a high precision bounding {@link RectBounds} that
     * completely encloses this &lt;code&gt;Area&lt;/code&gt;.
     * &lt;p&gt;
     * The Area class will attempt to return the tightest bounding
     * box possible for the Shape.  The bounding box will not be
     * padded to include the control points of curves in the outline
     * of the Shape, but should tightly fit the actual geometry of
     * the outline itself.
     * @return    the bounding &lt;code&gt;RectBounds&lt;/code&gt; for the
     * &lt;code&gt;Area&lt;/code&gt;.
     */
    public RectBounds getBounds() {
        return new RectBounds(getCachedBounds());
    }

    /**
     * Tests whether the geometries of the two &lt;code&gt;Area&lt;/code&gt; objects
     * cover the same area.
     * This method will return false if the argument is null.
     * @param   other  the &lt;code&gt;Area&lt;/code&gt; to be compared to this
     *          &lt;code&gt;Area&lt;/code&gt;
     * @return  &lt;code&gt;true&lt;/code&gt; if the two geometries are equivalent;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isEquivalent(Area other) {
        // REMIND: A *much* simpler operation should be possible...
        // Should be able to do a curve-wise comparison since all Areas
        // should evaluate their curves in the same top-down order.
        if (other == this) {
            return true;
        }
        if (other == null) {
            return false;
        }
        Vector c = new AreaOp.XorOp().calculate(this.curves, other.curves);
        return c.isEmpty();
    }

    /**
     * Transforms the geometry of this &lt;code&gt;Area&lt;/code&gt; using the specified
     * {@link BaseTransform}.  The geometry is transformed in place, which
     * permanently changes the enclosed area defined by this object.
     * @param tx the transformation used to transform the area
     * @throws NullPointerException if &lt;code&gt;t&lt;/code&gt; is null
     */
    public void transform(BaseTransform tx) {
        if (tx == null) {
            throw new NullPointerException(&quot;transform must not be null&quot;);
        }
        // REMIND: A simpler operation can be performed for some types
        // of transform.
        curves = pathToCurves(getPathIterator(tx));
        invalidateBounds();
    }

    /**
     * Creates a new &lt;code&gt;Area&lt;/code&gt; object that contains the same
     * geometry as this &lt;code&gt;Area&lt;/code&gt; transformed by the specified
     * &lt;code&gt;BaseTransform&lt;/code&gt;.  This &lt;code&gt;Area&lt;/code&gt; object
     * is unchanged.
     * @param tx the specified &lt;code&gt;BaseTransform&lt;/code&gt; used to transform
     *           the new &lt;code&gt;Area&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;t&lt;/code&gt; is null
     * @return   a new &lt;code&gt;Area&lt;/code&gt; object representing the transformed
     *           geometry.
     */
    public Area createTransformedArea(BaseTransform tx) {
        Area a = new Area(this);
        a.transform(tx);
        return a;
    }

    /**
     * {@inheritDoc}
     */
    public boolean contains(float x, float y) {
        if (!getCachedBounds().contains(x, y)) {
            return false;
        }
        Enumeration enum_ = curves.elements();
        int crossings = 0;
        while (enum_.hasMoreElements()) {
            Curve c = (Curve) enum_.nextElement();
            crossings += c.crossingsFor(x, y);
        }
        return ((crossings &amp; 1) == 1);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean contains(Point2D p) {
        return contains(p.x, p.y);
    }

    /**
     * {@inheritDoc}
     */
    public boolean contains(float x, float y, float w, float h) {
        if (w &lt; 0 || h &lt; 0) {
            return false;
        }
        if (!getCachedBounds().contains(x, y) || !getCachedBounds().contains(x+w, y+h)) {
            return false;
        }
        Crossings c = Crossings.findCrossings(curves, x, y, x+w, y+h);
        return (c != null &amp;&amp; c.covers(y, y+h));
    }

    /**
     * {@inheritDoc}
     */
    public boolean intersects(float x, float y, float w, float h) {
        if (w &lt; 0 || h &lt; 0) {
            return false;
        }
        if (!getCachedBounds().intersects(x, y, w, h)) {
            return false;
        }
        Crossings c = Crossings.findCrossings(curves, x, y, x+w, y+h);
        return (c == null || !c.isEmpty());
    }

    /**
     * Creates a {@link PathIterator} for the outline of this
     * &lt;code&gt;Area&lt;/code&gt; object.  This &lt;code&gt;Area&lt;/code&gt; object is unchanged.
     * @param tx an optional &lt;code&gt;BaseTransform&lt;/code&gt; to be applied to
     * the coordinates as they are returned in the iteration, or
     * &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired
     * @return    the &lt;code&gt;PathIterator&lt;/code&gt; object that returns the
     *          geometry of the outline of this &lt;code&gt;Area&lt;/code&gt;, one
     *          segment at a time.
     */
    public PathIterator getPathIterator(BaseTransform tx) {
        return new AreaIterator(curves, tx);
    }

    /**
     * Creates a &lt;code&gt;PathIterator&lt;/code&gt; for the flattened outline of
     * this &lt;code&gt;Area&lt;/code&gt; object.  Only uncurved path segments
     * represented by the SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point
     * types are returned by the iterator.  This &lt;code&gt;Area&lt;/code&gt;
     * object is unchanged.
     * @param tx an optional &lt;code&gt;BaseTransform&lt;/code&gt; to be
     * applied to the coordinates as they are returned in the
     * iteration, or &lt;code&gt;null&lt;/code&gt; if untransformed coordinates
     * are desired
     * @param flatness the maximum amount that the control points
     * for a given curve can vary from colinear before a subdivided
     * curve is replaced by a straight line connecting the end points
     * @return    the &lt;code&gt;PathIterator&lt;/code&gt; object that returns the
     * geometry of the outline of this &lt;code&gt;Area&lt;/code&gt;, one segment
     * at a time.
     */
    public PathIterator getPathIterator(BaseTransform tx, float flatness) {
        return new FlatteningPathIterator(getPathIterator(tx), flatness);
    }

    @Override
    public Area copy() {
        return new Area(this);
    }
}

class AreaIterator implements PathIterator {
    private BaseTransform transform;
    private Vector curves;
    private int index;
    private Curve prevcurve;
    private Curve thiscurve;

    public AreaIterator(Vector curves, BaseTransform tx) {
        this.curves = curves;
        this.transform = tx;
        if (curves.size() &gt;= 1) {
            thiscurve = (Curve) curves.get(0);
        }
    }

    public int getWindingRule() {
        // REMIND: Which is better, EVEN_ODD or NON_ZERO?
        //         The paths calculated could be classified either way.
        //return WIND_EVEN_ODD;
        return WIND_NON_ZERO;
    }

    public boolean isDone() {
        return (prevcurve == null &amp;&amp; thiscurve == null);
    }

    public void next() {
        if (prevcurve != null) {
            prevcurve = null;
        } else {
            prevcurve = thiscurve;
            index++;
            if (index &lt; curves.size()) {
                thiscurve = (Curve) curves.get(index);
                if (thiscurve.getOrder() != 0 &amp;&amp;
                    prevcurve.getX1() == thiscurve.getX0() &amp;&amp;
                    prevcurve.getY1() == thiscurve.getY0())
                {
                    prevcurve = null;
                }
            } else {
                thiscurve = null;
            }
        }
    }

    public int currentSegment(float coords[]) {
        int segtype;
        int numpoints;
        if (prevcurve != null) {
            // Need to finish off junction between curves
            if (thiscurve == null || thiscurve.getOrder() == 0) {
                return SEG_CLOSE;
            }
            coords[0] = (float) thiscurve.getX0();
            coords[1] = (float) thiscurve.getY0();
            segtype = SEG_LINETO;
            numpoints = 1;
        } else if (thiscurve == null) {
            throw new NoSuchElementException(&quot;area iterator out of bounds&quot;);
        } else {
            segtype = thiscurve.getSegment(coords);
            numpoints = thiscurve.getOrder();
            if (numpoints == 0) {
                numpoints = 1;
            }
        }
        if (transform != null) {
            transform.transform(coords, 0, coords, 0, numpoints);
        }
        return segtype;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/CacheFilter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import com.sun.javafx.logging.PulseLogger;
import javafx.scene.CacheHint;
import java.util.List;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.prism.Graphics;
import com.sun.prism.RTTexture;
import com.sun.prism.Texture;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import javafx.geometry.Insets;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.paint.Color;

/**
 * Base implementation of the Node.cache and cacheHint APIs.
 *
 * When all or a portion of the cacheHint becomes enabled, we should try *not*
 * to re-render the cache.  This avoids a big hiccup at the beginning of the
 * &quot;use SPEED only while animating&quot; use case:
 *   0) Under DEFAULT, we should already have a cached image
 *   1) scale/rotate caching is enabled (no expensive re-render required)
 *   2) animation happens, using the cached image
 *   3) animation completes, caching is disable and the node is re-rendered (at
 *      full-fidelity) with the final transform.
 *
 * Certain transform combinations are not supported, notably scaling by unequal
 * amounts in the x and y directions while also rotating.  Other than simple
 * translation, animations in this case will require re-rendering every frame.
 *
 * Ideally, a simple change to a Node's translation should never regenerate the
 * cached image.
 *
 * The CacheFilter is also capable of optimizing the scrolling of the cached contents.
 * For example, the ScrollView UI Control can define its content area as being cached,
 * such that when the user scrolls, we can shift the old content area and adjust the
 * dirty region so that it only includes the &quot;newly exposed&quot; area.
 */
public class CacheFilter {
    /**
     * Defines the state when we're in the midst of scrolling a cached image
     */
    private static enum ScrollCacheState {
        CHECKING_PRECONDITIONS,
        ENABLED,
        DISABLED
    }

    // Garbage-reduction variables:
    private static final Rectangle TEMP_RECT = new Rectangle();
    private static final DirtyRegionContainer TEMP_CONTAINER = new DirtyRegionContainer(1);
    private static final Affine3D TEMP_CACHEFILTER_TRANSFORM = new Affine3D();
    private static final RectBounds TEMP_BOUNDS = new RectBounds();
    // Fun with floating point
    private static final double EPSILON = 0.0000001;

    private RTTexture tempTexture;
    private double lastXDelta;
    private double lastYDelta;
    private ScrollCacheState scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
    // Note: this ImageData is always created and assumed to be untransformed.
    private ImageData cachedImageData;
    private Rectangle cacheBounds = new Rectangle();
    // Used to draw into the cache
    private final Affine2D cachedXform = new Affine2D();

    // The scale and rotate used to draw into the cache
    private double cachedScaleX;
    private double cachedScaleY;
    private double cachedRotate;

    private double cachedX;
    private double cachedY;
    private NGNode node;

    // Used to draw the cached image to the screen
    private final Affine2D screenXform = new Affine2D();

    // Cache hint settings
    private boolean scaleHint;
    private boolean rotateHint;
    // We keep this around for the sake of matchesHint
    private CacheHint cacheHint;

    // Was the last paint unsupported by the cache?  If so, will need to
    // regenerate the cache next time.
    private boolean wasUnsupported = false;

    /**
     * Compute the dirty region that must be re-rendered after scrolling
     */
    private Rectangle computeDirtyRegionForTranslate() {
        if (lastXDelta != 0) {
            if (lastXDelta &gt; 0) {
                TEMP_RECT.setBounds(0, 0, (int)lastXDelta, cacheBounds.height);
            } else {
                TEMP_RECT.setBounds(cacheBounds.width + (int)lastXDelta, 0, -(int)lastXDelta, cacheBounds.height);
            }
        } else {
            if (lastYDelta &gt; 0) {
                TEMP_RECT.setBounds(0, 0, cacheBounds.width, (int)lastYDelta);
            } else {
                TEMP_RECT.setBounds(0, cacheBounds.height + (int)lastYDelta, cacheBounds.width, -(int)lastYDelta);
            }
        }
        return TEMP_RECT;
    }

    protected CacheFilter(NGNode node, CacheHint cacheHint) {
        this.node = node;
        this.scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
<A NAME="2"></A>        setHint(cacheHint);
    }

    public void setHint(<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#2',2,'match45-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CacheHint cacheHint) {
        this.cacheHint = cacheHint;
        this.scaleHint = (cacheHint == CacheHint.SPEED ||
                          cacheHint == CacheHint.SCALE ||
                          cacheHint == CacheHint.SCALE_AND_ROTATE);
        this.rotateHint = (cacheHint == CacheHint.SPEED ||
                           cacheHint == CacheHint.ROTATE ||
                           cacheHint == CacheHint.SCALE_AND_ROTATE);
    }

    // These two methods exist only for the sake of testing.
    final boolean isScaleHint() { return scaleHint; }
    final boolean isRotateHint() { return rotateHint; }

    /**
     * Indicates whether this CacheFilter's hint matches the CacheHint
     * passed in.
     */
    boolean matchesHint(CacheHint cacheHint) {
        return this.cacheHint == cacheHint;
    }</B></FONT>

    /**
     * Are we attempting to use cache for an unsupported transform mode?  Mostly
     * this is for trying to rotate while scaling the object by different
     * amounts in the x and y directions (this also includes shearing).
     */
    boolean unsupported(double[] xformInfo) {
        double scaleX = xformInfo[0];
        double scaleY = xformInfo[1];
        double rotate = xformInfo[2];

        // If we're trying to rotate...
        if (rotate &gt; EPSILON || rotate &lt; -EPSILON) {
            // ...and if scaleX != scaleY.  This can be in the render xform, or
            // may have made it into the cached image.
            if (scaleX &gt; scaleY + EPSILON || scaleY &gt; scaleX + EPSILON ||
                scaleX &lt; scaleY - EPSILON || scaleY &lt; scaleX - EPSILON ||
                cachedScaleX &gt; cachedScaleY + EPSILON ||
                cachedScaleY &gt; cachedScaleX + EPSILON ||
                cachedScaleX &lt; cachedScaleY - EPSILON ||
                cachedScaleY &lt; cachedScaleX - EPSILON ) {
                    return true;
            }
        }
        return false;
    }

    private boolean isXformScrollCacheCapable(double[] xformInfo) {
        if (unsupported(xformInfo)) {
            return false;
        }
        double rotate = xformInfo[2];
        return rotateHint || rotate == 0;
    }

    /*
     * Do we need to regenerate the cached image?
     * Assumes that caller locked and validated the cachedImageData.untximage
     * if not null...
     */
    private boolean needToRenderCache(BaseTransform renderXform, double[] xformInfo,
                                      float pixelScaleX, float pixelScaleY)
    {
        if (cachedImageData == null) {
            return true;
        }

        if (lastXDelta != 0 || lastYDelta != 0) {
            if (Math.abs(lastXDelta) &gt;= cacheBounds.width || Math.abs(lastYDelta) &gt;= cacheBounds.height ||
                    Math.rint(lastXDelta) != lastXDelta || Math.rint(lastYDelta) != lastYDelta) {
                node.clearDirtyTree(); // Need to clear dirty (by translation) flags in the children
                lastXDelta = lastYDelta = 0;
                return true;
            }
            if (scrollCacheState == ScrollCacheState.CHECKING_PRECONDITIONS) {
                if (scrollCacheCapable() &amp;&amp; isXformScrollCacheCapable(xformInfo)) {
                    scrollCacheState = ScrollCacheState.ENABLED;
                } else {
                    scrollCacheState = ScrollCacheState.DISABLED;
                    return true;
                }
            }
        }

        // TODO: is == sufficient for floating point comparison here? (RT-23963)
        if (cachedXform.getMxx() == renderXform.getMxx() &amp;&amp;
            cachedXform.getMyy() == renderXform.getMyy() &amp;&amp;
            cachedXform.getMxy() == renderXform.getMxy() &amp;&amp;
            cachedXform.getMyx() == renderXform.getMyx()) {
            // It's just a translation - use cached Image
            return false;
        }
        // Not just a translation - if was or is unsupported, then must rerender
        if (wasUnsupported || unsupported(xformInfo)) {
            return true;
        }

        double scaleX = xformInfo[0];
        double scaleY = xformInfo[1];
        double rotate = xformInfo[2];
        if (scaleHint) {
            if (cachedScaleX &lt; pixelScaleX || cachedScaleY &lt; pixelScaleY) {
                // We have moved onto a screen with a higher pixelScale and
                // our cache was less than that pixel scale.  Even though
                // we have the scaleHint, we always cache at a minimum of
                // the pixel scale of the screen so we need to re-cache.
                return true;
            }
            if (rotateHint) {
                return false;
            } else {
                // Not caching for rotate: regenerate cache if rotate changed
                if (cachedRotate - EPSILON &lt; rotate &amp;&amp; rotate &lt; cachedRotate + EPSILON) {
                    return false;
                } else {
                    return true;
                }
            }
        } else {
            if (rotateHint) {
                // Not caching for scale: regenerate cache if scale changed
                if (cachedScaleX - EPSILON &lt; scaleX &amp;&amp; scaleX &lt; cachedScaleX + EPSILON &amp;&amp;
                    cachedScaleY - EPSILON &lt; scaleY &amp;&amp; scaleY &lt; cachedScaleY + EPSILON) {
                    return false;
                } else {// Scale is not &quot;equal enough&quot; - regenerate
                    return true;
                }
            }
            else { // Not caching for anything; always regenerate
                return true;
            }
        }
    }

    /*
     * Given the new xform info, update the screenXform as needed to correctly
     * paint the cache to the screen.
     */
    void updateScreenXform(double[] xformInfo) {
        // screenXform will be the difference between the cachedXform and the
        // render xform.

        if (scaleHint) {
            if (rotateHint) {
                double screenScaleX = xformInfo[0] / cachedScaleX;
                double screenScaleY = xformInfo[1] / cachedScaleY;
                double screenRotate = xformInfo[2] - cachedRotate;

                screenXform.setToScale(screenScaleX, screenScaleY);
                screenXform.rotate(screenRotate);
            } else {
                double screenScaleX = xformInfo[0] / cachedScaleX;
                double screenScaleY = xformInfo[1] / cachedScaleY;
                screenXform.setToScale(screenScaleX, screenScaleY);
            }
        } else {
            if (rotateHint) {
                double screenRotate = xformInfo[2] - cachedRotate;
                screenXform.setToRotation(screenRotate, 0.0, 0.0);
            } else {
                // No caching, cache already rendered with xform; just paint it
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            }
        }
    }

    public void invalidate() {
        if (scrollCacheState == ScrollCacheState.ENABLED) {
            scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
        }
        imageDataUnref();
        lastXDelta = lastYDelta = 0;
    }

    void imageDataUnref() {
        if (tempTexture != null) {
            tempTexture.dispose();
            tempTexture = null;
        }
        if (cachedImageData != null) {
            // While we hold on to this ImageData we leave the texture
            // unlocked so it can be reclaimed, but the default unref()
            // method assumes it was locked.
            Filterable implImage = cachedImageData.getUntransformedImage();
            if (implImage != null) {
                implImage.lock();
            }
            cachedImageData.unref();
            cachedImageData = null;
        }
    }

    void invalidateByTranslation(double translateXDelta, double translateYDelta) {
        if (cachedImageData == null) {
            return;
        }

        if (scrollCacheState == ScrollCacheState.DISABLED) {
            imageDataUnref();
        } else {
             // When both mxt and myt change, we don't currently use scroll optimization
            if (translateXDelta != 0 &amp;&amp; translateYDelta != 0) {
                imageDataUnref();
            } else {
                lastYDelta = translateYDelta;
                lastXDelta = translateXDelta;
            }
        }
    }

    public void dispose() {
        invalidate();
        node = null;
    }

    /*
     * unmatrix() and the supporting functions are based on the code from
     * &quot;Decomposing A Matrix Into Simple Transformations&quot; by Spencer W. Thomas
     * from Graphics Gems II, as found at
     * http://tog.acm.org/resources/GraphicsGems/
     * which states, &quot;All code here can be used without restrictions.&quot;
     *
     * The code was reduced from handling a 4x4 matrix (3D w/ perspective)
     * to handle just a 2x2 (2D scale/rotate, w/o translate, as that is handled
     * separately).
     */

    /**
     * Given a BaseTransform, decompose it into values for scaleX, scaleY and
     * rotate.
     *
     * The return value is a double[3], the values being:
     *   [0]: scaleX
     *   [1]: scaleY
     *   [2]: rotation angle, in radians, between *** and ***
     *
     * From unmatrix() in unmatrix.c
     */
    double[] unmatrix(BaseTransform xform) {
        double[] retVal = new double[3];

        double[][] row = {{xform.getMxx(), xform.getMxy()},
            {xform.getMyx(), xform.getMyy()}};
        final double xSignum = unitDir(row[0][0]);
        final double ySignum = unitDir(row[1][1]);

        // Compute X scale factor and normalize first row.
        // tran[U_SCALEX] = V3Length(&amp;row[0]);
        // row[0] = *V3Scale(&amp;row[0], 1.0);

        double scaleX = xSignum * v2length(row[0]);
        v2scale(row[0], xSignum);

        // Compute XY shear factor and make 2nd row orthogonal to 1st.
        // tran[U_SHEARXY] = V3Dot(&amp;row[0], &amp;row[1]);
        // (void)V3Combine(&amp;row[1], &amp;row[0], &amp;row[1], 1.0, -tran[U_SHEARXY]);
        //
        // &quot;this is too large by the y scaling factor&quot;
        double shearXY = v2dot(row[0], row[1]);

        // Combine into row[1]
        v2combine(row[1], row[0], row[1], 1.0, -shearXY);

        // Now, compute Y scale and normalize 2nd row
        // tran[U_SCALEY] = V3Length(&amp;row[1]);
        // V3Scale(&amp;row[1], 1.0);
        // tran[U_SHEARXY] /= tran[U_SCALEY];

        double scaleY = ySignum * v2length(row[1]);
        v2scale(row[1], ySignum);

        // Now extract the rotation. (This is new code, not from the Gem.)
        //
        // In our matrix, we now have
        // [   cos(theta)    -sin(theta)    ]
        // [   sin(theta)     cos(theta)    ]
        //
        // TODO: assert: all 4 values are sane (RT-23962)
        //
        double sin = row[1][0];
        double cos = row[0][0];
        double angleRad = 0.0;

        // Recall:
        // arcsin works for theta: -90 -&gt; 90
        // arccos works for theta:   0 -&gt; 180
        if (sin &gt;= 0) {
            // theta is 0 -&gt; 180, use acos()
            angleRad = Math.acos(cos);
        } else {
            if (cos &gt; 0) {
                // sin &lt; 0, cos &gt; 0, so theta is 270 -&gt; 360, aka -90 -&gt; 0
                // use asin(), add 360
                angleRad = 2.0 * Math.PI + Math.asin(sin);
            } else {
                // sin &lt; 0, cos &lt; 0, so theta 180 -&gt; 270
                // cos from 180 -&gt; 270 is inverse of cos from 0-&gt;90,
                // so take acos(-cos) and add 180
                angleRad = Math.PI + Math.acos(-cos);
            }
        }

        retVal[0] = scaleX;
        retVal[1] = scaleY;
        retVal[2] = angleRad;

        return retVal;
    }

    /**
     * Return the unit distance in a direction compatible with the matrix element.
     * @param v the matrix element representing a scale factor
     * @return -1.0 if the matrix element is negative, otherwise 1.0
     */
    double unitDir(double v) {
        return v &lt; 0.0 ? -1.0 : 1.0;
    }

    /**
     * make a linear combination of two vectors and return the result
     * result = (v0 * scalarA) + (v1 * scalarB)
     *
     * From V3Combine() in GGVecLib.c
     */
    void v2combine(double v0[], double v1[], double result[], double scalarA, double scalarB) {
        // make a linear combination of two vectors and return the result.
        // result = (a * ascl) + (b * bscl)
        /*
        Vector3 *V3Combine (a, b, result, ascl, bscl)
        Vector3 *a, *b, *result;
        double ascl, bscl;
        {
                result-&gt;x = (ascl * a-&gt;x) + (bscl * b-&gt;x);
                result-&gt;y = (ascl * a-&gt;y) + (bscl * b-&gt;y);
                result-&gt;z = (ascl * a-&gt;z) + (bscl * b-&gt;z);
                return(result);
        */

        result[0] = scalarA*v0[0] + scalarB*v1[0];
        result[1] = scalarA*v0[1] + scalarB*v1[1];
    }

    /**
     * dot product of 2 vectors of length 2
     */
    double v2dot(double v0[], double v1[]) {
        return v0[0]*v1[0] + v0[1]*v1[1];
    }

    /**
     * scale v[] to be relative to newLen
     *
     * From V3Scale() in GGVecLib.c
     */
    void v2scale(double v[], double newLen) {
        double len = v2length(v);
        if (len != 0) {
            v[0] *= newLen / len;
            v[1] *= newLen / len;
        }
    }

    /**
     * returns length of input vector
     *
     * Based on V3Length() in GGVecLib.c
     */
    double v2length(double v[]) {
        return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    }

    void render(Graphics g) {
        // The following is safe; xform will not be mutated below
        BaseTransform xform = g.getTransformNoClone();
        FilterContext fctx = PrFilterContext.getInstance(g.getAssociatedScreen()); // getFilterContext

        double[] xformInfo = unmatrix(xform);
        boolean isUnsupported = unsupported(xformInfo);

        lastXDelta = lastXDelta * xformInfo[0];
        lastYDelta = lastYDelta * xformInfo[1];

        if (cachedImageData != null) {
            Filterable implImage = cachedImageData.getUntransformedImage();
            if (implImage != null) {
                implImage.lock();
                if (!cachedImageData.validate(fctx)) {
                    implImage.unlock();
                    invalidate();
                }
            }
        }
        float pixelScaleX = g.getPixelScaleFactorX();
        float pixelScaleY = g.getPixelScaleFactorY();
        if (needToRenderCache(xform, xformInfo, pixelScaleX, pixelScaleY)) {
            if (PulseLogger.PULSE_LOGGING_ENABLED) {
                PulseLogger.incrementCounter(&quot;CacheFilter rebuilding&quot;);
            }
            if (cachedImageData != null) {
                Filterable implImage = cachedImageData.getUntransformedImage();
                if (implImage != null) {
                    implImage.unlock();
                }
                invalidate();
            }
            if (scaleHint) {
                // do not cache the image at a small scale factor when
                // scaleHint is set as it leads to poor rendering results
                // when image is scaled up.
                cachedScaleX = Math.max(pixelScaleX, xformInfo[0]);
                cachedScaleY = Math.max(pixelScaleY, xformInfo[1]);
                cachedRotate = 0;
                cachedXform.setTransform(cachedScaleX, 0.0,
                                         0.0, cachedScaleX,
                                         0.0, 0.0);
                updateScreenXform(xformInfo);
            } else {
                cachedScaleX = xformInfo[0];
                cachedScaleY = xformInfo[1];
                cachedRotate = xformInfo[2];

                // Update the cachedXform to the current xform (ignoring translate).
                cachedXform.setTransform(xform.getMxx(), xform.getMyx(),
                                         xform.getMxy(), xform.getMyy(),
                                         0.0, 0.0);

                // screenXform is always identity in this case, as we've just
                // rendered into the cache using the render xform.
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            }

            cacheBounds = getCacheBounds(cacheBounds, cachedXform);
            cachedImageData = createImageData(fctx, cacheBounds);
            renderNodeToCache(cachedImageData, cacheBounds, cachedXform, null);

            // cachedBounds includes effects, and is in *scene* coords
            Rectangle cachedBounds = cachedImageData.getUntransformedBounds();

            // Save out the (un-transformed) x &amp; y coordinates.  This accounts
            // for effects and other reasons the untranslated location may not
            // be 0,0.
            cachedX = cachedBounds.x;
            cachedY = cachedBounds.y;

        } else {
            if (scrollCacheState == ScrollCacheState.ENABLED &amp;&amp;
                    (lastXDelta != 0 || lastYDelta != 0) ) {
                moveCacheBy(cachedImageData, lastXDelta, lastYDelta);
                renderNodeToCache(cachedImageData, cacheBounds, cachedXform, computeDirtyRegionForTranslate());
                lastXDelta = lastYDelta = 0;
            }
            // Using the cached image; calculate screenXform to paint to screen.
            if (isUnsupported) {
                // Only way we should be using the cached image in the
                // unsupported case is for a change in translate only.  No other
                // xform should be needed, so use identity.

                // TODO: assert cachedXform == render xform (ignoring translate)
                //   or  assert xforminfo == cachedXform info (RT-23962)
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            } else {
                updateScreenXform(xformInfo);
            }
        }
        // If this render is unsupported, remember for next time.  We'll need
        // to regenerate the cache once we're in a supported scenario again.
        wasUnsupported = isUnsupported;

        Filterable implImage = cachedImageData.getUntransformedImage();
        if (implImage == null) {
            if (PulseLogger.PULSE_LOGGING_ENABLED) {
                PulseLogger.incrementCounter(&quot;CacheFilter not used&quot;);
            }
            renderNodeToScreen(g);
        } else {
            double mxt = xform.getMxt();
            double myt = xform.getMyt();
            renderCacheToScreen(g, implImage, mxt, myt);
            implImage.unlock();
        }
    }

    /**
     * Create the ImageData for the cached bitmap, with the specified bounds.
     */
    ImageData createImageData(FilterContext fctx, Rectangle bounds) {
        Filterable ret;
        try {
            ret = Effect.getCompatibleImage(fctx,
                    bounds.width, bounds.height);
            Texture cachedTex = ((PrDrawable) ret).getTextureObject();
            cachedTex.contentsUseful();
        } catch (Throwable e) {
            ret = null;
        }

        return new ImageData(fctx, ret, bounds);
    }

    /**
     * Render node to cache.
     * @param cacheData the cache
     * @param cacheBounds cache bounds
     * @param xform transformation
     * @param dirtyBounds null or dirty rectangle to be rendered
     */
    void renderNodeToCache(ImageData cacheData,
                                Rectangle cacheBounds,
                                BaseTransform xform,
                                Rectangle dirtyBounds) {
        final PrDrawable image = (PrDrawable) cacheData.getUntransformedImage();

        if (image != null) {
            Graphics g = image.createGraphics();
            TEMP_CACHEFILTER_TRANSFORM.setToIdentity();
            TEMP_CACHEFILTER_TRANSFORM.translate(-cacheBounds.x, -cacheBounds.y);
            if (xform != null) {
                TEMP_CACHEFILTER_TRANSFORM.concatenate(xform);
            }
            if (dirtyBounds != null) {
                TEMP_CONTAINER.deriveWithNewRegion((RectBounds)TEMP_BOUNDS.deriveWithNewBounds(dirtyBounds));
                // Culling might save us a lot when there's a dirty region
                node.doPreCulling(TEMP_CONTAINER, TEMP_CACHEFILTER_TRANSFORM, new GeneralTransform3D());
                g.setHasPreCullingBits(true);
                g.setClipRectIndex(0);
                g.setClipRect(dirtyBounds);
            }
            g.transform(TEMP_CACHEFILTER_TRANSFORM);
            if (node.getClipNode() != null) {
                node.renderClip(g);
            } else if (node.getEffectFilter() != null) {
                node.renderEffect(g);
            } else {
                node.renderContent(g);
            }
        }
    }

    /**
     * Render the node directly to the screen, in the case that the cached
     * image is unexpectedly null.  See RT-6428.
     */
    void renderNodeToScreen(Object implGraphics) {
        Graphics g = (Graphics)implGraphics;
        if (node.getEffectFilter() != null) {
            node.renderEffect(g);
        } else {
            node.renderContent(g);
        }
    }

    /**
     * Render the cached image to the screen, translated by mxt, myt.
     */
    void renderCacheToScreen(Object implGraphics, Filterable implImage,
                                  double mxt, double myt)
    {
        Graphics g = (Graphics)implGraphics;

        g.setTransform(screenXform.getMxx(),
                       screenXform.getMyx(),
                       screenXform.getMxy(),
                       screenXform.getMyy(),
                       mxt, myt);
        g.translate((float)cachedX, (float)cachedY);
        Texture cachedTex = ((PrDrawable)implImage).getTextureObject();
        Rectangle cachedBounds = cachedImageData.getUntransformedBounds();
        g.drawTexture(cachedTex, 0, 0,
                      cachedBounds.width, cachedBounds.height);
        // FYI: transform state is restored by the NGNode.render() method
    }

    /**
     * True if we can use scrolling optimization on this node.
     */
    boolean scrollCacheCapable() {
        if (!(node instanceof NGGroup)) {
            return false;
        }
        List&lt;NGNode&gt; children = ((NGGroup)node).getChildren();
        if (children.size() != 1) {
            return false;
        }
        NGNode child = children.get(0);
        if (!child.getTransform().is2D()) {
            return false;
        }

        NGNode clip = node.getClipNode();
        if (clip == null || !clip.isRectClip(BaseTransform.IDENTITY_TRANSFORM, false)) {
            return false;
        }

        if (node instanceof NGRegion) {
            NGRegion region = (NGRegion) node;
            if (!region.getBorder().isEmpty()) {
                return false;
            }
            final Background background = region.getBackground();

            if (!background.isEmpty()) {
                if (!background.getImages().isEmpty()
                        || background.getFills().size() != 1) {
                    return false;
                }
                BackgroundFill fill = background.getFills().get(0);
                javafx.scene.paint.Paint fillPaint = fill.getFill();
                BaseBounds clipBounds = clip.getCompleteBounds(TEMP_BOUNDS, BaseTransform.IDENTITY_TRANSFORM);

                return fillPaint.isOpaque() &amp;&amp; fillPaint instanceof Color &amp;&amp; fill.getInsets().equals(Insets.EMPTY)
                        &amp;&amp; clipBounds.getMinX() == 0 &amp;&amp; clipBounds.getMinY() == 0
                        &amp;&amp; clipBounds.getMaxX() == region.getWidth() &amp;&amp; clipBounds.getMaxY() == region.getHeight();
            }
        }

        return true;
    }

    /**
     * Moves a subregion of the cache, &quot;scrolling&quot; the cache by x/y Delta.
     * On of xDelta/yDelta must be zero. The rest of the pixels will be cleared.
     * @param cachedImageData cache
     * @param xDelta x-axis delta
     * @param yDelta y-axis delta
     */
    void moveCacheBy(ImageData cachedImageData, double xDelta, double yDelta) {
        PrDrawable drawable = (PrDrawable) cachedImageData.getUntransformedImage();
        final Rectangle r = cachedImageData.getUntransformedBounds();
        int x = (int)Math.max(0, (-xDelta));
        int y = (int)Math.max(0, (-yDelta));
        int destX = (int)Math.max(0, (xDelta));
        int destY = (int) Math.max(0, yDelta);
        int w = r.width - (int) Math.abs(xDelta);
        int h = r.height - (int) Math.abs(yDelta);

        final Graphics g = drawable.createGraphics();
        if (tempTexture != null) {
            tempTexture.lock();
            if (tempTexture.isSurfaceLost()) {
                tempTexture = null;
            }
        }
        if (tempTexture == null) {
            tempTexture = g.getResourceFactory().
                createRTTexture(drawable.getPhysicalWidth(), drawable.getPhysicalHeight(),
                                Texture.WrapMode.CLAMP_NOT_NEEDED);
        }
        final Graphics tempG = tempTexture.createGraphics();
        tempG.clear();
        tempG.drawTexture(drawable.getTextureObject(), 0, 0, w, h, x, y, x + w, y + h);
        tempG.sync();

        g.clear();
        g.drawTexture(tempTexture, destX, destY, destX + w, destY + h, 0, 0, w, h);
        tempTexture.unlock();
    }

    /**
     * Get the cache bounds.
     * @param bounds rectangle to store bounds to
     * @param xform transformation
     */
    Rectangle getCacheBounds(Rectangle bounds, BaseTransform xform) {
        final BaseBounds b = node.getClippedBounds(TEMP_BOUNDS, xform);
        bounds.setBounds(b);
        return bounds;
    }

    BaseBounds computeDirtyBounds(BaseBounds region, BaseTransform tx, GeneralTransform3D pvTx) {
        // For now, we just use the computed dirty bounds of the Node and
        // round them out before the transforms.
        // Later, we could use the bounds of the cache
        // to compute the dirty region directly (and more accurately).
        // See RT-34928 for more details.
        if (!node.dirtyBounds.isEmpty()) {
            region = region.deriveWithNewBounds(node.dirtyBounds);
        } else {
            region = region.deriveWithNewBounds(node.transformedBounds);
        }

        if (!region.isEmpty()) {
            region.roundOut();
            region = node.computePadding(region);
            region = tx.transform(region, region);
            region = pvTx.transform(region, region);
        }
        return region;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/stage/WindowPeerListener.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="10"></A> * questions.
 */

<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#10',2,'match45-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.stage;

import javafx.event.Event;
import javafx.stage.Window;

import com.sun.javafx.tk.FocusCause;
import com.sun.javafx.tk.TKStageListener;
import javafx.stage.WindowEvent;

/**
 * Listener for the Stage Peer to pass updates and events back to the stage.
 *
 */
public class WindowPeerListener implements TKStageListener {

    private final Window window;

    public WindowPeerListener(Window window) {
        this.window = window;
    }

    @Override</B></FONT>
    public void changedLocation(float x, float y) {
        WindowHelper.notifyLocationChanged(window, x, y);
    }

    @Override
    public void changedSize(float width, float height) {
        WindowHelper.notifySizeChanged(window, width, height);
    }

    @Override
    public void changedScale(float xScale, float yScale) {
        WindowHelper.notifyScaleChanged(window, xScale, yScale);
    }

    public void changedFocused(boolean focused, FocusCause cause) {
        // Also overridden in subclasses
        WindowHelper.setFocused(window, focused);
    }

    public void changedIconified(boolean iconified) {
        // Overridden in subclasses
    }

    public void changedMaximized(boolean maximized) {
        // Overridden in subclasses
    }

    public void changedResizable(boolean resizable) {
        // Overridden in subclasses
    }

    public void changedFullscreen(boolean fs) {
        // Overridden in subclasses
    }

    public void changedAlwaysOnTop(boolean aot) {
        // Overridden in subclasses
    }

    public void changedScreen(Object from, Object to) {
        WindowHelper.getWindowAccessor().notifyScreenChanged(window, from, to);
    }

    @Override
    public void closing() {
        Event.fireEvent(window,
                        new WindowEvent(window,
                                        WindowEvent.WINDOW_CLOSE_REQUEST));
    }

    @Override
    public void closed() {
        if (window.isShowing()) {
            // This is a notification to an owned window, which is being
            // closed as a result of closing its owner. The owned window
            // can be a modal dialog, so we call hide() to exit its nested
            // event loop and unblock other windows.
            window.hide();
        }
    }

    @Override public void focusUngrab() {
        Event.fireEvent(window, new FocusUngrabEvent());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/marlin/TransformingPathConsumer2D.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.marlin;

import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathConsumer2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.marlin.Helpers.IndexStack;
import com.sun.marlin.Helpers.PolyStack;
import java.util.Arrays;

public final class TransformingPathConsumer2D {

    // higher uncertainty in float variant for huge shapes &gt; 10^7
    static final float CLIP_RECT_PADDING = 1.0f;

    private final RendererContext rdrCtx;

    // recycled ClosedPathDetector instance from detectClosedPath()
    private final ClosedPathDetector   cpDetector;

    // recycled PathClipFilter instance from pathClipper()
    private final PathClipFilter       pathClipper;

    // recycled PathConsumer2D instance from wrapPath2D()
    private final Path2DWrapper        wp_Path2DWrapper        = new Path2DWrapper();

    // recycled PathConsumer2D instances from deltaTransformConsumer()
    private final DeltaScaleFilter     dt_DeltaScaleFilter     = new DeltaScaleFilter();
    private final DeltaTransformFilter dt_DeltaTransformFilter = new DeltaTransformFilter();

    // recycled PathConsumer2D instances from inverseDeltaTransformConsumer()
    private final DeltaScaleFilter     iv_DeltaScaleFilter     = new DeltaScaleFilter();
    private final DeltaTransformFilter iv_DeltaTransformFilter = new DeltaTransformFilter();

    // recycled PathTracer instances from tracer...() methods
    private final PathTracer tracerInput      = new PathTracer(&quot;[Input]&quot;);
    private final PathTracer tracerCPDetector = new PathTracer(&quot;ClosedPathDetector&quot;);
    private final PathTracer tracerFiller     = new PathTracer(&quot;Filler&quot;);
    private final PathTracer tracerStroker    = new PathTracer(&quot;Stroker&quot;);
    private final PathTracer tracerDasher     = new PathTracer(&quot;Dasher&quot;);

    TransformingPathConsumer2D(final RendererContext rdrCtx) {
        // used by RendererContext
        this.rdrCtx = rdrCtx;
        this.cpDetector = new ClosedPathDetector(rdrCtx);
        this.pathClipper = new PathClipFilter(rdrCtx);
    }

    public PathConsumer2D wrapPath2D(Path2D p2d) {
        return wp_Path2DWrapper.init(p2d);
    }

    public PathConsumer2D traceInput(PathConsumer2D out) {
        return tracerInput.init(out);
    }

    public PathConsumer2D traceClosedPathDetector(PathConsumer2D out) {
        return tracerCPDetector.init(out);
    }

    public PathConsumer2D traceFiller(PathConsumer2D out) {
        return tracerFiller.init(out);
    }

    public PathConsumer2D traceStroker(PathConsumer2D out) {
        return tracerStroker.init(out);
    }

    public PathConsumer2D traceDasher(PathConsumer2D out) {
        return tracerDasher.init(out);
    }

    public PathConsumer2D detectClosedPath(PathConsumer2D out) {
        return cpDetector.init(out);
    }

    public PathConsumer2D pathClipper(PathConsumer2D out) {
        return pathClipper.init(out);
    }

    public PathConsumer2D deltaTransformConsumer(PathConsumer2D out,
                                                 BaseTransform at)
    {
        if (at == null) {
            return out;
        }
        final float mxx = (float) at.getMxx();
        final float mxy = (float) at.getMxy();
        final float myx = (float) at.getMyx();
        final float myy = (float) at.getMyy();

        if (mxy == 0.0f &amp;&amp; myx == 0.0f) {
            if (mxx == 1.0f &amp;&amp; myy == 1.0f) {
                return out;
            } else {
                // Scale only
                if (rdrCtx.doClip) {
                    // adjust clip rectangle (ymin, ymax, xmin, xmax):
                    rdrCtx.clipInvScale = adjustClipScale(rdrCtx.clipRect,
                        mxx, myy);
                }
                return dt_DeltaScaleFilter.init(out, mxx, myy);
            }
        } else {
            if (rdrCtx.doClip) {
                // adjust clip rectangle (ymin, ymax, xmin, xmax):
                rdrCtx.clipInvScale = adjustClipInverseDelta(rdrCtx.clipRect,
                    mxx, mxy, myx, myy);
            }
            return dt_DeltaTransformFilter.init(out, mxx, mxy, myx, myy);
        }
    }

    private static float adjustClipScale(final float[] clipRect,
                                         final float mxx, final float myy)
    {
        // Adjust the clipping rectangle (iv_DeltaScaleFilter):
        final float scaleY = 1.0f / myy;
        clipRect[0] *= scaleY;
        clipRect[1] *= scaleY;

        if (clipRect[1] &lt; clipRect[0]) {
            float tmp = clipRect[0];
            clipRect[0] = clipRect[1];
            clipRect[1] = tmp;
        }

        final float scaleX = 1.0f / mxx;
        clipRect[2] *= scaleX;
        clipRect[3] *= scaleX;

        if (clipRect[3] &lt; clipRect[2]) {
            float tmp = clipRect[2];
            clipRect[2] = clipRect[3];
            clipRect[3] = tmp;
        }

        if (MarlinConst.DO_LOG_CLIP) {
                MarlinUtils.logInfo(&quot;clipRect (ClipScale): &quot;
                                    + Arrays.toString(clipRect));
        }
        return 0.5f * (Math.abs(scaleX) + Math.abs(scaleY));
    }

    private static float adjustClipInverseDelta(final float[] clipRect,
                                                final float mxx, final float mxy,
                                                final float myx, final float myy)
    {
        // Adjust the clipping rectangle (iv_DeltaTransformFilter):
        final float det = mxx * myy - mxy * myx;
        final float imxx =  myy / det;
        final float imxy = -mxy / det;
        final float imyx = -myx / det;
        final float imyy =  mxx / det;

        float xmin, xmax, ymin, ymax;
        float x, y;
        // xmin, ymin:
        x = clipRect[2] * imxx + clipRect[0] * imxy;
        y = clipRect[2] * imyx + clipRect[0] * imyy;

        xmin = xmax = x;
        ymin = ymax = y;

        // xmax, ymin:
        x = clipRect[3] * imxx + clipRect[0] * imxy;
        y = clipRect[3] * imyx + clipRect[0] * imyy;

        if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
        if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }

        // xmin, ymax:
        x = clipRect[2] * imxx + clipRect[1] * imxy;
        y = clipRect[2] * imyx + clipRect[1] * imyy;

        if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
        if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }

        // xmax, ymax:
        x = clipRect[3] * imxx + clipRect[1] * imxy;
        y = clipRect[3] * imyx + clipRect[1] * imyy;

        if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
        if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }

        clipRect[0] = ymin;
        clipRect[1] = ymax;
        clipRect[2] = xmin;
        clipRect[3] = xmax;

        if (MarlinConst.DO_LOG_CLIP) {
                MarlinUtils.logInfo(&quot;clipRect (ClipInverseDelta): &quot;
                                    + Arrays.toString(clipRect));
        }

        final float scaleX = (float) Math.sqrt(imxx * imxx + imxy * imxy);
        final float scaleY = (float) Math.sqrt(imyx * imyx + imyy * imyy);

        return 0.5f * (scaleX + scaleY);
    }

    public PathConsumer2D inverseDeltaTransformConsumer(PathConsumer2D out,
                                                        BaseTransform at)
    {
        if (at == null) {
            return out;
        }
        float mxx = (float) at.getMxx();
        float mxy = (float) at.getMxy();
        float myx = (float) at.getMyx();
        float myy = (float) at.getMyy();

        if (mxy == 0.0f &amp;&amp; myx == 0.0f) {
            if (mxx == 1.0f &amp;&amp; myy == 1.0f) {
                return out;
            } else {
                return iv_DeltaScaleFilter.init(out, 1.0f / mxx, 1.0f / myy);
            }
        } else {
            final float det = mxx * myy - mxy * myx;
            return iv_DeltaTransformFilter.init(out,
                                                myy / det,
                                               -mxy / det,
                                               -myx / det,
                                                mxx / det);
        }
    }

    static final class DeltaScaleFilter implements PathConsumer2D {
        private PathConsumer2D out;
        private float sx, sy;

        DeltaScaleFilter() {}

        DeltaScaleFilter init(PathConsumer2D out,
                              float mxx, float myy)
        {
            this.out = out;
            sx = mxx;
            sy = myy;
            return this; // fluent API
        }

        @Override
        public void moveTo(float x0, float y0) {
            out.moveTo(x0 * sx, y0 * sy);
        }

        @Override
        public void lineTo(float x1, float y1) {
            out.lineTo(x1 * sx, y1 * sy);
        }

        @Override
        public void quadTo(float x1, float y1,
                           float x2, float y2)
        {
            out.quadTo(x1 * sx, y1 * sy,
                       x2 * sx, y2 * sy);
        }

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            out.curveTo(x1 * sx, y1 * sy,
                        x2 * sx, y2 * sy,
                        x3 * sx, y3 * sy);
        }

        @Override
        public void closePath() {
            out.closePath();
        }

        @Override
        public void pathDone() {
            out.pathDone();
        }
    }

    static final class DeltaTransformFilter implements PathConsumer2D {
        private PathConsumer2D out;
        private float mxx, mxy, myx, myy;

        DeltaTransformFilter() {}

        DeltaTransformFilter init(PathConsumer2D out,
                                  float mxx, float mxy,
                                  float myx, float myy)
        {
            this.out = out;
            this.mxx = mxx;
            this.mxy = mxy;
            this.myx = myx;
            this.myy = myy;
            return this; // fluent API
        }

        @Override
        public void moveTo(float x0, float y0) {
            out.moveTo(x0 * mxx + y0 * mxy,
                       x0 * myx + y0 * myy);
        }

        @Override
        public void lineTo(float x1, float y1) {
            out.lineTo(x1 * mxx + y1 * mxy,
                       x1 * myx + y1 * myy);
        }

        @Override
        public void quadTo(float x1, float y1,
                           float x2, float y2)
        {
            out.quadTo(x1 * mxx + y1 * mxy,
                       x1 * myx + y1 * myy,
                       x2 * mxx + y2 * mxy,
                       x2 * myx + y2 * myy);
        }

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            out.curveTo(x1 * mxx + y1 * mxy,
                        x1 * myx + y1 * myy,
                        x2 * mxx + y2 * mxy,
                        x2 * myx + y2 * myy,
                        x3 * mxx + y3 * mxy,
                        x3 * myx + y3 * myy);
        }

        @Override
        public void closePath() {
            out.closePath();
        }

        @Override
        public void pathDone() {
            out.pathDone();
        }
    }

    static final class Path2DWrapper implements PathConsumer2D {
        private Path2D p2d;

        Path2DWrapper() {}

        Path2DWrapper init(Path2D p2d) {
            this.p2d = p2d;
            return this;
        }

        @Override
        public void moveTo(float x0, float y0) {
            p2d.moveTo(x0, y0);
        }

        @Override
        public void lineTo(float x1, float y1) {
            p2d.lineTo(x1, y1);
        }

        @Override
        public void closePath() {
            p2d.closePath();
        }

        @Override
        public void pathDone() {}

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            p2d.curveTo(x1, y1, x2, y2, x3, y3);
        }

        @Override
        public void quadTo(float x1, float y1, float x2, float y2) {
            p2d.quadTo(x1, y1, x2, y2);
        }
    }

    static final class ClosedPathDetector implements PathConsumer2D {

        private final RendererContext rdrCtx;
        private final PolyStack stack;

        private PathConsumer2D out;

        ClosedPathDetector(final RendererContext rdrCtx) {
            this.rdrCtx = rdrCtx;
            this.stack = (rdrCtx.stats != null) ?
                new PolyStack(rdrCtx,
                        rdrCtx.stats.stat_cpd_polystack_types,
                        rdrCtx.stats.stat_cpd_polystack_curves,
                        rdrCtx.stats.hist_cpd_polystack_curves,
                        rdrCtx.stats.stat_array_cpd_polystack_curves,
                        rdrCtx.stats.stat_array_cpd_polystack_types)
                : new PolyStack(rdrCtx);
        }

        ClosedPathDetector init(PathConsumer2D out) {
            this.out = out;
            return this; // fluent API
        }

        /**
         * Disposes this instance:
         * clean up before reusing this instance
         */
        void dispose() {
            stack.dispose();
        }

        @Override
        public void pathDone() {
            // previous path is not closed:
            finish(false);
            out.pathDone();

            // TODO: fix possible leak if exception happened
            // Dispose this instance:
            dispose();
        }

        @Override
        public void closePath() {
            // path is closed
            finish(true);
            out.closePath();
        }

        @Override
        public void moveTo(float x0, float y0) {
            // previous path is not closed:
            finish(false);
            out.moveTo(x0, y0);
        }

        private void finish(final boolean closed) {
            rdrCtx.closedPath = closed;
            stack.pullAll(out);
        }

        @Override
        public void lineTo(float x1, float y1) {
            stack.pushLine(x1, y1);
        }

        @Override
        public void curveTo(float x3, float y3,
                            float x2, float y2,
                            float x1, float y1)
        {
            stack.pushCubic(x1, y1, x2, y2, x3, y3);
        }

        @Override
        public void quadTo(float x2, float y2, float x1, float y1) {
            stack.pushQuad(x1, y1, x2, y2);
        }
    }

    static final class PathClipFilter implements PathConsumer2D {

        private PathConsumer2D out;

        // Bounds of the drawing region, at pixel precision.
        private final float[] clipRect;

        private final float[] corners = new float[8];
        private boolean init_corners = false;

        private final IndexStack stack;

        // the current outcode of the current sub path
        private int cOutCode = 0;

        // the cumulated (and) outcode of the complete path
        private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;

        private boolean outside = false;

        // The current point (TODO stupid repeated info)
        private float cx0, cy0;

        // The current point OUTSIDE
        private float cox0, coy0;

        private boolean subdivide = MarlinConst.DO_CLIP_SUBDIVIDER;
        private final CurveClipSplitter curveSplitter;

        PathClipFilter(final RendererContext rdrCtx) {
            this.clipRect = rdrCtx.clipRect;
            this.curveSplitter = rdrCtx.curveClipSplitter;

            this.stack = (rdrCtx.stats != null) ?
                new IndexStack(rdrCtx,
                        rdrCtx.stats.stat_pcf_idxstack_indices,
                        rdrCtx.stats.hist_pcf_idxstack_indices,
                        rdrCtx.stats.stat_array_pcf_idxstack_indices)
                : new IndexStack(rdrCtx);
        }

        PathClipFilter init(final PathConsumer2D out) {
            this.out = out;

            if (MarlinConst.DO_CLIP_SUBDIVIDER) {
                // adjust padded clip rectangle:
                curveSplitter.init();
            }

            this.init_corners = true;
            this.gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;

            return this; // fluent API
        }

        /**
         * Disposes this instance:
         * clean up before reusing this instance
         */
        void dispose() {
            stack.dispose();
        }

        private void finishPath() {
            if (outside) {
                // criteria: inside or totally outside ?
                if (gOutCode == 0) {
                    finish();
                } else {
                    this.outside = false;
                    stack.reset();
                }
            }
        }

        private void finish() {
            this.outside = false;

            if (!stack.isEmpty()) {
                if (init_corners) {
                    init_corners = false;

                    final float[] _corners = corners;
                    final float[] _clipRect = clipRect;
                    // Top Left (0):
                    _corners[0] = _clipRect[2];
                    _corners[1] = _clipRect[0];
                    // Bottom Left (1):
                    _corners[2] = _clipRect[2];
                    _corners[3] = _clipRect[1];
                    // Top right (2):
                    _corners[4] = _clipRect[3];
                    _corners[5] = _clipRect[0];
                    // Bottom Right (3):
                    _corners[6] = _clipRect[3];
                    _corners[7] = _clipRect[1];
                }
                stack.pullAll(corners, out);
            }
            out.lineTo(cox0, coy0);
            this.cx0 = cox0;
            this.cy0 = coy0;
        }

        @Override
        public void pathDone() {
            finishPath();

            out.pathDone();

            // TODO: fix possible leak if exception happened
            // Dispose this instance:
            dispose();
        }

        @Override
        public void closePath() {
            finishPath();

            out.closePath();
        }

        @Override
        public void moveTo(final float x0, final float y0) {
            finishPath();

            this.cOutCode = Helpers.outcode(x0, y0, clipRect);
            this.outside = false;
            out.moveTo(x0, y0);
            this.cx0 = x0;
            this.cy0 = y0;
        }

        @Override
        public void lineTo(final float xe, final float ye) {
            final int outcode0 = this.cOutCode;
            final int outcode1 = Helpers.outcode(xe, ye, clipRect);

            // Should clip
            final int orCode = (outcode0 | outcode1);
            if (orCode != 0) {
                final int sideCode = (outcode0 &amp; outcode1);

                // basic rejection criteria:
                if (sideCode == 0) {
                    // ovelap clip:
                    if (subdivide) {
                        // avoid reentrance
                        subdivide = false;
                        boolean ret;
                        // subdivide curve =&gt; callback with subdivided parts:
                        if (outside) {
                            ret = curveSplitter.splitLine(cox0, coy0, xe, ye,
                                                          orCode, this);
                        } else {
                            ret = curveSplitter.splitLine(cx0, cy0, xe, ye,
                                                          orCode, this);
                        }
                        // reentrance is done:
                        subdivide = true;
                        if (ret) {
                            return;
                        }
                    }
                    // already subdivided so render it
                } else {
                    this.cOutCode = outcode1;
                    this.gOutCode &amp;= sideCode;
                    // keep last point coordinate before entering the clip again:
                    this.outside = true;
                    this.cox0 = xe;
                    this.coy0 = ye;

                    clip(sideCode, outcode0, outcode1);
                    return;
                }
            }

            this.cOutCode = outcode1;
            this.gOutCode = 0;

            if (outside) {
                finish();
            }
            // clipping disabled:
            out.lineTo(xe, ye);
            this.cx0 = xe;
            this.cy0 = ye;
        }

        private void clip(final int sideCode,
                          final int outcode0,
                          final int outcode1)
        {
            // corner or cross-boundary on left or right side:
            if ((outcode0 != outcode1)
                    &amp;&amp; ((sideCode &amp; MarlinConst.OUTCODE_MASK_L_R) != 0))
            {
                // combine outcodes:
                final int mergeCode = (outcode0 | outcode1);
                final int tbCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_T_B;
                final int lrCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_L_R;
                final int off = (lrCode == MarlinConst.OUTCODE_LEFT) ? 0 : 2;

                // add corners to outside stack:
                switch (tbCode) {
                    case MarlinConst.OUTCODE_TOP:
                        stack.push(off); // top
                        return;
                    case MarlinConst.OUTCODE_BOTTOM:
                        stack.push(off + 1); // bottom
                        return;
                    default:
                        // both TOP / BOTTOM:
                        if ((outcode0 &amp; MarlinConst.OUTCODE_TOP) != 0) {
                            // top to bottom
                            stack.push(off); // top
                            stack.push(off + 1); // bottom
                        } else {
                            // bottom to top
                            stack.push(off + 1); // bottom
                            stack.push(off); // top
                        }
                }
            }
        }

        @Override
        public void curveTo(final float x1, final float y1,
                            final float x2, final float y2,
                            final float xe, final float ye)
        {
            final int outcode0 = this.cOutCode;
            final int outcode1 = Helpers.outcode(x1, y1, clipRect);
            final int outcode2 = Helpers.outcode(x2, y2, clipRect);
            final int outcode3 = Helpers.outcode(xe, ye, clipRect);

            // Should clip
            final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
            if (orCode != 0) {
                final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;

                // basic rejection criteria:
                if (sideCode == 0) {
                    // ovelap clip:
                    if (subdivide) {
                        // avoid reentrance
                        subdivide = false;
                        // subdivide curve =&gt; callback with subdivided parts:
                        boolean ret;
                        if (outside) {
                            ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,
                                                           x2, y2, xe, ye,
                                                           orCode, this);
                        } else {
                            ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
                                                           x2, y2, xe, ye,
                                                           orCode, this);
                        }
                        // reentrance is done:
                        subdivide = true;
                        if (ret) {
                            return;
                        }
                    }
                    // already subdivided so render it
                } else {
                    this.cOutCode = outcode3;
                    this.gOutCode &amp;= sideCode;
                    // keep last point coordinate before entering the clip again:
                    this.outside = true;
                    this.cox0 = xe;
                    this.coy0 = ye;

                    clip(sideCode, outcode0, outcode3);
                    return;
                }
            }

            this.cOutCode = outcode3;
            this.gOutCode = 0;

            if (outside) {
                finish();
            }
            // clipping disabled:
            out.curveTo(x1, y1, x2, y2, xe, ye);
            this.cx0 = xe;
            this.cy0 = ye;
        }

        @Override
        public void quadTo(final float x1, final float y1,
                           final float xe, final float ye)
        {
            final int outcode0 = this.cOutCode;
            final int outcode1 = Helpers.outcode(x1, y1, clipRect);
            final int outcode2 = Helpers.outcode(xe, ye, clipRect);

            // Should clip
            final int orCode = (outcode0 | outcode1 | outcode2);
            if (orCode != 0) {
                final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;

                // basic rejection criteria:
                if (sideCode == 0) {
                    // ovelap clip:
                    if (subdivide) {
                        // avoid reentrance
                        subdivide = false;
                        // subdivide curve =&gt; callback with subdivided parts:
                        boolean ret;
                        if (outside) {
                            ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,
                                                          xe, ye, orCode, this);
                        } else {
                            ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
                                                          xe, ye, orCode, this);
                        }
                        // reentrance is done:
                        subdivide = true;
                        if (ret) {
                            return;
                        }
                    }
                    // already subdivided so render it
                } else {
                    this.cOutCode = outcode2;
                    this.gOutCode &amp;= sideCode;
                    // keep last point coordinate before entering the clip again:
                    this.outside = true;
                    this.cox0 = xe;
                    this.coy0 = ye;

                    clip(sideCode, outcode0, outcode2);
                    return;
                }
            }

            this.cOutCode = outcode2;
            this.gOutCode = 0;

            if (outside) {
                finish();
            }
            // clipping disabled:
            out.quadTo(x1, y1, xe, ye);
            this.cx0 = xe;
            this.cy0 = ye;
        }
    }

    static final class CurveClipSplitter {

        static final float LEN_TH = MarlinProperties.getSubdividerMinLength();
        static final boolean DO_CHECK_LENGTH = (LEN_TH &gt; 0.0f);

        private static final boolean TRACE = false;

        private static final int MAX_N_CURVES = 3 * 4;

        private final RendererContext rdrCtx;

        // scaled length threshold:
        private float minLength;

        // clip rectangle (ymin, ymax, xmin, xmax):
        final float[] clipRect;

        // clip rectangle (ymin, ymax, xmin, xmax) including padding:
        final float[] clipRectPad = new float[4];
        private boolean init_clipRectPad = false;

        // This is where the curve to be processed is put. We give it
        // enough room to store all curves.
        final float[] middle = new float[MAX_N_CURVES * 8 + 2];
        // t values at subdivision points
        private final float[] subdivTs = new float[MAX_N_CURVES];

        // dirty curve
        private final Curve curve;

        CurveClipSplitter(final RendererContext rdrCtx) {
            this.rdrCtx = rdrCtx;
            this.clipRect = rdrCtx.clipRect;
            this.curve = rdrCtx.curve;
        }

        void init() {
            this.init_clipRectPad = true;

            if (DO_CHECK_LENGTH) {
                this.minLength = (this.rdrCtx.clipInvScale == 0.0f) ? LEN_TH
                                    : (LEN_TH * this.rdrCtx.clipInvScale);

                if (MarlinConst.DO_LOG_CLIP) {
                    MarlinUtils.logInfo(&quot;CurveClipSplitter.minLength = &quot;
                                            + minLength);
                }
            }
        }

        private void initPaddedClip() {
            // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
            // adjust padded clip rectangle (ymin, ymax, xmin, xmax):
            // add a rounding error (curve subdivision ~ 0.1px):
            final float[] _clipRect = clipRect;
            final float[] _clipRectPad = clipRectPad;

            _clipRectPad[0] = _clipRect[0] - CLIP_RECT_PADDING;
            _clipRectPad[1] = _clipRect[1] + CLIP_RECT_PADDING;
            _clipRectPad[2] = _clipRect[2] - CLIP_RECT_PADDING;
            _clipRectPad[3] = _clipRect[3] + CLIP_RECT_PADDING;

            if (TRACE) {
                MarlinUtils.logInfo(&quot;clip: X [&quot; + _clipRectPad[2] + &quot; .. &quot; + _clipRectPad[3] +&quot;] &quot;
                                        + &quot;Y [&quot; + _clipRectPad[0] + &quot; .. &quot; + _clipRectPad[1] +&quot;]&quot;);
            }
        }

        boolean splitLine(final float x0, final float y0,
                          final float x1, final float y1,
                          final int outCodeOR,
                          final PathConsumer2D out)
        {
            if (TRACE) {
                MarlinUtils.logInfo(&quot;divLine P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;)&quot;);
            }

            if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastLineLen(x0, y0, x1, y1) &lt;= minLength) {
                return false;
            }

            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;

            return subdivideAtIntersections(4, outCodeOR, out);
        }

        boolean splitQuad(final float x0, final float y0,
                          final float x1, final float y1,
                          final float x2, final float y2,
                          final int outCodeOR,
                          final PathConsumer2D out)
        {
            if (TRACE) {
                MarlinUtils.logInfo(&quot;divQuad P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2 + &quot;)&quot;);
            }

            if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastQuadLen(x0, y0, x1, y1, x2, y2) &lt;= minLength) {
                return false;
            }

            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;

            return subdivideAtIntersections(6, outCodeOR, out);
        }

        boolean splitCurve(final float x0, final float y0,
                           final float x1, final float y1,
                           final float x2, final float y2,
                           final float x3, final float y3,
                           final int outCodeOR,
                           final PathConsumer2D out)
        {
            if (TRACE) {
                MarlinUtils.logInfo(&quot;divCurve P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2 + &quot;) P3(&quot; + x3 + &quot;, &quot; + y3 + &quot;)&quot;);
            }

            if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastCurvelen(x0, y0, x1, y1, x2, y2, x3, y3) &lt;= minLength) {
                return false;
            }

            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;
            mid[6] = x3;  mid[7] = y3;

            return subdivideAtIntersections(8, outCodeOR, out);
        }

        private boolean subdivideAtIntersections(final int type, final int outCodeOR,
                                                 final PathConsumer2D out)
        {
            final float[] mid = middle;
            final float[] subTs = subdivTs;

            if (init_clipRectPad) {
                init_clipRectPad = false;
                initPaddedClip();
            }

            final int nSplits = Helpers.findClipPoints(curve, mid, subTs, type,
                                                        outCodeOR, clipRectPad);

            if (TRACE) {
                MarlinUtils.logInfo(&quot;nSplits: &quot; + nSplits);
                MarlinUtils.logInfo(&quot;subTs: &quot; + Arrays.toString(Arrays.copyOfRange(subTs, 0, nSplits)));
            }
            if (nSplits == 0) {
                // only curve support shortcut
                return false;
            }
            float prevT = 0.0f;

            for (int i = 0, off = 0; i &lt; nSplits; i++, off += type) {
                final float t = subTs[i];

                Helpers.subdivideAt((t - prevT) / (1.0f - prevT),
                                     mid, off, mid, off, type);
                prevT = t;
            }

            for (int i = 0, off = 0; i &lt;= nSplits; i++, off += type) {
                if (TRACE) {
                    MarlinUtils.logInfo(&quot;Part Curve &quot; + Arrays.toString(Arrays.copyOfRange(mid, off, off + type)));
                }
                emitCurrent(type, mid, off, out);
            }
            return true;
        }

        static void emitCurrent(final int type, final float[] pts,
                                final int off, final PathConsumer2D out)
        {
            // if instead of switch (perf + most probable cases first)
            if (type == 8) {
                out.curveTo(pts[off + 2], pts[off + 3],
                            pts[off + 4], pts[off + 5],
                            pts[off + 6], pts[off + 7]);
            } else if (type == 4) {
                out.lineTo(pts[off + 2], pts[off + 3]);
            } else {
                out.quadTo(pts[off + 2], pts[off + 3],
                           pts[off + 4], pts[off + 5]);
            }
        }
    }

    public static final class CurveBasicMonotonizer {

        private static final int MAX_N_CURVES = 11;

        // squared half line width (for stroker)
        private float lw2;

        // number of splitted curves
        int nbSplits;

        // This is where the curve to be processed is put. We give it
        // enough room to store all curves.
        final float[] middle = new float[MAX_N_CURVES * 6 + 2];
        // t values at subdivision points
        private final float[] subdivTs = new float[MAX_N_CURVES - 1];

        // dirty curve
        private final Curve curve;

        CurveBasicMonotonizer(final RendererContext rdrCtx) {
            this.curve = rdrCtx.curve;
        }

        public void init(final float lineWidth) {
            this.lw2 = (lineWidth * lineWidth) / 4.0f;
        }

        CurveBasicMonotonizer curve(final float x0, final float y0,
                                    final float x1, final float y1,
                                    final float x2, final float y2,
                                    final float x3, final float y3)
        {
            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;
            mid[6] = x3;  mid[7] = y3;

            final float[] subTs = subdivTs;
            final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 8, lw2);

            float prevT = 0.0f;
            for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
                final float t = subTs[i];

                Helpers.subdivideCubicAt((t - prevT) / (1.0f - prevT),
                                          mid, off, mid, off, off + 6);
                prevT = t;
            }

            this.nbSplits = nSplits;
            return this;
        }

        CurveBasicMonotonizer quad(final float x0, final float y0,
                                   final float x1, final float y1,
                                   final float x2, final float y2)
        {
            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;

            final float[] subTs = subdivTs;
            final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 6, lw2);

            float prevt = 0.0f;
            for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
                final float t = subTs[i];
                Helpers.subdivideQuadAt((t - prevt) / (1.0f - prevt),
                                         mid, off, mid, off, off + 4);
                prevt = t;
            }

            this.nbSplits = nSplits;
            return this;
        }
    }

    static final class PathTracer implements PathConsumer2D {
        private final String prefix;
        private PathConsumer2D out;

        PathTracer(String name) {
            this.prefix = name + &quot;: &quot;;
        }

        PathTracer init(PathConsumer2D out) {
            this.out = out;
            return this; // fluent API
        }

        @Override
        public void moveTo(float x0, float y0) {
            log(&quot;moveTo (&quot; + x0 + &quot;, &quot; + y0 + ')');
            out.moveTo(x0, y0);
        }

        @Override
        public void lineTo(float x1, float y1) {
            log(&quot;lineTo (&quot; + x1 + &quot;, &quot; + y1 + ')');
            out.lineTo(x1, y1);
        }

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            log(&quot;curveTo P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2  + &quot;) P3(&quot; + x3 + &quot;, &quot; + y3 + ')');
            out.curveTo(x1, y1, x2, y2, x3, y3);
        }

        @Override
        public void quadTo(float x1, float y1, float x2, float y2) {
            log(&quot;quadTo P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2  + ')');
            out.quadTo(x1, y1, x2, y2);
        }

        @Override
        public void closePath() {
            log(&quot;closePath&quot;);
            out.closePath();
        }
<A NAME="1"></A>
        @Override
        public void pathDone() {
            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#1',2,'match45-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>log(&quot;pathDone&quot;);
            out.pathDone();
        }

        private void log(final String message) {
            MarlinUtils.logInfo(prefix + message);
        }
    }</B></FONT>
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/packrect/RectanglePacker.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.packrect;

import com.sun.javafx.geom.Rectangle;
import com.sun.prism.Texture;
import java.util.ArrayList;
import java.util.List;

/**
 * Packs rectangles supplied by the user (typically representing image regions)
 * into a larger backing store rectangle (typically representing a large
 * texture). Supports automatic compaction of the space on the backing store,
 * and automatic expansion of the backing store, when necessary.
 */
public class RectanglePacker {
    /**
     * A reference to the backing store that was created (lazily)
     * by the backing store manager.
     */
    private Texture backingStore;

    /** Manages a list of Levels; this is the core data structure
     contained within the RectanglePacker and encompasses the storage
     algorithm for the contained Rects. */
    // Maintained in sorted order by increasing Y coordinate
    private List&lt;Level&gt; levels = new ArrayList&lt;Level&gt;(150);
    private static final int MIN_SIZE = 8; // The minimum size of level
    private static final int ROUND_UP = 4; // Round up to multiple of 4
    private int recentUsedLevelIndex = 0;
    private int length;
    private int size;
    private int sizeOffset;
    private int x;
    private int y;
    private boolean vertical;

    public RectanglePacker(Texture backingStore, int x, int y,
                           int width, int height, boolean vertical) {
        this.backingStore = backingStore;
        if (vertical) {
            this.length = height;
            this.size = width;
        } else {
            this.length = width;
            this.size = height;
        }
        this.x = x;
        this.y = y;
        this.vertical = vertical;
    }

    /**
     * Creates a new RectanglePacker. You must specify the texture used as the
     * backing store, and the width and height of the space within which rectangles
     * are to be packed.
     *
     * @param backingStore The backing store texture, must not be null
     * @param width The width of the backing store, must be &gt; 0 (typically &gt; 512)
     * @param height The height of the backing store, must be &gt; 0 (typically &gt; 512)
     */
    public RectanglePacker(Texture backingStore, int width, int height) {
        this(backingStore, 0, 0, width, height, false);
    }

    /**
     * Gets a reference to the backing store, creating it lazily if necessary.
     * @return A reference to the backing store.
     */
    public final Texture getBackingStore() {
        return backingStore;
    }

    /**
     * Decides upon an (x, y) position for the given rectangle (leaving
     * its width and height unchanged) and places it on the backing
     * store.
     */
    public final boolean add(Rectangle rect) {
        // N need to continue if the rectangle simply won't fit.
        final int requestedLength = vertical ? rect.height : rect.width;
        final int requestedSize = vertical ? rect.width : rect.height;

        if (requestedLength &gt; length) return false;
        if (requestedSize &gt; size) return false;

        int newSize = MIN_SIZE &gt; requestedSize ? MIN_SIZE : requestedSize;

        // Round up
        newSize = (newSize + ROUND_UP - 1) - (newSize - 1) % ROUND_UP;

        int newIndex;
        // If it does not match recent used level, using binary search to find
        // the best fit level's index
        if (recentUsedLevelIndex &lt; levels.size() &amp;&amp;
            levels.get(recentUsedLevelIndex).size != newSize) {
            newIndex = binarySearch(levels, newSize);
        } else {
            newIndex = recentUsedLevelIndex;
        }

        // Can create a new level with newSize
        final boolean newLevelFlag = sizeOffset + newSize &lt;= size;

        // Go through the levels check whether we can satisfy the allocation
        // request
        for (int i = newIndex, max = levels.size(); i &lt; max; i++) {
            Level level = levels.get(i);
            // If level's height is more than (newHeight + ROUND_UP * 2) and
            // the cache still has some space left, go create a new level
            if (level.size &gt; (newSize + ROUND_UP * 2) &amp;&amp; newLevelFlag) {
                break;
            } else if (level.add(rect, x, y, requestedLength, requestedSize, vertical)) {
                recentUsedLevelIndex = i;
                return true;
            }
        }

        // Try to add a new Level.
        if (!newLevelFlag) {
            return false;
        }

        Level newLevel = new Level(length, newSize, sizeOffset);
        sizeOffset += newSize;
<A NAME="14"></A>
        // For a rect that cannot fit into the existing level, create a new
        // level and add at the end of levels that have the same height
        if (newIndex &lt; levels.size() &amp;&amp; <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#14',2,'match45-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>levels.get(newIndex).size &lt;= newSize) {
            levels.add(newIndex + 1, newLevel);
            recentUsedLevelIndex = newIndex + 1;
        } else {
            levels.add(newIndex, newLevel);
            recentUsedLevelIndex = newIndex;
        }</B></FONT>
        return newLevel.add(rect, x, y, requestedLength, requestedSize, vertical);
    }

    /**
     * Clears all Rectangles contained in this RectanglePacker.
     */
    public void clear() {
        levels.clear();
        sizeOffset = 0;
        recentUsedLevelIndex = 0;
    }

    /**
     * Disposes the backing store allocated by the
     * BackingStoreManager. This RectanglePacker may no longer be used
     * after calling this method.
     */
    public void dispose() {
        if (backingStore != null) {
            backingStore.dispose();
        }

        backingStore = null;
        levels = null;
    }

    /** Using binary search to find the last index of best fit level for k,
     where k is a rounded-up value. */
    private static int binarySearch(List&lt;Level&gt; levels, int k) {

        // k+1 is used to find the last index of the level with height of k. Because of rounding up, more
        // likely, there are a bunch of levels have the same height. But, we always keep adding levels and
        // rects at the end. k+1 is a trick to find the last index by finding the next greater value's index
        // and go back one.
        // Note that since the sizes are quantized, k+1 is a special value that will not appear in the list
        // of level sizes and so the search for it will find the gap between the size for k and the size
        // for the next quantum.
        int key = k + 1;
        int from = 0, to = levels.size() - 1;
        int mid = 0;
        int midSize = 0;

        if (to &lt; 0) {
            return 0;
        }

        while (from &lt;= to) {
            mid = (from + to) / 2;
            midSize = levels.get(mid).size;
            if (key &lt; midSize) {
                to = mid - 1;
            } else {
                from = mid + 1;
            }
        }

        if (midSize &lt; k) {
            return mid + 1;
        } else if (midSize &gt; k) {
            return mid &gt; 0 ? mid - 1 : 0;
        } else {
            return mid;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/shape/OpenPiscesPrismUtils.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.shape;


import com.sun.javafx.geom.PathConsumer2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.openpisces.Dasher;
import com.sun.openpisces.Renderer;
import com.sun.openpisces.Stroker;
import com.sun.openpisces.TransformingPathConsumer2D;
import com.sun.prism.BasicStroke;

public class OpenPiscesPrismUtils {
    private static final Renderer savedAARenderer = new Renderer(3, 3);
    private static final Renderer savedRenderer = new Renderer(0, 0);
    private static final Stroker savedStroker = new Stroker(savedRenderer);
    private static final Dasher savedDasher = new Dasher(savedStroker);

    private static TransformingPathConsumer2D.FilterSet transformer =
        new TransformingPathConsumer2D.FilterSet();

    private static PathConsumer2D initRenderer(BasicStroke stroke,
                                               BaseTransform tx,
                                               Rectangle clip,
                                               int pirule,
                                               Renderer renderer)
    {
        int oprule = (stroke == null &amp;&amp; pirule == PathIterator.WIND_EVEN_ODD) ?
            Renderer.WIND_EVEN_ODD : Renderer.WIND_NON_ZERO;
        renderer.reset(clip.x, clip.y, clip.width, clip.height, oprule);
        PathConsumer2D ret = transformer.getConsumer(renderer, tx);
        if (stroke != null) {
            savedStroker.reset(stroke.getLineWidth(), stroke.getEndCap(),
                               stroke.getLineJoin(), stroke.getMiterLimit());
            savedStroker.setConsumer(ret);
<A NAME="24"></A>            ret = savedStroker;
            float dashes[] = stroke.getDashArray();
            if (dashes != null) {
                <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#24',2,'match45-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>savedDasher.reset(dashes, stroke.getDashPhase());
                ret = savedDasher;
            }
        }
        return ret;
    }

    public stati</B></FONT>c void feedConsumer(PathIterator pi, PathConsumer2D pc) {
        float[] coords = new float[6];
        while (!pi.isDone()) {
            int type = pi.currentSegment(coords);
            switch (type) {
                case PathIterator.SEG_MOVETO:
                    pc.moveTo(coords[0], coords[1]);
                    break;
                case PathIterator.SEG_LINETO:
                    pc.lineTo(coords[0], coords[1]);
                    break;
                case PathIterator.SEG_QUADTO:
                    pc.quadTo(coords[0], coords[1],
                              coords[2], coords[3]);
                    break;
                case PathIterator.SEG_CUBICTO:
                    pc.curveTo(coords[0], coords[1],
                               coords[2], coords[3],
                               coords[4], coords[5]);
                    break;
                case PathIterator.SEG_CLOSE:
                    pc.closePath();
                    break;
            }
            pi.next();
        }
        pc.pathDone();
    }

    public static Renderer setupRenderer(Shape shape,
                                  BasicStroke stroke,
                                  BaseTransform xform,
                                  Rectangle rclip,
                                  boolean antialiasedShape)
    {
        PathIterator pi = shape.getPathIterator(null);
        Renderer r = antialiasedShape ? savedAARenderer : savedRenderer;
        feedConsumer(pi, initRenderer(stroke, xform, rclip, pi.getWindingRule(), r));
        return r;
    }

    public static Renderer setupRenderer(Path2D p2d,
                                  BasicStroke stroke,
                                  BaseTransform xform,
                                  Rectangle rclip,
                                  boolean antialiasedShape)
    {
        Renderer r = antialiasedShape ? savedAARenderer : savedRenderer;
        PathConsumer2D pc2d = initRenderer(stroke, xform, rclip, p2d.getWindingRule(), r);

        float coords[] = p2d.getFloatCoordsNoClone();
        byte types[] = p2d.getCommandsNoClone();
        int nsegs = p2d.getNumCommands();
        int coff = 0;
        for (int i = 0; i &lt; nsegs; i++) {
            switch (types[i]) {
                case PathIterator.SEG_MOVETO:
                    pc2d.moveTo(coords[coff+0], coords[coff+1]);
                    coff += 2;
                    break;
                case PathIterator.SEG_LINETO:
                    pc2d.lineTo(coords[coff+0], coords[coff+1]);
                    coff += 2;
                    break;
                case PathIterator.SEG_QUADTO:
                    pc2d.quadTo(coords[coff+0], coords[coff+1],
                                coords[coff+2], coords[coff+3]);
                    coff += 4;
                    break;
                case PathIterator.SEG_CUBICTO:
                    pc2d.curveTo(coords[coff+0], coords[coff+1],
                                 coords[coff+2], coords[coff+3],
                                 coords[coff+4], coords[coff+5]);
                    coff += 6;
                    break;
                case PathIterator.SEG_CLOSE:
                    pc2d.closePath();
                    break;
            }
        }
        pc2d.pathDone();
        return r;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/effect/Lighting.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.effect;

import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.scene.Node;

import com.sun.javafx.util.Utils;
import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.scenario.effect.PhongLighting;

/**
 * An effect that simulates a light source shining on the given content,
 * which can be used to give flat objects a more realistic, three-dimensional
 * appearance.
 *
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;{@code
 * Light.Distant light = new Light.Distant();
 * light.setAzimuth(-135.0);
 *
 * Lighting lighting = new Lighting();
 * lighting.setLight(light);
 * lighting.setSurfaceScale(5.0);
 *
 * Text text = new Text();
 * text.setText(&quot;JavaFX!&quot;);
 * text.setFill(Color.STEELBLUE);
 * text.setFont(Font.font(null, FontWeight.BOLD, 60));
 * text.setX(10.0);
 * text.setY(10.0);
 * text.setTextOrigin(VPos.TOP);
 *
 * text.setEffect(lighting);
 * }&lt;/pre&gt;
 * &lt;p&gt; The code above produces the following: &lt;/p&gt;
 * &lt;p&gt;
 * &lt;img src=&quot;doc-files/lighting.png&quot; alt=&quot;The visual effect of Lighting on text&quot;&gt;
 * &lt;/p&gt;
 * @since JavaFX 2.0
 */
public class Lighting extends Effect {
    @Override
    com.sun.scenario.effect.PhongLighting createPeer() {
        return new PhongLighting(getLightInternal().getPeer());
    };

    /**
     * Creates a new instance of Lighting with default parameters.
<A NAME="15"></A>     */
    public Lighting() {
        Shadow shadow = new Shadow();
        <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#15',2,'match45-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>shadow.setRadius(10.0f);
        setBumpInput(shadow);
    }

    /**
     * Creates a new instance of Lighting with the specified light.
     * @param light the light source for this {@code Lighting} effect
     * @since JavaFX 2.1
     */
    public Lighting(Light light) {
        Shadow shadow = new Shadow();
        shadow.setRadius(10.0f);
        setBumpInput(shadow);
        setLight</B></FONT>(light);
    }

    private final Light defaultLight = new Light.Distant();

    /**
     * The light source for this {@code Lighting} effect.
     */
    private ObjectProperty&lt;Light&gt; light = new ObjectPropertyBase&lt;Light&gt;(new Light.Distant()) {
        @Override
        public void invalidated() {
            markDirty(EffectDirtyBits.EFFECT_DIRTY);
            effectBoundsChanged();
        }

        @Override
        public Object getBean() {
            return Lighting.this;
        }

        @Override
        public String getName() {
            return &quot;light&quot;;
        }
    };


    public final void setLight(Light value) {
        lightProperty().set(value);
    }

    public final Light getLight() {
        return light.get();
    }

    public final ObjectProperty&lt;Light&gt; lightProperty() {
        return light;
    }

    private final LightChangeListener lightChangeListener = new LightChangeListener();

    @Override
    Effect copy() {
        Lighting lighting = new Lighting(this.getLight());
        lighting.setBumpInput(this.getBumpInput());
        lighting.setContentInput(this.getContentInput());
        lighting.setDiffuseConstant(this.getDiffuseConstant());
        lighting.setSpecularConstant(this.getSpecularConstant());
        lighting.setSpecularExponent(this.getSpecularExponent());
        lighting.setSurfaceScale(this.getSurfaceScale());
        return lighting;
    }
    private class LightChangeListener extends EffectChangeListener {
        Light light;

        public void register(Light value) {
            light = value;
            super.register(light == null ? null : light.effectDirtyProperty());
        }

        @Override
        public void invalidated(Observable valueModel) {
            if (light.isEffectDirty()) {
                markDirty(EffectDirtyBits.EFFECT_DIRTY);
                effectBoundsChanged();
            }
        }
    };
    /**
     * The optional bump map input.
     * If not specified, a bump map will be automatically generated
     * from the default input.
     * If set to {@code null}, or left unspecified, a graphical image of
     * the {@code Node} to which the {@code Effect} is attached will be
     * used to generate a default bump map.
     * @defaultValue a Shadow effect with a radius of 10
     */
    private ObjectProperty&lt;Effect&gt; bumpInput;


    public final void setBumpInput(Effect value) {
        bumpInputProperty().set(value);
    }

    public final Effect getBumpInput() {
        return bumpInput == null ? null : bumpInput.get();
    }

    public final ObjectProperty&lt;Effect&gt; bumpInputProperty() {
        if (bumpInput == null) {
            bumpInput = new EffectInputProperty(&quot;bumpInput&quot;);
        }
        return bumpInput;
    }

    /**
     * The content input for this {@code Effect}.
     * If set to {@code null}, or left unspecified, a graphical image of
     * the {@code Node} to which the {@code Effect} is attached will be
     * used as the input.
     * @defaultValue null
     */
    private ObjectProperty&lt;Effect&gt; contentInput;


    public final void setContentInput(Effect value) {
        contentInputProperty().set(value);
    }

    public final Effect getContentInput() {
        return contentInput == null ? null : contentInput.get();
    }

    public final ObjectProperty&lt;Effect&gt; contentInputProperty() {
        if (contentInput == null) {
            contentInput = new EffectInputProperty(&quot;contentInput&quot;);
        }
        return contentInput;
    }

    @Override
    boolean checkChainContains(Effect e) {
        Effect localBumpInput = getBumpInput();
        Effect localContentInput = getContentInput();
        if (localContentInput == e || localBumpInput == e)
            return true;
        if (localContentInput != null &amp;&amp; localContentInput.checkChainContains(e))
            return true;
        if (localBumpInput != null &amp;&amp; localBumpInput.checkChainContains(e))
            return true;

        return false;
    }

    /**
     * The diffuse constant.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 2.0
     *   Default: 1.0
     *  Identity: n/a
     * &lt;/pre&gt;
     * @defaultValue 1.0
     */
    private DoubleProperty diffuseConstant;


    public final void setDiffuseConstant(double value) {
        diffuseConstantProperty().set(value);
    }

    public final double getDiffuseConstant() {
        return diffuseConstant == null ? 1 : diffuseConstant.get();
    }

    public final DoubleProperty diffuseConstantProperty() {
        if (diffuseConstant == null) {
            diffuseConstant = new DoublePropertyBase(1) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;diffuseConstant&quot;;
                }
            };
        }
        return diffuseConstant;
    }

    /**
     * The specular constant.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 2.0
     *   Default: 0.3
     *  Identity: n/a
     * &lt;/pre&gt;
     * @defaultValue 0.3
     */
    private DoubleProperty specularConstant;


    public final void setSpecularConstant(double value) {
        specularConstantProperty().set(value);
    }

    public final double getSpecularConstant() {
        return specularConstant == null ? 0.3 : specularConstant.get();
    }

    public final DoubleProperty specularConstantProperty() {
        if (specularConstant == null) {
            specularConstant = new DoublePropertyBase(0.3) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;specularConstant&quot;;
                }
            };
        }
        return specularConstant;
    }

    /**
     * The specular exponent.
     * &lt;pre&gt;
     *       Min:  0.0
     *       Max: 40.0
     *   Default: 20.0
     *  Identity:  n/a
     * &lt;/pre&gt;
     * @defaultValue 20.0
     */
    private DoubleProperty specularExponent;


    public final void setSpecularExponent(double value) {
        specularExponentProperty().set(value);
    }

    public final double getSpecularExponent() {
        return specularExponent == null ? 20 : specularExponent.get();
    }

    public final DoubleProperty specularExponentProperty() {
        if (specularExponent == null) {
            specularExponent = new DoublePropertyBase(20) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;specularExponent&quot;;
                }
            };
        }
        return specularExponent;
    }

    /**
     * The surface scale factor.
     * &lt;pre&gt;
     *       Min:  0.0
     *       Max: 10.0
     *   Default:  1.5
     *  Identity:  n/a
     * &lt;/pre&gt;
     * @defaultValue 1.5
     */
    private DoubleProperty surfaceScale;


    public final void setSurfaceScale(double value) {
        surfaceScaleProperty().set(value);
    }

    public final double getSurfaceScale() {
        return surfaceScale == null ? 1.5 : surfaceScale.get();
    }

    public final DoubleProperty surfaceScaleProperty() {
        if (surfaceScale == null) {
            surfaceScale = new DoublePropertyBase(1.5) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;surfaceScale&quot;;
                }
            };
        }
        return surfaceScale;
    }

    private Light getLightInternal() {
        Light localLight = getLight();
        return localLight == null ? defaultLight : localLight;
    }

    @Override
    void update() {
        Effect localBumpInput = getBumpInput();

        if (localBumpInput != null) {
            localBumpInput.sync();
        }

        Effect localContentInput = getContentInput();
        if (localContentInput != null) {
            localContentInput.sync();
        }

        PhongLighting peer = (PhongLighting) getPeer();
        peer.setBumpInput(localBumpInput == null ? null : localBumpInput.getPeer());
        peer.setContentInput(localContentInput == null ? null : localContentInput.getPeer());
        peer.setDiffuseConstant((float)Utils.clamp(0, getDiffuseConstant(), 2));
        peer.setSpecularConstant((float)Utils.clamp(0, getSpecularConstant(), 2));
        peer.setSpecularExponent((float)Utils.clamp(0, getSpecularExponent(), 40));
        peer.setSurfaceScale((float)Utils.clamp(0, getSurfaceScale(), 10));
        // we don't need to register on default light in case the light is null
        // because default light never changes
        lightChangeListener.register(getLight());

        getLightInternal().sync();
        peer.setLight(getLightInternal().getPeer());
    }

    @Override
    BaseBounds getBounds(BaseBounds bounds,
                         BaseTransform tx,
                         Node node,
                         BoundsAccessor boundsAccessor) {
        return getInputBounds(bounds, tx, node, boundsAccessor, getContentInput());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/input/Dragboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.input;

import java.security.Permission;
import java.util.Set;

import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.javafx.tk.PermissionHelper;
import com.sun.javafx.tk.TKClipboard;
import com.sun.javafx.tk.TKScene;
import javafx.scene.image.Image;

/**
 * A drag and drop specific {@link Clipboard}.
 * @since JavaFX 2.0
 */
public final class Dragboard extends Clipboard {

    /**
     * Whether access to the data requires a permission.
     */
    private boolean dataAccessRestricted = true;

    Dragboard(TKClipboard peer) {
        super(peer);
    }

    @Override
    Object getContentImpl(DataFormat dataFormat) {
        if (dataAccessRestricted) {
            PermissionHelper.checkClipboardPermission();
        }
        return super.getContentImpl(dataFormat);
    }

    /**
     * Gets set of transport modes supported by source of this drag opeation.
     * @return set of supported transfer modes
     */
    public final Set&lt;TransferMode&gt; getTransferModes() {
        return peer.getTransferModes();
    }

    TKClipboard getPeer() {
        return peer;
    }

    static Dragboard createDragboard(TKClipboard peer) {
        return new Dragboard(peer);
    }

    // PENDING_DOC_REVIEW
    /**
     * Sets the visual representation of data being transfered
     * in a drag and drop gesture.
     * Uses the given image for the drag view with the offsetX and offsetY
     * specifying cursor position over the image.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param image image to use for the drag view
     * @param offsetX x position of the cursor over the image
<A NAME="4"></A>     * @param offsetY y position of the cursor over the image
     * @since JavaFX 8.0
     */
    public void setDragView(Image image, <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#4',2,'match45-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>double offsetX, double offsetY) {
        peer.setDragView(image);
        peer.setDragViewOffsetX(offsetX);
        peer.setDragViewOffsetY(offsetY);
    }

    /**
     * Sets the visual representation of data being transfered
     * in a drag and drop gesture.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param image image to use for the drag view
     * @since JavaFX 8.0
     */
    public void setDragView(Image image) {
        peer.setDragView(image);
    }

    /**
     * Sets the x position of the cursor of the drag view image.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param offsetX x position of the cursor over the image
     * @since JavaFX 8.0
     */
    public void setDragViewOffsetX(double offsetX) {</B></FONT>
        peer.setDragViewOffsetX(offsetX);
    }

    /**
     * Sets the y position of the cursor of the drag view image.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param offsetY y position of the cursor over the image
     * @since JavaFX 8.0
     */
    public void setDragViewOffsetY(double offsetY) {
        peer.setDragViewOffsetY(offsetY);
    }

    /**
     * Gets the image used as a drag view.
     * This method returns meaningful value only when starting drag and drop
     * operation in the DRAG_DETECTED handler, it returns null at other times.
     * @return the image used as a drag view
     * @since JavaFX 8.0
     */
    public Image getDragView() {
        return peer.getDragView();
    }

    /**
     * Gets the x position of the cursor of the drag view image.
     * This method returns meaningful value only when starting drag and drop
     * operation in the DRAG_DETECTED handler, it returns 0 at other times.
     * @return x position of the cursor over the image
     * @since JavaFX 8.0
     */
    public double getDragViewOffsetX() {
        return peer.getDragViewOffsetX();
    }

    /**
     * Gets the y position of the cursor of the drag view image.
     * This method returns meaningful value only when starting drag and drop
     * operation in the DRAG_DETECTED handler, it returns 0 at other times.
     * @return y position of the cursor over the image
     * @since JavaFX 8.0
     */
    public double getDragViewOffsetY() {
        return peer.getDragViewOffsetY();
    }

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        DragboardHelper.setDragboardAccessor(new DragboardHelper.DragboardAccessor() {

            @Override
            public void setDataAccessRestriction(Dragboard dragboard, boolean restricted) {
                dragboard.dataAccessRestricted = restricted;
            }

            @Override
            public TKClipboard getPeer(Dragboard dragboard) {
                return dragboard.getPeer();
            }

            @Override
            public Dragboard createDragboard(TKClipboard peer) {
                return Dragboard.createDragboard(peer);
            }
        });
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/TriangleMesh.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.scene.shape.ObservableFaceArrayImpl;
import com.sun.javafx.collections.FloatArraySyncer;
import com.sun.javafx.collections.IntegerArraySyncer;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.shape.TriangleMeshHelper;
import com.sun.javafx.sg.prism.NGTriangleMesh;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ArrayChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ObservableArray;
import javafx.collections.ObservableFloatArray;
import javafx.collections.ObservableIntegerArray;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.scene.Node;
import javafx.scene.input.PickResult;
import javafx.scene.transform.Affine;
import javafx.scene.transform.NonInvertibleTransformException;
import javafx.scene.transform.Rotate;
import com.sun.javafx.logging.PlatformLogger;

/**
 * Defines a 3D triangle mesh that consists of its associated {@code VertexFormat}
 * and a set of separate arrays of vertex components such as points, normals,
 * texture coordinates, and an array of faces that define the individual triangles
 * of the mesh.
 *&lt;p&gt;
 * Note that the term point, as used in the method names and method
 * descriptions, actually refers to a 3D point (x, y, z) in space
 * representing the position of a single vertex. The term points (plural) is
 * used to indicate sets of 3D points for multiple vertices.
 * Similarly, the term normal is used to indicate a 3D vector (nx, ny, nz) in space
 * representing the direction of a single vertex. The term normals (plural) is
 * used to indicate sets of 3D vectors for multiple vertices.
 * The term texCoord is used to indicate a single pair of 2D texture
 * coordinates (u, v) for a single vertex, while the term texCoords (plural) is used
 * to indicate sets of texture coordinates for multiple vertices.
 * Lastly, the term face is used to indicate 3 sets of interleaving points,
 * normals (optional, depending on the associated VertexFormat)
 * and texture coordinates that together represent the geometric topology of a
 * single triangle, while the term faces (plural) is used to indicate sets of
 * triangles (each represent by a face).
 * &lt;p&gt;
 * For example, the faces with {@code VertexFormat.POINT_TEXCOORD} that represent
 * a single textured rectangle, using 2 triangles, have the following data order: [
 * &lt;p&gt;
 * p0, t0, p1, t1, p3, t3,  // First triangle of a textured rectangle
 * &lt;p&gt;
 * p1, t1, p2, t2, p3, t3   // Second triangle of a textured rectangle
 * &lt;p&gt;
 * ]
 * &lt;p&gt;
 * whereas the faces with {@code VertexFormat.POINT_NORMAL_TEXCOORD} that represent
 * a single textured rectangle, using 2 triangles, have the following data order: [
 * &lt;p&gt;
 * p0, n0, t0, p1, n1, t1, p3, n3, t3,  // First triangle of a textured rectangle
 * &lt;p&gt;
 * p1, n1, t1, p2, n2, t2, p3, n3, t3   // Second triangle of a textured rectangle
 * &lt;p&gt;
 * ]
 * &lt;p&gt;
 * where p0, p1, p2 and p3 are indices into the points array, n0, n1, n2 and n3
 * are indices into the normals array, and t0, t1, t2 and t3 are indices into
 * the texCoords array.
 *
 * &lt;p&gt;
 * A triangle has a front and back face. The winding order of a triangle's vertices
 * determines which side is the front face. JavaFX chooses the counter-clockwise
 * (or right-hand rule) winding order as the front face. By default, only the
 * front face of a triangle is rendered. See {@code CullFace} for more
 * information.
 *
 * &lt;p&gt;
 * The length of {@code points}, {@code normals}, and {@code texCoords} must be
 * divisible by 3, 3, and 2 respectively. The length of {@code faces} must be
 * divisible by 6 if it is of {@code VertexFormat.POINT_TEXCOORD} else it must
 * be divisible by 9 if it is of {@code VertexFormat.POINT_NORMAL_TEXCOORD}.
 * The values in the faces array must be within the range of the number of vertices
 * in the points array (0 to points.length / 3 - 1) for the point indices, within
 * the range of the number of vertices in the normals array
 * (0 to normals.length / 3 - 1) for the normal indices, and within the range of
 * the number of the vertices in the texCoords array (0 to texCoords.length / 2 - 1)
 * for the texture coordinate indices.
 *
 * &lt;p&gt; A warning will be recorded to the logger and the mesh will not be rendered
 * (and will have an empty bounds) if any of the array lengths are invalid
 * or if any of the values in the faces array are out of range.
 *
 * @since JavaFX 8.0
 */
public class TriangleMesh extends Mesh {
    static {
        TriangleMeshHelper.setTriangleMeshAccessor(new TriangleMeshHelper.TriangleMeshAccessor() {
            @Override
            public boolean doComputeIntersects(Mesh mesh, PickRay pickRay,
                    PickResultChooser pickResult, Node candidate, CullFace cullFace,
                    boolean reportFace) {
                return ((TriangleMesh) mesh).doComputeIntersects(pickRay,
                        pickResult, candidate, cullFace, reportFace);
            }
        });
    }

    private final ObservableFloatArray points = FXCollections.observableFloatArray();
    private final ObservableFloatArray normals = FXCollections.observableFloatArray();
    private final ObservableFloatArray texCoords = FXCollections.observableFloatArray();
    private final ObservableFaceArray faces = new ObservableFaceArrayImpl();
    private final ObservableIntegerArray faceSmoothingGroups = FXCollections.observableIntegerArray();

    private final Listener pointsSyncer = new Listener(points);
    private final Listener normalsSyncer = new Listener(normals);
    private final Listener texCoordsSyncer = new Listener(texCoords);
    private final Listener facesSyncer = new Listener(faces);
<A NAME="17"></A>    private final Listener faceSmoothingGroupsSyncer = new Listener(faceSmoothingGroups);
    private final boolean isPredefinedShape;
    private boolean isValidDirty = true;
    <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#17',2,'match45-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private boolean isPointsValid, isNormalsValid, isTexCoordsValid, isFacesValid, isFaceSmoothingGroupValid;
    private int refCount = 1;

    private BaseBounds cachedBounds;

    /**
     * Creates a new instance of {@code TriangleMesh} class with the default
     * {@code VertexFormat.POINT_TEXCOORD} format type.
     */
    public TriangleMesh() {
        this(false);
        TriangleMeshHelper.initHelper(this);
    }

    /**
     * Creates a new instance of {@code TriangleMesh} class with the specified
     * {@code VertexFormat}.
     *
     * @param vertexFormat specifies the vertex format type.
     *
     * @since JavaFX 8u40
     */
    public</B></FONT> TriangleMesh(VertexFormat vertexFormat) {
        this(false);
        this.setVertexFormat(vertexFormat);
        TriangleMeshHelper.initHelper(this);
    }

    TriangleMesh(boolean isPredefinedShape) {
        this.isPredefinedShape = isPredefinedShape;
        if (isPredefinedShape) {
            isPointsValid = true;
            isNormalsValid = true;
            isTexCoordsValid = true;
            isFacesValid = true;
            isFaceSmoothingGroupValid = true;
        } else {
            isPointsValid = false;
            isNormalsValid = false;
            isTexCoordsValid = false;
            isFacesValid = false;
            isFaceSmoothingGroupValid = false;
        }
        TriangleMeshHelper.initHelper(this);
    }

    /**
     * Specifies the vertex format of this {@code TriangleMesh}, one of
     * {@code VertexFormat.POINT_TEXCOORD} or {@code VertexFormat.POINT_NORMAL_TEXCOORD}.
     *
     * @defaultValue VertexFormat.POINT_TEXCOORD
     *
     * @since JavaFX 8u40
     */
    private ObjectProperty&lt;VertexFormat&gt; vertexFormat;

    public final void setVertexFormat(VertexFormat value) {
        vertexFormatProperty().set(value);
    }

    public final VertexFormat getVertexFormat() {
        return vertexFormat == null ? VertexFormat.POINT_TEXCOORD : vertexFormat.get();
    }

    public final ObjectProperty&lt;VertexFormat&gt; vertexFormatProperty() {
        if (vertexFormat == null) {
            vertexFormat = new SimpleObjectProperty&lt;VertexFormat&gt;(TriangleMesh.this, &quot;vertexFormat&quot;) {

                @Override
                protected void invalidated() {
                    setDirty(true);
                    // Need to mark faces and faceSmoothingGroups dirty too.
                    facesSyncer.setDirty(true);
                    faceSmoothingGroupsSyncer.setDirty(true);
                }
            };
        }
        return vertexFormat;
    }

    /**
     * Returns the number of elements that represents a point.
     *
     * @return number of elements
     */
    public final int getPointElementSize() {
        return getVertexFormat().getPointElementSize();
    }

    /**
     * Returns the number of elements that represents a normal.
     *
     * @return number of elements
     *
     * @since JavaFX 8u40
     */
    public final int getNormalElementSize() {
        return getVertexFormat().getNormalElementSize();
    }

    /**
     * Returns the number of elements that represents a texture coordinates.
     *
     * @return number of elements
     */
    public final int getTexCoordElementSize() {
        return getVertexFormat().getTexCoordElementSize();
    }

    /**
     * Returns the number of elements that represents a face.
     *
     * @return number of elements
     */
    public final int getFaceElementSize() {
        return getVertexFormat().getVertexIndexSize() * 3;
    }

    /**
     * Gets the {@code points} array of this {@code TriangleMesh}.
     *
     * @return {@code points} array where each point is
     * represented by 3 float values x, y and z, in that order.
     */
    public final ObservableFloatArray getPoints() {
        return points;
    }

    /**
     * Gets the {@code normals} array of this {@code TriangleMesh}.
     *
     * @return {@code normals} array where each normal is
     * represented by 3 float values nx, ny and nz, in that order.
     *
     * @since JavaFX 8u40
     */
    public final ObservableFloatArray getNormals() {
        return normals;
    }

    /**
     * Gets the  {@code texCoords} array of this {@code TriangleMesh}.
     * The coordinates are proportional, so texture's top-left corner
     * is at [0, 0] and bottom-right corner is at [1, 1].
     *
     * @return {@code texCoord} array where each texture coordinate is represented
     * by 2 float values: u and v, in that order.
     */
    public final ObservableFloatArray getTexCoords() {
        return texCoords;
    }

    /**
     * Gets the {@code faces} array, indices into the {@code points},
     * {@code normals} (optional, if it is a {@code VertexFormat.POINT_NORMAL_TEXCOORD}
     * mesh) and {@code texCoords} arrays, of this  {@code TriangleMesh}. All
     * indices are in terms of elements in to the points, normals or texCoords
     * arrays not individual floats.
     *
     * @return {@code faces} array where each face is of
     * 3 * {@code VertexFormat.getVertexIndexSize()} integers.
     */
    public final ObservableFaceArray getFaces() {
        return faces;
    }

    /**
     * Gets the {@code faceSmoothingGroups} array of this {@code TriangleMesh}.
     * Smoothing affects how a mesh is rendered but it does not effect its
     * geometry. The face smoothing group value is used to control the smoothing
     * between adjacent faces.
     *
     * &lt;p&gt;
     * {@literal The face smoothing group value is represented by an array of bits and up to
     * 32 unique groups is possible; (1 &lt;&lt; 0) to (1 &lt;&lt; 31). The face smoothing
     * group value can range from 0 (no smoothing group) to all 32 groups. A face
     * can belong to zero or more smoothing groups. A face is a member of group
     * N if bit N is set, for example, groups |= (1 &lt;&lt; N). A value of 0 implies
     * no smoothing group or hard edges.}
     * Smoothing is applied when adjacent pair of faces shared a smoothing group.
     * Otherwise the faces are rendered with a hard edge between them.
     *
     * &lt;p&gt; An empty faceSmoothingGroups implies all faces in this mesh have a
     * smoothing group value of 1.
     *
     * &lt;p&gt; If faceSmoothingGroups is not empty, its size must
     * be equal to number of faces.
     *
     * &lt;p&gt; This faceSmoothingGroups has no effect on its {@code TriangleMesh} if
     * it is of {@code VertexFormat.POINT_NORMAL_TEXCOORD} format.
     * @return the {@code faceSmoothingGroups} array of this {@code TriangleMesh}
     */
    public final ObservableIntegerArray getFaceSmoothingGroups() {
        return faceSmoothingGroups;
    }

    @Override void setDirty(boolean value) {
        super.setDirty(value);
        if (!value) { // false
            pointsSyncer.setDirty(false);
            normalsSyncer.setDirty(false);
            texCoordsSyncer.setDirty(false);
            facesSyncer.setDirty(false);
            faceSmoothingGroupsSyncer.setDirty(false);
        }
    }

    int getRefCount() {
        return refCount;
    }

    synchronized void incRef() {
        this.refCount += 1;
    }

    synchronized void decRef() {
        this.refCount -= 1;
    }

    private NGTriangleMesh peer;

    /* The peer node created by the graphics Toolkit/Pipeline implementation */
    NGTriangleMesh getPGTriangleMesh() {
        if (peer == null) {
            peer = new NGTriangleMesh();
        }
        return peer;
    }

    @Override
    NGTriangleMesh getPGMesh() {
        return getPGTriangleMesh();
    }

    private boolean validatePoints() {
        if (points.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        if ((points.size() % getVertexFormat().getPointElementSize()) != 0) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;points.size() has &quot;
                    + &quot;to be divisible by getPointElementSize(). It is to&quot;
                    + &quot; store multiple x, y, and z coordinates of this mesh&quot;);
            return false;
        }
        return true;
    }

    private boolean validateNormals() {
        // Only validate normals if vertex format has normal component
        if (getVertexFormat() != VertexFormat.POINT_NORMAL_TEXCOORD) return true;

        if (normals.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        if ((normals.size() % getVertexFormat().getNormalElementSize()) != 0) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;normals.size() has &quot;
                    + &quot;to be divisible by getNormalElementSize(). It is to&quot;
                    + &quot; store multiple nx, ny, and nz coordinates of this mesh&quot;);
            return false;
        }
        return true;
    }

    private boolean validateTexCoords() {
        if (texCoords.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        if ((texCoords.size() % getVertexFormat().getTexCoordElementSize()) != 0) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;texCoords.size() &quot;
                    + &quot;has to be divisible by getTexCoordElementSize().&quot;
                    + &quot; It is to store multiple u and v texture coordinates&quot;
                    + &quot; of this mesh&quot;);
            return false;
        }
        return true;
    }

    private boolean validateFaces() {
        if (faces.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        String logname = TriangleMesh.class.getName();
        if ((faces.size() % getFaceElementSize()) != 0) {
            PlatformLogger.getLogger(logname).warning(&quot;faces.size() has &quot;
                    + &quot;to be divisible by getFaceElementSize().&quot;);
            return false;
        }

        if (getVertexFormat() == VertexFormat.POINT_TEXCOORD) {
            int nVerts = points.size() / getVertexFormat().getPointElementSize();
            int nTVerts = texCoords.size() / getVertexFormat().getTexCoordElementSize();
            for (int i = 0; i &lt; faces.size(); i++) {
                if (i % 2 == 0 &amp;&amp; (faces.get(i) &gt;= nVerts || faces.get(i) &lt; 0)
                        || (i % 2 != 0 &amp;&amp; (faces.get(i) &gt;= nTVerts || faces.get(i) &lt; 0))) {
                    PlatformLogger.getLogger(logname).warning(&quot;The values in the &quot;
                            + &quot;faces array must be within the range of the number &quot;
                            + &quot;of vertices in the points array (0 to points.length / 3 - 1) &quot;
                            + &quot;for the point indices and within the range of the &quot;
                            + &quot;number of the vertices in the texCoords array (0 to &quot;
                            + &quot;texCoords.length / 2 - 1) for the texture coordinate indices.&quot;);
                    return false;
                }
            }
        } else if (getVertexFormat() == VertexFormat.POINT_NORMAL_TEXCOORD) {
            int nVerts = points.size() / getVertexFormat().getPointElementSize();
            int nNVerts =  normals.size() / getVertexFormat().getNormalElementSize();
            int nTVerts = texCoords.size() / getVertexFormat().getTexCoordElementSize();
            for (int i = 0; i &lt; faces.size(); i+=3) {
                if ((faces.get(i) &gt;= nVerts || faces.get(i) &lt; 0)
                        || (faces.get(i + 1) &gt;= nNVerts || faces.get(i + 1) &lt; 0)
                        || (faces.get(i + 2) &gt;= nTVerts || faces.get(i + 2) &lt; 0)) {
                    PlatformLogger.getLogger(logname).warning(&quot;The values in the &quot;
                            + &quot;faces array must be within the range of the number &quot;
                            + &quot;of vertices in the points array (0 to points.length / 3 - 1) &quot;
                            + &quot;for the point indices, and within the range of the &quot;
                            + &quot;number of the vertices in the normals array (0 to &quot;
                            + &quot;normals.length / 3 - 1) for the normals indices, and &quot;
                            + &quot;number of the vertices in the texCoords array (0 to &quot;
                            + &quot;texCoords.length / 2 - 1) for the texture coordinate indices.&quot;);
                    return false;
                }
            }
        } else {
            PlatformLogger.getLogger(logname).warning(&quot;Unsupported VertexFormat: &quot; + getVertexFormat().toString());
            return false;
        }
        return true;
    }

    private boolean validateFaceSmoothingGroups() {
        if (faceSmoothingGroups.size() != 0
                &amp;&amp; faceSmoothingGroups.size() != (faces.size() / getFaceElementSize())) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;faceSmoothingGroups.size()&quot;
                    + &quot; has to equal to number of faces.&quot;);
            return false;
        }
        return true;
    }

    private boolean validate() {
        if (isPredefinedShape) {
            return true;
        }

        if (isValidDirty) {
            if (pointsSyncer.dirtyInFull) {
                isPointsValid = validatePoints();
            }
            if (normalsSyncer.dirtyInFull) {
                isNormalsValid = validateNormals();
            }
            if (texCoordsSyncer.dirtyInFull) {
                isTexCoordsValid = validateTexCoords();
            }
            if (facesSyncer.dirty || pointsSyncer.dirtyInFull
                    || normalsSyncer.dirtyInFull || texCoordsSyncer.dirtyInFull) {
                isFacesValid = isPointsValid &amp;&amp; isNormalsValid
                        &amp;&amp; isTexCoordsValid &amp;&amp; validateFaces();
            }
            if (faceSmoothingGroupsSyncer.dirtyInFull || facesSyncer.dirtyInFull) {
                isFaceSmoothingGroupValid = isFacesValid &amp;&amp; validateFaceSmoothingGroups();
            }
            isValidDirty = false;
        }
        return isPointsValid &amp;&amp; isNormalsValid &amp;&amp; isTexCoordsValid
                &amp;&amp; isFaceSmoothingGroupValid &amp;&amp; isFacesValid;
    }

    @Override
    void updatePG() {
        if (!isDirty()) {
            return;
        }

        final NGTriangleMesh pgTriMesh = getPGTriangleMesh();
        if (validate()) {
            pgTriMesh.setUserDefinedNormals(getVertexFormat() == VertexFormat.POINT_NORMAL_TEXCOORD);
            pgTriMesh.syncPoints(pointsSyncer);
            pgTriMesh.syncNormals(normalsSyncer);
            pgTriMesh.syncTexCoords(texCoordsSyncer);
            pgTriMesh.syncFaces(facesSyncer);
            pgTriMesh.syncFaceSmoothingGroups(faceSmoothingGroupsSyncer);
        } else {
            pgTriMesh.setUserDefinedNormals(false);
            pgTriMesh.syncPoints(null);
            pgTriMesh.syncNormals(null);
            pgTriMesh.syncTexCoords(null);
            pgTriMesh.syncFaces(null);
            pgTriMesh.syncFaceSmoothingGroups(null);
        }
        setDirty(false);
    }

    @Override
    BaseBounds computeBounds(BaseBounds bounds) {
        if (isDirty() || cachedBounds == null) {
            cachedBounds = new BoxBounds();
            if (validate()) {
                final int len = points.size();
                final int pointElementSize = getVertexFormat().getPointElementSize();
                for (int i = 0; i &lt; len; i += pointElementSize) {
                    cachedBounds.add(points.get(i), points.get(i + 1), points.get(i + 2));
                }
            }
        }
        return bounds.deriveWithNewBounds(cachedBounds);
    }

    /**
     * Computes the centroid of the given triangle
     * @param v0x x coord of first vertex of the triangle
     * @param v0y y coord of first vertex of the triangle
     * @param v0z z coord of first vertex of the triangle
     * @param v1x x coord of second vertex of the triangle
     * @param v1y y coord of second vertex of the triangle
     * @param v1z z coord of second vertex of the triangle
     * @param v2x x coord of third vertex of the triangle
     * @param v2y y coord of third vertex of the triangle
     * @param v2z z coord of third vertex of the triangle
     * @return the triangle centroid
     */
    private Point3D computeCentroid(
            double v0x, double v0y, double v0z,
            double v1x, double v1y, double v1z,
            double v2x, double v2y, double v2z) {

//        Point3D center = v1.midpoint(v2);
//        Point3D vec = center.subtract(v0);
//        return v0.add(new Point3D(vec.getX() / 3.0, vec.getY() / 3.0, vec.getZ() / 3.0));

        return new Point3D(
            v0x + (v2x + (v1x - v2x) / 2.0 - v0x) / 3.0,
            v0y + (v2y + (v1y - v2y) / 2.0 - v0y) / 3.0,
            v0z + (v2z + (v1z - v2z) / 2.0 - v0z) / 3.0);
    }

    /**
     * Computes the centroid of the given triangle
     * @param v0 vertex of the triangle
     * @param v1 vertex of the triangle
     * @param v2 vertex of the triangle
     * @return the triangle centroid
     */
    private Point2D computeCentroid(Point2D v0, Point2D v1, Point2D v2) {
        Point2D center = v1.midpoint(v2);

        Point2D vec = center.subtract(v0);
        return v0.add(new Point2D(vec.getX() / 3.0, vec.getY() / 3.0));
    }

    /**
     * Computes intersection of a pick ray and a single triangle face.
     *
     * It takes pickRay, origin and dir. The latter two can be of course obtained
     * from the pickRay, but we need them to be converted to Point3D and don't
     * want to do that for all faces. Therefore the conversion is done just once
     * and passed to the method for all the faces.
     *
     * @param pickRay pick ray
     * @param origin pick ray's origin
     * @param dir pick ray's direction
     * @param faceIndex index of the face to test
     * @param cullFace cull face of the Node (and thus the tested face)
     * @param candidate the owner node (for the possible placement to the result)
     * @param reportFace whether or not to report he hit face
     * @param result the pick result to be updated if a closer intersection is found
     * @return true if the pick ray intersects with the face (regardless of whether
     *              the result has been updated)
     */
    private boolean computeIntersectsFace(
            PickRay pickRay, Vec3d origin, Vec3d dir, int faceIndex,
            CullFace cullFace, Node candidate, boolean reportFace, PickResultChooser result) {//, BoxBounds rayBounds) {

        // This computation was naturally done by Point3D and its operations,
        // but it needs a lot of points and there is often a lot of triangles
        // so it is vital for performance to use only primitive variables
        // and do the computing manually.

        int vertexIndexSize = getVertexFormat().getVertexIndexSize();
        int pointElementSize = getVertexFormat().getPointElementSize();
        final int v0Idx = faces.get(faceIndex) * pointElementSize;
        final int v1Idx = faces.get(faceIndex + vertexIndexSize) * pointElementSize;
        final int v2Idx = faces.get(faceIndex + (2 * vertexIndexSize)) * pointElementSize;

        final float v0x = points.get(v0Idx);
        final float v0y = points.get(v0Idx + 1);
        final float v0z = points.get(v0Idx + 2);
        final float v1x = points.get(v1Idx);
        final float v1y = points.get(v1Idx + 1);
        final float v1z = points.get(v1Idx + 2);
        final float v2x = points.get(v2Idx);
        final float v2y = points.get(v2Idx + 1);
        final float v2z = points.get(v2Idx + 2);

        // e1 = v1.subtract(v0)
        final float e1x = v1x - v0x;
        final float e1y = v1y - v0y;
        final float e1z = v1z - v0z;
        // e2 = v2.subtract(v0)
        final float e2x = v2x - v0x;
        final float e2y = v2y - v0y;
        final float e2z = v2z - v0z;

        // h = dir.crossProduct(e2)
        final double hx = dir.y * e2z - dir.z * e2y;
        final double hy = dir.z * e2x - dir.x * e2z;
        final double hz = dir.x * e2y - dir.y * e2x;

        // a = e1.dotProduct(h)
        final double a = e1x * hx + e1y * hy + e1z * hz;
        if (a == 0.0) {
            return false;
        }
        final double f = 1.0 / a;

        // s = origin.subtract(v0)
        final double sx = origin.x - v0x;
        final double sy = origin.y - v0y;
        final double sz = origin.z - v0z;

        // u = f * (s.dotProduct(h))
        final double u = f * (sx * hx + sy * hy + sz * hz);

        if (u &lt; 0.0 || u &gt; 1.0) {
            return false;
        }

        // q = s.crossProduct(e1)
        final double qx = sy * e1z - sz * e1y;
        final double qy = sz * e1x - sx * e1z;
        final double qz = sx * e1y - sy * e1x;

        // v = f * dir.dotProduct(q)
        double v = f * (dir.x * qx + dir.y * qy + dir.z * qz);

        if (v &lt; 0.0 || u + v &gt; 1.0) {
            return false;
        }

        // t = f * e2.dotProduct(q)
        final double t = f * (e2x * qx + e2y * qy + e2z * qz);

        if (t &gt;= pickRay.getNearClip() &amp;&amp; t &lt;= pickRay.getFarClip()) {
            // This branch is entered only for hit triangles (not so often),
            // so we can get smoothly back to the nice code using Point3Ds.

            if (cullFace != CullFace.NONE) {
                // normal = e1.crossProduct(e2)
                final Point3D normal = new Point3D(
                    e1y * e2z - e1z * e2y,
                    e1z * e2x - e1x * e2z,
                    e1x * e2y - e1y * e2x);

                final double nangle = normal.angle(
                        new Point3D(-dir.x, -dir.y, -dir.z));
                if ((nangle &gt;= 90 || cullFace != CullFace.BACK) &amp;&amp;
                        (nangle &lt;= 90 || cullFace != CullFace.FRONT)) {
                    // hit culled face
                    return false;
                }
            }

            if (Double.isInfinite(t) || Double.isNaN(t)) {
                // we've got a nonsense pick ray or triangle
                return false;
            }

            if (result == null || !result.isCloser(t)) {
                // it intersects, but we are not interested in the result
                // or we already have a better (closer) result
                // so we can omit the point and texture computation
                return true;
            }

            Point3D point = PickResultChooser.computePoint(pickRay, t);

            // Now compute texture mapping. First rotate the triangle
            // so that we can compute in 2D

            // centroid = computeCentroid(v0, v1, v2);
            final Point3D centroid = computeCentroid(
                    v0x, v0y, v0z,
                    v1x, v1y, v1z,
                    v2x, v2y, v2z);

            // cv0 = v0.subtract(centroid)
            final Point3D cv0 = new Point3D(
                    v0x - centroid.getX(),
                    v0y - centroid.getY(),
                    v0z - centroid.getZ());
            // cv1 = v1.subtract(centroid)
            final Point3D cv1 = new Point3D(
                    v1x - centroid.getX(),
                    v1y - centroid.getY(),
                    v1z - centroid.getZ());
            // cv2 = v2.subtract(centroid)
            final Point3D cv2 = new Point3D(
                    v2x - centroid.getX(),
                    v2y - centroid.getY(),
                    v2z - centroid.getZ());

            final Point3D ce1 = cv1.subtract(cv0);
            final Point3D ce2 = cv2.subtract(cv0);
            Point3D n = ce1.crossProduct(ce2);
            if (n.getZ() &lt; 0) {
                n = new Point3D(-n.getX(), -n.getY(), -n.getZ());
            }
            final Point3D ax = n.crossProduct(Rotate.Z_AXIS);
            final double angle = Math.atan2(ax.magnitude(), n.dotProduct(Rotate.Z_AXIS));

            Rotate r = new Rotate(Math.toDegrees(angle), ax);
            final Point3D crv0 = r.transform(cv0);
            final Point3D crv1 = r.transform(cv1);
            final Point3D crv2 = r.transform(cv2);
            final Point3D rPoint = r.transform(point.subtract(centroid));

            final Point2D flatV0 = new Point2D(crv0.getX(), crv0.getY());
            final Point2D flatV1 = new Point2D(crv1.getX(), crv1.getY());
            final Point2D flatV2 = new Point2D(crv2.getX(), crv2.getY());
            final Point2D flatPoint = new Point2D(rPoint.getX(), rPoint.getY());

            // Obtain the texture triangle
            int texCoordElementSize = getVertexFormat().getTexCoordElementSize();
            int texCoordOffset = getVertexFormat().getTexCoordIndexOffset();
            final int t0Idx = faces.get(faceIndex + texCoordOffset) * texCoordElementSize;
            final int t1Idx = faces.get(faceIndex + vertexIndexSize + texCoordOffset) * texCoordElementSize;
            final int t2Idx = faces.get(faceIndex + (vertexIndexSize * 2) + texCoordOffset) * texCoordElementSize;

            final Point2D u0 = new Point2D(texCoords.get(t0Idx), texCoords.get(t0Idx + 1));
            final Point2D u1 = new Point2D(texCoords.get(t1Idx), texCoords.get(t1Idx + 1));
            final Point2D u2 = new Point2D(texCoords.get(t2Idx), texCoords.get(t2Idx + 1));

            final Point2D txCentroid = computeCentroid(u0, u1, u2);

            final Point2D cu0 = u0.subtract(txCentroid);
            final Point2D cu1 = u1.subtract(txCentroid);
            final Point2D cu2 = u2.subtract(txCentroid);

            // Find the transform between the two triangles

            final Affine src = new Affine(
                    flatV0.getX(), flatV1.getX(), flatV2.getX(),
                    flatV0.getY(), flatV1.getY(), flatV2.getY());
            final Affine trg = new Affine(
                    cu0.getX(), cu1.getX(), cu2.getX(),
                    cu0.getY(), cu1.getY(), cu2.getY());

            Point2D txCoords = null;

            try {
                src.invert();
                trg.append(src);
                txCoords = txCentroid.add(trg.transform(flatPoint));
            } catch (NonInvertibleTransformException e) {
                // Can't compute texture mapping, probably the coordinates
                // don't make sense. Ignore it and return null tex coords.
            }

            result.offer(candidate, t,
                    reportFace ? faceIndex / getFaceElementSize() : PickResult.FACE_UNDEFINED,
                    point, txCoords);
            return true;
        }

        return false;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult,
            Node candidate, CullFace cullFace, boolean reportFace) {

        boolean found = false;
        if (validate()) {
            final int size = faces.size();

            final Vec3d o = pickRay.getOriginNoClone();

            final Vec3d d = pickRay.getDirectionNoClone();

            for (int i = 0; i &lt; size; i += getFaceElementSize()) {
                if (computeIntersectsFace(pickRay, o, d, i, cullFace, candidate,
                        reportFace, pickResult)) {
                    found = true;
                }
            }
        }
        return found;
    }

    private class Listener&lt;T extends ObservableArray&lt;T&gt;&gt; implements ArrayChangeListener&lt;T&gt;, FloatArraySyncer, IntegerArraySyncer {

        protected final T array;
        protected boolean dirty = true;
        /**
         * Array was replaced
         * @return true if array was replaced; false otherwise
         */
        protected boolean dirtyInFull = true;
        protected int dirtyRangeFrom;
        protected int dirtyRangeLength;

        public Listener(T array) {
            this.array = array;
            array.addListener(this);
        }

        /**
         * Adds a dirty range
         * @param from index of the first modified element
         * @param length length of the modified range
         */
        protected final void addDirtyRange(int from, int length) {
            if (length &gt; 0 &amp;&amp; !dirtyInFull) {
                markDirty();
                if (dirtyRangeLength == 0) {
                    dirtyRangeFrom = from;
                    dirtyRangeLength = length;
                } else {
                    int fromIndex = Math.min(dirtyRangeFrom, from);
                    int toIndex = Math.max(dirtyRangeFrom + dirtyRangeLength, from + length);
                    dirtyRangeFrom = fromIndex;
                    dirtyRangeLength = toIndex - fromIndex;
                }
            }
        }

        protected void markDirty() {
            dirty = true;
            TriangleMesh.this.setDirty(true);
        }

        @Override
        public void onChanged(T observableArray, boolean sizeChanged, int from, int to) {
            if (sizeChanged) {
                setDirty(true);
            } else {
                addDirtyRange(from, to - from);
            }
            isValidDirty = true;
        }

        /**
         * @param dirty if true, the whole collection is marked as dirty;
         * if false, the whole collection is marked as not-dirty
         */
        public final void setDirty(boolean dirty) {
            this.dirtyInFull = dirty;
            if (dirty) {
                markDirty();
                dirtyRangeFrom = 0;
                dirtyRangeLength = array.size();
            } else {
                this.dirty = false;
                dirtyRangeFrom = dirtyRangeLength = 0;
            }
        }

        @Override
        public float[] syncTo(float[] array, int[] fromAndLengthIndices) {
            assert ((fromAndLengthIndices != null) &amp;&amp; (fromAndLengthIndices.length == 2));
            ObservableFloatArray floatArray = (ObservableFloatArray) this.array;
            if (dirtyInFull || array == null || array.length != floatArray.size()) {
                // Always allocate a new array when size changes
                fromAndLengthIndices[0] = 0;
                fromAndLengthIndices[1] = floatArray.size();
                return floatArray.toArray(null);
            }
            fromAndLengthIndices[0] = dirtyRangeFrom;
            fromAndLengthIndices[1] = dirtyRangeLength;
            floatArray.copyTo(dirtyRangeFrom, array, dirtyRangeFrom, dirtyRangeLength);
            return array;
        }

        @Override
        public int[] syncTo(int[] array, int[] fromAndLengthIndices) {
            assert ((fromAndLengthIndices != null) &amp;&amp; (fromAndLengthIndices.length == 2));
            ObservableIntegerArray intArray = (ObservableIntegerArray) this.array;
            if (dirtyInFull || array == null || array.length != intArray.size()) {
                fromAndLengthIndices[0] = 0;
                fromAndLengthIndices[1] = intArray.size();
                // Always allocate a new array when size changes
                return intArray.toArray(null);
            }
            fromAndLengthIndices[0] = dirtyRangeFrom;
            fromAndLengthIndices[1] = dirtyRangeLength;
            intArray.copyTo(dirtyRangeFrom, array, dirtyRangeFrom, dirtyRangeLength);
            return array;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Scale.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;

import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;


/**
 * This class represents an {@code Affine} object that scales coordinates
 * by the specified factors. The matrix representing the scaling transformation
 * around a pivot point {@code (pivotX, pivotY, pivotZ)} with scaling factors
 * {@code x}, {@code y} and {@code z} is as follows:
 * &lt;pre&gt;
 *              [   x   0   0   (1-x)*pivotX   ]
 *              [   0   y   0   (1-y)*pivotY   ]
 *              [   0   0   z   (1-z)*pivotZ   ]
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Scale extends Transform {
    /**
     * Creates a default Scale (identity).
     */
    public Scale() {
    }

    /**
     * Creates a two-dimensional Scale.
     * The pivot point is set to (0,0)
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     */
    public Scale(double x, double y) {
        setX(x);
        setY(y);
    }

    /**
     * Creates a two-dimensional Scale with pivot.
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     * @param pivotX the X coordinate about which point the scale occurs
     * @param pivotY the Y coordinate about which point the scale occurs
     */
    public Scale(double x, double y, double pivotX, double pivotY) {
        this(x, y);
        setPivotX(pivotX);
        setPivotY(pivotY);
    }

    /**
     * Creates a three-dimensional Scale.
     * The pivot point is set to (0,0,0)
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     * @param z the factor by which coordinates are scaled along the Z axis
     */
    public Scale(double x, double y, double z) {
        this(x, y);
        setZ(z);
    }

    /**
     * Creates a three-dimensional Scale with pivot.
     * @param x the factor by which coordinates are scaled along the X axis
     * @param y the factor by which coordinates are scaled along the Y axis
     * @param z the factor by which coordinates are scaled along the Z axis
     * @param pivotX the X coordinate about which point the scale occurs
     * @param pivotY the Y coordinate about which point the scale occurs
     * @param pivotZ the Z coordinate about which point the scale occurs
     */
    public Scale(double x, double y, double z, double pivotX, double pivotY, double pivotZ) {
        this(x, y, pivotX, pivotY);
        setZ(z);
        setPivotZ(pivotZ);
    }

    /**
     * Defines the factor by which coordinates are scaled
     * along the X axis direction. The default value is {@code 1.0}.
     */
    private DoubleProperty x;


    public final void setX(double value) {
        xProperty().set(value);
    }

    public final double getX() {
        return x == null ? 1.0F : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase(1.0F) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;x&quot;;
                }
            };
        }
        return x;
    }

    /**
     * Defines the factor by which coordinates are scaled
     * along the Y axis direction. The default value is {@code 1.0}.
     */
    private DoubleProperty y;


    public final void setY(double value) {
        yProperty().set(value);
    }

    public final double getY() {
        return y == null ? 1.0F : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase(1.0F) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;y&quot;;
                }
            };
        }
        return y;
    }

    /**
     * Defines the factor by which coordinates are scaled
     * along the Z axis direction. The default value is {@code 1.0}.
     */
    private DoubleProperty z;


    public final void setZ(double value) {
        zProperty().set(value);
    }

    public final double getZ() {
        return z == null ? 1.0F : z.get();
    }

    public final DoubleProperty zProperty() {
        if (z == null) {
            z = new DoublePropertyBase(1.0F) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;z&quot;;
                }
            };
        }
        return z;
    }

    /**
     * Defines the X coordinate about which point the scale occurs.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotX;


    public final void setPivotX(double value) {
        pivotXProperty().set(value);
    }

    public final double getPivotX() {
        return pivotX == null ? 0.0 : pivotX.get();
    }

    public final DoubleProperty pivotXProperty() {
        if (pivotX == null) {
            pivotX = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotX&quot;;
                }
            };
        }
        return pivotX;
    }

    /**
     * Defines the Y coordinate about which point the scale occurs.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotY;


    public final void setPivotY(double value) {
        pivotYProperty().set(value);
    }

    public final double getPivotY() {
        return pivotY == null ? 0.0 : pivotY.get();
    }

    public final DoubleProperty pivotYProperty() {
        if (pivotY == null) {
            pivotY = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotY&quot;;
                }
            };
        }
        return pivotY;
    }

    /**
     * Defines the Z coordinate about which point the scale occurs.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotZ;


    public final void setPivotZ(double value) {
        pivotZProperty().set(value);
    }

    public final double getPivotZ() {
        return pivotZ == null ? 0.0 : pivotZ.get();
    }

    public final DoubleProperty pivotZProperty() {
        if (pivotZ == null) {
            pivotZ = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Scale.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotZ&quot;;
                }
            };
        }
        return pivotZ;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    public double getMxx() {
        return getX();
    }

    @Override
    public double getMyy() {
        return getY();
    }

    @Override
    public double getMzz() {
        return getZ();
    }

    @Override
    public double getTx() {
        return (1-getX()) * getPivotX();
    }

    @Override
    public double getTy() {
        return (1-getY()) * getPivotY();
    }

    @Override
    public double getTz() {
        return (1-getZ()) * getPivotZ();
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        return getZ() == 1.0;
    }

    @Override
    boolean computeIsIdentity() {
        return getX() == 1.0 &amp;&amp; getY() == 1.0 &amp;&amp; getZ() == 1.0;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    void fill2DArray(double[] array) {
        final double sx = getX();
        final double sy = getY();

        array[0] = sx;
        array[1] = 0.0;
        array[2] = (1-sx) * getPivotX();
        array[3] = 0.0;
        array[4] = sy;
        array[5] = (1-sy) * getPivotY();
    }

    @Override
    void fill3DArray(double[] array) {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        array[0] = sx;
        array[1] = 0.0;
        array[2] = 0.0;
        array[3] = (1-sx) * getPivotX();
        array[4] = 0.0;
        array[5] = sy;
        array[6] = 0.0;
        array[7] = (1-sy) * getPivotY();
        array[8] = 0.0;
        array[9] = 0.0;
        array[10] = sz;
        array[11] = (1-sz) * getPivotZ();
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (transform instanceof Scale) {
            final Scale other = (Scale) transform;
            if (other.getPivotX() == getPivotX()
                    &amp;&amp; other.getPivotY() == getPivotY()
                    &amp;&amp; other.getPivotZ() == getPivotZ()) {
                return new Scale(
                        sx * other.getX(),
                        sy * other.getY(),
                        sz * other.getZ(),
                        getPivotX(), getPivotY(), getPivotZ());
            }
        }

        if (transform instanceof Translate) {
            final Translate t = (Translate) transform;

            final double tx = t.getX();
            final double ty = t.getY();
            final double tz = t.getZ();

            if ((tx == 0.0 || (sx != 1.0 &amp;&amp; sx != 0.0)) &amp;&amp;
                    (ty == 0.0 || (sy != 1.0 &amp;&amp; sy != 0.0)) &amp;&amp;
                    (tz == 0.0 || (sz != 1.0 &amp;&amp; sz != 0.0))) {
                return new Scale(
                        sx, sy, sz,
                        (sx != 1.0 ? sx * tx / (1 - sx) : 0) + getPivotX(),
                        (sy != 1.0 ? sy * ty / (1 - sy) : 0) + getPivotY(),
                        (sz != 1.0 ? sz * tz / (1 - sz) : 0) + getPivotZ());
            }
        }

        if (transform instanceof Affine) {
            Affine a = (Affine) transform.clone();
            a.prepend(this);
            return a;
        }

        final double txx = transform.getMxx();
        final double txy = transform.getMxy();
        final double txz = transform.getMxz();
        final double ttx = transform.getTx();
        final double tyx = transform.getMyx();
        final double tyy = transform.getMyy();
        final double tyz = transform.getMyz();
        final double tty = transform.getTy();
        final double tzx = transform.getMzx();
        final double tzy = transform.getMzy();
        final double tzz = transform.getMzz();
        final double ttz = transform.getTz();
        return new Affine(
                sx * txx, sx * txy, sx * txz, sx * ttx + (1 - sx) * getPivotX(),
                sy * tyx, sy * tyy, sy * tyz, sy * tty + (1 - sy) * getPivotY(),
                sz * tzx, sz * tzy, sz * tzz, sz * ttz + (1 - sz) * getPivotZ());
    }

    @Override
    public Scale createInverse() throws NonInvertibleTransformException {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        return new Scale(1.0 / sx, 1.0 / sy, 1.0 / sz,
                getPivotX(), getPivotY(), getPivotZ());
    }

    @Override
    public Scale clone() {
        return new Scale(getX(), getY(), getZ(),
                getPivotX(), getPivotY(), getPivotZ());
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        final double mxx = getX();
        final double myy = getY();

        return new Point2D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY());
    }

    @Override
    public Point3D transform(double x, double y, double z) {

        final double mxx = getX();
        final double myy = getY();
        final double mzz = getZ();

        return new Point3D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY(),
            mzz * z + (1 - mzz) * getPivotZ());
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getX();
        final double yy = getY();
        final double px = getPivotX();
        final double py = getPivotY();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + (1 - xx) * px;
            dstPts[dstOff++] = yy * y + (1 - yy) * py;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getX();
        final double yy = getY();
        final double zz = getZ();
        final double px = getPivotX();
        final double py = getPivotY();
        final double pz = getPivotZ();

        while (--numPts &gt;= 0) {
            dstPts[dstOff++] = xx * srcPts[srcOff++] + (1 - xx) * px;
            dstPts[dstOff++] = yy * srcPts[srcOff++] + (1 - yy) * py;
            dstPts[dstOff++] = zz * srcPts[srcOff++] + (1 - zz) * pz;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
                getX() * x,
                getY() * y);
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        return new Point3D(
                getX() * x,
                getY() * y,
                getZ() * z);
    }

    @Override
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        final double sx = getX();
        final double sy = getY();

        if (sx == 0.0 || sy == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double mxx = 1.0 / sx;
        final double myy = 1.0 / sy;

        return new Point2D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY());
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {
        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double mxx = 1.0 / sx;
        final double myy = 1.0 / sy;
        final double mzz = 1.0 / sz;

        return new Point3D(
            mxx * x + (1 - mxx) * getPivotX(),
            myy * y + (1 - myy) * getPivotY(),
            mzz * z + (1 - mzz) * getPivotZ());
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {
        final double sx = getX();
        final double sy = getY();

        if (sx == 0.0 || sy == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double xx = 1.0 / sx;
        final double yy = 1.0 / sy;
        final double px = getPivotX();
        final double py = getPivotY();

        while (--numPts &gt;= 0) {
            dstPts[dstOff++] = xx * srcPts[srcOff++] + (1 - xx) * px;
            dstPts[dstOff++] = yy * srcPts[srcOff++] + (1 - yy) * py;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        final double xx = 1.0 / sx;
        final double yy = 1.0 / sy;
        final double zz = 1.0 / sz;
        final double px = getPivotX();
        final double py = getPivotY();
        final double pz = getPivotZ();

        while (--numPts &gt;= 0) {
            dstPts[dstOff++] = xx * srcPts[srcOff++] + (1 - xx) * px;
            dstPts[dstOff++] = yy * srcPts[srcOff++] + (1 - yy) * py;
            dstPts[dstOff++] = zz * srcPts[srcOff++] + (1 - zz) * pz;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        final double sx = getX();
        final double sy = getY();

        if (sx == 0.0 || sy == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        return new Point2D(
            (1.0 / sx) * x,
            (1.0 / sy) * y);
    }

    @Override
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        final double sx = getX();
        final double sy = getY();
        final double sz = getZ();

        if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
            throw new NonInvertibleTransformException(
                    &quot;Zero scale is not invertible&quot;);
        }

        return new Point3D(
            (1.0 / sx) * x,
            (1.0 / sy) * y,
            (1.0 / sz) * z);
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Scale} object.
     * @return a string representation of this {@code Scale} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Scale [&quot;);

        sb.append(&quot;x=&quot;).append(getX());
        sb.append(&quot;, y=&quot;).append(getY());
        sb.append(&quot;, z=&quot;).append(getZ());
        sb.append(&quot;, pivotX=&quot;).append(getPivotX());
        sb.append(&quot;, pivotY=&quot;).append(getPivotY());
        sb.append(&quot;, pivotZ=&quot;).append(getPivotZ());

        return sb.append(&quot;]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/
<A NAME="23"></A>
    @Override
    void apply(final Affine3D trans) {
        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#23',2,'match45-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (getPivotX() != 0 || getPivotY() != 0 || getPivotZ() != 0) {
            trans.translate(getPivotX(), getPivotY(), getPivotZ());
            trans.scale(getX(), getY(), getZ());
            trans.translate(-getPivotX(), -getPivotY(), -getPivotZ</B></FONT>());
        } else {
            trans.scale(getX(), getY(), getZ());
        }
    }

    @Override
    BaseTransform derive(BaseTransform trans) {
        if (isIdentity()) {
            return trans;
        }
        if (getPivotX() != 0 || getPivotY() != 0 || getPivotZ() != 0) {
            trans = trans.deriveWithTranslation(getPivotX(), getPivotY(), getPivotZ());
            trans = trans.deriveWithScale(getX(), getY(), getZ());
            return trans.deriveWithTranslation(-getPivotX(), -getPivotY(), -getPivotZ());
        } else {
            return trans.deriveWithScale(getX(), getY(), getZ());
        }
    }

    @Override
    void validate() {
        getX(); getPivotX();
        getY(); getPivotY();
        getZ(); getPivotZ();
    }

    @Override
    void appendTo(Affine a) {
        a.appendScale(getX(), getY(), getZ(),
                getPivotX(), getPivotY(), getPivotZ());
    }

    @Override
    void prependTo(Affine a) {
        a.prependScale(getX(), getY(), getZ(),
                getPivotX(), getPivotY(), getPivotZ());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/stage/PopupWindow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.stage;

import com.sun.javafx.util.Utils;
import com.sun.javafx.event.DirectEvent;
import java.util.ArrayList;
import java.util.List;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoubleWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.collections.ObservableList;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Rectangle2D;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;

import com.sun.javafx.event.EventHandlerManager;
import com.sun.javafx.event.EventRedirector;
import com.sun.javafx.event.EventUtil;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.stage.FocusUngrabEvent;
import com.sun.javafx.stage.PopupWindowPeerListener;
import com.sun.javafx.stage.WindowCloseRequestHandler;
import com.sun.javafx.stage.WindowEventDispatcher;
import com.sun.javafx.tk.Toolkit;
import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.PopupWindowHelper;
import com.sun.javafx.stage.WindowHelper;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.value.WeakChangeListener;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Background;
import javafx.scene.layout.Pane;

/**
 * PopupWindow is the parent for a variety of different types of popup
 * based windows including {@link Popup} and {@link javafx.scene.control.Tooltip}
 * and {@link javafx.scene.control.ContextMenu}.
 * &lt;p&gt;
 * A PopupWindow is a secondary window which has no window decorations or title bar.
 * It doesn't show up in the OS as a top-level window. It is typically
 * used for tool tip like notification, drop down boxes, menus, and so forth.
 * &lt;p&gt;
 * The PopupWindow &lt;strong&gt;cannot be shown without an owner&lt;/strong&gt;.
 * PopupWindows require that an owner window exist in order to be shown. However,
 * it is possible to create a PopupWindow ahead of time and simply set the owner
 * (or change the owner) before first being made visible. Attempting to change
 * the owner while the PopupWindow is visible will result in an IllegalStateException.
 * &lt;p&gt;
 * The PopupWindow encapsulates much of the behavior and functionality common to popups,
 * such as the ability to close when the &quot;esc&quot; key is pressed, or the ability to
 * hide all child popup windows whenever this window is hidden. These abilities can
 * be enabled or disabled via properties.
 * @since JavaFX 2.0
 */
public abstract class PopupWindow extends Window {

     static {
        PopupWindowHelper.setPopupWindowAccessor(new PopupWindowHelper.PopupWindowAccessor() {
            @Override public void doVisibleChanging(Window window, boolean visible) {
                ((PopupWindow) window).doVisibleChanging(visible);
            }

            @Override public void doVisibleChanged(Window window, boolean visible) {
                ((PopupWindow) window).doVisibleChanged(visible);
            }

            @Override
            public ObservableList&lt;Node&gt; getContent(PopupWindow popupWindow) {
                return popupWindow.getContent();
            }
        });
    }

    /**
     * A private list of all child popups.
     */
    private final List&lt;PopupWindow&gt; children = new ArrayList&lt;PopupWindow&gt;();

    /**
     * Keeps track of the bounds of the content, and adjust the position and
     * size of the popup window accordingly. This way as the popup content
     * changes, the window will be changed to match.
     */
    private final InvalidationListener popupWindowUpdater =
            new InvalidationListener() {
                @Override
                public void invalidated(final Observable observable) {
                    cachedExtendedBounds = null;
                    cachedAnchorBounds = null;
                    updateWindow(getAnchorX(), getAnchorY());
                }
            };

    /**
     * RT-28454: When a parent node or parent window we are associated with is not
     * visible anymore, possibly because the scene was not valid anymore, we should hide.
     */
    private ChangeListener&lt;Boolean&gt; changeListener = (observable, oldValue, newValue) -&gt; {
        if (oldValue &amp;&amp; !newValue) {
            hide();
        }
    };

    private WeakChangeListener&lt;Boolean&gt; weakOwnerNodeListener = new WeakChangeListener(changeListener);

    public PopupWindow() {
        final Pane popupRoot = new Pane();
        popupRoot.setBackground(Background.EMPTY);
        popupRoot.getStyleClass().add(&quot;popup&quot;);

        final Scene scene = SceneHelper.createPopupScene(popupRoot);
        scene.setFill(null);
        super.setScene(scene);

        popupRoot.layoutBoundsProperty().addListener(popupWindowUpdater);
        popupRoot.boundsInLocalProperty().addListener(popupWindowUpdater);
        scene.rootProperty().addListener(
                new InvalidationListener() {
                    private Node oldRoot = scene.getRoot();

                    @Override
                    public void invalidated(final Observable observable) {
                        final Node newRoot = scene.getRoot();
                        if (oldRoot != newRoot) {
                            if (oldRoot != null) {
                                oldRoot.layoutBoundsProperty()
                                       .removeListener(popupWindowUpdater);
                                oldRoot.boundsInLocalProperty()
                                       .removeListener(popupWindowUpdater);
                                oldRoot.getStyleClass().remove(&quot;popup&quot;);
                            }

                            if (newRoot != null) {
                                newRoot.layoutBoundsProperty()
                                       .addListener(popupWindowUpdater);
                                newRoot.boundsInLocalProperty()
                                       .addListener(popupWindowUpdater);
                                newRoot.getStyleClass().add(&quot;popup&quot;);
                            }

                            oldRoot = newRoot;
<A NAME="31"></A>
                            cachedExtendedBounds = null;
                            cachedAnchorBounds = null;
                            updateWindow(getAnchorX(), <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#31',2,'match45-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getAnchorY());
                        }
                    }
                });
        PopupWindowHelper.initHelper(this);
    }

    /*
     * Gets the observable, modifiable list of children which are placed in this
     * PopupWindow.
     *
     * @return the PopupWindow content
     */
    ObservableList&lt;Node&gt; getContent() {</B></FONT>
        final Parent rootNode = getScene().getRoot();
        if (rootNode instanceof Group) {
            return ((Group) rootNode).getChildren();
        }

        if (rootNode instanceof Pane) {
            return ((Pane) rootNode).getChildren();
        }

        throw new IllegalStateException(
                &quot;The content of the Popup can't be accessed&quot;);
    }

    /**
     * The window which is the parent of this popup. All popups must have an
     * owner window.
     */
    private ReadOnlyObjectWrapper&lt;Window&gt; ownerWindow =
            new ReadOnlyObjectWrapper&lt;Window&gt;(this, &quot;ownerWindow&quot;);
    public final Window getOwnerWindow() {
        return ownerWindow.get();
    }
    public final ReadOnlyObjectProperty&lt;Window&gt; ownerWindowProperty() {
        return ownerWindow.getReadOnlyProperty();
    }

    /**
     * The node which is the owner of this popup. All popups must have an
     * owner window but are not required to be associated with an owner node.
     * If an autohide Popup has an owner node, mouse press inside the owner node
     * doesn't cause the Popup to hide.
     */
    private ReadOnlyObjectWrapper&lt;Node&gt; ownerNode =
            new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;ownerNode&quot;);
    public final Node getOwnerNode() {
        return ownerNode.get();
    }
    public final ReadOnlyObjectProperty&lt;Node&gt; ownerNodeProperty() {
        return ownerNode.getReadOnlyProperty();
    }

    /**
     * Note to subclasses: the scene used by PopupWindow is very specifically
     * managed by PopupWindow. This method is overridden to throw
     * UnsupportedOperationException. You cannot specify your own scene.
     *
     * @param scene the scene to be rendered on this window
     */
    @Override protected final void setScene(Scene scene) {
        throw new UnsupportedOperationException();
    }

    /**
     * This convenience variable indicates whether, when the popup is shown,
     * it should automatically correct its position such that it doesn't end
     * up positioned off the screen.
     * @defaultValue true
     */
    private BooleanProperty autoFix =
            new BooleanPropertyBase(true) {
                @Override
                protected void invalidated() {
                    handleAutofixActivation(isShowing(), get());
                }

                @Override
                public Object getBean() {
                    return PopupWindow.this;
                }

                @Override
                public String getName() {
                    return &quot;autoFix&quot;;
                }
            };
    public final void setAutoFix(boolean value) { autoFix.set(value); }
    public final boolean isAutoFix() { return autoFix.get(); }
    public final BooleanProperty autoFixProperty() { return autoFix; }

    /**
     * Specifies whether Popups should auto hide. If a popup loses focus and
     * autoHide is true, then the popup will be hidden automatically.
     * &lt;p&gt;
     * The only exception is when owner Node is specified using {@link #show(javafx.scene.Node, double, double)}.
     * Focusing owner Node will not hide the PopupWindow.
     * &lt;/p&gt;
     * @defaultValue false
     */
    private BooleanProperty autoHide =
            new BooleanPropertyBase() {
                @Override
                protected void invalidated() {
                    handleAutohideActivation(isShowing(), get());
                }

                @Override
                public Object getBean() {
                    return PopupWindow.this;
                }

                @Override
                public String getName() {
                    return &quot;autoHide&quot;;
                }
            };
    public final void setAutoHide(boolean value) { autoHide.set(value); }
    public final boolean isAutoHide() { return autoHide.get(); }
    public final BooleanProperty autoHideProperty() { return autoHide; }

    /**
     * Called after autoHide is run.
     */
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onAutoHide =
            new SimpleObjectProperty&lt;EventHandler&lt;Event&gt;&gt;(this, &quot;onAutoHide&quot;);
    public final void setOnAutoHide(EventHandler&lt;Event&gt; value) { onAutoHide.set(value); }
    public final EventHandler&lt;Event&gt; getOnAutoHide() { return onAutoHide.get(); }
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onAutoHideProperty() { return onAutoHide; }

    /**
     * Specifies whether the PopupWindow should be hidden when an unhandled escape key
     * is pressed while the popup has focus.
     * @defaultValue true
     */
    private BooleanProperty hideOnEscape =
            new SimpleBooleanProperty(this, &quot;hideOnEscape&quot;, true);
    public final void setHideOnEscape(boolean value) { hideOnEscape.set(value); }
    public final boolean isHideOnEscape() { return hideOnEscape.get(); }
    public final BooleanProperty hideOnEscapeProperty() { return hideOnEscape; }

    /**
     * Specifies whether the event, which caused the Popup to hide, should be
     * consumed. Having the event consumed prevents it from triggering some
     * additional UI response in the Popup's owner window.
     * @defaultValue true
     * @since JavaFX 2.2
     */
    private BooleanProperty consumeAutoHidingEvents =
            new SimpleBooleanProperty(this, &quot;consumeAutoHidingEvents&quot;,
                                      true);

    public final void setConsumeAutoHidingEvents(boolean value) {
        consumeAutoHidingEvents.set(value);
    }

    public final boolean getConsumeAutoHidingEvents() {
        return consumeAutoHidingEvents.get();
    }

    public final BooleanProperty consumeAutoHidingEventsProperty() {
        return consumeAutoHidingEvents;
    }

    /**
     * Show the popup.
     * @param owner The owner of the popup. This must not be null.
     * @throws NullPointerException if owner is null
     * @throws IllegalArgumentException if the specified owner window would
     *      create cycle in the window hierarchy
     */
    public void show(Window owner) {
        validateOwnerWindow(owner);
        showImpl(owner);
    }

    /**
     * Shows the popup at the specified location on the screen. The popup window
     * is positioned in such way that its anchor point ({@link #anchorLocationProperty() anchorLocation})
     * is displayed at the specified {@code anchorX} and {@code anchorY}
     * coordinates.
     * &lt;p&gt;
     * The popup is associated with the specified owner node. The {@code Window}
     * which contains the owner node at the time of the call becomes an owner
     * window of the displayed popup.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Note that when {@link #autoHideProperty() autoHide} is set to true, mouse press on the owner Node
     * will not hide the PopupWindow.
     * &lt;/p&gt;
     *
     * @param ownerNode The owner Node of the popup. It must not be null
     *        and must be associated with a Window.
     * @param anchorX the x position of the popup anchor in screen coordinates
     * @param anchorY the y position of the popup anchor in screen coordinates
     * @throws NullPointerException if ownerNode is null
     * @throws IllegalArgumentException if the specified owner node is not
     *      associated with a Window or when the window would create cycle
     *      in the window hierarchy
     */
    public void show(Node ownerNode, double anchorX, double anchorY) {
        if (ownerNode == null) {
            throw new NullPointerException(&quot;The owner node must not be null&quot;);
        }

        final Scene ownerNodeScene = ownerNode.getScene();
        if ((ownerNodeScene == null)
                || (ownerNodeScene.getWindow() == null)) {
            throw new IllegalArgumentException(
                    &quot;The owner node needs to be associated with a window&quot;);
        }

        final Window newOwnerWindow = ownerNodeScene.getWindow();
        validateOwnerWindow(newOwnerWindow);

        this.ownerNode.set(ownerNode);

        // PopupWindow should disappear when owner node is not visible
        if (ownerNode != null) {
            NodeHelper.treeShowingProperty(ownerNode).addListener(weakOwnerNodeListener);
        }

        updateWindow(anchorX, anchorY);
        showImpl(newOwnerWindow);
    }

    /**
     * Shows the popup at the specified location on the screen. The popup window
     * is positioned in such way that its anchor point ({@link #anchorLocationProperty() anchorLocation})
     * is displayed at the specified {@code anchorX} and {@code anchorY}
     * coordinates.
     *
     * @param ownerWindow The owner of the popup. This must not be null.
     * @param anchorX the x position of the popup anchor in screen coordinates
     * @param anchorY the y position of the popup anchor in screen coordinates
     * @throws NullPointerException if ownerWindow is null
     * @throws IllegalArgumentException if the specified owner window would
     *      create cycle in the window hierarchy
     */
    public void show(Window ownerWindow, double anchorX, double anchorY) {
        validateOwnerWindow(ownerWindow);

        updateWindow(anchorX, anchorY);
        showImpl(ownerWindow);
    }

    private void showImpl(final Window owner) {
        // Update the owner field
        this.ownerWindow.set(owner);
        if (owner instanceof PopupWindow) {
            ((PopupWindow)owner).children.add(this);
        }
        // PopupWindow should disappear when owner node is not visible
        if (owner != null) {
            owner.showingProperty().addListener(weakOwnerNodeListener);
        }

        final Scene sceneValue = getScene();
        SceneHelper.parentEffectiveOrientationInvalidated(sceneValue);

        // RT-28447
        final Scene ownerScene = getRootWindow(owner).getScene();
        if (ownerScene != null) {
            if (ownerScene.getUserAgentStylesheet() != null) {
                sceneValue.setUserAgentStylesheet(ownerScene.getUserAgentStylesheet());
            }
            sceneValue.getStylesheets().setAll(ownerScene.getStylesheets());
            if (sceneValue.getCursor() == null) {
                sceneValue.setCursor(ownerScene.getCursor());
            }
        }

        // It is required that the root window exist and be visible to show the popup.
        if (getRootWindow(owner).isShowing()) {
            // We do show() first so that the width and height of the
            // popup window are initialized. This way the x,y location of the
            // popup calculated below uses the right width and height values for
            // its calculation. (fix for part of RT-10675).
            show();
        }
    }

    /**
     * Hide this Popup and all its children
     */
    @Override public void hide() {
        for (PopupWindow c : children) {
            if (c.isShowing()) {
                c.hide();
            }
        }
        children.clear();
        super.hide();

        // When popup hides, remove listeners; these are added when the popup shows.
        if (getOwnerWindow() != null) getOwnerWindow().showingProperty().removeListener(weakOwnerNodeListener);
        if (getOwnerNode() != null) NodeHelper.treeShowingProperty(getOwnerNode()).removeListener(weakOwnerNodeListener);
    }

    /*
     * This can be replaced by listening for the onShowing/onHiding events
     * Note: This method MUST only be called via its accessor method.
     */
    private void doVisibleChanging(boolean visible) {
        PerformanceTracker.logEvent(&quot;PopupWindow.storeVisible for [PopupWindow]&quot;);

        Toolkit toolkit = Toolkit.getToolkit();
        if (visible &amp;&amp; (getPeer() == null)) {
            // Setup the peer
            StageStyle popupStyle;
            try {
                final SecurityManager securityManager =
                        System.getSecurityManager();
                if (securityManager != null) {
                    securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);
                }
                popupStyle = StageStyle.TRANSPARENT;
            } catch (final SecurityException e) {
                popupStyle = StageStyle.UNDECORATED;
            }
            setPeer(toolkit.createTKPopupStage(this, popupStyle, getOwnerWindow().getPeer(), acc));
            setPeerListener(new PopupWindowPeerListener(PopupWindow.this));
        }
    }

    private Window rootWindow;

    /*
     * This can be replaced by listening for the onShown/onHidden events
     * Note: This method MUST only be called via its accessor method.
     */
    private void doVisibleChanged(boolean visible) {
        final Window ownerWindowValue = getOwnerWindow();
        if (visible) {
            rootWindow = getRootWindow(ownerWindowValue);

            startMonitorOwnerEvents(ownerWindowValue);
            // currently we consider popup window to be focused when it is
            // visible and its owner window is focused (we need to track
            // that through listener on owner window focused property)
            // a better solution would require some focus manager, which can
            // track focus state across multiple windows
            bindOwnerFocusedProperty(ownerWindowValue);
            WindowHelper.setFocused(this, ownerWindowValue.isFocused());
            handleAutofixActivation(true, isAutoFix());
            handleAutohideActivation(true, isAutoHide());
        } else {
            stopMonitorOwnerEvents(ownerWindowValue);
            unbindOwnerFocusedProperty(ownerWindowValue);
            WindowHelper.setFocused(this, false);
            handleAutofixActivation(false, isAutoFix());
            handleAutohideActivation(false, isAutoHide());
            rootWindow = null;
        }

        PerformanceTracker.logEvent(&quot;PopupWindow.storeVisible for [PopupWindow] finished&quot;);
    }

    /**
     * Specifies the x coordinate of the popup anchor point on the screen. If
     * the {@code anchorLocation} is set to {@code WINDOW_TOP_LEFT} or
     * {@code WINDOW_BOTTOM_LEFT} the {@code x} and {@code anchorX} values will
     * be identical.
     *
     * @since JavaFX 8.0
     */
    private final ReadOnlyDoubleWrapper anchorX =
            new ReadOnlyDoubleWrapper(this, &quot;anchorX&quot;, Double.NaN);

    public final void setAnchorX(final double value) {
        updateWindow(value, getAnchorY());
    }
    public final double getAnchorX() {
        return anchorX.get();
    }
    public final ReadOnlyDoubleProperty anchorXProperty() {
        return anchorX.getReadOnlyProperty();
    }

    /**
     * Specifies the y coordinate of the popup anchor point on the screen. If
     * the {@code anchorLocation} is set to {@code WINDOW_TOP_LEFT} or
     * {@code WINDOW_TOP_RIGHT} the {@code y} and {@code anchorY} values will
     * be identical.
     *
     * @since JavaFX 8.0
     */
    private final ReadOnlyDoubleWrapper anchorY =
            new ReadOnlyDoubleWrapper(this, &quot;anchorY&quot;, Double.NaN);

    public final void setAnchorY(final double value) {
        updateWindow(getAnchorX(), value);
    }
    public final double getAnchorY() {
        return anchorY.get();
    }
    public final ReadOnlyDoubleProperty anchorYProperty() {
        return anchorY.getReadOnlyProperty();
    }

    /**
     * Specifies the popup anchor point which is used in popup positioning. The
     * point can be set to a corner of the popup window or a corner of its
     * content. In this context the content corners are derived from the popup
     * root node's layout bounds.
     * &lt;p&gt;
     * In general changing of the anchor location won't change the current
     * window position. Instead of that, the {@code anchorX} and {@code anchorY}
     * values are recalculated to correspond to the new anchor point.
     * &lt;/p&gt;
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;AnchorLocation&gt; anchorLocation =
            new ObjectPropertyBase&lt;AnchorLocation&gt;(
                    AnchorLocation.WINDOW_TOP_LEFT) {
                @Override
                protected void invalidated() {
                    cachedAnchorBounds = null;
                    updateWindow(windowToAnchorX(getX()),
                                 windowToAnchorY(getY()));
                }

                @Override
                public Object getBean() {
                    return PopupWindow.this;
                }

                @Override
                public String getName() {
                    return &quot;anchorLocation&quot;;
                }
            };
    public final void setAnchorLocation(final AnchorLocation value) {
        anchorLocation.set(value);
    }
    public final AnchorLocation getAnchorLocation() {
        return anchorLocation.get();
    }
    public final ObjectProperty&lt;AnchorLocation&gt; anchorLocationProperty() {
        return anchorLocation;
    }

    /**
     * Anchor location constants for popup anchor point selection.
     *
     * @since JavaFX 8.0
     */
    public enum AnchorLocation {
        /** Represents top left window corner. */
        WINDOW_TOP_LEFT(0, 0, false),
        /** Represents top right window corner. */
        WINDOW_TOP_RIGHT(1, 0, false),
        /** Represents bottom left window corner. */
        WINDOW_BOTTOM_LEFT(0, 1, false),
        /** Represents bottom right window corner. */
        WINDOW_BOTTOM_RIGHT(1, 1, false),
        /** Represents top left content corner. */
        CONTENT_TOP_LEFT(0, 0, true),
        /** Represents top right content corner. */
        CONTENT_TOP_RIGHT(1, 0, true),
        /** Represents bottom left content corner. */
        CONTENT_BOTTOM_LEFT(0, 1, true),
        /** Represents bottom right content corner. */
        CONTENT_BOTTOM_RIGHT(1, 1, true);

        private final double xCoef;
        private final double yCoef;
        private final boolean contentLocation;

        private AnchorLocation(final double xCoef, final double yCoef,
                               final boolean contentLocation) {
            this.xCoef = xCoef;
            this.yCoef = yCoef;
            this.contentLocation = contentLocation;
        }

        double getXCoef() {
            return xCoef;
        }

        double getYCoef() {
            return yCoef;
        }

        boolean isContentLocation() {
            return contentLocation;
        }
    };

    @Override
    void setXInternal(final double value) {
        updateWindow(windowToAnchorX(value), getAnchorY());
    }

    @Override
    void setYInternal(final double value) {
        updateWindow(getAnchorX(), windowToAnchorY(value));
    }

    @Override
    void notifyLocationChanged(final double newX, final double newY) {
        super.notifyLocationChanged(newX, newY);
        anchorX.set(windowToAnchorX(newX));
        anchorY.set(windowToAnchorY(newY));
    }

    private Bounds cachedExtendedBounds;
    private Bounds cachedAnchorBounds;

    private Bounds getExtendedBounds() {
        if (cachedExtendedBounds == null) {
            final Parent rootNode = getScene().getRoot();
            cachedExtendedBounds = union(rootNode.getLayoutBounds(),
                                         rootNode.getBoundsInLocal());
        }

        return cachedExtendedBounds;
    }

    private Bounds getAnchorBounds() {
        if (cachedAnchorBounds == null) {
            cachedAnchorBounds = getAnchorLocation().isContentLocation()
                                         ? getScene().getRoot()
                                                     .getLayoutBounds()
                                         : getExtendedBounds();
        }

        return cachedAnchorBounds;
    }

    private void updateWindow(final double newAnchorX,
                              final double newAnchorY) {
        final AnchorLocation anchorLocationValue = getAnchorLocation();
        final Parent rootNode = getScene().getRoot();
        final Bounds extendedBounds = getExtendedBounds();
        final Bounds anchorBounds = getAnchorBounds();

        final double anchorXCoef = anchorLocationValue.getXCoef();
        final double anchorYCoef = anchorLocationValue.getYCoef();
        final double anchorDeltaX = anchorXCoef * anchorBounds.getWidth();
        final double anchorDeltaY = anchorYCoef * anchorBounds.getHeight();
        double anchorScrMinX = newAnchorX - anchorDeltaX;
        double anchorScrMinY = newAnchorY - anchorDeltaY;

        if (autofixActive) {
            final Screen currentScreen =
                    Utils.getScreenForPoint(newAnchorX, newAnchorY);
            final Rectangle2D screenBounds =
                    Utils.hasFullScreenStage(currentScreen)
                            ? currentScreen.getBounds()
                            : currentScreen.getVisualBounds();

            if (anchorXCoef &lt;= 0.5) {
                // left side of the popup is more important, try to keep it
                // visible if the popup width is larger than screen width
                anchorScrMinX = Math.min(anchorScrMinX,
                                         screenBounds.getMaxX()
                                             - anchorBounds.getWidth());
                anchorScrMinX = Math.max(anchorScrMinX, screenBounds.getMinX());
            } else {
                // right side of the popup is more important
                anchorScrMinX = Math.max(anchorScrMinX, screenBounds.getMinX());
                anchorScrMinX = Math.min(anchorScrMinX,
                                         screenBounds.getMaxX()
                                             - anchorBounds.getWidth());
            }

            if (anchorYCoef &lt;= 0.5) {
                // top side of the popup is more important
                anchorScrMinY = Math.min(anchorScrMinY,
                                         screenBounds.getMaxY()
                                             - anchorBounds.getHeight());
                anchorScrMinY = Math.max(anchorScrMinY, screenBounds.getMinY());
            } else {
                // bottom side of the popup is more important
                anchorScrMinY = Math.max(anchorScrMinY, screenBounds.getMinY());
                anchorScrMinY = Math.min(anchorScrMinY,
                                         screenBounds.getMaxY()
                                             - anchorBounds.getHeight());
            }
        }

        final double windowScrMinX =
                anchorScrMinX - anchorBounds.getMinX()
                              + extendedBounds.getMinX();
        final double windowScrMinY =
                anchorScrMinY - anchorBounds.getMinY()
                              + extendedBounds.getMinY();

        // update popup dimensions
        setWidth(extendedBounds.getWidth());
        setHeight(extendedBounds.getHeight());
        // update transform
        rootNode.setTranslateX(-extendedBounds.getMinX());
        rootNode.setTranslateY(-extendedBounds.getMinY());

        // update popup position
        // don't set Window.xExplicit unnecessarily
        if (!Double.isNaN(windowScrMinX)) {
            super.setXInternal(windowScrMinX);
        }
        // don't set Window.yExplicit unnecessarily
        if (!Double.isNaN(windowScrMinY)) {
            super.setYInternal(windowScrMinY);
        }

        // set anchor x, anchor y
        anchorX.set(anchorScrMinX + anchorDeltaX);
        anchorY.set(anchorScrMinY + anchorDeltaY);
    }

    private Bounds union(final Bounds bounds1, final Bounds bounds2) {
        final double minX = Math.min(bounds1.getMinX(), bounds2.getMinX());
        final double minY = Math.min(bounds1.getMinY(), bounds2.getMinY());
        final double maxX = Math.max(bounds1.getMaxX(), bounds2.getMaxX());
        final double maxY = Math.max(bounds1.getMaxY(), bounds2.getMaxY());

        return new BoundingBox(minX, minY, maxX - minX, maxY - minY);
    }

    private double windowToAnchorX(final double windowX) {
        final Bounds anchorBounds = getAnchorBounds();
        return windowX - getExtendedBounds().getMinX()
                       + anchorBounds.getMinX()
                       + getAnchorLocation().getXCoef()
                             * anchorBounds.getWidth();
    }

    private double windowToAnchorY(final double windowY) {
        final Bounds anchorBounds = getAnchorBounds();
        return windowY - getExtendedBounds().getMinY()
                       + anchorBounds.getMinY()
                       + getAnchorLocation().getYCoef()
                             * anchorBounds.getHeight();
    }

    /**
     *
     * Gets the root (non PopupWindow) Window for the provided window.
     *
     * @param win the Window for which to get the root window
     */
    private static Window getRootWindow(Window win) {
        // should be enough to traverse PopupWindow hierarchy here to get to the
        // first non-popup focusable window
        while (win instanceof PopupWindow) {
            win = ((PopupWindow) win).getOwnerWindow();
        }
        return win;
    }

    void doAutoHide() {
        // There is a timing problem here. I would like to have this isVisible
        // check, such that we don't send an onAutoHide event if it was already
        // invisible. However, visible is already false by the time this method
        // gets called, when done by certain code paths.
//        if (isVisible()) {
        // hide this popup
        hide();
        if (getOnAutoHide() != null) {
            getOnAutoHide().handle(new Event(this, this, Event.ANY));
        }
//        }
    }

    @Override
    WindowEventDispatcher createInternalEventDispatcher() {
        return new WindowEventDispatcher(new PopupEventRedirector(this),
                                         new WindowCloseRequestHandler(this),
                                         new EventHandlerManager(this));

    }

    @Override
    Window getWindowOwner() {
        return getOwnerWindow();
    }

    private void startMonitorOwnerEvents(final Window ownerWindowValue) {
        final EventRedirector parentEventRedirector =
                ownerWindowValue.getInternalEventDispatcher()
                                .getEventRedirector();
        parentEventRedirector.addEventDispatcher(getEventDispatcher());
    }

    private void stopMonitorOwnerEvents(final Window ownerWindowValue) {
        final EventRedirector parentEventRedirector =
                ownerWindowValue.getInternalEventDispatcher()
                                .getEventRedirector();
        parentEventRedirector.removeEventDispatcher(getEventDispatcher());
    }

    private ChangeListener&lt;Boolean&gt; ownerFocusedListener;

    private void bindOwnerFocusedProperty(final Window ownerWindowValue) {
        ownerFocusedListener =
                (observable, oldValue, newValue) -&gt; WindowHelper.setFocused(this, newValue);
        ownerWindowValue.focusedProperty().addListener(ownerFocusedListener);
    }

    private void unbindOwnerFocusedProperty(final Window ownerWindowValue) {
        ownerWindowValue.focusedProperty().removeListener(ownerFocusedListener);
        ownerFocusedListener = null;
    }

    private boolean autofixActive;
    private void handleAutofixActivation(final boolean visible,
                                         final boolean autofix) {
        final boolean newAutofixActive = visible &amp;&amp; autofix;
        if (autofixActive != newAutofixActive) {
            autofixActive = newAutofixActive;
            if (newAutofixActive) {
                Screen.getScreens().addListener(popupWindowUpdater);
                updateWindow(getAnchorX(), getAnchorY());
            } else {
                Screen.getScreens().removeListener(popupWindowUpdater);
            }
        }
    }

    private boolean autohideActive;
    private void handleAutohideActivation(final boolean visible,
                                          final boolean autohide) {
        final boolean newAutohideActive = visible &amp;&amp; autohide;
        if (autohideActive != newAutohideActive) {
            // assert rootWindow != null;
            autohideActive = newAutohideActive;
            if (newAutohideActive) {
                rootWindow.increaseFocusGrabCounter();
            } else {
                rootWindow.decreaseFocusGrabCounter();
            }
        }
    }

    private void validateOwnerWindow(final Window owner) {
        if (owner == null) {
            throw new NullPointerException(&quot;Owner window must not be null&quot;);
        }

        if (wouldCreateCycle(owner, this)) {
            throw new IllegalArgumentException(
                    &quot;Specified owner window would create cycle&quot;
                        + &quot; in the window hierarchy&quot;);
        }

        if (isShowing() &amp;&amp; (getOwnerWindow() != owner)) {
            throw new IllegalStateException(
                    &quot;Popup is already shown with different owner window&quot;);
        }
    }

    private static boolean wouldCreateCycle(Window parent, final Window child) {
       while (parent != null) {
           if (parent == child) {
               return true;
           }

           parent = parent.getWindowOwner();
       }

       return false;
    }

    static class PopupEventRedirector extends EventRedirector {

        private static final KeyCombination ESCAPE_KEY_COMBINATION =
                KeyCombination.keyCombination(&quot;Esc&quot;);
        private final PopupWindow popupWindow;

        public PopupEventRedirector(final PopupWindow popupWindow) {
            super(popupWindow);
            this.popupWindow = popupWindow;
        }

        @Override
        protected void handleRedirectedEvent(final Object eventSource,
                final Event event) {
            if (event instanceof KeyEvent) {
                handleKeyEvent((KeyEvent) event);
                return;
            }

            final EventType&lt;?&gt; eventType = event.getEventType();

            if (eventType == MouseEvent.MOUSE_PRESSED
                    || eventType == ScrollEvent.SCROLL) {
                handleAutoHidingEvents(eventSource, event);
                return;
            }

            if (eventType == FocusUngrabEvent.FOCUS_UNGRAB) {
                handleFocusUngrabEvent();
                return;
            }
        }

        private void handleKeyEvent(final KeyEvent event) {
            if (event.isConsumed()) {
                return;
            }

            final Scene scene = popupWindow.getScene();
            if (scene != null) {
                final Node sceneFocusOwner = scene.getFocusOwner();
                final EventTarget eventTarget =
                        (sceneFocusOwner != null) ? sceneFocusOwner : scene;
                if (EventUtil.fireEvent(eventTarget, new DirectEvent(event.copyFor(popupWindow, eventTarget)))
                        == null) {
                    event.consume();
                    return;
                }
            }

            if ((event.getEventType() == KeyEvent.KEY_PRESSED)
                    &amp;&amp; ESCAPE_KEY_COMBINATION.match(event)) {
                handleEscapeKeyPressedEvent(event);
            }
        }

        private void handleEscapeKeyPressedEvent(final Event event) {
            if (popupWindow.isHideOnEscape()) {
                popupWindow.doAutoHide();

                if (popupWindow.getConsumeAutoHidingEvents()) {
                    event.consume();
                }
            }
        }

        private void handleAutoHidingEvents(final Object eventSource,
                                            final Event event) {
            // we handle mouse pressed only for the immediate parent window,
            // where we can check whether the mouse press is inside of the owner
            // control or not, we will force possible child popups to close
            // by sending the FOCUS_UNGRAB event
            if (popupWindow.getOwnerWindow() != eventSource) {
                return;
            }

            if (popupWindow.isAutoHide() &amp;&amp; !isOwnerNodeEvent(event)) {
                // the mouse press is outside of the owner control,
                // fire FOCUS_UNGRAB to child popups
                Event.fireEvent(popupWindow, new FocusUngrabEvent());

                popupWindow.doAutoHide();

                if (popupWindow.getConsumeAutoHidingEvents()) {
                    event.consume();
                }
            }
        }

        private void handleFocusUngrabEvent() {
            if (popupWindow.isAutoHide()) {
                popupWindow.doAutoHide();
            }
        }

        private boolean isOwnerNodeEvent(final Event event) {
            final Node ownerNode = popupWindow.getOwnerNode();
            if (ownerNode == null) {
                return false;
            }

            final EventTarget eventTarget = event.getTarget();
            if (!(eventTarget instanceof Node)) {
                return false;
            }

            Node node = (Node) eventTarget;
            do {
                if (node == ownerNode) {
                    return true;
                }
                node = node.getParent();
            } while (node != null);

            return false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/com/sun/javafx/embed/swing/CachingTransferable.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.embed.swing;

import java.awt.datatransfer.DataFlavor;
<A NAME="0"></A>import java.awt.datatransfer.Transferable;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#0',2,'match45-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javafx.scene.input.Clipboard;
import javafx.scene.input.DataFormat;

/**
 * A Transferable implementation backed by a Map.
 * The data can be populated either from AWT Transferable
 * or from FX Clipboard.
 */
public class CachingTransferable implements Transferable {

    @Override
    public Object getTransferData(final DataFlavor flavor) throws UnsupportedEncodingException
    {
        String mimeType = DataFlavorUtils.getFxMimeType</B></FONT>(flavor);
        return DataFlavorUtils.adjustFxData(
                flavor, getData(mimeType));
    }

    @Override
    public DataFlavor[] getTransferDataFlavors() {
        final String mimeTypes[] = getMimeTypes();
        return DataFlavorUtils.getDataFlavors(mimeTypes);
    }

    @Override
    public boolean isDataFlavorSupported(final DataFlavor flavor) {
        return isMimeTypeAvailable(
                DataFlavorUtils.getFxMimeType(flavor));
    }

    private Map&lt;String, Object&gt; mimeType2Data = Collections.EMPTY_MAP;

    public void updateData(Transferable t, boolean fetchData) {
        final Map&lt;String, DataFlavor&gt; mimeType2DataFlavor =
                DataFlavorUtils.adjustSwingDataFlavors(
                t.getTransferDataFlavors());

        // If we keep reference to source Transferable in SwingDragSource and
        // call Transferable#getTransferData() on it from
        // SwingDragSource#getData() we may run into
        // &quot;java.awt.dnd.InvalidDnDOperationException&quot; issue as
        // SwingDragSource#getData() is called from FX user code and from
        // QuantumClipboard#getContent() (sik!). These calls usually take
        // place in the context of
        // EmbeddedSceneDTInterface#handleDragDrop() method as the
        // normal handling of DnD.
        // Instead of keeping reference to source Transferable we just read
        // all its data while in the context safe for calling
        // Transferable#getTransferData().
        //
        // This observation is true for standard AWT Transferable-s.
        // Things may be totally broken for custom Transferable-s though.

        // For performance reasons, the DRAG_ENTERED and DRAG_OVER event
        // handlers pass fetchData == false so as to update the set of
        // available MIME types only. The DRAG_DROPPED handler passes
        // fetchData == true which also fetches all the data.
        // NOTE: Due to JDK-8028585 this code won't be able to fetch data
        // when invoked from handlers other than DROPPED in any case.

        try {
            mimeType2Data = DataFlavorUtils.readAllData(t, mimeType2DataFlavor,
                    fetchData);
        } catch (Exception e) {
            mimeType2Data = Collections.EMPTY_MAP;
        }
    }

    public void updateData(Clipboard cb, boolean fetchData) {
        mimeType2Data = new HashMap&lt;&gt;();
        for (DataFormat f : cb.getContentTypes()) {
            mimeType2Data.put(DataFlavorUtils.getMimeType(f),
                    fetchData ? cb.getContent(f) : null);
        }
    }

    public Object getData(final String mimeType) {
        return mimeType2Data.get(mimeType);
    }

    public String[] getMimeTypes() {
        return mimeType2Data.keySet().toArray(new String[0]);
    }

    public boolean isMimeTypeAvailable(final String mimeType) {
        return Arrays.asList(getMimeTypes()).contains(mimeType);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/javafx/embed/swing/SwingNode.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.embed.swing;

import javax.swing.JComponent;
import javax.swing.Timer;
import java.awt.AWTEvent;
import java.awt.EventQueue;
import java.awt.Toolkit;
import java.awt.event.InputEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.WindowEvent;
import java.awt.event.WindowFocusListener;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.stage.Window;
import java.lang.ref.WeakReference;
import java.nio.IntBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.embed.swing.Disposer;
import com.sun.javafx.embed.swing.DisposerRecord;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.sg.prism.NGExternalNode;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.stage.FocusUngrabEvent;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.scene.NodeHelper;
import static javafx.stage.WindowEvent.WINDOW_HIDDEN;

import com.sun.javafx.embed.swing.SwingNodeHelper;
import com.sun.javafx.embed.swing.SwingEvents;
import com.sun.javafx.embed.swing.InteropFactory;
import com.sun.javafx.embed.swing.SwingNodeInterop;

/**
 * This class is used to embed a Swing content into a JavaFX application.
 * The content to be displayed is specified with the {@link #setContent} method
 * that accepts an instance of Swing {@code JComponent}. The hierarchy of components
 * contained in the {@code JComponent} instance should not contain any heavyweight
 * components, otherwise {@code SwingNode} may fail to paint it. The content gets
 * repainted automatically. All the input and focus events are forwarded to the
 * {@code JComponent} instance transparently to the developer.
 * &lt;p&gt;
 * Here is a typical pattern which demonstrates how {@code SwingNode} can be used:
 * &lt;pre&gt;
 *     public class SwingFx extends Application {
 *
 *         &amp;#064;Override
 *         public void start(Stage stage) {
 *             final SwingNode swingNode = new SwingNode();
 *             createAndSetSwingContent(swingNode);
 *
 *             StackPane pane = new StackPane();
 *             pane.getChildren().add(swingNode);
 *
 *             stage.setScene(new Scene(pane, 100, 50));
 *             stage.show();
 *         }
 *
 *         private void createAndSetSwingContent(final SwingNode swingNode) {
 *             SwingUtilities.invokeLater(new Runnable() {
 *                 &amp;#064;Override
 *                 public void run() {
 *                     swingNode.setContent(new JButton(&quot;Click me!&quot;));
 *                 }
 *             });
 *         }
 *
 *         public static void main(String[] args) {
 *             launch(args);
 *         }
 *     }
 * &lt;/pre&gt;
 * @since JavaFX 8.0
 */
public class SwingNode extends Node {
    private static boolean isThreadMerged;
    private SwingNodeInterop swNodeIOP;
    private static InteropFactory iopFactoryInstance = null;

    static {
        try {
            iopFactoryInstance = InteropFactory.getInstance();
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }

        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            public Object run() {
                isThreadMerged = Boolean.valueOf(
                        System.getProperty(&quot;javafx.embed.singleThread&quot;));
                return null;
            }
        });


         // This is used by classes in different packages to get access to
         // private and package private methods.
        SwingNodeHelper.setSwingNodeAccessor(new SwingNodeHelper.SwingNodeAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((SwingNode) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((SwingNode) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((SwingNode) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((SwingNode) node).doComputeContains(localX, localY);
            }

            @Override
            public Object getLightweightFrame(SwingNode node) {
                return node.getLightweightFrame();
            }

            @Override
            public ReentrantLock getPaintLock(SwingNode node) {
                return node.getPaintLock();
            }

            @Override
            public void setImageBuffer(SwingNode node, final int[] data,
                               final int x, final int y,
                               final int w, final int h, final int linestride,
                               final double scaleX, final double scaleY) {
                node.setImageBuffer(data, x, y, w, h, linestride, scaleX, scaleY);
            }

            @Override
            public void setImageBounds(SwingNode node, final int x, final int y,
                               final int w, final int h) {
                node.setImageBounds(x, y, w, h);
            }

            @Override
            public void repaintDirtyRegion(SwingNode node, final int dirtyX, final int dirtyY,
                               final int dirtyWidth, final int dirtyHeight) {
                node.repaintDirtyRegion(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            }

            @Override
            public void ungrabFocus(SwingNode node, boolean postUngrabEvent) {
                node.ungrabFocus(postUngrabEvent);
            }

            @Override
            public void setSwingPrefWidth(SwingNode node, int swingPrefWidth) {
                node.swingPrefWidth = swingPrefWidth;
            }

            @Override
            public void setSwingPrefHeight(SwingNode node, int swingPrefHeight) {
                node.swingPrefHeight = swingPrefHeight;
            }

            @Override
            public void setSwingMaxWidth(SwingNode node, int swingMaxWidth) {
                node.swingMaxWidth = swingMaxWidth;
            }

            @Override
            public void setSwingMaxHeight(SwingNode node, int swingMaxHeight) {
                node.swingMaxHeight = swingMaxHeight;
            }

            @Override
            public void setSwingMinWidth(SwingNode node, int swingMinWidth) {
                node.swingMinWidth = swingMinWidth;
            }

            @Override
            public void setSwingMinHeight(SwingNode node, int swingMinHeight) {
                node.swingMinHeight = swingMinHeight;
            }

            @Override
            public void setGrabbed(SwingNode node, boolean grab) {
                node.grabbed = grab;
            }
        });
    }

    private double fxWidth;
    private double fxHeight;
    private int swingPrefWidth;
    private int swingPrefHeight;
    private int swingMaxWidth;
    private int swingMaxHeight;
    private int swingMinWidth;
    private int swingMinHeight;

    private volatile JComponent content;
    private volatile Object lwFrame;
    private final Object getLightweightFrame() { return lwFrame; }

    private NGExternalNode peer;

    private final ReentrantLock paintLock = new ReentrantLock();

    private ReentrantLock getPaintLock() {
        return paintLock;
    }

    private boolean skipBackwardUnrgabNotification;
    private boolean grabbed; // lwframe initiated grab
    private Timer deactivate; // lwFrame deactivate delay for Linux

    {
        // To initialize the class helper at the begining each constructor of this class
        SwingNodeHelper.initHelper(this);
    }

    /**
     * Constructs a new instance of {@code SwingNode}.
     */
    public SwingNode() {
        swNodeIOP = iopFactoryInstance.createSwingNodeImpl();
        setFocusTraversable(true);
        setEventHandler(MouseEvent.ANY, new SwingMouseEventHandler());
        setEventHandler(KeyEvent.ANY, new SwingKeyEventHandler());
        setEventHandler(ScrollEvent.SCROLL, new SwingScrollEventHandler());

        focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
             activateLwFrame(newValue);
        });

        //Workaround for RT-34170
        javafx.scene.text.Font.getFamilies();
    }


    private EventHandler windowHiddenHandler = (Event event) -&gt; {
        if (lwFrame != null &amp;&amp;  event.getTarget() instanceof Window) {
            final Window w = (Window) event.getTarget();
            TKStage tk = WindowHelper.getPeer(w);
            if (tk != null) {
                if (isThreadMerged) {
                    swNodeIOP.overrideNativeWindowHandle(lwFrame, 0L, null);
                } else {
                    // Postpone actual window closing to ensure that
                    // a native window handler is valid on a Swing side
                    tk.postponeClose();
                    SwingNodeHelper.runOnEDT(() -&gt; {
                        swNodeIOP.overrideNativeWindowHandle(lwFrame, 0L,
                            (Runnable) () -&gt; SwingNodeHelper.runOnFxThread(
                                        () -&gt; tk.closePostponed()));
                    });
                }
            }
        }

    };

    private Window hWindow = null;
    private void notifyNativeHandle(Window window) {
        if (hWindow != window) {
            if (hWindow != null) {
                hWindow.removeEventHandler(WINDOW_HIDDEN, windowHiddenHandler);
            }
            if (window != null) {
                window.addEventHandler(WINDOW_HIDDEN, windowHiddenHandler);
            }
            hWindow = window;
        }

        if (lwFrame != null) {
            long rawHandle = 0L;
            if (window != null) {
                TKStage tkStage = WindowHelper.getPeer(window);
                if (tkStage != null) {
                    rawHandle = tkStage.getRawHandle();
                }
            }
            swNodeIOP.overrideNativeWindowHandle(lwFrame, rawHandle, null);
        }
    }

    /**
     * Attaches a {@code JComponent} instance to display in this {@code SwingNode}.
     * &lt;p&gt;
     * The method can be called either on the JavaFX Application thread or the Event Dispatch thread.
     * Note however, that access to a Swing component must occur from the Event Dispatch thread
     * according to the Swing threading restrictions.
     *
     * @param content a Swing component to display in this {@code SwingNode}
     *
     * @see java.awt.EventQueue#isDispatchThread()
     * @see javafx.application.Platform#isFxApplicationThread()
     */
    public void setContent(final JComponent content) {
        this.content = content;

        SwingNodeHelper.runOnEDT(() -&gt; setContentImpl(content));
    }

    /**
     * Returns the {@code JComponent} instance attached to this {@code SwingNode}.
     * &lt;p&gt;
     * The method can be called either on the JavaFX Application thread or the Event Dispatch thread.
     * Note however, that access to a Swing component must occur from the Event Dispatch thread
     * according to the Swing threading restrictions.
     *
     * @see java.awt.EventQueue#isDispatchThread()
     * @see javafx.application.Platform#isFxApplicationThread()
     *
     * @return the Swing component attached to this {@code SwingNode}
     */
    public JComponent getContent() {
        return content;
    }

    /*
     * Called on EDT
     */
    private void setContentImpl(JComponent content) {
        if (lwFrame != null) {
            swNodeIOP.disposeFrame(lwFrame);
            lwFrame = null;
        }
        if (content != null) {
            lwFrame = swNodeIOP.createLightweightFrame();

            SwingNodeWindowFocusListener snfListener =
                                 new SwingNodeWindowFocusListener(this);
            swNodeIOP.addWindowFocusListener(lwFrame, snfListener);

            if (getScene() != null) {
                Window window = getScene().getWindow();
                if (window != null) {
                    swNodeIOP.notifyDisplayChanged(lwFrame, window.getRenderScaleX(),
                                               window.getRenderScaleY());
                }
            }
            swNodeIOP.setContent(lwFrame, swNodeIOP.createSwingNodeContent(content, this));
            swNodeIOP.setVisible(lwFrame, true);

            Disposer.addRecord(this, swNodeIOP.createSwingNodeDisposer(lwFrame));

            if (getScene() != null) {
                notifyNativeHandle(getScene().getWindow());
            }

            SwingNodeHelper.runOnFxThread(() -&gt; {
                locateLwFrame();// initialize location

                if (focusedProperty().get()) {
                    activateLwFrame(true);
                }
            });
        }
    }

    private List&lt;Runnable&gt; peerRequests = new ArrayList&lt;&gt;();

    /*
     * Called on EDT
     */
    void setImageBuffer(final int[] data,
                        final int x, final int y,
                        final int w, final int h,
                        final int linestride,
                        final double scaleX,
                        final double scaleY)
    {
        Runnable r = () -&gt; peer.setImageBuffer(IntBuffer.wrap(data), x, y, w, h,
                                w, h, linestride, scaleX, scaleY);
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if (peer != null) {
                r.run();
            } else {
                peerRequests.clear();
                peerRequests.add(r);
            }
        });
    }

    /*
     * Called on EDT
     */
    void setImageBounds(final int x, final int y, final int w, final int h) {
        Runnable r = () -&gt; peer.setImageBounds(x, y, w, h, w, h);
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if (peer != null) {
                r.run();
            } else {
                peerRequests.add(r);
            }
        });
    }

    /*
     * Called on EDT
     */
    void repaintDirtyRegion(final int dirtyX, final int dirtyY, final int dirtyWidth, final int dirtyHeight) {
        Runnable r = () -&gt; {
            peer.repaintDirtyRegion(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
        };
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if (peer != null) {
                r.run();
            } else {
                peerRequests.add(r);
            }
        });
    }

    @Override public boolean isResizable() {
        return true;
    }

    /**
     * Invoked by the {@code SwingNode}'s parent during layout to set the {@code SwingNode}'s
     * width and height. &lt;b&gt;Applications should not invoke this method directly&lt;/b&gt;.
     * If an application needs to directly set the size of the {@code SwingNode}, it should
     * set the Swing component's minimum/preferred/maximum size constraints which will
     * be propagated correspondingly to the {@code SwingNode} and it's parent will honor those
     * settings during layout.
     *
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     */
    @Override public void resize(final double width, final double height) {
        super.resize(width, height);
        if (width != this.fxWidth || height != this.fxHeight) {
            this.fxWidth = width;
            this.fxHeight = height;
            NodeHelper.geomChanged(this);
            NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
            SwingNodeHelper.runOnEDT(() -&gt; {
                if (lwFrame != null) {
                    locateLwFrame();
                }
            });
        }
    }

    /**
     * Returns the {@code SwingNode}'s preferred width for use in layout calculations.
     * This value corresponds to the preferred width of the Swing component.
     *
     * @return the preferred width that the node should be resized to during layout
     */
    @Override
    public double prefWidth(double height) {
        return swingPrefWidth;
    }

    /**
     * Returns the {@code SwingNode}'s preferred height for use in layout calculations.
     * This value corresponds to the preferred height of the Swing component.
     *
     * @return the preferred height that the node should be resized to during layout
     */
    @Override
    public double prefHeight(double width) {
        return swingPrefHeight;
    }

    /**
     * Returns the {@code SwingNode}'s maximum width for use in layout calculations.
     * This value corresponds to the maximum width of the Swing component.
     *
     * @return the maximum width that the node should be resized to during layout
     */
    @Override public double maxWidth(double height) {
        return swingMaxWidth;
    }

    /**
     * Returns the {@code SwingNode}'s maximum height for use in layout calculations.
     * This value corresponds to the maximum height of the Swing component.
     *
     * @return the maximum height that the node should be resized to during layout
     */
    @Override public double maxHeight(double width) {
        return swingMaxHeight;
    }

    /**
     * Returns the {@code SwingNode}'s minimum width for use in layout calculations.
     * This value corresponds to the minimum width of the Swing component.
     *
     * @return the minimum width that the node should be resized to during layout
     */
    @Override public double minWidth(double height) {
        return swingMinWidth;
    }

    /**
     * Returns the {@code SwingNode}'s minimum height for use in layout calculations.
     * This value corresponds to the minimum height of the Swing component.
     *
     * @return the minimum height that the node should be resized to during layout
     */
    @Override public double minHeight(double width) {
        return swingMinHeight;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        return true;
    }

    private final InvalidationListener locationListener = observable -&gt; {
        locateLwFrame();
    };

    private final EventHandler&lt;FocusUngrabEvent&gt; ungrabHandler = event -&gt; {
        if (!skipBackwardUnrgabNotification) {
            if (lwFrame != null) {
                AccessController.doPrivileged(new PostEventAction(
                    swNodeIOP.createUngrabEvent(lwFrame)));
            }
        }
    };

    private final ChangeListener&lt;Boolean&gt; windowVisibleListener = (observable, oldValue, newValue) -&gt; {
        if (!newValue) {
            disposeLwFrame();
        } else {
            setContent(content);
        }
    };

    private final ChangeListener&lt;Window&gt; sceneWindowListener = (observable, oldValue, newValue) -&gt; {
        if (oldValue != null) {
            removeWindowListeners(oldValue);
        }

        notifyNativeHandle(newValue);

        if (newValue != null) {
            addWindowListeners(newValue);
        }
    };

    private void removeSceneListeners(Scene scene) {
        Window window = scene.getWindow();
        if (window != null) {
            removeWindowListeners(window);
        }
        scene.windowProperty().removeListener(sceneWindowListener);
    }

    private void addSceneListeners(final Scene scene) {
        Window window = scene.getWindow();
        if (window != null) {
            addWindowListeners(window);
            notifyNativeHandle(window);
        }
        scene.windowProperty().addListener(sceneWindowListener);
    }

    private void addWindowListeners(final Window window) {
        window.xProperty().addListener(locationListener);
        window.yProperty().addListener(locationListener);
        window.widthProperty().addListener(locationListener);
        window.heightProperty().addListener(locationListener);
        window.renderScaleXProperty().addListener(locationListener);
        window.addEventHandler(FocusUngrabEvent.FOCUS_UNGRAB, ungrabHandler);
        window.showingProperty().addListener(windowVisibleListener);
        setLwFrameScale(window.getRenderScaleX(), window.getRenderScaleY());
    }

    private void removeWindowListeners(final Window window) {
        window.xProperty().removeListener(locationListener);
<A NAME="28"></A>        window.yProperty().removeListener(locationListener);
        window.widthProperty().removeListener(locationListener);
        window.heightProperty().removeListener(locationListener);
        <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#28',2,'match45-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>window.renderScaleXProperty().removeListener(locationListener);
        window.removeEventHandler(FocusUngrabEvent.FOCUS_UNGRAB, ungrabHandler);
        window.showingProperty().removeListener(windowVisibleListener);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        peer = new</B></FONT> NGExternalNode();
        peer.setLock(paintLock);
        for (Runnable request : peerRequests) {
            request.run();
        }
        peerRequests = null;

        if (getScene() != null) {
            addSceneListeners(getScene());
        }

        sceneProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != null) {
                // Removed from scene
                removeSceneListeners(oldValue);
                disposeLwFrame();
            }
            if (newValue != null) {
                // Added to another scene
                if (content != null &amp;&amp; lwFrame == null) {
                    setContent(content);
                }
                addSceneListeners(newValue);
            }
        });

        NodeHelper.treeVisibleProperty(this).addListener((observable, oldValue, newValue) -&gt; {
            setLwFrameVisible(newValue);
        });

        return peer;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        if (NodeHelper.isDirty(this, DirtyBits.NODE_VISIBLE)
                || NodeHelper.isDirty(this, DirtyBits.NODE_BOUNDS)) {
            locateLwFrame(); // initialize location
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.markContentDirty();
        }
    }

    private void locateLwFrame() {
        if (getScene() == null
                || lwFrame == null
                || getScene().getWindow() == null
                || !getScene().getWindow().isShowing()) {
            // Not initialized yet. Skip the update to set the real values later
            return;
        }
        Window w = getScene().getWindow();
        double renderScaleX = w.getRenderScaleX();
        double renderScaleY = w.getRenderScaleY();
        final Point2D loc = localToScene(0, 0);
        final int windowX = (int) (w.getX());
        final int windowY = (int) (w.getY());
        final int windowW = (int) (w.getWidth());
        final int windowH = (int) (w.getHeight());
        final int frameX = (int) Math.round(w.getX() + getScene().getX() + loc.getX());
        final int frameY = (int) Math.round(w.getY() + getScene().getY() + loc.getY());
        final int frameW = (int) (fxWidth);
        final int frameH = (int) (fxHeight);

        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.notifyDisplayChanged(lwFrame, renderScaleX, renderScaleY);
                swNodeIOP.setBounds(lwFrame, frameX, frameY, frameW, frameH);
                swNodeIOP.setHostBounds(lwFrame, windowX, windowY, windowW, windowH);
            }
        });
    }

    private void activateLwFrame(final boolean activate) {
        if (lwFrame == null) {
            return;
        }
        if (PlatformUtil.isLinux()) {
            // Workaround to block FocusOut/FocusIn notifications from Unity
            // focus grabbing upon Alt press
            if (deactivate == null || !deactivate.isRunning()) {
                if (!activate) {
                    deactivate = new Timer(50, (e) -&gt; {
                        {
                            if (lwFrame != null) {
                                swNodeIOP.emulateActivation(lwFrame, false);
                            }
                        }
                    });
                    deactivate.start();
                    return;
                }
            } else {
                deactivate.stop();
            }
        }

        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.emulateActivation(lwFrame, activate);
            }
        });
    }

    private void disposeLwFrame() {
        if (lwFrame == null) {
            return;
        }
        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.disposeFrame(lwFrame);
                lwFrame = null;
            }
        });
    }

    private void setLwFrameVisible(final boolean visible) {
        if (lwFrame == null) {
            return;
        }
        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.setVisible(lwFrame, visible);
            }
        });
    }

    private void setLwFrameScale(final double scaleX, final double scaleY) {
        if (lwFrame == null) {
            return;
        }
        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.notifyDisplayChanged(lwFrame, scaleX, scaleY);
        }
    });
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        bounds.deriveWithNewBounds(0, 0, 0, (float)fxWidth, (float)fxHeight, 0);
        tx.transform(bounds, bounds);
        return bounds;
    }


    private static class SwingNodeWindowFocusListener implements WindowFocusListener {
        private WeakReference&lt;SwingNode&gt; swingNodeRef;

        SwingNodeWindowFocusListener(SwingNode swingNode) {
            this.swingNodeRef = new WeakReference&lt;SwingNode&gt;(swingNode);
        }

        @Override
        public void windowGainedFocus(WindowEvent e) {
            SwingNodeHelper.runOnFxThread(() -&gt; {
                SwingNode swingNode = swingNodeRef.get();
                if (swingNode != null) {
                    swingNode.requestFocus();
                }
            });
        }

        @Override
        public void windowLostFocus(WindowEvent e) {
            SwingNodeHelper.runOnFxThread(() -&gt; {
                SwingNode swingNode = swingNodeRef.get();
                if (swingNode != null) {
                    swingNode.ungrabFocus(true);
                }
            });
        }
    }

    private void ungrabFocus(boolean postUngrabEvent) {
        // On X11 grab is limited to a single XDisplay connection,
        // so we can't delegate it to another GUI toolkit.
        if (PlatformUtil.isLinux()) return;

        if (grabbed &amp;&amp;
            getScene() != null &amp;&amp;
            getScene().getWindow() != null &amp;&amp;
            WindowHelper.getPeer(getScene().getWindow()) != null)
        {
            skipBackwardUnrgabNotification = !postUngrabEvent;
            WindowHelper.getPeer(getScene().getWindow()).ungrabFocus();
            skipBackwardUnrgabNotification = false;
            grabbed = false;
        }
    }

    private class PostEventAction implements PrivilegedAction&lt;Void&gt; {
        private AWTEvent event;
        PostEventAction(AWTEvent event) {
            this.event = event;
        }
        @Override
        public Void run() {
            EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue();
            eq.postEvent(event);
            return null;
        }
    }

    private class SwingMouseEventHandler implements EventHandler&lt;MouseEvent&gt; {
        private final Set&lt;MouseButton&gt; mouseClickedAllowed = new HashSet&lt;&gt;();

        @Override
        public void handle(MouseEvent event) {
            Object frame = swNodeIOP.getLightweightFrame();
            if (frame == null) {
                return;
            }
            int swingID = SwingEvents.fxMouseEventTypeToMouseID(event);
            if (swingID &lt; 0) {
                return;
            }

            // Prevent ancestors of the SwingNode from stealing the focus
            event.consume();

            final EventType&lt;?&gt; type = event.getEventType();
            if (type == MouseEvent.MOUSE_PRESSED) {
                mouseClickedAllowed.add(event.getButton());
            } else if (type == MouseEvent.MOUSE_RELEASED) {
                // RELEASED comes before CLICKED, so we don't remove the button from the set
                //mouseClickedAllowed.remove(event.getButton());
            } else if (type == MouseEvent.MOUSE_DRAGGED) {
                // This is what AWT/Swing do
                mouseClickedAllowed.clear();
            } else if (type == MouseEvent.MOUSE_CLICKED) {
                if (event.getClickCount() == 1 &amp;&amp; !mouseClickedAllowed.contains(event.getButton())) {
                    // RT-34610: In FX, CLICKED events are generated even after dragging the mouse pointer
                    // Note that this is only relevant for single clicks. Double clicks use a smudge factor.
                    return;
                }
                mouseClickedAllowed.remove(event.getButton());
            }
            int swingModifiers = SwingEvents.fxMouseModsToMouseMods(event);
            boolean swingPopupTrigger = event.isPopupTrigger();
            int swingButton = SwingEvents.fxMouseButtonToMouseButton(event);
            long swingWhen = System.currentTimeMillis();
            int relX = (int) Math.round(event.getX());
            int relY = (int) Math.round(event.getY());
            int absX = (int) Math.round(event.getScreenX());
            int absY = (int) Math.round(event.getScreenY());
            java.awt.event.MouseEvent mouseEvent =
                    swNodeIOP.createMouseEvent(
                        frame, swingID, swingWhen, swingModifiers,
                        relX, relY, absX, absY,
                        event.getClickCount(), swingPopupTrigger, swingButton);
            AccessController.doPrivileged(new PostEventAction(mouseEvent));
        }
    }

    private class SwingScrollEventHandler implements EventHandler&lt;ScrollEvent&gt; {
        @Override
        public void handle(ScrollEvent event) {
            Object frame = swNodeIOP.getLightweightFrame();
            if (frame == null) {
                return;
            }

            int swingModifiers = SwingEvents.fxScrollModsToMouseWheelMods(event);
            final boolean isShift = (swingModifiers &amp; InputEvent.SHIFT_DOWN_MASK) != 0;

            // Vertical scroll.
            if (!isShift &amp;&amp; event.getDeltaY() != 0.0) {
                sendMouseWheelEvent(frame, event.getX(), event.getY(),
                        swingModifiers, event.getDeltaY() / event.getMultiplierY());
            }
            // Horizontal scroll or shirt+vertical scroll.
            final double delta = isShift &amp;&amp; event.getDeltaY() != 0.0
                                  ? event.getDeltaY() / event.getMultiplierY()
                                  : event.getDeltaX() / event.getMultiplierX();
            if (delta != 0.0) {
                swingModifiers |= InputEvent.SHIFT_DOWN_MASK;
                sendMouseWheelEvent(frame, event.getX(), event.getY(),
                        swingModifiers, delta);
            }
        }

        private void sendMouseWheelEvent(Object source, double fxX, double fxY, int swingModifiers, double delta) {
            int wheelRotation = (int) delta;
            int signum = (int) Math.signum(delta);
            if (signum * delta &lt; 1) {
                wheelRotation = signum;
            }
            int x = (int) Math.round(fxX);
            int y = (int) Math.round(fxY);
            MouseWheelEvent mouseWheelEvent =
                swNodeIOP.createMouseWheelEvent(source, swingModifiers, x, y, -wheelRotation);
            AccessController.doPrivileged(new PostEventAction(mouseWheelEvent));
        }
    }

    private class SwingKeyEventHandler implements EventHandler&lt;KeyEvent&gt; {
        @Override
        public void handle(KeyEvent event) {
            Object frame = swNodeIOP.getLightweightFrame();
            if (frame == null) {
                return;
            }
            if (event.getCharacter().isEmpty()) {
                // TODO: should we post an &quot;empty&quot; character?
                return;
            }
            // Don't let Arrows, Tab, Shift+Tab traverse focus out.
            if (event.getCode() == KeyCode.LEFT  ||
                event.getCode() == KeyCode.RIGHT ||
                event.getCode() == KeyCode.UP ||
                event.getCode() == KeyCode.DOWN ||
                event.getCode() == KeyCode.TAB)
            {
                event.consume();
            }

            int swingID = SwingEvents.fxKeyEventTypeToKeyID(event);
            if (swingID &lt; 0) {
                return;
            }
            int swingModifiers = SwingEvents.fxKeyModsToKeyMods(event);
            int swingKeyCode = event.getCode().getCode();
            char swingChar = event.getCharacter().charAt(0);

            // A workaround. Some swing L&amp;F's process mnemonics on KEY_PRESSED,
            // for which swing provides a keychar. Extracting it from the text.
            if (event.getEventType() == javafx.scene.input.KeyEvent.KEY_PRESSED) {
                String text = event.getText();
                if (text.length() == 1) {
                    swingChar = text.charAt(0);
                }
            }
            long swingWhen = System.currentTimeMillis();
            java.awt.event.KeyEvent keyEvent = swNodeIOP.createKeyEvent(frame,
                swingID, swingWhen, swingModifiers, swingKeyCode,
                swingChar);
            AccessController.doPrivileged(new PostEventAction(keyEvent));
        }
    }
}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/dom/CharacterDataImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<A NAME="26"></A>
package com.sun.webkit.dom;

<FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#26',2,'match45-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.lang.annotation.Native;
import org.w3c.dom.CharacterData;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

public class CharacterDataImpl extends NodeImpl implements CharacterData {
    @Native public static final byte DIRECTIONALITY_LEFT_TO_RIGHT = Character.DIRECTIONALITY_LEFT_TO_RIGHT;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT = Character.DIRECTIONALITY_RIGHT_TO_LEFT;
    @Native public static final byte DIRECTIONALITY_EUROPEAN_NUMBER = Character.DIRECTIONALITY_EUROPEAN_NUMBER;
    @Native public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR = Character.DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR = Character.DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR;
    @Native public static final byte DIRECTIONALITY_ARABIC_NUMBER = Character.DIRECTIONALITY_ARABIC_NUMBER;
    @Native public static final byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR = Character.DIRECTIONALITY_COMMON_NUMBER_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_PARAGRAPH_SEPARATOR = Character.DIRECTIONALITY_PARAGRAPH_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_SEGMENT_SEPARATOR = Character.DIRECTIONALITY_SEGMENT_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_WHITESPACE = Character.DIRECTIONALITY_WHITESPACE;
    @Native public static final byte DIRECTIONALITY_OTHER_NEUTRALS = Character.DIRECTIONALITY_OTHER_NEUTRALS;
    @Native public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING = Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING;
    @Native public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE = Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC = Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING = Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE = Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE;
    @Native public static final byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT = Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT;
    @Native public static final byte DIRECTIONALITY_NONSPACING_MARK = Character.DIRECTIONALITY_NONSPACING_MARK;
    @Native public static final byte DIRECTIONALITY_BOUNDARY_NEUTRAL = Character.DIRECTIONALITY_BOUNDARY_NEUTRAL;
    @Native public static final byte UNASSIGNED = Character.UNASSIGNED;
    @Native public static final byte UPPERCASE_LETTER = Character.UPPERCASE_LETTER;
    @Native public static final byte LOWERCASE_LETTER = Character.LOWERCASE_LETTER;
    @Native public static final byte TITLECASE_LETTER = Character.TITLECASE_LETTER;
    @Native public static final byte MODIFIER_LETTER = Character.MODIFIER_LETTER;
    @Native public static final byte OTHER_LETTER = Character.OTHER_LETTER</B></FONT>;

    @Native public static final byte NON_SPACING_MARK = Character.NON_SPACING_MARK;
    @Native public static final byte ENCLOSING_MARK = Character.ENCLOSING_MARK;
    @Native public static final byte COMBINING_SPACING_MARK = Character.COMBINING_SPACING_MARK;

    @Native public static final byte DECIMAL_DIGIT_NUMBER = Character.DECIMAL_DIGIT_NUMBER;
    @Native public static final byte LETTER_NUMBER = Character.LETTER_NUMBER;
    @Native public static final byte OTHER_NUMBER = Character.OTHER_NUMBER;

    @Native public static final byte SPACE_SEPARATOR = Character.SPACE_SEPARATOR;
    @Native public static final byte LINE_SEPARATOR = Character.LINE_SEPARATOR;
    @Native public static final byte PARAGRAPH_SEPARATOR = Character.PARAGRAPH_SEPARATOR;

    @Native public static final byte CONTROL = Character.CONTROL;
    @Native public static final byte FORMAT = Character.FORMAT;
    @Native public static final byte PRIVATE_USE = Character.PRIVATE_USE;
    @Native public static final byte SURROGATE = Character.SURROGATE;

    @Native public static final byte DASH_PUNCTUATION = Character.DASH_PUNCTUATION;
    @Native public static final byte START_PUNCTUATION = Character.START_PUNCTUATION;
    @Native public static final byte END_PUNCTUATION = Character.END_PUNCTUATION;
    @Native public static final byte CONNECTOR_PUNCTUATION = Character.CONNECTOR_PUNCTUATION;
    @Native public static final byte OTHER_PUNCTUATION = Character.OTHER_PUNCTUATION;

    @Native public static final byte MATH_SYMBOL = Character.MATH_SYMBOL;
    @Native public static final byte CURRENCY_SYMBOL = Character.CURRENCY_SYMBOL;
    @Native public static final byte MODIFIER_SYMBOL = Character.MODIFIER_SYMBOL;
    @Native public static final byte OTHER_SYMBOL = Character.OTHER_SYMBOL;

    @Native public static final byte INITIAL_QUOTE_PUNCTUATION = Character.INITIAL_QUOTE_PUNCTUATION;
    @Native public static final byte FINAL_QUOTE_PUNCTUATION = Character.FINAL_QUOTE_PUNCTUATION;

    CharacterDataImpl(long peer) {
        super(peer);
    }

    static Node getImpl(long peer) {
        return (Node)create(peer);
    }


// Attributes
    public String getData() {
        return getDataImpl(getPeer());
    }
    native static String getDataImpl(long peer);

    public void setData(String value) {
        setDataImpl(getPeer(), value);
    }
    native static void setDataImpl(long peer, String value);

    public int getLength() {
        return getLengthImpl(getPeer());
    }
    native static int getLengthImpl(long peer);

    public Element getPreviousElementSibling() {
        return ElementImpl.getImpl(getPreviousElementSiblingImpl(getPeer()));
    }
    native static long getPreviousElementSiblingImpl(long peer);

    public Element getNextElementSibling() {
        return ElementImpl.getImpl(getNextElementSiblingImpl(getPeer()));
    }
    native static long getNextElementSiblingImpl(long peer);


// Functions
    public String substringData(int offset
        , int length) throws DOMException
    {
        return substringDataImpl(getPeer()
            , offset
            , length);
    }
    native static String substringDataImpl(long peer
        , int offset
        , int length);


    public void appendData(String data)
    {
        appendDataImpl(getPeer()
            , data);
    }
    native static void appendDataImpl(long peer
        , String data);


    public void insertData(int offset
        , String data) throws DOMException
    {
        insertDataImpl(getPeer()
            , offset
            , data);
    }
    native static void insertDataImpl(long peer
        , int offset
        , String data);


    public void deleteData(int offset
        , int length) throws DOMException
    {
        deleteDataImpl(getPeer()
            , offset
            , length);
    }
    native static void deleteDataImpl(long peer
        , int offset
        , int length);


    public void replaceData(int offset
        , int length
        , String data) throws DOMException
    {
        replaceDataImpl(getPeer()
            , offset
            , length
            , data);
    }
    native static void replaceDataImpl(long peer
        , int offset
        , int length
        , String data);


    public void remove() throws DOMException
    {
        removeImpl(getPeer());
    }
    native static void removeImpl(long peer);


}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/network/URLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.network;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.webkit.Invoker;
import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.WebPage;
import static com.sun.webkit.network.URLs.newURL;
import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.lang.annotation.Native;
import java.net.ConnectException;
import java.net.HttpRetryException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.NoRouteToHostException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.net.UnknownHostException;
<A NAME="3"></A>import java.nio.ByteBuffer;
import java.security.AccessControlException;
import java.security.AccessController;
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#3',2,'match45-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.security.PrivilegedAction;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.zip.GZIPInputStream;
import java.util.zip.InflaterInputStream;
import javax.net.ssl.SSLHandshakeException;

/**
 * A runnable that loads a resource specified by a URL.
 */
final class URLLoader implements Runnable {

    @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;

    private static final PlatformLogger logger =
            PlatformLogger.getLogger</B></FONT>(URLLoader.class.getName());
    private static final int MAX_REDIRECTS = 10;
    private static final int MAX_BUF_COUNT = 3;
    private static final String GET = &quot;GET&quot;;
    private static final String HEAD = &quot;HEAD&quot;;
    private static final String DELETE = &quot;DELETE&quot;;


    private final WebPage webPage;
    private final ByteBufferPool byteBufferPool;
    private final boolean asynchronous;
    private String url;
    private String method;
    private final String headers;
    private FormDataElement[] formDataElements;
    private final long data;
    private volatile boolean canceled = false;


    /**
     * Creates a new {@code URLLoader}.
     */
    URLLoader(WebPage webPage,
              ByteBufferPool byteBufferPool,
              boolean asynchronous,
              String url,
              String method,
              String headers,
              FormDataElement[] formDataElements,
              long data)
    {
        this.webPage = webPage;
        this.byteBufferPool = byteBufferPool;
        this.asynchronous = asynchronous;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.formDataElements = formDataElements;
        this.data = data;
    }


    /**
     * Cancels this loader.
     */
    private void fwkCancel() {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
        }
        canceled = true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void run() {
        // Run the loader in the page's access control context
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            doRun();
            return null;
        }, webPage.getAccessControlContext());
    }

    /**
     * Executes this loader.
     */
    private void doRun() {
        Throwable error = null;
        int errorCode = 0;
        try {
            int redirectCount = 0;
            boolean streaming = true;
            boolean connectionResetRetry = true;
            while (true) {
                // RT-14438
                String actualUrl = url;
                if (url.startsWith(&quot;file:&quot;)) {
                    int questionMarkPosition = url.indexOf('?');
                    if (questionMarkPosition != -1) {
                        actualUrl = url.substring(0, questionMarkPosition);
                    }
                }

                URL urlObject = newURL(actualUrl);

                // RT-22458
                workaround7177996(urlObject);

                URLConnection c = urlObject.openConnection();
                prepareConnection(c);

                Redirect redirect = null;
                try {
                    sendRequest(c, streaming);
                    redirect = receiveResponse(c);
                } catch (HttpRetryException ex) {
                    // RT-19914
                    if (streaming) {
                        streaming = false;
                        continue; // retry without streaming
                    } else {
                        throw ex;
                    }
                } catch (SocketException ex) {
                    // SocketException: Connection reset, Retry once
                    if (&quot;Connection reset&quot;.equals(ex.getMessage()) &amp;&amp; connectionResetRetry) {
                        connectionResetRetry = false;
                        continue;
                    } else {
                        throw ex;
                    }
                } finally {
                    close(c);
                }

                if (redirect != null) {
                    if (redirectCount++ &gt;= MAX_REDIRECTS) {
                        throw new TooManyRedirectsException();
                    }
                    boolean resetRequest = !redirect.preserveRequest
                            &amp;&amp; !method.equals(GET) &amp;&amp; !method.equals(HEAD);
                    String newMethod = resetRequest ? GET : method;
                    willSendRequest(redirect.url, newMethod, c);
                    // willSendRequest() may cancel this loader
                    if (canceled) {
                        break;
                    }
                    url = redirect.url;
                    method = newMethod;
                    formDataElements = resetRequest ? null : formDataElements;
                } else {
                    break;
                }
            }
        } catch (MalformedURLException ex) {
            error = ex;
            errorCode = LoadListenerClient.MALFORMED_URL;
        } catch (AccessControlException ex) {
            error = ex;
            errorCode = LoadListenerClient.PERMISSION_DENIED;
        } catch (UnknownHostException ex) {
            error = ex;
            errorCode = LoadListenerClient.UNKNOWN_HOST;
        } catch (NoRouteToHostException ex) {
            error = ex;
            errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;
        } catch (ConnectException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_REFUSED;
        } catch (SocketException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_RESET;
        } catch (SSLHandshakeException ex) {
            error = ex;
            errorCode = LoadListenerClient.SSL_HANDSHAKE;
        } catch (SocketTimeoutException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_TIMED_OUT;
        } catch (InvalidResponseException ex) {
            error = ex;
            errorCode = LoadListenerClient.INVALID_RESPONSE;
        } catch (TooManyRedirectsException ex) {
            error = ex;
            errorCode = LoadListenerClient.TOO_MANY_REDIRECTS;
        } catch (FileNotFoundException ex) {
            error = ex;
            errorCode = LoadListenerClient.FILE_NOT_FOUND;
        } catch (Throwable th) {
            error = th;
            errorCode = LoadListenerClient.UNKNOWN_ERROR;
        }

        if (error != null) {
            if (errorCode == LoadListenerClient.UNKNOWN_ERROR) {
                logger.warning(&quot;Unexpected error&quot;, error);
            } else {
                logger.finest(&quot;Load error&quot;, error);
            }
            didFail(errorCode, error.getMessage());
        }
    }

    private static void workaround7177996(URL url)
        throws FileNotFoundException
    {
        if (!url.getProtocol().equals(&quot;file&quot;)) {
            return;
        }

        String host = url.getHost();
        if (host == null || host.equals(&quot;&quot;) || host.equals(&quot;~&quot;)
                || host.equalsIgnoreCase(&quot;localhost&quot;) )
        {
           return;
        }

        if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
            String path = null;
            try {
                path = URLDecoder.decode(url.getPath(), &quot;UTF-8&quot;);
            } catch (UnsupportedEncodingException e) {
                // The system should always have the platform default
            }
            path = path.replace('/', '\\');
            path = path.replace('|', ':');
            File file = new File(&quot;\\\\&quot; + host + path);
            if (!file.exists()) {
                throw new FileNotFoundException(&quot;File not found: &quot; + url);
            }
        } else {
            throw new FileNotFoundException(&quot;File not found: &quot; + url);
        }
    }

    /**
     * Prepares a connection.
     */
    private void prepareConnection(URLConnection c) throws IOException {
        // The following two timeouts are quite arbitrary and should
        // probably be configurable via an API
        c.setConnectTimeout(30000);   // 30 seconds
        c.setReadTimeout(60000 * 60); // 60 minutes

        // Given that WebKit has its own cache, do not use
        // any URLConnection caches, even if someone installs them.
        // As a side effect, this fixes the problem of WebPane not
        // working well with the plug-in cache, which was one of
        // the causes for RT-11880.
        c.setUseCaches(false);

        Locale loc = Locale.getDefault();
        String lang = &quot;&quot;;
        if (!loc.equals(Locale.US) &amp;&amp; !loc.equals(Locale.ENGLISH)) {
            lang = loc.getCountry().isEmpty() ?
                loc.getLanguage() + &quot;,&quot;:
                loc.getLanguage() + &quot;-&quot; + loc.getCountry() + &quot;,&quot;;
        }
        c.setRequestProperty(&quot;Accept-Language&quot;, lang.toLowerCase() + &quot;en-us;q=0.8,en;q=0.7&quot;);
        c.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);
        c.setRequestProperty(&quot;Accept-Charset&quot;, &quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;);

        if (headers != null &amp;&amp; headers.length() &gt; 0) {
            for (String h : headers.split(&quot;\n&quot;)) {
                int i = h.indexOf(':');
                if (i &gt; 0) {
                    c.addRequestProperty(h.substring(0, i), h.substring(i + 2));
                }
            }
        }

        if (c instanceof HttpURLConnection) {
            HttpURLConnection httpConnection = (HttpURLConnection) c;
            httpConnection.setRequestMethod(method);
            // There are too many bugs in the way HttpURLConnection handles
            // redirects, so we will deal with them ourselves
            httpConnection.setInstanceFollowRedirects(false);
        }
    }

    /**
     * Sends request to the server.
     */
    private void sendRequest(URLConnection c, boolean streaming)
        throws IOException
    {
        OutputStream out = null;
        try {
            long bytesToBeSent = 0;
            boolean sendFormData = formDataElements != null
                    &amp;&amp; c instanceof HttpURLConnection
                    &amp;&amp; !method.equals(DELETE);
            boolean isGetOrHead = method.equals(GET) || method.equals(HEAD);
            if (sendFormData) {
                c.setDoOutput(true);

                for (FormDataElement formDataElement : formDataElements) {
                    formDataElement.open();
                    bytesToBeSent += formDataElement.getSize();
                }

                if (streaming) {
                    HttpURLConnection http = (HttpURLConnection) c;
                    if (bytesToBeSent &lt;= Integer.MAX_VALUE) {
                        http.setFixedLengthStreamingMode((int) bytesToBeSent);
                    } else {
                        http.setChunkedStreamingMode(0);
                    }
                }
            } else if (!isGetOrHead &amp;&amp; (c instanceof HttpURLConnection)) {
                c.setRequestProperty(&quot;Content-Length&quot;, &quot;0&quot;);
            }

            int maxTryCount = isGetOrHead ? 3 : 1;
            c.setConnectTimeout(c.getConnectTimeout() / maxTryCount);
            int tryCount = 0;
            while (!canceled) {
                try {
                    c.connect();
                    break;
                } catch (SocketTimeoutException ex) {
                    if (++tryCount &gt;= maxTryCount) {
                        throw ex;
                    }
                } catch (IllegalArgumentException ex) {
                    // Happens with some malformed URLs
                    throw new MalformedURLException(url);
                }
            }

            if (sendFormData) {
                out = c.getOutputStream();
                byte[] buffer = new byte[4096];
                long bytesSent = 0;
                for (FormDataElement formDataElement : formDataElements) {
                    InputStream in = formDataElement.getInputStream();
                    int count;
                    while ((count = in.read(buffer)) &gt; 0) {
                        out.write(buffer, 0, count);
                        bytesSent += count;
                        didSendData(bytesSent, bytesToBeSent);
                    }
                    formDataElement.close();
                }
                out.flush();
                out.close();
                out = null;
            }
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ignore) {}
            }
            if (formDataElements != null &amp;&amp; c instanceof HttpURLConnection) {
                for (FormDataElement formDataElement : formDataElements) {
                    try {
                        formDataElement.close();
                    } catch (IOException ignore) {}
                }
            }
        }
    }

    /**
     * Receives response from the server.
     */
    private Redirect receiveResponse(URLConnection c)
        throws IOException, InterruptedException
    {
        if (canceled) {
            return null;
        }

        InputStream errorStream = null;

        if (c instanceof HttpURLConnection) {
            HttpURLConnection http = (HttpURLConnection) c;

            int code = http.getResponseCode();
            if (code == -1) {
                throw new InvalidResponseException();
            }

            if (canceled) {
                return null;
            }

            // See RT-17435
            switch (code) {
                case 301: // Moved Permanently
                case 302: // Found
                case 303: // See Other
                case 307: // Temporary Redirect
                    String newLoc = http.getHeaderField(&quot;Location&quot;);
                    if (newLoc != null) {
                        URL newUrl;
                        try {
                            newUrl = newURL(newLoc);
                        } catch (MalformedURLException mue) {
                            // Try to treat newLoc as a relative URI to conform
                            // to popular browsers
                            newUrl = newURL(c.getURL(), newLoc);
                        }
                        return new Redirect(newUrl.toExternalForm(),
                                            code == 307);
                    }
                    break;

                case 304: // Not Modified
                    didReceiveResponse(c);
                    didFinishLoading();
                    return null;
            }

            if (code &gt;= 400 &amp;&amp; !method.equals(HEAD)) {
                errorStream = http.getErrorStream();
            }
        }

        // Let's see if it's an ftp (or ftps) URL and we need to transform
        // a directory listing into HTML
        if (url.startsWith(&quot;ftp:&quot;) || url.startsWith(&quot;ftps:&quot;)) {
            boolean dir = false;
            boolean notsure = false;
            // Unfortunately, there is no clear way to determine if we are
            // accessing a directory, so a bit of guessing is in order
            String path = c.getURL().getPath();
            if (path == null || path.isEmpty() || path.endsWith(&quot;/&quot;)
                    || path.contains(&quot;;type=d&quot;))
            {
                dir = true;
            } else {
                String type = c.getContentType();
                if (&quot;text/plain&quot;.equalsIgnoreCase(type)
                        || &quot;text/html&quot;.equalsIgnoreCase(type))
                {
                    dir = true;
                    notsure = true;
                }
            }
            if (dir) {
                c = new DirectoryURLConnection(c, notsure);
            }
        }

        // Same is true for FileURLConnection
        if (url.startsWith(&quot;file:&quot;)) {
            if(&quot;text/plain&quot;.equals(c.getContentType())
                    &amp;&amp; c.getHeaderField(&quot;content-length&quot;) == null)
            {
                // It is a directory
                c = new DirectoryURLConnection(c);
            }
        }

        didReceiveResponse(c);

        if (method.equals(HEAD)) {
            didFinishLoading();
            return null;
        }

        InputStream inputStream = null;
        try {
            inputStream = errorStream == null
                ? c.getInputStream() : errorStream;
        } catch (HttpRetryException ex) {
            // HttpRetryException is handled from doRun() method.
            // Hence rethrowing the exception to caller(doRun() method)
            throw ex;
        } catch (IOException e) {
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
                    e.getClass().getSimpleName(),
                    e.getMessage()));
            }
        }

        String encoding = c.getContentEncoding();
        if (inputStream != null) {
            try {
                if (&quot;gzip&quot;.equalsIgnoreCase(encoding)) {
                    inputStream = new GZIPInputStream(inputStream);
                } else if (&quot;deflate&quot;.equalsIgnoreCase(encoding)) {
                    inputStream = new InflaterInputStream(inputStream);
                }
            } catch (IOException e) {
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
                        e.getClass().getSimpleName(),
                        e.getMessage()));
                }
            }
        }

        ByteBufferAllocator allocator =
                byteBufferPool.newAllocator(MAX_BUF_COUNT);
        ByteBuffer byteBuffer = null;
        try {
            if (inputStream != null) {
                // 8192 is the default size of a BufferedInputStream used in
                // most URLConnections, by using the same size, we avoid quite
                // a few System.arrayCopy() calls
                byte[] buffer = new byte[8192];
                while (!canceled) {
                    int count;
                    try {
                        count = inputStream.read(buffer);
                    } catch (EOFException ex) {
                        // can be thrown by GZIPInputStream signaling
                        // the end of the stream
                        count = -1;
                    }

                    if (count == -1) {
                        break;
                    }

                    if (byteBuffer == null) {
                        byteBuffer = allocator.allocate();
                    }

                    int remaining = byteBuffer.remaining();
                    if (count &lt; remaining) {
                        byteBuffer.put(buffer, 0, count);
                    } else {
                        byteBuffer.put(buffer, 0, remaining);

                        byteBuffer.flip();
                        didReceiveData(byteBuffer, allocator);
                        byteBuffer = null;

                        int outstanding = count - remaining;
                        if (outstanding &gt; 0) {
                            byteBuffer = allocator.allocate();
                            byteBuffer.put(buffer, remaining, outstanding);
                        }
                    }
                }
            }
            if (!canceled) {
                if (byteBuffer != null &amp;&amp; byteBuffer.position() &gt; 0) {
                    byteBuffer.flip();
                    didReceiveData(byteBuffer, allocator);
                    byteBuffer = null;
                }
                didFinishLoading();
            }
        } finally {
            if (byteBuffer != null) {
                byteBuffer.clear();
                allocator.release(byteBuffer);
            }
        }
        return null;
    }

    /**
     * Releases the resources that may be associated with a connection.
     */
    private static void close(URLConnection c) {
        if (c instanceof HttpURLConnection) {
            InputStream errorStream = ((HttpURLConnection) c).getErrorStream();
            if (errorStream != null) {
                try {
                    errorStream.close();
                } catch (IOException ignore) {}
            }
        }
        try {
            c.getInputStream().close();
        } catch (IOException ignore) {}
    }


    /**
     * A holder for redirect information.
     */
    private static final class Redirect {
        private final String url;
        private final boolean preserveRequest;

        private Redirect(String url, boolean preserveRequest) {
            this.url = url;
            this.preserveRequest = preserveRequest;
        }
    }

    /**
     * Signals an invalid response from the server.
     */
    private static final class InvalidResponseException extends IOException {
        private InvalidResponseException() {
            super(&quot;Invalid server response&quot;);
        }
    }

    /**
     * Signals that too many redirects have been encountered
     * while processing the request.
     */
    private static final class TooManyRedirectsException extends IOException {
        private TooManyRedirectsException() {
            super(&quot;Too many redirects&quot;);
        }
    }

    private void didSendData(final long totalBytesSent,
                             final long totalBytesToBeSent)
    {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidSendData(totalBytesSent, totalBytesToBeSent);
            }
        });
    }

    private void notifyDidSendData(long totalBytesSent,
                                   long totalBytesToBeSent)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;totalBytesSent: [%d], &quot;
                    + &quot;totalBytesToBeSent: [%d], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    totalBytesSent,
                    totalBytesToBeSent,
                    data));
        }
        twkDidSendData(totalBytesSent, totalBytesToBeSent, data);
    }

    private void willSendRequest(String newUrl,
                                 final String newMethod,
                                 URLConnection c) throws InterruptedException
    {
        final String adjustedNewUrl = adjustUrlForWebKit(newUrl);
        final int status = extractStatus(c);
        final String contentType = c.getContentType();
        final String contentEncoding = extractContentEncoding(c);
        final long contentLength = extractContentLength(c);
        final String responseHeaders = extractHeaders(c);
        final String adjustedUrl = adjustUrlForWebKit(url);
        final CountDownLatch latch =
                asynchronous ? new CountDownLatch(1) : null;
        callBack(() -&gt; {
            try {
                if (!canceled) {
                    boolean keepGoing = notifyWillSendRequest(
                            adjustedNewUrl,
                            newMethod,
                            status,
                            contentType,
                            contentEncoding,
                            contentLength,
                            responseHeaders,
                            adjustedUrl);
                    if (!keepGoing) {
                        fwkCancel();
                    }
                }
            } finally {
                if (latch != null) {
                    latch.countDown();
                }
            }
        });
        if (latch != null) {
            latch.await();
        }
    }

    private boolean notifyWillSendRequest(String newUrl,
                                          String newMethod,
                                          int status,
                                          String contentType,
                                          String contentEncoding,
                                          long contentLength,
                                          String headers,
                                          String url)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;newUrl: [%s], &quot;
                    + &quot;newMethod: [%s], &quot;
                    + &quot;status: [%d], &quot;
                    + &quot;contentType: [%s], &quot;
                    + &quot;contentEncoding: [%s], &quot;
                    + &quot;contentLength: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;data: [0x%016X], &quot;
                    + &quot;headers:%n%s&quot;,
                    newUrl,
                    newMethod,
                    status,
                    contentType,
                    contentEncoding,
                    contentLength,
                    url,
                    data,
                    Util.formatHeaders(headers)));
        }
        boolean result = twkWillSendRequest(
                newUrl,
                newMethod,
                status,
                contentType,
                contentEncoding,
                contentLength,
                headers,
                url,
                data);
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;result: [%s]&quot;, result));
        }
        return result;
    }

    private void didReceiveResponse(URLConnection c) {
        final int status = extractStatus(c);
        final String contentType = c.getContentType();
        final String contentEncoding = extractContentEncoding(c);
        final long contentLength = extractContentLength(c);
        final String responseHeaders = extractHeaders(c);
        final String adjustedUrl = adjustUrlForWebKit(url);
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidReceiveResponse(
                        status,
                        contentType,
                        contentEncoding,
                        contentLength,
                        responseHeaders,
                        adjustedUrl);
            }
        });
    }

    private void notifyDidReceiveResponse(int status,
                                          String contentType,
                                          String contentEncoding,
                                          long contentLength,
                                          String headers,
                                          String url)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;status: [%d], &quot;
                    + &quot;contentType: [%s], &quot;
                    + &quot;contentEncoding: [%s], &quot;
                    + &quot;contentLength: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;data: [0x%016X], &quot;
                    + &quot;headers:%n%s&quot;,
                    status,
                    contentType,
                    contentEncoding,
                    contentLength,
                    url,
                    data,
                    Util.formatHeaders(headers)));
        }
        twkDidReceiveResponse(
                status,
                contentType,
                contentEncoding,
                contentLength,
                headers,
                url,
                data);
    }

    private void didReceiveData(final ByteBuffer byteBuffer,
                                final ByteBufferAllocator allocator)
    {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidReceiveData(
                        byteBuffer,
                        byteBuffer.position(),
                        byteBuffer.remaining());
            }
            byteBuffer.clear();
            allocator.release(byteBuffer);
        });
    }

    private void notifyDidReceiveData(ByteBuffer byteBuffer,
                                      int position,
                                      int remaining)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;byteBuffer: [%s], &quot;
                    + &quot;position: [%s], &quot;
                    + &quot;remaining: [%s], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    byteBuffer,
                    position,
                    remaining,
                    data));
        }
        twkDidReceiveData(byteBuffer, position, remaining, data);
    }

    private void didFinishLoading() {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidFinishLoading();
            }
        });
    }

    private void notifyDidFinishLoading() {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
        }
        twkDidFinishLoading(data);
    }

    private void didFail(final int errorCode, final String message) {
        final String adjustedUrl = adjustUrlForWebKit(url);
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidFail(errorCode, adjustedUrl, message);
            }
        });
    }

    private void notifyDidFail(int errorCode, String url, String message) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;errorCode: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;message: [%s], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    errorCode,
                    url,
                    message,
                    data));
        }
        twkDidFail(errorCode, url, message, data);
    }

    private void callBack(Runnable runnable) {
        if (asynchronous) {
            Invoker.getInvoker().invokeOnEventThread(runnable);
        } else {
            runnable.run();
        }
    }

    private static native void twkDidSendData(long totalBytesSent,
                                              long totalBytesToBeSent,
                                              long data);

    private static native boolean twkWillSendRequest(String newUrl,
                                                     String newMethod,
                                                     int status,
                                                     String contentType,
                                                     String contentEncoding,
                                                     long contentLength,
                                                     String headers,
                                                     String url,
                                                     long data);

    private static native void twkDidReceiveResponse(int status,
                                                     String contentType,
                                                     String contentEncoding,
                                                     long contentLength,
                                                     String headers,
                                                     String url,
                                                     long data);

    private static native void twkDidReceiveData(ByteBuffer byteBuffer,
                                                 int position,
                                                 int remaining,
                                                 long data);

    private static native void twkDidFinishLoading(long data);

    private static native void twkDidFail(int errorCode,
                                          String url,
                                          String message,
                                          long data);

    /**
     * Given a {@link URLConnection}, returns the connection status
     * for passing into native callbacks.
     */
    private static int extractStatus(URLConnection c) {
        int status = 0;
        if (c instanceof HttpURLConnection) {
            try {
                status = ((HttpURLConnection) c).getResponseCode();
            } catch (java.io.IOException ignore) {}
        }
        return status;
    }

    /**
     * Given a {@link URLConnection}, returns the content encoding
     * for passing into native callbacks.
     */
    private static String extractContentEncoding(URLConnection c) {
        String contentEncoding = c.getContentEncoding();
        // For compressed streams, the encoding is in Content-Type
        if (&quot;gzip&quot;.equalsIgnoreCase(contentEncoding) ||
            &quot;deflate&quot;.equalsIgnoreCase(contentEncoding))
        {
            contentEncoding = null;
            String contentType  = c.getContentType();
            if (contentType != null) {
                int i = contentType.indexOf(&quot;charset=&quot;);
                if (i &gt;= 0) {
                    contentEncoding = contentType.substring(i + 8);
                    i = contentEncoding.indexOf(&quot;;&quot;);
                    if (i &gt; 0) {
                        contentEncoding = contentEncoding.substring(0, i);
                    }
                }
            }
        }
        return contentEncoding;
    }

    /**
     * Given a {@link URLConnection}, returns the content length
     * for passing into native callbacks.
     */
    private static long extractContentLength(URLConnection c) {
        // Cannot use URLConnection.getContentLength()
        // as it only returns an int
        try {
            return Long.parseLong(c.getHeaderField(&quot;content-length&quot;));
        } catch (Exception ex) {
            return -1;
        }
    }

    /**
     * Given a {@link URLConnection}, returns the headers string
     * for passing into native callbacks.
     */
    private static String extractHeaders(URLConnection c) {
        StringBuilder sb = new StringBuilder();
        Map&lt;String, List&lt;String&gt;&gt; headers = c.getHeaderFields();
        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: headers.entrySet()) {
            String key = entry.getKey();
            List&lt;String&gt; values = entry.getValue();
            for (String value : values) {
                sb.append(key != null ? key : &quot;&quot;);
                sb.append(':').append(value).append('\n');
            }
        }
        return sb.toString();
    }

    /**
     * Adjust a URL string for passing into WebKit.
     */
    private static String adjustUrlForWebKit(String url) {
        try {
            url = Util.adjustUrlForWebKit(url);
        } catch (Exception ignore) {
        }
        return url;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/Controller/TroChoiVietDemo.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.Controller;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;
import sample.Sound.*;
import sample.View.*;
import java.util.*;
import javafx.animation.Interpolator;
import javafx.animation.RotateTransition;
import javafx.animation.SequentialTransition;
import javafx.scene.Node;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class TroChoiVietDemo extends Application {
    private int  matches;
<A NAME="27"></A>    private Queue&lt;Card&gt; queue = new LinkedList&lt;&gt;();
    private Scene startScene;
    private Scene gameScene;
    <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#27',2,'match45-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private Scene endScene;
    private StartView startView;
    private GameView gameView;
    private EndView endView;
    private int timeLevel;
    private Stage primaryStage;
    private Sound sound;

    @Override
    public void start(Stage primaryStage</B></FONT>){
        // Create stage
        setPrimaryStage(new Stage());
        // Add sound
        setSound(new Sound());
        //Create startView, set viewID, width, height and background by css file
        setStartView(new StartView());
        getStartView().setId(&quot;startScene&quot;);
        setStartScene(new Scene(getStartView(), 810, 960));
        getStartScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        // Create EndScene, set viewID, width, height and background by css file
        setEndView(new EndView());
        getEndView().setId(&quot;endScene&quot;);
        setEndScene(new Scene(getEndView(), 710, 444));
        getEndScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        //Set primaryStage firstly show startScene
        getPrimaryStage().setScene(getStartScene());
        getPrimaryStage().setTitle(&quot;Tro Choi Viet&quot;);
        getPrimaryStage().show();
        //


        // Set action for btLevel 1
        getStartView().getBtLevel1().setId(&quot;btLevel1&quot;);
        getStartView().getBtLevel1().setOnAction(getMyHandler());

        // Set action for btLevel 2
        getStartView().getBtLevel2().setId(&quot;btLevel2&quot;);
        getStartView().getBtLevel2().setOnAction(getMyHandler());

        // Set action for btLevel 3
        getStartView().getBtLevel3().setId(&quot;btLevel3&quot;);
        getStartView().getBtLevel3().setOnAction(getMyHandler());
        //
        getStartView().getBtSoundPlay().setId(&quot;play&quot;);
        getStartView().getBtSoundPlay().setOnAction(getMyHandler());
        //
        getStartView().getBtSoundPause().setId(&quot;pause&quot;);
        getStartView().getBtSoundPause().setOnAction(getMyHandler());

        // Set btQuit, btPlayAgain
        getEndView().getBtQuit().setId(&quot;btQuit&quot;);
        getEndView().getBtQuit().setOnAction(getMyHandler());
        getEndView().getBtPlayAgain().setId(&quot;btPlayAgain&quot;);
        getEndView().getBtPlayAgain().setOnAction(getMyHandler());
    }

    private EventHandler&lt;ActionEvent&gt; myHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override
        public void handle(ActionEvent event) {
            Button x = (Button) event.getSource();
            if (x.getId().equals(getEndView().getBtQuit().getId()))
                System.exit(0);
            else if (x.getId().equals(getEndView().getBtPlayAgain().getId()))
                getPrimaryStage().setScene(getStartScene());
            else if (x.getId().equals(getStartView().getBtLevel1().getId())) {
                setTimeLevel(3);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtLevel2().getId())) {
                setTimeLevel(2);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtLevel3().getId())) {
                setTimeLevel(1);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtSoundPlay().getId()))
                getSound().playMusic();
            else if (x.getId().equals(getStartView().getBtSoundPause().getId()))
                getSound().pauseMusic();
        }
    };

    private void setGameLevel() {
        setGameView(new GameView());
        getGameView().setId(&quot;gameScene&quot;);
        setGameScene(new Scene(getGameView(), 1280, 720));
        getGameScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        getPrimaryStage().setScene(getGameScene());
        setMatches(0);
        // if 10 matches -&gt; switch to endScene
        checkMatches();
        if (getMatches() ==  10) {
            getPrimaryStage().setScene(getEndScene()); }
    }

    private void checkMatches() {
        ArrayList&lt;Card&gt; cards = getGameView().getCards();
        for (Card card : cards){
            card.setOnMouseClicked(event -&gt; {
                getQueue().add(card);
                if(getQueue().size() &lt;= 2){
                    rotateCard(card);
                }
                if(getQueue().size() == 2){
                    Card card1 = getQueue().peek();
                    getQueue().remove();
                    Card card2 = getQueue().peek();
                    getQueue().remove();
                    //Check cardID by print out to the console
                    System.out.println(card1.getCardID());
                    System.out.println(card2.getCardID());
                    // If 2 cards are the same
                    if(card1.getCardID() == card2.getCardID()){
                        showFront2Cards(card1, card2);
                        setMatches(getMatches() + 1);
                        if (getMatches() ==  10) { getPrimaryStage().setScene(getEndScene()); }
                    }
                }
            });
        }
    }

    private void showFront2Cards(Card card1, Card card2) {
        card1.imageProperty().unbind();
        card1.setImage(card1.getFrontSide());
        card2.imageProperty().unbind();
        card2.setImage(card2.getFrontSide());
    }

    private void rotateCard(Card card) {
        RotateTransition rotator1 = createRotator(card);
        rotator1.setOnFinished(evt -&gt; {
            card.getIsFront().set(true);
        }); // When rotator1 completed, the status is true
        RotateTransition rotator2 = new RotateTransition(Duration.millis(getTimeLevel() * 1000), card);
        rotator2.setAxis(Rotate.Y_AXIS);
        rotator2.setFromAngle(0);
        rotator2.setToAngle(0);
        rotator2.setInterpolator(Interpolator.LINEAR);
        rotator2.setOnFinished(evt -&gt; {
            card.getIsFront().set(false);
        }); // When rotator2 completed, the status is false
        RotateTransition rotator3 = createRotator(card);
        SequentialTransition rotator = new SequentialTransition(card, rotator1, rotator2, rotator3);
        rotator.play();
    }

    private RotateTransition createRotator(Node card) {
        // animation length proportional to the rotation angle
        RotateTransition rotator = new RotateTransition(Duration.millis(100), card);
        rotator.setAxis(Rotate.Y_AXIS);
        rotator.setFromAngle(0);
        rotator.setToAngle(180);
        rotator.setInterpolator(Interpolator.LINEAR);

        return rotator;
    }

    private int getMatches() {
        return matches;
    }
    private void setMatches(int number) {
        this.matches = number;
    }

    private Queue&lt;Card&gt; getQueue() {
        return queue;
    }

    private void setQueue(Queue&lt;Card&gt; queue) {
        this.queue = queue;
    }

    private Scene getStartScene() {
        return startScene;
    }
    private void setStartScene(Scene startScene) {
        this.startScene = startScene;
    }

    private int getTimeLevel() {
        return timeLevel;
    }

    private void setTimeLevel(int time) {
        this.timeLevel = time;
    }

    private StartView getStartView() {
        return startView;
    }

    private void setStartView(StartView startView) {
        this.startView = startView;
    }

    private Scene getGameScene() {
        return gameScene;
    }

    private void setGameScene(Scene gameScene) {
        this.gameScene = gameScene;
    }

    private Scene getEndScene() {
        return endScene;
    }

    private void setEndScene(Scene endScene) {
        this.endScene = endScene;
    }

    private GameView getGameView() {
        return gameView;
    }

    private void setGameView(GameView gameView) {
        this.gameView = gameView;
    }

    private EndView getEndView() {
        return endView;
    }

    private void setEndView(EndView endView) {
        this.endView = endView;
    }

    private Stage getPrimaryStage() {
        return primaryStage;
    }

    private void setPrimaryStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    private EventHandler&lt;ActionEvent&gt; getMyHandler() {
        return myHandler;
    }

    public void setSound(Sound sound) {
        this.sound = sound;
    }

    public Sound getSound() {
        return sound;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/Sound/Sound.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 16/12/2019
<A NAME="7"></A>  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#7',2,'match45-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package sample.Sound;

import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import java.io.File;

public class Sound {
    private MediaPlayer mediaPlayer;

    public Sound() {
        //Please set the path of the song before run the program
        String path = &quot;/Users/quocdai/Downloads/OOP_Assignment2-3/src/sample/Sound/JingleBells.mp3&quot;;
        Media media = new Media(new</B></FONT> File(path).toURI().toString());
        setMediaPlayer(new MediaPlayer(media));
        getMediaPlayer().play();
    }

    public MediaPlayer getMediaPlayer() {
        return mediaPlayer;
    }

    public void setMediaPlayer(MediaPlayer mediaPlayer) {
        this.mediaPlayer = mediaPlayer;
    }
    public void pauseMusic() {
        this.mediaPlayer.pause();
    }
    public void playMusic() {
        this.mediaPlayer.play();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/GameView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
<A NAME="25"></A>  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
<FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match45-0.html#25',2,'match45-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package sample.View;

import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import java.util.ArrayList;
import</B></FONT> java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class GameView extends VBox{
    int[] cardIndices = { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10};
    ArrayList &lt;Card&gt; cards = new ArrayList&lt;&gt;();
    private GridPane matrixCards;
    private TimeBar timeBar;
    private Image image;
    private Text timeDisplay;
    private Timer timer;
    private int min = 1;
    private int sec = 59;
    private int milliSec = 99;
    private int totalFront;

    public GameView() {
        setSpacing(20);
        setAlignment(Pos.CENTER_RIGHT);

        matrixCards = new GridPane();
        String prefix = &quot;Images/&quot;;
        String postfix = &quot;.jpg&quot;;
        shuffleCards();
        for (int col = 1; col &lt;= 5; col++) {
            for (int row = 1; row &lt;= 4; row++) {
                String cardID = Integer.toString(cardIndices[row - 1 + 4*(col-1)]);
                Card temp = new Card(prefix + cardID + postfix);
                matrixCards.add(temp, col, row);
                cards.add(temp);
            }
        }
        setTimeBar(new TimeBar());
        getChildren().addAll(matrixCards, getTimeBar());

        //Set timeDisplay
        setTimeDisplay(new Text(&quot;Time: 00:00:00&quot;));
        getTimeDisplay().setFill(Color.YELLOW);
        getTimeDisplay().setFont(Font.font(&quot;Courier&quot;, FontWeight.BOLD, FontPosture.REGULAR, 15));
        getChildren().add(getTimeDisplay());
        timerProcess(); //Set timer
    }

    //For Card
    public void shuffleCards() {
        Random rand = new Random();
        for (int i = 0; i &lt; cardIndices.length; i++) {
            int randomIndexToSwap = rand.nextInt(cardIndices.length);
            int temp = cardIndices[randomIndexToSwap];
            cardIndices[randomIndexToSwap] = cardIndices[i];
            cardIndices[i] = temp;
        }
    }
    //For timer
    private void timerProcess() {

        setTotalFront(0);
        int delay = 40;
        int period = 40;
        setTimer(new Timer());
        getTimer().scheduleAtFixedRate(new TimerTask() {
            public void run() {
                getTimeDisplay().setText(&quot;Time: &quot;+ showCountDown());
            }
        }, delay, period);
    }

    //For timer
    private String showCountDown() {
        setMilliSec(getMilliSec() -4);
        if (getMilliSec() &lt; 0){
            setMilliSec(99);
            setSec(getSec() - 1);
        }
        if (getSec() == 0){
            setSec(59);
            setMin(getMin() - 1);
        }
        if (getMin() &lt; 0) {
            getTimer().cancel();
            return &quot;00:00:00&quot;;
        };
        if (getTotalFront() == 20){
            getTimer().cancel();
        }
        return &quot;0&quot;+Integer.toString(getMin())+&quot;:&quot;+Integer.toString(getSec()/10)+Integer.toString(getSec()%10)+&quot;:&quot;+Integer.toString(getMilliSec());
    }

    private TimeBar getTimeBar() {
        return timeBar;
    }

    private void setTimeBar(TimeBar timeBar) {
        this.timeBar = timeBar;
    }

    private Image getImage() {
        return image;
    }

    private void setImage(Image image) {
        this.image = image;
    }

    public ArrayList&lt;Card&gt; getCards() {
        return cards;
    }

    private Text getTimeDisplay() {
        return timeDisplay;
    }

    private void setTimeDisplay(Text timeDisplay) {
        this.timeDisplay = timeDisplay;
    }

    private Timer getTimer() {
        return timer;
    }

    private void setTimer(Timer timer) {
        this.timer = timer;
    }

    private int getMin() {
        return min;
    }

    private void setMin(int min) {
        this.min = min;
    }

    private int getSec() {
        return sec;
    }

    private void setSec(int sec) {
        this.sec = sec;
    }

    private int getMilliSec() {
        return milliSec;
    }

    private void setMilliSec(int milliSec) {
        this.milliSec = milliSec;
    }

    private int getTotalFront() {
        return totalFront;
    }

    private void setTotalFront(int totalFront) {
        this.totalFront = totalFront;
    }
}
</PRE>

</BODY>
</HTML>
