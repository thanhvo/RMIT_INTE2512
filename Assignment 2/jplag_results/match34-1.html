<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/com/sun/javafx/binding/StringFormatter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.binding;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import javafx.beans.binding.StringBinding;
import javafx.beans.binding.StringExpression;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;


public abstract class StringFormatter extends StringBinding {

    private static Object extractValue(Object obj) {
        return obj instanceof ObservableValue ? ((ObservableValue&lt;?&gt;)obj).getValue() : obj;
    }

    private static Object[] extractValues(Object[] objs) {
        final int n = objs.length;
<A NAME="8"></A>        final Object[] values = new Object[n];
        for (int i = 0; i &lt; n; i++) {
            values[i] = extractValue(objs[i]);
        <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#8',2,'match34-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        return values;
    }

    private static ObservableValue&lt;?&gt;[] extractDependencies(Object... args) {
        final List&lt;ObservableValue&lt;?&gt;&gt; dependencies = new ArrayList&lt;ObservableValue&lt;?&gt;&gt;();
        for (final Object obj : args) {</B></FONT>
            if (obj instanceof ObservableValue) {
                dependencies.add((ObservableValue&lt;?&gt;) obj);
            }
        }
        return dependencies.toArray(new ObservableValue[dependencies.size()]);
    }

    public static StringExpression convert(final ObservableValue&lt;?&gt; observableValue) {
        if (observableValue == null) {
            throw new NullPointerException(&quot;ObservableValue must be specified&quot;);
        }
        if (observableValue instanceof StringExpression) {
            return (StringExpression) observableValue;
        } else {
            return new StringBinding() {
                {
                    super.bind(observableValue);
                }

                @Override
                public void dispose() {
                    super.unbind(observableValue);
                }

                @Override
                protected String computeValue() {
                    final Object value = observableValue.getValue();
                    return (value == null)? &quot;null&quot; : value.toString();
                }

                @Override
                public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                    return FXCollections.&lt;ObservableValue&lt;?&gt;&gt; singletonObservableList(observableValue);
                }
            };
        }
    }

    public static StringExpression concat(final Object... args) {
        if ((args == null) || (args.length == 0)) {
            return StringConstant.valueOf(&quot;&quot;);
        }
        if (args.length == 1) {
            final Object cur = args[0];
            return cur instanceof ObservableValue ? convert((ObservableValue&lt;?&gt;) cur)
                    : StringConstant.valueOf(cur.toString());
        }
        if (extractDependencies(args).length == 0) {
            final StringBuilder builder = new StringBuilder();
            for (final Object obj : args) {
                builder.append(obj);
            }
            return StringConstant.valueOf(builder.toString());
        }
        return new StringFormatter() {
            {
                super.bind(extractDependencies(args));
            }

            @Override
            public void dispose() {
                super.unbind(extractDependencies(args));
            }

            @Override
            protected String computeValue() {
                final StringBuilder builder = new StringBuilder();
                for (final Object obj : args) {
                    builder.append(extractValue(obj));
                }
                return builder.toString();
            }

            @Override
            public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                return FXCollections.unmodifiableObservableList(FXCollections
                        .observableArrayList(extractDependencies(args)));
            }
        };
    }

    public static StringExpression format(final Locale locale, final String format, final Object... args) {
        if (format == null) {
            throw new NullPointerException(&quot;Format cannot be null.&quot;);
        }
        if (extractDependencies(args).length == 0) {
            return StringConstant.valueOf(String.format(locale, format, args));
        }
        final StringFormatter formatter = new StringFormatter() {
            {
                super.bind(extractDependencies(args));
            }

            @Override
            public void dispose() {
                super.unbind(extractDependencies(args));
            }

            @Override
            protected String computeValue() {
                final Object[] values = extractValues(args);
                return String.format(locale, format, values);
            }

            @Override
            public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                return FXCollections.unmodifiableObservableList(FXCollections
                        .observableArrayList(extractDependencies(args)));
            }
        };
        // Force calculation to check format
        formatter.get();
        return formatter;
    }

    public static StringExpression format(final String format, final Object... args) {
        if (format == null) {
            throw new NullPointerException(&quot;Format cannot be null.&quot;);
        }
        if (extractDependencies(args).length == 0) {
            return StringConstant.valueOf(String.format(format, args));
        }
        final StringFormatter formatter = new StringFormatter() {
            {
                super.bind(extractDependencies(args));
            }

            @Override
            public void dispose() {
                super.unbind(extractDependencies(args));
            }

            @Override
            protected String computeValue() {
                final Object[] values = extractValues(args);
                return String.format(format, values);
            }

            @Override
            public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                return FXCollections.unmodifiableObservableList(FXCollections
                        .observableArrayList(extractDependencies(args)));
            }
        };
        // Force calculation to check format
        formatter.get();
        return formatter;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/property/DoubleProperty.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

<A NAME="35"></A>package javafx.beans.property;

import com.sun.javafx.binding.BidirectionalBinding;
<FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#35',2,'match34-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.javafx.binding.ExpressionHelper;
import javafx.beans.binding.Bindings;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableDoubleValue;
import com.sun.javafx.binding.Logging;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableDoubleValue;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * This class defines a {@link Property} wrapping a {@code double} value.
 * &lt;p&gt;
 * The value of a {@code DoubleProperty} can be get and set with {@link #get()},
 * {@link #getValue()}, {@link #set(double)}, and {@link #setValue(Number)}.
 * &lt;p&gt;
 * A property can be bound and unbound unidirectional with
 * {@link #bind(ObservableValue)} and {@link #unbind()}. Bidirectional bindings
 * can be created and removed with {@link #bindBidirectional(Property)} and
 * {@link #unbindBidirectional(Property)}.
 * &lt;p&gt;
 * The context of a {@code DoubleProperty} can be read with {@link #getBean()}
 * and {@link #getName()}.
 * &lt;p&gt;
 * Note: setting or binding this property to a null value will set the property to &quot;0.0&quot;. See {@link #setValue(java.lang.Number) }.
 *
 * @see javafx.beans.value.ObservableDoubleValue
 * @see javafx.beans.value.WritableDoubleValue
 * @see ReadOnlyDoubleProperty
 * @see Property
 *
 * @since JavaFX 2.0
 */
public abstract class DoubleProperty extends ReadOnlyDoubleProperty implements
        Property&lt;Number&gt;, WritableDoubleValue {

    /**
     * {@inheritDoc}
     */
    @Override
    public void setValue(Number v) {</B></FONT>
        if (v == null) {
            Logging.getLogger().fine(&quot;Attempt to set double property to null, using default value instead.&quot;, new NullPointerException());
            set(0.0);
        } else {
            set(v.doubleValue());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void bindBidirectional(Property&lt;Number&gt; other) {
        Bindings.bindBidirectional(this, other);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void unbindBidirectional(Property&lt;Number&gt; other) {
        Bindings.unbindBidirectional(this, other);
    }

    /**
     * Returns a string representation of this {@code DoubleProperty} object.
     * @return a string representation of this {@code DoubleProperty} object.
     */
    @Override
    public String toString() {
        final Object bean = getBean();
        final String name = getName();
        final StringBuilder result = new StringBuilder(
                &quot;DoubleProperty [&quot;);
        if (bean != null) {
            result.append(&quot;bean: &quot;).append(bean).append(&quot;, &quot;);
        }
        if ((name != null) &amp;&amp; (!name.equals(&quot;&quot;))) {
            result.append(&quot;name: &quot;).append(name).append(&quot;, &quot;);
        }
        result.append(&quot;value: &quot;).append(get()).append(&quot;]&quot;);
        return result.toString();
    }

    /**
     * Returns a {@code DoubleProperty} that wraps a
     * {@link javafx.beans.property.Property} and is
     * bidirectionally bound to it.
     * Changing this property will result in a change of the original property.
     *
     * &lt;p&gt;
     * This is very useful when bidirectionally binding an ObjectProperty&amp;lt;Double&amp;gt; and
     * a DoubleProperty.
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     *   DoubleProperty doubleProperty = new SimpleDoubleProperty(1.0);
     *   ObjectProperty&amp;lt;Double&amp;gt; objectProperty = new SimpleObjectProperty&amp;lt;&amp;gt;(2.0);
     *
     *   // Need to keep the reference as bidirectional binding uses weak references
     *   DoubleProperty objectAsDouble = DoubleProperty.doubleProperty(objectProperty);
     *
     *   doubleProperty.bindBidirectional(objectAsDouble);
     *
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * Another approach is to convert the DoubleProperty to ObjectProperty using
     * {@link #asObject()} method.
     * &lt;p&gt;
     * Note: null values in the source property will be interpreted as 0.0
     *
     * @param property
     *            The source {@code Property}
     * @return A {@code DoubleProperty} that wraps the
     *         {@code Property}
     * @throws NullPointerException
     *             if {@code property} is {@code null}
     * @see #asObject()
     * @since JavaFX 8.0
     */
    public static DoubleProperty doubleProperty(final Property&lt;Double&gt; property) {
        if (property == null) {
            throw new NullPointerException(&quot;Property cannot be null&quot;);
        }
        return new DoublePropertyBase() {
            private final AccessControlContext acc = AccessController.getContext();
            {
                BidirectionalBinding.bindNumber(this, property);
            }

            @Override
            public Object getBean() {
                return null; // Virtual property, no bean
            }

            @Override
            public String getName() {
                return property.getName();
            }

            @Override
            protected void finalize() throws Throwable {
                try {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        BidirectionalBinding.unbindNumber(property, this);
                        return null;
                    }, acc);
                } finally {
                    super.finalize();
                }
            }
        };
    }

    /**
     * Creates an {@link javafx.beans.property.ObjectProperty}
     * that bidirectionally bound to this {@code DoubleProperty}. If the
     * value of this {@code DoubleProperty} changes, the value of the
     * {@code ObjectProperty} will be updated automatically and vice-versa.
     *
     * &lt;p&gt;
     * Can be used for binding an ObjectProperty to DoubleProperty.
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     *   DoubleProperty doubleProperty = new SimpleDoubleProperty(1.0);
     *   ObjectProperty&amp;lt;Double&amp;gt; objectProperty = new SimpleObjectProperty&amp;lt;&amp;gt;(2.0);
     *
     *   objectProperty.bind(doubleProperty.asObject());
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return the new {@code ObjectProperty}
     * @since JavaFX 8.0
     */
    @Override
    public ObjectProperty&lt;Double&gt; asObject() {
        return new ObjectPropertyBase&lt;Double&gt; () {
            private final AccessControlContext acc = AccessController.getContext();
            {
                BidirectionalBinding.bindNumber(this, DoubleProperty.this);
            }

            @Override
            public Object getBean() {
                return null; // Virtual property, does not exist on a bean
            }

            @Override
            public String getName() {
                return DoubleProperty.this.getName();
            }

            @Override
            protected void finalize() throws Throwable {
                try {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        BidirectionalBinding.unbindNumber(this, DoubleProperty.this);
                        return null;
                    }, acc);
                } finally {
                    super.finalize();
                }
            }

        };
    }


}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/util/converter/LocalDateTimeStringConverter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.util.converter;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.LocalDateTime;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.chrono.ChronoLocalDateTime;
import java.time.chrono.IsoChronology;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DecimalStyle;
import java.time.format.FormatStyle;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAccessor;
import java.util.Locale;

import javafx.util.StringConverter;

import com.sun.javafx.binding.Logging;

/**
 * &lt;p&gt;{@link StringConverter} implementation for {@link LocalDateTime} values.&lt;/p&gt;
 *
 * @see LocalDateStringConverter
 * @see LocalTimeStringConverter
 * @since JavaFX 8u40
 */
public class LocalDateTimeStringConverter extends StringConverter&lt;LocalDateTime&gt; {

    LdtConverter&lt;LocalDateTime&gt; ldtConverter;



   // ------------------------------------------------------------ Constructors

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values, using a
     * default formatter and parser based on {@link IsoChronology},
     * {@link FormatStyle#SHORT} for both date and time, and the user's
     * {@link Locale}.
     *
     * &lt;p&gt;This converter ensures symmetry between the toString() and
     * fromString() methods. Many of the default locale based patterns used by
     * {@link DateTimeFormatter} will display only two digits for the year when
     * formatting to a string. This would cause a value like 1955 to be
     * displayed as 55, which in turn would be parsed back as 2055. This
     * converter modifies two-digit year patterns to always use four digits. The
     * input parsing is not affected, so two digit year values can still be
     * parsed as expected in these locales.&lt;/p&gt;
     */
    public LocalDateTimeStringConverter() {
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, null, null,
                                                       null, null, null, null);
    }

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values, using
     * a default formatter and parser based on {@link IsoChronology}, the
     * specified {@link FormatStyle} values for date and time, and the user's
     * {@link Locale}.
     *
     * @param dateStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the date. If null then {@link FormatStyle#SHORT}
     * will be used.
     * @param timeStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the time. If null then {@link FormatStyle#SHORT}
     * will be used.
     */
    public LocalDateTimeStringConverter(FormatStyle dateStyle, FormatStyle timeStyle) {
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, null, null,
                                                       dateStyle, timeStyle, null, null);
    }

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values using
     * the supplied formatter and parser.
     *
     * &lt;p&gt;For example, to use a fixed pattern for converting both ways:&lt;/p&gt;
     * &lt;blockquote&gt;&lt;pre&gt;
     * String pattern = &quot;yyyy-MM-dd HH:mm&quot;;
     * DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
     * StringConverter&amp;lt;LocalDateTime&amp;gt; converter =
     *     DateTimeStringConverter.getLocalDateTimeConverter(formatter, null);
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * Note that the formatter and parser can be created to handle non-default
     * {@link Locale} and {@link Chronology} as needed.
     *
     * @param formatter An instance of {@link DateTimeFormatter} which will be
     * used for formatting by the toString() method. If null then a default
     * formatter will be used.
     * @param parser An instance of {@link DateTimeFormatter} which will be used
     * for parsing by the fromString() method. This can be identical to
<A NAME="37"></A>     * formatter. If null then formatter will be used, and if that is also null,
     * then a default parser will be used.
     */
    public LocalDateTimeStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser) <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#37',2,'match34-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, formatter, parser,
                                                       null, null, null, null);
    }

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values using a
     * default formatter and parser, which will be based on the supplied
     * {@link FormatStyle}s, {@link Locale}, and {@link Chronology}.
     *
     * @param dateStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the date. If null then {@link FormatStyle#SHORT}
     * will be used.
     * @param timeStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the time. If null then {@link FormatStyle#SHORT}
     * will be used.
     * @param locale The {@link Locale} that will be used by the
     * default formatter and parser. If null then
     * {@code Locale.getDefault(Locale.Category.FORMAT)} will be used.
     * @param chronology The {@link Chronology} that will be used by the default
     * formatter and parser. If null then {@link IsoChronology#INSTANCE} will be
     * used.
     */
    public LocalDateTimeStringConverter(FormatStyle dateStyle, FormatStyle timeStyle,
                                        Locale locale, Chronology chronology) {</B></FONT>
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, null, null,
                                                       dateStyle, timeStyle, locale, chronology);
    }



    // ------------------------------------------------------- Converter Methods

    /** {@inheritDoc} */
    @Override public LocalDateTime fromString(String value) {
        return ldtConverter.fromString(value);
    }

    /** {@inheritDoc} */
    @Override public String toString(LocalDateTime value) {
        return ldtConverter.toString(value);
    }



    static class LdtConverter&lt;T extends Temporal&gt; extends StringConverter&lt;T&gt; {
        private Class&lt;T&gt; type;
        Locale locale;
        Chronology chronology;
        DateTimeFormatter formatter;
        DateTimeFormatter parser;
        FormatStyle dateStyle;
        FormatStyle timeStyle;

        LdtConverter(Class&lt;T&gt; type, DateTimeFormatter formatter, DateTimeFormatter parser,
                     FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chronology) {
            this.type = type;
            this.formatter = formatter;
            this.parser = (parser != null) ? parser : formatter;
            this.locale = (locale != null) ? locale : Locale.getDefault(Locale.Category.FORMAT);
            this.chronology = (chronology != null) ? chronology : IsoChronology.INSTANCE;

            if (type == LocalDate.class || type == LocalDateTime.class) {
                this.dateStyle = (dateStyle != null) ? dateStyle : FormatStyle.SHORT;
            }

            if (type == LocalTime.class || type == LocalDateTime.class) {
                this.timeStyle = (timeStyle != null) ? timeStyle : FormatStyle.SHORT;
            }
        }

        /** {@inheritDoc} */
        @SuppressWarnings({&quot;unchecked&quot;})
        @Override public T fromString(String text) {
            if (text == null || text.isEmpty()) {
                return null;
            }

            text = text.trim();

            if (parser == null) {
                parser = getDefaultParser();
            }

            TemporalAccessor temporal = parser.parse(text);

            if (type == LocalDate.class) {
                return (T)LocalDate.from(chronology.date(temporal));
            } else if (type == LocalTime.class) {
                return (T)LocalTime.from(temporal);
            } else {
                return (T)LocalDateTime.from(chronology.localDateTime(temporal));
            }
        }


        /** {@inheritDoc} */
        @Override public String toString(T value) {
            // If the specified value is null, return a zero-length String
            if (value == null) {
                return &quot;&quot;;
            }

            if (formatter == null) {
                formatter = getDefaultFormatter();
            }

            if (value instanceof LocalDate) {
                ChronoLocalDate cDate;
                try {
                    cDate = chronology.date(value);
                } catch (DateTimeException ex) {
                    Logging.getLogger().warning(&quot;Converting LocalDate &quot; + value + &quot; to &quot; + chronology + &quot; failed, falling back to IsoChronology.&quot;, ex);
                    chronology = IsoChronology.INSTANCE;
                    cDate = (LocalDate)value;
                }
                return formatter.format(cDate);
            } else if (value instanceof LocalDateTime) {
                ChronoLocalDateTime&lt;? extends ChronoLocalDate&gt; cDateTime;
                try {
                    cDateTime = chronology.localDateTime(value);
                } catch (DateTimeException ex) {
                    Logging.getLogger().warning(&quot;Converting LocalDateTime &quot; + value + &quot; to &quot; + chronology + &quot; failed, falling back to IsoChronology.&quot;, ex);
                    chronology = IsoChronology.INSTANCE;
                    cDateTime = (LocalDateTime)value;
                }
                return formatter.format(cDateTime);
            } else {
                return formatter.format(value);
            }
        }


        private DateTimeFormatter getDefaultParser() {
            String pattern =
                DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle,
                                                                     chronology, locale);
            return new DateTimeFormatterBuilder().parseLenient()
                                                 .appendPattern(pattern)
                                                 .toFormatter()
                                                 .withChronology(chronology)
                                                 .withDecimalStyle(DecimalStyle.of(locale));
        }

        /**
         * &lt;p&gt;Return a default &lt;code&gt;DateTimeFormatter&lt;/code&gt; instance to use for formatting
         * and parsing in this {@link StringConverter}.&lt;/p&gt;
         */
        private DateTimeFormatter getDefaultFormatter() {
            DateTimeFormatter formatter;

            if (dateStyle != null &amp;&amp; timeStyle != null) {
                formatter = DateTimeFormatter.ofLocalizedDateTime(dateStyle, timeStyle);
            } else if (dateStyle != null) {
                formatter = DateTimeFormatter.ofLocalizedDate(dateStyle);
            } else {
                formatter = DateTimeFormatter.ofLocalizedTime(timeStyle);
            }

            formatter = formatter.withLocale(locale)
                                 .withChronology(chronology)
                                 .withDecimalStyle(DecimalStyle.of(locale));

            if (dateStyle != null) {
                formatter = fixFourDigitYear(formatter, dateStyle, timeStyle,
                                             chronology, locale);
            }

            return formatter;
        }

        private DateTimeFormatter fixFourDigitYear(DateTimeFormatter formatter,
                                                   FormatStyle dateStyle, FormatStyle timeStyle,
                                                   Chronology chronology, Locale locale) {
            String pattern =
                DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle,
                                                                     chronology, locale);
            if (pattern.contains(&quot;yy&quot;) &amp;&amp; !pattern.contains(&quot;yyy&quot;)) {
                // Modify pattern to show four-digit year, including leading zeros.
                String newPattern = pattern.replace(&quot;yy&quot;, &quot;yyyy&quot;);
                formatter = DateTimeFormatter.ofPattern(newPattern)
                                             .withDecimalStyle(DecimalStyle.of(locale));
            }

            return formatter;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/ContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Direction;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
<A NAME="5"></A>import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.value.ChangeListener;
<FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#5',2,'match34-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.*;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.stage.Window;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * This is a the SkinBase for ContextMenu based controls so that the CSS parts
 * work right, because otherwise we would have to copy the Keys from there to here.
 */
public class ContextMenuContent extends Region {

    private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;

    private ContextMenu contextMenu;

    /***************************************************************************
     * UI subcomponents
     **************************************************************************/

    private double maxGraphicWidth = 0; // we keep this margin to left for graphic
    private double maxRightWidth = 0;
    private double maxLabelWidth = 0;
    private double maxRowHeight = 0</B></FONT>;
    private double maxLeftWidth = 0;
    private double oldWidth = 0;

    private Rectangle clipRect;
    MenuBox itemsContainer;
    private ArrowMenuItem upArrow;
    private ArrowMenuItem downArrow;

    /*
     * We maintain a current focused index which is used
     * in keyboard navigation of menu items.
     */
    private int currentFocusedIndex = -1;

    private boolean itemsDirty = true;
    private InvalidationListener popupShowingListener = arg0 -&gt; {
        updateItems();
    };
    private WeakInvalidationListener weakPopupShowingListener =
            new WeakInvalidationListener(popupShowingListener);


    /***************************************************************************
     * Constructors
     **************************************************************************/
    public ContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        clipRect = new Rectangle();
         clipRect.setSmooth(false);
        itemsContainer = new MenuBox();
//        itemsContainer = new VBox();
        itemsContainer.setClip(clipRect);

        upArrow = new ArrowMenuItem(this);
        upArrow.setUp(true);
        upArrow.setFocusTraversable(false);

        downArrow = new ArrowMenuItem(this);
        downArrow.setUp(false);
        downArrow.setFocusTraversable(false);
        getChildren().add(itemsContainer);
        getChildren().add(upArrow);
        getChildren().add(downArrow);
        initialize();
        setUpBinds();
        updateItems();
        // RT-20197 add menuitems only on first show.
        popupMenu.showingProperty().addListener(weakPopupShowingListener);

        /*
        ** only add this if we're on an embedded
        ** platform that supports 5-button navigation
        */
        if (Utils.isTwoLevelFocus()) {
            new TwoLevelFocusPopupBehavior(this);
        }
    }

    //For access from controls
    public VBox getItemsContainer() {
        return itemsContainer;
    }
    //For testing purpose only
    int getCurrentFocusIndex() {
        return currentFocusedIndex;
    }
    //For testing purpose only
    void setCurrentFocusedIndex(int index) {
        if (index &lt; itemsContainer.getChildren().size()) {
            currentFocusedIndex = index;
        }
    }

    private void updateItems() {
        if (itemsDirty) {
            updateVisualItems();
            itemsDirty = false;
        }
    }

    private void computeVisualMetrics() {
        maxRightWidth = 0;
        maxLabelWidth = 0;
        maxRowHeight = 0;
        maxGraphicWidth = 0;
        maxLeftWidth = 0;

        for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node child = itemsContainer.getChildren().get(i);
            if (child instanceof MenuItemContainer) {
                final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);

                if (! menuItemContainer.isVisible()) continue;

                double alt = -1;
                Node n = menuItemContainer.left;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.graphic;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.label;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) {
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.right;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }
            }
        }

        // Fix for RT-38838.
        // This fixes the issue where CSS is applied to a menu after it has been
        // showing, resulting in its bounds changing. In this case, we need to
        // shift the submenu such that it is properly aligned with its parent menu.
        //
        // To do this, we must firstly determine if the open submenu is shifted
        // horizontally to appear on the other side of this menu, as this is the
        // only situation where shifting has to happen. If so, we need to check
        // if we should shift the submenu due to changes in width.
        //
        // We need to get the parent menu of this contextMenu, so that we only
        // modify the X value in the following conditions:
        // 1) There exists a parent menu
        // 2) The parent menu is in the correct position (i.e. to the left of this
        //    menu in normal LTR systems).
        final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
        Window ownerWindow = contextMenu.getOwnerWindow();
        if (ownerWindow instanceof ContextMenu) {
            if (contextMenu.getX() &lt; ownerWindow.getX()) {
                if (oldWidth != newWidth) {
                    contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
                }
            }
        }

        oldWidth = newWidth;
    }

    private void updateVisualItems() {
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();

        disposeVisualItems();

        for (int row = 0; row &lt; getItems().size(); row++) {
            final MenuItem item = getItems().get(row);
            if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
                continue;
            }

            if (item instanceof SeparatorMenuItem) {
                // we don't want the hover highlight for separators, so for
                // now this is the simplest approach - just remove the
                // background entirely. This may cause issues if people
                // intend to style the background differently.
                Node node = ((CustomMenuItem) item).getContent();
                node.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(node);
                // Add the (separator) menu item to properties map of this node.
                // Special casing this for separator :
                // This allows associating this container with SeparatorMenuItem.
                node.getProperties().put(MenuItem.class, item);
            } else {
                MenuItemContainer menuItemContainer = new MenuItemContainer(item);
                menuItemContainer.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(menuItemContainer);
            }
        }

        // Add the Menu to properties map of this skin. Used by QA for testing
        // This enables associating a parent menu for this skin showing menu items.
        if (getItems().size() &gt; 0) {
            final MenuItem item = getItems().get(0);
            getProperties().put(Menu.class, item.getParentMenu());
        }

        // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
        NodeHelper.reapplyCSS(this);
    }

    private void disposeVisualItems() {
        // clean up itemsContainer
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
        for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
            Node n = itemsContainerChilder.get(i);

            if (n instanceof MenuItemContainer) {
                MenuItemContainer container = (MenuItemContainer) n;
                container.visibleProperty().unbind();
                container.dispose();
            }
        }
        itemsContainerChilder.clear();
    }

    /**
     * Can be called by Skins when they need to clean up the content of any
     * ContextMenu instances they might have created. This ensures that contents
     * of submenus if any, also get cleaned up.
     */
    public void dispose() {
        disposeBinds();
        disposeVisualItems();

        disposeContextMenu(submenu);
        submenu = null;
        openSubmenu = null;
        selectedBackground = null;
        if (contextMenu != null) {
            contextMenu.getItems().clear();
            contextMenu = null;
        }
    }

    public void disposeContextMenu(ContextMenu menu) {
        if (menu == null) return;

        Skin&lt;?&gt; skin = menu.getSkin();
        if (skin == null) return;

        ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
        if (cmContent == null) return;

        cmContent.dispose(); // recursive call to dispose submenus.
    }

    @Override protected void layoutChildren() {
        if (itemsContainer.getChildren().size() == 0) return;
        final double x = snappedLeftInset();
        final double y = snappedTopInset();
        final double w = getWidth() - x - snappedRightInset();
        final double h = getHeight() - y - snappedBottomInset();
        final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);

        itemsContainer.resize(w,contentHeight);
        itemsContainer.relocate(x, y);

        if (isFirstShow &amp;&amp; ty == 0) {
            upArrow.setVisible(false);
            isFirstShow = false;
        } else {
            upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
        }
        downArrow.setVisible(ty + contentHeight &gt; (y + h));

        clipRect.setX(0);
        clipRect.setY(0);
        clipRect.setWidth(w);
        clipRect.setHeight(h);

        if (upArrow.isVisible()) {
            final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
            clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
            upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
            positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }

        if (downArrow.isVisible()) {
            final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
            downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
            positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }
    }

     @Override protected double computePrefWidth(double height) {
         computeVisualMetrics();
         double prefWidth = 0;
         if (itemsContainer.getChildren().size() == 0) return 0;
         for (Node n : itemsContainer.getChildren()) {
             if (! n.isVisible()) continue;
             prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
         }
         return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
    }

    @Override protected double computePrefHeight(double width) {
        if (itemsContainer.getChildren().size() == 0) return 0;
        final double screenHeight = getScreenHeight();
        final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
        double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
        // the pref height of this menu is the smaller value of the
        // actual pref height and the height of the screens _visual_ bounds.
        double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
        return prefHeight;
    }

    @Override protected double computeMinHeight(double width) {
        return 0.0;
    }

    @Override protected double computeMaxHeight(double height) {
        return getScreenHeight();
    }

    private double getScreenHeight() {
        if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
                contextMenu.getOwnerWindow().getScene() == null) {
            return -1;
        }
        return snapSizeY(com.sun.javafx.util.Utils.getScreen(
            contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());

    }

    private double getContentHeight() {
        double h = 0.0d;
        for (Node i : itemsContainer.getChildren()) {
            if (i.isVisible()) {
               h += snapSizeY(i.prefHeight(-1));
            }
        }
        return h;
    }

    // This handles shifting ty when doing keyboard navigation.
    private void ensureFocusedMenuItemIsVisible(Node node) {
        if (node == null) return;

        final Bounds nodeBounds = node.getBoundsInParent();
        final Bounds clipBounds = clipRect.getBoundsInParent();

        if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
            // this is for moving down the menu
            scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
        } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
            // this is for moving up the menu
            scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
        }
    }

    protected ObservableList&lt;MenuItem&gt; getItems() {
        return contextMenu.getItems();
    }

    /**
     * Finds the index of currently focused item.
     */
    private int findFocusedIndex() {
         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node n = itemsContainer.getChildren().get(i);
            if (n.isFocused()) {
                return i;
            }
        }
        return -1;
    }

    private boolean isFirstShow = true;
    private double ty;

    private void initialize() {
        // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
        contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
            currentFocusedIndex = -1;
            for (Node child : itemsContainer.getChildren()) {
                if (child instanceof MenuItemContainer) {
                    final MenuItem item = ((MenuItemContainer)child).item;
                    // When the choiceBox popup is shown, if this menu item is selected
                    // do a requestFocus so CSS kicks in and the item is highlighted.
                    if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
                        if (((RadioMenuItem)item).isSelected()) {
                            child.requestFocus();
                            break;
                        }
                    }
                }

            }
        });

//        // FIXME For some reason getSkinnable()Behavior traversal functions don't
//        // get called as expected, so I've just put the important code below.
        // We use setOnKeyPressed here as we are not adding a listener to a public
        // event type (ContextMenuContent is not public API), and without this
        // we get the issue shown in RT-34429
        setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent ke) {
                switch (ke.getCode()) {
                    case LEFT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processRightKey(ke);
                        } else {
                            processLeftKey(ke);
                        }
                        break;
                    case RIGHT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processLeftKey(ke);
                        } else {
                            processRightKey(ke);
                        }
                        break;
                    case CANCEL:
                        ke.consume();
                        break;
                    case ESCAPE:
                        // if the owner is not a menubar button, just close the
                        // menu - this will move focus up to the parent menu
                        // as required. In the case of the parent being a
                        // menubar button we special case in the conditional code
                        // beneath this switch statement. See RT-34429 for more context.
                        final Node ownerNode = contextMenu.getOwnerNode();
                        if (! (ownerNode instanceof MenuBarButton)) {
                            contextMenu.hide();
                            ke.consume();
                        }
                        break;
                    case DOWN:
                        // move to the next sibling
                        move(Direction.NEXT);
                        ke.consume();
                        break;
                    case UP:
                        // move to previous sibling
                        move(Direction.PREVIOUS);
                        ke.consume();
                        break;
                    case SPACE:
                    case ENTER:
                        // select the menuitem
                        selectMenuItem();
                        ke.consume();
                        break;
                    default:
                        break;
                }

                if (!ke.isConsumed()) {
                    final Node ownerNode = contextMenu.getOwnerNode();
                    if (ownerNode instanceof MenuItemContainer) {
                        // Forward to parent menu
                        Parent parent = ownerNode.getParent();
                        while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
                            parent = parent.getParent();
                        }
                        if (parent instanceof ContextMenuContent) {
                            parent.getOnKeyPressed().handle(ke);
                        }
                    } else if (ownerNode instanceof MenuBarButton) {
                        // the following code no longer appears necessary, but
                        // leaving in intact for now...
//                        // This is a top-level MenuBar Menu, so forward event to MenuBar
//                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
//                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
//                            mbs.getKeyEventHandler().handle(ke);
//                        }
                    }
                }
            }
        });

        addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            /*
             * we'll only scroll if the arrows are visible in the direction
             * that we're going, otherwise we go into empty space.
             */
            final double textDeltaY = event.getTextDeltaY();
            final double deltaY = event.getDeltaY();
            if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
                (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {

                switch(event.getTextDeltaYUnits()) {
                  case LINES:
                      /*
                      ** scroll lines, use the row height of selected row,
                      ** or row 0 if none selected
                      */
                      int focusedIndex = findFocusedIndex();
                      if (focusedIndex == -1) {
                          focusedIndex = 0;
                      }
                      double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
                      scroll(textDeltaY * rowHeight);
                      break;
                  case PAGES:
                      /*
                      ** page scroll, scroll the menu height
                      */
                      scroll(textDeltaY * itemsContainer.getHeight());
                      break;
                  case NONE:
                      /*
                      ** pixel scroll
                      */
                      scroll(deltaY);
                      break;
                }
                event.consume();
            }
        });
    }

    private Optional&lt;Node&gt; getFocusedNode() {
        final List&lt;Node&gt; children = itemsContainer.getChildren();
        final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
        return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
    }

    private void processLeftKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;

                    // if the submenu for this menu is showing, hide it
                    if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        hideSubmenu();
                        ke.consume();
                    }
                }
            }
        });
    }

    private void processRightKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);

                    // RT-15103
                    // if submenu for this menu is already showing then do nothing
                    // Menubar will process the right key and move to the next menu
                    if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        return;
                    }

                    showMenu(menu);
                    ke.consume();
                }
            }
        });
    }

    private void showMenu(Menu menu) {
        menu.show();
        // request focus on the first item of the submenu after it is shown
        ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
        if (cmContent != null) {
           if (cmContent.itemsContainer.getChildren().size() &gt; 0) {
               cmContent.itemsContainer.getChildren().get(0).requestFocus();
               cmContent.currentFocusedIndex = 0;
           } else {
               cmContent.requestFocus();
           }
        }
    }

    private void selectMenuItem() {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);
                    menu.show();
                } else {
                    ((MenuItemContainer)n).doSelect();
                }
            }
        });
    }

    private void move(Direction dir) {
        int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
        requestFocusOnIndex(findSibling(dir, startIndex));
    }

    private int findSibling(final Direction dir, final int startIndex) {
        final int childCount = itemsContainer.getChildren().size();
        int i = startIndex;
        do {
            if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
                // loop to zero
                i = 0;
            } else if (!dir.isForward() &amp;&amp; i == 0) {
                // loop to end
                i = childCount - 1;
            } else {
                i += (dir.isForward() ? 1 : -1);
            }

            Node n = itemsContainer.getChildren().get(i);
            if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
                return i;
            }
        } while (i != startIndex);
        return -1;
    }

    public void requestFocusOnIndex(int index) {
        currentFocusedIndex = index;
        Node n = itemsContainer.getChildren().get(index);
        selectedBackground = ((MenuItemContainer)n);
        n.requestFocus();
        ensureFocusedMenuItemIsVisible(n);
    }

    /*
     * Get the Y offset from the top of the popup to the menu item whose index
     * is given.
     */
    public double getMenuYOffset(int menuIndex) {
        double offset = 0;
        if (itemsContainer.getChildren().size() &gt; menuIndex) {
            offset = snappedTopInset();
            Node menuitem = itemsContainer.getChildren().get(menuIndex);
            offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
        }
        return offset;
    }

    private void setUpBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), true);
        contextMenu.getItems().addListener(contextMenuItemsListener);
    }

    private void disposeBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), false);
        contextMenu.getItems().removeListener(contextMenuItemsListener);
    }

    private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
        ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
        Menu menu = (Menu) isShowingProperty.getBean();

        if (wasShowing &amp;&amp; ! isShowing) {
            // hide the submenu popup
            hideSubmenu();
        } else if (! wasShowing &amp;&amp; isShowing) {
            // show the submenu popup
            showSubmenu(menu);
        }
    };

    private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
        // Add listeners to the showing property of all menus that have
        // been added, and remove listeners from menus that have been removed
        // FIXME this is temporary - we should be adding and removing
        // listeners such that they use the one listener defined above
        // - but that can't be done until we have the bean in the
        // ObservableValue
        while (c.next()) {
            updateMenuShowingListeners(c.getRemoved(), false);
            updateMenuShowingListeners(c.getAddedSubList(), true);
        }

        // Listener to items in PopupMenu to update items in PopupMenuContent
        itemsDirty = true;
        updateItems(); // RT-29761
    };

    private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
        // re layout as item's visibility changed
        requestLayout();
    };

    private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
        for (MenuItem item : items) {
            if (item instanceof Menu) {
                final Menu menu = (Menu) item;

                if (addListeners) {
                    menu.showingProperty().addListener(menuShowingListener);
                } else {
                    menu.showingProperty().removeListener(menuShowingListener);
                }
            }

             // listen to menu items's visible property.
            if (addListeners) {
                item.visibleProperty().addListener(menuItemVisibleListener);
            } else {
                item.visibleProperty().removeListener(menuItemVisibleListener);
            }
        }
    }

    // For test purpose only
    ContextMenu getSubMenu() {
        return submenu;
    }

    Menu getOpenSubMenu() {
        return openSubmenu;
    }

    private void createSubmenu() {
        if (submenu == null) {
            submenu = new ContextMenu();
            submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
                @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
                                              Boolean oldValue, Boolean newValue) {
                    if (!submenu.isShowing()) {
                        // Maybe user clicked outside or typed ESCAPE.
                        // Make sure menus are in sync.
                        for (Node node : itemsContainer.getChildren()) {
                            if (node instanceof MenuItemContainer
                                  &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
                                Menu menu = (Menu)((MenuItemContainer)node).item;
                                if (menu.isShowing()) {
                                    menu.hide();
                                }
                            }
                        }
                    }
                }
            });
        }
    }

    private void showSubmenu(Menu menu) {
        openSubmenu = menu;
        createSubmenu();
        submenu.getItems().setAll(menu.getItems());
        submenu.show(selectedBackground, Side.RIGHT, 0, 0);
    }

    private void hideSubmenu() {
        if (submenu == null) return;

        submenu.hide();
        openSubmenu = null;

        // Fix for RT-37022 - we dispose content so that we do not process CSS
        // on hidden submenus
        disposeContextMenu(submenu);
        submenu = null;

        // Fix for JDK-8158679 - we put the focus on the menu, and then back
        // on the menu item, so that screen readers can properly speak out
        // the menu item.
        getFocusedNode().ifPresent(n -&gt; {
            requestFocus();
            n.requestFocus();
        });
    }

    private void hideAllMenus(MenuItem item) {
        if (contextMenu != null) contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    private Menu openSubmenu;
    private ContextMenu submenu;

    // FIXME: HACKY. We use this so that a submenu knows where to open from
    // but this will only work for mouse hovers currently - and won't work
    // programmatically.
    // package protected for testing only!
    Region selectedBackground;

    void scroll(double delta) {
        double newTy = ty + delta;
        if (ty == newTy) return;

        // translation should never be positive (this would mean the top of the
        // menu content is detaching from the top of the menu!)
        if (newTy &gt; 0.0) {
            newTy = 0.0;
        }

        // translation should never be greater than the preferred height of the
        // menu content (otherwise the menu content will be detaching from the
        // bottom of the menu).
        // RT-37185: We check the direction of the scroll, to prevent it locking
        // up when scrolling upwards from the very bottom (using the on-screen
        // up arrow).
        if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
            newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
        }

        ty = newTy;
        itemsContainer.requestLayout();
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/
    @Override public Styleable getStyleableParent() {
        return contextMenu;
    }

    private static class StyleableProperties {

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());

            //
            // SkinBase only has Region's unique StlyleableProperty's, none of Nodes
            // So, we need to add effect back in. The effect property is in a
            // private inner class, so get the property from Node the hard way.
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
            for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
                CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
                if (&quot;effect&quot;.equals(styleable.getProperty())) {
                    styleables.add(styleable);
                    break;
                }
            }
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    public Label getLabelAt(int index) {
        return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
    }

    /**
     * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
     * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
     * timeline when mouse is over up/down arrow.
     */
    class MenuBox extends VBox {
        MenuBox() {
            setAccessibleRole(AccessibleRole.CONTEXT_MENU);
        }

        @Override protected void layoutChildren() {
            double yOffset = ty;
            for (Node n : getChildren()) {
                if (n.isVisible()) {
                    final double prefHeight = snapSizeY(n.prefHeight(-1));
                    n.resize(snapSizeX(getWidth()), prefHeight);
                    n.relocate(snappedLeftInset(), yOffset);
                    yOffset += prefHeight;
                }
            }
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case VISIBLE: return contextMenu.isShowing();
                case PARENT_MENU: return contextMenu.getOwnerNode();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }
    }

    class ArrowMenuItem extends StackPane {
         private StackPane upDownArrow;
         private ContextMenuContent popupMenuContent;
         private boolean up = false;
         public final boolean isUp() { return up; }
         public void setUp(boolean value) {
            up = value;
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
        }

        // used to automatically scroll through menu items when the user performs
        // certain interactions, e.g. pressing and holding the arrow buttons
        private Timeline scrollTimeline;

        public ArrowMenuItem(ContextMenuContent pmc) {
            getStyleClass().setAll(&quot;scroll-arrow&quot;);
            upDownArrow = new StackPane();
            this.popupMenuContent = pmc;
            upDownArrow.setMouseTransparent(true);
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
    //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
            addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
                if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
                    return;
                }
                startTimeline();
            });
            addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
                stopTimeline();
            });
            setVisible(false);
            setManaged(false);
            getChildren().add(upDownArrow);
        }

        @Override protected double computePrefWidth(double height) {
//            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
            return itemsContainer.getWidth();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double w = snapSizeX(upDownArrow.prefWidth(-1));
            double h = snapSizeY(upDownArrow.prefHeight(-1));

            upDownArrow.resize(w, h);
            positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }

        private void adjust() {
            if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
        }

        private void startTimeline() {
            scrollTimeline = new Timeline();
            scrollTimeline.setCycleCount(Timeline.INDEFINITE);
            KeyFrame kf = new KeyFrame(
                Duration.millis(60),
                    event -&gt; {
                        adjust();
                    }
            );
            scrollTimeline.getKeyFrames().clear();
            scrollTimeline.getKeyFrames().add(kf);
            scrollTimeline.play();
        }

        private void stopTimeline() {
            scrollTimeline.stop();
            scrollTimeline = null;
        }
    }

    /*
     * Container responsible for laying out a single row in the menu - in other
     * words, this contains and lays out a single MenuItem, regardless of it's
     * specific subtype.
     */
    public class MenuItemContainer extends Region {

        private final MenuItem item;

        private Node left;
        private Node graphic;
        private Node label;
        private Node right;

        private final LambdaMultiplePropertyChangeListenerHandler listener =
            new LambdaMultiplePropertyChangeListenerHandler();

        private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
        private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;

        private EventHandler&lt;ActionEvent&gt; actionEventHandler;

        protected Label getLabel(){
            return (Label) label;
        }

        public MenuItem getItem() {
            return item;
        }

        public MenuItemContainer(MenuItem item){
            if (item == null) {
                throw new NullPointerException(&quot;MenuItem can not be null&quot;);
            }

            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            setFocusTraversable(!(item instanceof CustomMenuItem));
            this.item = item;

            createChildren();

            // listen to changes in the state of certain MenuItem types
            ReadOnlyBooleanProperty pseudoProperty;
            if (item instanceof Menu) {
                pseudoProperty = ((Menu)item).showingProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.MENU);
            } else if (item instanceof RadioMenuItem) {
                pseudoProperty = ((RadioMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
            } else if (item instanceof CheckMenuItem) {
                pseudoProperty = ((CheckMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
            } else {
                setAccessibleRole(AccessibleRole.MENU_ITEM);
            }

            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
            listener.registerChangeListener(item.disableProperty(),
                    e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));

            // Add the menu item to properties map of this node. Used by QA for testing
            // This allows associating this container with corresponding MenuItem.
            getProperties().put(MenuItem.class, item);

            listener.registerChangeListener(item.graphicProperty(), e -&gt; {
                createChildren();
                computeVisualMetrics();
            });

            actionEventHandler = e -&gt; {
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }

                    selectedBackground = MenuItemContainer.this;
                    showMenu(menu);
                } else {
                    doSelect();
                }
            };
            addEventHandler(ActionEvent.ACTION, actionEventHandler);
        }

        public void dispose() {
            if (item instanceof CustomMenuItem) {
                Node node = ((CustomMenuItem)item).getContent();
                if (node != null) {
                    node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
                }
            }

            listener.dispose();
            removeEventHandler(ActionEvent.ACTION, actionEventHandler);

            if (label != null) {
                ((Label)label).textProperty().unbind();
                label.styleProperty().unbind();
                label.idProperty().unbind();

                ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
                if (itemStyleClassListener != null) {
                    item.getStyleClass().removeListener(itemStyleClassListener);
                }
            }

            left = null;
            graphic = null;
            label = null;
            right = null;
        }

        private void createChildren() {
            getChildren().clear();

            // draw background region for hover effects. All content (other
            // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
            // this background also acts as the receiver of user input
            if (item instanceof CustomMenuItem) {
                createNodeMenuItemChildren((CustomMenuItem)item);

                if (mouseEnteredEventHandler == null) {
                    mouseEnteredEventHandler = event -&gt; {
                        requestFocus(); // request Focus on hover
                    };
                } else {
                    removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                }
                addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
            } else {
                // --- add check / radio to left column
                Node leftNode = getLeftGraphic(item);
                if (leftNode != null) {
                    StackPane leftPane = new StackPane();
                    leftPane.getStyleClass().add(&quot;left-container&quot;);
                    leftPane.getChildren().add(leftNode);
                    left = leftPane;
                    getChildren().add(left);
                    left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
                }
                // -- add graphic to graphic pane
                if (item.getGraphic() != null) {
                    Node graphicNode = item.getGraphic();
                    StackPane graphicPane = new StackPane();
                    graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
                    graphicPane.getChildren().add(graphicNode);
                    graphic = graphicPane;
                    getChildren().add(graphic);
                }

                // --- add text to center column
                label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()

                // set up bindings from the MenuItem into the Label
                ((Label)label).textProperty().bind(item.textProperty());
                label.styleProperty().bind(item.styleProperty());
                label.idProperty().bind(item.styleProperty());

                // we want to ensure that any styleclasses set on the menuitem are applied to the
                // label (so we can style appropriately), but we can't just do a binding such as this:
                // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
                // Because that means we overwrite the 'label' style class on the Label.
                // What we really want is to ensure all style classes in the MenuItem are _copied_
                // into the label, which is what we do below
                ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
                    while (c.next()) {
                        label.getStyleClass().removeAll(c.getRemoved());
                        label.getStyleClass().addAll(c.getAddedSubList());
                    }
                };
                item.getStyleClass().addListener(itemStyleClassListener);
                item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);


                label.setMouseTransparent(true);
                getChildren().add(label);

                listener.unregisterChangeListeners(focusedProperty());
                // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
                // e.g this happens when you press the Right key to open a submenu; the first
                // menuitem is focused.
                listener.registerChangeListener(focusedProperty(), e -&gt; {
                    if (isFocused()) {
                        currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
                    }
                });

                // --- draw in right column - this depends on whether we are
                // a Menu or not. A Menu gets an arrow, whereas other MenuItems
                // get the ability to draw an accelerator
                if (item instanceof Menu) {
                    // --- add arrow / accelerator / mnemonic to right column
                    Region rightNode = new Region();
                    rightNode.setMouseTransparent(true);
                    rightNode.getStyleClass().add(&quot;arrow&quot;);

                    StackPane rightPane = new StackPane();
                    rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
                    rightPane.setMouseTransparent(true);
                    rightPane.getStyleClass().add(&quot;right-container&quot;);
                    rightPane.getChildren().add(rightNode);
                    right = rightPane;
                    getChildren().add(rightPane);

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null &amp;&amp; item != openSubmenu) {
                                // if a submenu of a different menu is already
                                // open then close it (RT-15049)
                                hideSubmenu();
                            }

                            selectedBackground = MenuItemContainer.this;
                            requestFocus();  // request Focus on hover
                            final Menu menu = (Menu) item;
                            if (menu.isDisable()) return;
                            menu.show();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            item.fire();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    // show submenu when the menu is hovered over
                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                } else { // normal MenuItem
                    // remove old listeners
                    listener.unregisterChangeListeners(item.acceleratorProperty());

                    // accelerator support
                    updateAccelerator();

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null) {
                                openSubmenu.hide();
                            }
                            requestFocus();  // request Focus on hover
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            doSelect();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);

                    listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
                }
            }
        }

        private void updateAccelerator() {
            if (item.getAccelerator() != null) {
                if (right != null) {
                    getChildren().remove(right);
                }

                String text = item.getAccelerator().getDisplayText();
                right = new Label(text);
                right.setStyle(item.getStyle());
                right.getStyleClass().add(&quot;accelerator-text&quot;);
                getChildren().add(right);
            } else {
                getChildren().remove(right);
            }
        }

        void doSelect() {
            // don't do anything on disabled menu items
            if (item.isDisable()) return;
            // toggle state of check or radio items
            if (item instanceof CheckMenuItem) {
                CheckMenuItem checkItem = (CheckMenuItem)item;
                checkItem.setSelected(!checkItem.isSelected());
            } else if (item instanceof RadioMenuItem) {
                // this is a radio button. If there is a toggleGroup specified, we
                // simply set selected to true. If no toggleGroup is specified, we
                // toggle the selected state, as there is no assumption of mutual
                // exclusivity when no toggleGroup is set.
                final RadioMenuItem radioItem = (RadioMenuItem) item;
                radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
            }

            // fire the action before hiding the menu
            item.fire();

            if (item instanceof CustomMenuItem) {
                CustomMenuItem customMenuItem = (CustomMenuItem) item;
                if (customMenuItem.isHideOnClick()) {
                    hideAllMenus(item);
                }
            } else {
                hideAllMenus(item);
            }
        }

        private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;

        private void createNodeMenuItemChildren(final CustomMenuItem item) {
            Node node = item.getContent();
            getChildren().add(node);

            // handle hideOnClick
            customMenuItemMouseClickedHandler = event -&gt; {
                if (item == null || item.isDisable()) return;

                item.fire();
                if (item.isHideOnClick()) {
                    hideAllMenus(item);
                }
            };
            node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
        }

        @Override protected void layoutChildren() {
            double xOffset;

            final double prefHeight = prefHeight(-1);
            if (left != null) {
                xOffset = snappedLeftInset();
                left.resize(left.prefWidth(-1), left.prefHeight(-1));
                positionInArea(left, xOffset, 0,
                        maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }
            if (graphic != null) {
                xOffset = snappedLeftInset() + maxLeftWidth;
                graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
                positionInArea(graphic, xOffset, 0,
                        maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (label != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
                label.resize(label.prefWidth(-1), label.prefHeight(-1));
                positionInArea(label, xOffset, 0,
                        maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (right != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
                right.resize(right.prefWidth(-1), right.prefHeight(-1));
                positionInArea(right, xOffset, 0,
                    maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
            }

            if ( item instanceof CustomMenuItem) {
                Node n = ((CustomMenuItem) item).getContent();
                if (item instanceof SeparatorMenuItem) {
                    double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
                    n.resize(width, n.prefHeight(-1));
                    positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                } else {
                    n.resize(n.prefWidth(-1), n.prefHeight(-1));
                    //the node should be left aligned
                    positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                }
            }
        }

        @Override protected double computePrefHeight(double width) {
            double prefHeight = 0;
            if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
                prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
            } else {
                prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
            }
             return snappedTopInset() + prefHeight + snappedBottomInset();
        }

        @Override protected double computePrefWidth(double height) {
            double nodeMenuItemWidth = 0;
            if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
                nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
                        snappedRightInset();
            }
            return Math.max(nodeMenuItemWidth,
                    snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
                    maxLabelWidth + maxRightWidth + snappedRightInset());
        }

        // Responsible for returning a graphic (if necessary) to position in the
        // left column of the menu. This may be a Node from the MenuItem.graphic
        // property, or it may be a check/radio item if necessary.
        private Node getLeftGraphic(MenuItem item) {
            if (item instanceof RadioMenuItem) {
                 final Region _graphic = new Region();
                _graphic.getStyleClass().add(&quot;radio&quot;);
                return _graphic;
            } else if (item instanceof CheckMenuItem) {
                final StackPane _graphic = new StackPane();
                _graphic.getStyleClass().add(&quot;check&quot;);
                return _graphic;
            }

            return null;
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case SELECTED:
                    if (item instanceof CheckMenuItem) {
                        return ((CheckMenuItem)item).isSelected();
                    }
                    if (item instanceof RadioMenuItem) {
                        return ((RadioMenuItem) item).isSelected();
                    }
                    return false;
                case ACCELERATOR: return item.getAccelerator();
                case TEXT: {
                    String title = &quot;&quot;;
                    if (graphic != null) {
                        String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    final Label label = getLabel();
                    if (label != null) {
                        String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    if (item instanceof CustomMenuItem) {
                        Node content = ((CustomMenuItem) item).getContent();
                        if (content != null) {
                            String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                            if (t != null) title += t;
                        }
                    }
                    return title;
                }
                case MNEMONIC: {
                    final Label label = getLabel();
                    if (label != null) {
                        String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
                        if (mnemonic != null) return mnemonic;
                    }
                    return null;
                }
                case DISABLED: return item.isDisable();
                case SUBMENU:
                    createSubmenu();
                    // Accessibility might need to see the menu node before the window
                    // is visible (i.e. before the skin is applied).
                    if (submenu.getSkin() == null) {
                        submenu.getStyleableNode().applyCss();
                    }
                    ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
                    return cmContent.itemsContainer;
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case SHOW_MENU:{
                    if (item instanceof Menu) {
                        final Menu menuItem = (Menu) item;
                        if (menuItem.isShowing()) {
                            menuItem.hide();
                        } else {
                            menuItem.show();
                        }
                    }
                    break;
                }
                case FIRE:
                    doSelect();
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }


    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;checked&quot;);

    private class MenuLabel extends Label {

        public MenuLabel(MenuItem item, MenuItemContainer mic) {
            super(item.getText());
            setMnemonicParsing(item.isMnemonicParsing());
            setLabelFor(mic);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerHijrahContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.LocalDate;
import java.time.DateTimeException;
import java.time.YearMonth;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.HijrahChronology;
import java.time.chrono.HijrahDate;
import java.time.chrono.IsoChronology;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;

import javafx.geometry.Pos;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.scene.text.Text;

/**
 * Extends DatePickerContent to add a secondary calendar, allowing the
 * ISO and Islamic calendars to be displayed simultaneously.  The
 * secondary month, day, and year values are displayed as a colored
 * overlay, offset from the primary values.
 *
 * If the current DatePicker Chronology is HijrahChronology, then sets
 * the content's primary Chronology to be IsoChronology, and sets
 * HijrahChronology as the secondary.
 */
public class DatePickerHijrahContent extends DatePickerContent {
    private Label hijrahMonthYearLabel;

    public DatePickerHijrahContent(final DatePicker datePicker) {
        super(datePicker);
    }

    /**
     * The primary chronology for display. This is overridden because
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    @Override protected Chronology getPrimaryChronology() {
        return IsoChronology.INSTANCE;
    }

    @Override protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = super.createMonthYearPane();

        hijrahMonthYearLabel = new Label();
        hijrahMonthYearLabel.getStyleClass().add(&quot;secondary-label&quot;);
        monthYearPane.setBottom(hijrahMonthYearLabel);
        BorderPane.setAlignment(hijrahMonthYearLabel, Pos.CENTER);

        return monthYearPane;
    }


    @Override protected void updateMonthYearPane() {
        super.updateMonthYearPane();

        Locale locale = getLocale();
        HijrahChronology chrono = HijrahChronology.INSTANCE;
        long firstMonth = -1;
        long firstYear = -1;
        String firstMonthStr = null;
        String firstYearStr = null;
        String hijrahStr = null;
        YearMonth displayedYearMonth = displayedYearMonthProperty().get();

        for (DateCell dayCell : dayCells) {
            LocalDate date = dayCellDate(dayCell);

            // Display Hijra month names only for current ISO month.
            if (!displayedYearMonth.equals(YearMonth.from(date))) {
                continue;
            }

            try {
                HijrahDate cDate = chrono.date(date);
                long month = cDate.getLong(MONTH_OF_YEAR);
                long year = cDate.getLong(YEAR);

                if (hijrahStr == null || month != firstMonth) {
                    String monthStr = monthFormatter.withLocale(locale)
                                                    .withChronology(chrono)
                                                    .withDecimalStyle(DecimalStyle.of(locale))
                                                    .format(cDate);
                    String yearStr = yearFormatter.withLocale(locale)
                                                    .withChronology(chrono)
                                                    .withDecimalStyle(DecimalStyle.of(locale))
                                                    .format(cDate);
                    if (hijrahStr == null) {
                        firstMonth = month;
                        firstYear = year;
                        firstMonthStr = monthStr;
                        firstYearStr = yearStr;
                        hijrahStr = firstMonthStr + &quot; &quot; + firstYearStr;
                    } else {
                        if (year &gt; firstYear) {
                            hijrahStr = firstMonthStr + &quot; &quot; + firstYearStr + &quot; - &quot; + monthStr + &quot; &quot; + yearStr;
                        } else {
                            hijrahStr = firstMonthStr + &quot; - &quot; + monthStr + &quot; &quot; + firstYearStr;
                        }
                        break;
                    }
                }
            } catch (DateTimeException ex) {
                // Date is out of range, ignore.

                //System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
            }
        }

        hijrahMonthYearLabel.setText(hijrahStr);
    }

    @Override protected void createDayCells() {
        super.createDayCells();

        for (DateCell dayCell : dayCells) {
            Text secondaryText = new Text();
            dayCell.getProperties().put(&quot;DateCell.secondaryText&quot;, secondaryText);
        }
    }

    @Override public void updateDayCells() {
        super.updateDayCells();

        Locale locale = getLocale();
        HijrahChronology chrono = HijrahChronology.INSTANCE;

        int majorityMonth = -1;
        int visibleDaysInMajorityMonth = -1;
        int curMonth = -1;
        int visibleDaysInCurMonth = 0;

        for (DateCell dayCell : dayCells) {
            Text secondaryText = (Text)dayCell.getProperties().get(&quot;DateCell.secondaryText&quot;);
            dayCell.getStyleClass().add(&quot;hijrah-day-cell&quot;);
            secondaryText.getStyleClass().setAll(&quot;text&quot;, &quot;secondary-text&quot;);

            try {
                HijrahDate cDate = chrono.date(dayCellDate(dayCell));
<A NAME="14"></A>//             long month = cDate.getLong(MONTH_OF_YEAR);

                String hijrahStr =
                    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#14',2,'match34-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);

                secondaryText.setText(hijrahStr);
                dayCell.requestLayout();
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                secondaryText.setText</B></FONT>(&quot; &quot;);
                dayCell.setDisable(true);
            }

//             if (month == curMonth) {
//                 visibleDaysInCurMonth++;
//             } else {
//                 curMonth = month;
//                 visibleDaysInCurMonth = 1;
//             }
//             if (visibleDaysInCurMonth &gt; visibleDaysInMajorityMonth) {
//                 majorityMonth = month;
//                 visibleDaysInMajorityMonth = visibleDaysInCurMonth;
//             }
        }

//         boolean seenMajorityMonth = false;
//         for (DateCell dayCell : dayCells) {
//             HijrahDate cDate = chrono.date(dayCellDate(dayCell));
//             int month = cDate.get(MONTH_OF_YEAR);
//             Text secondaryText = (Text)dayCell.getProperties().get(&quot;DateCell.secondaryText&quot;);

//             if (month == majorityMonth) {
//                 seenMajorityMonth = true;
//                 secondaryText.getStyleClass().add(&quot;current-month&quot;);
//             } else {
//                 secondaryText.getStyleClass().add(seenMajorityMonth ? &quot;next-month&quot; : &quot;previous-month&quot;);
//             }
//         }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/TabObservableList.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control;

import com.sun.javafx.collections.NonIterableChange;
import com.sun.javafx.collections.ObservableListWrapper;
import javafx.scene.control.Tab;
import java.util.List;
import java.util.ListIterator;

/*
 * TabObservableList class extends ObservableListWrapper and
 * adds a method for reordering the list.
 */

<A NAME="24"></A>public class TabObservableList&lt;E&gt; extends ObservableListWrapper&lt;E&gt; {
    private final List&lt;E&gt; tabList;

    public TabObservableList(List&lt;E&gt; list) <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#24',2,'match34-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        super(list);
        tabList = list;
    }

    public void reorder(Tab fromTab, Tab toTab) {</B></FONT>
        if (!tabList.contains(fromTab) || !tabList.contains(toTab) || fromTab == toTab) {
            return;
        }
        // Perform reorder with the array of tabs.
        Object[] a = tabList.toArray();
        int fromIndex = tabList.indexOf(fromTab);
        int toIndex = tabList.indexOf(toTab);
        if (fromIndex == -1 || toIndex == -1) {
            return;
        }
        int direction = (toIndex - fromIndex) / Math.abs(toIndex - fromIndex);

        for (int j = fromIndex; j != toIndex; j += direction) {
            a[j] = a[j + direction];
        }
        a[toIndex] = fromTab;

        // Update the list with reordered array.
        ListIterator iter = tabList.listIterator();
        for (int j = 0; j &lt; tabList.size(); j++) {
            iter.next();
            iter.set(a[j]);
        }

        // Update selected tab &amp; index.
        fromTab.getTabPane().getSelectionModel().select(fromTab);

        // Fire permutation change event.
        int permSize = Math.abs(toIndex - fromIndex) + 1;
        int[] perm = new int[permSize];
        int from = direction &gt; 0 ? fromIndex : toIndex;
        int to = direction &lt; 0 ? fromIndex : toIndex;
        for (int i = 0; i &lt; permSize; ++i) {
            perm[i] = i + from;
        }
        fireChange(new NonIterableChange.SimplePermutationChange&lt;E&gt;(from, to + 1, perm, this));
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ButtonBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.beans.Observable;
import javafx.scene.control.ButtonBase;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;

import static com.sun.javafx.scene.control.inputmap.InputMap.*;
import static javafx.scene.input.KeyCode.ENTER;
import static javafx.scene.input.KeyCode.SPACE;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public class ButtonBehavior&lt;C extends ButtonBase&gt; extends BehaviorBase&lt;C&gt; {
    private final InputMap&lt;C&gt; buttonInputMap;

    /**
     * Indicates that a keyboard key has been pressed which represents the
     * event (this could be space bar for example). As long as keyDown is true,
     * we are also armed, and will ignore mouse events related to arming.
     * Note this is made package private solely for the sake of testing.
     */
    private boolean keyDown;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public ButtonBehavior(C control) {
        super(control);

        // create a map for button-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        buttonInputMap = createInputMap();

        // add focus traversal mappings
        addDefaultMapping(buttonInputMap, FocusTraversalInputMap.getFocusTraversalMappings());

        // then button-specific mappings for key and mouse input
        addDefaultMapping(buttonInputMap,
            new KeyMapping(SPACE, KeyEvent.KEY_PRESSED, this::keyPressed),
            new KeyMapping(SPACE, KeyEvent.KEY_RELEASED, this::keyReleased),
            new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
            new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
            new MouseMapping(MouseEvent.MOUSE_ENTERED, this::mouseEntered),
            new MouseMapping(MouseEvent.MOUSE_EXITED, this::mouseExited),

            // on non-Mac OS platforms, we support pressing the ENTER key to activate the button
            new KeyMapping(new KeyBinding(ENTER, KeyEvent.KEY_PRESSED), this::keyPressed, event -&gt; PlatformUtil.isMac()),
            new KeyMapping(new KeyBinding(ENTER, KeyEvent.KEY_RELEASED), this::keyReleased, event -&gt; PlatformUtil.isMac())
        );

        // Button also cares about focus
        control.focusedProperty().addListener(this::focusChanged);
    }



    /***************************************************************************
     *                                                                         *
     * Implementation of BehaviorBase API                                      *
     *                                                                         *
     **************************************************************************/

    @Override public InputMap&lt;C&gt; getInputMap() {
        return buttonInputMap;
    }

    @Override public void dispose() {
        super.dispose();

        // TODO
        getNode().focusedProperty().removeListener(this::focusChanged);
    }



    /***************************************************************************
     *                                                                         *
     * Focus change handling                                                   *
     *                                                                         *
     **************************************************************************/

    private void focusChanged(Observable o) {
        // If we did have the key down, but are now not focused, then we must
        // disarm the button.
        final ButtonBase button = getNode();
        if (keyDown &amp;&amp; !button.isFocused()) {
            keyDown = false;
            button.disarm();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Key event handling                                                      *
     *                                                                         *
     **************************************************************************/

    /**
     * This function is invoked when an appropriate keystroke occurs which
     * causes this button to be armed if it is not already armed by a mouse
     * press.
     */
    protected void keyPressed(KeyEvent e) {
        if (! getNode().isPressed() &amp;&amp; ! getNode().isArmed()) {
            keyDown = true;
            getNode().arm();
        }
    }

    /**
     * Invoked when a valid keystroke release occurs which causes the button
     * to fire if it was armed by a keyPress.
     */
    protected void keyReleased(KeyEvent e) {
        if (keyDown) {
            keyDown = false;
            if (getNode().isArmed()) {
                getNode().disarm();
                getNode().fire();
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Mouse event handling                                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * Invoked when a mouse press has occurred over the button. In addition to
     * potentially arming the Button, this will transfer focus to the button
     */
    protected void mousePressed(MouseEvent e) {
        // if the button is not already focused, then request the focus
        if (! getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
            getNode().requestFocus();
        }

        // arm the button if it is a valid mouse event
        // Note there appears to be a bug where if I press and hold and release
        // then there is a clickCount of 0 on the release, whereas a quick click
        // has a release clickCount of 1. So here I'll check clickCount &lt;= 1,
        // though it should really be == 1 I think.
        boolean valid = (e.getButton() == MouseButton.PRIMARY &amp;&amp;
                ! (e.isMiddleButtonDown() || e.isSecondaryButtonDown() ||
                        e.isShiftDown() || e.isControlDown() || e.isAltDown() || e.isMetaDown()));

        if (! getNode().isArmed() &amp;&amp; valid) {
            getNode().arm();
        }
    }

    /**
     * Invoked when a mouse release has occurred. We determine whether this
<A NAME="21"></A>     * was done in a manner that would fire the button's action. This happens
     * only if the button was armed by a corresponding mouse press.
     */
    protected void mouseReleased(<FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#21',2,'match34-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MouseEvent e) {
        // if armed by a mouse press instead of key press, then fire!
        if (! keyDown &amp;&amp; getNode().isArmed()) {
            getNode().fire();
            getNode().disarm();
        }
    }</B></FONT>

    /**
     * Invoked when the mouse enters the Button. If the Button had been armed
     * by a mouse press and the mouse is still pressed, then this will cause
     * the button to be rearmed.
     */
    protected void mouseEntered(MouseEvent e) {
        // rearm if necessary
        if (! keyDown &amp;&amp; getNode().isPressed()) {
            getNode().arm();
        }
    }

    /**
     * Invoked when the mouse exits the Button. If the Button is armed due to
     * a mouse press, then this function will disarm the button upon the mouse
     * exiting it.
     */
    protected void mouseExited(MouseEvent e) {
        // Disarm if necessary
        if (! keyDown &amp;&amp; getNode().isArmed()) {
            getNode().disarm();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ToggleButtonBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.skin.Utils;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.Toggle;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.KeyEvent;

import static com.sun.javafx.scene.control.inputmap.InputMap.*;
import static javafx.scene.input.KeyCode.*;

public class ToggleButtonBehavior&lt;C extends ToggleButton&gt; extends ButtonBehavior&lt;C&gt;{

    public ToggleButtonBehavior(C button) {
        super(button);

        ObservableList&lt;Mapping&lt;?&gt;&gt; mappings = FXCollections.observableArrayList(
            new KeyMapping(RIGHT, e -&gt; traverse(e, &quot;ToggleNext-Right&quot;)),
            new KeyMapping(LEFT, e -&gt; traverse(e, &quot;TogglePrevious-Left&quot;)),
            new KeyMapping(DOWN, e -&gt; traverse(e, &quot;ToggleNext-Down&quot;)),
            new KeyMapping(UP, e -&gt; traverse(e, &quot;TogglePrevious-Up&quot;))
        );

        // we disable auto-consuming, so that unconsumed events work their way
        // back up the input map hierarchy and back out of the node.
        for (Mapping&lt;?&gt; mapping : mappings) {
            mapping.setAutoConsume(false);
<A NAME="13"></A>        }

        // put the mappings into a child input map so they take precedence
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#13',2,'match34-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>InputMap&lt;C&gt; overriddenFocusInput = new InputMap&lt;&gt;(button);
        overriddenFocusInput.getMappings().addAll(mappings);
        addDefaultChildMap(getInputMap(), overriddenFocusInput);
    }

    /**
     * Returns the next toggle index or &quot;from&quot; if none found
     */
    private int nextToggleIndex(final ObservableList&lt;Toggle&gt; toggles, final int from) {</B></FONT>
        Toggle toggle;
        if (from  &lt; 0 || from &gt;= toggles.size()) return 0;
        int i = (from + 1) % toggles.size();
        while (i != from &amp;&amp; (toggle = toggles.get(i)) instanceof Node &amp;&amp;
                ((Node)toggle).isDisabled()) {
            i = (i + 1) % toggles.size();
        }
        return i;
    }

    /**
     * Returns the previous toggle index or &quot;from&quot; if none found
     */
    private int previousToggleIndex(final ObservableList&lt;Toggle&gt; toggles, final int from) {
        Toggle toggle;
        if (from  &lt; 0 || from &gt;= toggles.size()) return toggles.size();
        int i = Math.floorMod(from - 1, toggles.size());
        while (i != from &amp;&amp; (toggle = toggles.get(i)) instanceof Node &amp;&amp;
                ((Node)toggle).isDisabled()) {
            i = Math.floorMod(i - 1, toggles.size());
        }
        return i;
    }

    private void traverse(KeyEvent e, String name) {
        ToggleButton toggleButton = getNode();
        final ToggleGroup toggleGroup = toggleButton.getToggleGroup();
        // A ToggleButton does not have to be in a group.
        if (toggleGroup == null) {
            e.consume();
            return;
        }
        ObservableList&lt;Toggle&gt; toggles = toggleGroup.getToggles();
        final int currentToggleIdx = toggles.indexOf(toggleButton);

        boolean traversingToNext = traversingToNext(name, toggleButton.getEffectiveNodeOrientation());
        if (Utils.isTwoLevelFocus()) {
            // Because we don't auto-consume (see mapping definitions above), we
            // can simply return here and have the traversal handled by another
            // appropriate mapping
        } else if (traversingToNext) {
            int nextToggleIndex = nextToggleIndex(toggles, currentToggleIdx);
            if (nextToggleIndex == currentToggleIdx) {
                // Because we don't auto-consume (see mapping definitions above), we
                // can simply return here and have the traversal handled by another
                // appropriate mapping
            } else {
                Toggle toggle = toggles.get(nextToggleIndex);
                toggleGroup.selectToggle(toggle);
                ((Control)toggle).requestFocus();
                e.consume();
            }
        } else {
            int prevToggleIndex = previousToggleIndex(toggles, currentToggleIdx);
            if (prevToggleIndex == currentToggleIdx) {
                // Because we don't auto-consume (see mapping definitions above), we
                // can simply return here and have the traversal handled by another
                // appropriate mapping
            } else {
                Toggle toggle = toggles.get(prevToggleIndex);
                toggleGroup.selectToggle(toggle);
                ((Control)toggle).requestFocus();
                e.consume();
            }
        }
    }

    private boolean traversingToNext(String name, NodeOrientation effectiveNodeOrientation) {
        boolean rtl = effectiveNodeOrientation == NodeOrientation.RIGHT_TO_LEFT;
        switch (name) {
            case &quot;ToggleNext-Right&quot;:
                return rtl ? false : true;
            case &quot;ToggleNext-Down&quot;:
                return true;
            case &quot;TogglePrevious-Left&quot;:
                return rtl ? true : false;
            case &quot;TogglePrevious-Up&quot;:
                return false;
            default:
                throw new IllegalArgumentException(&quot;Not a toggle action&quot;);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TwoLevelFocusBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.NodeHelper;
import javafx.css.PseudoClass;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.PopupControl;

import javafx.scene.Scene;
import javafx.scene.input.KeyEvent;

import javafx.beans.value.ChangeListener;
import javafx.event.Event;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.scene.input.MouseEvent;

/**
 * A two level focus handler allows a Control to behave as if it
 * has three focus states :
 *  - not focused
 *  - focused with internal focus
 *  - focused with external focus
 *
 * In external focus mode it intercepts focus and traversal events and
 * prevents the Controls acting upon them, or trapping focus.
 * In internal focus mode most events go to the Control, except
 * for events that are defined to exit the mode.
 */
public class TwoLevelFocusBehavior {

    Node tlNode = null;
    PopupControl tlPopup = null;
    EventDispatcher origEventDispatcher = null;

    public TwoLevelFocusBehavior() {
    }

    public TwoLevelFocusBehavior(Node node) {
        tlNode = node;
        tlPopup = null;

        tlNode.addEventHandler(KeyEvent.ANY, keyEventListener);
        tlNode.addEventHandler(MouseEvent.MOUSE_PRESSED, mouseEventListener);
        tlNode.focusedProperty().addListener(focusListener);

        // block ScrollEvent from being passed down to scrollbar's skin
        origEventDispatcher = tlNode.getEventDispatcher();
        tlNode.setEventDispatcher(tlfEventDispatcher);
    }

    /**
     * Invoked by the behavior when it is disposed, so that any listeners installed by
     * the TwoLevelFocusBehavior can also be uninstalled
     */
    public void dispose() {
        tlNode.removeEventHandler(KeyEvent.ANY, keyEventListener);
        tlNode.removeEventHandler(MouseEvent.MOUSE_PRESSED, mouseEventListener);
        tlNode.focusedProperty().removeListener(focusListener);
        tlNode.setEventDispatcher(origEventDispatcher);
    }

    /**
     * Don't allow the Node to handle a key event if it is in externalFocus mode.
     * the only keyboard actions allowed are the navigation keys......
     */
    final EventDispatcher preemptiveEventDispatcher = (event, tail) -&gt; {

        // block the event from being passed down to children
        if (event instanceof KeyEvent &amp;&amp; event.getEventType() == KeyEvent.KEY_PRESSED) {
            if (!((KeyEvent)event).isMetaDown() &amp;&amp; !((KeyEvent)event).isControlDown()  &amp;&amp; !((KeyEvent)event).isAltDown()) {
                if (isExternalFocus()) {
                    //
                    // don't let the behaviour leak any navigation keys when
                    // we're not in blocking mode....
                    //
                    Object obj = event.getTarget();

                    switch (((KeyEvent)event).getCode()) {
                      case TAB :
                          if (((KeyEvent)event).isShiftDown()) {
                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);
                          }
                          else {
                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);
                          }
                          event.consume();
                          break;
                      case UP :
                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);
                          event.consume();
                          break;
                      case DOWN :
                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);
                          event.consume();
                          break;
                      case LEFT :
                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);
                          event.consume();
                          break;
                      case RIGHT :
                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);
                          event.consume();
                          break;
                      case ENTER :
                          setExternalFocus(false);
                          event.consume();
                          break;
                      default :
                          // this'll kill mnemonics.... unless!
                          Scene s = tlNode.getScene();
                          Event.fireEvent(s, event);
                          event.consume();
                          break;
                    }
                }
            }
        }

        return event;
    };

    final EventDispatcher tlfEventDispatcher = (event, tail) -&gt; {

        if ((event instanceof KeyEvent)) {
            if (isExternalFocus()) {
                tail = tail.prepend(preemptiveEventDispatcher);
                return tail.dispatchEvent(event);
            }
        }
        return origEventDispatcher.dispatchEvent(event, tail);
    };

    private Event postDispatchTidyup(Event event) {
        // block the event from being passed down to children
        if (event instanceof KeyEvent &amp;&amp; event.getEventType() == KeyEvent.KEY_PRESSED) {
            if (!isExternalFocus()) {
                //
                // don't let the behaviour leak any navigation keys when
                // we're not in blocking mode....
                //
                if (!((KeyEvent)event).isMetaDown() &amp;&amp; !((KeyEvent)event).isControlDown()  &amp;&amp; !((KeyEvent)event).isAltDown()) {

                    switch (((KeyEvent)event).getCode()) {
                      case TAB :
                      case UP :
                      case DOWN :
                      case LEFT :
                      case RIGHT :
                          event.consume();
                          break;
                      case ENTER :
                          setExternalFocus(true);
                          event.consume();
                          break;
                      default :
                          break;
                    }
                }
            }
        }
        return event;
    }


    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        postDispatchTidyup(e);
    };


    /**
     *  When a node gets focus, put it in external-focus mode.
     */
    final ChangeListener&lt;Boolean&gt; focusListener = (observable, oldVal, newVal) -&gt; {
        if (newVal &amp;&amp; tlPopup != null) {
            setExternalFocus(false);
        }
        else {
            setExternalFocus(true);
        }
    };

    private final EventHandler&lt;MouseEvent&gt; mouseEventListener  = e -&gt; {
        setExternalFocus(false);
    };

    private boolean externalFocus = true;

    public boolean isExternalFocus() {
        return externalFocus;
    }

    private static final PseudoClass INTERNAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;internal-focus&quot;);
    private static final PseudoClass EXTERNAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;external-focus&quot;);

    public void setExternalFocus(boolean value) {
<A NAME="29"></A>        externalFocus = value;

        if (tlNode != null &amp;&amp; tlNode instanceof Control) {
            <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#29',2,'match34-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>tlNode.pseudoClassStateChanged(INTERNAL_PSEUDOCLASS_STATE, !value);
            tlNode.pseudoClassStateChanged(EXTERNAL_PSEUDOCLASS_STATE, value);
        }
        else if (tlPopup != null) {
            tlPopup.pseudoClassStateChanged(INTERNAL_PSEUDOCLASS_STATE, !value);
            tlPopup.pseudoClassStateChanged(EXTERNAL_PSEUDOCLASS_STATE, value);
        }
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/FXVKSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.SkinBase;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.TextField;
import javafx.scene.control.TextArea;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.Scene;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.input.InputEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.Region;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Window;
import javafx.util.Duration;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.HashMap;
import static javafx.scene.input.MouseEvent.MOUSE_PRESSED;
import static javafx.scene.input.TouchEvent.TOUCH_PRESSED;
import static javafx.scene.layout.Region.USE_PREF_SIZE;
import java.security.AccessController;
import java.security.PrivilegedAction;


public class FXVKSkin extends SkinBase&lt;FXVK&gt; {

    private static final int GAP = 6;

    private List&lt;List&lt;Key&gt;&gt; currentBoard;
    private static HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt; boardMap = new HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt;();
    private int numCols;

    private boolean capsDown = false;
    private boolean shiftDown = false;
    private boolean isSymbol = false;
    long lastTime = -1L;

    void clearShift() {
        if (shiftDown &amp;&amp; !capsDown) {
            shiftDown = false;
            updateKeys();
        }
        lastTime = -1L;
    }

    void pressShift() {
        long time = System.currentTimeMillis();

        //potential for a shift lock
        if (shiftDown &amp;&amp; !capsDown) {
            if (lastTime &gt; 0L &amp;&amp; time - lastTime &lt; 400L) {
                //set caps lock
                shiftDown = false;
                capsDown =  true;
            } else {
                //set normal
                shiftDown = false;
                capsDown =  false;
            }
        } else if (!shiftDown &amp;&amp; !capsDown) {
            // set shift
            shiftDown=true;
        } else {
            //set to normal
            shiftDown = false;
            capsDown =  false;
        }

        updateKeys();
        lastTime = time;
    }

    void clearSymbolABC() {
        isSymbol = false;
        updateKeys();
    }

    void pressSymbolABC() {
        isSymbol = !isSymbol;
        updateKeys();
    }

    void clearStateKeys() {
        capsDown = false;
        shiftDown = false;
        isSymbol = false;
        lastTime = -1L;
        updateKeys();
<A NAME="10"></A>    }

    private void updateKeys() {
        <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#10',2,'match34-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                key.update(capsDown, shiftDown, isSymbol);
            }
        }</B></FONT>
    }

    private static Popup vkPopup;
    private static Popup secondaryPopup;
    private static FXVK primaryVK;

    private static Timeline slideInTimeline = new Timeline();
    private static Timeline slideOutTimeline = new Timeline();
    private static boolean hideAfterSlideOut = false;

    private static FXVK secondaryVK;
    private static Timeline secondaryVKDelay;
    private static CharKey secondaryVKKey;
    private static TextInputKey repeatKey;

    private static Timeline repeatInitialDelay;
    private static Timeline repeatSubsequentDelay;

    // key repeat initial delay (ms)
    private static double KEY_REPEAT_DELAY = 400;
    private static double KEY_REPEAT_DELAY_MIN = 100;
    private static double KEY_REPEAT_DELAY_MAX = 1000;

    // key repeat rate (cps)
    private static double KEY_REPEAT_RATE = 25;
    private static double KEY_REPEAT_RATE_MIN = 2;
    private static double KEY_REPEAT_RATE_MAX = 50;

    private Node attachedNode;
    private String vkType = null;

    FXVK fxvk;

    static final double VK_HEIGHT = 243;
    static final double VK_SLIDE_MILLIS = 250;
    static final double PREF_PORTRAIT_KEY_WIDTH = 40;
    static final double PREF_KEY_HEIGHT = 56;

    static boolean vkAdjustWindow = false;
    static boolean vkLookup = false;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String s = System.getProperty(&quot;com.sun.javafx.vk.adjustwindow&quot;);
            if (s != null) {
                vkAdjustWindow = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.sqe.vk.lookup&quot;);
            if (s != null) {
                vkLookup = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatDelay&quot;);
            if (s != null) {
                Double delay = Double.valueOf(s);
                KEY_REPEAT_DELAY = Math.min(Math.max(delay, KEY_REPEAT_DELAY_MIN), KEY_REPEAT_DELAY_MAX);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatRate&quot;);
            if (s != null) {
                Double rate = Double.valueOf(s);
                if (rate &lt;= 0) {
                    //disable key repeat
                    KEY_REPEAT_RATE = 0;
                } else {
                    KEY_REPEAT_RATE = Math.min(Math.max(rate, KEY_REPEAT_RATE_MIN), KEY_REPEAT_RATE_MAX);
                }
            }
            return null;
        });
    }

    // Proxy for read-only Window.yProperty() so we can animate.
    private static DoubleProperty winY = new SimpleDoubleProperty();
    static {
        winY.addListener(valueModel -&gt; {
            if (vkPopup != null) {
                vkPopup.setY(winY.get());
            }
        });
    }

    private static void startSlideIn() {
        slideOutTimeline.stop();
        slideInTimeline.playFromStart();
    }

    private static void startSlideOut(boolean doHide) {
        hideAfterSlideOut = doHide;
        slideInTimeline.stop();
        slideOutTimeline.playFromStart();
    }

    private void adjustWindowPosition(final Node node) {
        if ( !(node instanceof TextInputControl) ) {
            return;
        }

        // attached node y position in window coordinates
        double inputControlMinY = node.localToScene(0.0, 0.0).getY() + node.getScene().getY();
        double inputControlHeight = ((TextInputControl) node).getHeight();
        double inputControlMaxY = inputControlMinY + inputControlHeight;

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(node).getBounds().getHeight();
        double visibleAreaMaxY = screenHeight - VK_HEIGHT;

        double inputLineCenterY = 0.0;
        double inputLineBottomY = 0.0;
        double newWindowYPos = 0.0;
        double screenTopOffset = 10.0;

        if (node instanceof TextField) {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            //check for combo box
            Parent parent = attachedNode.getParent();
            if (parent instanceof ComboBoxBase) {
                //combo box
                // position near screen top
                newWindowYPos = Math.min(screenTopOffset - inputControlMinY, 0);
            } else {
                // position at center of visible screen area
                newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin textAreaSkin = (TextAreaSkin)((TextArea)node).getSkin();
            Bounds caretBounds = textAreaSkin.getCaretBounds();
            double caretMinY = caretBounds.getMinY();
            double caretMaxY = caretBounds.getMaxY();
            inputLineCenterY = inputControlMinY + ( caretMinY + caretMaxY ) / 2;
            inputLineBottomY = inputControlMinY + caretMaxY;

            if (inputControlHeight &lt; visibleAreaMaxY) {
                // position at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - (inputControlMinY + inputControlHeight / 2);
            } else {
                // position the line containing the caret at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - inputLineCenterY;
            }
            newWindowYPos = Math.min(newWindowYPos, 0);

        } else {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            // position at center of visible screen area
            newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
        }

        Window w = node.getScene().getWindow();
        if (origWindowYPos + inputLineBottomY &gt; visibleAreaMaxY) {
            w.setY(newWindowYPos);
        } else {
            w.setY(origWindowYPos);
        }
    }

    private void saveWindowPosition(final Node node) {
        Window w = node.getScene().getWindow();
        origWindowYPos = w.getY();
    }

    private void restoreWindowPosition(final Node node) {
        if (node != null) {
            Scene scene = node.getScene();
            if (scene != null) {
                Window window = scene.getWindow();
                if (window != null) {
                    window.setY(origWindowYPos);
                }
            }
        }
    }

    EventHandler&lt;InputEvent&gt; unHideEventHandler;

    private boolean isVKHidden = false;
    private Double origWindowYPos = null;

    private void registerUnhideHandler(final Node node) {
        if (unHideEventHandler == null) {
            unHideEventHandler = event -&gt; {
                if (attachedNode != null &amp;&amp; isVKHidden) {
                    double screenHeight = com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds().getHeight();
                    if (fxvk.getHeight() &gt; 0 &amp;&amp; (vkPopup.getY() &gt; screenHeight - fxvk.getHeight())) {
                        if (slideInTimeline.getStatus() != Animation.Status.RUNNING) {
                            startSlideIn();
                            if (vkAdjustWindow) {
                                adjustWindowPosition(attachedNode);
                            }
                        }
                    }
                }
                isVKHidden = false;
            };
        }
        node.addEventHandler(TOUCH_PRESSED, unHideEventHandler);
        node.addEventHandler(MOUSE_PRESSED, unHideEventHandler);
    }

    private void unRegisterUnhideHandler(Node node) {
        if (unHideEventHandler != null) {
            node.removeEventHandler(TOUCH_PRESSED, unHideEventHandler);
            node.removeEventHandler(MOUSE_PRESSED, unHideEventHandler);
        }
    }

    private String getNodeVKType(Node node) {
        Integer vkType = (Integer)node.getProperties().get(FXVK.VK_TYPE_PROP_KEY);
        String typeStr = null;
        if (vkType != null) {
            Object typeValue = FXVK.VK_TYPE_NAMES[vkType];
            if (typeValue instanceof String) {
                typeStr = ((String)typeValue).toLowerCase(Locale.ROOT);
            }
        }
        return (typeStr != null ? typeStr : &quot;text&quot;);
    }

    private void updateKeyboardType(Node node) {
        String oldType = vkType;
        vkType = getNodeVKType(node);
        //VK type changed, rebuild
        if ( oldType == null || !vkType.equals(oldType) ) {
            rebuildPrimaryVK(vkType);
        }
    }

    private void closeSecondaryVK() {
        if (secondaryVK != null) {
            secondaryVK.setAttachedNode(null);
            secondaryPopup.hide();
        }
    }

    private void setupPrimaryVK() {
        fxvk.setFocusTraversable(false);
        fxvk.setVisible(true);

        // init popup window and slide animations
        if (vkPopup == null) {
            vkPopup = new Popup();
            vkPopup.setAutoFix(false);
        }
        vkPopup.getContent().setAll(fxvk);

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getHeight();
        double width = com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getWidth();

        //Setup VK slide animations
        slideInTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                         new KeyValue(winY, screenHeight - VK_HEIGHT,
                                      Interpolator.EASE_BOTH)));
        slideOutTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                    event -&gt; {
                        if (hideAfterSlideOut &amp;&amp; vkPopup.isShowing()) {
                            vkPopup.hide();
                        }
                    },
                new KeyValue(winY, screenHeight, Interpolator.EASE_BOTH)));

        //Set VK size
        fxvk.setPrefWidth(width);
        fxvk.setMinWidth(USE_PREF_SIZE);
        fxvk.setMaxWidth(USE_PREF_SIZE);

        fxvk.setPrefHeight(VK_HEIGHT);
        fxvk.setMinHeight(USE_PREF_SIZE);


        //set up long-press triger for secondary VK
        if (secondaryVKDelay == null) {
            secondaryVKDelay = new Timeline();
        }
        KeyFrame kf = new KeyFrame(Duration.millis(500), event -&gt; {
            if (secondaryVKKey != null) {
                showSecondaryVK(secondaryVKKey);
            }
        });
        secondaryVKDelay.getKeyFrames().setAll(kf);

        //Setup key repeat animations
        if (KEY_REPEAT_RATE &gt; 0) {
            repeatInitialDelay = new Timeline(new KeyFrame(
                    Duration.millis(KEY_REPEAT_DELAY),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                        //Start repeat animation
                        repeatSubsequentDelay.playFromStart();
                    }
            ));
            repeatSubsequentDelay = new Timeline(new KeyFrame(
                    Duration.millis(1000.0 / KEY_REPEAT_RATE),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                    }
            ));
            repeatSubsequentDelay.setCycleCount(Animation.INDEFINITE);
        }
    }

    void prerender(Node node) {
        if (fxvk != primaryVK) {
            return;
        }

        //Preload all boards
        loadBoard(&quot;text&quot;);
        loadBoard(&quot;numeric&quot;);
        loadBoard(&quot;url&quot;);
        loadBoard(&quot;email&quot;);

        updateKeyboardType(node);
        fxvk.setVisible(true);

        if (!vkPopup.isShowing()) {
            Rectangle2D screenBounds =
                com.sun.javafx.util.Utils.getScreen(node).getBounds();

            vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
            winY.set(screenBounds.getHeight());
            vkPopup.show(node.getScene().getWindow());
        }
    }

    public FXVKSkin(final FXVK fxvk) {
        super(fxvk);
        this.fxvk = fxvk;
        if (fxvk == FXVK.vk) {
            primaryVK = fxvk;
        }

        if (fxvk == primaryVK) {
            setupPrimaryVK();
        }

        fxvk.attachedNodeProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                Node oldNode = attachedNode;
                attachedNode = fxvk.getAttachedNode();
                if (fxvk != primaryVK) {
                    return;
                }

                closeSecondaryVK();

                if (attachedNode != null) {
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    registerUnhideHandler(attachedNode);
                    updateKeyboardType(attachedNode);

                    //owner window has changed so hide VK and show with new owner
                    if (oldNode == null || oldNode.getScene() == null || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                        if (vkPopup.isShowing()) {
                            vkPopup.hide();
                        } else {
                        }
                    }

                    if (!vkPopup.isShowing()) {
                        Rectangle2D screenBounds =
                            com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds();

                        vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
                        if (oldNode == null || isVKHidden) {
                            //position off screen
                            winY.set(screenBounds.getHeight());
                        } else {
                            //position on screen (no slide in)
                            winY.set(screenBounds.getHeight() - VK_HEIGHT);
                        }
                        vkPopup.show(attachedNode.getScene().getWindow());
                    }

                    if (oldNode == null || isVKHidden) {
                        startSlideIn();
                    }

                    if (vkAdjustWindow) {
                        //update previous window position only if moving from non-input control node or window has changed.
                        if (oldNode == null || oldNode.getScene() == null
                            || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                            saveWindowPosition(attachedNode);
                        }
                        // Move window containing input node
                        adjustWindowPosition(attachedNode);
                    }
                } else { // attachedNode == null
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    startSlideOut(true);
                    // Restore window position
                    if (vkAdjustWindow) {
                        restoreWindowPosition(oldNode);
                    }
                }
                isVKHidden = false;
            }
        });
    }

    /**
     * builds secondary (long-press) VK
     */
    private void rebuildSecondaryVK() {
        if (secondaryVK.chars == null) {
        } else {
            int nKeys = secondaryVK.chars.length;
            int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
            int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

            Key tmpKey;
            List&lt;List&lt;Key&gt;&gt; rows = new ArrayList&lt;List&lt;Key&gt;&gt;(2);

            for (int i = 0; i &lt; nRows; i++) {
                int start = i * nKeysPerRow;
                int end = Math.min(start + nKeysPerRow, nKeys);
                if (start &gt;= end)
                    break;

                List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(nKeysPerRow);
                for (int j = start; j &lt; end; j++) {
                    tmpKey = new CharKey(secondaryVK.chars[j], null, null);
                    tmpKey.col= (j - start) * 2;
                    tmpKey.colSpan = 2;
                    for (String sc : tmpKey.getStyleClass()) {
                        tmpKey.text.getStyleClass().add(sc + &quot;-text&quot;);
                        tmpKey.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                        tmpKey.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                    }
                    if (secondaryVK.chars[j] != null &amp;&amp; secondaryVK.chars[j].length() &gt; 1) {
                        tmpKey.text.getStyleClass().add(&quot;multi-char-text&quot;);
                    }
                    keys.add(tmpKey);
                }
                rows.add(keys);
            }
            currentBoard = rows;

            getChildren().clear();
            numCols = 0;
            for (List&lt;Key&gt; row : currentBoard) {
                for (Key key : row) {
                    numCols = Math.max(numCols, key.col + key.colSpan);
                }
                getChildren().addAll(row);
            }
        }
    }

    /**
     * builds primary VK based on the keyboard
     * type set on the VirtualKeyboard.
     */
    private void rebuildPrimaryVK(String type) {
        currentBoard = loadBoard(type);

        //Clear all state keys and updates current board
        clearStateKeys();

        getChildren().clear();
        numCols = 0;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                numCols = Math.max(numCols, key.col + key.colSpan);
            }
            getChildren().addAll(row);
        }
    }

    // This skin is designed such that it gives equal widths to all columns. So
    // the pref width is just some hard-coded value (although I could have maybe
    // done it based on the pref width of a text node with the right font).
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return leftInset + (56 * numCols) + rightInset;
    }

    // Pref height is just some value. This isn't overly important.
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + (80 * 5) + bottomInset;
    }

    // Lays the buttons comprising the current keyboard out.
    @Override
    protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        // I have fixed width columns, all the same.
        int numRows = currentBoard.size();
        final double colWidth = ((contentWidth - ((numCols - 1) * GAP)) / numCols);
        double rowHeight = ((contentHeight - ((numRows - 1) * GAP)) / numRows);
        double rowY = contentY;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                double startX = contentX + (key.col * (colWidth + GAP));
                double width = (key.colSpan * (colWidth + GAP)) - GAP;
                key.resizeRelocate((int)(startX + .5), (int)(rowY + .5),
                                   width, rowHeight);
            }
            rowY += rowHeight + GAP;
        }
    }


    /**
     * A Key on the virtual keyboard. This is simply a Region. Some information
     * about the key relative to other keys on the layout is given by the col
     * and colSpan fields.
     */
    private class Key extends Region {
        int col = 0;
        int colSpan = 1;
        protected final Text text;
        protected final Text altText;
        protected final Region icon;

        protected Key() {
            icon = new Region();
            text = new Text();
            text.setTextOrigin(VPos.TOP);
            altText = new Text();
            altText.setTextOrigin(VPos.TOP);
            getChildren().setAll(text, altText, icon);
            getStyleClass().setAll(&quot;key&quot;);
            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    press();
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    release();
            });
        }
        protected void press() { }
        protected void release() {
            clearShift();
        }

        public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) { }

        @Override protected void layoutChildren() {
            final double left = snappedLeftInset();
            final double top = snappedTopInset();
            final double width = getWidth() - left - snappedRightInset();
            final double height = getHeight() - top - snappedBottomInset();

            text.setVisible(icon.getBackground() == null);
            double contentPrefWidth = text.prefWidth(-1);
            double contentPrefHeight = text.prefHeight(-1);
            text.resizeRelocate(
                    (int) (left + ((width - contentPrefWidth) / 2) + .5),
                    (int) (top + ((height - contentPrefHeight) / 2) + .5),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            altText.setVisible(icon.getBackground() == null &amp;&amp; altText.getText().length() &gt; 0);
            contentPrefWidth = altText.prefWidth(-1);
            contentPrefHeight = altText.prefHeight(-1);
            altText.resizeRelocate(
                    (int) left + (width - contentPrefWidth) + .5,
                    (int) (top + ((height - contentPrefHeight) / 2) + .5 - height/2),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            icon.resizeRelocate(left-8, top-8, width+16, height+16);
        }

    }

    /**
     * Any key on the keyboard which will send a KeyEvent to the client. This
     * class just maintains the state and logic for firing an event, using the
     * &quot;chars&quot; and &quot;code&quot; as the values sent in the event. A subclass must set
     * these appropriately.
     */
    private class TextInputKey extends Key {
        String chars = &quot;&quot;;

        protected void press() {
        }
        protected void release() {
            if (fxvk != secondaryVK &amp;&amp; secondaryPopup != null &amp;&amp; secondaryPopup.isShowing()) {
                return;
            }
            sendKeyEvents();
            if (fxvk == secondaryVK) {
                showSecondaryVK(null);
            }
            super.release();
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                if (chars != null) {
                    target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                }
            }
        }
    }

    /**
     * A key which has a letter, a number or symbol on it
     *
     */
    private class CharKey extends TextInputKey {
        private final String letterChars;
        private final String altChars;
        private final String[] moreChars;

        private CharKey(String letter, String alt, String[] moreChars, String id) {
            this.letterChars = letter;
            this.altChars = alt;
            this.moreChars = moreChars;
            this.chars = this.letterChars;

            text.setText(this.chars);
            altText.setText(this.altChars);
            if (vkLookup) {
                setId((id != null ? id : chars).replaceAll(&quot;\\.&quot;, &quot;&quot;));
            }
        }

        private CharKey(String letter, String alt, String[] moreChars) {
            this(letter, alt, moreChars, null);
        }

        protected void press() {
            super.press();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                showSecondaryVK(null);
                secondaryVKKey = CharKey.this;
                secondaryVKDelay.playFromStart();
            }
        }

        protected void release() {
            super.release();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                secondaryVKDelay.stop();
            }
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            if (isSymbol) {
                chars = altChars;
                text.setText(chars);
                if (moreChars != null &amp;&amp; moreChars.length &gt; 0 &amp;&amp; !Character.isLetter(moreChars[0].charAt(0))) {
                    altText.setText(moreChars[0]);
                } else {
                    altText.setText(null);
                }
            } else {
                chars = (capsDown || shiftDown) ? letterChars.toUpperCase() : letterChars.toLowerCase();
                text.setText(chars);
                altText.setText(altChars);
            }
        }
    }

    /**
     * One of several TextInputKeys which have super powers, such as &quot;Tab&quot; and
     * &quot;Return&quot; and &quot;Backspace&quot;. These keys still send events to the client,
     * but may also have additional state related functionality on the keyboard
     * such as the &quot;Shift&quot; key.
     */
    private class SuperKey extends TextInputKey {
        private SuperKey(String letter, String code) {
            this.chars = code;
            text.setText(letter);
            getStyleClass().add(&quot;special&quot;);
            if (vkLookup) {
                setId(letter);
            }
        }
    }

    /**
     * Some keys actually do need to use KeyCode for pressed / released events,
     * and BackSpace is one of them.
     */
    private class KeyCodeKey extends SuperKey {
        private KeyCode code;

        private KeyCodeKey(String letter, String c, KeyCode code) {
            super(letter, c);
            this.code = code;
            if (vkLookup) {
                setId(letter);
            }
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                target.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_RELEASED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
            }
        }
    }

    /**
     * These keys only manipulate the state of the keyboard and never
     * send key events to the client. For example, &quot;Hide&quot;, &quot;Caps Lock&quot;,
     * etc are all KeyboardStateKeys.
     */
    private class KeyboardStateKey extends Key {
        private final String defaultText;
        private final String toggledText;

        private KeyboardStateKey(String defaultText, String toggledText, String id) {
            this.defaultText = defaultText;
            this.toggledText = toggledText;
            text.setText(this.defaultText);
            if (vkLookup &amp;&amp; id != null) {
                setId(id);
            }
            getStyleClass().add(&quot;special&quot;);
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            //change icon

            if (isSymbol) {
                text.setText(this.toggledText);
            } else {
                text.setText(this.defaultText);
            }
        }
    }

    private void showSecondaryVK(final CharKey key) {
        if (key != null) {
            final Node textInput = primaryVK.getAttachedNode();

            if (secondaryVK == null) {
                secondaryVK = new FXVK();
                //secondaryVK.getStyleClass().addAll(&quot;fxvk-secondary&quot;, &quot;fxvk-portrait&quot;);
                secondaryVK.setSkin(new FXVKSkin(secondaryVK));
                secondaryVK.getStyleClass().setAll(&quot;fxvk-secondary&quot;);
                secondaryPopup = new Popup();
                secondaryPopup.setAutoHide(true);
                secondaryPopup.getContent().add(secondaryVK);
            }

            secondaryVK.chars=null;
            ArrayList&lt;String&gt; secondaryList = new ArrayList&lt;String&gt;();

            // Add primary character
            if (!isSymbol) {
                if (key.letterChars != null &amp;&amp; key.letterChars.length() &gt; 0) {
                    if (shiftDown || capsDown) {
                        secondaryList.add(key.letterChars.toUpperCase());
                    } else {
                        secondaryList.add(key.letterChars);
                    }
                }
            }

            // Add secondary character
            if (key.altChars != null &amp;&amp; key.altChars.length() &gt; 0) {
                if (shiftDown || capsDown) {
                    secondaryList.add(key.altChars.toUpperCase());
                } else {
                    secondaryList.add(key.altChars);
                }
            }

            // Add more letters
            if (key.moreChars != null &amp;&amp; key.moreChars.length &gt; 0) {
                if (isSymbol) {
                    //Add non-letters
                    for (String ch : key.moreChars) {
                        if (!Character.isLetter(ch.charAt(0))) {
                            secondaryList.add(ch);
                        }
                    }
                 } else {
                    //Add letters
                    for (String ch : key.moreChars) {
                        if (Character.isLetter(ch.charAt(0))) {
                            if (shiftDown || capsDown) {
                                secondaryList.add(ch.toUpperCase());
                            } else {
                                secondaryList.add(ch);
                            }
                        }
                    }
                }
            }

            boolean isMultiChar = false;
            for (String s : secondaryList) {
                if (s.length() &gt; 1 ) {
                    isMultiChar = true;
                }
            }

            secondaryVK.chars = secondaryList.toArray(new String[secondaryList.size()]);

            if (secondaryVK.chars.length &gt; 1) {
                if (secondaryVK.getSkin() != null) {
                    ((FXVKSkin)secondaryVK.getSkin()).rebuildSecondaryVK();
                }

                secondaryVK.setAttachedNode(textInput);
                FXVKSkin primarySkin = (FXVKSkin)primaryVK.getSkin();
                FXVKSkin secondarySkin = (FXVKSkin)secondaryVK.getSkin();
                //Insets insets = secondarySkin.getInsets();
                int nKeys = secondaryVK.chars.length;
                int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
                int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

                final double w = snappedLeftInset() + snappedRightInset() +
                                 nKeysPerRow * PREF_PORTRAIT_KEY_WIDTH * (isMultiChar ? 2 : 1) + (nKeysPerRow - 1) * GAP;
                final double h = snappedTopInset() + snappedBottomInset() +
                                 nRows * PREF_KEY_HEIGHT + (nRows-1) * GAP;

                secondaryVK.setPrefWidth(w);
                secondaryVK.setMinWidth(USE_PREF_SIZE);
                secondaryVK.setPrefHeight(h);
                secondaryVK.setMinHeight(USE_PREF_SIZE);
                Platform.runLater(() -&gt; {
                    // Position popup on screen
                    Point2D nodePoint =
                        com.sun.javafx.util.Utils.pointRelativeTo(key, w, h, HPos.CENTER, VPos.TOP,
                                                             5, -3, true);
                    double x = nodePoint.getX();
                    double y = nodePoint.getY();
                    Scene scene = key.getScene();
                    x = Math.min(x, scene.getWindow().getX() + scene.getWidth() - w);
                    secondaryPopup.show(key.getScene().getWindow(), x, y);
                });
            }
        } else {
            closeSecondaryVK();
        }
    }


    private List&lt;List&lt;Key&gt;&gt; loadBoard(String type) {
        List&lt;List&lt;Key&gt;&gt; tmpBoard = boardMap.get(type);
        if (tmpBoard != null) {
            return tmpBoard;
        }

        String boardFileName = type.substring(0,1).toUpperCase() + type.substring(1).toLowerCase() + &quot;Board.txt&quot;;
        try {
            tmpBoard = new ArrayList&lt;List&lt;Key&gt;&gt;(5);
            List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(20);

            InputStream boardFile = FXVKSkin.class.getResourceAsStream(boardFileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(boardFile, &quot;UTF-8&quot;));
            String line;
            // A pointer to the current column. This will be incremented for every string
            // of text, or space.
            int c = 0;
            // The col at which the key will be placed
            int col = 0;
            // The number of columns that the key will span
            int colSpan = 1;
            // Whether the &quot;chars&quot; is an identifier, like $shift or $SymbolBoard, etc.
            boolean identifier = false;
            // The textual content of the Key
            List&lt;String&gt; charsList = new ArrayList&lt;String&gt;(10);

            while ((line = reader.readLine()) != null) {
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                // A single line represents a single row of buttons
                for (int i=0; i&lt;line.length(); i++) {
                    char ch = line.charAt(i);

                    // Process the char
                    if (ch == ' ') {
                        c++;
                    } else if (ch == '[') {
                        // Start of a key
                        col = c;
                        charsList = new ArrayList&lt;String&gt;(10);
                        identifier = false;
                    } else if (ch == ']') {
                        String chars = &quot;&quot;;
                        String alt = null;
                        String[] moreChars = null;

                        for (int idx = 0; idx &lt; charsList.size(); idx++) {
                            charsList.set(idx, FXVKCharEntities.get(charsList.get(idx)));
                        }

                        int listSize = charsList.size();
                        if (listSize &gt; 0) {
                            chars = charsList.get(0);
                            if (listSize &gt; 1) {
                                alt = charsList.get(1);
                                if (listSize &gt; 2) {
                                    moreChars = charsList.subList(2, listSize).toArray(new String[listSize - 2]);
                                }
                            }
                        }

                        // End of a key
                        colSpan = c - col;
                        Key key;
                        if (identifier) {
                            if (&quot;$shift&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;&quot;, null, &quot;shift&quot;) {
                                    @Override protected void release() {
                                        pressShift();
                                    }

                                    @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
                                        if (isSymbol) {
                                            this.setDisable(true);
                                            this.setVisible(false);
                                        } else {
                                            if (capsDown) {
                                                icon.getStyleClass().remove(&quot;shift-icon&quot;);
                                                icon.getStyleClass().add(&quot;capslock-icon&quot;);
                                            } else {
                                                icon.getStyleClass().remove(&quot;capslock-icon&quot;);
                                                icon.getStyleClass().add(&quot;shift-icon&quot;);
                                            }
                                            this.setDisable(false);
                                            this.setVisible(true);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;shift&quot;);

                            } else if (&quot;$SymbolABC&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;!#123&quot;, &quot;ABC&quot;, &quot;symbol&quot;) {
                                    @Override protected void release() {
                                        pressSymbolABC();
                                    }
                                };
                            } else if (&quot;$backspace&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;backspace&quot;, &quot;\b&quot;, KeyCode.BACK_SPACE) {
                                    @Override protected void press() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            clearShift();
                                            sendKeyEvents();
                                            repeatKey = this;
                                            repeatInitialDelay.playFromStart();
                                        } else {
                                            super.press();
                                        }
                                    }
                                    @Override protected void release() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            repeatInitialDelay.stop();
                                            repeatSubsequentDelay.stop();
                                        } else {
                                            super.release();
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;backspace&quot;);
                            } else if (&quot;$enter&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;enter&quot;, &quot;\n&quot;, KeyCode.ENTER);
                                key.getStyleClass().add(&quot;enter&quot;);
                            } else if (&quot;$tab&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;tab&quot;, &quot;\t&quot;, KeyCode.TAB);
                            } else if (&quot;$space&quot;.equals(chars)) {
                                key = new CharKey(&quot; &quot;, &quot; &quot;, null, &quot;space&quot;);
                            } else if (&quot;$clear&quot;.equals(chars)) {
                                key = new SuperKey(&quot;clear&quot;, &quot;&quot;);
                            } else if (&quot;$.org&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.org&quot;, &quot;.org&quot;);
                            } else if (&quot;$.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.com&quot;, &quot;.com&quot;);
                            } else if (&quot;$.net&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.net&quot;, &quot;.net&quot;);
                            } else if (&quot;$oracle.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;oracle.com&quot;, &quot;oracle.com&quot;);
                            } else if (&quot;$gmail.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;gmail.com&quot;, &quot;gmail.com&quot;);
                            } else if (&quot;$hide&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;hide&quot;, null, &quot;hide&quot;) {
                                    @Override protected void release() {
                                        isVKHidden = true;
                                        startSlideOut(false);
                                        // Restore window position
                                        if (vkAdjustWindow) {
                                            restoreWindowPosition(attachedNode);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;hide&quot;);
                            } else if (&quot;$undo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;undo&quot;, &quot;&quot;);
                            } else if (&quot;$redo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;redo&quot;, &quot;&quot;);
                            } else {
                                //Unknown Key
                                key = null;
                            }
                        } else {
                            key = new CharKey(chars, alt, moreChars);
                        }
                        if (key != null) {
                            key.col = col;
                            key.colSpan = colSpan;
                            for (String sc : key.getStyleClass()) {
                                key.text.getStyleClass().add(sc + &quot;-text&quot;);
                                key.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                                key.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                            }
                            if (chars != null &amp;&amp; chars.length() &gt; 1) {
                                key.text.getStyleClass().add(&quot;multi-char-text&quot;);
                            }
                            if (alt != null &amp;&amp; alt.length() &gt; 1) {
                                key.altText.getStyleClass().add(&quot;multi-char-text&quot;);
                            }

                            keys.add(key);
                        }
                    } else {
                        // Normal textual characters. Read all the way up to the
                        // next ] or space
                        for (int j=i; j&lt;line.length(); j++) {
                            char c2 = line.charAt(j);
                            boolean e = false;
                            if (c2 == '\\') {
                                j++;
                                i++;
                                e = true;
                                c2 = line.charAt(j);
                            }

                            if (c2 == '$' &amp;&amp; !e) {
                                identifier = true;
                            }

                            if (c2 == '|' &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j + 1;
                            } else if ((c2 == ']' || c2 == ' ') &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j-1;
                                break;
                            }
                        }
                        c++;
                    }
                }

                c = 0;
                col = 0;
                tmpBoard.add(keys);
                keys = new ArrayList&lt;Key&gt;(20);
            }
            reader.close();
            boardMap.put(type, tmpBoard);
            return tmpBoard;
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ListCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.List;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;

import javafx.scene.control.skin.ListCellSkin;

/**
 * &lt;p&gt;The {@link Cell} type used within {@link ListView} instances. In addition
 * to the API defined on Cell and {@link IndexedCell}, the ListCell is more
 * tightly bound to a ListView, allowing for better support of editing events,
 * etc.
 *
 * &lt;p&gt;A ListView maintains selection, indicating which cell(s) have been selected,
 * and focus, indicating the current focus owner for any given ListView. For each
 * property, each ListCell has a boolean reflecting whether this specific cell is
 * selected or focused. To achieve this, each ListCell has a reference back to
 * the ListView that it is being used within. Each ListCell belongs to one and
 * only one ListView.
 *
 * &lt;p&gt;Note that in the case of virtualized controls like ListView, when a cell
 * has focus this is not in the same sense as application focus. When a ListCell
 * has focus it simply represents the fact that the cell will  receive keyboard
 * events in the situation that the owning ListView actually contains focus. Of
 * course, in the case where a cell has a Node set in the
 * {@link #graphicProperty() graphic} property, it is completely legal for this
 * Node to request, and acquire focus as would normally be expected.
 *
 * @param &lt;T&gt; The type of the item contained within the ListCell.
 * @since JavaFX 2.0
 */
// TODO add code examples
public class ListCell&lt;T&gt; extends IndexedCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default ListCell with the default style class of 'list-cell'.
     */
    public ListCell() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.LIST_ITEM);
    }


    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *     We have to listen to a number of properties on the ListView itself  *
     *     as well as attach listeners to a couple different ObservableLists.  *
     *     We have to be sure to unhook these listeners whenever the reference *
     *     to the ListView changes, or whenever one of the ObservableList      *
     *     references changes (such as setting the selectionModel, focusModel, *
     *     or items).                                                          *
     *                                                                         *
     **************************************************************************/

    /**
     * Listens to the editing index on the ListView. It is possible for the developer
     * to call the ListView#edit(int) method and cause a specific cell to start
     * editing. In such a case, we need to be notified so we can call startEdit
     * on our side.
     */
    private final InvalidationListener editingListener = value -&gt; {
        updateEditing();
    };
    private boolean updateEditingIndex = true;

    /**
     * Listens to the selection model on the ListView. Whenever the selection model
     * is changed (updated), the selected property on the ListCell is updated accordingly.
     */
    private final ListChangeListener&lt;Integer&gt; selectedListener = c -&gt; {
        updateSelection();
    };

    /**
     * Listens to the selectionModel property on the ListView. Whenever the entire model is changed,
     * we have to unhook the weakSelectedListener and update the selection.
     */
    private final ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelPropertyListener = new ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;() {
        @Override
        public void changed(
                ObservableValue&lt;? extends MultipleSelectionModel&lt;T&gt;&gt; observable,
                MultipleSelectionModel&lt;T&gt; oldValue,
                MultipleSelectionModel&lt;T&gt; newValue) {

            if (oldValue != null) {
                oldValue.getSelectedIndices().removeListener(weakSelectedListener);
            }

            if (newValue != null) {
                newValue.getSelectedIndices().addListener(weakSelectedListener);
            }

            updateSelection();
        }

    };

    /**
     * Listens to the items on the ListView. Whenever the items are changed in such a way that
     * it impacts the index of this ListCell, then we must update the item.
     */
    private final ListChangeListener&lt;T&gt; itemsListener = c -&gt; {
        boolean doUpdate = false;
        while (c.next()) {
            // RT-35395: We only update the item in this cell if the current cell
            // index is within the range of the change and certain changes to the
            // list have occurred.
            final int currentIndex = getIndex();
            final ListView&lt;T&gt; lv = getListView();
            final List&lt;T&gt; items = lv == null ? null : lv.getItems();
            final int itemCount = items == null ? 0 : items.size();

            final boolean indexAfterChangeFromIndex = currentIndex &gt;= c.getFrom();
            final boolean indexBeforeChangeToIndex = currentIndex &lt; c.getTo() || currentIndex == itemCount;
            final boolean indexInRange = indexAfterChangeFromIndex &amp;&amp; indexBeforeChangeToIndex;

            doUpdate = indexInRange || (indexAfterChangeFromIndex &amp;&amp; !c.wasReplaced() &amp;&amp; (c.wasRemoved() || c.wasAdded()));
        }

        if (doUpdate) {
            updateItem(-1);
        }
    };

    /**
     * Listens to the items property on the ListView. Whenever the entire list is changed,
     * we have to unhook the weakItemsListener and update the item.
     */
    private final InvalidationListener itemsPropertyListener = new InvalidationListener() {
        private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(null);

        @Override public void invalidated(Observable observable) {
            ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
            if (oldItems != null) {
                oldItems.removeListener(weakItemsListener);
            }

            ListView&lt;T&gt; listView = getListView();
            ObservableList&lt;T&gt; items = listView == null ? null : listView.getItems();
            weakItemsRef = new WeakReference&lt;&gt;(items);

            if (items != null) {
                items.addListener(weakItemsListener);
            }
            updateItem(-1);
        }
    };

    /**
     * Listens to the focus model on the ListView. Whenever the focus model changes,
     * the focused property on the ListCell is updated
     */
    private final InvalidationListener focusedListener = value -&gt; {
        updateFocus();
    };

    /**
     * Listens to the focusModel property on the ListView. Whenever the entire model is changed,
     * we have to unhook the weakFocusedListener and update the focus.
     */
    private final ChangeListener&lt;FocusModel&lt;T&gt;&gt; focusModelPropertyListener = new ChangeListener&lt;FocusModel&lt;T&gt;&gt;() {
        @Override public void changed(ObservableValue&lt;? extends FocusModel&lt;T&gt;&gt; observable,
                                      FocusModel&lt;T&gt; oldValue,
                                      FocusModel&lt;T&gt; newValue) {
            if (oldValue != null) {
                oldValue.focusedIndexProperty().removeListener(weakFocusedListener);
            }
            if (newValue != null) {
                newValue.focusedIndexProperty().addListener(weakFocusedListener);
            }
            updateFocus();
        }
    };


    private final WeakInvalidationListener weakEditingListener = new WeakInvalidationListener(editingListener);
    private final WeakListChangeListener&lt;Integer&gt; weakSelectedListener = new WeakListChangeListener&lt;Integer&gt;(selectedListener);
    private final WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; weakSelectionModelPropertyListener = new WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;(selectionModelPropertyListener);
    private final WeakListChangeListener&lt;T&gt; weakItemsListener = new WeakListChangeListener&lt;T&gt;(itemsListener);
    private final WeakInvalidationListener weakItemsPropertyListener = new WeakInvalidationListener(itemsPropertyListener);
    private final WeakInvalidationListener weakFocusedListener = new WeakInvalidationListener(focusedListener);
    private final WeakChangeListener&lt;FocusModel&lt;T&gt;&gt; weakFocusModelPropertyListener = new WeakChangeListener&lt;FocusModel&lt;T&gt;&gt;(focusModelPropertyListener);

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The ListView associated with this Cell.
     */
    private ReadOnlyObjectWrapper&lt;ListView&lt;T&gt;&gt; listView = new ReadOnlyObjectWrapper&lt;ListView&lt;T&gt;&gt;(this, &quot;listView&quot;) {
        /**
         * A weak reference to the ListView itself, such that whenever the ...
         */
        private WeakReference&lt;ListView&lt;T&gt;&gt; weakListViewRef = new WeakReference&lt;ListView&lt;T&gt;&gt;(null);

        @Override protected void invalidated() {
            // Get the current and old list view references
            final ListView&lt;T&gt; currentListView = get();
            final ListView&lt;T&gt; oldListView = weakListViewRef.get();

            // If the currentListView is the same as the oldListView, then
            // there is nothing to be done.
            if (currentListView == oldListView) return;

            // If the old list view is not null, then we must unhook all its listeners
            if (oldListView != null) {
                // If the old selection model isn't null, unhook it
                final MultipleSelectionModel&lt;T&gt; sm = oldListView.getSelectionModel();
                if (sm != null) {
                    sm.getSelectedIndices().removeListener(weakSelectedListener);
                }

                // If the old focus model isn't null, unhook it
                final FocusModel&lt;T&gt; fm = oldListView.getFocusModel();
                if (fm != null) {
                    fm.focusedIndexProperty().removeListener(weakFocusedListener);
                }

                // If the old items isn't null, unhook the listener
                final ObservableList&lt;T&gt; items = oldListView.getItems();
                if (items != null) {
                    items.removeListener(weakItemsListener);
                }

                // Remove the listeners of the properties on ListView
                oldListView.editingIndexProperty().removeListener(weakEditingListener);
                oldListView.itemsProperty().removeListener(weakItemsPropertyListener);
                oldListView.focusModelProperty().removeListener(weakFocusModelPropertyListener);
                oldListView.selectionModelProperty().removeListener(weakSelectionModelPropertyListener);
            }

            if (currentListView != null) {
                final MultipleSelectionModel&lt;T&gt; sm = currentListView.getSelectionModel();
                if (sm != null) {
                    sm.getSelectedIndices().addListener(weakSelectedListener);
                }

                final FocusModel&lt;T&gt; fm = currentListView.getFocusModel();
                if (fm != null) {
                    fm.focusedIndexProperty().addListener(weakFocusedListener);
                }

                final ObservableList&lt;T&gt; items = currentListView.getItems();
                if (items != null) {
                    items.addListener(weakItemsListener);
                }

                currentListView.editingIndexProperty().addListener(weakEditingListener);
                currentListView.itemsProperty().addListener(weakItemsPropertyListener);
                currentListView.focusModelProperty().addListener(weakFocusModelPropertyListener);
                currentListView.selectionModelProperty().addListener(weakSelectionModelPropertyListener);

                weakListViewRef = new WeakReference&lt;ListView&lt;T&gt;&gt;(currentListView);
            }

            updateItem(-1);
            updateSelection();
            updateFocus();
            requestLayout();
        }
    };
    private void setListView(ListView&lt;T&gt; value) { listView.set(value); }
    public final ListView&lt;T&gt; getListView() { return listView.get(); }
    public final ReadOnlyObjectProperty&lt;ListView&lt;T&gt;&gt; listViewProperty() { return listView.getReadOnlyProperty(); }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void indexChanged(int oldIndex, int newIndex) {
        super.indexChanged(oldIndex, newIndex);

        if (isEditing() &amp;&amp; newIndex == oldIndex) {
            // no-op
            // Fix for RT-31165 - if we (needlessly) update the index whilst the
            // cell is being edited it will no longer be in an editing state.
            // This means that in certain (common) circumstances that it will
            // appear that a cell is uneditable as, despite being clicked, it
            // will not change to the editing state as a layout of VirtualFlow
            // is immediately invoked, which forces all cells to be updated.
        } else {
            updateItem(oldIndex);
            updateSelection();
            updateFocus();
        }
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new ListCellSkin&lt;T&gt;(this);
    }


    /***************************************************************************
     *                                                                         *
     * Editing API                                                             *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void startEdit() {
        final ListView&lt;T&gt; list = getListView();
        if (!isEditable() || (list != null &amp;&amp; ! list.isEditable())) {
            return;
        }

        // it makes sense to get the cell into its editing state before firing
        // the event to the ListView below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

         // Inform the ListView of the edit starting.
        if (list != null) {
            list.fireEvent(new ListView.EditEvent&lt;T&gt;(list,
                    ListView.&lt;T&gt;editStartEvent(),
                    null,
                    getIndex()));
            list.edit(getIndex());
            list.requestFocus();
        }
    }

    /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing()) return;
        ListView&lt;T&gt; list = getListView();

        if (list != null) {
            // Inform the ListView of the edit being ready to be committed.
            list.fireEvent(new ListView.EditEvent&lt;T&gt;(list,
                    ListView.&lt;T&gt;editCommitEvent(),
                    newValue,
                    list.getEditingIndex()));
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state.
        // This MUST come before the updateItem call below, otherwise it will
        // call cancelEdit(), resulting in both commit and cancel events being
        // fired (as identified in RT-29650)
        super.commitEdit(newValue);

        // update the item within this cell, so that it represents the new value
        updateItem(newValue, false);

        if (list != null) {
            // reset the editing index on the ListView. This must come after the
            // event is fired so that the developer on the other side can consult
            // the ListView editingIndex property (if they choose to do that
            // rather than just grab the int from the event).
            list.edit(-1);

            // request focus back onto the list, only if the current focus
            // owner has the list as a parent (otherwise the user might have
            // clicked out of the list entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(list);
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

         // Inform the ListView of the edit being cancelled.
        ListView&lt;T&gt; list = getListView();

        super.cancelEdit();

        if (list != null) {
            int editingIndex = list.getEditingIndex();

            // reset the editing index on the ListView
            if (updateEditingIndex) list.edit(-1);

            // request focus back onto the list, only if the current focus
            // owner has the list as a parent (otherwise the user might have
            // clicked out of the list entirely and given focus to something else.
            // It would be rude of us to request it back again.
            ControlUtils.requestFocusOnControlOnlyIfCurrentFocusOwnerIsChild(list);

            list.fireEvent(new ListView.EditEvent&lt;T&gt;(list,
                    ListView.&lt;T&gt;editCancelEvent(),
                    null,
                    editingIndex));
        }
    }


    /* *************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean firstRun = true;
    private void updateItem(int oldIndex) {
        final ListView&lt;T&gt; lv = getListView();
        final List&lt;T&gt; items = lv == null ? null : lv.getItems();
        final int index = getIndex();
        final int itemCount = items == null ? -1 : items.size();

        // Compute whether the index for this cell is for a real item
        boolean valid = items != null &amp;&amp; index &gt;=0 &amp;&amp; index &lt; itemCount;

        final T oldValue = getItem();
        final boolean isEmpty = isEmpty();

        // Cause the cell to update itself
        outer: if (valid) {
            final T newValue = items.get(index);

            // RT-35864 - if the index didn't change, then avoid calling updateItem
            // unless the item has changed.
            if (oldIndex == index) {
                if (!isItemChanged(oldValue, newValue)) {
                    // RT-37054:  we break out of the if/else code here and
                    // proceed with the code following this, so that we may
                    // still update references, listeners, etc as required.
                    break outer;
                }
            }
            updateItem(newValue, false);
        } else {
            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            if ((!isEmpty &amp;&amp; oldValue != null) || firstRun) {
                updateItem(null, true);
                firstRun = false;
            }
        }
    }

    /**
     * Updates the ListView associated with this Cell.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     * @param listView the ListView associated with this cell
     */
    public final void updateListView(ListView&lt;T&gt; listView) {
        setListView(listView);
    }

    private void updateSelection() {
        if (isEmpty()) return;
        int index = getIndex();
        ListView&lt;T&gt; listView = getListView();
        if (index == -1 || listView == null) return;

        SelectionModel&lt;T&gt; sm = listView.getSelectionModel();
        if (sm == null) {
            updateSelected(false);
            return;
        }

        boolean isSelected = sm.isSelected(index);
        if (isSelected() == isSelected) return;

        updateSelected(isSelected);
    }

    private void updateFocus() {
        int index = getIndex();
        ListView&lt;T&gt; listView = getListView();
        if (index == -1 || listView == null) return;

        FocusModel&lt;T&gt; fm = listView.getFocusModel();
        if (fm == null) {
            setFocused(false);
            return;
        }

        setFocused(fm.isFocused(index));
    }

    private void updateEditing() {
        final int index = getIndex();
        final ListView&lt;T&gt; list = getListView();
        final int editIndex = list == null ? -1 : list.getEditingIndex();
        final boolean editing = isEditing();

        // Check that the list is specified, and my index is not -1
        if (index != -1 &amp;&amp; list != null) {
<A NAME="18"></A>            // If my index is the index being edited and I'm not currently in
            // the edit mode, then I need to enter the edit mode
            if (index == editIndex &amp;&amp; !editing) {
                <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#18',2,'match34-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>startEdit();
            } else if (index != editIndex &amp;&amp; editing) {
                // If my index is not the one being edited then I need to cancel
                // the edit. The tricky thing here is that as part of this call
                // I cannot end up calling list.edit(-1) the way that the standard
                // cancelEdit method would do. Yet, I need to call cancelEdit
                // so that subclasses which override cancelEdit can execute. So,
                // I have to use a kind of hacky flag workaround.
                updateEditingIndex = false;
                cancelEdit();
                updateEditingIndex = true;
            }
        }
    }</B></FONT>



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;list-cell&quot;;



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case INDEX: return getIndex();
            case SELECTED: return isSelected();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS: {
                ListView&lt;T&gt; listView = getListView();
                if (listView != null) {
                    FocusModel&lt;T&gt; fm = listView.getFocusModel();
                    if (fm != null) {
                        fm.focus(getIndex());
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ListView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import com.sun.javafx.scene.control.behavior.ListCellBehavior;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.css.StyleableDoubleProperty;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Orientation;
import javafx.scene.layout.Region;
import javafx.util.Callback;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.EnumConverter;

import javafx.collections.WeakListChangeListener;

import javafx.css.converter.SizeConverter;
import javafx.scene.control.skin.ListViewSkin;

import java.lang.ref.WeakReference;

import javafx.css.PseudoClass;
import javafx.beans.DefaultProperty;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.util.Pair;

/**
 * A ListView displays a horizontal or vertical list of items from which the
 * user may select, or with which the user may interact. A ListView is able to
 * have its generic type set to represent the type of data in the backing model.
 * Doing this has the benefit of making various methods in the ListView, as well
 * as the supporting classes (mentioned below), type-safe. In addition, making
 * use of the generic type supports substantially simplified development of applications
 * making use of ListView, as all modern IDEs are able to auto-complete far
 * more successfully with the additional type information.
 *
 * &lt;h3&gt;Populating a ListView&lt;/h3&gt;
 * &lt;p&gt;A simple example of how to create and populate a ListView of names (Strings)
 * is shown here:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;String&gt; names = FXCollections.observableArrayList(
 *          &quot;Julia&quot;, &quot;Ian&quot;, &quot;Sue&quot;, &quot;Matthew&quot;, &quot;Hannah&quot;, &quot;Stephan&quot;, &quot;Denise&quot;);
 * ListView&lt;String&gt; listView = new ListView&lt;String&gt;(names);}&lt;/pre&gt;
 *
 * &lt;p&gt;The elements of the ListView are contained within the
 * {@link #itemsProperty() items} {@link ObservableList}. This
 * ObservableList is automatically observed by the ListView, such that any
 * changes that occur inside the ObservableList will be automatically shown in
 * the ListView itself. If passing the &lt;code&gt;ObservableList&lt;/code&gt; in to the
 * ListView constructor is not feasible, the recommended approach for setting
 * the items is to simply call:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;T&gt; content = ...
 * listView.setItems(content);}&lt;/pre&gt;
 *
 * The end result of this is, as noted above, that the ListView will automatically
 * refresh the view to represent the items in the list.
 *
 * &lt;p&gt;Another approach, whilst accepted by the ListView, &lt;b&gt;is not the
 * recommended approach&lt;/b&gt;:
 *
 * &lt;pre&gt;
 * {@code
 * List&lt;T&gt; content = ...
 * getItems().setAll(content);}&lt;/pre&gt;
 *
 * The issue with the approach shown above is that the content list is being
 * copied into the items list - meaning that subsequent changes to the content
 * list are not observed, and will not be reflected visually within the ListView.
 *
 * &lt;h3&gt;ListView Selection / Focus APIs&lt;/h3&gt;
 * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 * {@link SelectionModel} and {@link FocusModel} classes. A ListView has at most
 * one instance of each of these classes, available from
 * {@link #selectionModelProperty() selectionModel} and
 * {@link #focusModelProperty() focusModel} properties respectively.
 * Whilst it is possible to use this API to set a new selection model, in
 * most circumstances this is not necessary - the default selection and focus
 * models should work in most circumstances.
 *
 * &lt;p&gt;The default {@link SelectionModel} used when instantiating a ListView is
 * an implementation of the {@link MultipleSelectionModel} abstract class.
 * However, as noted in the API documentation for
 * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property, the default value is {@link SelectionMode#SINGLE}. To enable
 * multiple selection in a default ListView instance, it is therefore necessary
 * to do the following:
 *
 * &lt;pre&gt;
 * {@code
 * listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 *
 * &lt;h3&gt;Customizing ListView Visuals&lt;/h3&gt;
 * &lt;p&gt;The visuals of the ListView can be entirely customized by replacing the
 * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 * generate {@link ListCell} instances, which are used to represent an item in the
 * ListView. See the {@link Cell} class documentation for a more complete
 * description of how to write custom Cells.
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 *
 * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 * than when a cell is not being edited. This is the responsibility of the
 * {@link Cell} implementation being used. For ListView, this is the responsibility
 * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 * or to switch to a different UI when editing begins (e.g. when a double-click
 * is received on a cell).&lt;/p&gt;
 *
 * &lt;p&gt;To know when editing has been requested on a cell,
 * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 * appropriate (e.g. set the text to null and set the graphic to be a
 * {@link TextField}). Additionally, you should also override
 * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 * when the editing concludes. In both cases it is important that you also
 * ensure that you call the super method to have the cell perform all duties it
 * must do to enter or exit its editing mode.&lt;/p&gt;
 *
 * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 * interested in is how to commit or cancel the editing that is taking place. This is your
 * responsibility as the cell factory provider. Your cell implementation will know
 * when the editing is over, based on the user input (e.g. when the user presses
 * the Enter or ESC keys on their keyboard). When this happens, it is your
 * responsibility to call {@link Cell#commitEdit(Object)} or
 * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 *
 * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 * ListView, which you can observe by adding an {@link EventHandler} via
 * {@link ListView#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 * you can also observe edit events for
 * {@link ListView#setOnEditStart(javafx.event.EventHandler) edit start}
 * and {@link ListView#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 *
 * &lt;p&gt;By default the ListView edit commit handler is non-null, with a default
 * handler that attempts to overwrite the property value for the
 * item in the currently-being-edited row. It is able to do this as the
 * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 * is passed along to the edit commit handler via the
 * {@link EditEvent} that is fired. It is simply a matter of calling
 * {@link EditEvent#getNewValue()} to retrieve this value.
 *
 * &lt;p&gt;It is very important to note that if you call
 * {@link ListView#setOnEditCommit(javafx.event.EventHandler)} with your own
 * {@link EventHandler}, then you will be removing the default handler. Unless
 * you then handle the writeback to the property (or the relevant data source),
 * nothing will happen. You can work around this by using the
 * {@link ListView#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 * method to add a {@link ListView#editCommitEvent()} {@link EventType} with
 * your desired {@link EventHandler} as the second argument. Using this method,
 * you will not replace the default implementation, but you will be notified when
 * an edit commit has occurred.&lt;/p&gt;
 *
 * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 * Fortunately, JavaFX ships with a number of pre-built cell factories that
 * handle all the editing requirements on your behalf. You can find these
 * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 *
 * @see ListCell
 * @see MultipleSelectionModel
 * @see FocusModel
 * @param &lt;T&gt; This type is used to represent the type of the objects stored in
 *          the ListViews {@link #itemsProperty() items} ObservableList. It is
 *          also used in the {@link #selectionModelProperty() selection model}
 *          and {@link #focusModelProperty() focus model}.
 * @since JavaFX 2.0
 */
// TODO add code examples
@DefaultProperty(&quot;items&quot;)
public class ListView&lt;T&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * An EventType that indicates some edit event has occurred. It is the parent
     * type of all other edit events: {@link #editStartEvent()},
     *  {@link #editCommitEvent()} and {@link #editCancelEvent()}.
     * @param &lt;T&gt; the type of the objects stored in this ListView
     * @return the event type
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editAnyEvent() {
        return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_ANY_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
            new EventType&lt;&gt;(Event.ANY, &quot;LIST_VIEW_EDIT&quot;);

    /**
     * An EventType used to indicate that an edit event has started within the
     * ListView upon which the event was fired.
     * @param &lt;T&gt; the type of the objects stored in this ListView
     * @return the event type
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editStartEvent() {
        return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_START_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_START_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);

    /**
     * An EventType used to indicate that an edit event has just been canceled
     * within the ListView upon which the event was fired.
     * @param &lt;T&gt; the type of the objects stored in this ListView
     * @return the event type
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editCancelEvent() {
        return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_CANCEL_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);

    /**
     * An EventType used to indicate that an edit event has been committed
     * within the ListView upon which the event was fired.
     * @param &lt;T&gt; the type of the objects stored in this ListView
     * @return the event type
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editCommitEvent() {
        return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_COMMIT_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);



    /***************************************************************************
     *                                                                         *
     * Fields                                                                  *
     *                                                                         *
     **************************************************************************/

    // by default we always select the first row in the ListView, and when the
    // items list changes, we also reselect the first row. In some cases, such as
    // for the ComboBox, this is not desirable, so it can be disabled here.
    private boolean selectFirstRowByDefault = true;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default ListView which will display contents stacked vertically.
     * As no {@link ObservableList} is provided in this constructor, an empty
     * ObservableList is created, meaning that it is legal to directly call
     * {@link #getItems()} if so desired. However, as noted elsewhere, this
     * is not the recommended approach
     * (instead call {@link #setItems(javafx.collections.ObservableList)}).
     *
     * &lt;p&gt;Refer to the {@link ListView} class documentation for details on the
     * default state of other properties.
     */
    public ListView() {
        this(FXCollections.&lt;T&gt;observableArrayList());
    }

    /**
     * Creates a default ListView which will stack the contents retrieved from the
     * provided {@link ObservableList} vertically.
     *
     * &lt;p&gt;Attempts to add a listener to the {@link ObservableList}, such that all
     * subsequent changes inside the list will be shown to the user.
     *
     * &lt;p&gt;Refer to the {@link ListView} class documentation for details on the
     * default state of other properties.
     * @param items the list of items
     */
    public ListView(ObservableList&lt;T&gt; items) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.LIST_VIEW);

        setItems(items);

        // Install default....
        // ...selection model
        setSelectionModel(new ListView.ListViewBitSetSelectionModel&lt;T&gt;(this));

        // ...focus model
        setFocusModel(new ListView.ListViewFocusModel&lt;T&gt;(this));

        // ...edit commit handler
        setOnEditCommit(DEFAULT_EDIT_COMMIT_HANDLER);

        // Fix for RT-36651, which was introduced by RT-35679 (above) and resolved
        // by having special-case code to remove the listener when requested.
        // This is done by ComboBoxListViewSkin, so that selection is not done
        // when a ComboBox is shown.
        getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) change -&gt; {
            if (change.wasAdded() &amp;&amp; &quot;selectFirstRowByDefault&quot;.equals(change.getKey())) {
                Boolean _selectFirstRowByDefault = (Boolean) change.getValueAdded();
                if (_selectFirstRowByDefault == null) return;
                selectFirstRowByDefault = _selectFirstRowByDefault;
            }
        });
    }



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; DEFAULT_EDIT_COMMIT_HANDLER = t -&gt; {
        int index = t.getIndex();
        List&lt;T&gt; list = getItems();
        if (index &lt; 0 || index &gt;= list.size()) return;
        list.set(index, t.getNewValue());
    };



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- Items
    private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items;

    /**
     * Sets the underlying data model for the ListView. Note that it has a generic
     * type that must match the type of the ListView itself.
     * @param value the list of items for this ListView
     */
    public final void setItems(ObservableList&lt;T&gt; value) {
        itemsProperty().set(value);
    }

    /**
     * Returns an {@link ObservableList} that contains the items currently being
     * shown to the user. This may be null if
     * {@link #setItems(javafx.collections.ObservableList)} has previously been
     * called, however, by default it is an empty ObservableList.
     *
     * @return An ObservableList containing the items to be shown to the user, or
     *      null if the items have previously been set to null.
     */
    public final ObservableList&lt;T&gt; getItems() {
        return items == null ? null : items.get();
    }

    /**
     * The underlying data model for the ListView. Note that it has a generic
     * type that must match the type of the ListView itself.
     * @return the items property for this ListView
     */
    public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() {
        if (items == null) {
            items = new SimpleObjectProperty&lt;&gt;(this, &quot;items&quot;);
        }
        return items;
    }


    // --- Placeholder Node
    private ObjectProperty&lt;Node&gt; placeholder;
    /**
     * This Node is shown to the user when the listview has no content to show.
     * This may be the case because the table model has no data in the first
     * place or that a filter has been applied to the list model, resulting
     * in there being nothing to show the user..
     * @return the placeholder property for this ListView
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Node&gt; placeholderProperty() {
        if (placeholder == null) {
            placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
        }
        return placeholder;
    }
    public final void setPlaceholder(Node value) {
        placeholderProperty().set(value);
    }
    public final Node getPlaceholder() {
        return placeholder == null ? null : placeholder.get();
    }


    // --- Selection Model
    private ObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModel = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt;(this, &quot;selectionModel&quot;);

    /**
     * Sets the {@link MultipleSelectionModel} to be used in the ListView.
     * Despite a ListView requiring a &lt;b&gt;Multiple&lt;/b&gt;SelectionModel, it is possible
     * to configure it to only allow single selection (see
     * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
     * for more information).
     * @param value the MultipleSelectionModel to be used in this ListView
     */
    public final void setSelectionModel(MultipleSelectionModel&lt;T&gt; value) {
        selectionModelProperty().set(value);
    }

    /**
     * Returns the currently installed selection model.
     * @return the currently installed selection model
     */
    public final MultipleSelectionModel&lt;T&gt; getSelectionModel() {
        return selectionModel == null ? null : selectionModel.get();
    }

    /**
     * The SelectionModel provides the API through which it is possible
     * to select single or multiple items within a ListView, as  well as inspect
     * which items have been selected by the user. Note that it has a generic
     * type that must match the type of the ListView itself.
     * @return the selectionModel property
     */
    public final ObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelProperty() {
        return selectionModel;
    }


    // --- Focus Model
    private ObjectProperty&lt;FocusModel&lt;T&gt;&gt; focusModel;

    /**
     * Sets the {@link FocusModel} to be used in the ListView.
     * @param value the FocusModel to be used in the ListView
     */
    public final void setFocusModel(FocusModel&lt;T&gt; value) {
        focusModelProperty().set(value);
    }

    /**
     * Returns the currently installed {@link FocusModel}.
     * @return the currently installed FocusModel
     */
    public final FocusModel&lt;T&gt; getFocusModel() {
        return focusModel == null ? null : focusModel.get();
    }

    /**
     * The FocusModel provides the API through which it is possible
     * to both get and set the focus on a single item within a ListView. Note
     * that it has a generic type that must match the type of the ListView itself.
     * @return the FocusModel property
     */
    public final ObjectProperty&lt;FocusModel&lt;T&gt;&gt; focusModelProperty() {
        if (focusModel == null) {
            focusModel = new SimpleObjectProperty&lt;FocusModel&lt;T&gt;&gt;(this, &quot;focusModel&quot;);
        }
        return focusModel;
    }


    // --- Orientation
    private ObjectProperty&lt;Orientation&gt; orientation;

    /**
     * Sets the orientation of the ListView, which dictates whether
     * it scrolls vertically or horizontally.
     * @param value the orientation of the ListView
     */
    public final void setOrientation(Orientation value) {
        orientationProperty().set(value);
    };

    /**
     * Returns the current orientation of the ListView, which dictates whether
     * it scrolls vertically or horizontally.
     * @return the current orientation of the ListView
     */
    public final Orientation getOrientation() {
        return orientation == null ? Orientation.VERTICAL : orientation.get();
    }

    /**
     * The orientation of the {@code ListView} - this can either be horizontal
     * or vertical.
     * @return the orientation property of this ListView
     */
    public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
        if (orientation == null) {
            orientation = new StyleableObjectProperty&lt;Orientation&gt;(Orientation.VERTICAL) {
                @Override public void invalidated() {
                    final boolean active = (get() == Orientation.VERTICAL);
                    pseudoClassStateChanged(PSEUDO_CLASS_VERTICAL,    active);
                    pseudoClassStateChanged(PSEUDO_CLASS_HORIZONTAL, !active);
                }

                @Override
                public CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt; getCssMetaData() {
                    return ListView.StyleableProperties.ORIENTATION;
                }

                @Override
                public Object getBean() {
                    return ListView.this;
                }

                @Override
                public String getName() {
                    return &quot;orientation&quot;;
                }
            };
        }
        return orientation;
    }




    // --- Cell Factory
    private ObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt; cellFactory;

    /**
     * Sets a new cell factory to use in the ListView. This forces all old
     * {@link ListCell}'s to be thrown away, and new ListCell's created with
     * the new cell factory.
     * @param value cell factory to use in this ListView
     */
    public final void setCellFactory(Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; value) {
        cellFactoryProperty().set(value);
    }

    /**
     * Returns the current cell factory.
     * @return the current cell factory
     */
    public final Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; getCellFactory() {
        return cellFactory == null ? null : cellFactory.get();
    }

    /**
     * &lt;p&gt;Setting a custom cell factory has the effect of deferring all cell
     * creation, allowing for total customization of the cell. Internally, the
     * ListView is responsible for reusing ListCells - all that is necessary
     * is for the custom cell factory to return from this function a ListCell
     * which might be usable for representing any item in the ListView.
     *
     * &lt;p&gt;Refer to the {@link Cell} class documentation for more detail.
     * @return the cell factory property
     */
    public final ObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt; cellFactoryProperty() {
        if (cellFactory == null) {
            cellFactory = new SimpleObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt;(this, &quot;cellFactory&quot;);
        }
        return cellFactory;
    }


    // --- Fixed cell size
    private DoubleProperty fixedCellSize;

    /**
     * Sets the new fixed cell size for this control. Any value greater than
     * zero will enable fixed cell size mode, whereas a zero or negative value
     * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
     * mode.
     *
     * @param value The new fixed cell size value, or a value less than or equal
     *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
     * @since JavaFX 8.0
     */
    public final void setFixedCellSize(double value) {
        fixedCellSizeProperty().set(value);
    }

    /**
     * Returns the fixed cell size value. A value less than or equal to zero is
     * used to represent that fixed cell size mode is disabled, and a value
     * greater than zero represents the size of all cells in this control.
     *
     * @return A double representing the fixed cell size of this control, or a
     *      value less than or equal to zero if fixed cell size mode is disabled.
     * @since JavaFX 8.0
     */
    public final double getFixedCellSize() {
        return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
    }
    /**
     * Specifies whether this control has cells that are a fixed height (of the
     * specified value). If this value is less than or equal to zero,
     * then all cells are individually sized and positioned. This is a slow
     * operation. Therefore, when performance matters and developers are not
     * dependent on variable cell sizes it is a good idea to set the fixed cell
     * size value. Generally cells are around 24px, so setting a fixed cell size
     * of 24 is likely to result in very little difference in visuals, but a
     * improvement to performance.
     *
     * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
     * This should not be confused with the -fx-cell-size property. The difference
     * between these two CSS properties is that -fx-cell-size will size all
     * cells to the specified size, but it will not enforce that this is the
     * only size (thus allowing for variable cell sizes, and preventing the
     * performance gains from being possible). Therefore, when performance matters
     * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
     * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
     *
     * @return the fixed cell size property
     * @since JavaFX 8.0
     */
    public final DoubleProperty fixedCellSizeProperty() {
        if (fixedCellSize == null) {
            fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
                @Override public CssMetaData&lt;ListView&lt;?&gt;,Number&gt; getCssMetaData() {
                    return StyleableProperties.FIXED_CELL_SIZE;
                }

                @Override public Object getBean() {
                    return ListView.this;
                }

                @Override public String getName() {
                    return &quot;fixedCellSize&quot;;
                }
            };
        }
        return fixedCellSize;
    }


    // --- Editable
    private BooleanProperty editable;
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }
    public final boolean isEditable() {
        return editable == null ? false : editable.get();
    }
    /**
     * Specifies whether this ListView is editable - only if the ListView and
     * the ListCells within it are both editable will a ListCell be able to go
     * into their editing state.
     * @return the editable property
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
        }
        return editable;
    }


    // --- Editing Index
    private ReadOnlyIntegerWrapper editingIndex;

    private void setEditingIndex(int value) {
        editingIndexPropertyImpl().set(value);
    }

    /**
     * Returns the index of the item currently being edited in the ListView,
     * or -1 if no item is being edited.
     * @return the index of the item currently being edited
     */
    public final int getEditingIndex() {
        return editingIndex == null ? -1 : editingIndex.get();
    }

    /**
     * &lt;p&gt;A property used to represent the index of the item currently being edited
     * in the ListView, if editing is taking place, or -1 if no item is being edited.
     *
     * &lt;p&gt;It is not possible to set the editing index, instead it is required that
     * you call {@link #edit(int)}.
     * @return the editing index property
     */
    public final ReadOnlyIntegerProperty editingIndexProperty() {
        return editingIndexPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyIntegerWrapper editingIndexPropertyImpl() {
        if (editingIndex == null) {
            editingIndex = new ReadOnlyIntegerWrapper(this, &quot;editingIndex&quot;, -1);
        }
        return editingIndex;
    }


    // --- On Edit Start
    private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditStart;

    /**
     * Sets the {@link EventHandler} that will be called when the user begins
     * an edit.
     *
     * &lt;p&gt;This is a convenience method - the same result can be
     * achieved by calling
     * &lt;code&gt;addEventHandler(ListView.EDIT_START_EVENT, eventHandler)&lt;/code&gt;.
     * @param value the EventHandler that will be called when the user begins
     * an edit
     */
    public final void setOnEditStart(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
        onEditStartProperty().set(value);
    }

    /**
     * Returns the {@link EventHandler} that will be called when the user begins
     * an edit.
     * @return the EventHandler that will be called when the user begins an edit
     */
    public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditStart() {
        return onEditStart == null ? null : onEditStart.get();
    }

    /**
     * This event handler will be fired when the user successfully initiates
     * editing.
     * @return the onEditStart event handler property
     */
    public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditStartProperty() {
        if (onEditStart == null) {
            onEditStart = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(ListView.&lt;T&gt;editStartEvent(), get());
                }

                @Override
                public Object getBean() {
                    return ListView.this;
                }

                @Override
                public String getName() {
                    return &quot;onEditStart&quot;;
                }
            };
        }
        return onEditStart;
    }


    // --- On Edit Commit
    private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCommit;

    /**
     * Sets the {@link EventHandler} that will be called when the user has
     * completed their editing. This is called as part of the
     * {@link ListCell#commitEdit(java.lang.Object)} method.
     *
     * &lt;p&gt;This is a convenience method - the same result can be
     * achieved by calling
     * &lt;code&gt;addEventHandler(ListView.EDIT_START_EVENT, eventHandler)&lt;/code&gt;.
     * @param value the EventHandler that will be called when the user has
     * completed their editing
     */
    public final void setOnEditCommit(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
        onEditCommitProperty().set(value);
    }

    /**
     * Returns the {@link EventHandler} that will be called when the user commits
     * an edit.
     * @return the EventHandler that will be called when the user commits an edit
     */
    public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditCommit() {
        return onEditCommit == null ? null : onEditCommit.get();
    }

    /**
     * &lt;p&gt;This property is used when the user performs an action that should
     * result in their editing input being persisted.&lt;/p&gt;
     *
     * &lt;p&gt;The EventHandler in this property should not be called directly -
     * instead call {@link ListCell#commitEdit(java.lang.Object)} from within
     * your custom ListCell. This will handle firing this event, updating the
     * view, and switching out of the editing state.&lt;/p&gt;
     * @return the onEditCommit event handler property
     */
    public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCommitProperty() {
        if (onEditCommit == null) {
            onEditCommit = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(ListView.&lt;T&gt;editCommitEvent(), get());
                }

                @Override
                public Object getBean() {
                    return ListView.this;
                }

                @Override
                public String getName() {
                    return &quot;onEditCommit&quot;;
                }
            };
        }
        return onEditCommit;
    }


    // --- On Edit Cancel
    private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCancel;

    /**
     * Sets the {@link EventHandler} that will be called when the user cancels
     * an edit.
     * @param value the EventHandler that will be called when the user cancels
     * an edit
     */
    public final void setOnEditCancel(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
        onEditCancelProperty().set(value);
    }

    /**
     * Returns the {@link EventHandler} that will be called when the user cancels
     * an edit.
     * @return the EventHandler that will be called when the user cancels an edit
     */
    public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditCancel() {
        return onEditCancel == null ? null : onEditCancel.get();
    }

    /**
     * This event handler will be fired when the user cancels editing a cell.
     * @return the onEditCancel event handler property
     */
    public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCancelProperty() {
        if (onEditCancel == null) {
            onEditCancel = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(ListView.&lt;T&gt;editCancelEvent(), get());
                }

                @Override
                public Object getBean() {
                    return ListView.this;
                }

                @Override
                public String getName() {
                    return &quot;onEditCancel&quot;;
                }
            };
        }
        return onEditCancel;
    }




    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Instructs the ListView to begin editing the item in the given index, if
     * the ListView is {@link #editableProperty() editable}. Once
     * this method is called, if the current {@link #cellFactoryProperty()} is
     * set up to support editing, the Cell will switch its visual state to enable
     * for user input to take place.
     *
     * @param itemIndex The index of the item in the ListView that should be
     *     edited.
     */
    public void edit(int itemIndex) {
        if (!isEditable()) return;
        setEditingIndex(itemIndex);
    }

    /**
     * Scrolls the ListView such that the item in the given index is visible to
     * the end user.
     *
     * @param index The index that should be made visible to the user, assuming
     *      of course that it is greater than, or equal to 0, and less than the
     *      size of the items list contained within the given ListView.
     */
    public void scrollTo(int index) {
        ControlUtils.scrollToIndex(this, index);
    }

    /**
     * Scrolls the ListView so that the given object is visible within the viewport.
     * @param object The object that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollTo(T object) {
        if( getItems() != null ) {
            int idx = getItems().indexOf(object);
            if( idx &gt;= 0 ) {
                ControlUtils.scrollToIndex(this, idx);
            }
        }
    }

    /**
     * Called when there's a request to scroll an index into view using {@link #scrollTo(int)}
     * or {@link #scrollTo(Object)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;

    public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
        onScrollToProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
        if( onScrollTo != null ) {
            return onScrollTo.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
        if( onScrollTo == null ) {
            onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
                }

                @Override public Object getBean() {
                    return ListView.this;
                }

                @Override public String getName() {
                    return &quot;onScrollTo&quot;;
                }
            };
        }
        return onScrollTo;
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new ListViewSkin&lt;T&gt;(this);
    }

    /**
     * Calling {@code refresh()} forces the ListView control to recreate and
     * repopulate the cells necessary to populate the visual bounds of the control.
     * In other words, this forces the ListView to update what it is showing to
     * the user. This is useful in cases where the underlying data source has
     * changed in a way that is not observed by the ListView itself.
     *
     * @since JavaFX 8u60
     */
    public void refresh() {
        getProperties().put(Properties.RECREATE, Boolean.TRUE);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;list-view&quot;;

    private static class StyleableProperties {
        private static final CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt; ORIENTATION =
            new CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt;(&quot;-fx-orientation&quot;,
                new EnumConverter&lt;Orientation&gt;(Orientation.class),
                Orientation.VERTICAL) {

            @Override
            public Orientation getInitialValue(ListView&lt;?&gt; node) {
                // A vertical ListView should remain vertical
                return node.getOrientation();
            }

            @Override
            public boolean isSettable(ListView&lt;?&gt; n) {
                return n.orientation == null || !n.orientation.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // orientationProperty() is a StyleableProperty&lt;Orientation&gt;
            @Override
            public StyleableProperty&lt;Orientation&gt; getStyleableProperty(ListView&lt;?&gt; n) {
                return (StyleableProperty&lt;Orientation&gt;)n.orientationProperty();
            }
        };

        private static final CssMetaData&lt;ListView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
            new CssMetaData&lt;ListView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
                                                SizeConverter.getInstance(),
                                                Region.USE_COMPUTED_SIZE) {

                @Override public Double getInitialValue(ListView&lt;?&gt; node) {
                    return node.getFixedCellSize();
                }

                @Override public boolean isSettable(ListView&lt;?&gt; n) {
                    return n.fixedCellSize == null || !n.fixedCellSize.isBound();
                }

                @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ListView&lt;?&gt; n) {
                    return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.fixedCellSizeProperty();
                }
            };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(ORIENTATION);
            styleables.add(FIXED_CELL_SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    private static final PseudoClass PSEUDO_CLASS_VERTICAL =
            PseudoClass.getPseudoClass(&quot;vertical&quot;);
    private static final PseudoClass PSEUDO_CLASS_HORIZONTAL =
            PseudoClass.getPseudoClass(&quot;horizontal&quot;);



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case MULTIPLE_SELECTION: {
                MultipleSelectionModel&lt;T&gt; sm = getSelectionModel();
                return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Support Interfaces                                                      *
     *                                                                         *
     **************************************************************************/



    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**
     * An {@link Event} subclass used specifically in ListView for representing
     * edit-related events. It provides additional API to easily access the
     * index that the edit event took place on, as well as the input provided
     * by the end user.
     *
     * @param &lt;T&gt; The type of the input, which is the same type as the ListView
     *      itself.
     * @since JavaFX 2.0
     */
    public static class EditEvent&lt;T&gt; extends Event {
        private final T newValue;
        private final int editIndex;
        private final ListView&lt;T&gt; source;

        private static final long serialVersionUID = 20130724L;

        /**
         * Common supertype for all edit event types.
         * @since JavaFX 8.0
         */
        public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;

        /**
         * Creates a new EditEvent instance to represent an edit event. This
         * event is used for {@link #editStartEvent()},
         * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
         * @param source the source
         * @param eventType the event type
         * @param newValue the new value
         * @param editIndex the edit index
         */
        public EditEvent(ListView&lt;T&gt; source,
                         EventType&lt;? extends ListView.EditEvent&lt;T&gt;&gt; eventType,
                         T newValue,
                         int editIndex) {
            super(source, Event.NULL_SOURCE_TARGET, eventType);
            this.source = source;
            this.editIndex = editIndex;
            this.newValue = newValue;
        }

        /**
         * Returns the ListView upon which the edit took place.
         */
        @Override public ListView&lt;T&gt; getSource() {
            return source;
        }

        /**
         * Returns the index in which the edit took place.
         * @return the index in which the edit took place
         */
        public int getIndex() {
            return editIndex;
        }

        /**
         * Returns the value of the new input provided by the end user.
         * @return the value of the new input provided by the end user
         */
        public T getNewValue() {
            return newValue;
        }

        /**
         * Returns a string representation of this {@code EditEvent} object.
         * @return a string representation of this {@code EditEvent} object.
         */
        @Override public String toString() {
            return &quot;ListViewEditEvent [ newValue: &quot; + getNewValue() + &quot;, ListView: &quot; + getSource() + &quot; ]&quot;;
        }
    }



    // package for testing
    static class ListViewBitSetSelectionModel&lt;T&gt; extends MultipleSelectionModelBase&lt;T&gt; {

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        public ListViewBitSetSelectionModel(final ListView&lt;T&gt; listView) {
            if (listView == null) {
                throw new IllegalArgumentException(&quot;ListView can not be null&quot;);
            }

            this.listView = listView;

            ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(listView.getItems());


            /*
             * The following two listeners are used in conjunction with
             * SelectionModel.select(T obj) to allow for a developer to select
             * an item that is not actually in the data model. When this occurs,
             * we actively try to find an index that matches this object, going
             * so far as to actually watch for all changes to the items list,
             * rechecking each time.
             */
            itemsObserver = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
                    ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(listView.getItems());
                    updateItemsObserver(oldItems, listView.getItems());
                }
            };

            this.listView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
            if (listView.getItems() != null) {
                this.listView.getItems().addListener(weakItemsContentObserver);
            }

            updateItemCount();

            updateDefaultSelection();
        }

        // watching for changes to the items list content
        private final ListChangeListener&lt;T&gt; itemsContentObserver = new ListChangeListener&lt;T&gt;() {
            @Override public void onChanged(Change&lt;? extends T&gt; c) {
                updateItemCount();

                boolean doSelectionUpdate = true;

                while (c.next()) {
                    final T selectedItem = getSelectedItem();
                    final int selectedIndex = getSelectedIndex();

                    if (listView.getItems() == null || listView.getItems().isEmpty()) {
                        selectedItemChange = c;
                        clearSelection();
                        selectedItemChange = null;
                    } else if (selectedIndex == -1 &amp;&amp; selectedItem != null) {
                        int newIndex = listView.getItems().indexOf(selectedItem);
                        if (newIndex != -1) {
                            setSelectedIndex(newIndex);
                            doSelectionUpdate = false;
                        }
                    } else if (c.wasRemoved() &amp;&amp;
                            c.getRemovedSize() == 1 &amp;&amp;
                            ! c.wasAdded() &amp;&amp;
                            selectedItem != null &amp;&amp;
                            selectedItem.equals(c.getRemoved().get(0))) {
                        // Bug fix for RT-28637
                        if (getSelectedIndex() &lt; getItemCount()) {
                            final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
                            T newSelectedItem = getModelItem(previousRow);
                            if (! selectedItem.equals(newSelectedItem)) {
                                startAtomic();
                                clearSelection(selectedIndex);
                                stopAtomic();
                                select(newSelectedItem);
                            }
                        }
                    }
                }

                if (doSelectionUpdate) {
                    updateSelection(c);
                }
            }
        };

        // watching for changes to the items list
        private final InvalidationListener itemsObserver;

        private WeakListChangeListener&lt;T&gt; weakItemsContentObserver =
                new WeakListChangeListener&lt;&gt;(itemsContentObserver);




        /***********************************************************************
         *                                                                     *
         * Internal properties                                                 *
         *                                                                     *
         **********************************************************************/

        private final ListView&lt;T&gt; listView;

        private int itemCount = 0;

        private int previousModelSize = 0;

        // Listen to changes in the listview items list, such that when it
        // changes we can update the selected indices bitset to refer to the
        // new indices.
        // At present this is basically a left/right shift operation, which
        // seems to work ok.
        private void updateSelection(Change&lt;? extends T&gt; c) {
//            // debugging output
//            System.out.println(listView.getId());
//            if (c.wasAdded()) {
//                System.out.println(&quot;\tAdded size: &quot; + c.getAddedSize() + &quot;, Added sublist: &quot; + c.getAddedSubList());
//            }
//            if (c.wasRemoved()) {
//                System.out.println(&quot;\tRemoved size: &quot; + c.getRemovedSize() + &quot;, Removed sublist: &quot; + c.getRemoved());
//            }
//            if (c.wasReplaced()) {
//                System.out.println(&quot;\tWas replaced&quot;);
//            }
//            if (c.wasPermutated()) {
//                System.out.println(&quot;\tWas permutated&quot;);
//            }
            c.reset();

            List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts = new ArrayList&lt;&gt;();
            while (c.next()) {
                if (c.wasReplaced()) {
                    if (c.getList().isEmpty()) {
                        // the entire items list was emptied - clear selection
                        clearSelection();
                    } else {
                        int index = getSelectedIndex();

                        if (previousModelSize == c.getRemovedSize()) {
                            // all items were removed from the model
                            clearSelection();
                        } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
                            // Fix for RT-18969: the list had setAll called on it
                            // Use of makeAtomic is a fix for RT-20945
                            startAtomic();
                            clearSelection(index);
                            stopAtomic();
                            select(index);
                        } else {
                            // Fix for RT-22079
                            clearSelection();
                        }
                    }
                } else if (c.wasAdded() || c.wasRemoved()) {
                    int shift = c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
                    shifts.add(new Pair&lt;&gt;(c.getFrom(), shift));
                } else if (c.wasPermutated()) {

                    // General approach:
                    //   -- detected a sort has happened
                    //   -- Create a permutation lookup map (1)
                    //   -- dump all the selected indices into a list (2)
                    //   -- clear the selected items / indexes (3)
                    //   -- create a list containing the new indices (4)
                    //   -- for each previously-selected index (5)
                    //     -- if index is in the permutation lookup map
                    //       -- add the new index to the new indices list
                    //   -- Perform batch selection (6)

                    // (1)
                    int length = c.getTo() - c.getFrom();
                    HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;Integer, Integer&gt;(length);
                    for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                        pMap.put(i, c.getPermutation(i));
                    }

                    // (2)
                    List&lt;Integer&gt; selectedIndices = new ArrayList&lt;Integer&gt;(getSelectedIndices());


                    // (3)
                    clearSelection();

                    // (4)
                    List&lt;Integer&gt; newIndices = new ArrayList&lt;Integer&gt;(getSelectedIndices().size());

                    // (5)
                    for (int i = 0; i &lt; selectedIndices.size(); i++) {
                        int oldIndex = selectedIndices.get(i);

                        if (pMap.containsKey(oldIndex)) {
                            Integer newIndex = pMap.get(oldIndex);
                            newIndices.add(newIndex);
                        }
                    }
<A NAME="20"></A>
                    // (6)
                    if (!newIndices.isEmpty()) {
                        <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#20',2,'match34-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (newIndices.size() == 1) {
                            select(newIndices.get(0));
                        } else {
                            int[] ints = new int[newIndices.size() - 1]</B></FONT>;
                            for (int i = 0; i &lt; newIndices.size() - 1; i++) {
                                ints[i] = newIndices.get(i + 1);
                            }
                            selectIndices(newIndices.get(0), ints);
                        }
                    }
                }
            }

            if (!shifts.isEmpty()) {
                shiftSelection(shifts, null);
            }

            previousModelSize = getItemCount();
        }



        /***********************************************************************
         *                                                                     *
         * Public selection API                                                *
         *                                                                     *
         **********************************************************************/

        /** {@inheritDoc} */
        @Override public void selectAll() {
            // when a selectAll happens, the anchor should not change, so we store it
            // before, and restore it afterwards
            final int anchor = ListCellBehavior.getAnchor(listView, -1);
            super.selectAll();
            ListCellBehavior.setAnchor(listView, anchor, false);
        }

        /** {@inheritDoc} */
        @Override public void clearAndSelect(int row) {
            ListCellBehavior.setAnchor(listView, row, false);
            super.clearAndSelect(row);
        }

        /** {@inheritDoc} */
        @Override protected void focus(int row) {
            if (listView.getFocusModel() == null) return;
            listView.getFocusModel().focus(row);

            listView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        /** {@inheritDoc} */
        @Override protected int getFocusedIndex() {
            if (listView.getFocusModel() == null) return -1;
            return listView.getFocusModel().getFocusedIndex();
        }

        @Override protected int getItemCount() {
            return itemCount;
        }

        @Override protected T getModelItem(int index) {
            List&lt;T&gt; items = listView.getItems();
            if (items == null) return null;
            if (index &lt; 0 || index &gt;= itemCount) return null;

            return items.get(index);
        }



        /***********************************************************************
         *                                                                     *
         * Private implementation                                              *
         *                                                                     *
         **********************************************************************/

        private void updateItemCount() {
            if (listView == null) {
                itemCount = -1;
            } else {
                List&lt;T&gt; items = listView.getItems();
                itemCount = items == null ? -1 : items.size();
            }
        }

        private void updateItemsObserver(ObservableList&lt;T&gt; oldList, ObservableList&lt;T&gt; newList) {
            // update listeners
            if (oldList != null) {
                oldList.removeListener(weakItemsContentObserver);
            }
            if (newList != null) {
                newList.addListener(weakItemsContentObserver);
            }

            updateItemCount();
            updateDefaultSelection();
        }

        private void updateDefaultSelection() {
            // when the items list totally changes, we should clear out
            // the selection and focus
            int newSelectionIndex = -1;
            int newFocusIndex = -1;
            if (listView.getItems() != null) {
                T selectedItem = getSelectedItem();
                if (selectedItem != null) {
                    newSelectionIndex = listView.getItems().indexOf(selectedItem);
                    newFocusIndex = newSelectionIndex;
                }

                // we put focus onto the first item, if there is at least
                // one item in the list
                if (listView.selectFirstRowByDefault &amp;&amp; newFocusIndex == -1) {
                    newFocusIndex = listView.getItems().size() &gt; 0 ? 0 : -1;
                }
            }

            clearSelection();
            select(newSelectionIndex);
//            focus(newFocusIndex);
        }
    }



    // package for testing
    static class ListViewFocusModel&lt;T&gt; extends FocusModel&lt;T&gt; {

        private final ListView&lt;T&gt; listView;
        private int itemCount = 0;

        public ListViewFocusModel(final ListView&lt;T&gt; listView) {
            if (listView == null) {
                throw new IllegalArgumentException(&quot;ListView can not be null&quot;);
            }

            this.listView = listView;

            itemsObserver = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
                    updateItemsObserver(oldItems, listView.getItems());
                }
            };
            this.listView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
            if (listView.getItems() != null) {
                this.listView.getItems().addListener(weakItemsContentListener);
            }

            updateItemCount();
            updateDefaultFocus();

            focusedIndexProperty().addListener(o -&gt; {
                listView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
            });
        }


        private void updateItemsObserver(ObservableList&lt;T&gt; oldList, ObservableList&lt;T&gt; newList) {
            // the listview items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) oldList.removeListener(weakItemsContentListener);
            if (newList != null) newList.addListener(weakItemsContentListener);

            updateItemCount();
            updateDefaultFocus();
        }

        private final InvalidationListener itemsObserver;

        // Listen to changes in the listview items list, such that when it
        // changes we can update the focused index to refer to the new indices.
        private final ListChangeListener&lt;T&gt; itemsContentListener = c -&gt; {
            updateItemCount();

            while (c.next()) {
                // looking at the first change
                int from = c.getFrom();

                if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                    updateDefaultFocus();
                    return;
                }

                if (getFocusedIndex() == -1 || from &gt; getFocusedIndex()) {
                    return;
                }

                c.reset();
                boolean added = false;
                boolean removed = false;
                int addedSize = 0;
                int removedSize = 0;
                while (c.next()) {
                    added |= c.wasAdded();
                    removed |= c.wasRemoved();
                    addedSize += c.getAddedSize();
                    removedSize += c.getRemovedSize();
                }

                if (added &amp;&amp; !removed) {
                    focus(Math.min(getItemCount() - 1, getFocusedIndex() + addedSize));
                } else if (!added &amp;&amp; removed) {
                    focus(Math.max(0, getFocusedIndex() - removedSize));
                }
            }
        };

        private WeakListChangeListener&lt;T&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;T&gt;(itemsContentListener);

        @Override protected int getItemCount() {
            return itemCount;
        }

        @Override protected T getModelItem(int index) {
            if (isEmpty()) return null;
            if (index &lt; 0 || index &gt;= itemCount) return null;

            return listView.getItems().get(index);
        }

        private boolean isEmpty() {
            return itemCount == -1;
        }

        private void updateItemCount() {
            if (listView == null) {
                itemCount = -1;
            } else {
                List&lt;T&gt; items = listView.getItems();
                itemCount = items == null ? -1 : items.size();
            }
        }

        private void updateDefaultFocus() {
            // when the items list totally changes, we should clear out
            // the focus
            int newValueIndex = -1;
            if (listView.getItems() != null) {
                T focusedItem = getFocusedItem();
                if (focusedItem != null) {
                    newValueIndex = listView.getItems().indexOf(focusedItem);
                }

                // we put focus onto the first item, if there is at least
                // one item in the list
                if (newValueIndex == -1) {
                    newValueIndex = listView.getItems().size() &gt; 0 ? 0 : -1;
                }
            }

            focus(newValueIndex);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Slider.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WritableValue;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.util.StringConverter;

import com.sun.javafx.util.Utils;

import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableIntegerProperty;
import javafx.css.StyleableObjectProperty;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import javafx.scene.control.skin.SliderSkin;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * The Slider Control is used to display a continuous or discrete range of
 * valid numeric choices and allows the user to interact with the control. It is
 * typically represented visually as having a &quot;track&quot; and a &quot;knob&quot; or &quot;thumb&quot;
 * which is dragged within the track. The Slider can optionally show tick marks
 * and labels indicating the different slider position values.
 * &lt;p&gt;
 * The three fundamental variables of the slider are &lt;code&gt;min&lt;/code&gt;,
 * &lt;code&gt;max&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt;. The &lt;code&gt;value&lt;/code&gt; should always
 * be a number within the range defined by &lt;code&gt;min&lt;/code&gt; and
 * &lt;code&gt;max&lt;/code&gt;. &lt;code&gt;min&lt;/code&gt; should always be less than or equal to
 * &lt;code&gt;max&lt;/code&gt; (although a slider whose &lt;code&gt;min&lt;/code&gt; and
 * &lt;code&gt;max&lt;/code&gt; are equal is a degenerate case that makes no sense).
 * &lt;code&gt;min&lt;/code&gt; defaults to 0, whereas &lt;code&gt;max&lt;/code&gt; defaults to 100.
 * &lt;p&gt;
 * This first example creates a slider whose range, or span, goes from 0 to 1,
 * and whose value defaults to .5:
 *
 * &lt;pre&gt;
 * import javafx.scene.control.Slider;
 *
 * Slider slider = new Slider(0, 1, 0.5);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * This next example shows a slider with customized tick marks and tick mark
 * labels, which also spans from 0 to 1:
 *
 * &lt;pre&gt;
 * import javafx.scene.control.Slider;
 *
 * Slider slider = new Slider(0, 1, 0.5);
 * slider.setShowTickMarks(true);
 * slider.setShowTickLabels(true);
 * slider.setMajorTickUnit(0.25f);
 * slider.setBlockIncrement(0.1f);
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Slider extends Control {

    /**
     * Creates a default Slider instance.
     */
    public Slider() {
        initialize();
    }

    /**
     * Constructs a Slider control with the specified slider min, max and current value values.
     * @param min Slider minimum value
     * @param max Slider maximum value
     * @param value Slider current value
     */
    public Slider(double min, double max, double value) {
        setMax(max);
        setMin(min);
        setValue(value);
        adjustValues();
        initialize();
    }

    private void initialize() {
        //Initialize the style class to be 'slider'.
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.SLIDER);
    }
    /**
     * The maximum value represented by this Slider. This must be a
     * value greater than {@link #minProperty() min}.
     */
    private DoubleProperty max;
    public final void setMax(double value) {
        maxProperty().set(value);
    }

    public final double getMax() {
        return max == null ? 100 : max.get();
    }

    public final DoubleProperty maxProperty() {
        if (max == null) {
            max = new DoublePropertyBase(100) {
                @Override protected void invalidated() {
                    if (get() &lt; getMin()) {
                        setMin(get());
                    }
                    adjustValues();
                    notifyAccessibleAttributeChanged(AccessibleAttribute.MAX_VALUE);
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;max&quot;;
                }
            };
        }
        return max;
    }
    /**
     * The minimum value represented by this Slider. This must be a
     * value less than {@link #maxProperty() max}.
     */
    private DoubleProperty min;
    public final void setMin(double value) {
        minProperty().set(value);
    }

    public final double getMin() {
        return min == null ? 0 : min.get();
    }

    public final DoubleProperty minProperty() {
        if (min == null) {
            min = new DoublePropertyBase(0) {
                @Override protected void invalidated() {
                    if (get() &gt; getMax()) {
                        setMax(get());
                    }
                    adjustValues();
                    notifyAccessibleAttributeChanged(AccessibleAttribute.MIN_VALUE);
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;min&quot;;
                }
            };
        }
        return min;
    }
    /**
     * The current value represented by this Slider. This value must
     * always be between {@link #minProperty() min} and {@link #maxProperty() max},
     * inclusive. If it is ever out of bounds either due to {@code min} or
     * {@code max} changing or due to itself being changed, then it will
     * be clamped to always remain valid.
     */
    private DoubleProperty value;
    public final void setValue(double value) {
        if (!valueProperty().isBound()) valueProperty().set(value);
    }

    public final double getValue() {
        return value == null ? 0 : value.get();
    }

    public final DoubleProperty valueProperty() {
        if (value == null) {
            value = new DoublePropertyBase(0) {
                @Override protected void invalidated() {
                    adjustValues();
                    notifyAccessibleAttributeChanged(AccessibleAttribute.VALUE);
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;value&quot;;
                }
            };
        }
        return value;
    }
    /**
     * When true, indicates the current value of this Slider is changing.
     * It provides notification that the value is changing. Once the value is
     * computed, it is reset back to false.
     */
    private BooleanProperty valueChanging;

    public final void setValueChanging(boolean value) {
        valueChangingProperty().set(value);
    }

    public final boolean isValueChanging() {
        return valueChanging == null ? false : valueChanging.get();
    }

    public final BooleanProperty valueChangingProperty() {
        if (valueChanging == null) {
            valueChanging = new SimpleBooleanProperty(this, &quot;valueChanging&quot;, false);
        }
        return valueChanging;
    }
//    /**
//     * The {@code span} is the distance, or quantity, between min and max value.
//     * This will be strictly non-negative, since both {@code min} and
//     * {@code max} are forced to maintain a proper relationship.
//     */
//    //    public def span = bind max - min;

    /**
     * The orientation of the {@code Slider} can either be horizontal
     * or vertical.
     */
    private ObjectProperty&lt;Orientation&gt; orientation;
    public final void setOrientation(Orientation value) {
        orientationProperty().set(value);
    }

    public final Orientation getOrientation() {
        return orientation == null ? Orientation.HORIZONTAL : orientation.get();
    }

    public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
        if (orientation == null) {
            orientation = new StyleableObjectProperty&lt;Orientation&gt;(Orientation.HORIZONTAL) {
                @Override protected void invalidated() {
                    final boolean vertical = (get() == Orientation.VERTICAL);
                    pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE,    vertical);
                    pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, !vertical);
                }

                @Override
                public CssMetaData&lt;Slider,Orientation&gt; getCssMetaData() {
                    return StyleableProperties.ORIENTATION;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;orientation&quot;;
                }
            };
        }
        return orientation;
    }


    /**
     * Indicates that the labels for tick marks should be shown. Typically a
     * {@link Skin} implementation will only show labels if
     * {@link #showTickMarksProperty() showTickMarks} is also true.
     */
    private BooleanProperty showTickLabels;
    public final void setShowTickLabels(boolean value) {
        showTickLabelsProperty().set(value);
    }

    public final boolean isShowTickLabels() {
        return showTickLabels == null ? false : showTickLabels.get();
    }

    public final BooleanProperty showTickLabelsProperty() {
        if (showTickLabels == null) {
            showTickLabels = new StyleableBooleanProperty(false) {


                @Override
                public CssMetaData&lt;Slider,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.SHOW_TICK_LABELS;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;showTickLabels&quot;;
                }
            };
        }
        return showTickLabels;
    }
    /**
     * Specifies whether the {@link Skin} implementation should show tick marks.
     */
    private BooleanProperty showTickMarks;
    public final void setShowTickMarks(boolean value) {
        showTickMarksProperty().set(value);
    }

    public final boolean isShowTickMarks() {
        return showTickMarks == null ? false : showTickMarks.get();
    }

    public final BooleanProperty showTickMarksProperty() {
        if (showTickMarks == null) {
            showTickMarks = new StyleableBooleanProperty(false) {


                @Override
                public CssMetaData&lt;Slider,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.SHOW_TICK_MARKS;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;showTickMarks&quot;;
                }
            };
        }
        return showTickMarks;
    }
    /**
     * The unit distance between major tick marks. For example, if
     * the {@link #minProperty() min} is 0 and the {@link #maxProperty() max} is 100 and the
     * {@link #majorTickUnitProperty() majorTickUnit} is 25, then there would be 5 tick marks: one at
     * position 0, one at position 25, one at position 50, one at position
     * 75, and a final one at position 100.
     * &lt;p&gt;
     * This value should be positive and should be a value less than the
     * span. Out of range values are essentially the same as disabling
     * tick marks.
     */
    private DoubleProperty majorTickUnit;
    public final void setMajorTickUnit(double value) {
        if (value &lt;= 0) {
            throw new IllegalArgumentException(&quot;MajorTickUnit cannot be less than or equal to 0.&quot;);
        }
        majorTickUnitProperty().set(value);
    }

    public final double getMajorTickUnit() {
        return majorTickUnit == null ? 25 : majorTickUnit.get();
    }

    public final DoubleProperty majorTickUnitProperty() {
        if (majorTickUnit == null) {
            majorTickUnit = new StyleableDoubleProperty(25) {
                @Override
                public void invalidated() {
                    if (get() &lt;= 0) {
                        throw new IllegalArgumentException(&quot;MajorTickUnit cannot be less than or equal to 0.&quot;);
                    }
                }

                @Override
                public CssMetaData&lt;Slider,Number&gt; getCssMetaData() {
                    return StyleableProperties.MAJOR_TICK_UNIT;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;majorTickUnit&quot;;
                }
            };
        }
        return majorTickUnit;
    }
    /**
     * The number of minor ticks to place between any two major ticks. This
     * number should be positive or zero. Out of range values will disable
     * disable minor ticks, as will a value of zero.
     */
    private IntegerProperty minorTickCount;
    public final void setMinorTickCount(int value) {
        minorTickCountProperty().set(value);
    }

    public final int getMinorTickCount() {
        return minorTickCount == null ? 3 : minorTickCount.get();
    }

    public final IntegerProperty minorTickCountProperty() {
        if (minorTickCount == null) {
            minorTickCount = new StyleableIntegerProperty(3) {


                @Override
                public CssMetaData&lt;Slider,Number&gt; getCssMetaData() {
                    return StyleableProperties.MINOR_TICK_COUNT;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;minorTickCount&quot;;
                }
            };
        }
        return minorTickCount;
    }
    /**
     * Indicates whether the {@link #valueProperty() value} of the {@code Slider} should always
     * be aligned with the tick marks. This is honored even if the tick marks
     * are not shown.
     */
    private BooleanProperty snapToTicks;
    public final void setSnapToTicks(boolean value) {
        snapToTicksProperty().set(value);
    }

    public final boolean isSnapToTicks() {
        return snapToTicks == null ? false : snapToTicks.get();
    }

    public final BooleanProperty snapToTicksProperty() {
        if (snapToTicks == null) {
            snapToTicks = new StyleableBooleanProperty(false) {

                @Override
                public CssMetaData&lt;Slider,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.SNAP_TO_TICKS;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;snapToTicks&quot;;
                }
            };
        }
        return snapToTicks;
    }
    /**
     * A function for formatting the label for a major tick. The number
     * representing the major tick will be passed to the function. If this
     * function is not specified, then a default function will be used by
     * the {@link Skin} implementation.
     */
    private ObjectProperty&lt;StringConverter&lt;Double&gt;&gt; labelFormatter;

    public final void setLabelFormatter(StringConverter&lt;Double&gt; value) {
        labelFormatterProperty().set(value);
    }

    public final StringConverter&lt;Double&gt; getLabelFormatter() {
        return labelFormatter == null ? null : labelFormatter.get();
    }

    public final ObjectProperty&lt;StringConverter&lt;Double&gt;&gt; labelFormatterProperty() {
        if (labelFormatter == null) {
            labelFormatter = new SimpleObjectProperty&lt;StringConverter&lt;Double&gt;&gt;(this, &quot;labelFormatter&quot;);
        }
        return labelFormatter;
    }
    /**
     * The amount by which to adjust the slider if the track of the slider is
     * clicked. This is used when manipulating the slider position using keys. If
     * {@link #snapToTicksProperty() snapToTicks} is true then the nearest tick mark to the adjusted
     * value will be used.
     */
    private DoubleProperty blockIncrement;
    public final void setBlockIncrement(double value) {
        blockIncrementProperty().set(value);
    }

    public final double getBlockIncrement() {
        return blockIncrement == null ? 10 : blockIncrement.get();
    }

    public final DoubleProperty blockIncrementProperty() {
        if (blockIncrement == null) {
            blockIncrement = new StyleableDoubleProperty(10) {

                @Override
                public CssMetaData&lt;Slider,Number&gt; getCssMetaData() {
                    return StyleableProperties.BLOCK_INCREMENT;
                }

                @Override
                public Object getBean() {
                    return Slider.this;
                }

                @Override
                public String getName() {
                    return &quot;blockIncrement&quot;;
                }
            };
        }
        return blockIncrement;
    }

    /**
     * Adjusts {@link #valueProperty() value} to match &lt;code&gt;newValue&lt;/code&gt;. The
     * &lt;code&gt;value&lt;/code&gt;is the actual amount between the
     * {@link #minProperty() min} and {@link #maxProperty() max}. This function
     * also takes into account {@link #snapToTicksProperty() snapToTicks}, which
     * is the main difference between adjustValue and setValue. It also ensures
     * that the value is some valid number between min and max.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     * @param newValue the new adjusted value
     */
    public void adjustValue(double newValue) {
        // figure out the &quot;value&quot; associated with the specified position
        final double _min = getMin();
        final double _max = getMax();
        if (_max &lt;= _min) return;
<A NAME="34"></A>        newValue = newValue &lt; _min ? _min : newValue;
        newValue = newValue &gt; _max ? _max : newValue;

        setValue(<FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#34',2,'match34-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>snapValueToTicks(newValue));
    }

    /**
     * Increments the value by {@link #blockIncrementProperty() blockIncrement}, bounded by max. If the
     * max is less than or equal to the min, then this method does nothing.
     */
    public void increment() {
        adjustValue(getValue() + getBlockIncrement());
    }

    /**
     * Decrements the value by {@link #blockIncrementProperty() blockIncrement}, bounded by max. If the
     * max is less than or equal to the min, then this method does nothing.
     */
    public void decrement() {
        adjustValue(getValue() - getBlockIncrement());
    }

    /**
     * Ensures that min is always &lt; max, that value is always
     * somewhere between the two, and that if snapToTicks is set then the
     * value will always be set to align with a tick mark.
     */
    private void adjustValues() {</B></FONT>
        if ((getValue() &lt; getMin() || getValue() &gt; getMax()) /* &amp;&amp;  !isReadOnly(value)*/)
             setValue(Utils.clamp(getMin(), getValue(), getMax()));
    }

     /**
     * Utility function which, given the specified value, will position it
     * either aligned with a tick, or simply clamp between min &amp; max value,
     * depending on whether snapToTicks is set.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    private double snapValueToTicks(double val) {
        double v = val;
        if (isSnapToTicks()) {
            double tickSpacing = 0;
            // compute the nearest tick to this value
            if (getMinorTickCount() != 0) {
                tickSpacing = getMajorTickUnit() / (Math.max(getMinorTickCount(),0)+1);
            } else {
                tickSpacing = getMajorTickUnit();
            }
            int prevTick = (int)((v - getMin())/ tickSpacing);
            double prevTickValue = (prevTick) * tickSpacing + getMin();
            double nextTickValue = (prevTick + 1) * tickSpacing + getMin();
            v = Utils.nearest(prevTickValue, v, nextTickValue);
        }
        return Utils.clamp(getMin(), v, getMax());
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new SliderSkin(this);
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;slider&quot;;

    private static class StyleableProperties {
        private static final CssMetaData&lt;Slider,Number&gt; BLOCK_INCREMENT =
            new CssMetaData&lt;Slider,Number&gt;(&quot;-fx-block-increment&quot;,
                SizeConverter.getInstance(), 10.0) {

            @Override
            public boolean isSettable(Slider n) {
                return n.blockIncrement == null || !n.blockIncrement.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.blockIncrementProperty();
            }
        };

        private static final CssMetaData&lt;Slider,Boolean&gt; SHOW_TICK_LABELS =
            new CssMetaData&lt;Slider,Boolean&gt;(&quot;-fx-show-tick-labels&quot;,
                BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Slider n) {
                return n.showTickLabels == null || !n.showTickLabels.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.showTickLabelsProperty();
            }
        };

        private static final CssMetaData&lt;Slider,Boolean&gt; SHOW_TICK_MARKS =
            new CssMetaData&lt;Slider,Boolean&gt;(&quot;-fx-show-tick-marks&quot;,
                BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Slider n) {
                return n.showTickMarks == null || !n.showTickMarks.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.showTickMarksProperty();
            }
        };

        private static final CssMetaData&lt;Slider,Boolean&gt; SNAP_TO_TICKS =
            new CssMetaData&lt;Slider,Boolean&gt;(&quot;-fx-snap-to-ticks&quot;,
                BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Slider n) {
                return n.snapToTicks == null || !n.snapToTicks.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.snapToTicksProperty();
            }
        };

        private static final CssMetaData&lt;Slider,Number&gt; MAJOR_TICK_UNIT =
            new CssMetaData&lt;Slider,Number&gt;(&quot;-fx-major-tick-unit&quot;,
                SizeConverter.getInstance(), 25.0) {

            @Override
            public boolean isSettable(Slider n) {
                return n.majorTickUnit == null || !n.majorTickUnit.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.majorTickUnitProperty();
            }
        };

        private static final CssMetaData&lt;Slider,Number&gt; MINOR_TICK_COUNT =
            new CssMetaData&lt;Slider,Number&gt;(&quot;-fx-minor-tick-count&quot;,
                SizeConverter.getInstance(), 3.0) {

            @Override
            public boolean isSettable(Slider n) {
                return n.minorTickCount == null || !n.minorTickCount.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.minorTickCountProperty();
            }
        };

        private static final CssMetaData&lt;Slider,Orientation&gt; ORIENTATION =
            new CssMetaData&lt;Slider,Orientation&gt;(&quot;-fx-orientation&quot;,
                new EnumConverter&lt;Orientation&gt;(Orientation.class),
                Orientation.HORIZONTAL) {

            @Override
            public Orientation getInitialValue(Slider node) {
                // A vertical Slider should remain vertical
                return node.getOrientation();
            }

            @Override
            public boolean isSettable(Slider n) {
                return n.orientation == null || !n.orientation.isBound();
            }

            @Override
            public StyleableProperty&lt;Orientation&gt; getStyleableProperty(Slider n) {
                return (StyleableProperty&lt;Orientation&gt;)(WritableValue&lt;Orientation&gt;)n.orientationProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(BLOCK_INCREMENT);
            styleables.add(SHOW_TICK_LABELS);
            styleables.add(SHOW_TICK_MARKS);
            styleables.add(SNAP_TO_TICKS);
            styleables.add(MAJOR_TICK_UNIT);
            styleables.add(MINOR_TICK_COUNT);
            styleables.add(ORIENTATION);

            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override protected List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    private static final PseudoClass VERTICAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;vertical&quot;);
    private static final PseudoClass HORIZONTAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;horizontal&quot;);



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case VALUE: return getValue();
            case MAX_VALUE: return getMax();
            case MIN_VALUE: return getMin();
            case ORIENTATION: return getOrientation();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case INCREMENT: increment(); break;
            case DECREMENT: decrement(); break;
            case SET_VALUE: {
                Double value = (Double) parameters[0];
                if (value != null) setValue(value);
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ContextMenuSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.ContextMenuContent;
import com.sun.javafx.scene.control.EmbeddedTextContextMenuContent;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Menu;
import javafx.scene.control.Skin;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Region;
import javafx.stage.WindowEvent;
import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;

/**
 * Default Skin implementation for ContextMenu. Several controls use ContextMenu in
 * order to display items in a drop down. This class mostly deals mostly with
 * show / hide logic - the actual content of the context menu is contained within
 * the {@link #getNode() root node}.
 *
 * @since 9
 * @see ContextMenu
 */
public class ContextMenuSkin implements Skin&lt;ContextMenu&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    /* need to hold a reference to popupMenu here because getSkinnable() deliberately
     * returns null in PopupControlSkin. */
    private ContextMenu popupMenu;

    private final Region root;
    private TwoLevelFocusPopupBehavior tlFocus;

    // used to handle the situation where CSS is applied to the popup
    // after it is displayed, and we need to modify the position of the
    // popup to account for this.
    private double prefHeight;
    private double shiftY;
    private double prefWidth;
    private double shiftX;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    // Fix for RT-18247
    private final EventHandler&lt;KeyEvent&gt; keyListener = new EventHandler&lt;KeyEvent&gt;() {
        @Override public void handle(KeyEvent event) {
            if (event.getEventType() != KeyEvent.KEY_PRESSED) return;

            // We only care if the root container still has focus
            if (! root.isFocused()) return;

            final KeyCode code = event.getCode();
            switch (code) {
                case ENTER:
                case SPACE: popupMenu.hide(); return;
                default:    return;
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ContextMenuSkin instance.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ContextMenuSkin(final ContextMenu control) {
        this.popupMenu = control;

        popupMenu.addEventHandler(Menu.ON_SHOWING, new EventHandler&lt;Event&gt;() {
            @Override public void handle(Event event) {
                prefHeight = root.prefHeight(-1);
                prefWidth = root.prefWidth(-1);
            }
        });

        // When a contextMenu is shown, requestFocus on its content to enable
        // keyboard navigation.
        popupMenu.addEventHandler(Menu.ON_SHOWN, new EventHandler&lt;Event&gt;() {
            @Override public void handle(Event event) {
                Node cmContent = popupMenu.getSkin().getNode();
                if (cmContent != null) {
//                    cmContent.requestFocus();
                    if (cmContent instanceof ContextMenuContent) {
                        Node accMenu = ((ContextMenuContent)cmContent).getItemsContainer();
                        accMenu.notifyAccessibleAttributeChanged(AccessibleAttribute.VISIBLE);
                    }
                }

                root.addEventHandler(KeyEvent.KEY_PRESSED, keyListener);

                performPopupShifts();
            }
        });
        popupMenu.addEventHandler(Menu.ON_HIDDEN, new EventHandler&lt;Event&gt;() {
            @Override public void handle(Event event) {
                Node cmContent = popupMenu.getSkin().getNode();
                if (cmContent != null) cmContent.requestFocus();

                root.removeEventHandler(KeyEvent.KEY_PRESSED, keyListener);
            }
        });

        // For accessibility Menu.ON_HIDING does not work because isShowing is true
        // during the event, Menu.ON_HIDDEN does not work because the Window (in glass)
        // has already being disposed. The fix is to use WINDOW_HIDING (WINDOW_HIDDEN).
        popupMenu.addEventFilter(WindowEvent.WINDOW_HIDING, new EventHandler&lt;Event&gt;() {
            @Override public void handle(Event event) {
                Node cmContent = popupMenu.getSkin().getNode();
                if (cmContent instanceof ContextMenuContent) {
                    Node accMenu = ((ContextMenuContent)cmContent).getItemsContainer();
                    accMenu.notifyAccessibleAttributeChanged(AccessibleAttribute.VISIBLE);
                }
            }
        });

        if (Properties.IS_TOUCH_SUPPORTED &amp;&amp;
            popupMenu.getStyleClass().contains(&quot;text-input-context-menu&quot;)) {
            root = new EmbeddedTextContextMenuContent(popupMenu);
        } else {
            root = new ContextMenuContent(popupMenu);
        }
        root.idProperty().bind(popupMenu.idProperty());
        root.styleProperty().bind(popupMenu.styleProperty());
        root.getStyleClass().addAll(popupMenu.getStyleClass()); // TODO needs to handle updates

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusPopupBehavior(popupMenu); // needs to be last.
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public ContextMenu getSkinnable() {
        return popupMenu;
    }

    /** {@inheritDoc} */
    @Override public Node getNode() {
        return root;
<A NAME="28"></A>    }

    /** {@inheritDoc} */
    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#28',2,'match34-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override public void dispose() {
        root.idProperty().unbind();
        root.styleProperty().unbind();
        if (tlFocus != null) tlFocus.dispose</B></FONT>();
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void performPopupShifts() {
        final ContextMenu contextMenu = getSkinnable();
        final Node ownerNode = contextMenu.getOwnerNode();
        if (ownerNode == null) return;

        final Bounds ownerBounds = ownerNode.localToScreen(ownerNode.getLayoutBounds());
        if (ownerBounds == null) return;

        // shifting vertically
        final double rootPrefHeight = root.prefHeight(-1);
        shiftY = prefHeight - rootPrefHeight;
        if (shiftY &gt; 0 &amp;&amp; (contextMenu.getY() + rootPrefHeight) &lt; ownerBounds.getMinY()) {
            contextMenu.setY(contextMenu.getY() + shiftY);
        }

        // shifting horizontally
        final double rootPrefWidth = root.prefWidth(-1);
        shiftX = prefWidth - rootPrefWidth;
        if (shiftX &gt; 0 &amp;&amp; (contextMenu.getX() + rootPrefWidth) &lt; ownerBounds.getMinX()) {
            contextMenu.setX(contextMenu.getX() + shiftX);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
<A NAME="6"></A>        // In future we could add FADE, ...
    }

    <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#6',2,'match34-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions</B></FONT>;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableColumnHeader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TableColumnBaseHelper;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.value.WritableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumnBase;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import javafx.css.converter.SizeConverter;

import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;


/**
 * Region responsible for painting a single column header. A subcomponent used by
 * subclasses of {@link TableViewSkinBase}.
 *
 * @since 9
 */
public class TableColumnHeader extends Region {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/

    static final String DEFAULT_STYLE_CLASS = &quot;column-header&quot;;

    // Copied from TableColumn. The value here should always be in-sync with
    // the value in TableColumn
    static final double DEFAULT_COLUMN_WIDTH = 80.0F;



    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    private boolean autoSizeComplete = false;

    private double dragOffset;
    private NestedTableColumnHeader nestedColumnHeader;
    private TableHeaderRow tableHeaderRow;
    private NestedTableColumnHeader parentHeader;

    // work out where this column currently is within its parent
    Label label;

    // sort order
    int sortPos = -1;
    private Region arrow;
    private Label sortOrderLabel;
    private HBox sortOrderDots;
    private Node sortArrow;
    private boolean isSortColumn;

    private boolean isSizeDirty = false;

    boolean isLastVisibleColumn = false;

    // package for testing
    int columnIndex = -1;

    private int newColumnPos;

    // the line drawn in the table when a user presses and moves a column header
    // to indicate where the column will be dropped. This is provided by the
    // table skin, but manipulated by the header
    Region columnReorderLine;



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TableColumnHeader instance to visually represent the given
     * {@link TableColumnBase} instance.
     *
     * @param tc The table column to be visually represented by this instance.
     */
    public TableColumnHeader(final TableColumnBase tc) {
        setTableColumn(tc);
        setFocusTraversable(false);

        initStyleClasses();
        initUI();

        // change listener for multiple properties
        changeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();
        changeListenerHandler.registerChangeListener(sceneProperty(), e -&gt; updateScene());

        if (getTableColumn() != null) {
            changeListenerHandler.registerChangeListener(tc.idProperty(), e -&gt; setId(tc.getId()));
            changeListenerHandler.registerChangeListener(tc.styleProperty(), e -&gt; setStyle(tc.getStyle()));
            changeListenerHandler.registerChangeListener(tc.widthProperty(), e -&gt; {
                // It is this that ensures that when a column is resized that the header
                // visually adjusts its width as necessary.
                isSizeDirty = true;
                requestLayout();
            });
            changeListenerHandler.registerChangeListener(tc.visibleProperty(), e -&gt; setVisible(getTableColumn().isVisible()));
            changeListenerHandler.registerChangeListener(tc.sortNodeProperty(), e -&gt; updateSortGrid());
            changeListenerHandler.registerChangeListener(tc.sortableProperty(), e -&gt; {
                // we need to notify all headers that a sortable state has changed,
                // in case the sort grid in other columns needs to be updated.
                if (TableSkinUtils.getSortOrder(getTableSkin()).contains(getTableColumn())) {
                    NestedTableColumnHeader root = getTableHeaderRow().getRootHeader();
                    updateAllHeaders(root);
                }
            });
            changeListenerHandler.registerChangeListener(tc.textProperty(), e -&gt; label.setText(tc.getText()));
            changeListenerHandler.registerChangeListener(tc.graphicProperty(), e -&gt; label.setGraphic(tc.getGraphic()));

            setId(tc.getId());
            setStyle(tc.getStyle());
            /* Having TableColumn role parented by TableColumn causes VoiceOver to be unhappy */
            setAccessibleRole(AccessibleRole.TABLE_COLUMN);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    final LambdaMultiplePropertyChangeListenerHandler changeListenerHandler;

    private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderListener = c -&gt; {
        updateSortPosition();
    };

    private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
        updateColumnIndex();
        updateSortPosition();
    };

    private ListChangeListener&lt;String&gt; styleClassListener = c -&gt; {
        while (c.next()) {
            if (c.wasRemoved()) {
                getStyleClass().removeAll(c.getRemoved());
            }
            if (c.wasAdded()) {
                getStyleClass().addAll(c.getAddedSubList());
            }
        }
    };

    private WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakSortOrderListener =
            new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrderListener);
    private final WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakVisibleLeafColumnsListener =
            new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(visibleLeafColumnsListener);
    private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
            new WeakListChangeListener&lt;String&gt;(styleClassListener);

    private static final EventHandler&lt;MouseEvent&gt; mousePressedHandler = me -&gt; {
        TableColumnHeader header = (TableColumnHeader) me.getSource();
        TableColumnBase tableColumn = header.getTableColumn();

        ContextMenu menu = tableColumn.getContextMenu();
        if (menu != null &amp;&amp; menu.isShowing()) {
            menu.hide();
        }

        if (me.isConsumed()) return;
        me.consume();

        header.getTableHeaderRow().columnDragLock = true;

        // pass focus to the table, so that the user immediately sees
        // the focus rectangle around the table control.
        header.getTableSkin().getSkinnable().requestFocus();

        if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
            header.columnReorderingStarted(me.getX());
        }
    };

    private static final EventHandler&lt;MouseEvent&gt; mouseDraggedHandler = me -&gt; {
        if (me.isConsumed()) return;
        me.consume();

        TableColumnHeader header = (TableColumnHeader) me.getSource();

        if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
            header.columnReordering(me.getSceneX(), me.getSceneY());
        }
    };

    private static final EventHandler&lt;MouseEvent&gt; mouseReleasedHandler = me -&gt; {
        if (me.isPopupTrigger()) return;
        if (me.isConsumed()) return;
        me.consume();

        TableColumnHeader header = (TableColumnHeader) me.getSource();
        header.getTableHeaderRow().columnDragLock = false;

        if (header.getTableHeaderRow().isReordering() &amp;&amp; header.isColumnReorderingEnabled()) {
            header.columnReorderingComplete();
        } else if (me.isStillSincePress()) {
            header.sortColumn(me.isShiftDown());
        }
    };

    private static final EventHandler&lt;ContextMenuEvent&gt; contextMenuRequestedHandler = me -&gt; {
        TableColumnHeader header = (TableColumnHeader) me.getSource();
        TableColumnBase tableColumn = header.getTableColumn();

        ContextMenu menu = tableColumn.getContextMenu();
        if (menu != null) {
            menu.show(header, me.getScreenX(), me.getScreenY());
            me.consume();
        }
    };



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- size
    private DoubleProperty size;
    private final double getSize() {
        return size == null ? 20.0 : size.doubleValue();
    }
    private final DoubleProperty sizeProperty() {
        if (size == null) {
            size = new StyleableDoubleProperty(20) {
                @Override
                protected void invalidated() {
                    double value = get();
                    if (value &lt;= 0) {
                        if (isBound()) {
                            unbind();
                        }
                        set(20);
                        throw new IllegalArgumentException(&quot;Size cannot be 0 or negative&quot;);
                    }
                }



                @Override public Object getBean() {
                    return TableColumnHeader.this;
                }

                @Override public String getName() {
                    return &quot;size&quot;;
                }

                @Override public CssMetaData&lt;TableColumnHeader,Number&gt; getCssMetaData() {
                    return StyleableProperties.SIZE;
                }
            };
        }
        return size;
    }


    /**
     * A property that refers to the {@link TableColumnBase} instance that this
     * header is visually represents.
     */
    // --- table column
    private ReadOnlyObjectWrapper&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumn = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;tableColumn&quot;);
    private final void setTableColumn(TableColumnBase&lt;?,?&gt; column) {
        tableColumn.set(column);
    }
    public final TableColumnBase&lt;?,?&gt; getTableColumn() {
        return tableColumn.get();
    }
    public final ReadOnlyObjectProperty&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumnProperty() {
        return tableColumn.getReadOnlyProperty();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (isSizeDirty) {
            resize(getTableColumn().getWidth(), getHeight());
            isSizeDirty = false;
        }

        double sortWidth = 0;
        double w = snapSizeX(getWidth()) - (snappedLeftInset() + snappedRightInset());
        double h = getHeight() - (snappedTopInset() + snappedBottomInset());
        double x = w;

        // a bit hacky, but we REALLY don't want the arrow shape to fluctuate
        // in size
        if (arrow != null) {
            arrow.setMaxSize(arrow.prefWidth(-1), arrow.prefHeight(-1));
        }

        if (sortArrow != null &amp;&amp; sortArrow.isVisible()) {
            sortWidth = sortArrow.prefWidth(-1);
            x -= sortWidth;
            sortArrow.resize(sortWidth, sortArrow.prefHeight(-1));
            positionInArea(sortArrow, x, snappedTopInset(),
                    sortWidth, h, 0, HPos.CENTER, VPos.CENTER);
        }

        if (label != null) {
            double labelWidth = w - sortWidth;
            label.resizeRelocate(snappedLeftInset(), 0, labelWidth, getHeight());
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        if (getNestedColumnHeader() != null) {
            double width = getNestedColumnHeader().prefWidth(height);

            if (getTableColumn() != null) {
                TableColumnBaseHelper.setWidth(getTableColumn(), width);
            }

            return width;
        } else if (getTableColumn() != null &amp;&amp; getTableColumn().isVisible()) {
            return snapSizeX(getTableColumn().getWidth());
        }

        return 0;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width) {
        return label == null ? 0 : label.minHeight(width);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        if (getTableColumn() == null) return 0;
        return Math.max(getSize(), label.prefHeight(-1));
    }

    /** {@inheritDoc} */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** {@inheritDoc} */
    @Override  public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case INDEX: return getIndex(getTableColumn());
            case TEXT: return getTableColumn() != null ? getTableColumn().getText() : null;
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    void initStyleClasses() {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        installTableColumnStyleClassListener();
    }

    void installTableColumnStyleClassListener() {
        TableColumnBase tc = getTableColumn();
        if (tc != null) {
            // add in all styleclasses from the table column into the header, and also set up a listener
            // so that any subsequent changes to the table column are also applied to the header
            getStyleClass().addAll(tc.getStyleClass());
            tc.getStyleClass().addListener(weakStyleClassListener);
        }
    }

    NestedTableColumnHeader getNestedColumnHeader() { return nestedColumnHeader; }
    void setNestedColumnHeader(NestedTableColumnHeader nch) { nestedColumnHeader = nch; }

    TableHeaderRow getTableHeaderRow() { return tableHeaderRow; }
    void setTableHeaderRow(TableHeaderRow thr) {
        tableHeaderRow = thr;
        updateTableSkin();
    }

    private void updateTableSkin() {
        // when we get the table header row, we are also given the skin,
        // so this is the time to hook up listeners, etc.
        TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin = getTableSkin();
        if (tableSkin == null) return;

        updateColumnIndex();
        this.columnReorderLine = tableSkin.getColumnReorderLine();

        if (getTableColumn() != null) {
            updateSortPosition();
            TableSkinUtils.getSortOrder(tableSkin).addListener(weakSortOrderListener);
            TableSkinUtils.getVisibleLeafColumns(tableSkin).addListener(weakVisibleLeafColumnsListener);
        }
    }

    TableViewSkinBase&lt;?,?,?,?,?&gt; getTableSkin() {
        return tableHeaderRow == null ? null : tableHeaderRow.tableSkin;
    }

    NestedTableColumnHeader getParentHeader() { return parentHeader; }
    void setParentHeader(NestedTableColumnHeader ph) { parentHeader = ph; }

    // RT-29682: When the sortable property of a TableColumnBase changes this
    // may impact other TableColumnHeaders, as they may need to change their
    // sort order representation. Rather than install listeners across all
    // TableColumn in the sortOrder list for their sortable property, we simply
    // update the sortPosition of all headers whenever the sortOrder property
    // changes, assuming the column is within the sortOrder list.
    private void updateAllHeaders(TableColumnHeader header) {
        if (header instanceof NestedTableColumnHeader) {
            List&lt;TableColumnHeader&gt; children = ((NestedTableColumnHeader)header).getColumnHeaders();
            for (int i = 0; i &lt; children.size(); i++) {
                updateAllHeaders(children.get(i));
            }
        } else {
            header.updateSortPosition();
        }
    }

    private void updateScene() {
        // RT-17684: If the TableColumn widths are all currently the default,
        // we attempt to 'auto-size' based on the preferred width of the first
        // n rows (we can't do all rows, as that could conceivably be an unlimited
        // number of rows retrieved from a very slow (e.g. remote) data source.
        // Obviously, the bigger the value of n, the more likely the default
        // width will be suitable for most values in the column
        final int n = 30;
        if (! autoSizeComplete) {
            if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
                return;
            }
            doColumnAutoSize(getTableColumn(), n);
            autoSizeComplete = true;
        }
    }

    void dispose() {
        TableViewSkinBase tableSkin = getTableSkin();
        if (tableSkin != null) {
            TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
            TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
        }

        changeListenerHandler.dispose();
    }

    private boolean isSortingEnabled() {
        // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
        // to always return true (for now), as we want to support column sorting
        // everywhere
        return true;
    }

    private boolean isColumnReorderingEnabled() {
        // we only allow for column reordering if there are more than one column,
        return !Properties.IS_TOUCH_SUPPORTED &amp;&amp; TableSkinUtils.getVisibleLeafColumns(getTableSkin()).size() &gt; 1;
    }

    private void initUI() {
        // TableColumn will be null if we are dealing with the root NestedTableColumnHeader
        if (getTableColumn() == null) return;

        // set up mouse events
        setOnMousePressed(mousePressedHandler);
        setOnMouseDragged(mouseDraggedHandler);
        setOnDragDetected(event -&gt; event.consume());
        setOnContextMenuRequested(contextMenuRequestedHandler);
        setOnMouseReleased(mouseReleasedHandler);

        // --- label
        label = new Label();
        label.setText(getTableColumn().getText());
        label.setGraphic(getTableColumn().getGraphic());
        label.setVisible(getTableColumn().isVisible());

        // ---- container for the sort arrow (which is not supported on embedded
        // platforms)
        if (isSortingEnabled()) {
            // put together the grid
            updateSortGrid();
        }
    }

    private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {
        double prefWidth = column.getPrefWidth();

        // if the prefWidth has been set, we do _not_ autosize columns
        if (prefWidth == DEFAULT_COLUMN_WIDTH) {
            TableSkinUtils.resizeColumnToFitContent(getTableSkin(), column, cellsToMeasure);
//            getTableViewSkin().resizeColumnToFitContent(column, cellsToMeasure);
        }
    }

    private void updateSortPosition() {
        this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
        updateSortGrid();
    }

    private void updateSortGrid() {
        // Fix for RT-14488
        if (this instanceof NestedTableColumnHeader) return;

        getChildren().clear();
        getChildren().add(label);

        // we do not support sorting in embedded devices
        if (! isSortingEnabled()) return;

        isSortColumn = sortPos != -1;
        if (! isSortColumn) {
            if (sortArrow != null) {
                sortArrow.setVisible(false);
            }
            return;
        }

        // RT-28016: if the tablecolumn is not a visible leaf column, we should ignore this
        int visibleLeafIndex = TableSkinUtils.getVisibleLeafIndex(getTableSkin(), getTableColumn());
        if (visibleLeafIndex == -1) return;

        final int sortColumnCount = getVisibleSortOrderColumnCount();
        boolean showSortOrderDots = sortPos &lt;= 3 &amp;&amp; sortColumnCount &gt; 1;

        Node _sortArrow = null;
        if (getTableColumn().getSortNode() != null) {
            _sortArrow = getTableColumn().getSortNode();
            getChildren().add(_sortArrow);
        } else {
            GridPane sortArrowGrid = new GridPane();
            _sortArrow = sortArrowGrid;
            sortArrowGrid.setPadding(new Insets(0, 3, 0, 0));
            getChildren().add(sortArrowGrid);

            // if we are here, and the sort arrow is null, we better create it
            if (arrow == null) {
                arrow = new Region();
                arrow.getStyleClass().setAll(&quot;arrow&quot;);
                arrow.setVisible(true);
                arrow.setRotate(isAscending(getTableColumn()) ? 180.0F : 0.0F);
                changeListenerHandler.registerChangeListener(getSortTypeProperty(getTableColumn()), e -&gt; {
                    updateSortGrid();
                    if (arrow != null) {
                        arrow.setRotate(isAscending(getTableColumn()) ? 180 : 0.0);
                    }
                });
            }

            arrow.setVisible(isSortColumn);

            if (sortPos &gt; 2) {
                if (sortOrderLabel == null) {
                    // ---- sort order label (for sort positions greater than 3)
                    sortOrderLabel = new Label();
                    sortOrderLabel.getStyleClass().add(&quot;sort-order&quot;);
                }

                // only show the label if the sortPos is greater than 3 (for sortPos
                // values less than three, we show the sortOrderDots instead)
                sortOrderLabel.setText(&quot;&quot; + (sortPos + 1));
                sortOrderLabel.setVisible(sortColumnCount &gt; 1);

                // update the grid layout
                sortArrowGrid.add(arrow, 1, 1);
                GridPane.setHgrow(arrow, Priority.NEVER);
                GridPane.setVgrow(arrow, Priority.NEVER);
                sortArrowGrid.add(sortOrderLabel, 2, 1);
            } else if (showSortOrderDots) {
                if (sortOrderDots == null) {
                    sortOrderDots = new HBox(0);
                    sortOrderDots.getStyleClass().add(&quot;sort-order-dots-container&quot;);
                }

                // show the sort order dots
                boolean isAscending = isAscending(getTableColumn());
                int arrowRow = isAscending ? 1 : 2;
                int dotsRow = isAscending ? 2 : 1;

                sortArrowGrid.add(arrow, 1, arrowRow);
                GridPane.setHalignment(arrow, HPos.CENTER);
                sortArrowGrid.add(sortOrderDots, 1, dotsRow);

                updateSortOrderDots(sortPos);
            } else {
                // only show the arrow
                sortArrowGrid.add(arrow, 1, 1);
                GridPane.setHgrow(arrow, Priority.NEVER);
                GridPane.setVgrow(arrow, Priority.ALWAYS);
            }
        }

        sortArrow = _sortArrow;
        if (sortArrow != null) {
            sortArrow.setVisible(isSortColumn);
        }

        requestLayout();
    }

    private void updateSortOrderDots(int sortPos) {
        double arrowWidth = arrow.prefWidth(-1);

        sortOrderDots.getChildren().clear();

        for (int i = 0; i &lt;= sortPos; i++) {
            Region r = new Region();
            r.getStyleClass().add(&quot;sort-order-dot&quot;);

            String sortTypeName = getSortTypeName(getTableColumn());
            if (sortTypeName != null &amp;&amp; ! sortTypeName.isEmpty()) {
                r.getStyleClass().add(sortTypeName.toLowerCase(Locale.ROOT));
            }

            sortOrderDots.getChildren().add(r);

            // RT-34914: fine tuning the placement of the sort dots. We could have gone to a custom layout, but for now
            // this works fine.
            if (i &lt; sortPos) {
                Region spacer = new Region();
                double lp = sortPos == 1 ? 1 : 0;
                spacer.setPadding(new Insets(0, 1, 0, lp));
                sortOrderDots.getChildren().add(spacer);
            }
        }

        sortOrderDots.setAlignment(Pos.TOP_CENTER);
        sortOrderDots.setMaxWidth(arrowWidth);
    }

    // Package for testing purposes only.
    void moveColumn(TableColumnBase column, final int newColumnPos) {
        if (column == null || newColumnPos &lt; 0) return;

        ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);

        final int columnsCount = columns.size();
        final int currentPos = columns.indexOf(column);

        int actualNewColumnPos = newColumnPos;

        // Fix for RT-35141: We need to account for hidden columns.
        // We keep iterating until we see 'requiredVisibleColumns' number of visible columns
        final int requiredVisibleColumns = actualNewColumnPos;
        int visibleColumnsSeen = 0;
        for (int i = 0; i &lt; columnsCount; i++) {
            if (visibleColumnsSeen == (requiredVisibleColumns + 1)) {
                break;
            }

            if (columns.get(i).isVisible()) {
                visibleColumnsSeen++;
            } else {
                actualNewColumnPos++;
            }
        }
        // --- end of RT-35141 fix

        if (actualNewColumnPos &gt;= columnsCount) {
            actualNewColumnPos = columnsCount - 1;
        } else if (actualNewColumnPos &lt; 0) {
            actualNewColumnPos = 0;
        }

        if (actualNewColumnPos == currentPos) return;

        List&lt;TableColumnBase&lt;?,?&gt;&gt; tempList = new ArrayList&lt;&gt;(columns);
        tempList.remove(column);
        tempList.add(actualNewColumnPos, column);

        columns.setAll(tempList);
    }

    private ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; getColumns(TableColumnBase column) {
        return column.getParentColumn() == null ?
                TableSkinUtils.getColumns(getTableSkin()) :
                column.getParentColumn().getColumns();
    }

    private int getIndex(TableColumnBase&lt;?,?&gt; column) {
        if (column == null) return -1;

        ObservableList&lt;? extends TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);

        int index = -1;
        for (int i = 0; i &lt; columns.size(); i++) {
            TableColumnBase&lt;?,?&gt; _column = columns.get(i);
            if (! _column.isVisible()) continue;

            index++;
            if (column.equals(_column)) break;
        }

        return index;
    }

    private void updateColumnIndex() {
//        TableView tv = getTableView();
        TableColumnBase tc = getTableColumn();
        TableViewSkinBase tableSkin = getTableSkin();
        columnIndex = tableSkin == null || tc == null ? -1 :TableSkinUtils.getVisibleLeafIndex(tableSkin,tc);

        // update the pseudo class state regarding whether this is the last
        // visible cell (i.e. the right-most).
        isLastVisibleColumn = getTableColumn() != null &amp;&amp;
                columnIndex != -1 &amp;&amp;
                columnIndex == TableSkinUtils.getVisibleLeafColumns(tableSkin).size() - 1;
        pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
    }

    private void sortColumn(final boolean addColumn) {
        if (! isSortingEnabled()) return;

        // we only allow sorting on the leaf columns and columns
        // that actually have comparators defined, and are sortable
        if (getTableColumn() == null || getTableColumn().getColumns().size() != 0 || getTableColumn().getComparator() == null || !getTableColumn().isSortable()) return;
//        final int sortPos = getTable().getSortOrder().indexOf(column);
//        final boolean isSortColumn = sortPos != -1;

        final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());

        // addColumn is true e.g. when the user is holding down Shift
        if (addColumn) {
            if (!isSortColumn) {
                setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
                sortOrder.add(getTableColumn());
            } else if (isAscending(getTableColumn())) {
                setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
            } else {
                int i = sortOrder.indexOf(getTableColumn());
                if (i != -1) {
                    sortOrder.remove(i);
                }
            }
        } else {
            // the user has clicked on a column header - we should add this to
            // the TableView sortOrder list if it isn't already there.
            if (isSortColumn &amp;&amp; sortOrder.size() == 1) {
                // the column is already being sorted, and it's the only column.
                // We therefore move through the 2nd or 3rd states:
                //   1st click: sort ascending
                //   2nd click: sort descending
                //   3rd click: natural sorting (sorting is switched off)
                if (isAscending(getTableColumn())) {
                    setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
                } else {
                    // remove from sort
                    sortOrder.remove(getTableColumn());
                }
            } else if (isSortColumn) {
                // the column is already being used to sort, so we toggle its
                // sortAscending property, and also make the column become the
                // primary sort column
                if (isAscending(getTableColumn())) {
                    setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
                } else if (isDescending(getTableColumn())) {
                    setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
                }

                // to prevent multiple sorts, we make a copy of the sort order
                // list, moving the column value from the current position to
                // its new position at the front of the list
                List&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderCopy = new ArrayList&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrder);
                sortOrderCopy.remove(getTableColumn());
                sortOrderCopy.add(0, getTableColumn());
                sortOrder.setAll(getTableColumn());
            } else {
                // add to the sort order, in ascending form
                setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
                sortOrder.setAll(getTableColumn());
            }
        }
    }

    // Because it is possible that some columns are in the sortOrder list but are
    // not themselves sortable, we cannot just do sortOrderList.indexOf(column).
    // Therefore, this method does the proper work required of iterating through
    // and ignoring non-sortable (and null) columns in the sortOrder list.
    private int getSortPosition() {
        if (getTableColumn() == null) {
            return -1;
        }

        final List&lt;TableColumnBase&gt; sortOrder = getVisibleSortOrderColumns();
        int pos = 0;
        for (int i = 0; i &lt; sortOrder.size(); i++) {
            TableColumnBase _tc = sortOrder.get(i);

            if (getTableColumn().equals(_tc)) {
                return pos;
            }

<A NAME="32"></A>            pos++;
        }

        <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#32',2,'match34-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return -1;
    }

    private List&lt;TableColumnBase&gt; getVisibleSortOrderColumns() {
        final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());

        List&lt;TableColumnBase&gt; visibleSortOrderColumns = new</B></FONT> ArrayList&lt;&gt;();
        for (int i = 0; i &lt; sortOrder.size(); i++) {
            TableColumnBase _tc = sortOrder.get(i);
            if (_tc == null || ! _tc.isSortable() || ! _tc.isVisible()) {
                continue;
            }

            visibleSortOrderColumns.add(_tc);
        }

        return visibleSortOrderColumns;
    }

    // as with getSortPosition above, this method iterates through the sortOrder
    // list ignoring the null and non-sortable columns, so that we get the correct
    // number of columns in the sortOrder list.
    private int getVisibleSortOrderColumnCount() {
        return getVisibleSortOrderColumns().size();
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation: Column Reordering                               *
     *                                                                         *
     **************************************************************************/

    // package for testing
    void columnReorderingStarted(double dragOffset) {
        if (! getTableColumn().isReorderable()) return;

        // Used to ensure the column ghost is positioned relative to where the
        // user clicked on the column header
        this.dragOffset = dragOffset;

        // Note here that we only allow for reordering of 'root' columns
        getTableHeaderRow().setReorderingColumn(getTableColumn());
        getTableHeaderRow().setReorderingRegion(this);
    }

    // package for testing
    void columnReordering(double sceneX, double sceneY) {
        if (! getTableColumn().isReorderable()) return;

        // this is for handling the column drag to reorder columns.
        // It shows a line to indicate where the 'drop' will be.

        // indicate that we've started dragging so that the dragging
        // line overlay is shown
        getTableHeaderRow().setReordering(true);

        // Firstly we need to determine where to draw the line.
        // Find which column we're over
        TableColumnHeader hoverHeader = null;

        // x represents where the mouse is relative to the parent
        // NestedTableColumnHeader
        final double x = getParentHeader().sceneToLocal(sceneX, sceneY).getX();

        // calculate where the ghost column header should be
        double dragX = getTableSkin().getSkinnable().sceneToLocal(sceneX, sceneY).getX() - dragOffset;
        getTableHeaderRow().setDragHeaderX(dragX);

        double startX = 0;
        double endX = 0;
        double headersWidth = 0;
        newColumnPos = 0;
        for (TableColumnHeader header : getParentHeader().getColumnHeaders()) {
            if (! header.isVisible()) continue;

            double headerWidth = header.prefWidth(-1);
            headersWidth += headerWidth;

            startX = header.getBoundsInParent().getMinX();
            endX = startX + headerWidth;

            if (x &gt;= startX &amp;&amp; x &lt; endX) {
                hoverHeader = header;
                break;
            }
            newColumnPos++;
        }

        // hoverHeader will be null if the drag occurs outside of the
        // tableview. In this case we handle the newColumnPos specially
        // and then short-circuit. This results in the drop action
        // resulting in the correct result (the column will drop at
        // the start or end of the table).
        if (hoverHeader == null) {
            newColumnPos = x &gt; headersWidth ? (getParentHeader().getColumns().size() - 1) : 0;
            return;
        }

        // This is the x-axis value midway through hoverHeader. It's
        // used to determine whether the drop should be to the left
        // or the right of hoverHeader.
        double midPoint = startX + (endX - startX) / 2;
        boolean beforeMidPoint = x &lt;= midPoint;

        // Based on where the mouse actually is, we have to shuffle
        // where we want the column to end up. This code handles that.
        int currentPos = getIndex(getTableColumn());
        newColumnPos += newColumnPos &gt; currentPos &amp;&amp; beforeMidPoint ?
            -1 : (newColumnPos &lt; currentPos &amp;&amp; !beforeMidPoint ? 1 : 0);

        double lineX = getTableHeaderRow().sceneToLocal(hoverHeader.localToScene(hoverHeader.getBoundsInLocal())).getMinX();
        lineX = lineX + ((beforeMidPoint) ? (0) : (hoverHeader.getWidth()));

        if (lineX &gt;= -0.5 &amp;&amp; lineX &lt;= getTableSkin().getSkinnable().getWidth()) {
            columnReorderLine.setTranslateX(lineX);

            // then if this is the first event, we set the property to true
            // so that the line becomes visible until the drop is completed.
            // We also set reordering to true so that the various reordering
            // effects become visible (ghost, transparent overlay, etc).
            columnReorderLine.setVisible(true);
        }

        getTableHeaderRow().setReordering(true);
    }

    // package for testing
    void columnReorderingComplete() {
        if (! getTableColumn().isReorderable()) return;

        // Move col from where it is now to the new position.
        moveColumn(getTableColumn(), newColumnPos);

        // cleanup
        columnReorderLine.setTranslateX(0.0F);
        columnReorderLine.setLayoutX(0.0F);
        newColumnPos = 0;

        getTableHeaderRow().setReordering(false);
        columnReorderLine.setVisible(false);
        getTableHeaderRow().setReorderingColumn(null);
        getTableHeaderRow().setReorderingRegion(null);
        dragOffset = 0.0F;
    }

    double getDragRectHeight() {
        return getHeight();
    }

    // Used to test whether this column header properly represents the given column.
    // In particular, whether it has child column headers for all child columns
    boolean represents(TableColumnBase&lt;?, ?&gt; column) {
        if (!column.getColumns().isEmpty()) {
            // this column has children, but we are in a TableColumnHeader instance,
            // so the match is bad.
            return false;
        }
        return column == getTableColumn();
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
            PseudoClass.getPseudoClass(&quot;last-visible&quot;);

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;TableColumnHeader,Number&gt; SIZE =
            new CssMetaData&lt;TableColumnHeader,Number&gt;(&quot;-fx-size&quot;,
                 SizeConverter.getInstance(), 20.0) {

            @Override
            public boolean isSettable(TableColumnHeader n) {
                return n.size == null || !n.size.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TableColumnHeader n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.sizeProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);

         }
    }

    /**
     * Returnst the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TitledPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.Animation.Status;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.HPos;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.Control;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

import com.sun.javafx.scene.control.behavior.TitledPaneBehavior;
import javafx.beans.binding.DoubleBinding;
import javafx.geometry.Insets;
import javafx.scene.control.Accordion;
import javafx.scene.control.Labeled;
import javafx.scene.control.ContextMenu;
import javafx.scene.input.MouseButton;
import javafx.scene.text.Font;

/**
 * Default skin implementation for the {@link TitledPane} control.
 *
 * @see TitledPane
 * @since 9
 */
public class TitledPaneSkin extends LabeledSkinBase&lt;TitledPane&gt;  {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final Duration TRANSITION_DURATION = new Duration(350.0);

    // caching results in poorer looking text (it is blurry), so we don't do it
    // unless on a low powered device (admittedly the test below isn't a great
    // indicator of power, but it'll do for now).
    private static final boolean CACHE_ANIMATION = PlatformUtil.isEmbedded();



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final TitledPaneBehavior behavior;

    private final TitleRegion titleRegion;
    private final StackPane contentContainer;
    private Node content;
    private Timeline timeline;
    private double transitionStartValue;
    private Rectangle clipRect;
    private Pos pos;
    private HPos hpos;
    private VPos vpos;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TitledPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TitledPaneSkin(final TitledPane control) {
        super(control);

        // install default input map for the TitledPane control
        this.behavior = new TitledPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle();

        transitionStartValue = 0;
        titleRegion = new TitleRegion();

        content = getSkinnable().getContent();
        contentContainer = new StackPane() {
            {
                getStyleClass().setAll(&quot;content&quot;);

                if (content != null) {
                    getChildren().setAll(content);
                }
            }
        };
        contentContainer.setClip(clipRect);
        updateClip();

        if (control.isExpanded()) {
            setTransition(1.0f);
            setExpanded(control.isExpanded());
        } else {
            setTransition(0.0f);
            if (content != null) {
                content.setVisible(false);
            }
        }

        getChildren().setAll(contentContainer, titleRegion);

        registerChangeListener(control.contentProperty(), e -&gt; {
            content = getSkinnable().getContent();
            if (content == null) {
                contentContainer.getChildren().clear();
            } else {
                contentContainer.getChildren().setAll(content);
            }
        });
        registerChangeListener(control.expandedProperty(), e -&gt; setExpanded(getSkinnable().isExpanded()));
        registerChangeListener(control.collapsibleProperty(), e -&gt; titleRegion.update());
        registerChangeListener(control.alignmentProperty(), e -&gt; {
            pos = getSkinnable().getAlignment();
            hpos = pos.getHpos();
            vpos = pos.getVpos();
        });
        registerChangeListener(control.widthProperty(), e -&gt; updateClip());
        registerChangeListener(control.heightProperty(), e -&gt; updateClip());
        registerChangeListener(titleRegion.alignmentProperty(), e -&gt; {
            pos = titleRegion.getAlignment();
            hpos = pos.getHpos();
            vpos = pos.getVpos();
        });

        pos = control.getAlignment();
        hpos = pos == null ? HPos.LEFT   : pos.getHpos();
        vpos = pos == null ? VPos.CENTER : pos.getVpos();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private DoubleProperty transition;
    private final void setTransition(double value) { transitionProperty().set(value); }
    private final double getTransition() { return transition == null ? 0.0 : transition.get(); }
    private final DoubleProperty transitionProperty() {
        if (transition == null) {
            transition = new SimpleDoubleProperty(this, &quot;transition&quot;, 0.0) {
                @Override protected void invalidated() {
                    contentContainer.requestLayout();
                }
            };
        }
        return transition;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    // Override LabeledSkinBase updateChildren because
    // it removes all the children.  The update() in TitleRegion
    // will replace this method.
    /** {@inheritDoc} */
    @Override protected void updateChildren() {
        if (titleRegion != null) {
            titleRegion.update();
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, double y,
                                            final double w, final double h) {

        // header
        double headerHeight = snapSizeY(titleRegion.prefHeight(-1));

        titleRegion.resize(w, headerHeight);
        positionInArea(titleRegion, x, y,
                w, headerHeight, 0, HPos.LEFT, VPos.CENTER);
        titleRegion.requestLayout();

        // content
        double contentHeight = (h - headerHeight) * getTransition();
        if (isInsideAccordion()) {
            if (prefHeightFromAccordion != 0) {
                contentHeight = (prefHeightFromAccordion - headerHeight) * getTransition();
            }
        }
        contentHeight = snapSizeY(contentHeight);

        y += headerHeight;
        contentContainer.resize(w, contentHeight);
        clipRect.setHeight(contentHeight);
        positionInArea(contentContainer, x, y,
                w, contentHeight, /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double titleWidth = snapSizeX(titleRegion.prefWidth(height));
        double contentWidth = snapSizeX(contentContainer.minWidth(height));
        return Math.max(titleWidth, contentWidth) + leftInset + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double headerHeight = snapSizeY(titleRegion.prefHeight(width));
        double contentHeight = contentContainer.minHeight(width) * getTransition();
        return headerHeight + snapSizeY(contentHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double titleWidth = snapSizeX(titleRegion.prefWidth(height));
        double contentWidth = snapSizeX(contentContainer.prefWidth(height));
        return Math.max(titleWidth, contentWidth) + leftInset + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double headerHeight = snapSizeY(titleRegion.prefHeight(width));
        double contentHeight = contentContainer.prefHeight(width) * getTransition();
        return headerHeight + snapSizeY(contentHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Double.MAX_VALUE;
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void updateClip() {
        clipRect.setWidth(getSkinnable().getWidth());
        clipRect.setHeight(contentContainer.getHeight());
    }

    private void setExpanded(boolean expanded) {
        if (! getSkinnable().isCollapsible()) {
            setTransition(1.0f);
            return;
        }

        // we need to perform the transition between expanded / hidden
        if (getSkinnable().isAnimated()) {
            transitionStartValue = getTransition();
            doAnimationTransition();
        } else {
            if (expanded) {
                setTransition(1.0f);
            } else {
                setTransition(0.0f);
            }
            if (content != null) {
                content.setVisible(expanded);
             }
            getSkinnable().requestLayout();
        }
    }

    private boolean isInsideAccordion() {
        return getSkinnable().getParent() != null &amp;&amp; getSkinnable().getParent() instanceof Accordion;
<A NAME="27"></A>    }

    double getTitleRegionSize(double width) {
        return snapSizeY(titleRegion.prefHeight(width)) + snappedTopInset() + <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#27',2,'match34-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>snappedBottomInset();
    }

    private double prefHeightFromAccordion = 0;
    void setMaxTitledPaneHeightForAccordion(double height) {
        this.prefHeightFromAccordion = height;
    }

    double getTitledPaneHeightForAccordion() {
        double headerHeight = snapSizeY(titleRegion.prefHeight(-1))</B></FONT>;
        double contentHeight = (prefHeightFromAccordion - headerHeight) * getTransition();
        return headerHeight + snapSizeY(contentHeight) + snappedTopInset() + snappedBottomInset();
    }

    private void doAnimationTransition() {
        if (content == null) {
            return;
        }

        Duration duration;
        if (timeline != null &amp;&amp; (timeline.getStatus() != Status.STOPPED)) {
            duration = timeline.getCurrentTime();
            timeline.stop();
        } else {
            duration = TRANSITION_DURATION;
        }

        timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyFrame k1, k2;

        if (getSkinnable().isExpanded()) {
            k1 = new KeyFrame(
                Duration.ZERO,
                    event -&gt; {
                        // start expand
                        if (CACHE_ANIMATION) content.setCache(true);
                        content.setVisible(true);
                    },
                new KeyValue(transitionProperty(), transitionStartValue)
            );

            k2 = new KeyFrame(
                duration,
                    event -&gt; {
                        // end expand
                        if (CACHE_ANIMATION) content.setCache(false);
                    },
                new KeyValue(transitionProperty(), 1, Interpolator.LINEAR)

            );
        } else {
            k1 = new KeyFrame(
                Duration.ZERO,
                    event -&gt; {
                        // Start collapse
                        if (CACHE_ANIMATION) content.setCache(true);
                    },
                new KeyValue(transitionProperty(), transitionStartValue)
            );

            k2 = new KeyFrame(
                duration,
                    event -&gt; {
                        // end collapse
                        content.setVisible(false);
                        if (CACHE_ANIMATION) content.setCache(false);
                    },
                new KeyValue(transitionProperty(), 0, Interpolator.LINEAR)
            );
        }

        timeline.getKeyFrames().setAll(k1, k2);
        timeline.play();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    class TitleRegion extends StackPane {
        private final StackPane arrowRegion;

        public TitleRegion() {
            getStyleClass().setAll(&quot;title&quot;);
            arrowRegion = new StackPane();
            arrowRegion.setId(&quot;arrowRegion&quot;);
            arrowRegion.getStyleClass().setAll(&quot;arrow-button&quot;);

            StackPane arrow = new StackPane();
            arrow.setId(&quot;arrow&quot;);
            arrow.getStyleClass().setAll(&quot;arrow&quot;);
            arrowRegion.getChildren().setAll(arrow);

            // RT-13294: TitledPane : add animation to the title arrow
            arrow.rotateProperty().bind(new DoubleBinding() {
                { bind(transitionProperty()); }

                @Override protected double computeValue() {
                    return -90 * (1.0 - getTransition());
                }
            });

            setAlignment(Pos.CENTER_LEFT);

            setOnMouseReleased(e -&gt; {
                if( e.getButton() != MouseButton.PRIMARY ) return;
                ContextMenu contextMenu = getSkinnable().getContextMenu() ;
                if (contextMenu != null) {
                    contextMenu.hide() ;
                }
                if (getSkinnable().isCollapsible() &amp;&amp; getSkinnable().isFocused()) {
                    behavior.toggle();
                }
            });

            // title region consists of the title and the arrow regions
            update();
        }

        private void update() {
            getChildren().clear();
            final TitledPane titledPane = getSkinnable();

            if (titledPane.isCollapsible()) {
                getChildren().add(arrowRegion);
            }

            // Only in some situations do we want to have the graphicPropertyChangedListener
            // installed. Since updateChildren() is not called much, we'll just remove it always
            // and reinstall it later if it is necessary to do so.
            if (graphic != null) {
                graphic.layoutBoundsProperty().removeListener(graphicPropertyChangedListener);
            }
            // Now update the graphic (since it may have changed)
            graphic = titledPane.getGraphic();
            // Now update the children (and add the graphicPropertyChangedListener as necessary)
            if (isIgnoreGraphic()) {
                if (titledPane.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY) {
                    getChildren().clear();
                    getChildren().add(arrowRegion);
                } else {
                    getChildren().add(text);
                }
            } else {
                graphic.layoutBoundsProperty().addListener(graphicPropertyChangedListener);
                if (isIgnoreText()) {
                    getChildren().add(graphic);
                } else {
                    getChildren().addAll(graphic, text);
                }
            }
            setCursor(getSkinnable().isCollapsible() ? Cursor.HAND : Cursor.DEFAULT);
        }

        @Override protected double computePrefWidth(double height) {
            double left = snappedLeftInset();
            double right = snappedRightInset();
            double arrowWidth = 0;
            double labelPrefWidth = labelPrefWidth(height);

            if (arrowRegion != null) {
                arrowWidth = snapSize(arrowRegion.prefWidth(height));
            }

            return left + arrowWidth + labelPrefWidth + right;
        }

        @Override protected double computePrefHeight(double width) {
            double top = snappedTopInset();
            double bottom = snappedBottomInset();
            double arrowHeight = 0;
            double labelPrefHeight = labelPrefHeight(width);

            if (arrowRegion != null) {
                arrowHeight = snapSize(arrowRegion.prefHeight(width));
            }

            return top + Math.max(arrowHeight, labelPrefHeight) + bottom;
        }

        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double bottom = snappedBottomInset();
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            double width = getWidth() - (left + right);
            double height = getHeight() - (top + bottom);
            double arrowWidth = snapSize(arrowRegion.prefWidth(-1));
            double arrowHeight = snapSize(arrowRegion.prefHeight(-1));
            double labelWidth = snapSize(Math.min(width - arrowWidth / 2.0, labelPrefWidth(-1)));
            double labelHeight = snapSize(labelPrefHeight(-1));

            double x = left + arrowWidth + Utils.computeXOffset(width - arrowWidth, labelWidth, hpos);
            if (HPos.CENTER == hpos) {
                // We want to center the region based on the entire width of the TitledPane.
                x = left + Utils.computeXOffset(width, labelWidth, hpos);
            }
            double y = top + Utils.computeYOffset(height, Math.max(arrowHeight, labelHeight), vpos);

            arrowRegion.resize(arrowWidth, arrowHeight);
            positionInArea(arrowRegion, left, top, arrowWidth, height,
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

            layoutLabelInArea(x, y, labelWidth, height, pos);
        }

        // Copied from LabeledSkinBase because the padding from TitledPane was being
        // applied to the Label when it should not be.
        private double labelPrefWidth(double height) {
            // Get the preferred width of the text
            final Labeled labeled = getSkinnable();
            final Font font = text.getFont();
            final String string = labeled.getText();
            boolean emptyText = string == null || string.isEmpty();
            Insets labelPadding = labeled.getLabelPadding();
            double widthPadding = labelPadding.getLeft() + labelPadding.getRight();
            double textWidth = emptyText ? 0 : Utils.computeTextWidth(font, string, 0);

            // Now add on the graphic, gap, and padding as appropriate
            final Node graphic = labeled.getGraphic();
            if (isIgnoreGraphic()) {
                return textWidth + widthPadding;
            } else if (isIgnoreText()) {
                return graphic.prefWidth(-1) + widthPadding;
            } else if (labeled.getContentDisplay() == ContentDisplay.LEFT
                    || labeled.getContentDisplay() == ContentDisplay.RIGHT) {
                return textWidth + labeled.getGraphicTextGap() + graphic.prefWidth(-1) + widthPadding;
            } else {
                return Math.max(textWidth, graphic.prefWidth(-1)) + widthPadding;
            }
        }

        // Copied from LabeledSkinBase because the padding from TitledPane was being
        // applied to the Label when it should not be.
        private double labelPrefHeight(double width) {
            final Labeled labeled = getSkinnable();
            final Font font = text.getFont();
            final ContentDisplay contentDisplay = labeled.getContentDisplay();
            final double gap = labeled.getGraphicTextGap();
            final Insets labelPadding = labeled.getLabelPadding();
            final double widthPadding = snappedLeftInset() + snappedRightInset() + labelPadding.getLeft() + labelPadding.getRight();

            String str = labeled.getText();
            if (str != null &amp;&amp; str.endsWith(&quot;\n&quot;)) {
                // Strip ending newline so we don't count another row.
                str = str.substring(0, str.length() - 1);
            }

            if (!isIgnoreGraphic() &amp;&amp;
                (contentDisplay == ContentDisplay.LEFT || contentDisplay == ContentDisplay.RIGHT)) {
                width -= (graphic.prefWidth(-1) + gap);
            }

            width -= widthPadding;

            // TODO figure out how to cache this effectively.
            final double textHeight = Utils.computeTextHeight(font, str,
                    labeled.isWrapText() ? width : 0, text.getBoundsType());

            // Now we want to add on the graphic if necessary!
            double h = textHeight;
            if (!isIgnoreGraphic()) {
                final Node graphic = labeled.getGraphic();
                if (contentDisplay == ContentDisplay.TOP || contentDisplay == ContentDisplay.BOTTOM) {
                    h = graphic.prefHeight(-1) + gap + textHeight;
                } else {
                    h = Math.max(textHeight, graphic.prefHeight(-1));
                }
            }

            return h + labelPadding.getTop() + labelPadding.getBottom();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/javafx/fxml/FXMLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.fxml;

import com.sun.javafx.util.Logging;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.regex.Pattern;

import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.Property;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.*;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.util.Builder;
import javafx.util.BuilderFactory;
import javafx.util.Callback;

import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.util.StreamReaderDelegate;

import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.fxml.BeanAdapter;
import com.sun.javafx.fxml.ParseTraceElement;
import com.sun.javafx.fxml.PropertyNotFoundException;
import com.sun.javafx.fxml.expression.Expression;
import com.sun.javafx.fxml.expression.ExpressionValue;
import com.sun.javafx.fxml.expression.KeyPath;
import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
import com.sun.javafx.fxml.FXMLLoaderHelper;
import com.sun.javafx.fxml.MethodHelper;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.EnumMap;
import java.util.Locale;
import java.util.StringTokenizer;
import com.sun.javafx.reflect.ConstructorUtil;
import com.sun.javafx.reflect.MethodUtil;
import com.sun.javafx.reflect.ReflectUtil;

/**
 * Loads an object hierarchy from an XML document.
 * For more information, see the
 * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 * document.
 *
 * @since JavaFX 2.0
 */
public class FXMLLoader {

    // Indicates permission to get the ClassLoader
    private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
        new RuntimePermission(&quot;getClassLoader&quot;);

    // Instance of StackWalker used to get caller class (must be private)
    private static final StackWalker walker =
        AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));

    // Abstract base class for elements
    private abstract class Element {
        public final Element parent;

        public Object value = null;
        private BeanAdapter valueAdapter = null;

        public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();

        public Element() {
            parent = current;
        }

        public boolean isCollection() {
            // Return true if value is a list, or if the value's type defines
            // a default property that is a list
            boolean collection;
            if (value instanceof List&lt;?&gt;) {
                collection = true;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

                if (defaultProperty != null) {
                    collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
                } else {
                    collection = false;
                }
            }

            return collection;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void add(Object element) throws LoadException {
            // If value is a list, add element to it; otherwise, get the value
            // of the default property, which is assumed to be a list and add
            // to that (coerce to the appropriate type)
            List&lt;Object&gt; list;
            if (value instanceof List&lt;?&gt;) {
                list = (List&lt;Object&gt;)value;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
                String defaultPropertyName = defaultProperty.value();

                // Get the list value
                list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);

                // Coerce the element to the list item type
                if (!Map.class.isAssignableFrom(type)) {
                    Type listType = getValueAdapter().getGenericType(defaultPropertyName);
                    element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
                }
            }

            list.add(element);
        }

        public void set(Object value) throws LoadException {
            if (this.value == null) {
                throw constructLoadException(&quot;Cannot set value on this element.&quot;);
            }

            // Apply value to this element's properties
            Class&lt;?&gt; type = this.value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
            if (defaultProperty == null) {
                throw constructLoadException(&quot;Element does not define a default property.&quot;);
            }

            getProperties().put(defaultProperty.value(), value);
        }

        public void updateValue(Object value) {
            this.value = value;
            valueAdapter = null;
        }

        public boolean isTyped() {
            return !(value instanceof Map&lt;?, ?&gt;);
        }

        public BeanAdapter getValueAdapter() {
            if (valueAdapter == null) {
                valueAdapter = new BeanAdapter(value);
            }

            return valueAdapter;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Map&lt;String, Object&gt; getProperties() {
            return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
        }

        public void processStartElement() throws IOException {
            for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
                String prefix = xmlStreamReader.getAttributePrefix(i);
                String localName = xmlStreamReader.getAttributeLocalName(i);
                String value = xmlStreamReader.getAttributeValue(i);

                if (loadListener != null
                    &amp;&amp; prefix != null
                    &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                    loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
                }

                processAttribute(prefix, localName, value);
            }
        }

        public void processEndElement() throws IOException {
            // No-op
        }

        public void processCharacters() throws IOException {
            throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
        }

        public void processInstancePropertyAttributes() throws IOException {
            if (instancePropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : instancePropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }
        }

        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix == null) {
                // Add the attribute to the appropriate list
                if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
                    if (loadListener != null) {
                        loadListener.readEventHandlerAttribute(localName, value);
                    }

                    eventHandlerAttributes.add(new Attribute(localName, null, value));
                } else {
                    int i = localName.lastIndexOf('.');

                    if (i == -1) {
                        // The attribute represents an instance property
                        if (loadListener != null) {
                            loadListener.readPropertyAttribute(localName, null, value);
                        }

                        instancePropertyAttributes.add(new Attribute(localName, null, value));
                    } else {
                        // The attribute represents a static property
                        String name = localName.substring(i + 1);
                        Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                        if (sourceType != null) {
                            if (loadListener != null) {
                                loadListener.readPropertyAttribute(name, sourceType, value);
                            }

                            staticPropertyAttributes.add(new Attribute(name, sourceType, value));
                        } else if (staticLoad) {
                            if (loadListener != null) {
                                loadListener.readUnknownStaticPropertyAttribute(localName, value);
                            }
                        } else {
                            throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
                        }
                    }

                }
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void processPropertyAttribute(Attribute attribute) throws IOException {
            String value = attribute.value;
            if (isBindingExpression(value)) {
                // Resolve the expression
                Expression expression;

                if (attribute.sourceType != null) {
                    throw constructLoadException(&quot;Cannot bind to static property.&quot;);
                }

                if (!isTyped()) {
                    throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
                }

                // TODO We may want to identify binding properties in processAttribute()
                // and apply them after build() has been called
                if (this.value instanceof Builder) {
                    throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
                }

                if (!isStaticLoad()) {
                    value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
                            value.length() - 1);
                    expression = Expression.valueOf(value);

                    // Create the binding
                    BeanAdapter targetAdapter = new BeanAdapter(this.value);
                    ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
                    Class&lt;?&gt; type = targetAdapter.getType(attribute.name);

                    if (propertyModel instanceof Property&lt;?&gt;) {
                        ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
                    }
                }
            } else if (isBidirectionalBindingExpression(value)) {
                throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
<A NAME="38"></A>            } else {
                processValue(attribute.sourceType, attribute.name, value);
            }
        <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#38',2,'match34-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        private boolean isBindingExpression(String aValue) {
            return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
                   &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
        }

        private boolean isBidirectionalBindingExpression(String aValue) {
            return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
        }</B></FONT>

        private boolean processValue(Class sourceType, String propertyName, String aValue)
            throws LoadException {

            boolean processed = false;
                //process list or array first
                if (sourceType == null &amp;&amp; isTyped()) {
                    BeanAdapter valueAdapter = getValueAdapter();
                    Class&lt;?&gt; type = valueAdapter.getType(propertyName);

                    if (type == null) {
                        throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
                            + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
                    }

                    if (List.class.isAssignableFrom(type)
                        &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
                        populateListFromString(valueAdapter, propertyName, aValue);
                        processed = true;
                    } else if (type.isArray()) {
                        applyProperty(propertyName, sourceType,
                                populateArrayFromString(type, aValue));
                        processed = true;
                    }
                }
                if (!processed) {
                    applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
                    processed = true;
                }
                return processed;
        }

        /**
         * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
         */
        private Object resolvePrefixedValue(String aValue) throws LoadException {
            if (aValue.startsWith(ESCAPE_PREFIX)) {
                aValue = aValue.substring(ESCAPE_PREFIX.length());

                if (aValue.length() == 0
                    || !(aValue.startsWith(ESCAPE_PREFIX)
                        || aValue.startsWith(RELATIVE_PATH_PREFIX)
                        || aValue.startsWith(RESOURCE_KEY_PREFIX)
                        || aValue.startsWith(EXPRESSION_PREFIX)
                        || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
                    throw constructLoadException(&quot;Invalid escape sequence.&quot;);
                }
                return aValue;
            } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing relative path.&quot;);
                }
                if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
                    return aValue;
                } else {
                        if (aValue.charAt(0) == '/') {
                            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                            final URL res = getClassLoader().getResource(aValue.substring(1));
                            if (res == null) {
                                throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
                            }
                            return res.toString();
                        } else {
                            try {
                                return new URL(FXMLLoader.this.location, aValue).toString();
                            } catch (MalformedURLException e) {
                                System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
                            }
                        }
                }
            } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing resource key.&quot;);
                }
                if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
                    return aValue;
                } else {
                    // Resolve the resource value
                    if (resources == null) {
                        throw constructLoadException(&quot;No resources specified.&quot;);
                    }
                    if (!resources.containsKey(aValue)) {
                        throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
                    }

                    return resources.getString(aValue);
                }
            } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
                aValue = aValue.substring(EXPRESSION_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression.&quot;);
                }
                if (aValue.startsWith(EXPRESSION_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
                    return aValue;
                } else if (aValue.equals(NULL_KEYWORD)) {
                    // The attribute value is null
                    return null;
                }
                return Expression.get(namespace, KeyPath.parse(aValue));
            }
            return aValue;
        }

        /**
         * Creates an array of given type and populates it with values from
         * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
         * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
         * the array becomes relative to document location.
         */
        private Object populateArrayFromString(
                Class&lt;?&gt;type,
                String stringValue) throws LoadException {

            Object propertyValue = null;
            // Split the string and set the values as an array
            Class&lt;?&gt; componentType = type.getComponentType();

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
                propertyValue = Array.newInstance(componentType, values.length);
                for (int i = 0; i &lt; values.length; i++) {
                    Array.set(propertyValue, i,
                            BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
                            type.getComponentType()));
                }
            } else {
                propertyValue = Array.newInstance(componentType, 0);
            }
            return propertyValue;
        }

        /**
         * Populates list with values from a string where tokens are separated
         * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
         * a value added to the list becomes relative to document location.
         */
        private void populateListFromString(
                BeanAdapter valueAdapter,
                String listPropertyName,
                String stringValue) throws LoadException {
            // Split the string and add the values to the list
            List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
            Type listType = valueAdapter.getGenericType(listPropertyName);
            Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);

            if (itemType instanceof ParameterizedType) {
                itemType = ((ParameterizedType)itemType).getRawType();
            }

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);

                for (String aValue: values) {
                    aValue = aValue.trim();
                    list.add(
                            BeanAdapter.coerce(resolvePrefixedValue(aValue),
                                               (Class&lt;?&gt;)itemType));
                }
            }
        }

        public void warnDeprecatedEscapeSequence(String prefix) {
            System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
                + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
        }

        public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
            if (sourceType == null) {
                getProperties().put(name, value);
            } else {
                BeanAdapter.put(this.value, sourceType, name, value);
            }
        }

        private Object getExpressionObject(String handlerValue) throws LoadException{
            if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());

                if (handlerValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression reference.&quot;);
                }

                Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
                if (expression == null) {
                    throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
                }
                return expression;
            }
            return null;
        }

        private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
            Object expression = getExpressionObject(handlerValue);
            if (expression != null) {
                if (type.isInstance(expression)) {
                    return (T) expression;
                }
                throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
                        + &quot;Does not point to a &quot; + type.getName());
            }
            return null;
        }

        private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
            if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());

                if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    if (handlerName.length() == 0) {
                        throw constructLoadException(&quot;Missing controller method.&quot;);
                    }

                    if (controller == null) {
                        throw constructLoadException(&quot;No controller specified.&quot;);
                    }

                    for (SupportedType t : types) {
                        Method method = controllerAccessor
                                            .getControllerMethods()
                                            .get(t)
                                            .get(handlerName);
                        if (method != null) {
                            return new MethodHandler(controller, method, t);
                        }
                    }
                    Method method = controllerAccessor
                                        .getControllerMethods()
                                        .get(SupportedType.PARAMETERLESS)
                                        .get(handlerName);
                    if (method != null) {
                        return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
                    }

                    return null;

                }

            }
            return null;
        }

        public void processEventHandlerAttributes() throws LoadException {
            if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
                for (Attribute attribute : eventHandlerAttributes) {
                    String handlerName = attribute.value;
                    if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableListHandler(handlerName);
                    } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableMapHandler(handlerName);
                    } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableSetHandler(handlerName);
                    } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
                        processPropertyHandler(attribute.name, handlerName);
                    } else {
                        EventHandler&lt;? extends Event&gt; eventHandler = null;
                        MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
                        if (handler != null) {
                            eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
                        }

                        if (eventHandler == null) {
                            eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
                        }

                        if (eventHandler == null) {
                            if (handlerName.length() == 0 || scriptEngine == null) {
                                throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;='&quot; + attribute.value
                                        + &quot;', either the event handler is not in the Namespace or there is an error in the script.&quot;);
                            }

                            eventHandler = new ScriptEventHandler(handlerName, scriptEngine);
                        }

                        // Add the handler
                        getValueAdapter().put(attribute.name, eventHandler);
                    }
                }
            }
        }

        private void processObservableListHandler(String handlerValue) throws LoadException {
            ObservableList list = (ObservableList)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
                if (handler != null) {
                    list.addListener(new ObservableListChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                   if (listener instanceof ListChangeListener) {
                    list.addListener((ListChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    list.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableMapHandler(String handlerValue) throws LoadException {
            ObservableMap map = (ObservableMap)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
                if (handler != null) {
                    map.addListener(new ObservableMapChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof MapChangeListener) {
                    map.addListener((MapChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    map.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableSetHandler(String handlerValue) throws LoadException {
            ObservableSet set = (ObservableSet)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
                if (handler != null) {
                    set.addListener(new ObservableSetChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof SetChangeListener) {
                    set.addListener((SetChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    set.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {
            int i = EVENT_HANDLER_PREFIX.length();
            int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();

            if (i != j) {
                String key = Character.toLowerCase(attributeName.charAt(i))
                        + attributeName.substring(i + 1, j);

                ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
                if (propertyModel == null) {
                    throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
                            + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
                }

                if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
                    if (handler != null) {
                        if (handler.type == SupportedType.EVENT) {
                            // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
                            // has been used instead of usual property change parameters
                            propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
                                @Override
                                public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
                                    handler.invoke(new Event(value, null, Event.ANY));
                                }
                            });
                        } else {
                            propertyModel.addListener(new PropertyChangeAdapter(handler));
                        }
                    } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                    }
                } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                    Object listener = getExpressionObject(handlerValue);
                    if (listener instanceof ChangeListener) {
                        propertyModel.addListener((ChangeListener) listener);
                    } else if (listener instanceof InvalidationListener) {
                        propertyModel.addListener((InvalidationListener) listener);
                    } else {
                        throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                                + &quot;Must be either ChangeListener or InvalidationListener&quot;);
                    }
                }

            }
        }
    }

    // Element representing a value
    private abstract class ValueElement extends Element {
        public String fx_id = null;

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            updateValue(constructValue());

            if (value instanceof Builder&lt;?&gt;) {
                processInstancePropertyAttributes();
            } else {
                processValue();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processEndElement() throws IOException {
            super.processEndElement();

            // Build the value, if necessary
            if (value instanceof Builder&lt;?&gt;) {
                Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
                updateValue(builder.build());

                processValue();
            } else {
                processInstancePropertyAttributes();
            }

            processEventHandlerAttributes();

            // Process static property attributes
            if (staticPropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : staticPropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }

            // Process static property elements
            if (staticPropertyElements.size() &gt; 0) {
                for (PropertyElement element : staticPropertyElements) {
                    BeanAdapter.put(value, element.sourceType, element.name, element.value);
                }
            }

            if (parent != null) {
                if (parent.isCollection()) {
                    parent.add(value);
                } else {
                    parent.set(value);
                }
            }
        }

        private Object getListValue(Element parent, String listPropertyName, Object value) {
            // If possible, coerce the value to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(listPropertyName);

                if (listType != null) {
                    Type itemType = BeanAdapter.getGenericListItemType(listType);

                    if (itemType instanceof ParameterizedType) {
                        itemType = ((ParameterizedType)itemType).getRawType();
                    }

                    value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
                }
            }

            return value;
        }

        private void processValue() throws LoadException {
            // If this is the root element, update the value
            if (parent == null) {
                root = value;

                // checking version of fx namespace - throw exception if not supported
                String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
                if (fxNSURI != null) {
                    String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
                        throw constructLoadException(&quot;Loading FXML document of version &quot; +
                                fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
                    }
                }

                // checking the version JavaFX API - print warning if not supported
                String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
                if (defaultNSURI != null) {
                    String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
                        Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
                                nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
                    }
                }
            }

            // Add the value to the namespace
            if (fx_id != null) {
                namespace.put(fx_id, value);

                // If the value defines an ID property, set it
                IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);

                if (idProperty != null) {
                    Map&lt;String, Object&gt; properties = getProperties();
                    // set fx:id property value to Node.id only if Node.id was not
                    // already set when processing start element attributes
                    if (properties.get(idProperty.value()) == null) {
                        properties.put(idProperty.value(), fx_id);
                    }
                }

                // Set the controller field value
                injectFields(fx_id, value);
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processCharacters() throws LoadException {
            Class&lt;?&gt; type = value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

            // If the default property is a read-only list, add the value to it;
            // otherwise, set the value as the default property
            if (defaultProperty != null) {
                String text = xmlStreamReader.getText();
                text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

                String defaultPropertyName = defaultProperty.value();
                BeanAdapter valueAdapter = getValueAdapter();

                if (valueAdapter.isReadOnly(defaultPropertyName)
                    &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
                    List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
                    list.add(getListValue(this, defaultPropertyName, text));
                } else {
                    valueAdapter.put(defaultPropertyName, text.trim());
                }
            } else {
                throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_ID_ATTRIBUTE)) {
                    // Verify that ID is a valid identifier
                    if (value.equals(NULL_KEYWORD)) {
                        throw constructLoadException(&quot;Invalid identifier.&quot;);
                    }

                    for (int i = 0, n = value.length(); i &lt; n; i++) {
                        if (!Character.isJavaIdentifierPart(value.charAt(i))) {
                            throw constructLoadException(&quot;Invalid identifier.&quot;);
                        }
                    }

                    fx_id = value;

                } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
                    if (current.parent != null) {
                        throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
                            + &quot; can only be applied to root element.&quot;);
                    }

                    if (controller != null) {
                        throw constructLoadException(&quot;Controller value already specified.&quot;);
                    }

                    if (!staticLoad) {
                        Class&lt;?&gt; type;
                        try {
                            type = getClassLoader().loadClass(value);
                        } catch (ClassNotFoundException exception) {
                            throw constructLoadException(exception);
                        }

                        try {
                            if (controllerFactory == null) {
                                ReflectUtil.checkPackageAccess(type);
                                setController(type.newInstance());
                            } else {
                                setController(controllerFactory.call(type));
                            }
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                } else {
                    throw constructLoadException(&quot;Invalid attribute.&quot;);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        public abstract Object constructValue() throws IOException;
    }

    // Element representing a class instance
    private class InstanceDeclarationElement extends ValueElement {
        public Class&lt;?&gt; type;

        public String constant = null;
        public String factory = null;

        public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
            this.type = type;
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_VALUE_ATTRIBUTE)) {
                    this.value = value;
                } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
                    constant = value;
                } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
                    factory = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            Object value;
            if (this.value != null) {
                value = BeanAdapter.coerce(this.value, type);
            } else if (constant != null) {
                value = BeanAdapter.getConstantValue(type, constant);
            } else if (factory != null) {
                Method factoryMethod;
                try {
                    factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
                } catch (NoSuchMethodException exception) {
                    throw constructLoadException(exception);
                }

                try {
                    value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                if (value == null) {
                    value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                }

                if (value == null) {
                    try {
                        ReflectUtil.checkPackageAccess(type);
                        value = type.newInstance();
                    } catch (InstantiationException exception) {
                        throw constructLoadException(exception);
                    } catch (IllegalAccessException exception) {
                        throw constructLoadException(exception);
                    }
                }
            }

            return value;
        }
    }

    // Element representing an unknown type
    private class UnknownTypeElement extends ValueElement {
        // Map type representing an unknown value
        @DefaultProperty(&quot;items&quot;)
        public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
            private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
            private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();

            @Override
            public Object get(Object key) {
                if (key == null) {
                    throw new NullPointerException();
                }

                return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
                    items : values.get(key);
            }

            @Override
            public Object put(String key, Object value) {
                if (key == null) {
                    throw new NullPointerException();
                }

                if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
                    throw new IllegalArgumentException();
                }

                return values.put(key, value);
            }

            @Override
            public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
                return Collections.emptySet();
            }
        }

        @Override
        public void processEndElement() throws IOException {
            // No-op
        }

        @Override
        public Object constructValue() throws LoadException {
            return new UnknownValueMap();
        }
    }

    // Element representing an include
    private class IncludeElement extends ValueElement {
        public String source = null;
        public ResourceBundle resources = FXMLLoader.this.resources;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    resources = ResourceBundle.getBundle(value, Locale.getDefault(),
                            FXMLLoader.this.resources.getClass().getClassLoader());
                } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    charset = Charset.forName(value);
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            if (source == null) {
                throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            URL location;
            final ClassLoader cl = getClassLoader();
            if (source.charAt(0) == '/') {
            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                location = cl.getResource(source.substring(1));
                if (location == null) {
                    throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
                }
            } else {
                if (FXMLLoader.this.location == null) {
                    throw constructLoadException(&quot;Base location is undefined.&quot;);
                }

                location = new URL(FXMLLoader.this.location, source);
            }

            FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
                builderFactory, controllerFactory, charset,
                loaders);
            fxmlLoader.parentLoader = FXMLLoader.this;

            if (isCyclic(FXMLLoader.this, fxmlLoader)) {
                throw new IOException(
                        String.format(
                        &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
                        fxmlLoader.location.toExternalForm(),
                        FXMLLoader.this.location.toExternalForm()));
            }
            fxmlLoader.setClassLoader(cl);
            fxmlLoader.setStaticLoad(staticLoad);

            Object value = fxmlLoader.loadImpl(callerClass);

            if (fx_id != null) {
                String id = this.fx_id + CONTROLLER_SUFFIX;
                Object controller = fxmlLoader.getController();

                namespace.put(id, controller);
                injectFields(id, controller);
            }

            return value;
        }
    }

    private void injectFields(String fieldName, Object value) throws LoadException {
        if (controller != null &amp;&amp; fieldName != null) {
            List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
            if (fields != null) {
                try {
                    for (Field f : fields) {
                        f.set(controller, value);
                    }
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                }
            }
        }
    }

    // Element representing a reference
    private class ReferenceElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            return Expression.get(namespace, path);
        }
    }

    // Element representing a copy
    private class CopyElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            Object sourceValue = Expression.get(namespace, path);
            Class&lt;?&gt; sourceValueType = sourceValue.getClass();

            Constructor&lt;?&gt; constructor = null;
            try {
                constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            Object value;
            if (constructor != null) {
                try {
                    ReflectUtil.checkPackageAccess(sourceValueType);
                    value = constructor.newInstance(sourceValue);
                } catch (InstantiationException exception) {
                    throw constructLoadException(exception);
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                throw constructLoadException(&quot;Can't copy value &quot; + sourceValue + &quot;.&quot;);
            }

            return value;
        }
    }

    // Element representing a predefined root value
    private class RootElement extends ValueElement {
        public String type = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    type = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (type == null) {
                throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
            }

            Class&lt;?&gt; type = getType(this.type);

            if (type == null) {
                throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
            }

            Object value;
            if (root == null) {
                if (staticLoad) {
                    value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                    if (value == null) {
                        value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                    }

                    if (value == null) {
                        try {
                            ReflectUtil.checkPackageAccess(type);
                            value = type.newInstance();
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                    root = value;
                } else {
                    throw constructLoadException(&quot;Root hasn't been set. Use method setRoot() before load.&quot;);
                }
            } else {
                if (!type.isAssignableFrom(root.getClass())) {
                    throw constructLoadException(&quot;Root is not an instance of &quot;
                        + type.getName() + &quot;.&quot;);
                }

                value = root;
            }

            return value;
        }
    }

    // Element representing a property
    private class PropertyElement extends Element {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final boolean readOnly;

        public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }

            this.name = name;
            this.sourceType = sourceType;

            if (sourceType == null) {
                // The element represents an instance property
                if (name.startsWith(EVENT_HANDLER_PREFIX)) {
                    throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
                }

                Map&lt;String, Object&gt; parentProperties = parent.getProperties();

                if (parent.isTyped()) {
                    readOnly = parent.getValueAdapter().isReadOnly(name);
                } else {
                // If the map already defines a value for the property, assume
                    // that it is read-only
                    readOnly = parentProperties.containsKey(name);
                }

                if (readOnly) {
                    Object value = parentProperties.get(name);
                    if (value == null) {
                        throw constructLoadException(&quot;Invalid property.&quot;);
                    }

                    updateValue(value);
                }
            } else {
                // The element represents a static property
                readOnly = false;
            }
        }

        @Override
        public boolean isCollection() {
            return (readOnly) ? super.isCollection() : false;
        }

        @Override
        public void add(Object element) throws LoadException {
            // Coerce the element to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(name);
                element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
            }

            // Add the item to the list
            super.add(element);
        }

        @Override
        public void set(Object value) throws LoadException {
            // Update the value
            updateValue(value);

            if (sourceType == null) {
                // Apply value to parent element's properties
                parent.getProperties().put(name, value);
            } else {
                if (parent.value instanceof Builder) {
                    // Defer evaluation of the property
                    parent.staticPropertyElements.add(this);
                } else {
                    // Apply the static property value
                    BeanAdapter.put(parent.value, sourceType, name, value);
                }
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (!readOnly) {
                throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
            }

            super.processAttribute(prefix, localName, value);
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (readOnly) {
                processInstancePropertyAttributes();
                processEventHandlerAttributes();
            }
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();

            if (readOnly) {
                if (isCollection()) {
                    add(text);
                } else {
                    super.processCharacters();
                }
            } else {
                set(text);
            }
        }
    }

    // Element representing an unknown static property
    private class UnknownStaticPropertyElement extends Element {
        public UnknownStaticPropertyElement() throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }
        }

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void set(Object value) {
            updateValue(value);
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

            updateValue(text.trim());
        }
    }

    // Element representing a script block
    private class ScriptElement extends Element {
        public String source = null;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            if (source != null &amp;&amp; !staticLoad) {
                int i = source.lastIndexOf(&quot;.&quot;);
                if (i == -1) {
                    throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
                        + source + &quot;\&quot;.&quot;);
                }

                String extension = source.substring(i + 1);
                ScriptEngine engine;
                final ClassLoader cl = getClassLoader();
                if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
                    // If we have a page language and it's engine supports the extension, use the same engine
                    engine = scriptEngine;
                } else {
                    ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
                    try {
                        Thread.currentThread().setContextClassLoader(cl);
                        ScriptEngineManager scriptEngineManager = getScriptEngineManager();
                        engine = scriptEngineManager.getEngineByExtension(extension);
                    } finally {
                        Thread.currentThread().setContextClassLoader(oldLoader);
                    }
                }

                if (engine == null) {
                    throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
                        + &quot; extension &quot; + extension + &quot;.&quot;);
                }

                try {
                    URL location;
                    if (source.charAt(0) == '/') {
                        // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                        location = cl.getResource(source.substring(1));
                    } else {
                        if (FXMLLoader.this.location == null) {
                            throw constructLoadException(&quot;Base location is undefined.&quot;);
                        }

                        location = new URL(FXMLLoader.this.location, source);
                    }

                    InputStreamReader scriptReader = null;
                    try {
                        scriptReader = new InputStreamReader(location.openStream(), charset);
                        engine.eval(scriptReader);
                    } catch(ScriptException exception) {
                        exception.printStackTrace();
                    } finally {
                        if (scriptReader != null) {
                            scriptReader.close();
                        }
                    }
                } catch (IOException exception) {
                    throw constructLoadException(exception);
                }
            }
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (value != null &amp;&amp; !staticLoad) {
                // Evaluate the script
                try {
                    scriptEngine.eval((String)value);
                } catch (ScriptException exception) {
                    System.err.println(exception.getMessage());
                }
            }
        }

        @Override
        public void processCharacters() throws LoadException {
            if (source != null) {
                throw constructLoadException(&quot;Script source already specified.&quot;);
            }

            if (scriptEngine == null &amp;&amp; !staticLoad) {
                throw constructLoadException(&quot;Page language not specified.&quot;);
            }

            updateValue(xmlStreamReader.getText());
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null
                &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                source = value;
            } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                charset = Charset.forName(value);
            } else {
                throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }
    }

    // Element representing a define block
    private class DefineElement extends Element {
        @Override
        public boolean isCollection() {
            return true;
        }

        @Override
        public void add(Object element) {
            // No-op
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws LoadException{
            throw constructLoadException(&quot;Element does not support attributes.&quot;);
        }
    }

    // Class representing an attribute of an element
    private static class Attribute {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final String value;

        public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
            this.name = name;
            this.sourceType = sourceType;
            this.value = value;
        }
    }

    // Event handler that delegates to a method defined by the controller object
    private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
        private final MethodHandler handler;

        public ControllerMethodEventHandler(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void handle(T event) {
            handler.invoke(event);
        }
    }

    // Event handler implemented in script code
    private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
        public final String script;
        public final ScriptEngine scriptEngine;

        public ScriptEventHandler(String script, ScriptEngine scriptEngine) {
            this.script = script;
            this.scriptEngine = scriptEngine;
        }

        @Override
        public void handle(Event event) {
            // Don't pollute the page namespace with values defined in the script
            Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
            Bindings localBindings = scriptEngine.createBindings();
            localBindings.put(EVENT_KEY, event);
            localBindings.putAll(engineBindings);
            scriptEngine.setBindings(localBindings, ScriptContext.ENGINE_SCOPE);

            // Execute the script
            try {
                scriptEngine.eval(script);
            } catch (ScriptException exception){
                throw new RuntimeException(exception);
            }

            // Restore the original bindings
            scriptEngine.setBindings(engineBindings, ScriptContext.ENGINE_SCOPE);
        }
    }

    // Observable list change listener
    private static class ObservableListChangeAdapter implements ListChangeListener {
        private final MethodHandler handler;

        public ObservableListChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable map change listener
    private static class ObservableMapChangeAdapter implements MapChangeListener {
        public final MethodHandler handler;

        public ObservableMapChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable set change listener
    private static class ObservableSetChangeAdapter implements SetChangeListener {
        public final MethodHandler handler;

        public ObservableSetChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Property model change listener
    private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
        public final MethodHandler handler;

        public PropertyChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
            handler.invoke(observable, oldValue, newValue);
        }
    }

    private static class MethodHandler {
        private final Object controller;
        private final Method method;
        private final SupportedType type;

        private MethodHandler(Object controller, Method method, SupportedType type) {
            this.method = method;
            this.controller = controller;
            this.type = type;
        }

        public void invoke(Object... params) {
            try {
                if (type != SupportedType.PARAMETERLESS) {
                    MethodHelper.invoke(method, controller, params);
                } else {
                    MethodHelper.invoke(method, controller, new Object[] {});
                }
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            }
        }
    }

    private URL location;
    private ResourceBundle resources;

    private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();

    private Object root = null;
    private Object controller = null;

    private BuilderFactory builderFactory;
    private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
    private Charset charset;

    private final LinkedList&lt;FXMLLoader&gt; loaders;

    private ClassLoader classLoader = null;
    private boolean staticLoad = false;
    private LoadListener loadListener = null;

    private FXMLLoader parentLoader;

    private XMLStreamReader xmlStreamReader = null;
    private Element current = null;

    private ScriptEngine scriptEngine = null;

    private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
    private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();

    private ScriptEngineManager scriptEngineManager = null;

    private static ClassLoader defaultClassLoader = null;

    private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);

    private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();

    /**
     * The character set used when character set is not explicitly specified.
     */
    public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;

    /**
     * The tag name of language processing instruction.
     */
    public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
    /**
     * The tag name of import processing instruction.
     */
    public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;

    /**
     * Prefix of 'fx' namespace.
     */
    public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
    /**
     * The name of fx:controller attribute of a root.
     */
    public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
    /**
     * The name of fx:id attribute.
     */
    public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
    /**
     * The name of fx:value attribute.
     */
    public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
    /**
     * The tag name of 'fx:constant'.
     * @since JavaFX 2.2
     */
    public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
    /**
     * The name of 'fx:factory' attribute.
     */
    public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;

    /**
     * The tag name of {@literal &lt;fx:include&gt;}.
     */
    public static final String INCLUDE_TAG = &quot;include&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'source' attribute.
     */
    public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'resources' attribute.
     */
    public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'charset' attribute.
     */
    public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:script&gt;}.
     */
    public static final String SCRIPT_TAG = &quot;script&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'source' attribute.
     */
    public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'charset' attribute.
     */
    public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:define&gt;}.
     */
    public static final String DEFINE_TAG = &quot;define&quot;;

    /**
     * The tag name of {@literal &lt;fx:reference&gt;}.
     */
    public static final String REFERENCE_TAG = &quot;reference&quot;;
    /**
     * The {@literal &lt;fx:reference&gt;} 'source' attribute.
     */
    public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The tag name of {@literal &lt;fx:root&gt;}.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TAG = &quot;root&quot;;
    /**
     * The {@literal &lt;fx:root&gt;} 'type' attribute.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;

    /**
     * The tag name of {@literal &lt;fx:copy&gt;}.
     */
    public static final String COPY_TAG = &quot;copy&quot;;
    /**
     * The {@literal &lt;fx:copy&gt;} 'source' attribute.
     */
    public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The prefix of event handler attributes.
     */
    public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
    /**
     * The name of the Event object in event handler scripts.
     */
    public static final String EVENT_KEY = &quot;event&quot;;
    /**
     * Suffix for property change/invalidation handlers.
     */
    public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
    private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;

    /**
     * Value that represents 'null'.
     */
    public static final String NULL_KEYWORD = &quot;null&quot;;

    /**
     * Escape prefix for escaping special characters inside attribute values.
     * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
     * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
     * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
     * @since JavaFX 2.1
     */
    public static final String ESCAPE_PREFIX = &quot;\\&quot;;
    /**
     * Prefix for relative location resolution.
     */
    public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
    /**
     * Prefix for resource resolution.
     */
    public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
    /**
     * Prefix for (variable) expression resolution.
     */
    public static final String EXPRESSION_PREFIX = &quot;$&quot;;
    /**
     * Prefix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
    /**
     * Suffix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;

    /**
     * Prefix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
    /**
     * Suffix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;

    /**
     * Delimiter for arrays as values.
     * @since JavaFX 2.1
     */
    public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;

    /**
     * A key for location URL in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String LOCATION_KEY = &quot;location&quot;;
    /**
     * A key for ResourceBundle in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String RESOURCES_KEY = &quot;resources&quot;;

    /**
     * Prefix for controller method resolution.
     */
    public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
    /**
     * A key for controller in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.1
     */
    public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
    /**
     * A suffix for controllers of included fxml files.
     * The full key is stored in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;

    /**
     * The name of initialize method.
     * @since JavaFX 2.2
     */
    public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;

    /**
     * Contains the current javafx version.
     * @since JavaFX 8.0
     */
    public static final String JAVAFX_VERSION;

    /**
     * Contains the current fx namepsace version.
     * @since JavaFX 8.0
     */
    public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;

    static {
        JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            @Override
            public String run() {
                return System.getProperty(&quot;javafx.version&quot;);
            }
        });

        FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
            @Override
            public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
                fxmlLoader.setStaticLoad(staticLoad);
            }
        });
    }

    /**
     * Creates a new FXMLLoader instance.
     */
    public FXMLLoader() {
        this((URL)null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location) {
        this(location, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources) {
        this(location, resources, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
        this(location, resources, builderFactory, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param charset the character set used by this loader
     */
    public FXMLLoader(Charset charset) {
        this(null, null, null, null, charset);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
        this(location, resources, builderFactory, controllerFactory, charset,
            new LinkedList&lt;FXMLLoader&gt;());
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @param loaders list of loaders
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
        LinkedList&lt;FXMLLoader&gt; loaders) {
        setLocation(location);
        setResources(resources);
        setBuilderFactory(builderFactory);
        setControllerFactory(controllerFactory);
        setCharset(charset);

        this.loaders = new LinkedList(loaders);
    }

    /**
     * Returns the location used to resolve relative path attribute values.
     * @return the location used to resolve relative path attribute values
     */
    public URL getLocation() {
        return location;
    }

    /**
     * Sets the location used to resolve relative path attribute values.
     *
     * @param location the location
     */
    public void setLocation(URL location) {
        this.location = location;
    }

    /**
     * Returns the resources used to resolve resource key attribute values.
     * @return the resources used to resolve resource key attribute values
     */
    public ResourceBundle getResources() {
        return resources;
    }

    /**
     * Sets the resources used to resolve resource key attribute values.
     *
     * @param resources the resources
     */
    public void setResources(ResourceBundle resources) {
        this.resources = resources;
    }

    /**
     * Returns the namespace used by this loader.
     * @return the namespace
     */
    public ObservableMap&lt;String, Object&gt; getNamespace() {
        return namespace;
    }

    /**
     * Returns the root of the object hierarchy.
     * @param &lt;T&gt; the type of the root object
     * @return the root of the object hierarchy
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getRoot() {
        return (T)root;
    }

    /**
     * Sets the root of the object hierarchy. The value passed to this method
     * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
     * must be called prior to loading the document when using
     * {@code &lt;fx:root&gt;}.
     *
     * @param root the root of the object hierarchy
     *
     * @since JavaFX 2.2
     */
    public void setRoot(Object root) {
        this.root = root;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof FXMLLoader) {
            FXMLLoader loader = (FXMLLoader)obj;
            if (location == null || loader.location == null) {
                return loader.location == location;
            }
            return location.toExternalForm().equals(
                    loader.location.toExternalForm());
        }
        return false;
    }

    private boolean isCyclic(
                            FXMLLoader currentLoader,
                            FXMLLoader node) {
        if (currentLoader == null) {
            return false;
        }
        if (currentLoader.equals(node)) {
            return true;
        }
        return isCyclic(currentLoader.parentLoader, node);
    }

    /**
     * Returns the controller associated with the root object.
     * @param &lt;T&gt; the type of the controller
     * @return the controller associated with the root object
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getController() {
        return (T)controller;
    }

    /**
     * Sets the controller associated with the root object. The value passed to
     * this method is used as the value of the {@code fx:controller} attribute.
     * This method must be called prior to loading the document when using
     * controller event handlers when an {@code fx:controller} attribute is not
     * specified in the document.
     *
     * @param controller the controller to associate with the root object
     *
     * @since JavaFX 2.2
     */
    public void setController(Object controller) {
        this.controller = controller;

        if (controller == null) {
            namespace.remove(CONTROLLER_KEYWORD);
        } else {
            namespace.put(CONTROLLER_KEYWORD, controller);
        }

        controllerAccessor.setController(controller);
    }

    /**
     * Returns the builder factory used by this loader.
     * @return the builder factory
     */
    public BuilderFactory getBuilderFactory() {
        return builderFactory;
    }

    /**
     * Sets the builder factory used by this loader.
     *
     * @param builderFactory the builder factory
     */
    public void setBuilderFactory(BuilderFactory builderFactory) {
        this.builderFactory = builderFactory;
    }

    /**
     * Returns the controller factory used by this loader.
     * @return the controller factory
     * @since JavaFX 2.1
     */
    public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
        return controllerFactory;
    }

    /**
     * Sets the controller factory used by this loader.
     *
     * @param controllerFactory the controller factory
     * @since JavaFX 2.1
     */
    public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this.controllerFactory = controllerFactory;
    }

    /**
     * Returns the character set used by this loader.
     * @return the character set
     */
    public Charset getCharset() {
        return charset;
    }

    /**
     * Sets the character set used by this loader.
     *
     * @param charset the character set
     * @since JavaFX 2.1
     */
    public void setCharset(Charset charset) {
        if (charset == null) {
            throw new NullPointerException(&quot;charset is null.&quot;);
        }

        this.charset = charset;
    }

    /**
     * Returns the classloader used by this loader.
     * @return the classloader
     * @since JavaFX 2.1
     */
    public ClassLoader getClassLoader() {
        if (classLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            final Class caller = (sm != null) ?
                    walker.getCallerClass() :
                    null;
            return getDefaultClassLoader(caller);
        }
        return classLoader;
    }

    /**
     * Sets the classloader used by this loader and clears any existing
     * imports.
     *
     * @param classLoader the classloader
     * @since JavaFX 2.1
     */
    public void setClassLoader(ClassLoader classLoader) {
        if (classLoader == null) {
            throw new IllegalArgumentException();
        }

        this.classLoader = classLoader;

        clearImports();
    }

    /*
     * Returns the static load flag.
     */
    boolean isStaticLoad() {
        // SB-dependency: RT-21226 has been filed to track this
        return staticLoad;
    }

    /*
     * Sets the static load flag.
     *
     * @param staticLoad
     */
    void setStaticLoad(boolean staticLoad) {
        // SB-dependency: RT-21226 has been filed to track this
        this.staticLoad = staticLoad;
    }

    /**
     * Returns this loader's load listener.
     *
     * @return the load listener
     *
     * @since 9
     */
    public LoadListener getLoadListener() {
        // SB-dependency: RT-21228 has been filed to track this
        return loadListener;
    }

    /**
     * Sets this loader's load listener.
     *
     * @param loadListener the load listener
     *
     * @since 9
     */
    public final void setLoadListener(LoadListener loadListener) {
        // SB-dependency: RT-21228 has been filed to track this
        this.loadListener = loadListener;
    }

    /**
     * Loads an object hierarchy from a FXML document. The location from which
     * the document will be loaded must have been set by a prior call to
     * {@link #setLocation(URL)}.
     *
     * @param &lt;T&gt; the type of the root object
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public &lt;T&gt; T load() throws IOException {
        return loadImpl((System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param inputStream an input stream containing the FXML data to load
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public &lt;T&gt; T load(InputStream inputStream) throws IOException {
        return loadImpl(inputStream, (System.getSecurityManager() != null)
                                         ? walker.getCallerClass()
                                         : null);
    }

    private Class&lt;?&gt; callerClass;

    private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
        if (location == null) {
            throw new IllegalStateException(&quot;Location is not set.&quot;);
        }

        InputStream inputStream = null;
        T value;
        try {
            inputStream = location.openStream();
            value = loadImpl(inputStream, callerClass);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return value;
    }

    @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
    private &lt;T&gt; T loadImpl(InputStream inputStream,
                           Class&lt;?&gt; callerClass) throws IOException {
        if (inputStream == null) {
            throw new NullPointerException(&quot;inputStream is null.&quot;);
        }

        this.callerClass = callerClass;
        controllerAccessor.setCallerClass(callerClass);
        try {
            clearImports();

            // Initialize the namespace
            namespace.put(LOCATION_KEY, location);
            namespace.put(RESOURCES_KEY, resources);

            // Clear the script engine
            scriptEngine = null;

            // Create the parser
            try {
                XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);

                // Some stream readers incorrectly report an empty string as the prefix
                // for the default namespace; correct this as needed
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
                xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
                    @Override
                    public String getPrefix() {
                        String prefix = super.getPrefix();

                        if (prefix != null
                            &amp;&amp; prefix.length() == 0) {
                            prefix = null;
                        }

                        return prefix;
                    }

                    @Override
                    public String getAttributePrefix(int index) {
                        String attributePrefix = super.getAttributePrefix(index);

                        if (attributePrefix != null
                            &amp;&amp; attributePrefix.length() == 0) {
                            attributePrefix = null;
                        }

                        return attributePrefix;
                    }
                };
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            // Push this loader onto the stack
            loaders.push(this);

            // Parse the XML stream
            try {
                while (xmlStreamReader.hasNext()) {
                    int event = xmlStreamReader.next();

                    switch (event) {
                        case XMLStreamConstants.PROCESSING_INSTRUCTION: {
                            processProcessingInstruction();
                            break;
                        }

                        case XMLStreamConstants.COMMENT: {
                            processComment();
                            break;
                        }

                        case XMLStreamConstants.START_ELEMENT: {
                            processStartElement();
                            break;
                        }

                        case XMLStreamConstants.END_ELEMENT: {
                            processEndElement();
                            break;
                        }

                        case XMLStreamConstants.CHARACTERS: {
                            processCharacters();
                            break;
                        }
                    }
                }
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            if (controller != null) {
                if (controller instanceof Initializable) {
                    ((Initializable)controller).initialize(location, resources);
                } else {
                    // Inject controller fields
                    Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
                            controllerAccessor.getControllerFields();

                    injectFields(LOCATION_KEY, location);

                    injectFields(RESOURCES_KEY, resources);

                    // Initialize the controller
                    Method initializeMethod = controllerAccessor
                                                  .getControllerMethods()
                                                  .get(SupportedType.PARAMETERLESS)
                                                  .get(INITIALIZE_METHOD_NAME);

                    if (initializeMethod != null) {
                        try {
                            MethodHelper.invoke(initializeMethod, controller, new Object [] {});
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        } catch (InvocationTargetException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                }
            }
        } catch (final LoadException exception) {
            throw exception;
        } catch (final Exception exception) {
            throw constructLoadException(exception);
        } finally {
            controllerAccessor.setCallerClass(null);
            // Clear controller accessor caches
            controllerAccessor.reset();
            // Clear the parser
            xmlStreamReader = null;
        }

        return (T)root;
    }

    private void clearImports() {
        packages.clear();
        classes.clear();
    }

    private LoadException constructLoadException(String message){
        return new LoadException(message + constructFXMLTrace());
    }

    private LoadException constructLoadException(Throwable cause) {
        return new LoadException(constructFXMLTrace(), cause);
    }

    private LoadException constructLoadException(String message, Throwable cause){
        return new LoadException(message + constructFXMLTrace(), cause);
    }

    private String constructFXMLTrace() {
        StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);

        for (FXMLLoader loader : loaders) {
            messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);

            if (loader.current != null) {
                messageBuilder.append(&quot;:&quot;);
                messageBuilder.append(loader.getLineNumber());
            }

            messageBuilder.append(&quot;\n&quot;);
        }
        return messageBuilder.toString();
    }

    /**
     * Returns the current line number.
     */
    int getLineNumber() {
        return xmlStreamReader.getLocation().getLineNumber();
    }

    /**
     * Returns the current parse trace.
     */
    ParseTraceElement[] getParseTrace() {
        ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];

        int i = 0;
        for (FXMLLoader loader : loaders) {
            parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
                loader.getLineNumber() : -1);
        }

        return parseTrace;
    }

    private void processProcessingInstruction() throws LoadException {
        String piTarget = xmlStreamReader.getPITarget().trim();

        if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
            processLanguage();
        } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
            processImport();
        }
    }

    private void processLanguage() throws LoadException {
        if (scriptEngine != null) {
            throw constructLoadException(&quot;Page language already set.&quot;);
        }

        String language = xmlStreamReader.getPIData();

        if (loadListener != null) {
            loadListener.readLanguageProcessingInstruction(language);
        }

        if (!staticLoad) {
            ScriptEngineManager scriptEngineManager = getScriptEngineManager();
            scriptEngine = scriptEngineManager.getEngineByName(language);
        }
    }

    private void processImport() throws LoadException {
        String target = xmlStreamReader.getPIData().trim();

        if (loadListener != null) {
            loadListener.readImportProcessingInstruction(target);
        }

        if (target.endsWith(&quot;.*&quot;)) {
            importPackage(target.substring(0, target.length() - 2));
        } else {
            importClass(target);
        }
    }

    private void processComment() throws LoadException {
        if (loadListener != null) {
            loadListener.readComment(xmlStreamReader.getText());
        }
    }

    private void processStartElement() throws IOException {
        // Create the element
        createElement();

        // Process the start tag
        current.processStartElement();

        // Set the root value
        if (root == null) {
            root = current.value;
        }
    }

    private void createElement() throws IOException {
        String prefix = xmlStreamReader.getPrefix();
        String localName = xmlStreamReader.getLocalName();

        if (prefix == null) {
            int i = localName.lastIndexOf('.');

            if (Character.isLowerCase(localName.charAt(i + 1))) {
                String name = localName.substring(i + 1);

                if (i == -1) {
                    // This is an instance property
                    if (loadListener != null) {
                        loadListener.beginPropertyElement(name, null);
                    }

                    current = new PropertyElement(name, null);
                } else {
                    // This is a static property
                    Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                    if (sourceType != null) {
                        if (loadListener != null) {
                            loadListener.beginPropertyElement(name, sourceType);
                        }

                        current = new PropertyElement(name, sourceType);
                    } else if (staticLoad) {
                        // The source type was not recognized
                        if (loadListener != null) {
                            loadListener.beginUnknownStaticPropertyElement(localName);
                        }

                        current = new UnknownStaticPropertyElement();
                    } else {
                        throw constructLoadException(localName + &quot; is not a valid property.&quot;);
                    }
                }
            } else {
                if (current == null &amp;&amp; root != null) {
                    throw constructLoadException(&quot;Root value already specified.&quot;);
                }

                Class&lt;?&gt; type = getType(localName);

                if (type != null) {
                    if (loadListener != null) {
                        loadListener.beginInstanceDeclarationElement(type);
                    }

                    current = new InstanceDeclarationElement(type);
                } else if (staticLoad) {
                    // The type was not recognized
                    if (loadListener != null) {
                        loadListener.beginUnknownTypeElement(localName);
                    }

                    current = new UnknownTypeElement();
                } else {
                    throw constructLoadException(localName + &quot; is not a valid type.&quot;);
                }
            }
        } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
            if (localName.equals(INCLUDE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginIncludeElement();
                }

                current = new IncludeElement();
            } else if (localName.equals(REFERENCE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginReferenceElement();
                }

                current = new ReferenceElement();
            } else if (localName.equals(COPY_TAG)) {
                if (loadListener != null) {
                    loadListener.beginCopyElement();
                }

                current = new CopyElement();
            } else if (localName.equals(ROOT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginRootElement();
                }

                current = new RootElement();
            } else if (localName.equals(SCRIPT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginScriptElement();
                }

                current = new ScriptElement();
            } else if (localName.equals(DEFINE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginDefineElement();
                }

                current = new DefineElement();
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
            }
        } else {
            throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
        }
    }

    private void processEndElement() throws IOException {
        current.processEndElement();

        if (loadListener != null) {
            loadListener.endElement(current.value);
        }

        // Move up the stack
        current = current.parent;
    }

    private void processCharacters() throws IOException {
        // Process the characters
        if (!xmlStreamReader.isWhiteSpace()) {
            current.processCharacters();
        }
    }

    private void importPackage(String name) throws LoadException {
        packages.add(name);
    }

    private void importClass(String name) throws LoadException {
        try {
            loadType(name, true);
        } catch (ClassNotFoundException exception) {
            throw constructLoadException(exception);
        }
    }

    private Class&lt;?&gt; getType(String name) throws LoadException {
        Class&lt;?&gt; type = null;

        if (Character.isLowerCase(name.charAt(0))) {
            // This is a fully-qualified class name
            try {
                type = loadType(name, false);
            } catch (ClassNotFoundException exception) {
                // No-op
            }
        } else {
            // This is an unqualified class name
            type = classes.get(name);

            if (type == null) {
                // The class has not been loaded yet; look it up
                for (String packageName : packages) {
                    try {
                        type = loadTypeForPackage(packageName, name);
                    } catch (ClassNotFoundException exception) {
                        // No-op
                    }

                    if (type != null) {
                        break;
                    }
                }

                if (type != null) {
                    classes.put(name, type);
                }
            }
        }

        return type;
    }

    private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
        int i = name.indexOf('.');
        int n = name.length();
        while (i != -1
            &amp;&amp; i &lt; n
            &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
            i = name.indexOf('.', i + 1);
        }

        if (i == -1 || i == n) {
            throw new ClassNotFoundException();
        }

        String packageName = name.substring(0, i);
        String className = name.substring(i + 1);

        Class&lt;?&gt; type = loadTypeForPackage(packageName, className);

        if (cache) {
            classes.put(className, type);
        }

        return type;
    }

    // TODO Rename to loadType() when deprecated static version is removed
    private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
        return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    private static enum SupportedType {
        PARAMETERLESS {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 0;
            }

        },
        EVENT {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        Event.class.isAssignableFrom(m.getParameterTypes()[0]);
            }

        },
        LIST_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
            }

        },
        MAP_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
            }

        },
        SET_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
            }

        },
        PROPERTY_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 3 &amp;&amp;
                        ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
                        &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
            }

        };

        protected abstract boolean methodIsOfType(Method m);
    }

    private static SupportedType toSupportedType(Method m) {
        for (SupportedType t : SupportedType.values()) {
            if (t.methodIsOfType(m)) {
                return t;
            }
        }
        return null;
    }

    private ScriptEngineManager getScriptEngineManager() {
        if (scriptEngineManager == null) {
            scriptEngineManager = new javax.script.ScriptEngineManager();
            scriptEngineManager.setBindings(new SimpleBindings(namespace));
        }

        return scriptEngineManager;
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param packageName the package name of the class to load
     * @param className the name of the class to load
     *
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
        return loadType(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param className the name of the class to load
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
        ReflectUtil.checkPackageAccess(className);
        return Class.forName(className, true, getDefaultClassLoader());
    }

    private static boolean needsClassLoaderPermissionCheck(Class caller) {
        if (caller == null) {
            return false;
        }
        return !FXMLLoader.class.getModule().equals(caller.getModule());
    }

    private static ClassLoader getDefaultClassLoader(Class caller) {
        if (defaultClassLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                if (needsClassLoaderPermissionCheck(caller)) {
                    sm.checkPermission(GET_CLASSLOADER_PERMISSION);
                }
            }
            return Thread.currentThread().getContextClassLoader();
        }
        return defaultClassLoader;
    }

    /**
     * Returns the default class loader.
     * @return the default class loader
     * @since JavaFX 2.1
     */
    public static ClassLoader getDefaultClassLoader() {
        final SecurityManager sm = System.getSecurityManager();
        final Class caller = (sm != null) ?
                walker.getCallerClass() :
                null;
        return getDefaultClassLoader(caller);
    }

    /**
     * Sets the default class loader.
     *
     * @param defaultClassLoader
     * The default class loader to use when loading classes.
     * @since JavaFX 2.1
     */
    public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
        if (defaultClassLoader == null) {
            throw new NullPointerException();
        }
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }

        FXMLLoader.defaultClassLoader = defaultClassLoader;
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location) throws IOException {
        return loadImpl(location, (System.getSecurityManager() != null)
                                      ? walker.getCallerClass()
                                      : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
            throws IOException {
        return loadImpl(location, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources)
                                     throws IOException {
        return loadImpl(location, resources,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources,  null,
                        callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used to load the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     * @param charset the character set used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                             Charset charset) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        charset,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Charset charset, Class&lt;?&gt; callerClass)
                                          throws IOException {
        if (location == null) {
            throw new NullPointerException(&quot;Location is required.&quot;);
        }

        FXMLLoader fxmlLoader =
                new FXMLLoader(location, resources, builderFactory,
                               controllerFactory, charset);

        return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
    }

    /**
     * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
     * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
     * @param nsVer String representation of JavaFX version to compare against runtime version
     * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
     *          number &amp;gt; 0 if runtime is higher version
     */
    static int compareJFXVersions(String rtVer, String nsVer) {

        int retVal = 0;

        if (rtVer == null || &quot;&quot;.equals(rtVer) ||
            nsVer == null || &quot;&quot;.equals(nsVer)) {
            return retVal;
        }

        if (rtVer.equals(nsVer)) {
            return retVal;
        }

        // version string can contain '-'
        int dashIndex = rtVer.indexOf(&quot;-&quot;);
        if (dashIndex &gt; 0) {
            rtVer = rtVer.substring(0, dashIndex);
        }

        // or &quot;_&quot;
        int underIndex = rtVer.indexOf(&quot;_&quot;);
        if (underIndex &gt; 0) {
            rtVer = rtVer.substring(0, underIndex);
        }

        // do not try to compare if the string is not valid version format
        if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
            !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
            return retVal;
        }

        StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
        StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
        int nsDigit = 0, rtDigit = 0;
        boolean rtVerEnd = false;

        while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
            if (rtVerTokenizer.hasMoreTokens()) {
                rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
                retVal = rtDigit - nsDigit;
            } else {
                rtVerEnd = true;
                break;
            }
        }

        if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
            if (rtDigit &gt; 0) {
                retVal = 1;
            }
        }

        if (rtVerEnd) {
            if (nsDigit &gt; 0) {
                retVal = -1;
            } else {
                while (nsVerTokenizer.hasMoreTokens()) {
                    nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
                    if (nsDigit &gt; 0) {
                        retVal = -1;
                        break;
                    }
                }
            }
        }

        return retVal;
    }

    private static void checkClassLoaderPermission() {
        final SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }
    }

    private final ControllerAccessor controllerAccessor =
            new ControllerAccessor();

    private static final class ControllerAccessor {
        private static final int PUBLIC = 1;
        private static final int PROTECTED = 2;
        private static final int PACKAGE = 4;
        private static final int PRIVATE = 8;
        private static final int INITIAL_CLASS_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;
        private static final int INITIAL_MEMBER_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;

        private static final int METHODS = 0;
        private static final int FIELDS = 1;

        private Object controller;
        private ClassLoader callerClassLoader;

        private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
        private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;

        void setController(final Object controller) {
            if (this.controller != controller) {
                this.controller = controller;
                reset();
            }
        }

        void setCallerClass(final Class&lt;?&gt; callerClass) {
            final ClassLoader newCallerClassLoader =
                    (callerClass != null) ? callerClass.getClassLoader()
                                          : null;
            if (callerClassLoader != newCallerClassLoader) {
                callerClassLoader = newCallerClassLoader;
                reset();
            }
        }

        void reset() {
            controllerFields = null;
            controllerMethods = null;
        }

        Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
            if (controllerFields == null) {
                controllerFields = new HashMap&lt;&gt;();

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     FIELDS);
            }

            return controllerFields;
        }

        Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
            if (controllerMethods == null) {
                controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
                for (SupportedType t: SupportedType.values()) {
                    controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
                }

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     METHODS);
            }

            return controllerMethods;
        }

        private void addAccessibleMembers(final Class&lt;?&gt; type,
                                          final int prevAllowedClassAccess,
                                          final int prevAllowedMemberAccess,
                                          final int membersType) {
            if (type == Object.class) {
                return;
            }

            int allowedClassAccess = prevAllowedClassAccess;
            int allowedMemberAccess = prevAllowedMemberAccess;
            if ((callerClassLoader != null)
                    &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
                // restrict further access
                allowedClassAccess &amp;= PUBLIC;
                allowedMemberAccess &amp;= PUBLIC;
            }

            final int classAccess = getAccess(type.getModifiers());
            if ((classAccess &amp; allowedClassAccess) == 0) {
                // we are done
                return;
            }

            ReflectUtil.checkPackageAccess(type);

            addAccessibleMembers(type.getSuperclass(),
                                 allowedClassAccess,
                                 allowedMemberAccess,
                                 membersType);

            final int finalAllowedMemberAccess = allowedMemberAccess;
            AccessController.doPrivileged(
                    new PrivilegedAction&lt;Void&gt;() {
                        @Override
                        public Void run() {
                            if (membersType == FIELDS) {
                                addAccessibleFields(type,
                                                    finalAllowedMemberAccess);
                            } else {
                                addAccessibleMethods(type,
                                                     finalAllowedMemberAccess);
                            }

                            return null;
                        }
                    });
        }

        private void addAccessibleFields(final Class&lt;?&gt; type,
                                         final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Field[] fields = type.getDeclaredFields();
            for (int i = 0; i &lt; fields.length; ++i) {
                final Field field = fields[i];
                final int memberModifiers = field.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.FINAL)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (field.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public field
                        continue;
                    }

                    // Ensure that the field is accessible
                    field.setAccessible(true);
                }

                List&lt;Field&gt; list = controllerFields.get(field.getName());
                if (list == null) {
                    list = new ArrayList&lt;&gt;(1);
                    controllerFields.put(field.getName(), list);
                }
                list.add(field);

            }
        }

        private void addAccessibleMethods(final Class&lt;?&gt; type,
                                          final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Method[] methods = type.getDeclaredMethods();
            for (int i = 0; i &lt; methods.length; ++i) {
                final Method method = methods[i];
                final int memberModifiers = method.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.NATIVE)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (method.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public method
                        continue;
                    }

                    // Ensure that the method is accessible
                    method.setAccessible(true);
                }

                // Add this method to the map if:
                // a) it is the initialize() method, or
                // b) it takes a single event argument, or
                // c) it takes no arguments and a handler with this
                //    name has not already been defined
                final String methodName = method.getName();
                final SupportedType convertedType;

                if ((convertedType = toSupportedType(method)) != null) {
                    controllerMethods.get(convertedType)
                                     .put(methodName, method);
                }
            }
        }

        private static int getAccess(final int fullModifiers) {
            final int untransformedAccess =
                    fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
                                                      | Modifier.PUBLIC);

            switch (untransformedAccess) {
                case Modifier.PUBLIC:
                    return PUBLIC;

                case Modifier.PROTECTED:
                    return PROTECTED;

                case Modifier.PRIVATE:
                    return PRIVATE;

                default:
                    return PACKAGE;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/mac/MacApplication.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.mac;

import com.sun.glass.events.KeyEvent;
import com.sun.glass.ui.*;
import com.sun.glass.ui.CommonDialogs.ExtensionFilter;
import com.sun.glass.ui.CommonDialogs.FileChooserResult;

import java.io.File;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import java.security.AccessController;
import java.security.PrivilegedAction;

final class MacApplication extends Application implements InvokeLaterDispatcher.InvokeLaterSubmitter {

    private native static void _initIDs(boolean disableSyncRendering);
    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            Application.loadNativeLibrary();
            return null;
        });
        boolean disableSyncRendering = AccessController
                .doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
                        Boolean.getBoolean(&quot;glass.disableSyncRendering&quot;));
        _initIDs(disableSyncRendering);
    }

    native static int _getMacKey(int code);

    private boolean isTaskbarApplication = false;
    private final InvokeLaterDispatcher invokeLaterDispatcher;

    MacApplication() {
        // Embedded in SWT, with shared event thread
        boolean isEventThread = AccessController
                .doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.embed.isEventThread&quot;));
        if (!isEventThread) {
            invokeLaterDispatcher = new InvokeLaterDispatcher(this);
            invokeLaterDispatcher.start();
        } else {
            invokeLaterDispatcher = null;
        }
    }

    private Menu appleMenu;

    native void _runLoop(ClassLoader classLoader, Runnable launchable,
                         boolean isTaskbarApplication);
    @Override
    protected void runLoop(final Runnable launchable) {
        isTaskbarApplication =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                String taskbarAppProp = System.getProperty(&quot;glass.taskbarApplication&quot;);
                return  !&quot;false&quot;.equalsIgnoreCase(taskbarAppProp);
            });

        ClassLoader classLoader = MacApplication.class.getClassLoader();
        _runLoop(classLoader, launchable, isTaskbarApplication);
    }

<A NAME="1"></A>    native private void _finishTerminating();
    @Override
    protected void finishTerminating() {
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#1',2,'match34-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>_finishTerminating();

        super.finishTerminating();
    }

    private void notifyApplicationDidTerminate() {
        setEventThread(null);
    }

    // Called from the native code
    private void setEventThread() {
        setEventThread(Thread.currentThread());
    }</B></FONT>

    native private Object _enterNestedEventLoopImpl();
    @Override protected Object _enterNestedEventLoop() {
        if (invokeLaterDispatcher != null) {
            invokeLaterDispatcher.notifyEnteringNestedEventLoop();
        }
        try {
            return _enterNestedEventLoopImpl();
        } finally {
            if (invokeLaterDispatcher != null) {
                invokeLaterDispatcher.notifyLeftNestedEventLoop();
            }
        }
    }

    native private void _leaveNestedEventLoopImpl(Object retValue);
    @Override protected void _leaveNestedEventLoop(Object retValue) {
        if (invokeLaterDispatcher != null) {
            invokeLaterDispatcher.notifyLeavingNestedEventLoop();
        }
        _leaveNestedEventLoopImpl(retValue);
    }

    native private void _hide();
    native private void _hideOtherApplications();
    native private void _unhideAllApplications();

    public void installAppleMenu(MenuBar menubar) {
        this.appleMenu = createMenu(&quot;Apple&quot;);

        MenuItem hideMenu = createMenuItem(&quot;Hide &quot; + getName(), new MenuItem.Callback() {
            @Override public void action() {
                MacApplication.this._hide();
            }
            @Override public void validate() {
            }
        }, 'h', KeyEvent.MODIFIER_COMMAND);
        this.appleMenu.add(hideMenu);

        MenuItem hideOthersMenu = createMenuItem(&quot;Hide Others&quot;, new MenuItem.Callback() {
            @Override public void action() {
                MacApplication.this._hideOtherApplications();
            }
            @Override public void validate() {
            }
        }, 'h', KeyEvent.MODIFIER_COMMAND | KeyEvent.MODIFIER_ALT);
        this.appleMenu.add(hideOthersMenu);

        MenuItem unhideAllMenu = createMenuItem(&quot;Show All&quot;, new MenuItem.Callback() {
            @Override public void action() {
                MacApplication.this._unhideAllApplications();
            }
            @Override public void validate() {
            }
        });
        this.appleMenu.add(unhideAllMenu);

        this.appleMenu.add(MenuItem.Separator);

        MenuItem quitMenu = createMenuItem(&quot;Quit &quot; + getName(), new MenuItem.Callback() {
            @Override public void action() {
                Application.EventHandler eh = getEventHandler();
                if (eh != null) {
                    eh.handleQuitAction(Application.GetApplication(), System.nanoTime());
                }
            }
            @Override public void validate() {
            }
        }, 'q', KeyEvent.MODIFIER_COMMAND);
        this.appleMenu.add(quitMenu);

        menubar.add(this.appleMenu);
    }

    public Menu getAppleMenu() {
        return this.appleMenu;
    }

    @Override public void installDefaultMenus(MenuBar menubar) {
        installAppleMenu(menubar);
    }


    // FACTORY METHODS

    @Override public Window createWindow(Window owner, Screen screen, int styleMask) {
        return new MacWindow(owner, screen, styleMask);
    }

    final static long BROWSER_PARENT_ID = -1L;
    @Override public Window createWindow(long parent) {
        Window window = new MacWindow(parent);
        if (parent == BROWSER_PARENT_ID) {
            // Special case: a Mac embedded window, which is a parent to other child Windows.
            // Needs implicit view, with a layer that will be provided to the plugin
            window.setView(createView());
        }
        return window;
    }

    @Override public View createView() {
        return new MacView();
    }

    @Override public Cursor createCursor(int type) {
        return new MacCursor(type);
    }

    @Override public Cursor createCursor(int x, int y, Pixels pixels) {
        return new MacCursor(x, y, pixels);
    }

    @Override protected void staticCursor_setVisible(boolean visible) {
        MacCursor.setVisible_impl(visible);
    }

    @Override protected Size staticCursor_getBestSize(int width, int height) {
        return MacCursor.getBestSize_impl(width, height);
    }

    @Override public Pixels createPixels(int width, int height, ByteBuffer data) {
        return new MacPixels(width, height, data);
    }

    @Override public Pixels createPixels(int width, int height, IntBuffer data) {
        return new MacPixels(width, height, data);
    }

    @Override
    public Pixels createPixels(int width, int height, IntBuffer data, float scalex, float scaley) {
        return new MacPixels(width, height, data, scalex, scaley);
    }

    @Override protected int staticPixels_getNativeFormat() {
        return MacPixels.getNativeFormat_impl();
    }

    @Override public GlassRobot createRobot() {
        return new MacRobot();
    }

    @Override native protected double staticScreen_getVideoRefreshPeriod();
    @Override native protected Screen[] staticScreen_getScreens();

    @Override public Timer createTimer(Runnable runnable) {
        return new MacTimer(runnable);
    }

    @Override protected int staticTimer_getMinPeriod() {
        return MacTimer.getMinPeriod_impl();
    }

    @Override protected int staticTimer_getMaxPeriod() {
        return MacTimer.getMaxPeriod_impl();
    }

    @Override public Accessible createAccessible() {
        return new MacAccessible();
    }

    @Override protected FileChooserResult staticCommonDialogs_showFileChooser(Window owner, String folder, String filename, String title, int type,
                                                     boolean multipleMode, ExtensionFilter[] extensionFilters, int defaultFilterIndex) {
        return MacCommonDialogs.showFileChooser_impl(owner, folder, filename,
                title, type, multipleMode, extensionFilters, defaultFilterIndex);
    }

    @Override protected File staticCommonDialogs_showFolderChooser(Window owner, String folder, String title) {
        return MacCommonDialogs.showFolderChooser_impl(owner, folder, title);
    }

    @Override protected long staticView_getMultiClickTime() {
        return MacView.getMultiClickTime_impl();
    }

    @Override protected int staticView_getMultiClickMaxX() {
        return MacView.getMultiClickMaxX_impl();
    }

    @Override protected int staticView_getMultiClickMaxY() {
        return MacView.getMultiClickMaxY_impl();
    }

    @Override native protected void _invokeAndWait(Runnable runnable);

    private native void _submitForLaterInvocation(Runnable r);
    // InvokeLaterDispatcher.InvokeLaterSubmitter
    @Override public void submitForLaterInvocation(Runnable r) {
        _submitForLaterInvocation(r);
    }

    @Override protected void _invokeLater(Runnable runnable) {
        if (invokeLaterDispatcher != null) {
            invokeLaterDispatcher.invokeLater(runnable);
        } else {
            submitForLaterInvocation(runnable);
        }
    }

    @Override
    protected boolean _supportsInputMethods() {
        return true;
    }

    @Override
    protected boolean _supportsTransparentWindows() {
        return true;
    }

    @Override protected boolean _supportsUnifiedWindows() {
        return true;
    }

    @Override native protected boolean _supportsSystemMenu();

    native protected String _getRemoteLayerServerName();
    public String getRemoteLayerServerName() {
        return _getRemoteLayerServerName();
    }

    private native String _getDataDirectory();
    public String getDataDirectory() {
        checkEventThread();
        String baseDirectory = _getDataDirectory();
        if (baseDirectory == null || baseDirectory.length() == 0) {
            return super.getDataDirectory();
        }
        return baseDirectory + File.separator + name + File.separator;
    }

    @Override
    protected native int _getKeyCodeForChar(char c);
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/GetEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/** A test entry point for Monacle to show what events are read from input
 * devices.
 */
class GetEvent {

    private static Set&lt;File&gt; devices = new HashSet&lt;&gt;();

    private static UdevListener udevListener = (action, event) -&gt; {
        String subsystem = event.get(&quot;SUBSYSTEM&quot;);
        String devPath = event.get(&quot;DEVPATH&quot;);
        if (subsystem != null &amp;&amp; subsystem.equals(&quot;input&quot;)
                &amp;&amp; devPath != null) {

            // show the udev event properties
            System.out.format(&quot;%1$ts.%1$tL Received UEVENT:\n&quot;,
                    new Date());
            List&lt;String&gt; keys = new ArrayList&lt;&gt;(event.keySet());
            Collections.sort(keys);
            for (String key: keys) {
                System.out.format(&quot;  %s='%s'\n&quot;, key, event.get(key));
            }

            // process the event
            try {
                File sysPath = new File(&quot;/sys&quot;, devPath);
                String devNode = event.get(&quot;DEVNAME&quot;);
                if (devNode == null) {
                    return;
                }
                if (action.equals(&quot;add&quot;)
                        || (action.equals(&quot;change&quot;)
                            &amp;&amp; !devices.contains(sysPath))) {
                    LinuxInputDevice device = new LinuxInputDevice(
                            new File(devNode), sysPath, event);
                    device.setInputProcessor(new LinuxInputProcessor.Logger());
                    Thread thread = new Thread(device);
                    thread.setName(devNode.toString());
                    thread.setDaemon(true);
                    thread.start();
                    System.out.println(&quot;Added device &quot; + devNode);
                    System.out.println(&quot;  touch=&quot; + device.isTouch());
                    System.out.println(&quot;  multiTouch=&quot; + device.isMultiTouch());
                    System.out.println(&quot;  relative=&quot; + device.isRelative());
                    System.out.println(&quot;  5-way=&quot; + device.is5Way());
                    System.out.println(&quot;  fullKeyboard=&quot; + device.isFullKeyboard());
                    System.out.println(&quot;  PRODUCT=&quot; + device.getProduct());
                    for (short axis = 0; axis &lt; LinuxInput.ABS_MAX; axis++) {
                        LinuxAbsoluteInputCapabilities caps =
                                device.getAbsoluteInputCapabilities(axis);
                        if (caps != null) {
                            String axisName = LinuxInput.codeToString(&quot;EV_ABS&quot;, axis);
                            System.out.format(&quot;  ABSVAL %s %d\n&quot;,
                                              axisName, caps.getValue());
                            System.out.format(&quot;  ABSMIN %s %d\n&quot;,
                                              axisName, caps.getMinimum());
                            System.out.format(&quot;  ABSMAX %s %d\n&quot;,
                                              axisName, caps.getMaximum());
                            System.out.format(&quot;  ABSFUZZ %s %d\n&quot;,
                                              axisName, caps.getFuzz());
                            System.out.format(&quot;  ABSFLAT %s %d\n&quot;,
                                              axisName, caps.getFlat());
                            System.out.format(&quot;  ABSRES %s %d\n&quot;,
                                              axisName, caps.getResolution());
                        }
                    }
                    devices.add(sysPath);
                } else if (action.equals(&quot;remove&quot;)) {
                    devices.remove(devPath);
                }
            } catch (IOException | RuntimeException e) {
                e.printStackTrace();
            }
        }
<A NAME="36"></A>    };

    public static void main(String[] argv) throws Exception {
        <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#36',2,'match34-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>NativePlatform platform = NativePlatformFactory.getNativePlatform();
        Udev.getInstance().addListener(udevListener);
        // Request updates for existing devices
        SysFS.triggerUdevNotification(&quot;input&quot;);
        new Thread(platform.getRunnableProcessor()).start();
    }</B></FONT>

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/SysFS.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;

class SysFS {

    static final String CURSOR_BLINK =
            &quot;/sys/devices/virtual/graphics/fbcon/cursor_blink&quot;;

    /** Read input device capability data from sysfs */
    static Map&lt;String, BitSet&gt; readCapabilities(File sysPath) {
        Map&lt;String, BitSet&gt; capsMap = new HashMap&lt;String, BitSet&gt;();
        File[] capsFiles = new File(sysPath, &quot;device/capabilities&quot;).listFiles();
        if (capsFiles == null) {
            return capsMap;
        }
        for (int i = 0; i &lt; capsFiles.length; i++) {
            try {
                BufferedReader r = new BufferedReader(new FileReader(capsFiles[i]));
                String s = r.readLine();
                r.close();
                if (s == null) {
                    continue;
                }
                String[] elements = s.split(&quot; &quot;);
                if (elements == null) {
                    continue;
                }
                byte[] b = new byte[elements.length * (LinuxArch.is64Bit() ? 8 : 4)];
                ByteBuffer bb = ByteBuffer.wrap(b);
                bb.order(ByteOrder.LITTLE_ENDIAN);
                for (int j = elements.length - 1; j &gt;= 0; j--) {
                    if (LinuxArch.is64Bit()) {
                        bb.putLong(Long.parseUnsignedLong(elements[j], 16));
                    } else {
                        bb.putInt(Integer.parseUnsignedInt(elements[j], 16));
                    }
                }
                capsMap.put(capsFiles[i].getName(), BitSet.valueOf(b));
<A NAME="9"></A>            } catch (IOException | RuntimeException e) {
                e.printStackTrace();
            }
        <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#9',2,'match34-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        return capsMap;
    }

    static Map&lt;String, String&gt; readUEvent(File sysPath) {
        Map&lt;String, String&gt; uevent = new HashMap();
        File f = new File(sysPath, &quot;device/uevent&quot;)</B></FONT>;
        try {
            BufferedReader r = new BufferedReader(new FileReader(f));
            for (String line; (line = r.readLine()) != null;) {
                int i = line.indexOf(&quot;=&quot;);
                if (i &gt;= 0) {
                    uevent.put(line.substring(0, i), line.substring(i + 1));
                }
            }
        } catch (IOException e) {
            // return an empty map
        }
        return uevent;
    }

    /** Fires udev notification events for devices of the given type */
    static void triggerUdevNotification(String sysClass) {
        File[] devices = new File(&quot;/sys/class/&quot; + sysClass).listFiles();
        byte[] action = &quot;change&quot;.getBytes();
        for (File device: devices) {
            File uevent = new File(device, &quot;uevent&quot;);
            if (uevent.exists()) {
                try {
                    write(uevent.getAbsolutePath(), action);
                } catch (IOException e) {
                    System.err.println(&quot;Udev: Failed to write to &quot; + uevent);
                    System.err.println(&quot;      Check that you have permission to access input devices&quot;);
                    if (!e.getMessage().contains(&quot;Permission denied&quot;)) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static void write(String location, byte[] value) throws IOException {
        FileOutputStream out = new FileOutputStream(location);
        try {
            out.write(value);
        } finally {
            out.close();
        }
    }

    static void write(String location, String value) throws IOException {
        write(location, value.getBytes());
    }

    /** Read a comma-separated list of integer values from a file */
    static int[] readInts(String location, int expectedLength) throws IOException {
        BufferedReader r = new BufferedReader(new FileReader(location));
        String s = r.readLine();
        r.close();
        if (s != null &amp;&amp; s.length() &gt; 0) {
            String[] elements = s.split(&quot;,&quot;);
            try {
                if (expectedLength == 0 || elements.length == expectedLength) {
                    int[] xs = new int[elements.length];
                    for (int i = 0; i &lt; xs.length; i++) {
                        xs[i] = Integer.parseInt(elements[i]);
                    }
                    return xs;
                }
            } catch (NumberFormatException e) {
                // fall through to throw an IOException
            }
        }
        if (expectedLength != 0) {
            throw new IOException(&quot;Expected to find &quot; + expectedLength
                    + &quot; integers in &quot; + location + &quot; but found '&quot;
                    + s + &quot;'&quot;);
        } else {
            return new int[0];
        }
    }

    /**
     * Read a single integer value from a file
     */
    static int readInt(String location) throws IOException {
        BufferedReader r = new BufferedReader(new FileReader(location));
        String s = r.readLine();
        r.close();
        try {
            if (s != null &amp;&amp; s.length() &gt; 0) {
                return Integer.parseInt(s);
            } else {
                throw new IOException(location + &quot; does not contain an integer&quot;);
            }
        } catch (NumberFormatException e) {
            throw new IOException(
                    location + &quot; does not contain an integer ('&quot; + s + &quot;'&quot;);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/VNCScreen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.MouseEvent;
import javafx.application.Platform;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.BitSet;
import java.util.HashSet;
import java.util.Set;

/** A headless screen that is available for remote connections using the
 * RFB 3.3 protocol on port 5901.
 */
class VNCScreen extends HeadlessScreen {

    private ServerSocketChannel server;
    private Set&lt;ClientConnection&gt; clients = new HashSet&lt;ClientConnection&gt;();

    VNCScreen() {
        super(1024, 600, 32);
        try {
            server = ServerSocketChannel.open();
            int vncPort = AccessController.doPrivileged(
                    (PrivilegedAction&lt;Integer&gt;)
                            () -&gt; Integer.getInteger(&quot;vnc.port&quot;, 5901));
            server.bind(new InetSocketAddress(vncPort));
            Thread t = new Thread(new ConnectionAccepter());
<A NAME="22"></A>            t.setDaemon(true);
            t.setName(&quot;VNC Server on port &quot; + vncPort);
            t.start();
        <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#22',2,'match34-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void shutdown() {
        super.shutdown</B></FONT>();
        for (ClientConnection cc : clients) {
            try {
                cc.socket.close();
            } catch (IOException e) { }
        }
    }

    @Override
    public void swapBuffers() {
        ClientConnection[] ccs;
        synchronized (clients) {
            ccs = clients.toArray(new ClientConnection[clients.size()]);
        }
        for (ClientConnection cc : ccs) {
            try {
                sendBuffer(cc.socket);
            } catch (IOException e) {
                clients.remove(cc);
            }
        }
        super.swapBuffers();
    }

    private void removeClient(ClientConnection cc, IOException e) {
        synchronized (clients) {
            if (clients.contains(cc)) {
                System.out.format(&quot;Disconnecting %s: %s\n&quot;,
                                  cc.descriptor, e.getMessage());
                clients.remove(cc);
            }
        }
    }

    private void sendBuffer(WritableByteChannel out) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(16);
        buffer.order(ByteOrder.BIG_ENDIAN);
        buffer.put((byte) 0);
        buffer.put((byte) 0);
        buffer.putShort((short) 1); // rectangle count
        buffer.putShort((short) 0); // x
        buffer.putShort((short) 0); // y
        buffer.putShort((short) width);
        buffer.putShort((short) height);
        buffer.putInt(0); // raw
        buffer.flip();
        out.write(buffer);
        fb.write(out);
    }

    private class ConnectionAccepter implements Runnable {
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(64);
            buffer.order(ByteOrder.BIG_ENDIAN);
            while (true) {
                try {
                    SocketChannel client = server.accept();
                    System.out.format(&quot;Connection received from %s\n&quot;,
                                      client.getRemoteAddress());
                    // Declare the server protocol version
                    buffer.clear();
                    buffer.put(&quot;RFB 003.003\n&quot;.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    // Read the client protocol version
                    buffer.clear();
                    buffer.limit(12);
                    client.read(buffer);
                    buffer.flip();
                    System.out.format(&quot;Client supports %s\n&quot;,
                                      Charset.forName(&quot;UTF-8&quot;)
                                              .decode(buffer).toString().trim());
                    buffer.clear();
                    buffer.putInt(1); // no authentication
                    buffer.flip();
                    client.write(buffer);
                    buffer.clear();
                    buffer.limit(1);
                    client.read(buffer);
                    System.out.format(&quot;Client share request: %d\n&quot;,
                                      buffer.get(0));
                    buffer.clear();
                    buffer.putShort((short) width);
                    buffer.putShort((short) height);
                    buffer.put((byte) depth);
                    buffer.put((byte) depth);
                    buffer.put((byte) (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN) ? 0 : 1));
                    buffer.put((byte) 1); // true color
                    if (depth == 32) {
                        buffer.putShort((short) 255); // red max
                        buffer.putShort((short) 255); // green max
                        buffer.putShort((short) 255); // blue max
                        buffer.put((byte) 16); // red offset
                        buffer.put((byte) 8); // blue offset
                        buffer.put((byte) 0); // green offset
                    } else {
                        buffer.putShort((byte) (short) 31);
                        buffer.putShort((byte) (short) 63);
                        buffer.putShort((byte) (short) 31);
                        buffer.put((byte) 11);
                        buffer.put((byte) 5);
                        buffer.put((byte) 0);
                    }
                    buffer.put((byte) 0); // padding
                    buffer.put((byte) 0);
                    buffer.put((byte) 0);
                    String name = &quot;JavaFX on &quot; + client.getLocalAddress();
                    buffer.putInt(name.length());
                    buffer.put(name.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    ClientConnection cc = new ClientConnection();
                    cc.socket = client;
                    Thread t = new Thread(cc);
                    t.setDaemon(true);
                    t.setName(&quot;VNC client connection from &quot;
                                      + client.getRemoteAddress());
                    t.start();
                    synchronized (clients) {
                        clients.add(cc);
                    }
                    sendBuffer(client);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private class ClientConnection implements Runnable {
        private SocketChannel socket;
        private String descriptor;
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(32);
            buffer.order(ByteOrder.BIG_ENDIAN);
            try {
                descriptor = socket.getRemoteAddress().toString();
                while (true) {
                    buffer.clear();
                    buffer.limit(4);
                    socket.read(buffer);
                    switch (buffer.get(0)) {
                        case 0: // SetPixelFormat
                            // discard the message in the next 16 bytes
                            buffer.clear();
                            buffer.limit(16);
                            socket.read(buffer);
                            break;
                        case 1: // FixColorMapEntries
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            // discard color map entries
                            int colorMapEntryCount = buffer.getShort(0);
                            for (int i = 0; i &lt; colorMapEntryCount; i++) {
                                buffer.clear();
                                buffer.limit(6);
                                socket.read(buffer);
                            }
                            break;
                        case 2: // SetEncodings
                            // discard encodings
                            int encodingCount = buffer.getShort(2);
                            for (int i = 0; i &lt; encodingCount; i++) {
                                buffer.clear();
                                buffer.limit(4);
                                socket.read(buffer);
                            }
                        case 3: // FramebufferUpdateRequest
                            buffer.clear();
                            buffer.limit(6);
                            socket.read(buffer);
                            Platform.runLater(() -&gt; {
                                try {
                                    if (fb.hasReceivedData()) {
                                        // an update is in progress and will
                                        // be sent on the next call to
                                        // swapBuffers. No need to
                                        // respond to this request.
                                    } else {
                                        sendBuffer(socket);
                                    }
                                } catch (IOException e) {
                                    removeClient(ClientConnection.this, e);
                                }
                            });
                            break;
                        case 4: // KeyEvent
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            break;
                        case 5: { // PointerEvent
                            int x = buffer.getShort(2);
                            buffer.position(1);
                            buffer.limit(2);
                            BitSet buttons = BitSet.valueOf(buffer);
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            int y = buffer.getShort(0);
                            final MouseState state = new MouseState();
                            state.setX(x);
                            state.setY(y);
                            if (buttons.get(0)) {
                                state.pressButton(MouseEvent.BUTTON_LEFT);
                            }
                            if (buttons.get(1)) {
                                state.pressButton(MouseEvent.BUTTON_OTHER);
                            }
                            if (buttons.get(2)) {
                                state.pressButton(MouseEvent.BUTTON_RIGHT);
                            }
                            Platform.runLater(() -&gt; MouseInput.getInstance().setState(state, false));
                            break;
                        }
                        case 6: // ClientCutText
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            int textLength = buffer.getInt(0);
                            for (int i = 0; i &lt; textLength; i++) {
                                buffer.clear();
                                buffer.limit(1);
                                socket.read(buffer);
                            }
                            break;
                        default:
                            System.err.format(
                                    &quot;Unknown message %d from client %s\n&quot;,
                                    buffer.get(0), socket.getRemoteAddress());
                    }
                }
            } catch (IOException e) {
                removeClient(this, e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/win/WinSystemClipboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.win;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.SystemClipboard;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

class WinSystemClipboard extends SystemClipboard {

    private static native void initIDs();
    static {
        initIDs();
    }

    private long ptr = 0L; //native pointer

    protected WinSystemClipboard(String name) {
        super(name);
        create();
    }

    protected final long getPtr() {
        return ptr;
    }

    protected native boolean isOwner();

    protected native void create();
    protected native void dispose();

    /*
     * public mime types to system clipboard
     */
    protected native void push(Object[] keys, int supportedActions);

    /*
     * extract clipboard snap-shot
     */
    protected native boolean pop();

    static final byte[] terminator = new byte[] { 0, 0 };
    static final String defaultCharset = &quot;UTF-16LE&quot;;
    static final String RTFCharset = &quot;US-ASCII&quot;;

    // Called from native code
    private byte[] fosSerialize(String mime, long index) {
        Object data = getLocalData(mime);
        if (data instanceof ByteBuffer) {
            byte[] b = ((ByteBuffer)data).array();
            if (HTML_TYPE.equals(mime)) {
                b = WinHTMLCodec.encode(b);
            }
            return b;
        } else if (data instanceof String) {
            String st = ((String) data).replaceAll(&quot;(\r\n|\r|\n)&quot;, &quot;\r\n&quot;);
            if (HTML_TYPE.equals(mime)) {
                try {
                    // NOTE: Transfer of HTML data on Windows uses UTF-8 encoding!
                    byte[] bytes = st.getBytes(WinHTMLCodec.defaultCharset);
                    ByteBuffer ba = ByteBuffer.allocate(bytes.length + 1);
                    ba.put(bytes);
                    ba.put((byte)0);

                    return WinHTMLCodec.encode(ba.array());
                } catch (UnsupportedEncodingException ex) {
                    // never happen
                    return null;
                }
            } else if (RTF_TYPE.equals(mime)) {
                try {
                    // NOTE: Transfer of RTF data on Windows uses US-ASCII encoding!
                    byte[] bytes = st.getBytes(RTFCharset);
                    ByteBuffer ba = ByteBuffer.allocate(bytes.length + 1);
                    ba.put(bytes);
                    ba.put((byte)0);
                    return ba.array();
                } catch (UnsupportedEncodingException ex) {
                    // could happen on user error
                    return null;
                }
            } else {
                ByteBuffer ba = ByteBuffer.allocate((st.length() + 1) * 2);
                try {
                    ba.put(st.getBytes(defaultCharset));
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
                ba.put(terminator);
                return ba.array();
            }
        } else if (FILE_LIST_TYPE.equals(mime)) {
            String[] ast = ((String[]) data);
            if (ast != null &amp;&amp; ast.length &gt; 0) {
                int size = 0;
                for (String st : ast) {
                    size += (st.length() + 1) * 2;
                }
                size += 2;
                try {
                    ByteBuffer ba = ByteBuffer.allocate(size);
                    for (String st : ast) {
                        ba.put(st.getBytes(defaultCharset));
                        ba.put(terminator);
                    }
                    ba.put(terminator);
                    return ba.array();
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            }
        } else if (RAW_IMAGE_TYPE.equals(mime)) {
            Pixels pxls = (Pixels)data;
            if (pxls != null) {
                ByteBuffer ba = ByteBuffer.allocate(
                        pxls.getWidth() * pxls.getHeight() * 4 + 8);
                ba.putInt(pxls.getWidth());
                ba.putInt(pxls.getHeight());
                ba.put(pxls.asByteBuffer());
                return ba.array();
            }
        }
        //TODO: customizes for OS specific cases
        return null;
    }

    private static final class MimeTypeParser {
        protected static final String externalBodyMime = &quot;message/external-body&quot;;
        protected String mime;
        protected boolean bInMemoryFile;
        protected int index;

        public MimeTypeParser() {
            parse(&quot;&quot;);
        }

        public MimeTypeParser(String mimeFull) {
            parse(mimeFull);
        }

        public void parse(String mimeFull) {
            mime = mimeFull;
            bInMemoryFile = false;
            index = -1;
            //we are limited here by [message/external-body] mime type with clipboard acess-type,
            //because NetBeans has a clipboard format that includes [;]
            if (mimeFull.startsWith(externalBodyMime)) {
                String mimeParts[] = mimeFull.split(&quot;;&quot;);
                String accessType = &quot;&quot;;
                int indexValue = -1;
                //RFC 1521 extension for [message/external-body] mime
                for (int i = 1; i &lt; mimeParts.length; ++i) {
                    String params[] = mimeParts[i].split(&quot;=&quot;);
                    if (params.length == 2) {
                        if( params[0].trim().equalsIgnoreCase(&quot;index&quot;) ) {
                            //that is OK to have the runtime-exception here
                            //we already have a chance to have an exception in WinHTMLCodec
                            indexValue = Integer.parseInt(params[1].trim());
                        } else if( params[0].trim().equalsIgnoreCase(&quot;access-type&quot;) ) {
                            accessType = params[1].trim();
                        }
                    }
                    if (indexValue != -1 &amp;&amp; !accessType.isEmpty()) {
                        //Better to stop here to avoid problem with &quot;index=100.url&quot; filename
                        //it is not a security problem - we can request any index without
                        //buffer overflow or null pointer exception
                        break;
                    }
                }
                //we are responsible only for FX synthetic access type!
                if (accessType.equalsIgnoreCase(&quot;clipboard&quot;)) {
                    bInMemoryFile = true;
                    mime = mimeParts[0];
                    index = indexValue;
                }
            }
        }

        public String getMime() {
            return mime;
        }

        public int getIndex() {
            return index;
        }

        public boolean isInMemoryFile() {
            return bInMemoryFile;
        }
    }

    protected final void pushToSystem(HashMap&lt;String, Object&gt; cacheData, int supportedActions) {
        Set&lt;String&gt; mimes = cacheData.keySet();
        Set&lt;String&gt; mimesForSystem = new HashSet&lt;String&gt;();
        MimeTypeParser parser = new MimeTypeParser();
        for (String mime : mimes) {
            parser.parse(mime);
            if ( !parser.isInMemoryFile() ) {
                //[message/external-body] mime with [access-type=clipboard]
                //could not be exported to the system due to synthetic nature (Win-API subst),
                //but it could be used for applcation-wide communication
                mimesForSystem.add(mime);
            }
        }
        push(mimesForSystem.toArray(), supportedActions);
    }

    private native byte[] popBytes(String mime, long index);
    protected final Object popFromSystem(String mimeFull) {
        //we have to syncronize with system ones per
        //a popFromSystem function call, because
        //mime type data could be a collection of
        //sub-mimes likes &quot;ms-stuff/XXXX&quot;
        if ( !pop() ) {
            return null;
        }

        MimeTypeParser parser = new MimeTypeParser(mimeFull);
        String mime = parser.getMime();
        byte[] data = popBytes(mime, parser.getIndex());
        if (data != null) {
            if (TEXT_TYPE.equals(mime) || URI_TYPE.equals(mime)) {
                try {
                    // RT-16199 - internal Windows data null terminated
                    return new String(data, 0, data.length - 2, defaultCharset);
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            } else if (HTML_TYPE.equals(mime)) {
                try {
                    data = WinHTMLCodec.decode(data);
                    return new String(data, 0, data.length, WinHTMLCodec.defaultCharset);
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            } else if (RTF_TYPE.equals(mime)) {
                try {
                    return new String(data, 0, data.length, RTFCharset);
                } catch (UnsupportedEncodingException ex) {
                    //can happen for bad system data
                }
            } else if (FILE_LIST_TYPE.equals(mime)) {
                try {
                    String st = new String(data, 0, data.length, defaultCharset);
                    return st.split(&quot;\0&quot;);
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            } else if (RAW_IMAGE_TYPE.equals(mime)) {
                ByteBuffer size = ByteBuffer.wrap(data, 0, 8);
                return Application.GetApplication().createPixels(size.getInt(), size.getInt(),  ByteBuffer.wrap(data, 8, data.length - 8) );
            } else {
                return ByteBuffer.wrap(data);
            }
        } else {
            //alternative extraction if any
            if (URI_TYPE.equals(mime) || TEXT_TYPE.equals(mime)) {
                //try 8bit version
                data = popBytes(mime + &quot;;locale&quot;, parser.getIndex());
                if (data != null) {
                    try {
                        // RT-16199 - internal Windows data null terminated
                        // Here we can request the &quot;ms-stuff/locale&quot; mime data
                        // from GlassClipbord for codepage detection, but
                        // for the most of cases [UTF-8] is ok.
                        return new String(data, 0, data.length - 1, &quot;UTF-8&quot;);
                    } catch (UnsupportedEncodingException ex) {
                        //could happen, but not a problem
                    }
                }
            }
            if (URI_TYPE.equals(mime)) {
                //we are here if [text/uri-list;locale] mime is absent or
                //URL could not be decoded from the [data] as String
                String[] ret = (String[])popFromSystem(FILE_LIST_TYPE);
                if (ret != null) {
                    StringBuilder out = new StringBuilder();
                    //&quot;text/uri-list&quot; spec: http://www.ietf.org/rfc/rfc2483.txt
                    for (int i = 0; i &lt; ret.length; i++) {
                        String fileName = ret[i];
                        fileName = fileName.replace(&quot;\\&quot;, &quot;/&quot;);
                        //fileName = fileName.replace(&quot; &quot;, &quot;%20&quot;);
                        if (out.length() &gt; 0) {
                            out.append(&quot;\r\n&quot;);
                        }
                        out.append(&quot;file:/&quot;).append(fileName);
                    }
                    return out.toString();
                }
            }
        }
        return null;
    }

    private native String[] popMimesFromSystem();
    protected final String[] mimesFromSystem() {
        //we have to syncronize with system
        //if we heed to do it. DnD clipboard need not.
        if (!pop()) {
            return null;
        }
        return popMimesFromSystem();
    }
<A NAME="23"></A>
    @Override public String toString() {
        return &quot;Windows System Clipboard&quot;;
    <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#23',2,'match34-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override protected final void close() {
        dispose();
        ptr = 0L;
    }

    @</B></FONT>Override protected native void pushTargetActionToSystem(int actionDone);

    private native int popSupportedSourceActions();
    @Override protected int supportedSourceActionsFromSystem() {
        if (!pop()) {
            return ACTION_NONE;
        }
        return popSupportedSourceActions();
   }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/scene/traversal/TraversalEngine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.traversal;

import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.NodeHelper;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.scene.Node;
import javafx.scene.Parent;

import java.util.ArrayList;
import java.util.List;

/**
 * This is abstract class for a traversal engine. There are 2 types : {@link com.sun.javafx.scene.traversal.ParentTraversalEngine}
 * to be used in {@link Parent#setTraversalEngine(ParentTraversalEngine)} to override default behavior
 * and {@link com.sun.javafx.scene.traversal.TopMostTraversalEngine} that is the default traversal engine for scene and subscene.
 *
 * Every engine is basically a wrapper of an algorithm + some specific parent (or scene/subscene), which define engine's root.
 */
public abstract class TraversalEngine{

    /**
     * This is the default algorithm for the running platform. It's the algorithm that's used in TopMostTraversalEngine
     */
    static final Algorithm DEFAULT_ALGORITHM = PlatformImpl.isContextual2DNavigation() ? new Hueristic2D() : new ContainerTabOrder();

    private final TraversalContext context = new EngineContext(); // This is the context used in calls to this engine's algorithm
    // This is a special context that's used when invoking select &quot;callbacks&quot; to default algorithm in other contexts
    private final TempEngineContext tempEngineContext = new TempEngineContext();
    protected final Algorithm algorithm;

    private final Bounds initialBounds =  new BoundingBox(0, 0, 1, 1);
    private final ArrayList&lt;TraverseListener&gt; listeners = new ArrayList&lt;&gt;();

    /**
     * Creates engine with the specified algorithm
     * @param algorithm
     */
    protected TraversalEngine(Algorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * Creates engine with no algorithm. This makes all the select* calls invalid.
     * @see #canTraverse()
     */
    protected TraversalEngine() {
        this.algorithm = null;
    }

    /**
     * Add a listener to traversal engine. The listener is notified whenever focus is changed by traversal inside the associated scene or parent.
     * This can be used with ParentTraversalEngine that has no algorithm to observe changes to the focus inside the parent.
     * @param listener
<A NAME="15"></A>     */
    public final void addTraverseListener(TraverseListener listener) {
        listeners.add(listener);
    <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#15',2,'match34-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Fire notifications for listeners. This is called from the TopMostTraversalEngine
     * @param newNode the node which has been focused
     */
    final void notifyTraversedTo(Node newNode) {
        for (TraverseListener l : listeners) {
            l.onTraverse(newNode, getLayoutBounds(newNode, getRoot()));
        }
    }

    /**
     * Returns the node that is in the direction {@code dir} starting from the Node {@code from} using the engine's algorithm.
     * Null means there is no Node in that direction
     * @param from the node to start traversal from
     * @param dir the direction of traversal
     * @return the subsequent node in the specified direction or null if none
     * @throws java.lang.NullPointerException if there is no algorithm
     */
    public</B></FONT> final Node select(Node from, Direction dir) {
        return algorithm.select(from, dir, context);
    }

    /**
     * Returns the first node in this engine's context (scene/parent) using the engine's algorithm.
     * This can be null only if there are no traversable nodes
     * @return The first node or null if none exists
     * @throws java.lang.NullPointerException if there is no algorithm
     */
    public final Node selectFirst() {
        return algorithm.selectFirst(context);
    }

    /**
     * Returns the last node in this engine's context (scene/parent) using the engine's algorithm.
     * This can be null only if there are no traversable nodes
     * @return The last node or null if none exists
     * @throws java.lang.NullPointerException if there is no algorithm
     */
    public final Node selectLast() {
        return algorithm.selectLast(context);
    }

    /**
     * The root of this engine's context. This is the node that is the root of the tree that is traversed by this engine.
     * @return This engine's root
     */
    protected abstract Parent getRoot();

    /**
     * Returns true only if there's specified algorithm for this engine. Otherwise, this engine cannot be used for traversal.
     * The engine might be still useful however, e.g. for listening on traversal changes.
     * @return
     */
    public final boolean canTraverse() {
        return algorithm != null;
    }

    /**
     * Gets the appropriate bounds for the given node, transformed into
     * the scene's or the specified node's coordinates.
     * @return bounds of node in {@code forParent} coordinates or scene coordinates if {@code forParent} is null
     */
    private Bounds getLayoutBounds(Node n, Parent forParent) {
        final Bounds bounds;
        if (n != null) {
            if (forParent == null) {
                bounds = n.localToScene(n.getLayoutBounds());
            } else {
                bounds = forParent.sceneToLocal(n.localToScene(n.getLayoutBounds()));
            }
        } else {
            bounds = initialBounds;
        }
        return bounds;
    }

    // This is the engine context passed algorithm on select calls
    private final class EngineContext extends BaseEngineContext {
        @Override
        public Parent getRoot() {
            return TraversalEngine.this.getRoot();
        }
    }

    // This is the engine context passed to algorithm on select callbacks from other contexts.
    // It can change the root to the node defined in &quot;selectFirstInParent&quot;, &quot;selectLastInParent&quot; or
    // &quot;selectInSubtree&quot; methods
    private final class TempEngineContext extends BaseEngineContext {
        private Parent root;

        @Override
        public Parent getRoot() {
            return root;
        }

        public void setRoot(Parent root) {
            this.root = root;
        }
    }

    /**
     * The base class for all engine contexts
     */
    private abstract class BaseEngineContext implements TraversalContext {

        /**
         * Returns all traversable nodes in the context's (engine's) root
         */
        @Override
        public List&lt;Node&gt; getAllTargetNodes() {
            final List&lt;Node&gt; targetNodes = new ArrayList&lt;&gt;();
            addFocusableChildrenToList(targetNodes, getRoot());
            return targetNodes;
        }

        @Override
        public Bounds getSceneLayoutBounds(Node n) {
            return getLayoutBounds(n, null);
        }

        private void addFocusableChildrenToList(List&lt;Node&gt; list, Parent parent) {
            List&lt;Node&gt; parentsNodes = parent.getChildrenUnmodifiable();
            for (Node n : parentsNodes) {
                if (n.isFocusTraversable() &amp;&amp; !n.isFocused() &amp;&amp; NodeHelper.isTreeVisible(n) &amp;&amp; !n.isDisabled()) {
                    list.add(n);
                }
                if (n instanceof Parent) {
                    addFocusableChildrenToList(list, (Parent)n);
                }
            }
        }

        // All of the methods below are callbacks from traversal context to the default algorithm.
        // They can be used to obtain &quot;default&quot; result for the specified subtree.
        // This is useful when there is some algorithm that overrides behavior for a Parent but parent's children
        // should be again traversed by default algorithm.
        @Override
        public Node selectFirstInParent(Parent parent) {
            tempEngineContext.setRoot(parent);
            return DEFAULT_ALGORITHM.selectFirst(tempEngineContext);
        }

        @Override
        public Node selectLastInParent(Parent parent) {
            tempEngineContext.setRoot(parent);
            return DEFAULT_ALGORITHM.selectLast(tempEngineContext);
        }

        @Override
        public Node selectInSubtree(Parent subTreeRoot, Node from, Direction dir) {
            tempEngineContext.setRoot(subTreeRoot);
            return DEFAULT_ALGORITHM.select(from, dir, tempEngineContext);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/scene/traversal/WeightedClosestCorner.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.traversal;

import java.util.List;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Node;

import static com.sun.javafx.scene.traversal.Direction.*;

/**
 * First search for on-axis nodes. A node is on-axis if any part of its
 * closest edge lies between the pair of rays cast in the traversal direction
 * from the corners of the originating node.
 *
 * If there are multiple on-axis nodes, the closest is chosen.
 *
 * If there is a tie for the closest on-axis node, the tie is broken
 * by choosing the one whose center is closest to the center of the
 * originating node. TODO: investigate alternative tiebreaker algorithms
 * (filed as RT-19470).
 *
 * If there are no on-axis nodes, compute the distance OUT (in the traversal
 * direction) and the distance to the SIDE (perpendicular to the traversal
 * direction) and compute a distance metric OUT + WEIGHT * SIDE. Choose the
 * node with the smallest distance metric.
 *
 * TODO: presumably WEIGHT is greater than one, so that nodes farther OUT
 * but close (and not on) axis are chosen in preference to nodes that are
 * physically closer but are farther off to the side. Determine WEIGHT
 * somehow, possibly empirically (filed as RT-19471).
 */

public class WeightedClosestCorner implements Algorithm {


    WeightedClosestCorner() {
    }

    private boolean isOnAxis(Direction dir, Bounds cur, Bounds tgt) {

        final double cmin, cmax, tmin, tmax;

        if (dir == UP || dir == DOWN) {
            cmin = cur.getMinX();
            cmax = cur.getMaxX();
            tmin = tgt.getMinX();
            tmax = tgt.getMaxX();
        }
        else { // dir == LEFT || dir == RIGHT
            cmin = cur.getMinY();
            cmax = cur.getMaxY();
            tmin = tgt.getMinY();
            tmax = tgt.getMaxY();
        }

        return tmin &lt;= cmax &amp;&amp; tmax &gt;= cmin;
    }

    /**
     * Compute the out-distance to the near edge of the target in the
     * traversal direction. Negative means the near edge is &quot;behind&quot;.
     */
    private double outDistance(Direction dir, Bounds cur, Bounds tgt) {

        final double distance;

        if (dir == UP) {
            distance = cur.getMinY() - tgt.getMaxY();
        }
        else if (dir == DOWN) {
            distance = tgt.getMinY() - cur.getMaxY();
        }
        else if (dir == LEFT) {
            distance = cur.getMinX() - tgt.getMaxX();
        }
        else { // dir == RIGHT
            distance = tgt.getMinX() - cur.getMaxX();
        }

        return distance;
    }

    /**
     * Computes the side distance from current center to target center.
     * Always positive. This is only used for on-axis nodes.
     */
    private double centerSideDistance(Direction dir, Bounds cur, Bounds tgt) {

        final double cc; // current center
        final double tc; // target center

        if (dir == UP || dir == DOWN) {
            cc = cur.getMinX() + cur.getWidth() / 2.0f;
            tc = tgt.getMinX() + tgt.getWidth() / 2.0f;
        }
        else { // dir == LEFT || dir == RIGHT
            cc = cur.getMinY() + cur.getHeight() / 2.0f;
            tc = tgt.getMinY() + tgt.getHeight() / 2.0f;
        }

        return Math.abs(tc - cc);
        //return (tc &gt; cc) ? tc - cc : cc - tc;
    }

    /**
     * Computes the side distance between the closest corners of the current
     * and target. Always positive. This is only used for off-axis nodes.
     */
    private double cornerSideDistance(Direction dir, Bounds cur, Bounds tgt) {

        final double distance;

        if (dir == UP || dir == DOWN) {

            if (tgt.getMinX() &gt; cur.getMaxX()) {
                // on the right
                distance = tgt.getMinX() - cur.getMaxX();
            }
            else {
                // on the left
                distance = cur.getMinX() - tgt.getMaxX();
            }
        }
        else { // dir == LEFT or dir == RIGHT

            if (tgt.getMinY() &gt; cur.getMaxY()) {
                // below
                distance = tgt.getMinY() - cur.getMaxY();
            }
            else {
                // above
                distance = cur.getMinY() - tgt.getMaxY();
            }
        }
        return distance;
    }

    public Node select(Node node, Direction dir, TraversalContext context) {
        Node newNode = null;
        List&lt;Node&gt; nodes = context.getAllTargetNodes();

        int target = traverse(context.getSceneLayoutBounds(node), dir, nodes, context);
        if (target != -1) {
            newNode = nodes.get(target);
        }

        return newNode;
    }

    @Override
    public Node selectFirst(TraversalContext context) {
        List&lt;Node&gt; nodes = context.getAllTargetNodes();
        Point2D zeroZero = new Point2D(0,0);

        if (nodes.size() &gt; 0) {
            int nodeIndex;
            Node nearestNode = nodes.get(0);
            double nearestDistance = zeroZero.distance(context.getSceneLayoutBounds(nodes.get(0)).getMinX(),
                    context.getSceneLayoutBounds(nodes.get(0)).getMinY());
            double distance;

            for (nodeIndex = 1; nodeIndex &lt; nodes.size(); nodeIndex++) {
                distance = zeroZero.distance(context.getSceneLayoutBounds(nodes.get(nodeIndex)).getMinX(),
                        context.getSceneLayoutBounds(nodes.get(nodeIndex)).getMinY());
                if (nearestDistance &gt; distance) {
                    nearestDistance = distance;
                    nearestNode = nodes.get(nodeIndex);
                }
            }
            return nearestNode;
        }
        return null;
    }

    @Override
    public Node selectLast(TraversalContext context) {
        return null;
    }

    public int traverse(Bounds origin, Direction dir, List&lt;Node&gt; targets, TraversalContext context) {

        final int target;

        if (dir == NEXT || dir == NEXT_IN_LINE || dir == PREVIOUS) {
            target = trav1D(origin, dir, targets, context);
        } else {
            target = trav2D(origin, dir, targets, context);
        }

        return target;
    }

    private int trav2D(Bounds origin, Direction dir, List&lt;Node&gt; targets, TraversalContext context) {

        Bounds bestBounds = null;
        double bestMetric = 0.0;
        int bestIndex = -1;

        for (int i = 0; i &lt; targets.size(); i++) {
            final Bounds targetBounds = context.getSceneLayoutBounds(targets.get(i));
            final double outd = outDistance(dir, origin, targetBounds);
            final double metric;

            if (isOnAxis(dir, origin, targetBounds)) {
                metric = outd + centerSideDistance(dir, origin, targetBounds) / 100;
            }
            else {
                final double cosd = cornerSideDistance(dir, origin, targetBounds);
                metric = 100000 + outd*outd + 9*cosd*cosd;
            }

            if (outd &lt; 0.0) {
                continue;
            }

            if (bestBounds == null || metric &lt; bestMetric) {
                bestBounds = targetBounds;
                bestMetric = metric;
                bestIndex = i;
            }
        }

        return bestIndex;
    }

    /*
     * Consider focus targets to have a total order using values
     * (minY, minX, hashCode).
     */
    private int compare1D(Bounds a, Bounds b) {

        int res = 0;

        // the following use the node's center
        final double metric1a = (a.getMinY() + a.getMaxY()) / 2;
        final double metric1b = (b.getMinY() + b.getMaxY()) / 2;
        final double metric2a = (a.getMinX() + a.getMaxX()) / 2;
        final double metric2b = (b.getMinX() + b.getMaxX()) / 2;
        final double metric3a = a.hashCode();
        final double metric3b = b.hashCode();

        if (metric1a &lt; metric1b) {
            res = -1;
        }
        else if (metric1a &gt; metric1b) {
            res = 1;
        }
<A NAME="25"></A>        else if (metric2a &lt; metric2b) {
            res = -1;
        }
        else <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#25',2,'match34-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (metric2a &gt; metric2b) {
            res = 1;
        }
        else if (metric3a &lt; metric3b) {
            res = -1;
        }
        else if (metric3a &gt; metric3b) {
            res = 1;
        }</B></FONT>

        return res;
    }


    private int compare1D(Bounds a, Bounds b, Direction dir) {
        return (dir != PREVIOUS) ? -compare1D(a, b) : compare1D(a, b);
    }

    private int trav1D(Bounds origin, Direction dir, List&lt;Node&gt; targets, TraversalContext context) {
        int bestSoFar = -1;
        int leastSoFar = -1;

        for (int i = 0; i &lt; targets.size(); i++) {
            if (leastSoFar == -1 ||
                    compare1D(context.getSceneLayoutBounds(targets.get(i)),
                            context.getSceneLayoutBounds(targets.get(leastSoFar)), dir) &lt; 0) {
                leastSoFar = i;
            }

            if (compare1D(context.getSceneLayoutBounds(targets.get(i)), origin, dir) &lt; 0) {
                continue;
            }

            if (bestSoFar == -1 ||
                    compare1D(context.getSceneLayoutBounds(targets.get(i)), context.getSceneLayoutBounds(targets.get(bestSoFar)), dir) &lt; 0) {
                bestSoFar = i;
            }
        }

        return (bestSoFar == -1) ? leastSoFar : bestSoFar;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/openpisces/Curve.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.openpisces;

import java.util.Iterator;

final class Curve {

    float ax, ay, bx, by, cx, cy, dx, dy;
    float dax, day, dbx, dby;

    Curve() {
    }

    void set(float[] points, int type) {
        switch(type) {
        case 8:
            set(points[0], points[1],
                points[2], points[3],
                points[4], points[5],
                points[6], points[7]);
            break;
        case 6:
            set(points[0], points[1],
                points[2], points[3],
                points[4], points[5]);
            break;
        default:
            throw new InternalError(&quot;Curves can only be cubic or quadratic&quot;);
        }
    }

    void set(float x1, float y1,
             float x2, float y2,
             float x3, float y3,
             float x4, float y4)
    {
        ax = 3 * (x2 - x3) + x4 - x1;
        ay = 3 * (y2 - y3) + y4 - y1;
        bx = 3 * (x1 - 2 * x2 + x3);
        by = 3 * (y1 - 2 * y2 + y3);
        cx = 3 * (x2 - x1);
        cy = 3 * (y2 - y1);
        dx = x1;
        dy = y1;
        dax = 3 * ax; day = 3 * ay;
        dbx = 2 * bx; dby = 2 * by;
    }

    void set(float x1, float y1,
             float x2, float y2,
             float x3, float y3)
    {
        ax = ay = 0f;

        bx = x1 - 2 * x2 + x3;
        by = y1 - 2 * y2 + y3;
        cx = 2 * (x2 - x1);
        cy = 2 * (y2 - y1);
        dx = x1;
        dy = y1;
        dax = 0; day = 0;
        dbx = 2 * bx; dby = 2 * by;
    }

    float xat(float t) {
        return t * (t * (t * ax + bx) + cx) + dx;
    }
    float yat(float t) {
        return t * (t * (t * ay + by) + cy) + dy;
    }

    float dxat(float t) {
        return t * (t * dax + dbx) + cx;
    }

    float dyat(float t) {
        return t * (t * day + dby) + cy;
    }

    int dxRoots(float[] roots, int off) {
        return Helpers.quadraticRoots(dax, dbx, cx, roots, off);
    }

    int dyRoots(float[] roots, int off) {
        return Helpers.quadraticRoots(day, dby, cy, roots, off);
    }

    int infPoints(float[] pts, int off) {
        // inflection point at t if -f'(t)x*f''(t)y + f'(t)y*f''(t)x == 0
        // Fortunately, this turns out to be quadratic, so there are at
        // most 2 inflection points.
        final float a = dax * dby - dbx * day;
        final float b = 2 * (cy * dax - day * cx);
        final float c = cy * dbx - cx * dby;

        return Helpers.quadraticRoots(a, b, c, pts, off);
    }

    // finds points where the first and second derivative are
    // perpendicular. This happens when g(t) = f'(t)*f''(t) == 0 (where
    // * is a dot product). Unfortunately, we have to solve a cubic.
    private int perpendiculardfddf(float[] pts, int off) {
        assert pts.length &gt;= off + 4;

        // these are the coefficients of some multiple of g(t) (not g(t),
        // because the roots of a polynomial are not changed after multiplication
        // by a constant, and this way we save a few multiplications).
        final float a = 2*(dax*dax + day*day);
        final float b = 3*(dax*dbx + day*dby);
        final float c = 2*(dax*cx + day*cy) + dbx*dbx + dby*dby;
        final float d = dbx*cx + dby*cy;
        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0f, 1f);
    }

    // Tries to find the roots of the function ROC(t)-w in [0, 1). It uses
    // a variant of the false position algorithm to find the roots. False
    // position requires that 2 initial values x0,x1 be given, and that the
    // function must have opposite signs at those values. To find such
    // values, we need the local extrema of the ROC function, for which we
    // need the roots of its derivative; however, it's harder to find the
    // roots of the derivative in this case than it is to find the roots
    // of the original function. So, we find all points where this curve's
    // first and second derivative are perpendicular, and we pretend these
    // are our local extrema. There are at most 3 of these, so we will check
    // at most 4 sub-intervals of (0,1). ROC has asymptotes at inflection
    // points, so roc-w can have at least 6 roots. This shouldn't be a
    // problem for what we're trying to do (draw a nice looking curve).
    int rootsOfROCMinusW(float[] roots, int off, final float w, final float err) {
        // no OOB exception, because by now off&lt;=6, and roots.length &gt;= 10
        assert off &lt;= 6 &amp;&amp; roots.length &gt;= 10;
        int ret = off;
        int numPerpdfddf = perpendiculardfddf(roots, off);
        float t0 = 0, ft0 = ROCsq(t0) - w*w;
        roots[off + numPerpdfddf] = 1f; // always check interval end points
        numPerpdfddf++;
        for (int i = off; i &lt; off + numPerpdfddf; i++) {
            float t1 = roots[i], ft1 = ROCsq(t1) - w*w;
            if (ft0 == 0f) {
                roots[ret++] = t0;
            } else if (ft1 * ft0 &lt; 0f) { // have opposite signs
                // (ROC(t)^2 == w^2) == (ROC(t) == w) is true because
                // ROC(t) &gt;= 0 for all t.
                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w*w, err);
            }
            t0 = t1;
            ft0 = ft1;
        }

        return ret - off;
    }

    private static float eliminateInf(float x) {
        return (x == Float.POSITIVE_INFINITY ? Float.MAX_VALUE :
            (x == Float.NEGATIVE_INFINITY ? Float.MIN_VALUE : x));
    }

    // A slight modification of the false position algorithm on wikipedia.
    // This only works for the ROCsq-x functions. It might be nice to have
    // the function as an argument, but that would be awkward in java6.
    // TODO: It is something to consider for java8 (or whenever lambda
    // expressions make it into the language), depending on how closures
    // and turn out. Same goes for the newton's method
    // algorithm in Helpers.java (RT-26922)
    private float falsePositionROCsqMinusX(float x0, float x1,
                                           final float x, final float err)
    {
        final int iterLimit = 100;
        int side = 0;
        float t = x1, ft = eliminateInf(ROCsq(t) - x);
        float s = x0, fs = eliminateInf(ROCsq(s) - x);
        float r = s, fr;
        for (int i = 0; i &lt; iterLimit &amp;&amp; Math.abs(t - s) &gt; err * Math.abs(t + s); i++) {
<A NAME="7"></A>            r = (fs * t - ft * s) / (fs - ft);
            fr = ROCsq(r) - x;
            if (sameSign(fr, ft)) {
                ft = fr; <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#7',2,'match34-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>t = r;
                if (side &lt; 0) {
                    fs /= (1 &lt;&lt; (-side));
                    side--;
                } else {
                    side = -1;
                }</B></FONT>
            } else if (fr * fs &gt; 0) {
                fs = fr; s = r;
                if (side &gt; 0) {
                    ft /= (1 &lt;&lt; side);
                    side++;
                } else {
                    side = 1;
                }
            } else {
                break;
            }
        }
        return r;
    }

    private static boolean sameSign(double x, double y) {
        // another way is to test if x*y &gt; 0. This is bad for small x, y.
        return (x &lt; 0 &amp;&amp; y &lt; 0) || (x &gt; 0 &amp;&amp; y &gt; 0);
    }

    // returns the radius of curvature squared at t of this curve
    // see http://en.wikipedia.org/wiki/Radius_of_curvature_(applications)
    private float ROCsq(final float t) {
        // dx=xat(t) and dy=yat(t). These calls have been inlined for efficiency
        final float dx = t * (t * dax + dbx) + cx;
        final float dy = t * (t * day + dby) + cy;
        final float ddx = 2 * dax * t + dbx;
        final float ddy = 2 * day * t + dby;
        final float dx2dy2 = dx*dx + dy*dy;
        final float ddx2ddy2 = ddx*ddx + ddy*ddy;
        final float ddxdxddydy = ddx*dx + ddy*dy;
        return dx2dy2*((dx2dy2*dx2dy2) / (dx2dy2 * ddx2ddy2 - ddxdxddydy*ddxdxddydy));
    }

    // curve to be broken should be in pts
    // this will change the contents of pts but not Ts
    // TODO: There's no reason for Ts to be an array. All we need is a sequence
    // of t values at which to subdivide. An array statisfies this condition,
    // but is unnecessarily restrictive. Ts should be an Iterator&lt;Float&gt; instead.
    // Doing this will also make dashing easier, since we could easily make
    // LengthIterator an Iterator&lt;Float&gt; and feed it to this function to simplify
    // the loop in Dasher.somethingTo. (RT-26922)
    static Iterator&lt;Integer&gt; breakPtsAtTs(final float[] pts, final int type,
                                          final float[] Ts, final int numTs)
    {
        assert pts.length &gt;= 2*type &amp;&amp; numTs &lt;= Ts.length;
        return new Iterator&lt;Integer&gt;() {
            // these prevent object creation and destruction during autoboxing.
            // Because of this, the compiler should be able to completely
            // eliminate the boxing costs.
            final Integer i0 = 0;
            final Integer itype = type;
            int nextCurveIdx = 0;
            Integer curCurveOff = i0;
            float prevT = 0;

            @Override public boolean hasNext() {
                return nextCurveIdx &lt; numTs + 1;
            }

            @Override public Integer next() {
                Integer ret;
                if (nextCurveIdx &lt; numTs) {
                    float curT = Ts[nextCurveIdx];
                    float splitT = (curT - prevT) / (1 - prevT);
                    Helpers.subdivideAt(splitT,
                                        pts, curCurveOff,
                                        pts, 0,
                                        pts, type, type);
                    prevT = curT;
                    ret = i0;
                    curCurveOff = itype;
                } else {
                    ret = curCurveOff;
                }
                nextCurveIdx++;
                return ret;
            }

            @Override public void remove() {}
        };
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/MultiTexture.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.ArrayList;

<A NAME="2"></A>/**
 * A &quot;texture&quot; that wraps a list of sub-textures and values needed for multitexturing.
 */
<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#2',2,'match34-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public final class MultiTexture implements Texture {
    private int width;
    private int height;
    private PixelFormat format;
    private WrapMode wrapMode;
    private boolean linearFiltering = true;
    private final ArrayList&lt;Texture&gt; textures;
    private int lastImageSerial;

    public MultiTexture(PixelFormat format, WrapMode wrapMode, int width, int height) {
        this.width = width;
        this.height = height;
        t</B></FONT>his.format = format;
        this.wrapMode = wrapMode;
        textures = new ArrayList&lt;Texture&gt;(4);
    }

    private MultiTexture(MultiTexture sharedTex, WrapMode newMode) {
        this(sharedTex.format, newMode, sharedTex.width, sharedTex.height);
        for (int i = 0; i &lt; sharedTex.textureCount(); i++) {
            Texture t = sharedTex.getTexture(i);
            setTexture(t.getSharedTexture(newMode), i);
        }
        // REMIND: Do I need to use indirection to share these 2 field values?
        this.linearFiltering = sharedTex.linearFiltering;
        this.lastImageSerial = sharedTex.lastImageSerial;
    }

    @Override
    public Texture getSharedTexture(WrapMode altMode) {
        assertLocked();
        if (wrapMode == altMode) {
            lock();
            return this;
        }
        switch (altMode) {
            case REPEAT:
                if (wrapMode != WrapMode.CLAMP_TO_EDGE) {
                    return null;
                }
                break;
            case CLAMP_TO_EDGE:
                if (wrapMode != WrapMode.REPEAT) {
                    return null;
                }
                break;
            default:
                return null;
        }
        Texture altTex = new MultiTexture(this, altMode);
        altTex.lock();
        return altTex;
    }

    public int textureCount() {
        return textures.size();
    }

    public void setTexture(Texture tex, int index) {
        if (!tex.getWrapMode().isCompatibleWith(wrapMode)) {
            throw new IllegalArgumentException(&quot;texture wrap mode must match multi-texture mode&quot;);
        }
        if (textures.size() &lt; (index+1)) {
            // add null entries to fill in, then add tex to the end
            for (int ii = textures.size(); ii &lt; index; ii++) {
                textures.add(null);
            }
            textures.add(tex);
        } else {
            textures.set(index, tex);
        }
        tex.setLinearFiltering(linearFiltering);
    }

    public Texture getTexture(int index) {
        return textures.get(index);
    }

    public Texture[] getTextures() {
        return textures.toArray(new Texture[textures.size()]);
    }

    public void removeTexture(Texture tex) {
        textures.remove(tex);
    }

    public void removeTexture(int index) {
        textures.remove(index);
    }

    @Override
    public PixelFormat getPixelFormat() {
        return format;
    }

    @Override
    public int getPhysicalWidth() {
        return width;
    }

    @Override
    public int getPhysicalHeight() {
        return height;
    }

    @Override
    public int getContentX() {
        return 0;
    }

    @Override
    public int getContentY() {
        return 0;
    }

    @Override
    public int getContentWidth() {
        return width;
    }

    @Override
    public int getContentHeight() {
        return height;
    }

    @Override
    public int getLastImageSerial() {
        return lastImageSerial;
    }

    @Override
    public void setLastImageSerial(int serial) {
        lastImageSerial = serial;
    }

    @Override
    public void update(Image img) {
        throw new UnsupportedOperationException(&quot;Update from Image not supported&quot;);
    }

    @Override
    public void update(Image img, int dstx, int dsty) {
        throw new UnsupportedOperationException(&quot;Update from Image not supported&quot;);
    }

    @Override
    public void update(Image img, int dstx, int dsty, int srcw, int srch) {
        throw new UnsupportedOperationException(&quot;Update from Image not supported&quot;);
    }

    @Override
    public void update(Image img, int dstx, int dsty, int srcw, int srch, boolean skipFlush) {
        throw new UnsupportedOperationException(&quot;Update from Image not supported&quot;);
    }

    @Override
    public void update(Buffer buffer, PixelFormat format,
                       int dstx, int dsty,
                       int srcx, int srcy, int srcw, int srch,
                       int srcscan, boolean skipFlush)
    {
        throw new UnsupportedOperationException(&quot;Update from generic Buffer not supported&quot;);
    }

    @Override
    public void update(MediaFrame frame, boolean skipFlush) {
        if (frame.getPixelFormat() == PixelFormat.MULTI_YCbCr_420) {
            // call update(..) on each texture
            Texture tex;
            int encWidth = frame.getEncodedWidth();
            int encHeight = frame.getEncodedHeight();

            for (int index = 0; index &lt; frame.planeCount(); index++) {
                tex = textures.get(index);
                if (null != tex) {
                    int texWidth = encWidth;
                    int texHeight = encHeight;

                    if (index == PixelFormat.YCBCR_PLANE_CHROMABLUE
                            || index == PixelFormat.YCBCR_PLANE_CHROMARED) {
                        texWidth /= 2;
                        texHeight /= 2;
                    }

                    ByteBuffer pixels = frame.getBufferForPlane(index);
                    tex.update(pixels, PixelFormat.BYTE_ALPHA,
                            0, 0,
                            0, 0, texWidth, texHeight,
                            frame.strideForPlane(index), skipFlush);
                }
            }
        } else {
            throw new IllegalArgumentException(&quot;Invalid pixel format in MediaFrame&quot;);
        }
    }

    @Override
    public WrapMode getWrapMode() {
        return wrapMode;
    }

    @Override
    public boolean getUseMipmap() {
        // TODO: MultiTexture doesn't support mipmap yet
        return false;
    }

    @Override
    public boolean getLinearFiltering() {
        return linearFiltering;
    }

    @Override
    public void setLinearFiltering(boolean linear) {
        this.linearFiltering = linear;
        for (Texture tex : textures) {
            tex.setLinearFiltering(linear);
        }
    }

    @Override
    public void lock() {
        for (Texture tex : textures) {
            tex.lock();
        }
    }

    @Override
    public void unlock() {
        for (Texture tex : textures) {
            tex.unlock();
        }
    }

    @Override
    public boolean isLocked() {
        for (Texture tex : textures) {
            if (tex.isLocked()) return true;
        }
        return false;
    }

    @Override
    public int getLockCount() {
        int count = 0;
        for (Texture tex : textures) {
            count = Math.max(count, tex.getLockCount());
        }
        return count;
    }

    @Override
    public void assertLocked() {
        for (Texture tex : textures) {
            tex.assertLocked();
        }
    }

    @Override
    public void makePermanent() {
        for (Texture tex : textures) {
            tex.makePermanent();
        }
    }

    @Override
    public void contentsUseful() {
        for (Texture tex : textures) {
            tex.contentsUseful();
        }
    }

    @Override
    public void contentsNotUseful() {
        for (Texture tex : textures) {
            tex.contentsNotUseful();
        }
    }

    @Override
    public boolean isSurfaceLost() {
        for (Texture tex : textures) {
            if (tex.isSurfaceLost()) return true;
        }
        return false;
    }

    @Override
    public void dispose() {
        for (Texture tex : textures) {
            tex.dispose();
        }
        textures.clear();
    }

    @Override
    public int getMaxContentWidth() {
        return getPhysicalWidth();
    }

    @Override
    public int getMaxContentHeight() {
        return getPhysicalHeight();
    }

    @Override
    public void setContentWidth(int contentWidth) {
        throw new UnsupportedOperationException(&quot;Not supported.&quot;);
    }

    @Override
    public void setContentHeight(int contentHeight) {
        throw new UnsupportedOperationException(&quot;Not supported.&quot;);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/es2/GLPixelFormat.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.es2;

import java.lang.annotation.Native;
import java.security.AccessController;
import java.security.PrivilegedAction;

import com.sun.glass.utils.NativeLibLoader;
import com.sun.javafx.PlatformUtil;
import com.sun.prism.impl.PrismSettings;

class GLPixelFormat {
    final private Attributes attributes;
    final private long nativeScreen;
    private long nativePFInfo;
    private static int defaultDepthSize;
    private static int defaultBufferSize;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
           defaultDepthSize = Integer.getInteger(&quot;prism.glDepthSize&quot;, 24);
           defaultBufferSize = Integer.getInteger(&quot;prism.glBufferSize&quot;, 32);
            return null;
        });
    }

    GLPixelFormat(long nativeScreen, Attributes attributes) {
        this.nativeScreen = nativeScreen;
        this.attributes = attributes;
    }

    Attributes getAttributes() {
        return attributes;
    }

    long getNativeScreen() {
        return nativeScreen;
    }

    void setNativePFInfo(long nativePFInfo) {
        this.nativePFInfo = nativePFInfo;
    }

    long getNativePFInfo() {
        return nativePFInfo;
    }

    static class Attributes {
        //  These definitions are used by both the Mac, Win and X11 subclasses
        @Native final static int RED_SIZE      = 0;
        @Native final static int GREEN_SIZE    = 1;
        @Native final static int BLUE_SIZE     = 2;
        @Native final static int ALPHA_SIZE    = 3;
        @Native final static int DEPTH_SIZE    = 4;
        @Native final static int DOUBLEBUFFER  = 5;
        @Native final static int ONSCREEN      = 6;

        @Native final static int NUM_ITEMS     = 7;

        private boolean onScreen;
        private boolean doubleBuffer;
        private int alphaSize;
        private int blueSize;
        private int greenSize;
        private int redSize;
        private int depthSize;

        Attributes() {
            onScreen = true;
            doubleBuffer = true;
            depthSize = defaultDepthSize;
            switch (defaultBufferSize) {
                case 32:
                    redSize = greenSize = blueSize = alphaSize = 8;
                    break;
                case 24:
                    redSize = greenSize = blueSize = 8;
                    alphaSize = 0;
                    break;
                case 16:
                    redSize = blueSize = 5;
                    greenSize = 6;
                    alphaSize = 0;
                    break;
                default:
                    throw new IllegalArgumentException(&quot;color buffer size &quot;
                            + defaultBufferSize + &quot; not supported&quot;);
            }
        }

        boolean isOnScreen() {
            return onScreen;
        }

        boolean isDoubleBuffer() {
            return doubleBuffer;
        }

        int getDepthSize() {
            return depthSize;
        }

        int getAlphaSize() {
            return alphaSize;
        }

        int getBlueSize() {
            return blueSize;
        }

        int getGreenSize() {
            return greenSize;
        }

        int getRedSize() {
            return redSize;
        }

        void setOnScreen(boolean os) {
            onScreen = os;
        }

        void setDoubleBuffer(boolean db) {
            doubleBuffer = db;
<A NAME="3"></A>        }

        void setDepthSize(int ds) {
            <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#3',2,'match34-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>depthSize = ds;
        }

        void setAlphaSize(int as) {
            alphaSize = as;
        }

        void setBlueSize(int bs) {
            blueSize = bs;
        }

        void setGreenSize(int gs) {
            greenSize = gs;
        }

        void setRedSize(int rs) {
            redSize = rs;
        }

        public String toString() {
            return</B></FONT> &quot;onScreen: &quot; + onScreen
                    + &quot;redSize : &quot; + redSize + &quot;, &quot;
                    + &quot;greenSize : &quot; + greenSize + &quot;, &quot;
                    + &quot;blueSize : &quot; + blueSize + &quot;, &quot;
                    + &quot;alphaSize : &quot; + alphaSize + &quot;, &quot;
                    + &quot;depthSize : &quot; + depthSize + &quot;, &quot;
                    + &quot;doubleBuffer : &quot; + doubleBuffer;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/shape/MaskData.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.shape;

import com.sun.prism.PixelFormat;
import com.sun.prism.Texture;
import java.nio.ByteBuffer;

public class MaskData {

    private ByteBuffer maskBuffer;
    private int originX;
    private int originY;
    private int width;
    private int height;

    public MaskData() {
    }

    public ByteBuffer getMaskBuffer() {
        return maskBuffer;
    }

    public int getOriginX() {
        return originX;
    }

    public int getOriginY() {
        return originY;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }
<A NAME="16"></A>
    public void uploadToTexture(Texture tex, int dstx, int dsty,
                                boolean skipFlush)
    <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#16',2,'match34-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        int scan = width * tex.getPixelFormat().getBytesPerPixelUnit();
        tex.update(maskBuffer, tex.getPixelFormat(),
                   dstx, dsty, 0, 0, width, height,
                   scan, skipFlush);
    }

    public void update(ByteBuffer maskBuffer,
                       int originX, int originY</B></FONT>, int width, int height)
    {
        this.maskBuffer = maskBuffer;
        this.originX = originX;
        this.originY = originY;
        this.width = width;
        this.height = height;
    }

    public static MaskData create(byte[] pixels,
                                  int originX, int originY,
                                  int width, int height)
    {
        MaskData maskData = new MaskData();
        maskData.update(ByteBuffer.wrap(pixels), originX, originY, width, height);
        return maskData;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/sw/SWPaint.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.sw;

import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.pisces.GradientColorMap;
import com.sun.pisces.PiscesRenderer;
import com.sun.pisces.RendererBase;
import com.sun.pisces.Transform6;
import com.sun.prism.Image;
import com.sun.prism.PixelFormat;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.paint.Stop;

final class SWPaint {

    private final SWContext context;
    private final PiscesRenderer pr;

    private final BaseTransform paintTx = new Affine2D();
    private final Transform6 piscesTx = new Transform6();

    private float compositeAlpha = 1.0f;
    private float px, py, pw, ph;

    SWPaint(SWContext context, PiscesRenderer pr) {
        this.context = context;
        this.pr = pr;
    }

    float getCompositeAlpha() {
        return compositeAlpha;
    }

    void setCompositeAlpha(float newValue) {
        compositeAlpha = newValue;
<A NAME="12"></A>    }

    void setColor(Color c, float compositeAlpha) {
        <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#12',2,'match34-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (PrismSettings.debug) {
            System.out.println(&quot;PR.setColor: &quot; + c);
        }
        this.pr.setColor((int) (c.getRed() * 255),
                (int) (255 * c.getGreen()),
                (int) (255 * c.getBlue()),
                (int) (255 * c.getAlpha() * compositeAlpha));
    }

    void setPaintFromShape(Paint p</B></FONT>, BaseTransform tx, Shape shape, RectBounds nodeBounds,
                           float localX, float localY, float localWidth, float localHeight)
    {
        this.computePaintBounds(p, shape, nodeBounds, localX, localY, localWidth, localHeight);
        this.setPaintBeforeDraw(p, tx, px, py, pw, ph);
    }

    private void computePaintBounds(Paint p, Shape shape, RectBounds nodeBounds,
                                    float localX, float localY, float localWidth, float localHeight)
    {
        if (p.isProportional()) {
            if (nodeBounds != null) {
                px = nodeBounds.getMinX();
                py = nodeBounds.getMinY();
                pw = nodeBounds.getWidth();
                ph = nodeBounds.getHeight();
            } else if (shape != null) {
                final RectBounds bounds = shape.getBounds();
                px = bounds.getMinX();
                py = bounds.getMinY();
                pw = bounds.getWidth();
                ph = bounds.getHeight();
            } else {
                px = localX;
                py = localY;
                pw = localWidth;
                ph = localHeight;
            }
        } else {
            px = py = pw = ph = 0;
        }
    }

    void setPaintBeforeDraw(Paint p, BaseTransform tx, float x, float y, float width, float height) {
        switch (p.getType()) {
            case COLOR:
                this.setColor((Color)p, this.compositeAlpha);
                break;
            case LINEAR_GRADIENT:
                final LinearGradient lg = (LinearGradient)p;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setLinearGradient: &quot; + lg.getX1() + &quot;, &quot; + lg.getY1() + &quot;, &quot; + lg.getX2() + &quot;, &quot; + lg.getY2());
                }

                paintTx.setTransform(tx);
                SWUtils.convertToPiscesTransform(paintTx, piscesTx);

                float x1 = lg.getX1();
                float y1 = lg.getY1();
                float x2 = lg.getX2();
                float y2 = lg.getY2();
                if (lg.isProportional()) {
                    x1 = x + width * x1;
                    y1 = y + height * y1;
                    x2 = x + width * x2;
                    y2 = y + height * y2;
                }
                this.pr.setLinearGradient((int)(SWUtils.TO_PISCES * x1), (int)(SWUtils.TO_PISCES * y1),
                        (int)(SWUtils.TO_PISCES * x2), (int)(SWUtils.TO_PISCES * y2),
                        getFractions(lg), getARGB(lg, this.compositeAlpha), getPiscesGradientCycleMethod(lg.getSpreadMethod()), piscesTx);
                break;
            case RADIAL_GRADIENT:
                final RadialGradient rg = (RadialGradient)p;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setRadialGradient: &quot; + rg.getCenterX() + &quot;, &quot; + rg.getCenterY() + &quot;, &quot; + rg.getFocusAngle() + &quot;, &quot; + rg.getFocusDistance() + &quot;, &quot; + rg.getRadius());
                }

                paintTx.setTransform(tx);

                float cx = rg.getCenterX();
                float cy = rg.getCenterY();
                float r = rg.getRadius();
                if (rg.isProportional()) {
                    float dim = Math.min(width, height);
                    float bcx = x + width * 0.5f;
                    float bcy = y + height * 0.5f;
                    cx = bcx + (cx - 0.5f) * dim;
                    cy = bcy + (cy - 0.5f) * dim;
                    r *= dim;
                    if (width != height &amp;&amp; width != 0.0 &amp;&amp; height != 0.0) {
                        paintTx.deriveWithTranslation(bcx, bcy);
                        paintTx.deriveWithConcatenation(width / dim, 0, 0, height / dim, 0, 0);
                        paintTx.deriveWithTranslation(-bcx, -bcy);
                    }
                }
                SWUtils.convertToPiscesTransform(paintTx, piscesTx);

                final float fx = (float)(cx + rg.getFocusDistance() * r * Math.cos(Math.toRadians(rg.getFocusAngle())));
                final float fy = (float)(cy + rg.getFocusDistance() * r * Math.sin(Math.toRadians(rg.getFocusAngle())));

                this.pr.setRadialGradient((int) (SWUtils.TO_PISCES * cx), (int) (SWUtils.TO_PISCES * cy),
                        (int) (SWUtils.TO_PISCES * fx), (int) (SWUtils.TO_PISCES * fy), (int) (SWUtils.TO_PISCES * r),
                        getFractions(rg), getARGB(rg, this.compositeAlpha), getPiscesGradientCycleMethod(rg.getSpreadMethod()), piscesTx);
                break;
            case IMAGE_PATTERN:
                final ImagePattern ip = (ImagePattern)p;
                if (ip.getImage().getPixelFormat() == PixelFormat.BYTE_ALPHA) {
                    throw new UnsupportedOperationException(&quot;Alpha image is not supported as an image pattern.&quot;);
                } else {
                    this.computeImagePatternTransform(ip, tx, x, y, width, height);
                    final SWArgbPreTexture tex = context.validateImagePaintTexture(ip.getImage().getWidth(), ip.getImage().getHeight());
                    tex.update(ip.getImage());
                    if (this.compositeAlpha &lt; 1.0f) {
                        tex.applyCompositeAlpha(this.compositeAlpha);
                    }

                    this.pr.setTexture(RendererBase.TYPE_INT_ARGB_PRE, tex.getDataNoClone(),
                            tex.getContentWidth(), tex.getContentHeight(), tex.getPhysicalWidth(),
                            piscesTx,
                            tex.getWrapMode() == Texture.WrapMode.REPEAT,
                            tex.hasAlpha());
                }
                break;
            default:
                throw new IllegalArgumentException(&quot;Unknown paint type: &quot; + p.getType());
        }
    }

    private static int[] getARGB(Gradient grd, float compositeAlpha) {
        final int nstops = grd.getNumStops();
        final int argb[] = new int[nstops];
        for (int i = 0; i &lt; nstops; i++) {
            final Stop stop = grd.getStops().get(i);
            final Color stopColor = stop.getColor();
            float alpha255 = 255 * stopColor.getAlpha() * compositeAlpha;
            argb[i] = ((((int)(alpha255)) &amp; 0xFF) &lt;&lt; 24) +
                    ((((int)(alpha255 * stopColor.getRed())) &amp; 0xFF) &lt;&lt; 16) +
                    ((((int)(alpha255 * stopColor.getGreen())) &amp; 0xFF) &lt;&lt; 8) +
                    (((int)(alpha255 * stopColor.getBlue())) &amp; 0xFF);
        }
        return argb;
    }

    private static int[] getFractions(Gradient grd) {
        final int nstops = grd.getNumStops();
        final int fractions[] = new int[nstops];
        for (int i = 0; i &lt; nstops; i++) {
            final Stop stop = grd.getStops().get(i);
            fractions[i] = (int)(SWUtils.TO_PISCES * stop.getOffset());
        }
        return fractions;
    }

    private static int getPiscesGradientCycleMethod(final int prismCycleMethod) {
        switch (prismCycleMethod) {
            case Gradient.PAD:
                return GradientColorMap.CYCLE_NONE;
            case Gradient.REFLECT:
                return GradientColorMap.CYCLE_REFLECT;
            case Gradient.REPEAT:
                return GradientColorMap.CYCLE_REPEAT;
        }
        return GradientColorMap.CYCLE_NONE;
    }

    Transform6 computeDrawTexturePaintTransform(BaseTransform tx, float dx1, float dy1, float dx2, float dy2,
                                                float sx1, float sy1, float sx2, float sy2)
    {
        paintTx.setTransform(tx);

        final float scaleX = computeScale(dx1, dx2, sx1, sx2);
        final float scaleY = computeScale(dy1, dy2, sy1, sy2);

        if (scaleX == 1 &amp;&amp; scaleY == 1) {
            paintTx.deriveWithTranslation(-Math.min(sx1, sx2) + Math.min(dx1, dx2),
                    -Math.min(sy1, sy2) + Math.min(dy1, dy2));
        } else {
            paintTx.deriveWithTranslation(Math.min(dx1, dx2), Math.min(dy1, dy2));
            paintTx.deriveWithTranslation((scaleX &gt;= 0) ? 0 : Math.abs(dx2 - dx1),
                    (scaleY &gt;= 0) ? 0 : Math.abs(dy2 - dy1));
            paintTx.deriveWithConcatenation(scaleX, 0, 0, scaleY, 0, 0);
            paintTx.deriveWithTranslation(-Math.min(sx1, sx2), -Math.min(sy1, sy2));
        }

        SWUtils.convertToPiscesTransform(paintTx, piscesTx);
        return piscesTx;
    }

    private float computeScale(float dv1, float dv2, float sv1, float sv2) {
        final float dv_diff = dv2 - dv1;
        float scale = dv_diff / (sv2 - sv1);
        if (Math.abs(scale) &gt; (Integer.MAX_VALUE &gt;&gt; 16)) {
            scale = Math.signum(scale) * (Integer.MAX_VALUE &gt;&gt; 16);
        }
        return scale;
    }

    Transform6 computeSetTexturePaintTransform(Paint p, BaseTransform tx, RectBounds nodeBounds,
                                               float localX, float localY, float localWidth, float localHeight)
    {
        this.computePaintBounds(p, null, nodeBounds, localX, localY, localWidth, localHeight);

        final ImagePattern ip = (ImagePattern)p;
        this.computeImagePatternTransform(ip, tx, px, py, pw, ph);
        return piscesTx;
    }

    private void computeImagePatternTransform(ImagePattern ip, BaseTransform tx, float x, float y, float width, float height) {
        final Image image = ip.getImage();
        if (PrismSettings.debug) {
            System.out.println(&quot;PR.setTexturePaint: &quot; + image);
            System.out.println(&quot;imagePattern: x: &quot; + ip.getX() + &quot;, y: &quot; + ip.getY() +
                    &quot;, w: &quot; + ip.getWidth() + &quot;, h: &quot; + ip.getHeight() + &quot;, proportional: &quot; + ip.isProportional());
        }

        paintTx.setTransform(tx);
        if (ip.isProportional()) {
            paintTx.deriveWithConcatenation(width / image.getWidth() * ip.getWidth(), 0,
                    0, height / image.getHeight() * ip.getHeight(),
                    x + width * ip.getX(), y + height * ip.getY());
        } else {
            paintTx.deriveWithConcatenation(ip.getWidth() / image.getWidth(), 0,
                    0, ip.getHeight() / image.getHeight(),
                    x + ip.getX(), y + ip.getY());
        }
        SWUtils.convertToPiscesTransform(paintTx, piscesTx);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/animation/shared/InterpolationInterval.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.animation.shared;

import com.sun.javafx.animation.KeyValueHelper;
import javafx.animation.Interpolator;
import javafx.animation.KeyValue;
import javafx.beans.value.WritableBooleanValue;
import javafx.beans.value.WritableDoubleValue;
import javafx.beans.value.WritableFloatValue;
import javafx.beans.value.WritableIntegerValue;
import javafx.beans.value.WritableLongValue;
import javafx.beans.value.WritableValue;

import com.sun.scenario.animation.NumberTangentInterpolator;

public abstract class InterpolationInterval {

    protected final long ticks;
    protected final Interpolator rightInterpolator;

    protected InterpolationInterval(long ticks,
            Interpolator rightInterpolator) {
        this.ticks = ticks;
        this.rightInterpolator = rightInterpolator;
    }

    public abstract void interpolate(double frac);

    public abstract void recalculateStartValue();

    public static InterpolationInterval create(KeyValue rightKeyValue,
            long ticks, KeyValue leftKeyValue, long duration) {
        switch (KeyValueHelper.getType(rightKeyValue)) {
            case BOOLEAN:
                return new BooleanInterpolationInterval(rightKeyValue, ticks,
                        leftKeyValue.getEndValue());
            case DOUBLE:
                return ((leftKeyValue.getInterpolator() instanceof NumberTangentInterpolator) || (rightKeyValue
                        .getInterpolator() instanceof NumberTangentInterpolator)) ? new TangentDoubleInterpolationInterval(
                        rightKeyValue, ticks, leftKeyValue, duration)
                        : new DoubleInterpolationInterval(rightKeyValue,
                                ticks, leftKeyValue.getEndValue());
            case FLOAT:
                return ((leftKeyValue.getInterpolator() instanceof NumberTangentInterpolator) || (rightKeyValue
                        .getInterpolator() instanceof NumberTangentInterpolator)) ? new TangentFloatInterpolationInterval(
                        rightKeyValue, ticks, leftKeyValue, duration)
                        : new FloatInterpolationInterval(rightKeyValue, ticks,
                                leftKeyValue.getEndValue());
            case INTEGER:
                return ((leftKeyValue.getInterpolator() instanceof NumberTangentInterpolator) || (rightKeyValue
                        .getInterpolator() instanceof NumberTangentInterpolator)) ? new TangentIntegerInterpolationInterval(
                        rightKeyValue, ticks, leftKeyValue, duration)
                        : new IntegerInterpolationInterval(rightKeyValue,
                                ticks, leftKeyValue.getEndValue());
            case LONG:
                return ((leftKeyValue.getInterpolator() instanceof NumberTangentInterpolator) || (rightKeyValue
                        .getInterpolator() instanceof NumberTangentInterpolator)) ? new TangentLongInterpolationInterval(
                        rightKeyValue, ticks, leftKeyValue, duration)
                        : new LongInterpolationInterval(rightKeyValue, ticks,
                                leftKeyValue.getEndValue());
            case OBJECT:
                return new ObjectInterpolationInterval(rightKeyValue, ticks,
                        leftKeyValue.getEndValue());
        }
        throw new RuntimeException(&quot;Should not reach here&quot;);
    }

    public static InterpolationInterval create(KeyValue rightKeyValue,
            long ticks) {
        switch (KeyValueHelper.getType(rightKeyValue)) {
            case BOOLEAN:
                return new BooleanInterpolationInterval(rightKeyValue, ticks);
            case DOUBLE:
                return (rightKeyValue.getInterpolator() instanceof NumberTangentInterpolator) ? new TangentDoubleInterpolationInterval(
                        rightKeyValue, ticks)
                        : new DoubleInterpolationInterval(rightKeyValue, ticks);
            case FLOAT:
                return (rightKeyValue.getInterpolator() instanceof NumberTangentInterpolator) ? new TangentFloatInterpolationInterval(
                        rightKeyValue, ticks)
                        : new FloatInterpolationInterval(rightKeyValue, ticks);
            case INTEGER:
                return (rightKeyValue.getInterpolator() instanceof NumberTangentInterpolator) ? new TangentIntegerInterpolationInterval(
                        rightKeyValue, ticks)
                        : new IntegerInterpolationInterval(rightKeyValue,
                                ticks);
            case LONG:
                return (rightKeyValue.getInterpolator() instanceof NumberTangentInterpolator) ? new TangentLongInterpolationInterval(
                        rightKeyValue, ticks) : new LongInterpolationInterval(
                        rightKeyValue, ticks);
            case OBJECT:
                return new ObjectInterpolationInterval(rightKeyValue, ticks);
        }
        throw new RuntimeException(&quot;Should not reach here&quot;);
    }

    private static abstract class TangentInterpolationInterval extends
            InterpolationInterval {

        private final double duration;
        private final double p2;
        protected final double p3;
        private final NumberTangentInterpolator leftInterpolator;

        protected double p0;
        private double p1;

        private TangentInterpolationInterval(KeyValue rightKeyValue,
                long ticks, KeyValue leftKeyValue, long duration) {
            super(ticks, rightKeyValue.getInterpolator());
            assert (rightKeyValue.getEndValue() instanceof Number)
                    &amp;&amp; (leftKeyValue.getEndValue() instanceof Number);

            this.duration = duration;
            final Interpolator rawLeftInterpolator = leftKeyValue
                    .getInterpolator();
            leftInterpolator = (rawLeftInterpolator instanceof NumberTangentInterpolator) ? (NumberTangentInterpolator) rawLeftInterpolator
                    : null;
            recalculateStartValue(((Number) leftKeyValue.getEndValue())
                    .doubleValue());

            final NumberTangentInterpolator interpolator = (rightInterpolator instanceof NumberTangentInterpolator) ? (NumberTangentInterpolator) rightInterpolator
                    : null;
            p3 = ((Number) rightKeyValue.getEndValue()).doubleValue();
            final double p2Delta = (interpolator == null) ? 0 : (interpolator
                    .getInValue() - p3)
                    * duration
                    / interpolator.getInTicks()
                    / 3;
            p2 = p3 + p2Delta;
        }

        private TangentInterpolationInterval(KeyValue rightKeyValue,
                long ticks) {
            super(ticks, rightKeyValue.getInterpolator());
            assert rightKeyValue.getEndValue() instanceof Number;

            this.duration = ticks;
            leftInterpolator = null;

            final NumberTangentInterpolator interpolator = (rightInterpolator instanceof NumberTangentInterpolator) ? (NumberTangentInterpolator) rightInterpolator
                    : null;
            p3 = ((Number) rightKeyValue.getEndValue()).doubleValue();
            final double p2Delta = (interpolator == null) ? 0 : (interpolator
                    .getInValue() - p3)
                    * duration
<A NAME="30"></A>                    / interpolator.getInTicks()
                    / 3;
            p2 = p3 + p2Delta;
        <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#30',2,'match34-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        protected double calculate(double t) {
            final double oneMinusT = 1.0 - t;
            final double tSquared = t * t;
            final double oneMinusTSquared = oneMinusT * oneMinusT;

            return</B></FONT> oneMinusTSquared * oneMinusT * p0 + 3 * oneMinusTSquared * t
                    * p1 + 3 * oneMinusT * tSquared * p2 + tSquared * t * p3;
        }

        protected final void recalculateStartValue(double leftValue) {
            p0 = leftValue;
            final double p1Delta = (leftInterpolator == null) ? 0
                    : (leftInterpolator.getOutValue() - p0) * duration
                            / leftInterpolator.getOutTicks() / 3;
            p1 = p0 + p1Delta;
        }
    }

    private static class BooleanInterpolationInterval extends
            InterpolationInterval {

        private final WritableBooleanValue target;
        private boolean leftValue;
        private final boolean rightValue;

        private BooleanInterpolationInterval(KeyValue keyValue, long ticks,
                Object leftValue) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableBooleanValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Boolean)
                    &amp;&amp; (leftValue instanceof Boolean);
            this.target = (WritableBooleanValue) keyValue.getTarget();
            this.rightValue = (Boolean) keyValue.getEndValue();
            this.leftValue = (Boolean) leftValue;
        }

        private BooleanInterpolationInterval(KeyValue keyValue, long ticks) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableBooleanValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Boolean);
            this.target = (WritableBooleanValue) keyValue.getTarget();
            this.rightValue = (Boolean) keyValue.getEndValue();
            this.leftValue = target.get();
        }

        @Override
        public void interpolate(double frac) {
            final boolean value = rightInterpolator.interpolate(leftValue,
                    rightValue, frac);
            target.set(value);
        }

        @Override
        public void recalculateStartValue() {
            leftValue = target.get();
        }
    }

    private static class DoubleInterpolationInterval extends
            InterpolationInterval {

        private final WritableDoubleValue target;
        private double leftValue;
        private final double rightValue;

        private DoubleInterpolationInterval(KeyValue keyValue, long ticks,
                Object leftValue) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableDoubleValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number)
                    &amp;&amp; (leftValue instanceof Number);
            this.target = (WritableDoubleValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).doubleValue();
            this.leftValue = ((Number) leftValue).doubleValue();
        }

        private DoubleInterpolationInterval(KeyValue keyValue, long ticks) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableDoubleValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number);
            this.target = (WritableDoubleValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).doubleValue();
            this.leftValue = target.get();
        }

        @Override
        public void interpolate(double frac) {
            final double value = rightInterpolator.interpolate(leftValue,
                    rightValue, frac);
            target.set(value);
        }

        @Override
        public void recalculateStartValue() {
            leftValue = target.get();
        }
    }

    private static class TangentDoubleInterpolationInterval extends
            TangentInterpolationInterval {

        private final WritableDoubleValue target;

        private TangentDoubleInterpolationInterval(KeyValue rightKeyValue,
                long ticks, KeyValue leftKeyValue, long duration) {
            super(rightKeyValue, ticks, leftKeyValue, duration);
            assert rightKeyValue.getTarget() instanceof WritableDoubleValue;
            this.target = (WritableDoubleValue) rightKeyValue.getTarget();
        }

        private TangentDoubleInterpolationInterval(KeyValue rightKeyValue,
                long ticks) {
            super(rightKeyValue, ticks);
            assert rightKeyValue.getTarget() instanceof WritableDoubleValue;
            this.target = (WritableDoubleValue) rightKeyValue.getTarget();
            recalculateStartValue(target.get());
        }

        @Override
        public void interpolate(double frac) {
            target.set(calculate(frac));
        }

        @Override
        public void recalculateStartValue() {
            recalculateStartValue(target.get());
        }
    }

    private static class FloatInterpolationInterval extends
            InterpolationInterval {

        private final WritableFloatValue target;
        private float leftValue;
        private final float rightValue;

        private FloatInterpolationInterval(KeyValue keyValue, long ticks,
                Object leftValue) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableFloatValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number)
                    &amp;&amp; (leftValue instanceof Number);
            this.target = (WritableFloatValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).floatValue();
            this.leftValue = ((Number) leftValue).floatValue();
        }

        private FloatInterpolationInterval(KeyValue keyValue, long ticks) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableFloatValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number);
            this.target = (WritableFloatValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).floatValue();
            this.leftValue = target.get();
        }

        @Override
        public void interpolate(double frac) {
            final float value = (float) rightInterpolator.interpolate(
                    leftValue, rightValue, frac);
            target.set(value);
        }

        @Override
        public void recalculateStartValue() {
            leftValue = target.get();
        }
    }

    private static class TangentFloatInterpolationInterval extends
            TangentInterpolationInterval {

        private final WritableFloatValue target;

        private TangentFloatInterpolationInterval(KeyValue rightKeyValue,
                long ticks, KeyValue leftKeyValue, long duration) {
            super(rightKeyValue, ticks, leftKeyValue, duration);
            assert rightKeyValue.getTarget() instanceof WritableFloatValue;
            this.target = (WritableFloatValue) rightKeyValue.getTarget();
        }

        private TangentFloatInterpolationInterval(KeyValue rightKeyValue,
                long ticks) {
            super(rightKeyValue, ticks);
            assert rightKeyValue.getTarget() instanceof WritableFloatValue;
            this.target = (WritableFloatValue) rightKeyValue.getTarget();
            recalculateStartValue(target.get());
        }

        @Override
        public void interpolate(double frac) {
            target.set((float) calculate(frac));
        }

        @Override
        public void recalculateStartValue() {
            recalculateStartValue(target.get());
        }
    }

    private static class IntegerInterpolationInterval extends
            InterpolationInterval {

        private final WritableIntegerValue target;
        private int leftValue;
        private final int rightValue;

        private IntegerInterpolationInterval(KeyValue keyValue, long ticks,
                Object leftValue) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableIntegerValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number)
                    &amp;&amp; (leftValue instanceof Number);
            this.target = (WritableIntegerValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).intValue();
            this.leftValue = ((Number) leftValue).intValue();
        }

        private IntegerInterpolationInterval(KeyValue keyValue, long ticks) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableIntegerValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number);
            this.target = (WritableIntegerValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).intValue();
            this.leftValue = target.get();
        }

        @Override
        public void interpolate(double frac) {
            final int value = rightInterpolator.interpolate(leftValue,
                    rightValue, frac);
            target.set(value);
        }

        @Override
        public void recalculateStartValue() {
            leftValue = target.get();
        }
    }

    private static class TangentIntegerInterpolationInterval extends
            TangentInterpolationInterval {

        private final WritableIntegerValue target;

        private TangentIntegerInterpolationInterval(KeyValue rightKeyValue,
                long ticks, KeyValue leftKeyValue, long duration) {
            super(rightKeyValue, ticks, leftKeyValue, duration);
            assert rightKeyValue.getTarget() instanceof WritableIntegerValue;
            this.target = (WritableIntegerValue) rightKeyValue.getTarget();
        }

        private TangentIntegerInterpolationInterval(KeyValue rightKeyValue,
                long ticks) {
            super(rightKeyValue, ticks);
            assert rightKeyValue.getTarget() instanceof WritableIntegerValue;
            this.target = (WritableIntegerValue) rightKeyValue.getTarget();
            recalculateStartValue(target.get());
        }

        @Override
        public void interpolate(double frac) {
            target.set((int) Math.round(calculate(frac)));
        }

        @Override
        public void recalculateStartValue() {
            recalculateStartValue(target.get());
        }
    }

    private static class LongInterpolationInterval extends
            InterpolationInterval {

        private final WritableLongValue target;
        private long leftValue;
        private final long rightValue;

        private LongInterpolationInterval(KeyValue keyValue, long ticks,
                Object leftValue) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableLongValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number)
                    &amp;&amp; (leftValue instanceof Number);
            this.target = (WritableLongValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).longValue();
            this.leftValue = ((Number) leftValue).longValue();
        }

        private LongInterpolationInterval(KeyValue keyValue, long ticks) {
            super(ticks, keyValue.getInterpolator());
            assert (keyValue.getTarget() instanceof WritableLongValue)
                    &amp;&amp; (keyValue.getEndValue() instanceof Number);
            this.target = (WritableLongValue) keyValue.getTarget();
            this.rightValue = ((Number) keyValue.getEndValue()).longValue();
            this.leftValue = target.get();
        }

        @Override
        public void interpolate(double frac) {
            final long value = rightInterpolator.interpolate(leftValue,
                    rightValue, frac);
            target.set(value);
        }

        @Override
        public void recalculateStartValue() {
            leftValue = target.get();
        }
    }

    private static class TangentLongInterpolationInterval extends
            TangentInterpolationInterval {

        private final WritableLongValue target;

        private TangentLongInterpolationInterval(KeyValue rightKeyValue,
                long ticks, KeyValue leftKeyValue, long duration) {
            super(rightKeyValue, ticks, leftKeyValue, duration);
            assert rightKeyValue.getTarget() instanceof WritableLongValue;
            this.target = (WritableLongValue) rightKeyValue.getTarget();
        }

        private TangentLongInterpolationInterval(KeyValue rightKeyValue,
                long ticks) {
            super(rightKeyValue, ticks);
            assert rightKeyValue.getTarget() instanceof WritableLongValue;
            this.target = (WritableLongValue) rightKeyValue.getTarget();
            recalculateStartValue(target.get());
        }

        @Override
        public void interpolate(double frac) {
            target.set(Math.round(calculate(frac)));
        }

        @Override
        public void recalculateStartValue() {
            recalculateStartValue(target.get());
        }
    }

    private static class ObjectInterpolationInterval extends
            InterpolationInterval {

        @SuppressWarnings(&quot;rawtypes&quot;)
        private final WritableValue target;
        private Object leftValue;
        private final Object rightValue;

        private ObjectInterpolationInterval(KeyValue keyValue, long ticks,
                Object leftValue) {
            super(ticks, keyValue.getInterpolator());
            this.target = keyValue.getTarget();
            this.rightValue = keyValue.getEndValue();
            this.leftValue = leftValue;
        }

        private ObjectInterpolationInterval(KeyValue keyValue, long ticks) {
            super(ticks, keyValue.getInterpolator());
            this.target = keyValue.getTarget();
            this.rightValue = keyValue.getEndValue();
            this.leftValue = target.getValue();
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void interpolate(double frac) {
            final Object value = rightInterpolator.interpolate(leftValue,
                    rightValue, frac);
            target.setValue(value);
        }

        @Override
        public void recalculateStartValue() {
            leftValue = target.getValue();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/EffectPeer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl;

import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.Effect.AccelType;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.scenario.effect.impl.state.RenderState;

/**
 * The abstract base class for all {@code Effect} implementation peers.
 *
 * @param &lt;T&gt; an optional subclass of RenderState that can be assumed as the
 *            return value for the getRenderState() method
 */
public abstract class EffectPeer&lt;T extends RenderState&gt; {

    private final FilterContext fctx;
    private final Renderer renderer;
    private final String uniqueName;
    private Effect effect;
    private T renderState;
    private int pass;

    protected EffectPeer(FilterContext fctx, Renderer renderer, String uniqueName) {
        if (fctx == null) {
            throw new IllegalArgumentException(&quot;FilterContext must be non-null&quot;);
        }
        this.fctx = fctx;
        this.renderer = renderer;
        this.uniqueName = uniqueName;
    }

    public boolean isImageDataCompatible(ImageData id) {
        return getRenderer().isImageDataCompatible(id);
    }

    public abstract ImageData filter(Effect effect,
                                     T renderState,
                                     BaseTransform transform,
                                     Rectangle outputClip,
                                     ImageData... inputs);

    /**
     * Disposes resources associated with this peer.
     * Warning: may be called from the rendering thread.
     */
    public void dispose() {
    }
<A NAME="4"></A>
    public AccelType getAccelType() {
        return renderer.getAccelType();
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#4',2,'match34-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    protected final FilterContext getFilterContext() {
        return fctx;
    }

    protected Renderer getRenderer() {
        return renderer;
    }

    /**
     * Returns the unique name of this peer.  This value can be used as
     * the key value in a hashmap of cached peer instances.  In the case
     * of hardware peers, this value is typically the name of the shader that
     * is used by the peer.
     *
     * @return the unique name of this peer
     */
    public String getUniqueName() {
        return uniqueName;
    }

    protected Effect getEffect() {
        return effect;
    }

    protected void setEffect(Effect effect) {
        this.effect = effect;
    }

    protected T getRenderState() {
        return renderState;
    }

    protected void setRenderState(T renderState) {
        this.renderState = renderState;
    }

    public final int getPass() {
        return pass;
    }</B></FONT>

    public void setPass(int pass) {
        this.pass = pass;
    }

    // NOTE: this input(Native)Bounds stuff is unpleasant, but we somehow
    // need to provide access to the native surface bounds for various glue
    // methods (e.g. getKvals())

    private final Rectangle[] inputBounds = new Rectangle[2];
    /**
     * Returns the &quot;valid&quot; bounds of the source image for the given input.
     * Since Effect implementations try to recycle temporary Images, it is
     * quite possible that the input bounds returned by this method will
     * differ from the size of the associated input Image.  For example,
     * this method may return (0, 0, 210, 180) even though the associated
     * Image has dimensions of 230x200 pixels.  Pixels in the input Image
     * outside these &quot;valid&quot; bounds are undefined and should be avoided.
     *
     * @param inputIndex the index of the source input
     * @return the valid bounds of the source Image
     */
    protected final Rectangle getInputBounds(int inputIndex) {
        return inputBounds[inputIndex];
    }
    protected final void setInputBounds(int inputIndex, Rectangle r) {
        inputBounds[inputIndex] = r;
    }

    private final BaseTransform[] inputTransforms = new BaseTransform[2];
    protected final BaseTransform getInputTransform(int inputIndex) {
        return inputTransforms[inputIndex];
    }
    protected final void setInputTransform(int inputIndex, BaseTransform tx) {
        inputTransforms[inputIndex] = tx;
    }

    private final Rectangle[] inputNativeBounds = new Rectangle[2];
    /**
     * Returns the bounds of the native surface for the given input.
     * It is quite possible that the input native bounds returned by this
     * method will differ from the size of the associated input (Java-level)
     * Image.  This is common for the OGL and D3D backends of Java 2D,
     * where on older hardware the dimensions of a VRAM surface (e.g. texture)
     * must be a power of two.  For example, this method may return
     * (0, 0, 256, 256) even though the associated (Volatile)Image has
     * dimensions of 230x200 pixels.
     * &lt;p&gt;
     * This method is useful in cases where it is necessary to access
     * adjacent pixels in a native surface.  For example, the horizontal
     * distance between two texel centers of a native surface can be
     * calculated as (1f/inputNativeBounds.width); for the vertical distance,
     * (1f/inputNativeBounds.height).
     *
     * @param inputIndex the index of the source input
     * @return the native surface bounds
     */
    protected final Rectangle getInputNativeBounds(int inputIndex) {
        return inputNativeBounds[inputIndex];
    }
    protected final void setInputNativeBounds(int inputIndex, Rectangle r) {
        inputNativeBounds[inputIndex] = r;
    }

    public Rectangle getResultBounds(BaseTransform transform,
                                     Rectangle outputClip,
                                     ImageData... inputDatas)
    {
        return getEffect().getResultBounds(transform, outputClip, inputDatas);
    }

    /**
     * Returns an array of four floats that represent the mapping of the
     * data for the specified input to the given effect area.
     * The interpretation of the returned values is entirely dependent on
     * the algorithm of the pixel shader, but typical values are in the
     * &quot;unit&quot; coordinate space of the destination effect area, where
     * {@code (0,0)} is at the upper-left corner, and {@code (1,1)} is at
     * the lower-right corner.
     * The returned array contains the values in order (x1, y1, x2, y2).
     * &lt;p&gt;
     * The default implementation converts the logical destination effect
     * region into the coordinate space of the native surface of the
     * specified source input according to the
     * {@link getSourceRegion(Rectangle, Rectangle, Rectangle)} method.
     * &lt;p&gt;
     * Subclasses can override this method to provide more sophisticated
     * positioning behavior.
     *
     * @param inputIndex the index of the source input
     * @return an array of four float values
     */
    protected float[] getSourceRegion(int inputIndex)
    {
        return getSourceRegion(getInputBounds(inputIndex),
                               getInputNativeBounds(inputIndex),
                               getDestBounds());
    }

    /**
     * Returns an array of four floats that represent the mapping of the
     * specified source region for the specified effect area.
     * The returned values are in the &quot;unit&quot; coordinate space of the source
     * native surface, where (0,0) is at the upper-left corner, and (1,1)
     * is at the lower-right corner.
     * For example, if the native input surface (i.e. texture) is 256x256
     * pixels, and the effect output region is at the same coordinates as
     * the input region and is 200x200, this method will
     * return (0, 0, 200/256, 220/256).
     * The returned array contains the values in order (x1, y1, x2, y2).
     * &lt;p&gt;
     * Subclasses can override this method to provide more sophisticated
     * positioning behavior.
     *
     * @param srcBounds the logical bounds of the input data
     * @param srcNativeBounds the actual dimensions of the input image
     *                        containing the input data in its upper left
     * @param dstBounds the logical bounds of the resulting effect output
     * @return an array of four float values
     */
    static float[] getSourceRegion(Rectangle srcBounds,
                                   Rectangle srcNativeBounds,
                                   Rectangle dstBounds)
    {
        float x1 = dstBounds.x - srcBounds.x;
        float y1 = dstBounds.y - srcBounds.y;
        float x2 = x1 + dstBounds.width;
        float y2 = y1 + dstBounds.height;
        float sw = srcNativeBounds.width;
        float sh = srcNativeBounds.height;
        return new float[] {x1 / sw, y1 / sh, x2 / sw, y2 / sh};
    }

    /**
     * Returns either 4 or 8 source texture coordinates depending on the
     * transform being applied to the source.
     * &lt;p&gt;
     * If the mapping is rectilinear then 4 floats are returned.  The
     * texture coordinates are thus mapped using the following table:
     * &lt;pre&gt;
     *     dx1,dy1 =&gt; ret[0], ret[1]
     *     dx2,dy1 =&gt; ret[2], ret[1]
     *     dx1,dy2 =&gt; ret[0], ret[3]
     *     dx2,dy2 =&gt; ret[2], ret[3]
     * &lt;/pre&gt;
     * If the mapping is non-rectilinear then 8 floats are returned and
     * the texture coordinates are mapped using the following table (note
     * that the dx1,dy1 and dx2,dy2 mappings are still from the same
     * indices as in the 4 float return value):
     * &lt;pre&gt;
     *     dx1,dy1 =&gt; ret[0], ret[1]
     *     dx2,dy1 =&gt; ret[4], ret[5]
     *     dx1,dy2 =&gt; ret[6], ret[7]
     *     dx2,dy2 =&gt; ret[2], ret[3]
     * &lt;/pre&gt;
     * The default implementation of this method simply calls the static
     * method {@link getTextureCoordinates(float[],float,float,float,float,Rectangle,BaseTransform)}.
     *
     * @param inputIndex the index of the input whose texture coordinates
     *                   are being queried
     * @param coords An array that can hold up to 8 floats for returning
     *               the texture coordinates.
     * @param srcX The X coordinate of the origin of the source texture
     *             in the untransformed coordinate space.
     * @param srcY The Y coordinate of the origin of the source texture
     *             in the untransformed coordinate space.
     * @param srcNativeWidth the native width of the source texture
     * @param srcNativeHeight the native height of the source texture
     * @param dstBounds the output bounds that the texture is
     *                  being stretched over
     * @param transform the transform to be implicitly applied to the
     *                  source texture as it is mapped onto the destination
     * @return the number of texture coordinates stored in the {@code coords}
     *         array (either 4 or 8)
     */
    public int getTextureCoordinates(int inputIndex, float coords[],
                                     float srcX, float srcY,
                                     float srcNativeWidth,
                                     float srcNativeHeight,
                                     Rectangle dstBounds,
                                     BaseTransform transform)
    {
        return getTextureCoordinates(coords,
                                     srcX, srcY,
                                     srcNativeWidth, srcNativeHeight,
                                     dstBounds, transform);
    }

    /**
     * Returns either 4 or 8 source texture coordinates depending on the
     * transform being applied to the source.
     * &lt;p&gt;
     * If the mapping is rectilinear then 4 floats are returned.  The
     * texture coordinates are thus mapped using the following table:
     * &lt;pre&gt;
     *     dx1,dy1 =&gt; ret[0], ret[1]
     *     dx2,dy1 =&gt; ret[2], ret[1]
     *     dx1,dy2 =&gt; ret[0], ret[3]
     *     dx2,dy2 =&gt; ret[2], ret[3]
     * &lt;/pre&gt;
     * If the mapping is non-rectilinear then 8 floats are returned and
     * the texture coordinates are mapped using the following table (note
     * that the dx1,dy1 and dx2,dy2 mappings are still from the same
     * indices as in the 4 float return value):
     * &lt;pre&gt;
     *     dx1,dy1 =&gt; ret[0], ret[1]
     *     dx2,dy1 =&gt; ret[4], ret[5]
     *     dx1,dy2 =&gt; ret[6], ret[7]
     *     dx2,dy2 =&gt; ret[2], ret[3]
     * &lt;/pre&gt;
     *
     * @param coords An array that can hold up to 8 floats for returning
     *               the texture coordinates.
     * @param srcX The X coordinate of the origin of the source texture
     *             in the untransformed coordinate space.
     * @param srcY The Y coordinate of the origin of the source texture
     *             in the untransformed coordinate space.
     * @param srcNativeWidth the native width of the source texture
     * @param srcNativeHeight the native height of the source texture
     * @param dstBounds the output bounds that the texture is
     *                  being stretched over
     * @param transform the transform to be implicitly applied to the
     *                  source texture as it is mapped onto the destination
     * @return the number of texture coordinates stored in the {@code coords}
     *         array (either 4 or 8)
     */
    public static int getTextureCoordinates(float coords[],
                                            float srcX, float srcY,
                                            float srcNativeWidth,
                                            float srcNativeHeight,
                                            Rectangle dstBounds,
                                            BaseTransform transform)
    {
        coords[0] = dstBounds.x;
        coords[1] = dstBounds.y;
        coords[2] = coords[0] + dstBounds.width;
        coords[3] = coords[1] + dstBounds.height;
        int numCoords;
        if (transform.isTranslateOrIdentity()) {
            srcX += (float) transform.getMxt();
            srcY += (float) transform.getMyt();
            numCoords = 4;
        } else {
            coords[4] = coords[2];
            coords[5] = coords[1];
            coords[6] = coords[0];
            coords[7] = coords[3];
            numCoords = 8;
            try {
                transform.inverseTransform(coords, 0, coords, 0, 4);
            } catch (NoninvertibleTransformException e) {
                coords[0] = coords[1] = coords[2] = coords[4] = 0f;
                return 4;
            }
        }
        for (int i = 0; i &lt; numCoords; i += 2) {
            coords[i  ] = (coords[i  ] - srcX) / srcNativeWidth;
            coords[i+1] = (coords[i+1] - srcY) / srcNativeHeight;
        }
        return numCoords;
    }

    private Rectangle destBounds;
    protected final void setDestBounds(Rectangle r) {
        destBounds = r;
    }
    protected final Rectangle getDestBounds() {
        return destBounds;
    }

    private final Rectangle destNativeBounds = new Rectangle();
    protected final Rectangle getDestNativeBounds() {
        return destNativeBounds;
    }
    protected final void setDestNativeBounds(int w, int h) {
        destNativeBounds.width = w;
        destNativeBounds.height = h;
    }

    protected Object getSamplerData(int i) {
        return null;
    }

    /**
     * Returns true if the native coordinate system has its origin at
     * the upper-left corner of the destination surface; otherwise, returns
     * false, indicating that the origin is at the lower-left corner.
     * &lt;p&gt;
     * This method may be useful in determining the direction of adjacent
     * pixels in an OpenGL surface (since many OpenGL methods take parameters
     * assuming a lower-left origin).
     *
     * @return true if the coordinate system has an upper-left origin
     */
    protected boolean isOriginUpperLeft() {
        return (getAccelType() != Effect.AccelType.OPENGL);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/RendererFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl;

import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.PlatformUtil;
import com.sun.scenario.effect.FilterContext;

/**
 * A factory that produces a {@code Renderer} instance appropriate for
 * the desktop and tv stacks (either Swing or Prism based).  This class
 * dynamically locates a {@code Renderer} using the java.lang.reflect package,
 * which is not available on CLDC.  The CLDC-based mobile stack may
 * substitute their own version of this class that does not rely on reflection.
 */
class RendererFactory {

    private static String rootPkg = Renderer.rootPkg;
    private static boolean tryRSL = true;
    private static boolean trySIMD = false;
    // by default we only enable jogl hw acceleration on MacOS
    private static boolean tryJOGL = PlatformUtil.isMac();
    private static boolean tryPrism = true;

    static {
        try {
            if (&quot;false&quot;.equals(System.getProperty(&quot;decora.rsl&quot;))) {
                tryRSL = false;
            }
            if (&quot;false&quot;.equals(System.getProperty(&quot;decora.simd&quot;))) {
                trySIMD = false;
            }
            String tryJOGLProp = System.getProperty(&quot;decora.jogl&quot;);
            if (tryJOGLProp != null) {
                tryJOGL = Boolean.parseBoolean(tryJOGLProp);
            }
            if (&quot;false&quot;.equals(System.getProperty(&quot;decora.prism&quot;))) {
                tryPrism = false;
            }
        } catch (SecurityException ignore) {
        }
    }

    private static boolean isRSLFriendly(Class klass) {
        // can't use reflection here to check for sun.* class when running
        // in sandbox; however, we are allowed to walk up the tree and
        // check names of interfaces loaded by the system
        if (klass.getName().equals(&quot;sun.java2d.pipe.hw.AccelGraphicsConfig&quot;)) {
            return true;
        }
        boolean rsl = false;
        for (Class iface : klass.getInterfaces()) {
            if (isRSLFriendly(iface)) {
                rsl = true;
                break;
            }
        }
        return rsl;
    }

    private static boolean isRSLAvailable(FilterContext fctx) {
        return isRSLFriendly(fctx.getReferent().getClass());
    }

    private static Renderer createRSLRenderer(FilterContext fctx) {
        try {
            Class klass = Class.forName(rootPkg + &quot;.impl.j2d.rsl.RSLRenderer&quot;);
            Method m = klass.getMethod(&quot;createRenderer&quot;,
                                       new Class[] { FilterContext.class });
            return (Renderer)m.invoke(null, new Object[] { fctx });
        } catch (Throwable e) {}

        return null;
    }

    private static Renderer createJOGLRenderer(FilterContext fctx) {
        if (tryJOGL) {
            try {
                Class klass = Class.forName(rootPkg + &quot;.impl.j2d.jogl.JOGLRenderer&quot;);
                Method m = klass.getMethod(&quot;createRenderer&quot;,
                                           new Class[] { FilterContext.class });
                return (Renderer)m.invoke(null, new Object[] { fctx });
            } catch (Throwable e) {}
            // don't disable jogl if failed, it may be available for other config
        }
        return null;
    }

    private static Renderer createPrismRenderer(FilterContext fctx) {
        if (tryPrism) {
            try {
                Class klass = Class.forName(rootPkg + &quot;.impl.prism.PrRenderer&quot;);
                Method m = klass.getMethod(&quot;createRenderer&quot;,
                                           new Class[] { FilterContext.class });
                return (Renderer)m.invoke(null, new Object[] { fctx });
            } catch (Throwable e) {
                e.printStackTrace();
            }
            // don't disable prism if failed, it may be available for other config
        }
        return null;
    }

    private static Renderer getSSERenderer() {
        if (trySIMD) {
            try {
                Class klass = Class.forName(rootPkg + &quot;.impl.j2d.J2DSWRenderer&quot;);
                Method m = klass.getMethod(&quot;getSSEInstance&quot;, (Class[])null);
                Renderer sseRenderer = (Renderer)m.invoke(null, (Object[])null);
                if (sseRenderer != null) {
                    return sseRenderer;
                }
            } catch (Throwable e) {e.printStackTrace();}
            // don't bother trying to find SSE renderer again
            trySIMD = false;
        }
        return null;
    }

    private static Renderer getJavaRenderer() {
        try {
            Class klass = Class.forName(rootPkg + &quot;.impl.prism.sw.PSWRenderer&quot;);
            Class screenClass = Class.forName(&quot;com.sun.glass.ui.Screen&quot;);
            Method m = klass.getMethod(&quot;createJSWInstance&quot;,
                                       new Class[] { screenClass });
            Renderer jswRenderer =
                (Renderer)m.invoke(null, new Object[] { null } );
<A NAME="19"></A>            if (jswRenderer != null) {
                return jswRenderer;
            }
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#19',2,'match34-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} catch (Throwable e) {e.printStackTrace();}
        return null;
    }

    private static Renderer getJavaRenderer(FilterContext fctx) {
        try {</B></FONT>
            Class klass = Class.forName(rootPkg + &quot;.impl.prism.sw.PSWRenderer&quot;);
            Method m = klass.getMethod(&quot;createJSWInstance&quot;,
                                       new Class[] { FilterContext.class });
            Renderer jswRenderer =
               (Renderer)m.invoke(null, new Object[] { fctx } );
            if (jswRenderer != null) {
                return jswRenderer;
            }
        } catch (Throwable e) {}
        return null;
    }

    static Renderer getSoftwareRenderer() {
        Renderer r = getSSERenderer();
        if (r == null) {
            r = getJavaRenderer();
        }
        return r;
    }

    static Renderer createRenderer(final FilterContext fctx) {
        return AccessController.doPrivileged((PrivilegedAction&lt;Renderer&gt;) () -&gt; {
            Renderer r = null;
            // Class.getSimpleName is not available on CDC
            String klassName = fctx.getClass().getName();
            String simpleName = klassName.substring(klassName.lastIndexOf(&quot;.&quot;) + 1);

            if (simpleName.equals(&quot;PrFilterContext&quot;) &amp;&amp; tryPrism) {
                r = createPrismRenderer(fctx);
            }
            // check to see whether one of the hardware accelerated
            // Java 2D pipelines is in use and exposes the necessary
            // &quot;resource sharing layer&quot; APIs (only in Sun's JDK 6u10 and above)
            if (r == null &amp;&amp; tryRSL &amp;&amp; isRSLAvailable(fctx)) {
                // try locating an RSLRenderer (need to use reflection in case
                // certain RSL backend classes are not available;
                // this step will trigger lazy downloading of impl jars
                // via JNLP, if not already available)
                r = createRSLRenderer(fctx);
            }
            if (r == null &amp;&amp; tryJOGL) {
                // next try the JOGL renderer
                r = createJOGLRenderer(fctx);
            }
            if (r == null &amp;&amp; trySIMD) {
                // next try the SSE renderer
                r = getSSERenderer();
            }
            if (r == null) {
                // otherwise, fall back on the Java/CPU renderer
                r = getJavaRenderer(fctx);
            }
            return r;
        });
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/print/JobSettings.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.print;

import java.util.Set;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.Property;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ObservableValue;

/**
 * The JobSettings class encapsulates most of the configuration of a
 * print job. Applications do not - and cannot - directly create or
 * set a JobSettings instance. One is already installed on the print job
 * when it is created.
 * &lt;p&gt;
 * As documented on PrinterJob, the JobSettings installed on that job will
 * initially reflect the current default settings for the initially
 * associated printer for that job.
 * &lt;p&gt;
 * The JobSettings delegate then remains the same for the life of the job,
 * and will have it's member properties updated to be compatible with
 * a change in Printer on the job. For example as a
 * result of a user interaction via a platform's dialog.
 * An incompatible setting will usually cause the setting to revert to
 * the default for the new printer.
 * &lt;p&gt;
 * Any implicit or explicit updates to settings resulting from
 * the user interaction with dialog will be propagated and visible to
 * the application once the user approves the settings by
 * dismissing the dialog using its &quot;accept&quot; option.
 * &lt;p&gt;
 * For most printing applications it is likely sufficient to let the user
 * set the desired options and have these propagated to the job.
 * For applications which need them,
 * there are setter and getter methods for the individual options,
 * which are also available as properties, and change in values of
 * settings may be monitored and updated via these properties.
 * &lt;p&gt;
 * Not all values of settings are available on all printers. For example
 * a printer may not support two-sided printing.
 * See the {@link javafx.print.Printer Printer} class for how to
 * to determine supported settings.
 *
 * @since JavaFX 8.0
 */
public final class JobSettings {

    private PrinterJob job;
    private Printer printer;
    private PrinterAttributes printerCaps;

    /*
     * There's no need for client code to create a JobSettings
     * as there is already one set on a PrinterJob and it must
     * be updated, not replaced. So we do not expose the constructor.
     *
     */
    JobSettings(Printer printer) {
        this.printer = printer;
        printerCaps = printer.getPrinterAttributes();
    }

    void setPrinterJob(PrinterJob job) {
        this.job = job;
    }

    private boolean isJobNew() {
        // If we haven't yet set the job its equivalent to a new job.
        return job == null || job.isJobNew();
    }


    /*
     * We need to be able to distinguish settings which are
     * the printer defaults, versus explicitly set ones. so
     * the settings object remembers for each setting if it
     * was an explicit setting or a default.
     * Settings such as JobName which are supportable across printers
     * don't need this treatment.
     */

    private boolean defaultCopies = true;
    private boolean hasOldCopies = false;
    private int oldCopies;

    private boolean defaultSides = true;
    private boolean hasOldSides = false;
    private PrintSides oldSides;

    private boolean defaultCollation = true;
    private boolean hasOldCollation = false;
    private Collation oldCollation;

    private boolean defaultPrintColor = true;
    private boolean hasOldPrintColor = false;
    private PrintColor oldPrintColor;

    private boolean defaultPrintQuality = true;
    private boolean hasOldPrintQuality = false;
    private PrintQuality oldPrintQuality;

    private boolean defaultPrintResolution = true;
    private boolean hasOldPrintResolution = false;
    private PrintResolution oldPrintResolution;

    private boolean defaultPaperSource = true;
    private boolean hasOldPaperSource = false;
    private PaperSource oldPaperSource;

    private boolean defaultPageLayout = true;
    private boolean hasOldPageLayout = false;
    private PageLayout oldPageLayout;

    /**
     * If any settings are incompatible with the specified printer,
     * they are updated to be compatible.
     * This method could be useful as a public one.
     */
    void updateForPrinter(Printer printer) {

        this.printer = printer;
        this.printerCaps = printer.getPrinterAttributes();

        ////////////////////////////////////////////////

        /*
         * The algorithm for how we update is tricky in order to get
         * the desired behaviour, which needs to be explained first.
         * - If neither user nor code ever set a value for a property,
         * we always update to the default for the new printer.
         * - If user or code has ever explicitly set a value for a
         * property then when we navigate to a different printer we
         * remember that last set value.
         * - If the new printer can support that value, it is used
         * - If it can't, then we use the default value for that printer,
         * or in a few cases some 'close' value. Such as substituting
         * LANDSCAPE for REVERSE_LANDSCAPE.
         * - We still remember the value and if we move to another printer
         * that supports it, it gets resurrected.
         */
<A NAME="26"></A>
        //////////// COPIES ////////////

        if (defaultCopies) <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#26',2,'match34-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            if (getCopies() != printerCaps.getDefaultCopies()) {
                setCopies(printerCaps.getDefaultCopies());
                defaultCopies = true; // restore that this is default.
            }
        }</B></FONT> else {
            int copies = getCopies();
            if (hasOldCopies &amp;&amp; oldCopies &gt; copies) {
                copies = oldCopies;
            }
            int maxCopies = printerCaps.getMaxCopies();
            if (!hasOldCopies &amp;&amp; getCopies() &gt; maxCopies) {
                hasOldCopies = true;
                oldCopies = getCopies();
            }
            if (copies &gt; maxCopies) copies = maxCopies;
            setCopies(copies);
        }


        ////////////////////////////////////////////////

        PrintSides currSides = getPrintSides();
        PrintSides defSides = printerCaps.getDefaultPrintSides();
        Set&lt;PrintSides&gt; suppSides = printerCaps.getSupportedPrintSides();

        if (defaultSides) {
            if (currSides != defSides) {
                setPrintSides(defSides);
                defaultSides = true;  // restore that this is default.
            }
        } else {
            // The &quot;current&quot; sides may not be the one we really wanted,
            // but one that was forced by virtue of the current printer not
            // supporting the one specified for a previous printer.
            // Check to see if the old supported value can now
            // be restored on this new printer.
            if (hasOldSides) {
                if (suppSides.contains(oldSides)) {
                    setPrintSides(oldSides);
                    hasOldSides = false; // is current again.
                } else {
                    setPrintSides(defSides);
                }
            } else if (!suppSides.contains(currSides)) {
                    hasOldSides = true;
                    oldSides = currSides;
                    setPrintSides(defSides);
            }
        }

        ////////////////////////////////////////////////

        Collation currColl = getCollation();
        Collation defColl = printerCaps.getDefaultCollation();
        Set&lt;Collation&gt; suppColl = printerCaps.getSupportedCollations();

        if (defaultCollation) {
            if (currColl != defColl) {
                setCollation(defColl);
                defaultCollation = true;  // restore that this is default.
            }
        } else {
            if (hasOldCollation) {
                if (suppColl.contains(oldCollation)) {
                    setCollation(oldCollation);
                    hasOldCollation = false; // is current again.
                } else {
                    setCollation(defColl);
                }
            } else if (!suppColl.contains(currColl)) {
                    hasOldCollation = true;
                    oldCollation = currColl;
                    setCollation(defColl);
            }
        }


        ////////////////////////////////////////////////

        PrintColor currColor = getPrintColor();
        PrintColor defColor = printerCaps.getDefaultPrintColor();
        Set&lt;PrintColor&gt; suppColors = printerCaps.getSupportedPrintColors();

        if (defaultPrintColor) {
            if (currColor != defColor) {
                setPrintColor(defColor);
                defaultPrintColor = true; // restore that this is default.
            }
        } else {
            if (hasOldPrintColor) {
                if (suppColors.contains(oldPrintColor)) {
                    setPrintColor(oldPrintColor);
                    hasOldPrintColor = false; // is current again.
                } else {
                    setPrintColor(defColor);
                }
            } else if (!suppColors.contains(currColor)) {
                hasOldPrintColor = true;
                oldPrintColor = currColor;
                setPrintColor(defColor);
            }
        }

        ////////////////////////////////////////////////

        PrintQuality currQuality = getPrintQuality();
        PrintQuality defQuality = printerCaps.getDefaultPrintQuality();
        Set&lt;PrintQuality&gt; suppQuality = printerCaps.getSupportedPrintQuality();

        if (defaultPrintQuality) {
            if (currQuality != defQuality) {
                setPrintQuality(defQuality);
                defaultPrintQuality = true; // restore that this is default.
            }
        } else {
            if (hasOldPrintQuality) {
                if (suppQuality.contains(oldPrintQuality)) {
                    setPrintQuality(oldPrintQuality);
                    hasOldPrintQuality = false; // is current again.
                } else {
                    setPrintQuality(defQuality);
                }
            } else if (!suppQuality.contains(currQuality)) {
                hasOldPrintQuality = true;
                oldPrintQuality = currQuality;
                setPrintQuality(defQuality);
            }
        }

        ////////////////////////////////////////////////

       PrintResolution currRes = getPrintResolution();
       PrintResolution defResolution = printerCaps.getDefaultPrintResolution();
       Set&lt;PrintResolution&gt; suppRes =
           printerCaps.getSupportedPrintResolutions();

       if (defaultPrintResolution) {
           if (currRes != defResolution) {
               setPrintResolution(defResolution);
               defaultPrintResolution = true; // restore that this is default.
            }
        } else {
            if (hasOldPrintResolution) {
                if (suppRes.contains(oldPrintResolution)) {
                    setPrintResolution(oldPrintResolution);
                    hasOldPrintResolution = false; // is current again.
                } else {
                    setPrintResolution(defResolution);
                }
            } else if (!suppRes.contains(currRes)) {
                hasOldPrintResolution = true;
                oldPrintResolution = currRes;
                setPrintResolution(defResolution);
            }
        }

       ////////////////////////////////////////////////


       PaperSource currSource = getPaperSource();
       PaperSource defSource = printerCaps.getDefaultPaperSource();
       Set&lt;PaperSource&gt; suppSources = printerCaps.getSupportedPaperSources();

       if (defaultPaperSource) {
           if (currSource != defSource) {
               setPaperSource(defSource);
               defaultPaperSource = true; // restore that this is default.
            }
        } else {
            if (hasOldPaperSource) {
                if (suppSources.contains(oldPaperSource)) {
                    setPaperSource(oldPaperSource);
                    hasOldPaperSource = false; // is current again.
                } else {
                    setPaperSource(defSource);
                }
            } else if (!suppSources.contains(currSource)) {
                hasOldPaperSource = true;
                oldPaperSource = currSource;
                setPaperSource(defSource);
            }
        }

       ///////////////////////////////////////////////////

       // Paper size is an important component of PageLayout
       // and the selected paper input tray may affect the paper sizes
       // that are supported. For example non-standard sizes may
       // require a manual or secondary input tray to be used.
       // The implementation below is not accounting for that and
       // it likely should, which means that when updating to a new
       // printer we need to consider tray and layout together, not
       // consecutively.

       PageLayout currPageLayout = getPageLayout();
       PageLayout defPageLayout = printer.getDefaultPageLayout();

       if (defaultPageLayout) {
           // It might appear cleaner to always set the default page layout
           // instance for this printer, but it if they are equal, then
           // either set(..) will skip it anyway, or it won't and a
           // listener will see a somewhat spurious change in the property.
           if (!currPageLayout.equals(defPageLayout)) {
               setPageLayout(defPageLayout);
               defaultPageLayout = true; // restore that this is default.
            }
        } else {
            if (hasOldPageLayout) {
                PageLayout valPageLayout =
                    job.validatePageLayout(oldPageLayout);
                if (valPageLayout.equals(oldPageLayout)) {
                    setPageLayout(oldPageLayout);
                    hasOldPageLayout = false; // is current again.
                } else {
                    setPageLayout(defPageLayout);
                }
            } else {
                PageLayout valPageLayout =
                    job.validatePageLayout(currPageLayout);
                if (!valPageLayout.equals(currPageLayout)) {
                    hasOldPageLayout = true;
                    oldPageLayout = currPageLayout;
                    // Should I use the validated layout instead ?
                    setPageLayout(defPageLayout);
                }
            }
        }
    }

    ///////////////////////  START JOBNAME /////////////////////

    private static final String DEFAULT_JOBNAME = &quot;JavaFX Print Job&quot;;
    private SimpleStringProperty jobName;

    /**
     * &lt;code&gt;StringProperty&lt;/code&gt; representing the name of a job.
     * @return the name of a job
     */
    public final StringProperty jobNameProperty() {
        if (jobName == null) {
            jobName = new SimpleStringProperty(JobSettings.this, &quot;jobName&quot;,
                                               DEFAULT_JOBNAME) {

                @Override
                public void set(String value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        value = DEFAULT_JOBNAME;
                    }
                    super.set(value);
                }

                @Override
                public void bind(ObservableValue&lt;? extends String&gt;
                                 rawObservable) {
                    throw new
                        RuntimeException(&quot;Jobname property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;String&gt; other) {
                    throw new
                        RuntimeException(&quot;Jobname property cannot be bound&quot;);
                }
            };
        }
        return jobName;
    }

    /**
     * Get the name of a job.
     * @return a string representing the name of a job
     */
    public String getJobName() {
        return jobNameProperty().get();
    }


    /**
     * Set the name of a job.
     * @param name string representing the name of a job
     */
    public void setJobName(String name) {
        jobNameProperty().set(name);
    }
    ///////////////////////  END JOBNAME /////////////////////

    //////////////////////// START COPIES ////////////////////////

    private IntegerProperty copies;

    /**
     * &lt;code&gt;IntegerProperty&lt;/code&gt; representing the number of
     * copies of the job to print.
     * @return the number of copies of the job to print
     */
    public final IntegerProperty copiesProperty() {
        if (copies == null) {
            copies =
                new SimpleIntegerProperty(JobSettings.this, &quot;copies&quot;,
                                          printerCaps.getDefaultCopies()) {

                @Override
                public void set(int value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value &lt;= 0) {
                        if (defaultCopies) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultCopies());
                            defaultCopies = true;
                            return;
                        }
                    }
                    super.set(value);
                    defaultCopies = false;
                }

                @Override
                public void bind(ObservableValue&lt;? extends Number&gt;
                                 rawObservable) {
                    throw new
                        RuntimeException(&quot;Copies property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;Number&gt; other) {
                    throw new
                        RuntimeException(&quot;Copies property cannot be bound&quot;);
                }
            };
        }
        return copies;
    }

    /**
     * Get the number of copies to print.
     * @return number of copies to print
     */
    public int getCopies() {
         return copiesProperty().get();
    }

    /**
     * Set the number of copies to print.
     * @param nCopies number of copies to print
     */
    public final void setCopies(int nCopies) {
        copiesProperty().set(nCopies);
    }

    //////////////////////// END COPIES ////////////////////////


    ///////////////////////  START PAGE RANGES /////////////////////
    private ObjectProperty&lt;PageRange[]&gt; pageRanges = null;

    /**
     * An &lt;code&gt;ObjectProperty&lt;/code&gt; whose value represents the job pages
     * to print as an array of PageRange.
     * A null values mean print all pages.
     * Otherwise it must be a non-overlapping array of PageRange
     * instances ordered in increasing page number.
     * Page numbers start from 1 (one).
     * An empty array is considered equivalent to a null array.
     * &lt;p&gt;
     * An illegal or unsupported (by the printer) set of page ranges
     * will be ignored.
     * &lt;p&gt;
     * Ranges which exceed beyond the number of pages imaged by the job
     * during printing do not cause any error.
     *
     * @return the value presents the job pages to print as an array of PageRange
     */
    public final ObjectProperty pageRangesProperty() {
         if (pageRanges == null) {
            pageRanges = new SimpleObjectProperty(JobSettings.this,
                                                  &quot;pageRanges&quot;, null) {

                @Override
                public void set(Object o) {
                    try {
                        set((PageRange[])o);
                    } catch (ClassCastException e) {
                        return;
                    }
                }

                public void set(PageRange[] value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null || value.length == 0 ||
                        value[0] == null) {
                        value = null;
                    } else { // validate
                        int len = value.length;
                        PageRange[] arr = new PageRange[len];
                        int curr = 0;
                        for (int i=0; i&lt;len; i++) {
                            PageRange r = value[i];
                            if (r == null || curr &gt;= r.getStartPage()) {
                                return; // bad range
                            }
                            curr = r.getEndPage();
                            arr[i] = r;
                        }
                        value = arr;
                    }
                    // passed validation so its either null,
                    // or an array of ranges in increasing order.
                    super.set(value);
                }

                @Override
                public void bind(ObservableValue rawObservable) {
                    throw new RuntimeException
                        (&quot;PageRanges property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property other) {
                    throw new RuntimeException
                        (&quot;PageRanges property cannot be bound&quot;);
                }
            };
        }
        return pageRanges;
    }

    /**
     * The range of pages to print. null always means all pages.
     * See {@link pageRangesProperty} for more details.
     * @return null or an array as specified above
     */
    public PageRange[] getPageRanges() {
        return (PageRange[])(pageRangesProperty().get());
    }

    /**
     * The range of pages to print as an array of PageRange.
     * The use of varargs means the common case of a single range
     * can be auto-boxed.
     * &lt;code&gt;((PageRange[])null)&lt;/code&gt; always means all pages however
     * since this is the default it is less likely to be used.
     * See {@link pageRangesProperty} for more details.
     * @param pages null or a varargs array as specified above
     */
    public void setPageRanges(PageRange... pages) {
        pageRangesProperty().set((PageRange[])pages);
    }

    ///////////////////////  END PAGE RANGES /////////////////////


    ///////////////////////  START SIDES  /////////////////////

    private ObjectProperty&lt;PrintSides&gt; sides = null;

    /**
     * Property representing an instance of &lt;code&gt;PrintSides&lt;/code&gt;.
     * @return an instance of &lt;code&gt;PrintSides&lt;/code&gt;
     */
    public final ObjectProperty&lt;PrintSides&gt; printSidesProperty() {
         if (sides == null) {
             sides = new SimpleObjectProperty&lt;PrintSides&gt;
                 (JobSettings.this, &quot;printSides&quot;,
                  printerCaps.getDefaultPrintSides()) {

                @Override
                public void set(PrintSides value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        if (defaultSides) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultPrintSides());
                            defaultSides = true;
                        }
                    }
                    if (printerCaps.getSupportedPrintSides().contains(value)) {
                        super.set(value);
                        defaultSides = false;
                    }
                }

                @Override
                public void bind(ObservableValue&lt;? extends PrintSides&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;PrintSides property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;PrintSides&gt; other) {
                    throw new RuntimeException
                        (&quot;PrintSides property cannot be bound&quot;);
                }
            };
        }
        return sides;
    }

    /**
     * If a printer supports it, then a job may be printed on
     * both sides of the media (paper), ie duplex printing.
     * This method returns the selected setting.
     * @return the duplex (side) setting.
     */
    public PrintSides getPrintSides() {
        return printSidesProperty().get();
    }

    /**
     * Set the &lt;code&gt;PrintSides&lt;/code&gt; property which controls
     * duplex printing.
     * A null value is ignored.
     * @param sides new setting for number of sides.
     */
    public void setPrintSides(PrintSides sides) {
        if (sides == getPrintSides()) {
            return;
        }
        printSidesProperty().set(sides);
    }
    ///////////////////////  END SIDES  /////////////////////


    ///////////////////////  START COLLATION /////////////////////

    private ObjectProperty&lt;Collation&gt; collation = null;

    /**
     * Property representing an instance of &lt;code&gt;Collation&lt;/code&gt;.
     * @return an instance of &lt;code&gt;Collation&lt;/code&gt;
     */
    public final ObjectProperty&lt;Collation&gt; collationProperty() {
         if (collation == null) {
             Collation coll = printerCaps.getDefaultCollation();
             collation = new SimpleObjectProperty&lt;Collation&gt;
                (JobSettings.this, &quot;collation&quot;, coll) {

                @Override
                public void set(Collation value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        if (defaultCollation) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultCollation());
                            defaultCollation = true;
                            return;
                        }
                    }
                    if (printerCaps.getSupportedCollations().contains(value)) {
                        super.set(value);
                        defaultCollation = false;
                    }
                }

                @Override
                public void bind(ObservableValue&lt;? extends Collation&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;Collation property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;Collation&gt; other) {
                    throw new RuntimeException
                        (&quot;Collation property cannot be bound&quot;);
                }
            };
        }
        return collation;
    }

    /**
     * Collation determines how sheets are sorted when
     * multiple copies of a document are printed.
     * As such it is only relevant if 2 or more copies of
     * a document with 2 more sheets are printed.
     * A sheet is the physical media, so documents with 2 pages
     * that are printed N-up, or double-sided may still have only
     * one sheet.
     * A collated print job produces documents with sheets
     * of a document sorted in sequence.
     * An uncollated job collects together the multiple copies
     * of the same sheet.
     * Uncollated (&lt;code&gt;false&lt;/code&gt;) is the typical default value.
     *
     * @return the collation
     */
    public Collation getCollation() {
        return collationProperty().get();
    }

    /**
     * Set the &lt;code&gt;Collation&lt;/code&gt; property.
     * A null value is ignored.
     * @param collation new setting for collation
     */
    public void setCollation(Collation collation) {
        if (collation == getCollation()) {
            return;
        }
        collationProperty().set(collation);
    }

    ///////////////////////  END COLLATION /////////////////////

    ///////////////////////  START COLOUR /////////////////////

    private ObjectProperty&lt;PrintColor&gt; color = null;

    /**
     * Property representing an instance of &lt;code&gt;PrintColor&lt;/code&gt;.
     * @return an instance of &lt;code&gt;PrintColor&lt;/code&gt;
     */
    public final ObjectProperty&lt;PrintColor&gt; printColorProperty() {
         if (color == null) {
            color = new SimpleObjectProperty&lt;PrintColor&gt;
                (JobSettings.this, &quot;printColor&quot;,
                 printerCaps.getDefaultPrintColor()) {

                @Override
                public void set(PrintColor value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        if (defaultPrintColor) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultPrintColor());
                            defaultPrintColor = true;
                        }
                    }
                    if (printerCaps.
                        getSupportedPrintColors().contains(value)) {
                        super.set(value);
                        defaultPrintColor = false;
                    }
                }

                @Override
                public void bind(ObservableValue&lt;? extends PrintColor&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;PrintColor property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;PrintColor&gt; other) {
                    throw new RuntimeException
                        (&quot;PrintColor property cannot be bound&quot;);
                }
            };
        }
        return color;
    }

    public PrintColor getPrintColor() {
        return printColorProperty().get();
    }

    /**
     * Set the &lt;code&gt;PrintColor&lt;/code&gt; property.
     * A null value is ignored.
     *
     * @param color new setting for print color.
     */
    public void setPrintColor(PrintColor color) {
        if (color == getPrintColor()) {
            return;
        }
        printColorProperty().set(color);
    }

    ///////////////////////  END COLOUR /////////////////////

    ///////////////////////  START QUALITY /////////////////////

    private ObjectProperty&lt;PrintQuality&gt; quality = null;

    /**
     * Property representing an instance of &lt;code&gt;PrintQuality&lt;/code&gt;.
     * @return an instance of &lt;code&gt;PrintQuality&lt;/code&gt;
     */
    public final ObjectProperty&lt;PrintQuality&gt; printQualityProperty() {
         if (quality == null) {
            quality = new SimpleObjectProperty&lt;PrintQuality&gt;
                (JobSettings.this, &quot;printQuality&quot;,
                 printerCaps.getDefaultPrintQuality()) {

                @Override
                public void set(PrintQuality value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        if (defaultPrintQuality) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultPrintQuality());
                            defaultPrintQuality = true;
                        }
                    }
                    if (printerCaps.
                        getSupportedPrintQuality().contains(value)) {
                        super.set(value);
                        defaultPrintQuality = false;
                    }
                }

                @Override
                public void bind(ObservableValue&lt;? extends PrintQuality&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;PrintQuality property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;PrintQuality&gt; other) {
                    throw new RuntimeException
                        (&quot;PrintQuality property cannot be bound&quot;);
                }
            };
        }
        return quality;
    }

    public PrintQuality getPrintQuality() {
        return  printQualityProperty().get();
    }

    /**
     * Set the &lt;code&gt;PrintQuality&lt;/code&gt; property.
     * A null value is ignored.
     * &lt;p&gt;
     * Note that quality and resolution overlapping concepts.
     * Therefore a printer may support setting one, or the other but
     * not both. Applications setting these programmatically should
     * query both properties and select appropriately from the supported
     * values. If a printer supports non-standard values, code likely
     * cannot distinguish the printer's interpretation of these values
     * and is safest to stick to selecting from the standard value that
     * matches the requirement.
     * @param quality new setting for print quality.
     */
    public void setPrintQuality(PrintQuality quality) {
        if (quality == getPrintQuality()) {
            return;
        }
        printQualityProperty().set(quality);
    }

    ///////////////////////  END QUALITY /////////////////////

    ///////////////////////  START RESOLUTION /////////////////////


    private ObjectProperty&lt;PrintResolution&gt; resolution = null;

    /**
     * Property representing an instance of &lt;code&gt;PrintResolution&lt;/code&gt;.
     * @return an instance of &lt;code&gt;PrintResolution&lt;/code&gt;
     */
    public final ObjectProperty&lt;PrintResolution&gt; printResolutionProperty() {
         if (resolution == null) {
            resolution = new SimpleObjectProperty&lt;PrintResolution&gt;
                (JobSettings.this, &quot;printResolution&quot;,
                 printerCaps.getDefaultPrintResolution()) {

                @Override
                public void set(PrintResolution value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        if (defaultPrintResolution) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultPrintResolution());
                            defaultPrintResolution = true;
                        }
                    }
                    if (printerCaps.getSupportedPrintResolutions().
                        contains(value))
                    {
                        super.set(value);
                        defaultPrintResolution = false;
                    }
                }

                @Override
                public void bind(ObservableValue&lt;? extends PrintResolution&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;PrintResolution property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;PrintResolution&gt; other)
                {
                    throw new RuntimeException
                        (&quot;PrintResolution property cannot be bound&quot;);
                }
            };
        }
        return resolution;
    }

    /**
     *
     * @return the print resolution
     */
    public PrintResolution getPrintResolution() {
        return printResolutionProperty().get();
    }

    /**
     * Set the &lt;code&gt;PrintResolution&lt;/code&gt; property.
     * A null value is ignored.
     * &lt;p&gt;
     * Note that quality and resolution overlapping concepts.
     * Therefore a printer may support setting one, or the other but
     * not both. Applications setting these programmatically should
     * query both properties and select appropriately from the supported
     * values. If a printer supports non-standard values, code likely
     * cannot distinguish the printer's interpretation of these values
     * and is safest to stick to selecting from the standard value that
     * matches the requirement.
     * @param resolution new setting for print resolution.
     */
    public void setPrintResolution(PrintResolution resolution) {
        if (resolution == null || resolution == getPrintResolution()) {
            return;
        }
        printResolutionProperty().set(resolution);
    }

    ///////////////////////  END RESOLUTION /////////////////////

    //////////////// START PAPERSOURCE /////////////////

    private ObjectProperty&lt;PaperSource&gt; paperSource = null;


    /**
     * Property representing an instance of &lt;code&gt;PaperSource&lt;/code&gt;.
     * @return an instance of &lt;code&gt;PaperSource&lt;/code&gt;
     */
    public final ObjectProperty&lt;PaperSource&gt; paperSourceProperty() {
         if (paperSource == null) {
            paperSource = new SimpleObjectProperty&lt;PaperSource&gt;
                (JobSettings.this, &quot;paperSource&quot;,
                 printerCaps.getDefaultPaperSource()) {

                @Override
                public void set(PaperSource value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        if (defaultPaperSource) {
                            return;
                        } else {
                            super.set(printerCaps.getDefaultPaperSource());
                            defaultPaperSource = true;
                        }
                    }
                    if (printerCaps.
                        getSupportedPaperSources().contains(value)) {
                        super.set(value);
                        defaultPaperSource = false;
                    }
                }

                @Override
                public void bind(ObservableValue&lt;? extends PaperSource&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;PaperSource property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;PaperSource&gt; other) {
                    throw new RuntimeException
                        (&quot;PaperSource property cannot be bound&quot;);
                }
            };
        }
        return paperSource;
    }


    public PaperSource getPaperSource() {
        return paperSourceProperty().get();
    }

    public void setPaperSource(PaperSource value) {
        paperSourceProperty().set(value);
    }

    //////////////// END PAPERSOURCE /////////////////

    //////////////// START PAGELAYOUT /////////////////

    /*
     * Default page needs to originate from the printer, be the
     * default for the initial settings on the job.

     * having &quot;page&quot; be a property might make sense and perhaps
     * for the elts of a paper like orientation.
     * But what is the point in listening in on the paper of a Page
     * or orientation if a whole new Page is added instead ..
     */

    private ObjectProperty&lt;PageLayout&gt; layout = null;

    /**
     * Property representing an instance of &lt;code&gt;PageLayout&lt;/code&gt;.
     * @return an instance of &lt;code&gt;PageLayout&lt;/code&gt;
     */
    public final ObjectProperty&lt;PageLayout&gt; pageLayoutProperty() {
         if (layout == null) {
             layout = new SimpleObjectProperty&lt;PageLayout&gt;
                 (JobSettings.this, &quot;pageLayout&quot;,
                  printer.getDefaultPageLayout()) {

                @Override
                public void set(PageLayout value) {
                    if (!isJobNew()) {
                        return;
                    }
                    if (value == null) {
                        return;
                    }
                    defaultPageLayout = false;
                    super.set(value);
                }

                @Override
                public void bind(ObservableValue&lt;? extends PageLayout&gt;
                                 rawObservable) {
                    throw new RuntimeException
                        (&quot;PageLayout property cannot be bound&quot;);
                }

                @Override
                public void bindBidirectional(Property&lt;PageLayout&gt; other) {
                    throw new RuntimeException
                        (&quot;PageLayout property cannot be bound&quot;);
                }
            };
        }
        return layout;
    }

    /**
     * Get the current page layout for this job.
     * @return page layout to use for the job.
     */
    public PageLayout getPageLayout() {
        return pageLayoutProperty().get();
    }

    /**
     * Set the PageLayout to use.
     * @param pageLayout The page layout to use.
     */
    public void setPageLayout(PageLayout pageLayout) {
        pageLayoutProperty().set(pageLayout);
    }

    //////////////// END PAGELAYOUT /////////////////

    @Override
    public String toString() {
        String nl = System.lineSeparator();
        return
            &quot; Collation = &quot; + getCollation() + nl +
            &quot; Copies = &quot; + getCopies() + nl +
            &quot; Sides = &quot; + getPrintSides() + nl +
            &quot; JobName = &quot; + getJobName() + nl +
            &quot; Page ranges = &quot; + getPageRanges() + nl +
            &quot; Print color = &quot; + getPrintColor() + nl +
            &quot; Print quality = &quot; + getPrintQuality() + nl +
            &quot; Print resolution = &quot; + getPrintResolution() + nl +
            &quot; Paper source = &quot; + getPaperSource() + nl +
            &quot; Page layout = &quot; + getPageLayout();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/CssStyleHelper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WritableValue;
import com.sun.javafx.css.CascadingStyle;
import javafx.css.CssMetaData;
import javafx.css.CssParser;
import javafx.css.FontCssMetaData;
import javafx.css.ParsedValue;
import javafx.css.PseudoClass;
import javafx.css.Rule;
import javafx.css.Selector;
import javafx.css.Style;
import javafx.css.StyleConverter;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.css.Stylesheet;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;

import com.sun.javafx.css.CalculatedValue;
import com.sun.javafx.css.ParsedValueImpl;
import com.sun.javafx.css.PseudoClassState;
import com.sun.javafx.css.StyleCache;
import com.sun.javafx.css.StyleCacheEntry;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.css.StyleMap;
import javafx.css.converter.FontConverter;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.Utils;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

import static com.sun.javafx.css.CalculatedValue.*;

/**
 * The StyleHelper is a helper class used for applying CSS information to Nodes.
 */
final class CssStyleHelper {

    private static final PlatformLogger LOGGER = com.sun.javafx.util.Logging.getCSSLogger();

    private CssStyleHelper() {
        this.triggerStates = new PseudoClassState();
    }

    /**
     * Creates a new StyleHelper.
     */
    static CssStyleHelper createStyleHelper(final Node node) {

        // need to know how far we are to root in order to init arrays.
        // TODO: should we hang onto depth to avoid this nonsense later?
        // TODO: is there some other way of knowing how far from the root a node is?
        Styleable parent = node;
        int depth = 0;
        while(parent != null) {
            depth++;
            parent = parent.getStyleableParent();
        }

        // The List&lt;CacheEntry&gt; should only contain entries for those
        // pseudo-class states that have styles. The StyleHelper's
        // pseudoclassStateMask is a bitmask of those pseudoclasses that
        // appear in the node's StyleHelper's smap. This list of
        // pseudo-class masks is held by the StyleCacheKey. When a node is
        // styled, its pseudoclasses and the pseudoclasses of its parents
        // are gotten. By comparing the actual pseudo-class state to the
        // pseudo-class states that apply, a CacheEntry can be created or
        // fetched using only those pseudoclasses that matter.
        final PseudoClassState[] triggerStates = new PseudoClassState[depth];

        final StyleMap styleMap =
                StyleManager.getInstance().findMatchingStyles(node, node.getSubScene(), triggerStates);

        //
        // reuse the existing styleHelper if possible.
        //
        if ( canReuseStyleHelper(node, styleMap) ) {

            //
            // RT-33080
            //
            // If we're reusing a style helper, clear the fontSizeCache in case either this node or some parent
            // node has changed font from a user calling setFont.
            //
            // It may be the case that the node's font has changed from a call to setFont, which will
            // trigger a REAPPLY. If the REAPPLY comes because of a change in font, then the fontSizeCache
            // needs to be invalidated (cleared) so that new values will be looked up for all transition states.
            //
            if (node.styleHelper.cacheContainer != null &amp;&amp; node.styleHelper.isUserSetFont(node)) {
                node.styleHelper.cacheContainer.fontSizeCache.clear();
            }
            node.styleHelper.cacheContainer.forceSlowpath = true;
            node.styleHelper.triggerStates.addAll(triggerStates[0]);
            node.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(node);
            updateParentTriggerStates(node, depth, triggerStates);
            return node.styleHelper;

        }

        if (styleMap == null || styleMap.isEmpty()) {

            boolean mightInherit = false;

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();

            final int pMax = props != null ? props.size() : 0;
            for (int p=0; p&lt;pMax; p++) {

                final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
                if (prop.isInherits()) {
                    mightInherit = true;
                    break;
                }
            }

            if (mightInherit == false) {

                // If this node had a style helper, then reset properties to their initial value
                // since the node won't have a style helper after this call
                if (node.styleHelper != null) {
                    node.styleHelper.resetToInitialValues(node);
                }

                //
                // This node didn't have a StyleHelper before and it doesn't need one now since there are
                // no styles in the StyleMap and no inherited styles.
                return null;
            }

        }

        final CssStyleHelper helper = new CssStyleHelper();
        helper.triggerStates.addAll(triggerStates[0]);

        updateParentTriggerStates(node, depth, triggerStates);

        helper.cacheContainer = new CacheContainer(node, styleMap, depth);

        helper.firstStyleableAncestor = findFirstStyleableAncestor(node);

        // If this node had a style helper, then reset properties to their initial value
        // since the style map might now be different
        if (node.styleHelper != null) {
            node.styleHelper.resetToInitialValues(node);
        }
        return helper;
    }

    private static void updateParentTriggerStates(Styleable styleable, int depth, PseudoClassState[] triggerStates) {
        // make sure parent's transition states include the pseudo-classes
        // found when matching selectors
        Styleable parent = styleable.getStyleableParent();
        for(int n=1; n&lt;depth; n++) {

            // TODO: this means that a style like .menu-item:hover won't work. Need to separate CssStyleHelper tree from scene-graph tree
            if (parent instanceof Node == false) {
                parent=parent.getStyleableParent();
                continue;
            }
            Node parentNode = (Node)parent;

            final PseudoClassState triggerState = triggerStates[n];

            // if there is nothing in triggerState, then continue since there
            // isn't any pseudo-class state that might trigger a state change
            if (triggerState != null &amp;&amp; triggerState.size() &gt; 0) {

                // Create a StyleHelper for the parent, if necessary.
                // TODO : check why calling createStyleHelper(parentNode) does not work here?
                if (parentNode.styleHelper == null) {
                    parentNode.styleHelper = new CssStyleHelper();
                    parentNode.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(parentNode) ;
                }
                parentNode.styleHelper.triggerStates.addAll(triggerState);

            }

            parent=parent.getStyleableParent();
        }

    }
    //
    // return true if the fontStyleableProperty's origin is USER
    //
    private boolean isUserSetFont(Styleable node) {

        if (node == null) return false; // should never happen, but just to be safe...

        CssMetaData&lt;Styleable, Font&gt; fontCssMetaData = cacheContainer != null ? cacheContainer.fontProp : null;
        if (fontCssMetaData != null) {
            StyleableProperty&lt;Font&gt; fontStyleableProperty = fontCssMetaData != null ? fontCssMetaData.getStyleableProperty(node) : null;
            if (fontStyleableProperty != null &amp;&amp; fontStyleableProperty.getStyleOrigin() == StyleOrigin.USER) return true;
        }

        Styleable styleableParent = firstStyleableAncestor;
        CssStyleHelper parentStyleHelper = getStyleHelper(firstStyleableAncestor);

        if (parentStyleHelper != null) {
            return parentStyleHelper.isUserSetFont(styleableParent);
        } else {
            return false;
        }
    }

    private static CssStyleHelper getStyleHelper(Node n) {
        return (n != null)? n.styleHelper : null;
    }

    private static Node findFirstStyleableAncestor(Styleable st) {
        Node ancestor = null;
        Styleable parent = st.getStyleableParent();
        while (parent != null) {
            if (parent instanceof Node) {
                if (((Node) parent).styleHelper != null) {
                    ancestor = (Node) parent;
                    break;
                }
            }
            parent = parent.getStyleableParent();
        }

        return ancestor;
    }

    //
    // return the value of the property
    //
    private static boolean isTrue(WritableValue&lt;Boolean&gt; booleanProperty) {
        return booleanProperty != null &amp;&amp; booleanProperty.getValue();
    }

    //
    // set the value of the property to true
    //
    private static void setTrue(WritableValue&lt;Boolean&gt; booleanProperty) {
        if (booleanProperty != null) booleanProperty.setValue(true);
    }

    //
    // return true if the Node's current styleHelper can be reused.
    //
    private static boolean canReuseStyleHelper(final Node node, final StyleMap styleMap) {

        // Obviously, we cannot reuse the node's style helper if it doesn't have one.
        if (node == null || node.styleHelper == null) {
            return false;
        }

        // If we have a styleHelper but the new styleMap is null, then we don't need a styleHelper at all
        if (styleMap == null) {
            return false;
        }

        StyleMap currentMap = node.styleHelper.getStyleMap(node);

        // We cannot reuse the style helper if the styleMap is not the same instance as the current one
        // Note: check instance equality!
        if (currentMap != styleMap) {
            return false;
        }

        // If the style maps are the same instance, we can re-use the current styleHelper if the cacheContainer is null.
        // Under this condition, there are no styles for this node _and_ no styles inherit.
        if (node.styleHelper.cacheContainer == null) {
            return true;
        }

        //
        // The current map might be the same, but one of the node's parent's maps might have changed which
        // might cause some calculated values to change. To see if we can re-use the style-helper, we need to
        // check if the StyleMap id's have changed, which we can do by inspecting the cacheContainer's styleCacheKey
        // since it is made up of the current set of StyleMap ids.
        //

        Styleable parent = node.getStyleableParent();

        // if the node's parent is null and the style maps are the same, then we can certainly reuse the style-helper
        if (parent == null) {
            return true;
        }

        CssStyleHelper parentHelper = getStyleHelper(node.styleHelper.firstStyleableAncestor);

        if (parentHelper != null &amp;&amp; parentHelper.cacheContainer != null) {

            int[] parentIds = parentHelper.cacheContainer.styleCacheKey.getStyleMapIds();
            int[] nodeIds = node.styleHelper.cacheContainer.styleCacheKey.getStyleMapIds();

            if (parentIds.length == nodeIds.length - 1) {

                boolean isSame = true;

                // check that all of the style map ids are the same.
                for (int i = 0; i &lt; parentIds.length; i++) {
                    if (nodeIds[i + 1] != parentIds[i]) {
                        isSame = false;
                        break;
                    }
                }

                return isSame;

            }
        }

        return false;
    }

    /* This is the first Styleable parent (of Node this StyleHelper belongs to)
     * having a valid StyleHelper */
    private Node firstStyleableAncestor;

    private CacheContainer cacheContainer;

    private final static class CacheContainer {

        // Set internal internalState structures
        private CacheContainer(
                Node node,
                final StyleMap styleMap,
                int depth) {

            int ctr = 0;
            int[] smapIds = new int[depth];
            smapIds[ctr++] = this.smapId = styleMap.getId();

            //
            // Create a set of StyleMap id's from the parent's smapIds.
            // The resulting smapIds array may have less than depth elements.
            // If a parent doesn't have a styleHelper or the styleHelper's
            // internal state is null, then that parent doesn't contribute
            // to the selection of a style. Any Node that has the same
            // set of smapId's can potentially share previously calculated
            // values.
            //
            Styleable parent = node.getStyleableParent();
            for(int d=1; d&lt;depth; d++) {

                // TODO: won't work for something like .menu-item:hover. Need to separate CssStyleHelper tree from scene-graph tree
                if ( parent instanceof Node) {
                    Node parentNode = (Node)parent;
                final CssStyleHelper helper = parentNode.styleHelper;
                    if (helper != null &amp;&amp; helper.cacheContainer != null) {
                        smapIds[ctr++] = helper.cacheContainer.smapId;
                    }
                }
                parent = parent.getStyleableParent();

            }

            this.styleCacheKey = new StyleCache.Key(smapIds, ctr);

            CssMetaData&lt;Styleable,Font&gt; styleableFontProperty = null;

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
            final int pMax = props != null ? props.size() : 0;
            for (int p=0; p&lt;pMax; p++) {
                final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);

                if (&quot;-fx-font&quot;.equals(prop.getProperty())) {
                    // unchecked!
                    styleableFontProperty = (CssMetaData&lt;Styleable, Font&gt;) prop;
                    break;
                }
            }

            this.fontProp = styleableFontProperty;
            this.fontSizeCache = new HashMap&lt;&gt;();

            this.cssSetProperties = new HashMap&lt;&gt;();

        }

        private StyleMap getStyleMap(Styleable styleable) {
            if (styleable != null) {
                SubScene subScene =  (styleable instanceof Node) ? ((Node) styleable).getSubScene() : null;
                return StyleManager.getInstance().getStyleMap(styleable, subScene, smapId);
            } else {
                return StyleMap.EMPTY_MAP;
            }

        }

        // This is the key we use to find the shared cache
        private final StyleCache.Key styleCacheKey;

        // If the node has a fontProperty, we hang onto the CssMetaData for it
        // so we can get at it later.
        // TBD - why not the fontProperty itself?
        private final CssMetaData&lt;Styleable,Font&gt; fontProp;

        // The id of StyleMap that contains the styles that apply to this node
        private final int smapId;

        // All nodes with the same set of styles share the same cache of
        // calculated values. But one node might have a different font-size
        // than another so the values are stored in cache by font-size.
        // This map associates a style cache entry with the font to use when
        // getting a value from or putting a value into cache.
        private final Map&lt;StyleCacheEntry.Key, CalculatedValue&gt; fontSizeCache;

        // Any properties that have been set by this style helper are tracked
        // here so the property can be reset without expanding properties that
        // were not set by css.
        private final Map&lt;CssMetaData, CalculatedValue&gt; cssSetProperties;

        private boolean forceSlowpath = false;
    }

    private void resetToInitialValues(final Styleable styleable) {

        if (cacheContainer == null ||
                cacheContainer.cssSetProperties == null ||
                cacheContainer.cssSetProperties.isEmpty()) return;

        // RT-31714 - make a copy of the entry set and clear the cssSetProperties immediately.
        Set&lt;Entry&lt;CssMetaData, CalculatedValue&gt;&gt; entrySet = new HashSet&lt;&gt;(cacheContainer.cssSetProperties.entrySet());
        cacheContainer.cssSetProperties.clear();

        for (Entry&lt;CssMetaData, CalculatedValue&gt; resetValues : entrySet) {

            final CssMetaData metaData = resetValues.getKey();
            final StyleableProperty styleableProperty = metaData.getStyleableProperty(styleable);

            final StyleOrigin styleOrigin = styleableProperty.getStyleOrigin();
            if (styleOrigin != null &amp;&amp; styleOrigin != StyleOrigin.USER) {
                final CalculatedValue calculatedValue = resetValues.getValue();
                styleableProperty.applyStyle(calculatedValue.getOrigin(), calculatedValue.getValue());
            }
        }
    }


    private StyleMap getStyleMap(Styleable styleable) {
        if (cacheContainer == null || styleable == null) return null;
        return cacheContainer.getStyleMap(styleable);
    }

    /**
     * A Set of all the pseudo-class states which, if they change, need to
     * cause the Node to be set to UPDATE its CSS styles on the next pulse.
     * For example, your stylesheet might have:
     * &lt;pre&gt;&lt;code&gt;
     * .button { ... }
     * .button:hover { ... }
     * .button *.label { text-fill: black }
     * .button:hover *.label { text-fill: blue }
     * &lt;/code&gt;&lt;/pre&gt;
     * In this case, the first 2 rules apply to the Button itself, but the
     * second two rules apply to the label within a Button. When the hover
     * changes on the Button, however, we must mark the Button as needing
     * an UPDATE. StyleHelper though only contains styles for the first two
     * rules for Button. The pseudoclassStateMask would in this case have
     * only a single bit set for &quot;hover&quot;. In this way the StyleHelper associated
     * with the Button would know whether a change to &quot;hover&quot; requires the
     * button and all children to be update. Other pseudo-class state changes
     * that are not in this hash set are ignored.
     * *
     * Called &quot;triggerStates&quot; since they would trigger a CSS update.
     */
    private PseudoClassState triggerStates = new PseudoClassState();

    boolean pseudoClassStateChanged(PseudoClass pseudoClass) {
        return triggerStates.contains(pseudoClass);
    }

    /**
     * Dynamic pseudo-class state of the node and its parents.
     * Only valid during a pulse.
     *
     * The StyleCacheEntry to choose depends on the Node's pseudo-class state
     * and the pseudo-class state of its parents. Without the parent
     * pseudo-class state, the fact that the the node in this pseudo-class state
     * matched foo:blah bar { } is lost.
     */
    // TODO: this should work on Styleable, not Node
    private Set&lt;PseudoClass&gt;[] getTransitionStates(final Node node) {

        // if cacheContainer is null, then CSS just doesn't apply to this node
        if (cacheContainer == null) return null;

        int depth = 0;
        Node parent = node;
        while (parent != null) {
            depth += 1;
            parent = parent.getParent();
        }

        //
        // StyleHelper#triggerStates is the set of pseudo-classes that appear
        // in the style maps of this StyleHelper. Calculated values are
        // cached by pseudo-class state, but only the pseudo-class states
        // that mater are used in the search. So we take the transition states
        // and intersect them with triggerStates to remove the
        // transition states that don't matter when it comes to matching states
        // on a  selector. For example if the style map contains only
        // .foo:hover { -fx-fill: red; } then only the hover state matters
        // but the transtion state could be [hover, focused]
        //
        final Set&lt;PseudoClass&gt;[] retainedStates = new PseudoClassState[depth];

        //
        // Note Well: The array runs from leaf to root. That is,
        // retainedStates[0] is the pseudo-class state for node and
        // retainedStates[1..(states.length-1)] are the retainedStates for the
        // node's parents.
        //

        int count = 0;
        parent = node;
        while (parent != null) { // This loop traverses through all ancestors till root
            final CssStyleHelper helper = (parent instanceof Node) ? parent.styleHelper : null;
            if (helper != null) {
                final Set&lt;PseudoClass&gt; pseudoClassState = parent.pseudoClassStates;
                retainedStates[count] = new PseudoClassState();
                retainedStates[count].addAll(pseudoClassState);
                // retainAll method takes the intersection of pseudoClassState and helper.triggerStates
                retainedStates[count].retainAll(helper.triggerStates);
                count += 1;
            }
            parent = parent.getParent();
        }

        final Set&lt;PseudoClass&gt;[] transitionStates = new PseudoClassState[count];
        System.arraycopy(retainedStates, 0, transitionStates, 0, count);

        return transitionStates;

    }

    /**
     * Called by the Node whenever it has transitioned from one set of
     * pseudo-class states to another. This function will then lookup the
     * new values for each of the styleable variables on the Node, and
     * then either set the value directly or start an animation based on
     * how things are specified in the CSS file. Currently animation support
     * is disabled until the new parser comes online with support for
     * animations and that support is detectable via the API.
     */
    void transitionToState(final Node node) {

        if (cacheContainer == null) {
            return;
        }

        //
        // If styleMap is null, then StyleManager has blown it away and we need to reapply CSS.
        //
        final StyleMap styleMap = getStyleMap(node);
        if (styleMap == null) {
            cacheContainer = null;
            node.reapplyCSS();
            return;
        }

        // if the style-map is empty, then we are only looking for inherited styles.
        final boolean inheritOnly = styleMap.isEmpty();

        //
        // Styles that need lookup can be cached provided none of the styles
        // are from Node.style.
        //
        final StyleCache sharedCache = StyleManager.getInstance().getSharedCache(node, node.getSubScene(), cacheContainer.styleCacheKey);

        if (sharedCache == null) {
            // Shared cache was blown away by StyleManager.
            // Therefore, this CssStyleHelper is no good.
            cacheContainer = null;
            node.reapplyCSS();
            return;

        }

        final Set&lt;PseudoClass&gt;[] transitionStates = getTransitionStates(node);

        final StyleCacheEntry.Key fontCacheKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());
        CalculatedValue cachedFont = cacheContainer.fontSizeCache.get(fontCacheKey);

        if (cachedFont == null) {

            cachedFont = lookupFont(node, &quot;-fx-font&quot;, styleMap, cachedFont);

            if (cachedFont == SKIP) cachedFont = getCachedFont(node.getStyleableParent());
            if (cachedFont == null) cachedFont = new CalculatedValue(Font.getDefault(), null, false);

            cacheContainer.fontSizeCache.put(fontCacheKey,cachedFont);

        }

        final Font fontForRelativeSizes = (Font)cachedFont.getValue();

        final StyleCacheEntry.Key cacheEntryKey = new StyleCacheEntry.Key(transitionStates, fontForRelativeSizes);
        StyleCacheEntry cacheEntry = sharedCache.getStyleCacheEntry(cacheEntryKey);

        // if the cacheEntry already exists, take the fastpath
        final boolean fastpath = cacheEntry != null;

        if (cacheEntry == null) {
            cacheEntry = new StyleCacheEntry();
            sharedCache.addStyleCacheEntry(cacheEntryKey, cacheEntry);
        }

        final List&lt;CssMetaData&lt;? extends Styleable,  ?&gt;&gt; styleables = node.getCssMetaData();

        // Used in the for loop below, and a convenient place to stop when debugging.
        final int max = styleables.size();

        final boolean isForceSlowpath = cacheContainer.forceSlowpath;
        cacheContainer.forceSlowpath = false;

        // For each property that is settable, we need to do a lookup and
        // transition to that value.
        for(int n=0; n&lt;max; n++) {

            @SuppressWarnings(&quot;unchecked&quot;) // this is a widening conversion
            final CssMetaData&lt;Styleable,Object&gt; cssMetaData =
                    (CssMetaData&lt;Styleable,Object&gt;)styleables.get(n);

            // Don't bother looking up styles that don't inherit.
            if (inheritOnly &amp;&amp; cssMetaData.isInherits() == false) {
                continue;
            }

            // Skip the lookup if we know there isn't a chance for this property
            // to be set (usually due to a &quot;bind&quot;).
            if (!cssMetaData.isSettable(node)) continue;

            final String property = cssMetaData.getProperty();

            CalculatedValue calculatedValue = cacheEntry.get(property);

            // If there is no calculatedValue and we're on the fast path,
            // take the slow path if cssFlags is REAPPLY (RT-31691)
            final boolean forceSlowpath =
                    fastpath &amp;&amp; calculatedValue == null &amp;&amp; isForceSlowpath;

            final boolean addToCache =
                    (!fastpath &amp;&amp; calculatedValue == null) || forceSlowpath;

            if (fastpath &amp;&amp; !forceSlowpath) {

                // If the cache contains SKIP, then there was an
                // exception thrown from applyStyle
                if (calculatedValue == SKIP) {
                    continue;
                }

            } else if (calculatedValue == null) {

                // slowpath!
                calculatedValue = lookup(node, cssMetaData, styleMap, transitionStates[0],
                        node, cachedFont);

                // lookup is not supposed to return null.
                if (calculatedValue == null) {
                    assert false : &quot;lookup returned null for &quot; + property;
                    continue;
                }

            }

            // StyleableProperty#applyStyle might throw an exception and it is called
            // from two places in this try block.
            try {

                //
                // RT-19089
                // If the current value of the property was set by CSS
                // and there is no style for the property, then reset this
                // property to its initial value. If it was not set by CSS
                // then leave the property alone.
                //
                if (calculatedValue == null || calculatedValue == SKIP) {

                    // cssSetProperties keeps track of the StyleableProperty's that were set by CSS in the previous state.
                    // If this property is not in cssSetProperties map, then the property was not set in the previous state.
                    // This accomplishes two things. First, it lets us know if the property was set in the previous state
                    // so it can be reset in this state if there is no value for it. Second, it calling
                    // CssMetaData#getStyleableProperty which is rather expensive as it may cause expansion of lazy
                    // properties.
                    CalculatedValue initialValue = cacheContainer.cssSetProperties.get(cssMetaData);

                    // if the current value was set by CSS and there
                    // is no calculated value for the property, then
                    // there was no style for the property in the current
                    // state, so reset the property to its initial value.
                    if (initialValue != null) {

                        StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
                        if (styleableProperty.getStyleOrigin() != StyleOrigin.USER) {
                            styleableProperty.applyStyle(initialValue.getOrigin(), initialValue.getValue());
                        }
                    }

                    continue;

                }

                if (addToCache) {

                    // If we're not on the fastpath, then add the calculated
                    // value to cache.
                    cacheEntry.put(property, calculatedValue);
                }

                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);

                // need to know who set the current value - CSS, the user, or init
                final StyleOrigin originOfCurrentValue = styleableProperty.getStyleOrigin();


                // RT-10522:
                // If the user set the property and there is a style and
                // the style came from the user agent stylesheet, then
                // skip the value. A style from a user agent stylesheet should
                // not override the user set style.
                //
                final StyleOrigin originOfCalculatedValue = calculatedValue.getOrigin();

                // A calculated value should never have a null style origin since that would
                // imply the style didn't come from a stylesheet or in-line style.
                if (originOfCalculatedValue == null) {
                    assert false : styleableProperty.toString();
                    continue;
                }

                if (originOfCurrentValue == StyleOrigin.USER) {
                    if (originOfCalculatedValue == StyleOrigin.USER_AGENT) {
                        continue;
                    }
                }

                final Object value = calculatedValue.getValue();
                final Object currentValue = styleableProperty.getValue();

                // RT-21185: Only apply the style if something has changed.
                if ((originOfCurrentValue != originOfCalculatedValue)
                        || (currentValue != null
                        ? currentValue.equals(value) == false
                        : value != null)) {

                    if (LOGGER.isLoggable(Level.FINER)) {
                        LOGGER.finer(property + &quot;, call applyStyle: &quot; + styleableProperty + &quot;, value =&quot; +
                                String.valueOf(value) + &quot;, originOfCalculatedValue=&quot; + originOfCalculatedValue);
                    }

                    styleableProperty.applyStyle(originOfCalculatedValue, value);

                    if (cacheContainer.cssSetProperties.containsKey(cssMetaData) == false) {
                        // track this property
                        CalculatedValue initialValue = new CalculatedValue(currentValue, originOfCurrentValue, false);
                        cacheContainer.cssSetProperties.put(cssMetaData, initialValue);
                    }

                }

            } catch (Exception e) {

                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);

                final String msg = String.format(&quot;Failed to set css [%s] on [%s] due to '%s'\n&quot;,
                        cssMetaData.getProperty(), styleableProperty, e.getMessage());

                List&lt;CssParser.ParseError&gt; errors = null;
                if ((errors = StyleManager.getErrors()) != null) {
                    final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, node, msg);
                    errors.add(error);
                }

                PlatformLogger logger = Logging.getCSSLogger();
                if (logger.isLoggable(Level.WARNING)) {
                    logger.warning(msg);
                }

                // RT-27155: if setting value raises exception, reset value
                // the value to initial and thereafter skip setting the property
                cacheEntry.put(property, SKIP);

                CalculatedValue cachedValue = null;
                if (cacheContainer != null &amp;&amp; cacheContainer.cssSetProperties != null) {
                    cachedValue = cacheContainer.cssSetProperties.get(cssMetaData);
                }
                Object value = (cachedValue != null) ? cachedValue.getValue() : cssMetaData.getInitialValue(node);
                StyleOrigin origin = (cachedValue != null) ? cachedValue.getOrigin() : null;
                try {
                    styleableProperty.applyStyle(origin, value);
                } catch (Exception ebad) {
                    // This would be bad.
                    if (logger.isLoggable(Level.SEVERE)) {
                        logger.severe(String.format(&quot;Could not reset [%s] on [%s] due to %s\n&quot; ,
                                cssMetaData.getProperty(), styleableProperty, e.getMessage()));
                    }
                }

            }

        }
    }

    /**
     * Gets the CSS CascadingStyle for the property of this node in these pseudo-class
     * states. A null style may be returned if there is no style information
     * for this combination of input parameters.
     *
     *
     * @param styleable
     * @param property
     * @param styleMap
     * @param states   @return
     * */
    private CascadingStyle getStyle(final Styleable styleable, final String property, final StyleMap styleMap, final Set&lt;PseudoClass&gt; states){

        if (styleMap == null || styleMap.isEmpty()) return null;

        final Map&lt;String, List&lt;CascadingStyle&gt;&gt; cascadingStyleMap = styleMap.getCascadingStyles();
        if (cascadingStyleMap == null || cascadingStyleMap.isEmpty()) return null;

        // Get all of the Styles which may apply to this particular property
        List&lt;CascadingStyle&gt; styles = cascadingStyleMap.get(property);

        // If there are no styles for this property then we can just bail
        if ((styles == null) || styles.isEmpty()) return null;

        // Go looking for the style. We do this by visiting each CascadingStyle in
        // order finding the first that matches the current node &amp; set of
        // pseudo-class states. We use an iteration style that avoids creating
        // garbage iterators (and wish javac did it for us...)
       CascadingStyle style = null;
        final int max = (styles == null) ? 0 : styles.size();
        for (int i=0; i&lt;max; i++) {
            final CascadingStyle s = styles.get(i);
            final Selector sel = s == null ? null : s.getSelector();
            if (sel == null) continue; // bail if the selector is null.
//System.out.println(node.toString() + &quot;\n\tstates=&quot; + PseudoClassSet.getPseudoClasses(states) + &quot;\n\tstateMatches? &quot; + sel.stateMatches(node, states) + &quot;\n\tsel=&quot; + sel.toString());
            if (sel.stateMatches(styleable, states)) {
                style = s;
                break;
            }
        }

        return style;
    }

    /**
     * The main workhorse of this class, the lookup method walks up the CSS
     * style tree looking for the style information for the Node, the
     * property associated with the given styleable, in these states for this font.
     *
     *
     *
     *
     * @param styleable
     * @param states
     * @param originatingStyleable
     * @return
     */
    private CalculatedValue lookup(final Styleable styleable,
                                   final CssMetaData cssMetaData,
                                   final StyleMap styleMap,
                                   final Set&lt;PseudoClass&gt; states,
                                   final Styleable originatingStyleable,
                                   final CalculatedValue cachedFont) {

        if (cssMetaData.getConverter() == FontConverter.getInstance()) {
            return lookupFont(styleable, cssMetaData.getProperty(), styleMap, cachedFont);
        }

        final String property = cssMetaData.getProperty();

        // Get the CascadingStyle which may apply to this particular property
        CascadingStyle style = getStyle(styleable, property, styleMap, states);

        // If no style was found and there are no sub styleables, then there
        // are no matching styles for this property. We will then either SKIP
        // or we will INHERIT. We will inspect the default value for the styleable,
        // and if it is INHERIT then we will inherit otherwise we just skip it.
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; subProperties = cssMetaData.getSubProperties();
        final int numSubProperties = (subProperties != null) ? subProperties.size() : 0;
        if (style == null) {

            if (numSubProperties == 0) {

                return handleNoStyleFound(styleable, cssMetaData,
                        styleMap, states, originatingStyleable, cachedFont);

            } else {

                // If style is null then it means we didn't successfully find the
                // property we were looking for. However, there might be sub styleables,
                // in which case we should perform a lookup for them. For example,
                // there might not be a style for &quot;font&quot;, but there might be one
                // for &quot;font-size&quot; or &quot;font-weight&quot;. So if the style is null, then
                // we need to check with the sub-styleables.

                // Build up a list of all SubProperties which have a constituent part.
                // I default the array to be the size of the number of total
                // sub styleables to avoid having the array grow.
                Map&lt;CssMetaData,Object&gt; subs = null;
                StyleOrigin origin = null;

                boolean isRelative = false;

                for (int i=0; i&lt;numSubProperties; i++) {
                    CssMetaData subkey = subProperties.get(i);
                    CalculatedValue constituent =
                        lookup(styleable, subkey, styleMap, states,
                                originatingStyleable, cachedFont);
                    if (constituent != SKIP) {
                        if (subs == null) {
                            subs = new HashMap&lt;&gt;();
                        }
                        subs.put(subkey, constituent.getValue());

                        // origin of this style is the most specific
                        if ((origin != null &amp;&amp; constituent.getOrigin() != null)
                                ? origin.compareTo(constituent.getOrigin()) &lt; 0
                                : constituent.getOrigin() != null) {
                            origin = constituent.getOrigin();
                        }

                        // if the constiuent uses relative sizes, then
                        // isRelative is true;
                        isRelative = isRelative || constituent.isRelative();

                    }
                }

                // If there are no subkeys which apply...
                if (subs == null || subs.isEmpty()) {
                    return handleNoStyleFound(styleable, cssMetaData,
                            styleMap, states, originatingStyleable, cachedFont);
                }

                try {
                    final StyleConverter keyType = cssMetaData.getConverter();
                    Object ret = keyType.convert(subs);
                    return new CalculatedValue(ret, origin, isRelative);
                } catch (ClassCastException cce) {
                    final String msg = formatExceptionMessage(styleable, cssMetaData, null, cce);
                    List&lt;CssParser.ParseError&gt; errors = null;
                    if ((errors = StyleManager.getErrors()) != null) {
                        final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
                        errors.add(error);
                    }
                    if (LOGGER.isLoggable(Level.WARNING)) {
                        LOGGER.warning(msg);
                        LOGGER.fine(&quot;caught: &quot;, cce);
                        LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
                        LOGGER.fine(&quot;node = &quot; + styleable.toString());
                    }
                    return SKIP;
                }
            }

        } else { // style != null

            // RT-10522:
            // If the user set the property and there is a style and
            // the style came from the user agent stylesheet, then
            // skip the value. A style from a user agent stylesheet should
            // not override the user set style.
            if (style.getOrigin() == StyleOrigin.USER_AGENT) {

                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(originatingStyleable);
                // if styleableProperty is null, then we're dealing with a sub-property.
                if (styleableProperty != null &amp;&amp; styleableProperty.getStyleOrigin() == StyleOrigin.USER) {
                    return SKIP;
                }
            }

            // If there was a style found, then we want to check whether the
            // value was &quot;inherit&quot;. If so, then we will simply inherit.
            final ParsedValue cssValue = style.getParsedValue();
            if (cssValue != null &amp;&amp; &quot;inherit&quot;.equals(cssValue.getValue())) {
                style = getInheritedStyle(styleable, property);
                if (style == null) return SKIP;
            }
        }

//        System.out.println(&quot;lookup &quot; + property +
//                &quot;, selector = \'&quot; + style.selector.toString() + &quot;\'&quot; +
//                &quot;, node = &quot; + node.toString());

        return calculateValue(style, styleable, cssMetaData, styleMap, states,
                originatingStyleable, cachedFont);
    }

    /**
     * Called when there is no style found.
     */
    private CalculatedValue handleNoStyleFound(final Styleable styleable,
                                               final CssMetaData cssMetaData,
                                               final StyleMap styleMap, Set&lt;PseudoClass&gt; pseudoClassStates, Styleable originatingStyleable,
                                               final CalculatedValue cachedFont) {

        if (cssMetaData.isInherits()) {


            StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(styleable);
            StyleOrigin origin = styleableProperty != null ? styleableProperty.getStyleOrigin() : null;

            // RT-16308: if there is no matching style and the user set
            // the property, do not look for inherited styles.
            if (origin == StyleOrigin.USER) {

                    return SKIP;

            }

            CascadingStyle style = getInheritedStyle(styleable, cssMetaData.getProperty());
            if (style == null) return SKIP;

            CalculatedValue cv =
                    calculateValue(style, styleable, cssMetaData,
                            styleMap, pseudoClassStates, originatingStyleable,
                                   cachedFont);

            return cv;

        } else {

            // Not inherited. There is no style
            return SKIP;

        }
    }
    /**
     * Called when we must getInheritedStyle a value from a parent node in the scenegraph.
     */
    private CascadingStyle getInheritedStyle(
            final Styleable styleable,
            final String property) {

        Styleable parent = ((Node)styleable).styleHelper.firstStyleableAncestor;
        CssStyleHelper parentStyleHelper = getStyleHelper((Node) parent);

        if (parent != null &amp;&amp; parentStyleHelper != null) {

            StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);
            Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
            CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);

            if (cascadingStyle != null) {

                final ParsedValue cssValue = cascadingStyle.getParsedValue();

                if (&quot;inherit&quot;.equals(cssValue.getValue())) {
                    return getInheritedStyle(parent, property);
                }
                return cascadingStyle;
            }
        }

        return null;
    }


    // helps with self-documenting the code
    private static final Set&lt;PseudoClass&gt; NULL_PSEUDO_CLASS_STATE = null;

    /**
     * Find the property among the styles that pertain to the Node
     */
    private CascadingStyle resolveRef(final Styleable styleable, final String property, final StyleMap styleMap, final Set&lt;PseudoClass&gt; states) {

        final CascadingStyle style = getStyle(styleable, property, styleMap, states);
        if (style != null) {
            return style;
        } else {
            // if style is null, it may be because there isn't a style for this
            // node in this state, or we may need to look up the parent chain
            if (states != null &amp;&amp; states.size() &gt; 0) {
                // if states &gt; 0, then we need to check this node again,
                // but without any states.
                return resolveRef(styleable,property, styleMap, NULL_PSEUDO_CLASS_STATE);
            } else {
                // TODO: This block was copied from inherit. Both should use same code somehow.

                Styleable styleableParent = ((Node)styleable).styleHelper.firstStyleableAncestor;
                CssStyleHelper parentStyleHelper = getStyleHelper((Node) styleableParent);

                if (styleableParent == null || parentStyleHelper == null) {
                    return null;
                }

                StyleMap parentStyleMap = parentStyleHelper.getStyleMap(styleableParent);
                Set&lt;PseudoClass&gt; styleableParentPseudoClassStates =
                    styleableParent instanceof Node
                        ? ((Node)styleableParent).pseudoClassStates
                        : styleable.getPseudoClassStates();

                return parentStyleHelper.resolveRef(styleableParent, property,
                        parentStyleMap, styleableParentPseudoClassStates);
            }
        }
    }

    // to resolve a lookup, we just need to find the parsed value.
    private ParsedValue resolveLookups(
            final Styleable styleable,
            final ParsedValue parsedValue,
            final StyleMap styleMap, Set&lt;PseudoClass&gt; states,
            final ObjectProperty&lt;StyleOrigin&gt; whence,
            Set&lt;ParsedValue&gt; resolves) {

        //
        // either the value itself is a lookup, or the value contain a lookup
        //
        if (parsedValue.isLookup()) {

            // The value we're looking for should be a Paint, one of the
            // containers for linear, radial or ladder, or a derived color.
            final Object val = parsedValue.getValue();
            if (val instanceof String) {

                final String sval = ((String) val).toLowerCase(Locale.ROOT);

                CascadingStyle resolved =
                    resolveRef(styleable, sval, styleMap, states);

                if (resolved != null) {

                    if (resolves.contains(resolved.getParsedValue())) {

                        if (LOGGER.isLoggable(Level.WARNING)) {
                            LOGGER.warning(&quot;Loop detected in &quot; + resolved.getRule().toString() + &quot; while resolving '&quot; + sval + &quot;'&quot;);
                        }
                        throw new IllegalArgumentException(&quot;Loop detected in &quot; + resolved.getRule().toString() + &quot; while resolving '&quot; + sval + &quot;'&quot;);

                    } else {
                        resolves.add(parsedValue);
                    }

                    // The origin of this parsed value is the greatest of
                    // any of the resolved reference. If a resolved reference
                    // comes from an inline style, for example, then the value
                    // calculated from the resolved lookup should have inline
                    // as its origin. Otherwise, an inline style could be
                    // stored in shared cache.
                    final StyleOrigin wOrigin = whence.get();
                    final StyleOrigin rOrigin = resolved.getOrigin();
                    if (rOrigin != null &amp;&amp; (wOrigin == null ||  wOrigin.compareTo(rOrigin) &lt; 0)) {
                        whence.set(rOrigin);
                    }

                    // the resolved value may itself need to be resolved.
                    // For example, if the value &quot;color&quot; resolves to &quot;base&quot;,
                    // then &quot;base&quot; will need to be resolved as well.
                    ParsedValue pv = resolveLookups(styleable, resolved.getParsedValue(), styleMap, states, whence, resolves);

                    if (resolves != null) {
                        resolves.remove(parsedValue);
                    }

                    return pv;

                }
            }
        }

        // If the value doesn't contain any values that need lookup, then bail
        if (!parsedValue.isContainsLookups()) {
            return parsedValue;
        }

        final Object val = parsedValue.getValue();

        if (val instanceof ParsedValue[][]) {

            // If ParsedValue is a layered sequence of values, resolve the lookups for each.
            final ParsedValue[][] layers = (ParsedValue[][])val;
            ParsedValue[][] resolved = new ParsedValue[layers.length][0];
            for (int l=0; l&lt;layers.length; l++) {
                resolved[l] = new ParsedValue[layers[l].length];
                for (int ll=0; ll&lt;layers[l].length; ll++) {
                    if (layers[l][ll] == null) continue;
                    resolved[l][ll] =
                        resolveLookups(styleable, layers[l][ll], styleMap, states, whence, resolves);
                }
            }

            resolves.clear();

            return new ParsedValueImpl(resolved, parsedValue.getConverter(), false);

        } else if (val instanceof ParsedValueImpl[]) {

            // If ParsedValue is a sequence of values, resolve the lookups for each.
            final ParsedValue[] layer = (ParsedValue[])val;
            ParsedValue[] resolved = new ParsedValue[layer.length];
            for (int l=0; l&lt;layer.length; l++) {
                if (layer[l] == null) continue;
                resolved[l] =
                    resolveLookups(styleable, layer[l], styleMap, states, whence, resolves);
            }

            resolves.clear();

            return new ParsedValueImpl(resolved, parsedValue.getConverter(), false);

        }

        return parsedValue;

    }

    private String getUnresolvedLookup(final ParsedValue resolved) {

        Object value = resolved.getValue();

        if (resolved.isLookup() &amp;&amp; value instanceof String) {
            return (String)value;
        }

        if (value instanceof ParsedValue[][]) {
            final ParsedValue[][] layers = (ParsedValue[][])value;
            for (int l=0; l&lt;layers.length; l++) {
                for (int ll=0; ll&lt;layers[l].length; ll++) {
                    if (layers[l][ll] == null) continue;
                    String unresolvedLookup = getUnresolvedLookup(layers[l][ll]);
                    if (unresolvedLookup != null) return unresolvedLookup;
                }
            }

        } else if (value instanceof ParsedValue[]) {
        // If ParsedValue is a sequence of values, resolve the lookups for each.
            final ParsedValue[] layer = (ParsedValue[])value;
            for (int l=0; l&lt;layer.length; l++) {
                if (layer[l] == null) continue;
                String unresolvedLookup = getUnresolvedLookup(layer[l]);
                if (unresolvedLookup != null) return unresolvedLookup;
            }
        }

        return null;
    }

    private String formatUnresolvedLookupMessage(Styleable styleable, CssMetaData cssMetaData, Style style, ParsedValue resolved, ClassCastException cce) {

        // Find value that could not be looked up. If the resolved value does not contain lookups, then the
        // ClassCastException is not because of trying to convert a String (which is the missing lookup)
        // to some value, but is because the convert method got some wrong value - like a paint when it should be a color.
        // See RT-33319 for an example of this.
        String missingLookup = resolved != null &amp;&amp; resolved.isContainsLookups() ? getUnresolvedLookup(resolved) : null;

        StringBuilder sbuf = new StringBuilder();
        if (missingLookup != null) {
            sbuf.append(&quot;Could not resolve '&quot;)
                    .append(missingLookup)
                    .append(&quot;'&quot;)
                    .append(&quot; while resolving lookups for '&quot;)
                    .append(cssMetaData.getProperty())
                    .append(&quot;'&quot;);
        } else {
            sbuf.append(&quot;Caught '&quot;)
                    .append(cce)
                    .append(&quot;'&quot;)
                    .append(&quot; while converting value for '&quot;)
                    .append(cssMetaData.getProperty())
                    .append(&quot;'&quot;);
        }

        final Rule rule = style != null ? style.getDeclaration().getRule(): null;
        final Stylesheet stylesheet = rule != null ? rule.getStylesheet() : null;
        final String url = stylesheet != null ? stylesheet.getUrl() : null;
        if (url != null) {
            sbuf.append(&quot; from rule '&quot;)
                .append(style.getSelector())
                .append(&quot;' in stylesheet &quot;).append(url);
        } else if (stylesheet != null &amp;&amp; StyleOrigin.INLINE == stylesheet.getOrigin()) {
            sbuf.append(&quot; from inline style on &quot; )
                .append(styleable.toString());
        }

        return sbuf.toString();
    }

    private String formatExceptionMessage(Styleable styleable, CssMetaData cssMetaData, Style style, Exception e) {

        StringBuilder sbuf = new StringBuilder();
        sbuf.append(&quot;Caught &quot;)
            .append(String.valueOf(e));

        if (cssMetaData != null) {
            sbuf.append(&quot;'&quot;)
                .append(&quot; while calculating value for '&quot;)
                .append(cssMetaData.getProperty())
                .append(&quot;'&quot;);
        }

        if (style != null) {

            final Rule rule = style.getDeclaration().getRule();
            final Stylesheet stylesheet = rule != null ? rule.getStylesheet() : null;
            final String url = stylesheet != null ? stylesheet.getUrl() : null;

            if (url != null) {
                sbuf.append(&quot; from rule '&quot;)
                        .append(style.getSelector())
                        .append(&quot;' in stylesheet &quot;).append(url);
            } else if (styleable != null &amp;&amp; stylesheet != null &amp;&amp; StyleOrigin.INLINE == stylesheet.getOrigin()) {
                sbuf.append(&quot; from inline style on &quot; )
                        .append(styleable.toString());
            } else {
                sbuf.append(&quot; from style '&quot;)
                    .append(String.valueOf(style))
                    .append(&quot;'&quot;);
            }
        }

        return sbuf.toString();
    }


    private CalculatedValue calculateValue(
            final CascadingStyle style,
            final Styleable styleable,
            final CssMetaData cssMetaData,
            final StyleMap styleMap, final Set&lt;PseudoClass&gt; states,
            final Styleable originatingStyleable,
            final CalculatedValue fontFromCacheEntry) {

        final ParsedValue cssValue = style.getParsedValue();
        if (cssValue != null &amp;&amp; !(&quot;null&quot;.equals(cssValue.getValue()) || &quot;none&quot;.equals(cssValue.getValue()))) {

            ParsedValue resolved = null;
            try {

                ObjectProperty&lt;StyleOrigin&gt; whence = new SimpleObjectProperty&lt;&gt;(style.getOrigin());
                resolved = resolveLookups(styleable, cssValue, styleMap, states, whence, new HashSet&lt;&gt;());

                final String property = cssMetaData.getProperty();

                // The computed value
                Object val = null;
                boolean isFontProperty =
                        &quot;-fx-font&quot;.equals(property) ||
                        &quot;-fx-font-size&quot;.equals(property);

                boolean isRelative = ParsedValueImpl.containsFontRelativeSize(resolved, isFontProperty);

                //
                // Avoid using a font calculated from a relative size
                // to calculate a font with a relative size.
                // For example:
                // Assume the default font size is 13 and we have a style with
                // -fx-font-size: 1.5em, then the cacheEntry font value will
                // have a size of 13*1.5=19.5.
                // Now, when converting that same font size again in response
                // to looking up a value for -fx-font, we do not want to use
                // 19.5 as the font for relative size conversion since this will
                // yield a font 19.5*1.5=29.25 when really what we want is
                // a font size of 19.5.
                // In this situation, then, we use the font from the parent's
                // cache entry.
                Font fontForFontRelativeSizes = null;

                if (isRelative &amp;&amp; isFontProperty &amp;&amp;
                    (fontFromCacheEntry == null || fontFromCacheEntry.isRelative())) {

                    Styleable parent = styleable;
                    CalculatedValue childsCachedFont = fontFromCacheEntry;
                    do {

                        CalculatedValue parentsCachedFont = getCachedFont(parent.getStyleableParent());

                        if (parentsCachedFont != null)  {

                            if (parentsCachedFont.isRelative()) {

                                //
                                // If the cached fonts are the same, then the cached font came from the same
                                // style and we need to keep looking. Otherwise, use the font we found.
                                //
                                if (childsCachedFont == null || parentsCachedFont.equals(childsCachedFont)) {
                                    childsCachedFont = parentsCachedFont;
                                } else {
                                    fontForFontRelativeSizes = (Font)parentsCachedFont.getValue();
                                }

                            } else  {
                                // fontValue.isRelative() == false!
                                fontForFontRelativeSizes = (Font)parentsCachedFont.getValue();
                            }

                        }

                    } while(fontForFontRelativeSizes == null &amp;&amp;
                            (parent = parent.getStyleableParent()) != null);
                }

                // did we get a fontValue from the preceding block?
                // if not, get it from our cacheEntry or choose the default
                if (fontForFontRelativeSizes == null) {
                    if (fontFromCacheEntry != null &amp;&amp; fontFromCacheEntry.isRelative() == false) {
                        fontForFontRelativeSizes = (Font)fontFromCacheEntry.getValue();
                    } else {
                        fontForFontRelativeSizes = Font.getDefault();
                    }
                }

                final StyleConverter cssMetaDataConverter = cssMetaData.getConverter();
                // RT-37727 - handling of properties that are insets is wonky. If the property is -fx-inset, then
                // there isn't an issue because the converter assigns the InsetsConverter to the ParsedValue.
                // But -my-insets will parse as an array of numbers and the parser will assign the Size sequence
                // converter to it. So, if the CssMetaData says it uses InsetsConverter, use the InsetsConverter
                // and not the parser assigned converter.
                if (cssMetaDataConverter == StyleConverter.getInsetsConverter()) {
                    if (resolved.getValue() instanceof ParsedValue) {
                        // If you give the parser &quot;-my-insets: 5;&quot; you end up with a ParsedValue&lt;ParsedValue&lt;?,Size&gt;, Number&gt;
                        // and not a ParsedValue&lt;ParsedValue[], Number[]&gt; so here we wrap the value into an array
                        // to make the InsetsConverter happy.
                        resolved = new ParsedValueImpl(new ParsedValue[] {(ParsedValue)resolved.getValue()}, null, false);
                    }
                    val = cssMetaDataConverter.convert(resolved, fontForFontRelativeSizes);
                }
                else if (resolved.getConverter() != null)
                    val = resolved.convert(fontForFontRelativeSizes);
                else
                    val = cssMetaData.getConverter().convert(resolved, fontForFontRelativeSizes);

                final StyleOrigin origin = whence.get();
                return new CalculatedValue(val, origin, isRelative);

            } catch (ClassCastException cce) {
                final String msg = formatUnresolvedLookupMessage(styleable, cssMetaData, style.getStyle(),resolved, cce);
                List&lt;CssParser.ParseError&gt; errors = null;
                if ((errors = StyleManager.getErrors()) != null) {
                    final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
                    errors.add(error);
                }
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(msg);
                    LOGGER.fine(&quot;node = &quot; + styleable.toString());
                    LOGGER.fine(&quot;cssMetaData = &quot; + cssMetaData);
                    LOGGER.fine(&quot;styles = &quot; + getMatchingStyles(styleable, cssMetaData));
                }
                return SKIP;
            } catch (IllegalArgumentException iae) {
                final String msg = formatExceptionMessage(styleable, cssMetaData, style.getStyle(), iae);
                List&lt;CssParser.ParseError&gt; errors = null;
                if ((errors = StyleManager.getErrors()) != null) {
                    final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
                    errors.add(error);
                }
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(msg);
                    LOGGER.fine(&quot;caught: &quot;, iae);
                    LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
                    LOGGER.fine(&quot;node = &quot; + styleable.toString());
                }
                return SKIP;
            } catch (NullPointerException npe) {
                final String msg = formatExceptionMessage(styleable, cssMetaData, style.getStyle(), npe);
                List&lt;CssParser.ParseError&gt; errors = null;
                if ((errors = StyleManager.getErrors()) != null) {
                    final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
                    errors.add(error);
                }
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(msg);
                    LOGGER.fine(&quot;caught: &quot;, npe);
                    LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
                    LOGGER.fine(&quot;node = &quot; + styleable.toString());
                }
                return SKIP;
            }

        }
        // either cssValue was null or cssValue's value was &quot;null&quot; or &quot;none&quot;
        return new CalculatedValue(null, style.getOrigin(), false);

    }

    private static final CssMetaData dummyFontProperty =
            new FontCssMetaData&lt;Node&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

        @Override
        public boolean isSettable(Node node) {
            return true;
        }

        @Override
        public StyleableProperty&lt;Font&gt; getStyleableProperty(Node node) {
            return null;
        }
    };

    private CalculatedValue getCachedFont(final Styleable styleable) {

        if (styleable instanceof Node == false) return null;

        CalculatedValue cachedFont = null;

        Node parent = (Node)styleable;

        final CssStyleHelper parentHelper = parent.styleHelper;

        // if there is no parentHelper,
        // or there is a parentHelper but no cacheContainer,
        // then look to the next parent
        if (parentHelper == null || parentHelper.cacheContainer == null) {

            cachedFont = getCachedFont(parent.getStyleableParent());

        // there is a parent helper and a cacheContainer,
        } else  {

            CacheContainer parentCacheContainer = parentHelper.cacheContainer;
            if ( parentCacheContainer != null
                    &amp;&amp; parentCacheContainer.fontSizeCache != null
                    &amp;&amp; parentCacheContainer.fontSizeCache.isEmpty() == false) {

                Set&lt;PseudoClass&gt;[] transitionStates = parentHelper.getTransitionStates(parent);
                StyleCacheEntry.Key parentCacheEntryKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());
                cachedFont = parentCacheContainer.fontSizeCache.get(parentCacheEntryKey);
            }

            if (cachedFont == null)  {
                StyleMap smap = parentHelper.getStyleMap(parent);
                cachedFont = parentHelper.lookupFont(parent, &quot;-fx-font&quot;, smap, null);
            }
        }

        return cachedFont != SKIP ? cachedFont : null;
    }

    /*package access for testing*/ FontPosture getFontPosture(Font font) {
        if (font == null) return FontPosture.REGULAR;

        String fontName = font.getName().toLowerCase(Locale.ROOT);

        if (fontName.contains(&quot;italic&quot;)) {
            return FontPosture.ITALIC;
        }

        return FontPosture.REGULAR;
    }

    /*package access for testing*/ FontWeight getFontWeight(Font font) {
        if (font == null) return FontWeight.NORMAL;

        String fontName = font.getName().toLowerCase(Locale.ROOT);

        if (fontName.contains(&quot;bold&quot;)) {
            if (fontName.contains(&quot;extra&quot;)) return FontWeight.EXTRA_BOLD;
            if (fontName.contains(&quot;ultra&quot;)) return FontWeight.EXTRA_BOLD;
            else if (fontName.contains(&quot;semi&quot;)) return FontWeight.SEMI_BOLD;
            else if (fontName.contains(&quot;demi&quot;)) return FontWeight.SEMI_BOLD;
            else return FontWeight.BOLD;

        } else if (fontName.contains(&quot;light&quot;)) {
            if (fontName.contains(&quot;extra&quot;)) return FontWeight.EXTRA_LIGHT;
            if (fontName.contains(&quot;ultra&quot;)) return FontWeight.EXTRA_LIGHT;
            else return FontWeight.LIGHT;

        } else if (fontName.contains(&quot;black&quot;)) {
            return FontWeight.BLACK;

        } else if (fontName.contains(&quot;heavy&quot;)) {
            return FontWeight.BLACK;

        } else if (fontName.contains(&quot;medium&quot;)) {
            return FontWeight.MEDIUM;
        }

        return FontWeight.NORMAL;

    }

    /*package access for testing*/ String getFontFamily(Font font) {
        if (font == null) return Font.getDefault().getFamily();
        return font.getFamily();
    }


    /*package access for testing*/ Font deriveFont(
            Font font,
            String fontFamily,
            FontWeight fontWeight,
            FontPosture fontPosture,
            double fontSize) {

        if (font != null &amp;&amp; fontFamily == null) fontFamily = getFontFamily(font);
        else if (fontFamily != null) fontFamily = Utils.stripQuotes(fontFamily);

        if (font != null &amp;&amp; fontWeight == null) fontWeight = getFontWeight(font);
        if (font != null &amp;&amp; fontPosture == null) fontPosture = getFontPosture(font);
        if (font != null &amp;&amp; fontSize &lt;= 0) fontSize = font.getSize();

        return  Font.font(
                fontFamily,
                fontWeight,
                fontPosture,
                fontSize);
    }

    /**
     * Look up a font property. This is handled separately from lookup since
     * font is inherited and has sub-properties. One should expect that the
     * text font for the following would be 16px Arial. The lookup method would
     * give 16px system since it would look &lt;em&gt;only&lt;/em&gt; for font-size,
     * font-family, etc &lt;em&gt;only&lt;/em&gt; if the lookup on font failed.
     * &lt;pre&gt;
     * Text text = new Text(&quot;Hello World&quot;);
     * text.setStyle(&quot;-fx-font-size: 16px;&quot;);
     * Group group = new Group();
     * group.setStyle(&quot;-fx-font: 12px Arial;&quot;);
     * group.getChildren().add(text);
     * &lt;/pre&gt;
     */
     /*package access for testing*/ CalculatedValue lookupFont(
            final Styleable styleable,
            final String property,
            final StyleMap styleMap,
            final CalculatedValue cachedFont)
    {

        StyleOrigin origin = null;

        // How far from this node did we travel to find a font shorthand?
        // Don't look past this distance for other font properties.
        int distance = 0;

        // Did we find a style?
        boolean foundStyle = false;

        String family = null;
        double size = -1;
        FontWeight weight = null;
        FontPosture posture = null;

        CalculatedValue cvFont = cachedFont;


        Set&lt;PseudoClass&gt; states = styleable instanceof Node ? ((Node)styleable).pseudoClassStates : styleable.getPseudoClassStates();

        // RT-20145 - if looking for font size and the node has a font,
        // use the font property's value if it was set by the user and
        // there is not an inline or author style.

        if (cacheContainer.fontProp != null) {
            StyleableProperty&lt;Font&gt; styleableProp = cacheContainer.fontProp.getStyleableProperty(styleable);
            StyleOrigin fpOrigin = styleableProp.getStyleOrigin();
            Font font = styleableProp.getValue();
            if (font == null) font = Font.getDefault();
            if (fpOrigin == StyleOrigin.USER) {
                origin = fpOrigin;
                family = getFontFamily(font);
                size = font.getSize();
                weight = getFontWeight(font);
                posture = getFontPosture(font);
                cvFont = new CalculatedValue(font, fpOrigin, false);
            }
        }

        CalculatedValue parentCachedFont = getCachedFont(styleable.getStyleableParent());
        if (parentCachedFont == null) parentCachedFont = new CalculatedValue(Font.getDefault(), null, false);

        //
        // Look up the font- properties
        //
        CascadingStyle fontShorthand = getStyle(styleable, property, styleMap, states);

        // don't look past current node for font shorthand if user set the font
        if (fontShorthand == null &amp;&amp; origin != StyleOrigin.USER) {

            Styleable parent = styleable != null ? styleable.getStyleableParent() : null;

            while (parent != null) { // This loop traverses through all ancestors till root

                CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;
                if (parentStyleHelper != null) {

                    distance += 1;

                    StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);
                    Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
                    CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);

                    if (cascadingStyle != null) {

                        final ParsedValue cssValue = cascadingStyle.getParsedValue();

                        if (&quot;inherit&quot;.equals(cssValue.getValue()) == false) {
                            fontShorthand = cascadingStyle;
                            break;
                        }
                    }

                }

                parent = parent.getStyleableParent();

            }

        }

        if (fontShorthand != null) {

            //
            // If we don't have an existing font, or if the origin of the
            // existing font is less than that of the shorthand, then
            // take the shorthand. If the origins compare equals, then take
            // the shorthand since the fontProp value will not have been
            // updated yet.
            //
            if (origin == null || origin.compareTo(fontShorthand.getOrigin()) &lt;= 0) {

                final CalculatedValue cv =
                        calculateValue(fontShorthand, styleable, dummyFontProperty,
                                styleMap, states, styleable, parentCachedFont);

                // cv could be SKIP
                if (cv.getValue() instanceof Font) {
                    origin = cv.getOrigin();
                    Font font = (Font)cv.getValue();
                    family = getFontFamily(font);
                    size = font.getSize();
                    weight = getFontWeight(font);
                    posture = getFontPosture(font);
                    cvFont = cv;
                    foundStyle = true;
                }

            }
        }

        CascadingStyle fontSize = getStyle(styleable, property.concat(&quot;-size&quot;), styleMap, states);
        if (fontSize != null) {
            // if we have a font shorthand and it is more specific than font-size, then don't use the font-size style
            if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontSize) &lt; 0) {
                fontSize = null;
            } else if (origin == StyleOrigin.USER) {
                // If fontSize is an inline or author-stylesheet style, use it.
                // Otherwise, fontSize is a user-agent stylesheet style and should not override the USER style.
                if (StyleOrigin.USER.compareTo(fontSize.getOrigin()) &gt; 0) {
                    fontSize = null;
                }
            }
        } else if (origin != StyleOrigin.USER) {
            //
            // If we don't have a font-size, see if there is an inherited font-size.
            // If lookupInheritedFontProperty returns other than null, then we know that font-size is closer (more specific)
            // than the font shorthand
            //
            fontSize = lookupInheritedFontProperty(styleable, property.concat(&quot;-size&quot;), styleMap, distance, fontShorthand);
        }

        if (fontSize != null) {

            // The logic above ensures that, if fontSize is not null, then it is either
            // 1) a style matching this node and is more specific than the font shorthand or
            // 2) an inherited style that is more specific than the font shorthand
            // and, therefore, we can use the fontSize style

            final CalculatedValue cv =
                    calculateValue(fontSize, styleable, dummyFontProperty,
                            styleMap, states, styleable, parentCachedFont);

            if (cv.getValue() instanceof Double) {
                if (origin == null || origin.compareTo(fontSize.getOrigin()) &lt;= 0) {

                    origin = cv.getOrigin();
                }
                size = (Double) cv.getValue();

                if (cvFont != null) {
                    boolean isRelative = cvFont.isRelative() || cv.isRelative();
                    Font font = deriveFont((Font) cvFont.getValue(), family, weight, posture, size);
                    cvFont = new CalculatedValue(font, origin, isRelative);
                } else {
                    boolean isRelative = cv.isRelative();
                    Font font = deriveFont(Font.getDefault(), family, weight, posture, size);
                    cvFont = new CalculatedValue(font, origin, isRelative);
                }
                foundStyle = true;
            }

        }

        // if cachedFont is null, then we're in this method to look up a font for the CacheContainer's fontSizeCache
        // and we only care about font-size or the size from font shorthand.
        if (cachedFont == null) {
            return (cvFont != null) ? cvFont : SKIP;
        }

        CascadingStyle fontWeight = getStyle(styleable, property.concat(&quot;-weight&quot;), styleMap, states);
        if (fontWeight != null) {
            // if we have a font shorthand and it is more specific than font-weight, then don't use the font-weight style
            if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontWeight) &lt; 0) {
                fontWeight = null;
            }

        } else if (origin != StyleOrigin.USER) {
            //
            // If we don't have a font-weight, see if there is an inherited font-weight.
            // If lookupInheritedFontProperty returns other than null, then we know that font-weight is closer (more specific)
            // than the font shorthand
            //
            fontWeight = lookupInheritedFontProperty(styleable, property.concat(&quot;-weight&quot;), styleMap, distance, fontShorthand);
        }

        if (fontWeight != null) {

            // The logic above ensures that, if fontWeight is not null, then it is either
            // 1) a style matching this node and is more specific than the font shorthand or
            // 2) an inherited style that is more specific than the font shorthand
            // and, therefore, we can use the fontWeight style

            final CalculatedValue cv =
                    calculateValue(fontWeight, styleable, dummyFontProperty,
                            styleMap, states, styleable, null);

            if (cv.getValue() instanceof FontWeight) {
                if (origin == null || origin.compareTo(fontWeight.getOrigin()) &lt;= 0) {
                    origin = cv.getOrigin();
                }
                weight = (FontWeight)cv.getValue();
                foundStyle = true;
            }
        }


        CascadingStyle fontStyle = getStyle(styleable, property.concat(&quot;-style&quot;), styleMap, states);
        if (fontStyle != null) {
            // if we have a font shorthand and it is more specific than font-style, then don't use the font-style style
            if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontStyle) &lt; 0) {
                fontStyle = null;
            }

        } else if (origin != StyleOrigin.USER) {
            //
            // If we don't have a font-style, see if there is an inherited font-style.
            // If lookupInheritedFontProperty returns other than null, then we know that font-style is closer (more specific)
            // than the font shorthand
            //
            fontStyle = lookupInheritedFontProperty(styleable, property.concat(&quot;-style&quot;), styleMap, distance, fontShorthand);
        }

        if (fontStyle != null) {

            // The logic above ensures that, if fontStyle is not null, then it is either
            // 1) a style matching this node and is more specific than the font shorthand or
            // 2) an inherited style that is more specific than the font shorthand
            // and, therefore, we can use the fontStyle style

            final CalculatedValue cv =
                    calculateValue(fontStyle, styleable, dummyFontProperty,
                            styleMap, states, styleable, null);

            if (cv.getValue() instanceof FontPosture) {
                if (origin == null || origin.compareTo(fontStyle.getOrigin()) &lt;= 0) {
                    origin = cv.getOrigin();
                }
                posture = (FontPosture)cv.getValue();
                foundStyle = true;
            }

        }

        CascadingStyle fontFamily = getStyle(styleable, property.concat(&quot;-family&quot;), styleMap, states);
        if (fontFamily != null) {
            // if we have a font shorthand and it is more specific than font-family, then don't use the font-family style
            if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontFamily) &lt; 0) {
                fontFamily = null;
            }

        } else if (origin != StyleOrigin.USER) {
            //
            // If we don't have a font-family, see if there is an inherited font-family.
            // If lookupInheritedFontProperty returns other than null, then we know that font-family is closer (more specific)
            // than the font shorthand
            //
            fontFamily = lookupInheritedFontProperty(styleable, property.concat(&quot;-family&quot;), styleMap, distance, fontShorthand);
        }

        if (fontFamily != null) {

            // The logic above ensures that, if fontFamily is not null, then it is either
            // 1) a style matching this node and is more specific than the font shorthand or
            // 2) an inherited style that is more specific than the font shorthand
            // and, therefore, we can use the fontFamily style

            final CalculatedValue cv =
                    calculateValue(fontFamily, styleable, dummyFontProperty,
                            styleMap, states, styleable, null);

            if (cv.getValue() instanceof String) {
                if (origin == null || origin.compareTo(fontFamily.getOrigin()) &lt;= 0) {
                    origin = cv.getOrigin();
                }
                family = (String)cv.getValue();
                foundStyle = true;
            }

        }

        if (foundStyle) {

            Font font = cvFont != null ? (Font)cvFont.getValue() : Font.getDefault();
            Font derivedFont = deriveFont(font, family, weight, posture, size);
            return new CalculatedValue(derivedFont,origin,false);

        }

        return SKIP;
    }

    private CascadingStyle lookupInheritedFontProperty(
            final Styleable styleable,
            final String property,
            final StyleMap styleMap,
            final int distance,
            CascadingStyle fontShorthand) {

        Styleable parent = styleable != null ? styleable.getStyleableParent() : null;

        int nlooks = distance;
        while (parent != null &amp;&amp; nlooks &gt; 0) { // This loop traverses through all ancestors till root

            CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;
            if (parentStyleHelper != null) {

                nlooks -= 1;

                StyleMap parentStyleMap = parentStyleHelper.getStyleMap((parent));
                Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
                CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);

                if (cascadingStyle != null) {

                    // If we are closer to the node than the font shorthand, then font shorthand doesn't matter.
                    // If the font shorthand and this style are the same distance, then we need to compare.
                    if (fontShorthand != null &amp;&amp; nlooks == 0) {
                        if (fontShorthand.compareTo(cascadingStyle) &lt; 0) {
                            return null;
                        }
                    }

                    final ParsedValue cssValue = cascadingStyle.getParsedValue();

                    if (&quot;inherit&quot;.equals(cssValue.getValue()) == false) {
                        return cascadingStyle;
                    }
                }

            }

            parent = parent.getStyleableParent();

        }

        return null;
    }


    /**
     * Called from Node NodeHelper.getMatchingStyles
     * @param styleable
     * @param styleableProperty
     * @return
     */
    static List&lt;Style&gt; getMatchingStyles(final Styleable styleable, final CssMetaData styleableProperty) {

        if (!(styleable instanceof Node)) return Collections.&lt;Style&gt;emptyList();

        Node node = (Node)styleable;
        final CssStyleHelper helper = (node.styleHelper != null) ? node.styleHelper : createStyleHelper(node);

        if (helper != null) {
            return helper.getMatchingStyles(node, styleableProperty, false);
        }
        else {
            return Collections.&lt;Style&gt;emptyList();
        }
    }

    static Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getMatchingStyles(Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map, final Node node) {

        final CssStyleHelper helper = (node.styleHelper != null) ? node.styleHelper : createStyleHelper(node);
        if (helper != null) {
            if (map == null) map = new HashMap&lt;&gt;();
            for (CssMetaData metaData : node.getCssMetaData()) {
                List&lt;Style&gt; styleList = helper.getMatchingStyles(node, metaData, true);
                if (styleList != null &amp;&amp; !styleList.isEmpty()) {
                    StyleableProperty prop = metaData.getStyleableProperty(node);
                    map.put(prop, styleList);
                }
            }
        }

        if (node instanceof Parent) {
            for (Node child : ((Parent)node).getChildren()) {
                map = getMatchingStyles(map, child);
<A NAME="11"></A>            }
        }

        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#11',2,'match34-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return map;
    }

    private List&lt;Style&gt; getMatchingStyles(final Styleable node, final CssMetaData styleableProperty, boolean matchState) {

        final List&lt;CascadingStyle&gt; styleList = new</B></FONT> ArrayList&lt;&gt;();

        getMatchingStyles(node, styleableProperty, styleList, matchState);

        List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; subProperties = styleableProperty.getSubProperties();
        if (subProperties != null) {
            for (int n=0,nMax=subProperties.size(); n&lt;nMax; n++) {
                final CssMetaData subProperty = subProperties.get(n);
                getMatchingStyles(node, subProperty, styleList, matchState);
            }
        }

        Collections.sort(styleList);

        final List&lt;Style&gt; matchingStyles = new ArrayList&lt;&gt;(styleList.size());
        for (int n=0,nMax=styleList.size(); n&lt;nMax; n++) {
            final Style style = styleList.get(n).getStyle();
            if (!matchingStyles.contains(style)) matchingStyles.add(style);
        }

        return matchingStyles;
    }

    private void getMatchingStyles(final Styleable node, final CssMetaData styleableProperty, final List&lt;CascadingStyle&gt; styleList, boolean matchState) {

        if (node != null) {

            String property = styleableProperty.getProperty();
            Node _node = node instanceof Node ? (Node)node : null;
            final StyleMap smap = getStyleMap(_node);
            if (smap == null) return;

            if (matchState) {
                CascadingStyle cascadingStyle = getStyle(node, styleableProperty.getProperty(), smap, _node.pseudoClassStates);
                if (cascadingStyle != null) {
                    styleList.add(cascadingStyle);
                    final ParsedValue parsedValue = cascadingStyle.getParsedValue();
                    getMatchingLookupStyles(node, parsedValue, styleList, matchState);
                }
            }  else {

                Map&lt;String, List&lt;CascadingStyle&gt;&gt; cascadingStyleMap = smap.getCascadingStyles();
                // StyleMap.getCascadingStyles() does not return null
                List&lt;CascadingStyle&gt; styles = cascadingStyleMap.get(property);

                if (styles != null) {
                    styleList.addAll(styles);
                    for (int n=0, nMax=styles.size(); n&lt;nMax; n++) {
                        final CascadingStyle style = styles.get(n);
                        final ParsedValue parsedValue = style.getParsedValue();
                        getMatchingLookupStyles(node, parsedValue, styleList, matchState);
                    }
                }
            }

            if (styleableProperty.isInherits()) {
                Styleable parent = node.getStyleableParent();
                while (parent != null) { // This loop traverses through all ancestors till root
                    CssStyleHelper parentHelper = parent instanceof Node
                            ? ((Node)parent).styleHelper
                            : null;
                    if (parentHelper != null) {
                        parentHelper.getMatchingStyles(parent, styleableProperty, styleList, matchState);
                    }
                    parent = parent.getStyleableParent();
                }
            }

        }

    }

    // Pretty much a duplicate of resolveLookups, but without the state
    private void getMatchingLookupStyles(final Styleable node, final ParsedValue parsedValue, final List&lt;CascadingStyle&gt; styleList, boolean matchState) {

        if (parsedValue.isLookup()) {

            Object value = parsedValue.getValue();

            if (value instanceof String) {

                final String property = (String)value;
                // gather up any and all styles that contain this value as a property
                Styleable parent = node;
                do {

                    final Node _parent = parent instanceof Node ? (Node)parent : null;
                    final CssStyleHelper helper = _parent != null
                            ? _parent.styleHelper
                            : null;
                    if (helper != null) {

                        StyleMap styleMap = helper.getStyleMap(parent);
                        if (styleMap == null || styleMap.isEmpty()) continue;

                        final int start = styleList.size();

                        if (matchState) {
                            CascadingStyle cascadingStyle = helper.resolveRef(_parent, property, styleMap, _parent.pseudoClassStates);
                            if (cascadingStyle != null) {
                                styleList.add(cascadingStyle);
                            }
                        } else {
                            final Map&lt;String, List&lt;CascadingStyle&gt;&gt; smap = styleMap.getCascadingStyles();
                            // getCascadingStyles does not return null
                            List&lt;CascadingStyle&gt; styles = smap.get(property);

                            if (styles != null) {
                                styleList.addAll(styles);
                            }

                        }

                        final int end = styleList.size();

                        for (int index=start; index&lt;end; index++) {
                            final CascadingStyle style = styleList.get(index);
                            getMatchingLookupStyles(parent, style.getParsedValue(), styleList, matchState);
                        }
                    }

                } while ((parent = parent.getStyleableParent()) != null); // This loop traverses through all ancestors till root

            }
        }

        // If the value doesn't contain any values that need lookup, then bail
        if (!parsedValue.isContainsLookups()) {
            return;
        }

        final Object val = parsedValue.getValue();
        if (val instanceof ParsedValue[][]) {
        // If ParsedValue is a layered sequence of values, resolve the lookups for each.
            final ParsedValue[][] layers = (ParsedValue[][])val;
            for (int l=0; l&lt;layers.length; l++) {
                for (int ll=0; ll&lt;layers[l].length; ll++) {
                    if (layers[l][ll] == null) continue;
                        getMatchingLookupStyles(node, layers[l][ll], styleList, matchState);
                }
            }

        } else if (val instanceof ParsedValue[]) {
        // If ParsedValue is a sequence of values, resolve the lookups for each.
            final ParsedValue[] layer = (ParsedValue[])val;
            for (int l=0; l&lt;layer.length; l++) {
                if (layer[l] == null) continue;
                    getMatchingLookupStyles(node, layer[l], styleList, matchState);
            }
        }

    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Scene.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Accessible;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.Utils;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.event.EventQueue;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.SceneEventDispatcher;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
import com.sun.javafx.scene.input.InputEventUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.SceneTraversalEngine;
import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.tk.*;
import com.sun.prism.impl.PrismSettings;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.NamedArg;
import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.css.CssMetaData;
import javafx.css.StyleableObjectProperty;
import javafx.event.*;
import javafx.geometry.*;
import javafx.scene.image.WritableImage;
import javafx.scene.input.*;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.PopupWindow;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.util.Callback;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import com.sun.javafx.logging.PulseLogger;

import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.scene.input.ClipboardHelper;
import com.sun.javafx.scene.input.TouchPointHelper;
import java.lang.ref.WeakReference;

/**
 * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 * The background of the scene is filled as specified by the {@code fill} property.
 * &lt;p&gt;
 * The application must specify the root {@code Node} for the scene graph by setting
 * the {@code root} property.   If a {@code Group} is used as the root, the
 * contents of the scene graph will be clipped by the scene's width and height and
 * changes to the scene's size (if user resizes the stage) will not alter the
 * layout of the scene graph.    If a resizable node (layout {@code Region} or
 * {@code Control} is set as the root, then the root's size will track the
 * scene's size, causing the contents to be relayed out as necessary.
 * &lt;p&gt;
 * The scene's size may be initialized by the application during construction.
 * If no size is specified, the scene will automatically compute its initial
 * size based on the preferred size of its content. If only one dimension is specified,
 * the other dimension is computed using the specified dimension, respecting content bias
 * of a root.
 * &lt;p&gt;
 * An application may request depth buffer support or scene anti-aliasing
 * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 * without any 3D transforms does not need a depth buffer nor scene
 * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 * transforms may use depth buffer support for proper depth sorted rendering; to
 * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 * shapes that have no 3D transforms. See
 * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 * &lt;p&gt;
 * The depthBuffer and antiAliasing flags are conditional features. With the
 * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 * for more information.
 * &lt;p&gt;
 * A default headlight will be added to a scene that contains one or more
 * {@code Shape3D} nodes, but no light nodes. This light source is a
 * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 *
 * &lt;p&gt;
 * A {@code Scene} may be created and modified on any thread until it is attached
 * to a {@link Window} that is {@link Window#isShowing() showing}.
 * After that, it must be modified only on the JavaFX Application Thread.
 * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 * multiple threads at the same time will lead to unpredictable results and
 * must be avoided.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;
import javafx.scene.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;

Group root = new Group();
Scene s = new Scene(root, 300, 300, Color.BLACK);

Rectangle r = new Rectangle(25,25,250,250);
r.setFill(Color.BLUE);

root.getChildren().add(r);
 * &lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;root&quot;)
public class Scene implements EventTarget {

    private double widthSetByUser = -1.0;
    private double heightSetByUser = -1.0;
    private boolean sizeInitialized = false;
    private final boolean depthBuffer;
    private final SceneAntialiasing antiAliasing;

    private int dirtyBits;

    final AccessControlContext acc = AccessController.getContext();

    private Camera defaultCamera;

    /**
     * A node that is temporarily responsible for the FOCUS_NODE
     * accessibility attribute. E.g. a currently active MenuBar.
     */
    private Node transientFocusContainer;

    //Neither width nor height are initialized and will be calculated according to content when this Scene
    //is shown for the first time.
//    public Scene() {
//        //this(-1, -1, (Parent) new Group());
//        this(-1, -1, (Parent)null);
//    }

    /**
     * Creates a Scene for a specific root Node.
     *
     * @param root The root node of the scene graph
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root) {
        this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

//Public constructor initializing public-init properties
//When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
//Unitialized dimension is calculated when Scene is shown for the first time.
//    public Scene(
//            @Default(&quot;-1&quot;) double width,
//            @Default(&quot;-1&quot;) double height) {
//        //this(width, height, (Parent)new Group());
//        this(width, height, (Parent)null);
//    }
//
//    public Scene(double width, double height, Paint fill) {
//        //this(width, height, (Parent) new Group());
//        this(width, height, (Parent)null);
//        setFill(fill);
//    }

    /**
     * Creates a Scene for a specific root Node with a specific size.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
        this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a fill.
     *
     * @param root The parent
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a specific size and fill.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
            @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, and specifies whether a depth buffer is created for this scene.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
     * transforms may use depth buffer support for proper depth sorted
     * rendering; to avoid depth fighting (also known as Z fighting), disable
     * depth testing on 2D shapes that have no 3D transforms. See
     * {@link Node#depthTestProperty() depthTest} for more information.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * &lt;p&gt;
     * The depthBuffer flag is a conditional feature and its default value is
     * false. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
        this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, specifies whether a depth buffer is created for this scene and
     * specifies whether scene anti-aliasing is requested.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer nor scene anti-aliasing support. A scene containing 3D
     * shapes or 2D shapes with 3D transforms may use depth buffer support for
     * proper depth sorted rendering; to avoid depth fighting (also known as Z
     * fighting), disable depth testing on 2D shapes that have no 3D transforms.
     * See {@link Node#depthTestProperty() depthTest} for more information. A
     * scene with 3D shapes may enable scene anti-aliasing to improve its
     * rendering quality.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * @param antiAliasing The scene anti-aliasing attribute. A value of
     * {@code null} is treated as DISABLED.
     * &lt;p&gt;
     * The depthBuffer and antiAliasing are conditional features. With the
     * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     * @since JavaFX 8.0
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
            @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
            @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
        this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);

        if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
                !Toolkit.getToolkit().isMSAASupported())
        {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                + &quot;antiAliasing&quot;);
        }
    }

    private Scene(Parent root, double width, double height, Paint fill,
            boolean depthBuffer, SceneAntialiasing antiAliasing) {
        this.depthBuffer = depthBuffer;
        this.antiAliasing = antiAliasing;
        if (root == null) {
            throw new NullPointerException(&quot;Root cannot be null&quot;);
        }

        if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;ConditionalFeature.SCENE3D&quot;);
        }

        init();
        setRoot(root);
        init(width, height);
        setFill(fill);
    }

    static {
            PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
                public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
                    synchronized (trackerMonitor) {
                        scene.tracker = tracker;
                    }
                }
                public PerformanceTracker getPerfTracker(Scene scene) {
                    synchronized (trackerMonitor) {
                        return scene.tracker;
                    }
                }
            });
            SceneHelper.setSceneAccessor(
                    new SceneHelper.SceneAccessor() {
                        @Override
                        public void enableInputMethodEvents(Scene scene, boolean enable) {
                            scene.enableInputMethodEvents(enable);
                        }

                        @Override
                        public void processKeyEvent(Scene scene, KeyEvent e) {
                            scene.processKeyEvent(e);
                        }

                        @Override
                        public void processMouseEvent(Scene scene, MouseEvent e) {
                            scene.processMouseEvent(e);
                        }

                        @Override
                        public void preferredSize(Scene scene) {
                            scene.preferredSize();
                        }

                        @Override
                        public void disposePeer(Scene scene) {
                            scene.disposePeer();
                        }

                        @Override
                        public void initPeer(Scene scene) {
                            scene.initPeer();
                        }

                        @Override
                        public void setWindow(Scene scene, Window window) {
                            scene.setWindow(window);
                        }

                        @Override
                        public TKScene getPeer(Scene scene) {
                            return scene.getPeer();
                        }

                        @Override
                        public void setAllowPGAccess(boolean flag) {
                            Scene.setAllowPGAccess(flag);
                        }

                        @Override
                        public void parentEffectiveOrientationInvalidated(
                                final Scene scene) {
                            scene.parentEffectiveOrientationInvalidated();
                        }

                        @Override
                        public Camera getEffectiveCamera(Scene scene) {
                            return scene.getEffectiveCamera();
                        }

                        @Override
                        public Scene createPopupScene(Parent root) {
                            return new Scene(root) {
                                       @Override
                                       void doLayoutPass() {
                                           resizeRootToPreferredSize(getRoot());
                                           super.doLayoutPass();
                                       }

                                       @Override
                                       void resizeRootOnSceneSizeChange(
                                               double newWidth,
                                               double newHeight) {
                                           // don't resize
                                       }
                                   };
                        }

                        @Override
                        public void setTransientFocusContainer(Scene scene, Node node) {
                            if (scene != null) {
                                scene.transientFocusContainer = node;
                            }
                        }

                        @Override
                        public Accessible getAccessible(Scene scene) {
                            return scene.getAccessible();
                        }
                    });
        }

        // Reserve space for 30 nodes in the dirtyNodes set.
        private static final int MIN_DIRTY_CAPACITY = 30;

        // For debugging
        private static boolean inSynchronizer = false;
        private static boolean inMousePick = false;
        private static boolean allowPGAccess = false;
        private static int pgAccessCount = 0;

        /**
         * Used for debugging purposes. Returns true if we are in either the
         * mouse event code (picking) or the synchronizer, or if the scene is
         * not yet initialized,
         *
         */
        static boolean isPGAccessAllowed() {
            return inSynchronizer || inMousePick || allowPGAccess;
        }

        static void setAllowPGAccess(boolean flag) {
            if (Utils.assertionEnabled()) {
                if (flag) {
                    pgAccessCount++;
                    allowPGAccess = true;
                }
                else {
                    if (pgAccessCount &lt;= 0) {
                        throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
                    }
                    if (--pgAccessCount == 0) {
                        allowPGAccess = false;
                    }
                }
            }
        }

        /**
         * If true, use the platform's drag gesture detection
         * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
         */
        private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;

    /**
     * Set of dirty nodes; processed once per frame by the synchronizer.
     * When a node's state changes such that it becomes &quot;dirty&quot; with respect
     * to the graphics stack and requires synchronization, then that node
     * is added to this list. Note that if state on the Node changes, but it
     * was already dirty, then the Node doesn't add itself again.
     * &lt;p&gt;
     * Because at initialization time every node in the scene graph is dirty,
     * we have a special state and special code path during initialization
     * that does not involve adding each node to the dirtyNodes list. When
     * dirtyNodes is null, that means this Scene has not yet been synchronized.
     * A good default size is then created for the dirtyNodes list.
     * &lt;p&gt;
     * We double-buffer the set so that we can add new nodes to the
     * set while processing the existing set. This avoids our having to
     * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
     */
    private Node[] dirtyNodes;
    private int dirtyNodesSize;

    /**
     * Add the specified node to this scene's dirty list. Called by the
     * markDirty method in Node or when the Node's scene changes.
     */
    void addToDirtyList(Node n) {
        if (dirtyNodes == null || dirtyNodesSize == 0) {
            if (peer != null) {
                Toolkit.getToolkit().requestNextPulse();
            }
        }

        if (dirtyNodes != null) {
            if (dirtyNodesSize == dirtyNodes.length) {
                Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
                System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
                dirtyNodes = tmp;
            }
            dirtyNodes[dirtyNodesSize++] = n;
        }
    }

    private void doCSSPass() {
        final Parent sceneRoot = getRoot();
        //
        // RT-17547: when the tree is synchronized, the dirty bits are
        // are cleared but the cssFlag might still be something other than
        // clean.
        //
        // Before RT-17547, the code checked the dirty bit. But this is
        // superfluous since the dirty bit will be set if the flag is not clean,
        // but the flag will never be anything other than clean if the dirty
        // bit is not set. The dirty bit is still needed, however, since setting
        // it ensures a pulse if no other dirty bits have been set.
        //
        // For the purpose of showing the change, the dirty bit
        // check code was commented out and not removed.
        //
//        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
        if (sceneRoot.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS
            sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
            sceneRoot.processCSS();
        }
    }

    void doLayoutPass() {
        final Parent r = getRoot();
        if (r != null) {
            r.layout();
        }
    }

    /**
     * The peer of this scene
     */
    private TKScene peer;

    /*
     * Get Scene's peer
     */
    TKScene getPeer() {
        return peer;
    }

    /**
     * The scene pulse listener that gets called on toolkit pulses
     */
    ScenePulseListener scenePulseListener = new ScenePulseListener();

    private List&lt;Runnable&gt; preLayoutPulseListeners;
    private List&lt;Runnable&gt; postLayoutPulseListeners;

    /**
     * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
     * any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening and also for modifying the scenegraph
     * (as it is called before CSS and layout, so any changes made will be properly
     * styled and positioned).
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (preLayoutPulseListeners == null) {
            preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        preLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene pre layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (preLayoutPulseListeners == null) {
            return;
        }
        preLayoutPulseListeners.remove(r);
    }

    /**
     * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening, but it is not suited to use cases related
     * to modifying the scenegraph (as it is called after CSS and layout, so
     * any changes will possibly be incorrect until the next pulse is run).
     * An alternative (and better) solution for situations where a scenegraph
     * modification is required to happen is to use either the
     * {@link #addPreLayoutPulseListener(Runnable)} API or the the
     * {@link javafx.animation.AnimationTimer} API.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (postLayoutPulseListeners == null) {
            postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        postLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene post layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (postLayoutPulseListeners == null) {
            return;
        }
        postLayoutPulseListeners.remove(r);
    }

    /**
     * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
     * for more information.
     * @return the SceneAntialiasing for this scene
     * @since JavaFX 8.0
     */
    public final SceneAntialiasing getAntiAliasing() {
        return antiAliasing;
    }

    private boolean getAntiAliasingInternal() {
        return (antiAliasing != null &amp;&amp;
                Toolkit.getToolkit().isMSAASupported() &amp;&amp;
                Platform.isSupported(ConditionalFeature.SCENE3D)) ?
                antiAliasing != SceneAntialiasing.DISABLED : false;
    }

    /**
     * The {@code Window} for this {@code Scene}
     */
    private ReadOnlyObjectWrapper&lt;Window&gt; window;

    void setWindow(Window value) {
        windowPropertyImpl().set(value);
    }

    public final Window getWindow() {
        return window == null ? null : window.get();
    }

    public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
        return windowPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
        if (window == null) {
            window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
                private Window oldWindow;

                @Override protected void invalidated() {
                    final Window newWindow = get();
                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
                    if (oldWindow != null) {
                        disposePeer();
                    }
                    if (newWindow != null) {
                        initPeer();
                    }
                    parentEffectiveOrientationInvalidated();

                    oldWindow = newWindow;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;window&quot;;
                }
            };
        }
        return window;
    }

    void initPeer() {
        assert peer == null;

        Window window = getWindow();
        // initPeer() is only called from Window, either when the window
        // is being shown, or the window scene is being changed. In any case
        // this scene's window cannot be null.
        assert window != null;

        TKStage windowPeer = WindowHelper.getPeer(window);
        if (windowPeer == null) {
            // This is fine, the window is not visible. initPeer() will
            // be called again later, when the window is being shown.
            return;
        }

        final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
        if (!isTransparentWindowsSupported) {
            PlatformImpl.addNoTransparencyStylesheetToScene(this);
        }

        PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);

        setAllowPGAccess(true);

        Toolkit tk = Toolkit.getToolkit();
        peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
        peer.setTKSceneListener(new ScenePeerListener());
        peer.setTKScenePaintListener(new ScenePeerPaintListener());
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
        peer.setRoot(getRoot().getPeer());
        peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
        NodeHelper.updatePeer(getEffectiveCamera());
        peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
        peer.markDirty();
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);

        setAllowPGAccess(false);

        tk.addSceneTkPulseListener(scenePulseListener);
        // listen to dnd gestures coming from the platform
        if (PLATFORM_DRAG_GESTURE_INITIATION) {
            if (dragGestureListener == null) {
                dragGestureListener = new DragGestureListener();
            }
            tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
        }
        tk.enableDrop(peer, new DropTargetListener());
        tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());

        PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
    }

    public void disposePeer() {
        if (peer == null) {
            // This is fine, the window is either not shown yet and there is no
            // need in disposing scene peer, or is hidden and disposePeer()
            // has already been called.
            return;
        }

        PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);

        Toolkit tk = Toolkit.getToolkit();
        tk.removeSceneTkPulseListener(scenePulseListener);
        if (accessible != null) {
            disposeAccessibles();
            Node root = getRoot();
            if (root != null) root.releaseAccessible();
            accessible.dispose();
            accessible = null;
        }
        peer.dispose();
        peer = null;

        PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
    }

    DnDGesture dndGesture = null;
    DragGestureListener dragGestureListener;
    /**
     * The horizontal location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper x;

    private final void setX(double value) {
        xPropertyImpl().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final ReadOnlyDoubleProperty xProperty() {
        return xPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper xPropertyImpl() {
        if (x == null) {
            x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
        }
        return x;
    }

    /**
     * The vertical location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper y;

    private final void setY(double value) {
        yPropertyImpl().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final ReadOnlyDoubleProperty yProperty() {
        return yPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper yPropertyImpl() {
        if (y == null) {
            y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
        }
        return y;
    }

    /**
     * The width of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper width;

    private final void setWidth(double value) {
        widthPropertyImpl().set(value);
    }

    public final double getWidth() {
        return width == null ? 0.0 : width.get();
    }

    public final ReadOnlyDoubleProperty widthProperty() {
        return widthPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper widthPropertyImpl() {
        if (width == null) {
            width = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    //TODO - use a better method to update mirroring
                    if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                        NodeHelper.transformsChanged(_root);
                    }
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
                    }

                    getEffectiveCamera().setViewWidth(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;width&quot;;
                }
            };
        }
        return width;
    }

    /**
     * The height of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper height;

    private final void setHeight(double value) {
        heightPropertyImpl().set(value);
    }

    public final double getHeight() {
        return height == null ? 0.0 : height.get();
    }

    public final ReadOnlyDoubleProperty heightProperty() {
        return heightPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper heightPropertyImpl() {
        if (height == null) {
            height = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
                    }

                    getEffectiveCamera().setViewHeight(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;height&quot;;
                }
            };
        }
        return height;
    }

    void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
        getRoot().resize(newWidth, newHeight);
    }

    // Reusable target wrapper (to avoid creating new one for each picking)
    private TargetWrapper tmpTargetWrapper = new TargetWrapper();

    /**
     * Specifies the type of camera use for rendering this {@code Scene}.
     * If {@code camera} is null, a parallel camera is used for rendering.
     * It is illegal to set a camera that belongs to other {@code Scene}
     * or {@code SubScene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Camera&gt; camera;

    public final void setCamera(Camera value) {
        cameraProperty().set(value);
    }

    public final Camera getCamera() {
        return camera == null ? null : camera.get();
    }

    public final ObjectProperty&lt;Camera&gt; cameraProperty() {
        if (camera == null) {
            camera = new ObjectPropertyBase&lt;Camera&gt;() {
                Camera oldCamera = null;

                @Override
                protected void invalidated() {
                    Camera _value = get();
                    if (_value != null) {
                        if (_value instanceof PerspectiveCamera
                                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
                            String logname = Scene.class.getName();
                            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                                    + &quot;ConditionalFeature.SCENE3D&quot;);
                        }
                        // Illegal value if it belongs to other scene or any subscene
                        if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
                                || _value.getSubScene() != null) {
                            throw new IllegalArgumentException(_value
                                    + &quot;is already part of other scene or subscene&quot;);
                        }
                        // throws exception if the camera already has a different owner
                        _value.setOwnerScene(Scene.this);
                        _value.setViewWidth(getWidth());
                        _value.setViewHeight(getHeight());
                    }
                    if (oldCamera != null &amp;&amp; oldCamera != _value) {
                        oldCamera.setOwnerScene(null);
                    }
                    oldCamera = _value;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;camera&quot;;
                }
            };
        }
        return camera;
    }

    Camera getEffectiveCamera() {
        final Camera cam = getCamera();
        if (cam == null
                || (cam instanceof PerspectiveCamera
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
            if (defaultCamera == null) {
                defaultCamera = new ParallelCamera();
                defaultCamera.setOwnerScene(this);
                defaultCamera.setViewWidth(getWidth());
                defaultCamera.setViewHeight(getHeight());
            }
            return defaultCamera;
        }

        return cam;
    }

    // Used by the camera
    void markCameraDirty() {
        markDirty(DirtyBits.CAMERA_DIRTY);
        setNeedsRepaint();
    }

    void markCursorDirty() {
        markDirty(DirtyBits.CURSOR_DIRTY);
    }

    /**
     * Defines the background fill of this {@code Scene}. Both a {@code null}
     * value meaning 'paint no background' and a {@link javafx.scene.paint.Paint}
     * with transparency are supported. The default fill of the Scene is
     * {@link Color#WHITE}, but it is more commonly the case that the initial
     * color shown to users is the background fill of the
     * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
     * stretched to take up all available space in the {@code Scene}. The
     * root node of the {@code Scene} is given the CSS style class 'root', and
     * the default user agent stylesheets that ship with JavaFX (presently
     * Caspian and Modena) apply styling on to this root style class. In the
     * case of Caspian this does not impact the background fill color of the
     * root node, but in the case of Modena the default fill is set to be a
     * light gray color.
     *
     * @defaultValue WHITE
     */
    private ObjectProperty&lt;Paint&gt; fill;

    public final void setFill(Paint value) {
        fillProperty().set(value);
    }

    public final Paint getFill() {
        return fill == null ? Color.WHITE : fill.get();
    }

    public final ObjectProperty&lt;Paint&gt; fillProperty() {
        if (fill == null) {
            fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {

                @Override
                protected void invalidated() {
                    markDirty(DirtyBits.FILL_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;fill&quot;;
                }
            };
        }
        return fill;
    }

    /**
     * Defines the root {@code Node} of the scene graph.
     * If a {@code Group} is used as the root, the
     * contents of the scene graph will be clipped by the scene's width and height and
     * changes to the scene's size (if user resizes the stage) will not alter the
     * layout of the scene graph.    If a resizable node (layout {@code Region} or
     * {@code Control}) is set as the root, then the root's size will track the
     * scene's size, causing the contents to be relayed out as necessary.
     *
     * Scene doesn't accept null root.
     *
     */
    private ObjectProperty&lt;Parent&gt; root;

    public final void setRoot(Parent value) {
        rootProperty().set(value);
    }

    public final Parent getRoot() {
        return root == null ? null : root.get();
    }

    Parent oldRoot;
    public final ObjectProperty&lt;Parent&gt; rootProperty() {
        if (root == null) {
            root = new ObjectPropertyBase&lt;Parent&gt;() {

                private void forceUnbind() {
                    System.err.println(&quot;Unbinding illegal root.&quot;);
                    unbind();
                }

                @Override
                protected void invalidated() {
                    Parent _value = get();

                    if (_value == null) {
                        if (isBound()) forceUnbind();
                        throw new NullPointerException(&quot;Scene's root cannot be null&quot;);
                    }

                    if (_value.getParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already inside a scene-graph and cannot be set as root&quot;);
                    }
                    if (_value.getClipParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is set as a clip on another node, so cannot be set as root&quot;);
                    }
                    if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already set as root of another scene&quot;);
                    }

                    if (oldRoot != null) {
                        oldRoot.setScenes(null, null);
                    }
                    oldRoot = _value;
                    _value.getStyleClass().add(0, &quot;root&quot;);
                    _value.setScenes(Scene.this, null);
                    markDirty(DirtyBits.ROOT_DIRTY);
                    _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
                    _value.requestLayout();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;root&quot;;
                }
            };
        }
        return root;
    }

    void setNeedsRepaint() {
        if (this.peer != null) {
            peer.entireSceneNeedsRepaint();
        }
    }

    // Process CSS and layout and sync the scene prior to the snapshot
    // operation of the given node for this scene (currently the node
    // is unused but could possibly be used in the future to optimize this)
    void doCSSLayoutSyncForSnapshot(Node node) {
        if (!sizeInitialized) {
            preferredSize();
        } else {
            doCSSPass();
        }

        // we do not need pulse in the snapshot code
        // because this scene can be stage-less
        doLayoutPass();

        getRoot().updateBounds();
        if (peer != null) {
            peer.waitForRenderingToComplete();
            peer.waitForSynchronization();
            try {
                // Run the synchronizer while holding the render lock
                scenePulseListener.synchronizeSceneNodes();
            } finally {
                peer.releaseSynchronization(false);
            }
        } else {
            scenePulseListener.synchronizeSceneNodes();
        }

    }

    // Shared method for Scene.snapshot and Node.snapshot. It is static because
    // we might be doing a Node snapshot with a null scene
    static WritableImage doSnapshot(Scene scene,
            double x, double y, double w, double h,
            Node root, BaseTransform transform, boolean depthBuffer,
            Paint fill, Camera camera, WritableImage wimg) {

        Toolkit tk = Toolkit.getToolkit();
        Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();

        int xMin = (int)Math.floor(x);
        int yMin = (int)Math.floor(y);
        int xMax = (int)Math.ceil(x + w);
        int yMax = (int)Math.ceil(y + h);
        int width = Math.max(xMax - xMin, 1);
        int height = Math.max(yMax - yMin, 1);
        if (wimg == null) {
            wimg = new WritableImage(width, height);
        } else {
            width = (int)wimg.getWidth();
            height = (int)wimg.getHeight();
        }

        setAllowPGAccess(true);
        context.x = xMin;
        context.y = yMin;
        context.width = width;
        context.height = height;
        context.transform = transform;
        context.depthBuffer = depthBuffer;
        context.root = root.getPeer();
        context.platformPaint = fill == null ? null : tk.getPaint(fill);
        double cameraViewWidth = 1.0;
        double cameraViewHeight = 1.0;
        if (camera != null) {
            // temporarily adjust camera viewport to the snapshot size
            cameraViewWidth = camera.getViewWidth();
            cameraViewHeight = camera.getViewHeight();
            camera.setViewWidth(width);
            camera.setViewHeight(height);
            NodeHelper.updatePeer(camera);
            context.camera = camera.getPeer();
        } else {
            context.camera = null;
        }

        // Grab the lights from the scene
        context.lights = null;
        if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
            context.lights = new NGLightBase[scene.lights.size()];
            for (int i = 0; i &lt; scene.lights.size(); i++) {
                context.lights[i] = scene.lights.get(i).getPeer();
            }
        }

        Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
        context.platformImage = accessor.getTkImageLoader(wimg);
        setAllowPGAccess(false);
        Object tkImage = tk.renderToImage(context);
        accessor.loadTkImage(wimg, tkImage);

        if (camera != null) {
            setAllowPGAccess(true);
            camera.setViewWidth(cameraViewWidth);
            camera.setViewHeight(cameraViewHeight);
            NodeHelper.updatePeer(camera);
            setAllowPGAccess(false);
        }

        // if this scene belongs to some stage
        // we need to mark the entire scene as dirty
        // because dirty logic is buggy
        if (scene != null &amp;&amp; scene.peer != null) {
            scene.setNeedsRepaint();
        }

        return wimg;
    }

    /**
     * Implementation method for snapshot
     */
    private WritableImage doSnapshot(WritableImage img) {
        // TODO: no need to do CSS, layout or sync in the deferred case,
        // if this scene is attached to a visible stage
        doCSSLayoutSyncForSnapshot(getRoot());

        double w = getWidth();
        double h = getHeight();
        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;

        return doSnapshot(this, 0, 0, w, h,
                getRoot(), transform, isDepthBufferInternal(),
                getFill(), getEffectiveCamera(), img);
    }

    // Pulse listener used to run all deferred (async) snapshot requests
    private static TKPulseListener snapshotPulseListener = null;

    private static List&lt;Runnable&gt; snapshotRunnableListA;
    private static List&lt;Runnable&gt; snapshotRunnableListB;
    private static List&lt;Runnable&gt; snapshotRunnableList;

    static void addSnapshotRunnable(final Runnable runnable) {
        Toolkit.getToolkit().checkFxUserThread();

        if (snapshotPulseListener == null) {
            snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableList = snapshotRunnableListA;

            snapshotPulseListener = () -&gt; {
                if (snapshotRunnableList.size() &gt; 0) {
                    List&lt;Runnable&gt; runnables = snapshotRunnableList;
                    if (snapshotRunnableList == snapshotRunnableListA) {
                        snapshotRunnableList = snapshotRunnableListB;
                    } else {
                        snapshotRunnableList = snapshotRunnableListA;
                    }
                    for (Runnable r : runnables) {
                        try {
                            r.run();
                        } catch (Throwable th) {
                            System.err.println(&quot;Exception in snapshot runnable&quot;);
                            th.printStackTrace(System.err);
                        }
                    }
                    runnables.clear();
                }
            };

            // Add listener that will be called after all of the scenes have
            // had layout and CSS processing, and have been synced
            Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
        }

        final AccessControlContext acc = AccessController.getContext();
        snapshotRunnableList.add(() -&gt; {
            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                runnable.run();
                return null;
            }, acc);
        });
        Toolkit.getToolkit().requestNextPulse();
    }

    /**
     * Takes a snapshot of this scene and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        return doSnapshot(image);
    }

    /**
     * Takes a snapshot of this scene at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the scene is rendered.
     * If any such events modify a node in the scene that modification will
     * be reflected in the rendered image (as it will also be reflected in
     * the frame rendered to the Stage).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image and the source scene
     * that was rendered. The callback parameter must not be null.
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theImage);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            SnapshotResult result = new SnapshotResult(img, Scene.this, null);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };
//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        addSnapshotRunnable(snapshotRunnable);
    }

    /**
     * Defines the mouse cursor for this {@code Scene}.
     */
    private ObjectProperty&lt;Cursor&gt; cursor;

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return cursor == null ? null : cursor.get();
    }

    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        if (cursor == null) {
            cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
                         @Override
                         protected void invalidated() {
                             markCursorDirty();
                         }

                         @Override
                         public Object getBean() {
                             return Scene.this;
                         }

                         @Override
                         public String getName() {
                             return &quot;cursor&quot;;
                         }
                     };
        }
        return cursor;
    }

    /**
     * Looks for any node within the scene graph based on the specified CSS selector.
     * If more than one node matches the specified selector, this function
     * returns the first of them.
     * If no nodes are found with this id, then null is returned.
     *
     * @param selector The css selector to look up
     * @return the {@code Node} in the scene which matches the CSS {@code selector},
     * or {@code null} if none is found.
     */
     public Node lookup(String selector) {
         return getRoot().lookup(selector);
     }
    /**
     * A ObservableList of string URLs linking to the stylesheets to use with this scene's
     * contents. For additional information about using CSS with the
     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.
     */
    private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
            // RT-9784 - if stylesheet is removed, reset styled properties to
            // their initial value.
            c.reset();
            while(c.next()) {
                if (c.wasRemoved() == false) {
                    continue;
                }
                break; // no point in resetting more than once...
            }
            getRoot().reapplyCSS();
        }
    };

    /**
     * Gets an observable list of string URLs linking to the stylesheets to use
     * with this scene's contents.
     * &lt;p&gt;
     * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     *
     * package com.example.javafx.app;
     *
     * import javafx.application.Application;
     * import javafx.scene.Group;
     * import javafx.scene.Scene;
     * import javafx.stage.Stage;
     *
     * public class MyApp extends Application {
     *
     *     {@literal @}Override public void start(Stage stage) {
     *         Scene scene = new Scene(new Group());
     *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
     *         stage.setScene(scene);
     *         stage.show();
     *     }
     *
     *     public static void main(String[] args) {
     *         launch(args);
     *     }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     *
     * @return the list of stylesheets to use with this scene
     */
    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }

    private ObjectProperty&lt;String&gt; userAgentStylesheet = null;

    /**
     * @return the userAgentStylesheet property.
     * @see #getUserAgentStylesheet()
     * @see #setUserAgentStylesheet(String)
     * @since  JavaFX 8u20
     */
    public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
        if (userAgentStylesheet == null) {
            userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
                @Override protected void invalidated() {
                    StyleManager.getInstance().forget(Scene.this);
                    getRoot().reapplyCSS();
                }
            };
        }
        return userAgentStylesheet;
    }

    /**
     * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @return The URL of the user-agent stylesheet that will be used by this Scene,
     * or null if has not been set.
<A NAME="31"></A>     * @since  JavaFX 8u20
     */
    public final String getUserAgentStylesheet() {
        return userAgentStylesheet == null ? null : <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#31',2,'match34-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>userAgentStylesheet.get();
    }

    /**
     * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
     * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * @since  JavaFX 8u20
     */
    public final void setUserAgentStylesheet(String url) {
        userAgentStylesheetProperty().set(url);
    }

    /**
     * Retrieves the depth buffer attribute for this scene.
     * @return the depth buffer attribute.
     */
    public final boolean isDepthBuffer() {
        return depthBuffer;
    }

    boolean isDepthBufferInternal() {</B></FONT>
        if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
            return false;
        }
        return depthBuffer;
    }

    private void init(double width, double height) {
        if (width &gt;= 0) {
            widthSetByUser = width;
            setWidth((float)width);
        }
        if (height &gt;= 0) {
            heightSetByUser = height;
            setHeight((float)height);
        }
        sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
    }

    private void init() {
        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
        }
        mouseHandler = new MouseHandler();
        clickGenerator = new ClickGenerator();

        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
        }
    }

    void preferredSize() {
        final Parent root = getRoot();

        // one or the other isn't initialized, need to perform layout in
        // order to ensure we can properly measure the preferred size of the
        // scene
        doCSSPass();

        resizeRootToPreferredSize(root);
        doLayoutPass();

        if (widthSetByUser &lt; 0) {
            setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
                            root.getBoundsInParent().getMaxX());
        } else {
            setWidth(widthSetByUser);
        }

        if (heightSetByUser &lt; 0) {
            setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
                            root.getBoundsInParent().getMaxY());
        } else {
            setHeight(heightSetByUser);
        }

        sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);

        PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
    }

    final void resizeRootToPreferredSize(Parent root) {
        final double preferredWidth;
        final double preferredHeight;

        final Orientation contentBias = root.getContentBias();
        if (contentBias == null) {
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
        } else if (contentBias == Orientation.HORIZONTAL) {
            // height depends on width
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser,
                                                       preferredWidth);
        } else /* if (contentBias == Orientation.VERTICAL) */ {
            // width depends on height
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
            preferredWidth = getPreferredWidth(root, widthSetByUser,
                                                     preferredHeight);
        }

        root.resize(preferredWidth, preferredHeight);
    }

    private static double getPreferredWidth(Parent root,
                                            double forcedWidth,
                                            double height) {
        if (forcedWidth &gt;= 0) {
            return forcedWidth;
        }
        final double normalizedHeight = (height &gt;= 0) ? height : -1;
        return root.boundedSize(root.prefWidth(normalizedHeight),
                                root.minWidth(normalizedHeight),
                                root.maxWidth(normalizedHeight));
    }

    private static double getPreferredHeight(Parent root,
                                             double forcedHeight,
                                             double width) {
        if (forcedHeight &gt;= 0) {
            return forcedHeight;
        }
        final double normalizedWidth = (width &gt;= 0) ? width : -1;
        return root.boundedSize(root.prefHeight(normalizedWidth),
                                root.minHeight(normalizedWidth),
                                root.maxHeight(normalizedWidth));
    }

    private PerformanceTracker tracker;
    private static final Object trackerMonitor = new Object();

    // mouse events handling
    private MouseHandler mouseHandler;
    private ClickGenerator clickGenerator;

    // gesture events handling
    private Point2D cursorScreenPos;
    private Point2D cursorScenePos;

    private static class TouchGesture {
        WeakReference&lt;EventTarget&gt; target;
        Point2D sceneCoords;
        Point2D screenCoords;
        boolean finished;
    }

    private final TouchGesture scrollGesture = new TouchGesture();
    private final TouchGesture zoomGesture = new TouchGesture();
    private final TouchGesture rotateGesture = new TouchGesture();
    private final TouchGesture swipeGesture = new TouchGesture();

    // touch events handling
    private TouchMap touchMap = new TouchMap();
    private TouchEvent nextTouchEvent = null;
    private TouchPoint[] touchPoints = null;
    private int touchEventSetId = 0;
    private int touchPointIndex = 0;
    private Map&lt;Integer, EventTarget&gt; touchTargets =
            new HashMap&lt;Integer, EventTarget&gt;();

    void processMouseEvent(MouseEvent e) {
        mouseHandler.process(e, false);
    }

    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
        EventTarget eventTarget = null;
        Scene.inMousePick = true;
        if (isKeyboardTrigger) {
            Node sceneFocusOwner = getFocusOwner();

            // for keyboard triggers set coordinates inside focus owner
            final double xOffset = xAbs - x2;
            final double yOffset = yAbs - y2;
            if (sceneFocusOwner != null) {
                final Bounds bounds = sceneFocusOwner.localToScene(
                        sceneFocusOwner.getBoundsInLocal());
                x2 = bounds.getMinX() + bounds.getWidth() / 4;
                y2 = bounds.getMinY() + bounds.getHeight() / 2;
                eventTarget = sceneFocusOwner;
            } else {
                x2 = Scene.this.getWidth() / 4;
                y2 = Scene.this.getWidth() / 2;
                eventTarget = Scene.this;
            }

            xAbs = x2 + xOffset;
            yAbs = y2 + yOffset;
        }

        final PickResult res = pick(x2, y2);

        if (!isKeyboardTrigger) {
            eventTarget = res.getIntersectedNode();
            if (eventTarget == null) {
                eventTarget = this;
            }
        }

        if (eventTarget != null) {
            ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
            Event.fireEvent(eventTarget, context);
        }
        Scene.inMousePick = false;
    }

    private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
        EventTarget pickedTarget = null;

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = null;
            gesture.finished = false;
        }

        if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
            pickedTarget = gesture.target.get();
        } else {
            pickedTarget = e.getPickResult().getIntersectedNode();
            if (pickedTarget == null) {
                pickedTarget = this;
            }
        }

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = new WeakReference&lt;&gt;(pickedTarget);
        }
        if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
                e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
                e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
                !e.isInertia()) {
            gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
            gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
        }

        if (pickedTarget != null) {
            Event.fireEvent(pickedTarget, e);
        }

        if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
                e.getEventType() == RotateEvent.ROTATION_FINISHED ||
                e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
            gesture.finished = true;
        }
    }

    private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
        inMousePick = true;
        touchEventSetId++;

        List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);

        // fire all the events
        for (TouchPoint tp : touchPoints) {
            if (tp.getTarget() != null) {
                EventType&lt;TouchEvent&gt; type = null;
                switch (tp.getState()) {
                    case MOVED:
                        type = TouchEvent.TOUCH_MOVED;
                        break;
                    case PRESSED:
                        type = TouchEvent.TOUCH_PRESSED;
                        break;
                    case RELEASED:
                        type = TouchEvent.TOUCH_RELEASED;
                        break;
                    case STATIONARY:
                        type = TouchEvent.TOUCH_STATIONARY;
                        break;
                }

                for (TouchPoint t : touchPoints) {
                    TouchPointHelper.reset(t);
                }

                TouchEvent te = new TouchEvent(type, tp, touchList,
                        touchEventSetId, e.isShiftDown(), e.isControlDown(),
                        e.isAltDown(), e.isMetaDown());

                Event.fireEvent(tp.getTarget(), te);
            }
        }

        // process grabbing
        for (TouchPoint tp : touchPoints) {
            EventTarget grabbed = tp.getGrabbed();
            if (grabbed != null) {
                touchTargets.put(tp.getId(), grabbed);
            };

            if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
        }

        inMousePick = false;
    }

    /**
     * Note: The only user of this method is in unit test: PickAndContainTest.
     */
    Node test_pick(double x, double y) {
        inMousePick = true;
        PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
                Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
        inMousePick = false;
        if (result != null) {
            return result.getIntersectedNode();
        }
        return null;
    }

    private PickResult pick(final double x, final double y) {
        pick(tmpTargetWrapper, x, y);
        return tmpTargetWrapper.getResult();
    }

    private boolean isInScene(double x, double y) {
        if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
            return false;
        }

        Window w = getWindow();
        if (w instanceof Stage
                &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
                &amp;&amp; getFill() == null) {
            return false;
        }

        return true;
    }

    private void pick(TargetWrapper target, final double x, final double y) {
        final PickRay pickRay = getEffectiveCamera().computePickRay(
                x, y, null);

        final double mag = pickRay.getDirectionNoClone().length();
        pickRay.getDirectionNoClone().normalize();
        final PickResult res = mouseHandler.pickNode(pickRay);
        if (res != null) {
            target.setNodeResult(res);
        } else {
            //TODO: is this the intersection with projection plane?
            Vec3d o = pickRay.getOriginNoClone();
            Vec3d d = pickRay.getDirectionNoClone();
            target.setSceneResult(new PickResult(
                    null, new Point3D(
                    o.x + mag * d.x,
                    o.y + mag * d.y,
                    o.z + mag * d.z),
                    mag),
                    isInScene(x, y) ? this : null);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Key Events and Focus Traversal                                          *
     *                                                                         *
     **************************************************************************/

    /*
     * We cannot initialize keyHandler in init because some of the triggers
     * access it before the init block.
     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
     * does not compile.
     */
    private KeyHandler keyHandler = null;
    private KeyHandler getKeyHandler() {
        if (keyHandler == null) {
            keyHandler = new KeyHandler();
        }
        return keyHandler;
    }
    /**
     * Set to true if something has happened to the focused node that makes
     * it no longer eligible to have the focus.
     *
     */
    private boolean focusDirty = true;

    final void setFocusDirty(boolean value) {
        if (!focusDirty) {
            Toolkit.getToolkit().requestNextPulse();
        }
        focusDirty = value;
    }

    final boolean isFocusDirty() {
        return focusDirty;
    }

    private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);

    /**
     * Traverses focus from the given node in the given direction.
     */
    boolean traverse(Node node, Direction dir) {
        if (node.getSubScene() != null) {
            return node.getSubScene().traverse(node, dir);
        }
        return traversalEngine.trav(node, dir) != null;
    }

    /**
     * Moves the focus to a reasonable initial location. Called when a scene's
     * focus is dirty and there's no current owner, or if the owner has been
     * removed from the scene.
     */
    private void focusInitial() {
        traversalEngine.traverseToFirst();
    }

    /**
     * Moves the focus to a reasonble location &quot;near&quot; the given node.
     * Called when the focused node is no longer eligible to have
     * the focus because it has become invisible or disabled. This
     * function assumes that it is still a member of the same scene.
     */
    private void focusIneligible(Node node) {
        traverse(node, Direction.NEXT);
    }

    public void processKeyEvent(KeyEvent e) {
        if (dndGesture != null) {
            if (!dndGesture.processKey(e)) {
                dndGesture = null;
            }
        }

        getKeyHandler().process(e);
    }

    void requestFocus(Node node) {
        getKeyHandler().requestFocus(node);
    }

    private Node oldFocusOwner;

    /**
      * The scene's current focus owner node. This node's &quot;focused&quot;
      * variable might be false if this scene has no window, or if the
      * window is inactive (window.focused == false).
      * @since JavaFX 2.2
      */
    private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {

        @Override
        protected void invalidated() {
            if (oldFocusOwner != null) {
                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
            }
            Node value = get();
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
                if (value != oldFocusOwner) {
                    value.getScene().enableInputMethodEvents(
                            value.getInputMethodRequests() != null
                            &amp;&amp; value.getOnInputMethodTextChanged() != null);
                }
            }
            // for the rest of the method we need to update the oldFocusOwner
            // and use a local copy of it because the user handlers can cause
            // recurrent calls of requestFocus
            Node localOldOwner = oldFocusOwner;
            oldFocusOwner = value;
            if (localOldOwner != null) {
                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
            }
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
            }
            PlatformLogger logger = Logging.getFocusLogger();
            if (logger.isLoggable(Level.FINE)) {
                if (value == get()) {
                    logger.fine(&quot;Changed focus from &quot;
                            + localOldOwner + &quot; to &quot; + value);
                } else {
                    logger.fine(&quot;Changing focus from &quot;
                            + localOldOwner + &quot; to &quot; + value
                            + &quot; canceled by nested requestFocus&quot;);
                }
            }
            if (accessible != null) {
                accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
            }
        }
    };

    public final Node getFocusOwner() {
        return focusOwner.get();
    }

    public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
        return focusOwner.getReadOnlyProperty();
    }

    // For testing.
    void focusCleanup() {
        scenePulseListener.focusCleanup();
    }

    private void processInputMethodEvent(InputMethodEvent e) {
        Node node = getFocusOwner();
        if (node != null) {
            node.fireEvent(e);
        }
    }

    public void enableInputMethodEvents(boolean enable) {
       if (peer != null) {
           peer.enableInputMethodEvents(enable);
       }
    }

    /**
     * Returns true if this scene is quiescent, i.e. it has no activity
     * pending on it such as CSS processing or layout requests.
     *
     * Intended to be used for tests only
     *
     * @return boolean indicating whether the scene is quiescent
     */
    boolean isQuiescent() {
        final Parent r = getRoot();
        return !isFocusDirty()
               &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
                r.layoutFlag == LayoutFlags.CLEAN));
    }

    /**
     * A listener for pulses, used for testing. If non-null, this is called at
     * the very end of ScenePulseListener.pulse().
     *
     * Intended to be used for tests only
     */
    Runnable testPulseListener = null;

    /**
     * Set the specified dirty bit and mark the peer as dirty
     */
    private void markDirty(DirtyBits dirtyBit) {
        setDirty(dirtyBit);
        if (peer != null) {
            Toolkit.getToolkit().requestNextPulse();
        }
    }

    /**
     * Set the specified dirty bit
     */
    private void setDirty(DirtyBits dirtyBit) {
        dirtyBits |= dirtyBit.getMask();
    }

    /**
     * Test the specified dirty bit
     */
    private boolean isDirty(DirtyBits dirtyBit) {
        return ((dirtyBits &amp; dirtyBit.getMask()) != 0);
    }

    /**
     * Test whether the dirty bits are empty
     */
    private boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    private enum DirtyBits {
        FILL_DIRTY,
        ROOT_DIRTY,
        CAMERA_DIRTY,
        LIGHTS_DIRTY,
        CURSOR_DIRTY;

        private int mask;

        private DirtyBits() {
            mask = 1 &lt;&lt; ordinal();
        }

        public final int getMask() { return mask; }
    }

    private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();

    // @param light must not be null
    final void addLight(LightBase light) {
        if (!lights.contains(light)) {
            lights.add(light);
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    final void removeLight(LightBase light) {
        if (lights.remove(light)) {
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    /**
     * PG Light synchronizer.
     */
    private void syncLights() {
        if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
            return;
        }
        inSynchronizer = true;
        NGLightBase peerLights[] = peer.getLights();
        if (!lights.isEmpty() || (peerLights != null)) {
            if (lights.isEmpty()) {
                peer.setLights(null);
            } else {
                if (peerLights == null || peerLights.length &lt; lights.size()) {
                    peerLights = new NGLightBase[lights.size()];
                }
                int i = 0;
                for (; i &lt; lights.size(); i++) {
                    peerLights[i] = lights.get(i).getPeer();
                }
                // Clear the rest of the list
                while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
                    peerLights[i++] = null;
                }
                peer.setLights(peerLights);
            }
        }
        inSynchronizer = false;
    }

    //INNER CLASSES

    /*******************************************************************************
     *                                                                             *
     * Scene Pulse Listener                                                        *
     *                                                                             *
     ******************************************************************************/

    class ScenePulseListener implements TKPulseListener {

        private boolean firstPulse = true;

        /**
         * PG synchronizer. Called once per frame from the pulse listener.
         * This function calls the synchronizePGNode method on each node in
         * the dirty list.
         */
        private void synchronizeSceneNodes() {
            Toolkit.getToolkit().checkFxUserThread();

            Scene.inSynchronizer = true;

            // if dirtyNodes is null then that means this Scene has not yet been
            // synchronized, and so we will simply synchronize every node in the
            // scene and then create the dirty nodes array list
            if (Scene.this.dirtyNodes == null) {
                // must do this recursively
                syncAll(getRoot());
                dirtyNodes = new Node[MIN_DIRTY_CAPACITY];

            } else {
                // This is not the first time this scene has been synchronized,
                // so we will only synchronize those nodes that need it
                for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
                    Node node = dirtyNodes[i];
                    dirtyNodes[i] = null;
                    if (node.getScene() == Scene.this) {
                            node.syncPeer();
                        }
                    }
                dirtyNodesSize = 0;
            }

            Scene.inSynchronizer = false;
        }

        /**
         * Recursive function for synchronizing every node in the scenegraph.
         * The return value is the number of nodes in the graph.
         */
        private int syncAll(Node node) {
            node.syncPeer();
            int size = 1;
            if (node instanceof Parent) {
                Parent p = (Parent) node;
                final int childrenCount = p.getChildren().size();

                for (int i = 0; i &lt; childrenCount; i++) {
                    Node n = p.getChildren().get(i);
                    if (n != null) {
                        size += syncAll(n);
                    }
                }
            } else if (node instanceof SubScene) {
                SubScene subScene = (SubScene)node;
                size += syncAll(subScene.getRoot());
            }
            if (node.getClip() != null) {
                size += syncAll(node.getClip());
            }

            return size;
        }

        private void synchronizeSceneProperties() {
            inSynchronizer = true;
            if (isDirty(DirtyBits.ROOT_DIRTY)) {
                peer.setRoot(getRoot().getPeer());
            }

            if (isDirty(DirtyBits.FILL_DIRTY)) {
                Toolkit tk = Toolkit.getToolkit();
                peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
            }

            // new camera was set on the scene or old camera changed
            final Camera cam = getEffectiveCamera();
            if (isDirty(DirtyBits.CAMERA_DIRTY)) {
                NodeHelper.updatePeer(cam);
                peer.setCamera((NGCamera) cam.getPeer());
            }

            if (isDirty(DirtyBits.CURSOR_DIRTY)) {
                mouseHandler.updateCursor(getCursor());
                mouseHandler.updateCursorFrame();
            }

            clearDirty();
            inSynchronizer = false;
        }

        /**
         * The focus is considered dirty if something happened to
         * the scene graph that may require the focus to be moved.
         * This must handle cases where (a) the focus owner may have
         * become ineligible to have the focus, and (b) where the focus
         * owner is null and a node may have become traversable and eligible.
         */
        private void focusCleanup() {
            if (Scene.this.isFocusDirty()) {
                final Node oldOwner = Scene.this.getFocusOwner();
                if (oldOwner == null) {
                    Scene.this.focusInitial();
                } else if (oldOwner.getScene() != Scene.this) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusInitial();
                } else if (!oldOwner.isCanReceiveFocus()) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusIneligible(oldOwner);
                }
                Scene.this.setFocusDirty(false);
            }
        }

        @Override
        public void pulse() {
            if (Scene.this.tracker != null) {
                Scene.this.tracker.pulse();
            }
            if (firstPulse) {
                PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
            }

            focusCleanup();

            disposeAccessibles();

            // run any scene pre pulse listeners immediately _before_ css / layout,
            // and before scene synchronization
            if (preLayoutPulseListeners != null) {
                for (Runnable r : preLayoutPulseListeners) {
                    r.run();
                }
            }

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;CSS Pass&quot;);
            }
            Scene.this.doCSSPass();

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Layout Pass&quot;);
            }
            Scene.this.doLayoutPass();

            // run any scene post pulse listeners immediately _after_ css / layout,
            // and before scene synchronization
            if (postLayoutPulseListeners != null) {
                for (Runnable r : postLayoutPulseListeners) {
                    r.run();
                }
            }

            boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
            if (dirty) {
                if (PULSE_LOGGING_ENABLED) {
                    PulseLogger.newPhase(&quot;Update bounds&quot;);
                }
                getRoot().updateBounds();
                if (peer != null) {
                    try {
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
                        }
                        peer.waitForRenderingToComplete();
                        peer.waitForSynchronization();
                        // synchronize scene properties
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
                        }
                        syncLights();
                        synchronizeSceneProperties();
                        // Run the synchronizer
                        synchronizeSceneNodes();
                        Scene.this.mouseHandler.pulse();
                        // Tell the scene peer that it needs to repaint
                        peer.markDirty();
                    } finally {
                        peer.releaseSynchronization(true);
                    }
                } else {
                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
                    }
                    synchronizeSceneNodes();
                    Scene.this.mouseHandler.pulse();
                }

                if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
                    NodeHelper.markDirty(Scene.this.getRoot(),
                            com.sun.javafx.scene.DirtyBits.NODE_CSS);
                }
            }

            // required for image cursor created from animated image
            Scene.this.mouseHandler.updateCursorFrame();

            if (firstPulse) {
                if (PerformanceTracker.isLoggingEnabled()) {
                    PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
                    if (PrismSettings.perfLogFirstPaintFlush) {
                        PerformanceTracker.outputLog();
                    }
                    if (PrismSettings.perfLogFirstPaintExit) {
                        System.exit(0);
                    }
                }
                firstPulse = false;
            }

            if (testPulseListener != null) {
                testPulseListener.run();
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Scene Peer Listener                                                         *
     *                                                                             *
     ******************************************************************************/

    class ScenePeerListener implements TKSceneListener {
        @Override
        public void changedLocation(float x, float y) {
            if (x != Scene.this.getX()) {
                Scene.this.setX(x);
            }
            if (y != Scene.this.getY()) {
                Scene.this.setY(y);
            }
        }

        @Override
        public void changedSize(float w, float h) {
            if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
            if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
        }

        @Override
        public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
                               MouseButton button, boolean popupTrigger, boolean synthesized,
                               boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
                               boolean primaryDown, boolean middleDown, boolean secondaryDown)
        {
            MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
                    0, // click count will be adjusted by clickGenerator later anyway
                    shiftDown, controlDown, altDown, metaDown,
                    primaryDown, middleDown, secondaryDown, synthesized, popupTrigger, false, null);
            processMouseEvent(mouseEvent);
        }


        @Override
        public void keyEvent(KeyEvent keyEvent)
        {
            processKeyEvent(keyEvent);
        }

        @Override
        public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
                                     ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
                                     int caretPosition)
        {
            InputMethodEvent inputMethodEvent = new InputMethodEvent(
               type, composed, committed, caretPosition);
            processInputMethodEvent(inputMethodEvent);
        }

        public void menuEvent(double x, double y, double xAbs, double yAbs,
                boolean isKeyboardTrigger) {
            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
        }

        @Override
        public void scrollEvent(
                EventType&lt;ScrollEvent&gt; eventType,
                double scrollX, double scrollY,
                double totalScrollX, double totalScrollY,
                double xMultiplier, double yMultiplier,
                int touchCount,
                int scrollTextX, int scrollTextY,
                int defaultTextX, int defaultTextY,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
                    ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
                    ScrollEvent.HorizontalTextScrollUnits.NONE;

            double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;

            ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
                    ScrollEvent.VerticalTextScrollUnits.LINES :
                    (scrollTextY &lt; 0 ?
                        ScrollEvent.VerticalTextScrollUnits.PAGES :
                        ScrollEvent.VerticalTextScrollUnits.NONE);

            double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;

            xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
                    ? Math.round(xMultiplier * scrollTextX / defaultTextX)
                    : xMultiplier;

            yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
                    ? Math.round(yMultiplier * scrollTextY / defaultTextY)
                    : yMultiplier;

            if (eventType == ScrollEvent.SCROLL_FINISHED) {
                x = scrollGesture.sceneCoords.getX();
                y = scrollGesture.sceneCoords.getY();
                screenX = scrollGesture.screenCoords.getX();
                screenY = scrollGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ScrollEvent(
                    eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    scrollX * xMultiplier, scrollY * yMultiplier,
                    totalScrollX * xMultiplier, totalScrollY * yMultiplier,
                    xMultiplier, yMultiplier,
                    xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
                    scrollGesture);
            inMousePick = false;
        }

        @Override
        public void zoomEvent(
                EventType&lt;ZoomEvent&gt; eventType,
                double zoomFactor, double totalZoomFactor,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == ZoomEvent.ZOOM_FINISHED) {
                x = zoomGesture.sceneCoords.getX();
                y = zoomGesture.sceneCoords.getY();
                screenX = zoomGesture.screenCoords.getX();
                screenY = zoomGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ZoomEvent(eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    zoomFactor, totalZoomFactor, pick(x, y)),
                    zoomGesture);
            inMousePick = false;
        }

        @Override
        public void rotateEvent(
                EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == RotateEvent.ROTATION_FINISHED) {
                x = rotateGesture.sceneCoords.getX();
                y = rotateGesture.sceneCoords.getY();
                screenX = rotateGesture.screenCoords.getX();
                screenY = rotateGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new RotateEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia, angle, totalAngle, pick(x, y)),
                    rotateGesture);
            inMousePick = false;

        }

        @Override
        public void swipeEvent(
                EventType&lt;SwipeEvent&gt; eventType, int touchCount,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown, boolean _direct) {

            if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new SwipeEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown, _direct,
                    touchCount, pick(x, y)),
                    swipeGesture);
            inMousePick = false;
        }

        @Override
        public void touchEventBegin(
                long time, int touchCount, boolean isDirect,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown) {

            if (!isDirect) {
                nextTouchEvent = null;
                return;
            }
            nextTouchEvent = new TouchEvent(
                    TouchEvent.ANY, null, null, 0,
                    _shiftDown, _controlDown, _altDown, _metaDown);
            if (touchPoints == null || touchPoints.length != touchCount) {
                touchPoints = new TouchPoint[touchCount];
            }
            touchPointIndex = 0;
        }

        @Override
        public void touchEventNext(
                TouchPoint.State state, long touchId,
                double x, double y, double screenX, double screenY) {

            inMousePick = true;
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }
            touchPointIndex++;
            int id = (state == TouchPoint.State.PRESSED
                    ? touchMap.add(touchId) :  touchMap.get(touchId));
            if (state == TouchPoint.State.RELEASED) {
                touchMap.remove(touchId);
            }
            int order = touchMap.getOrder(id);

            if (order &gt;= touchPoints.length) {
                throw new RuntimeException(&quot;Too many touch points reported&quot;);
            }

            // pick target
            boolean isGrabbed = false;
            PickResult pickRes = pick(x, y);
            EventTarget pickedTarget = touchTargets.get(id);
            if (pickedTarget == null) {
                pickedTarget = pickRes.getIntersectedNode();
                if (pickedTarget == null) {
                    pickedTarget = Scene.this;
                }
            } else {
                isGrabbed = true;
            }

            TouchPoint tp = new TouchPoint(id, state,
                    x, y, screenX, screenY, pickedTarget, pickRes);

            touchPoints[order] = tp;

            if (isGrabbed) {
                tp.grab(pickedTarget);
            }
            if (tp.getState() == TouchPoint.State.PRESSED) {
                tp.grab(pickedTarget);
                touchTargets.put(tp.getId(), pickedTarget);
            } else if (tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
            inMousePick = false;
        }

        @Override
        public void touchEventEnd() {
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }

            if (touchPointIndex != touchPoints.length) {
                throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
            }

            Scene.this.processTouchEvent(nextTouchEvent, touchPoints);

            if (touchMap.cleanup()) {
                // gesture finished
                touchEventSetId = 0;
            }
        }

        @Override
        public Accessible getSceneAccessible() {
            return getAccessible();
        }
    }

    private class ScenePeerPaintListener implements TKScenePaintListener {
        @Override
        public void frameRendered() {
            // must use tracker with synchronization since this method is called on render thread
            synchronized (trackerMonitor) {
                if (Scene.this.tracker != null) {
                    Scene.this.tracker.frameRendered();
                }
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Drag and Drop                                                               *
     *                                                                             *
     ******************************************************************************/

    class DropTargetListener implements TKDropTargetListener {

        /*
         * This function is called when an drag operation enters a valid drop target.
         * This may be from either an internal or external dnd operation.
         */
        @Override
        public TransferMode dragEnter(double x, double y, double screenX, double screenY,
                                      TransferMode transferMode, TKClipboard dragboard)
        {
            if (dndGesture == null) {
                dndGesture = new DnDGesture();
            }
            Dragboard db = DragboardHelper.createDragboard(dragboard);
            dndGesture.dragboard = db;
            DragEvent dragEvent =
                    new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                            transferMode, null, null, pick(x, y));
            return dndGesture.processTargetEnterOver(dragEvent);
        }

        @Override
        public TransferMode dragOver(double x, double y, double screenX, double screenY,
                                     TransferMode transferMode)
        {
            if (Scene.this.dndGesture == null) {
                System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                return dndGesture.processTargetEnterOver(dragEvent);
            }
        }

        @Override
        public void dragExit(double x, double y, double screenX, double screenY) {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                null, null, null, pick(x, y));
                dndGesture.processTargetExit(dragEvent);
                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
            }
        }


        @Override
        public TransferMode drop(double x, double y, double screenX, double screenY,
                                  TransferMode transferMode)
        {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                // Data dropped to the app can be accessed without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);

                TransferMode tm;
                try {
                    tm = dndGesture.processTargetDrop(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(
                            dndGesture.dragboard, true);
                }

                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
                return tm;
            }
        }
    }

    class DragGestureListener implements TKDragGestureListener {

       @Override
       public void dragGestureRecognized(double x, double y, double screenX, double screenY,
                                         int button, TKClipboard dragboard)
       {
           Dragboard db = DragboardHelper.createDragboard(dragboard);
           dndGesture = new DnDGesture();
           dndGesture.dragboard = db;
           // TODO: support mouse buttons in DragEvent
           DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
                   null, null, null, pick(x, y));
           dndGesture.processRecognized(dragEvent);
           dndGesture = null;
        }
    }

    /**
     * A Drag and Drop gesture has a lifespan that lasts from mouse
     * PRESSED event to mouse RELEASED event.
     */
    class DnDGesture {
        private final double hysteresisSizeX =
                Toolkit.getToolkit().getMultiClickMaxX();
        private final double hysteresisSizeY =
                Toolkit.getToolkit().getMultiClickMaxY();

        private EventTarget source = null;
        private Set&lt;TransferMode&gt; sourceTransferModes = null;
        private TransferMode acceptedTransferMode = null;
        private Dragboard dragboard = null;
        private EventTarget potentialTarget = null;
        private EventTarget target = null;
        private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
        private double pressedX;
        private double pressedY;
        private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRSource = null;

        /**
         * Fires event on a given target or on scene if the node is null
         */
        private void fireEvent(EventTarget target, Event e) {
            if (target != null) {
                Event.fireEvent(target, e);
            }
        }

        /**
         * Called when DRAG_DETECTED event is going to be processed by
         * application
         */
        private void processingDragDetected() {
            dragDetected = DragDetectedState.PROCESSING;
        }

        /**
         * Called after DRAG_DETECTED event has been processed by application
         */
        private void dragDetectedProcessed() {
            dragDetected = DragDetectedState.DONE;
            final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
            if (hasContent) {
                /* start DnD */
                Toolkit.getToolkit().startDrag(Scene.this.peer,
                                                sourceTransferModes,
                                                new DragSourceListener(),
                                                dragboard);
            } else if (fullPDRSource != null) {
                /* start PDR */
                Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
            }

            fullPDRSource = null;
        }

        /**
         * Sets the default dragDetect value
         */
        private void processDragDetection(MouseEvent mouseEvent) {

            if (dragDetected != DragDetectedState.NOT_YET) {
                mouseEvent.setDragDetect(false);
                return;
            }

            if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
                pressedX = mouseEvent.getSceneX();
                pressedY = mouseEvent.getSceneY();

                mouseEvent.setDragDetect(false);

            } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {

                double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
                double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
                mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
                                         deltaY &gt; hysteresisSizeY);

            }
        }

        /**
         * This function is useful for drag gesture recognition from
         * within this Scene (as opposed to in the TK implementation... by the platform)
         */
        private boolean process(MouseEvent mouseEvent, EventTarget target) {
            boolean continueProcessing = true;
            if (!PLATFORM_DRAG_GESTURE_INITIATION) {

                if (dragDetected != DragDetectedState.DONE &amp;&amp;
                        (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
                        mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
                        mouseEvent.isDragDetect()) {

                    processingDragDetected();

                    if (target != null) {
                        final MouseEvent detectedEvent = mouseEvent.copyFor(
                                mouseEvent.getSource(), target,
                                MouseEvent.DRAG_DETECTED);

                        try {
                            fireEvent(target, detectedEvent);
                        } finally {
                            // Putting data to dragboard finished, restrict access to them
                            if (dragboard != null) {
                                DragboardHelper.setDataAccessRestriction(
                                        dragboard, true);
                            }
                        }
                    }

                    dragDetectedProcessed();
                }

                if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    continueProcessing = false;
                }
            }
            return continueProcessing;
        }

        /*
         * Called when a drag source is recognized. This occurs at the very start of
         * the publicly visible drag and drop API, as it is responsible for calling
         * the Node.onDragSourceRecognized function.
         */
        private boolean processRecognized(DragEvent de) {
            MouseEvent me = new MouseEvent(
                    MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
                    de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
                    false, false, false, false, false, true, false, false, false,
                    false, de.getPickResult());

            processingDragDetected();

            final EventTarget target = de.getPickResult().getIntersectedNode();
            try {
                fireEvent(target != null ? target : Scene.this, me);
            } finally {
                // Putting data to dragboard finished, restrict access to them
                if (dragboard != null) {
                    DragboardHelper.setDataAccessRestriction(
                            dragboard, true);
                }
            }

            dragDetectedProcessed();

            final boolean hasContent = dragboard != null
                    &amp;&amp; !dragboard.getContentTypes().isEmpty();
            return hasContent;
        }

        private void processDropEnd(DragEvent de) {
            if (source == null) {
                System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
                return;
            }

            de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, target, de.getPickResult());

            Event.fireEvent(source, de);

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            // at this point the drag and drop operation is completely over, so we
            // can tell the toolkit that it can clean up if needs be.
            Toolkit.getToolkit().stopDrag(dragboard);
        }

        private TransferMode processTargetEnterOver(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            if (dragboard == null) {
                dragboard = createDragboard(de, false);
            }

            de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
                    dragboard, de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            handleExitEnter(de, tmpTargetWrapper);

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            acceptedTransferMode = de.getAcceptedTransferMode();
            return acceptedTransferMode;
        }

        private void processTargetActionChanged(DragEvent de) {
            // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
//            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
//                de = DragEvent.copy(de.getSource(), pickedNode, source,
//                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
//
//                if (dragboard == null) {
//                    dragboard = createDragboard(de);
//                }
//                dragboard = de.getPlatformDragboard();
//
//                fireEvent(pickedNode, de);
//            }
        }

        private void processTargetExit(DragEvent de) {
            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
            }

            if (currentTargets.size() &gt; 0) {
                potentialTarget = null;
                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);
            }
        }

        private TransferMode processTargetDrop(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    acceptedTransferMode, source, potentialTarget, de.getPickResult());

            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
            }

            handleExitEnter(de, tmpTargetWrapper);

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            target = potentialTarget;

            TransferMode result = de.isDropCompleted() ?
                de.getAcceptedTransferMode() : null;

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            return result;
        }

        private void handleExitEnter(DragEvent e, TargetWrapper target) {
            EventTarget currentTarget =
                    currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;

            if (target.getEventTarget() != currentTarget) {

                target.fillHierarchy(newTargets);

                int i = currentTargets.size() - 1;
                int j = newTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    EventTarget t = currentTargets.get(i);
                    if (potentialTarget == t) {
                        potentialTarget = null;
                    }
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_EXITED_TARGET);
                    Event.fireEvent(t, e);
                }

                potentialTarget = null;
                for (; j &gt;= 0; j--) {
                    EventTarget t = newTargets.get(j);
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
                    Object acceptingObject = e.getAcceptingObject();
                    if (acceptingObject instanceof EventTarget) {
                        potentialTarget = (EventTarget) acceptingObject;
                    }
                    Event.fireEvent(t, e);
                }

                currentTargets.clear();
                currentTargets.addAll(newTargets);
                newTargets.clear();
            }
        }

//        function getIntendedTransferMode(e:MouseEvent):TransferMode {
//            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
//        }

        /*
         * Function that hooks into the key processing code in Scene to handle the
         * situation where a drag and drop event is taking place and the user presses
         * the escape key to cancel the drag and drop operation.
         */
        private boolean processKey(KeyEvent e) {
            //note: this seems not to be called, the DnD cancelation is provided by platform
            if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {

                // cancel drag and drop
                DragEvent de = new DragEvent(
                        source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
                        null, source, null, null);
                if (source != null) {
                    Event.fireEvent(source, de);
                }

                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);

                return false;
            }
            return true;
        }

        /*
         * This starts the drag gesture running, creating the dragboard used for
         * the remainder of this drag and drop operation.
         */
        private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
            if (dragDetected != DragDetectedState.PROCESSING) {
                throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
                        + &quot;outside of DRAG_DETECTED event handler&quot;);
            }

            if (t.isEmpty()) {
                dragboard = null;
            } else if (dragboard == null) {
                dragboard = createDragboard(null, true);
            }

            // The app can see what it puts to dragboard without restriction
            DragboardHelper.setDataAccessRestriction(dragboard, false);

            this.source = source;
            potentialTarget = source;
            sourceTransferModes = t;
            return dragboard;
        }

        /*
         * This starts the full PDR gesture.
         */
        private void startFullPDR(EventTarget source) {
            fullPDRSource = source;
        }

        private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
            Dragboard dragboard = null;
            if (de != null) {
                dragboard = de.getDragboard();
                if (dragboard != null) {
                    return dragboard;
                }
            }
            TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
            return DragboardHelper.createDragboard(dragboardPeer);
        }
    }

    /**
     * State of a drag gesture with regards to DRAG_DETECTED event.
     */
    private enum DragDetectedState {
        NOT_YET,
        PROCESSING,
        DONE
    }

    class DragSourceListener implements TKDragSourceListener {

        @Override
        public void dragDropEnd(double x, double y, double screenX, double screenY,
                                TransferMode transferMode)
        {
            if (dndGesture != null) {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                        transferMode, null, null, null);

                // DRAG_DONE event is delivered to gesture source, it can access
                // its own data without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
                try {
                    dndGesture.processDropEnd(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
                }
                dndGesture = null;
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Mouse Event Handling                                                        *
     *                                                                             *
     ******************************************************************************/

    static class ClickCounter {
        Toolkit toolkit = Toolkit.getToolkit();
        private int count;
        private boolean out;
        private boolean still;
        private Timeline timeout;
        private double pressedX, pressedY;

        private void inc() { count++; }
        private int get() { return count; }
        private boolean isStill() { return still; }

        private void clear() {
            count = 0;
            stopTimeout();
        }

        private void out() {
            out = true;
            stopTimeout();
        }

        private void applyOut() {
            if (out) clear();
            out = false;
        }

        private void moved(double x, double y) {
            if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
                    Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
                out();
                still = false;
            }
        }

        private void start(double x, double y) {
            pressedX = x;
            pressedY = y;
            out = false;

            if (timeout != null) {
                timeout.stop();
            }
            timeout = new Timeline();
            timeout.getKeyFrames().add(
                    new KeyFrame(new Duration(toolkit.getMultiClickTime()),
                            event -&gt; {
                                out = true;
                                timeout = null;
                            }
                    ));
            timeout.play();
            still = true;
        }

        private void stopTimeout() {
            if (timeout != null) {
                timeout.stop();
                timeout = null;
            }
        }
    }

    static class ClickGenerator {
        private ClickCounter lastPress = null;

        private Map&lt;MouseButton, ClickCounter&gt; counters =
                new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
        private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();

        public ClickGenerator() {
            for (MouseButton mb : MouseButton.values()) {
                if (mb != MouseButton.NONE) {
                    counters.put(mb, new ClickCounter());
                }
            }
        }

        private MouseEvent preProcess(MouseEvent e) {
            for (ClickCounter cc : counters.values()) {
                cc.moved(e.getSceneX(), e.getSceneY());
            }

            ClickCounter cc = counters.get(e.getButton());
            boolean still = lastPress != null ? lastPress.isStill() : false;

            if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {

                if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
                if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
                if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }

                cc.applyOut();
                cc.inc();
                cc.start(e.getSceneX(), e.getSceneY());
                lastPress = cc;
            }

            return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(),
                    cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
        }

        private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {

            if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                ClickCounter cc = counters.get(e.getButton());

                target.fillHierarchy(pressedTargets);
                pickedTarget.fillHierarchy(releasedTargets);
                int i = pressedTargets.size() - 1;
                int j = releasedTargets.size() - 1;

                EventTarget clickedTarget = null;
                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
                    clickedTarget = pressedTargets.get(i);
                    i--;
                    j--;
                }

                pressedTargets.clear();
                releasedTargets.clear();

                if (clickedTarget != null &amp;&amp; lastPress != null) {
                    MouseEvent click = new MouseEvent(null, clickedTarget,
                            MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
                            e.getScreenX(), e.getScreenY(), e.getButton(),
                            cc.get(),
                            e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                            e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                            e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
                    Event.fireEvent(clickedTarget, click);
                }
            }
        }
    }

    /**
     * Generates mouse exited event for a node which is going to be removed
     * and its children, where appropriate.
     * @param removing Node which is going to be removed
     */
    void generateMouseExited(Node removing) {
        mouseHandler.handleNodeRemoval(removing);
    }

    class MouseHandler {
        private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
        private boolean pdrInProgress = false;
        private boolean fullPDREntered = false;

        private EventTarget currentEventTarget = null;
        private MouseEvent lastEvent;
        private boolean hover = false;

        private boolean primaryButtonDown = false;
        private boolean secondaryButtonDown = false;
        private boolean middleButtonDown = false;

        private EventTarget fullPDRSource = null;
        private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();

        /* lists needed for enter/exit events generation */
        private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();

        private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRCurrentTarget = null;

        private Cursor currCursor;
        private CursorFrame currCursorFrame;
        private EventQueue queue = new EventQueue();

        private Runnable pickProcess = new Runnable() {

            @Override
            public void run() {
                // Make sure this is run only if the peer is still alive
                // and there is an event to deliver
                if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
                    process(lastEvent, true);
                }
            }
        };

        private void pulse() {
            if (hover &amp;&amp; lastEvent != null) {
                //Shouldn't run user code directly. User can call stage.showAndWait() and block the pulse.
                Platform.runLater(pickProcess);
            }
        }

        private void clearPDREventTargets() {
            pdrInProgress = false;
            currentEventTarget = currentEventTargets.size() &gt; 0
                    ? currentEventTargets.get(0) : null;
            pdrEventTarget.clear();
        }

        public void enterFullPDR(EventTarget gestureSource) {
            fullPDREntered = true;
            fullPDRSource = gestureSource;
            fullPDRCurrentTarget = null;
            fullPDRCurrentEventTargets.clear();
        }

        public void exitFullPDR(MouseEvent e) {
            if (!fullPDREntered) {
                return;
            }
            fullPDREntered = false;
            for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
                EventTarget entered = fullPDRCurrentEventTargets.get(i);
                Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
                        entered, entered,
                        MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                        fullPDRSource, e.getPickResult()));
            }
            fullPDRSource = null;
            fullPDRCurrentEventTargets.clear();
            fullPDRCurrentTarget = null;
        }

        private void handleNodeRemoval(Node removing) {
            if (lastEvent == null) {
                // this can happen only if everything has been exited anyway
                return;
            }


            if (currentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while(trg != removing) {
                    trg = currentEventTargets.get(i++);

                    queue.postEvent(lastEvent.copyFor(trg, trg,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }
                currentEventTargets.subList(0, i).clear();
            }

            if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = fullPDRCurrentEventTargets.get(i++);

                    queue.postEvent(
                            MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, lastEvent.getPickResult()));
                }

                fullPDRCurrentEventTargets.subList(0, i).clear();
            }

            queue.fire();

            if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = pdrEventTargets.get(i++);

                    // trg.setHover(false) - already taken care of
                    // by the code above which sent a mouse exited event
                    ((Node) trg).setPressed(false);
                }
                pdrEventTargets.subList(0, i).clear();

                trg = pdrEventTargets.get(0);
                final PickResult res = pdrEventTarget.getResult();
                if (trg instanceof Node) {
                    pdrEventTarget.setNodeResult(new PickResult((Node) trg,
                            res.getIntersectedPoint(), res.getIntersectedDistance()));
                } else {
                    pdrEventTarget.setSceneResult(new PickResult(null,
                            res.getIntersectedPoint(), res.getIntersectedDistance()),
                            (Scene) trg);
                }
            }
        }

        private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
            if (pickedTarget.getEventTarget() != currentEventTarget ||
                    e.getEventType() == MouseEvent.MOUSE_EXITED) {

                if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    newEventTargets.clear();
                } else {
                    pickedTarget.fillHierarchy(newEventTargets);
                }

                int newTargetsSize = newEventTargets.size();
                int i = currentEventTargets.size() - 1;
                int j = newTargetsSize - 1;
                int k = pdrEventTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
                    i--;
                    j--;
                    k--;
                }

                final int memk = k;
                for (; i &gt;= 0; i--, k--) {
                    final EventTarget exitedEventTarget = currentEventTargets.get(i);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
                         break;
                    }
                    queue.postEvent(e.copyFor(
                            exitedEventTarget, exitedEventTarget,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }

                k = memk;
                for (; j &gt;= 0; j--, k--) {
                    final EventTarget enteredEventTarget = newEventTargets.get(j);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
                        break;
                    }
                    queue.postEvent(e.copyFor(
                            enteredEventTarget, enteredEventTarget,
                            MouseEvent.MOUSE_ENTERED_TARGET));
                }

                currentEventTarget = pickedTarget.getEventTarget();
                currentEventTargets.clear();
                for (j++; j &lt; newTargetsSize; j++) {
                    currentEventTargets.add(newEventTargets.get(j));
                }
            }
            queue.fire();
        }

        private void process(MouseEvent e, boolean onPulse) {
            Toolkit.getToolkit().checkFxUserThread();
            Scene.inMousePick = true;

            cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
            cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());

            boolean gestureStarted = false;
            if (!onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
                    if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                        //old gesture ended and new one started
                        gestureStarted = true;
                        if (!PLATFORM_DRAG_GESTURE_INITIATION) {
                            Scene.this.dndGesture = new DnDGesture();
                        }
                        clearPDREventTargets();
                    }
                } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
                    // gesture ended
                    clearPDREventTargets();
                } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
                    hover = true;
                } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    hover = false;
                }

                primaryButtonDown = e.isPrimaryButtonDown();
                secondaryButtonDown = e.isSecondaryButtonDown();
                middleButtonDown = e.isMiddleButtonDown();
            }

            pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
            PickResult res = tmpTargetWrapper.getResult();
            if (res != null) {
                e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
            }

            if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                tmpTargetWrapper.clear();
            }

            TargetWrapper target;
            if (pdrInProgress) {
                target = pdrEventTarget;
            } else {
                target = tmpTargetWrapper;
            }

            if (gestureStarted) {
                pdrEventTarget.copy(target);
                pdrEventTarget.fillHierarchy(pdrEventTargets);
            }

            if (!onPulse) {
                e = clickGenerator.preProcess(e);
            }

            // enter/exit handling
            handleEnterExit(e, tmpTargetWrapper);

            //deliver event to the target node
            if (Scene.this.dndGesture != null) {
                Scene.this.dndGesture.processDragDetection(e);
            }

            if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (target.getEventTarget() != null) {
                if (e.getEventType() != MouseEvent.MOUSE_ENTERED
                        &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
                        &amp;&amp; !onPulse) {
                    Event.fireEvent(target.getEventTarget(), e);
                }
            }

            if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (!onPulse) {
                clickGenerator.postProcess(e, target, tmpTargetWrapper);
            }

            // handle drag and drop

            if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
                if (Scene.this.dndGesture != null) {
                    if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
                        dndGesture = null;
                    }
                }
            }

            Cursor cursor = target.getCursor();
            if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
                if (cursor == null &amp;&amp; hover) {
                    cursor = Scene.this.getCursor();
                }

                updateCursor(cursor);
                updateCursorFrame();
            }

            if (gestureStarted) {
                pdrInProgress = true;
            }

            if (pdrInProgress &amp;&amp;
                    !(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                clearPDREventTargets();
                exitFullPDR(e);
                // we need to do new picking in case the originally picked node
                // was moved or removed by the event handlers
                pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
                handleEnterExit(e, tmpTargetWrapper);
            }

            lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
            Scene.inMousePick = false;
        }

        private void processFullPDR(MouseEvent e, boolean onPulse) {

            pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
            final PickResult result = fullPDRTmpTargetWrapper.getResult();

            final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();

            // enter/exit handling
            if (eventTarget != fullPDRCurrentTarget) {

                fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);

                int newTargetsSize = fullPDRNewEventTargets.size();
                int i = fullPDRCurrentEventTargets.size() - 1;
                int j = newTargetsSize - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
                        fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
                    Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            exitedEventTarget, exitedEventTarget,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, result));
                }

                for (; j &gt;= 0; j--) {
                    final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
                    Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            enteredEventTarget, enteredEventTarget,
                            MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
                            fullPDRSource, result));
                }

                fullPDRCurrentTarget = eventTarget;
                fullPDRCurrentEventTargets.clear();
                fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
                fullPDRNewEventTargets.clear();
            }
            // done enter/exit handling

            // event delivery
            if (eventTarget != null &amp;&amp; !onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_OVER,
                            fullPDRSource, result));
                }
                if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_RELEASED,
                            fullPDRSource, result));
                }
            }
        }

        private void updateCursor(Cursor newCursor) {
            if (currCursor != newCursor) {
                if (currCursor != null) {
                    currCursor.deactivate();
                }

                if (newCursor != null) {
                    newCursor.activate();
                }

                currCursor = newCursor;
            }
        }

        public void updateCursorFrame() {
            final CursorFrame newCursorFrame =
                    (currCursor != null)
                           ? currCursor.getCurrentFrame()
                           : Cursor.DEFAULT.getCurrentFrame();
            if (currCursorFrame != newCursorFrame) {
                if (Scene.this.peer != null) {
                    Scene.this.peer.setCursor(newCursorFrame);
                }

                currCursorFrame = newCursorFrame;
            }
        }

        private PickResult pickNode(PickRay pickRay) {
            PickResultChooser r = new PickResultChooser();
            Scene.this.getRoot().pickNode(pickRay, r);
            return r.toPickResult();
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Key Event Handling                                                          *
     *                                                                             *
     ******************************************************************************/

    class KeyHandler {
        private void setFocusOwner(final Node value) {
            // Cancel IM composition if there is one in progress.
            // This needs to be done before the focus owner is switched as it
            // generates event that needs to be delivered to the old focus owner.
            if (oldFocusOwner != null) {
                final Scene s = oldFocusOwner.getScene();
                if (s != null) {
                    final TKScene peer = s.getPeer();
                    if (peer != null) {
                        peer.finishInputMethodComposition();
                    }
                }
            }
            focusOwner.set(value);
        }

        private boolean windowFocused;
        protected boolean isWindowFocused() { return windowFocused; }
        protected void setWindowFocused(boolean value) {
            windowFocused = value;
            if (getFocusOwner() != null) {
                getFocusOwner().setFocused(windowFocused);
            }
            if (windowFocused) {
                if (accessible != null) {
                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
                }
            }
        }

        private void windowForSceneChanged(Window oldWindow, Window window) {
            if (oldWindow != null) {
                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
            }

            if (window != null) {
                window.focusedProperty().addListener(sceneWindowFocusedListener);
                setWindowFocused(window.isFocused());
            } else {
                setWindowFocused(false);
            }
        }

        private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());

        private void process(KeyEvent e) {
            final Node sceneFocusOwner = getFocusOwner();
            final EventTarget eventTarget =
                    (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
                                              : Scene.this;

            // send the key event to the current focus owner or to scene if
            // the focus owner is not set
            Event.fireEvent(eventTarget, e);
        }

        private void requestFocus(Node node) {
            if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
                return;
            }
            setFocusOwner(node);
        }
    }
    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/
    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this scene. When replacing the value
     * with a new {@code EventDispatcher}, the new dispatcher should forward
     * events to the replaced dispatcher to keep the scene's default event
     * handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt;
            eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private SceneEventDispatcher internalEventDispatcher;

    // Delegates requests from platform input method to the focused
    // node's one, if any.
    class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
        @Override
        public Point2D getTextLocation(int offset) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getTextLocation(offset);
            } else {
                return new Point2D(0, 0);
            }
        }

        @Override
        public int getLocationOffset(int x, int y) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getLocationOffset(x, y);
            } else {
                return 0;
            }
        }

        @Override
        public void cancelLatestCommittedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                requests.cancelLatestCommittedText();
            }
        }

        @Override
        public String getSelectedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getSelectedText();
            }
            return null;
        }

        @Override
        public int getInsertPositionOffset() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
            }
            return 0;
        }

        @Override
        public String getCommittedText(int begin, int end) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
            }
            return null;
        }

        @Override
        public int getCommittedTextLength() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
            }
            return 0;
        }

        private InputMethodRequests getClientRequests() {
            Node focusOwner = getFocusOwner();
            if (focusOwner != null) {
                return focusOwner.getInputMethodRequests();
            }
            return null;
        }
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this scene. The handler is called when the
     * scene receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this scene. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventHandler(eventType,
                                                        eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this scene. The filter is called when the
     * scene receives an {@code Event} of the specified type during the
     * capturing phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this scene. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such
     * handler specified at a time. This handler is guaranteed to be called
     * first. This is used for registering the user-defined onFoo event
     * handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private SceneEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    final void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private SceneEventDispatcher createInternalEventDispatcher() {
        return new SceneEventDispatcher(this);
    }

    /**
     * Registers the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void addMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .addMnemonic(m);
    }


    /**
     * Unregisters the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void removeMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .removeMnemonic(m);
    }

    final void clearNodeMnemonics(Node node) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                .clearNodeMnemonics(node);
    }


    /**
     * Gets the list of mnemonics for this {@code Scene}.
     *
     * @return the list of mnemonics
     */
    public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getMnemonics();
    }

    /**
     * Gets the list of accelerators for this {@code Scene}.
     *
     * @return the list of accelerators
     */
    public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getAccelerators();
    }

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this scene. The event dispatch
     * chain contains all event dispatchers from the stage to this scene.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this scene
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {
        if (eventDispatcher != null) {
            final EventDispatcher eventDispatcherValue = eventDispatcher.get();
            if (eventDispatcherValue != null) {
                tail = tail.prepend(eventDispatcherValue);
            }
        }

        if (getWindow() != null) {
            tail = getWindow().buildEventDispatchChain(tail);
        }

        return tail;
    }

    /***************************************************************************
     *                                                                         *
     *                             Context Menus                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     * @since JavaFX 2.1
     */

    private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;

    public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return onContextMenuRequested == null ? null : onContextMenuRequested.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
        if (onContextMenuRequested == null) {
            onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onContextMenuRequested&quot;;
                }
            };
        }
        return onContextMenuRequested;
    }

    /***************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;

    public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return onMouseClicked == null ? null : onMouseClicked.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
        if (onMouseClicked == null) {
            onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_CLICKED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseClicked&quot;;
                }
            };
        }
        return onMouseClicked;
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Scene} and then dragged.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;

    public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return onMouseDragged == null ? null : onMouseDragged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
        if (onMouseDragged == null) {
            onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragged&quot;;
                }
            };
        }
        return onMouseDragged;
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;

    public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return onMouseEntered == null ? null : onMouseEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
        if (onMouseEntered == null) {
            onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseEntered&quot;;
                }
            };
        }
        return onMouseEntered;
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;

    public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return onMouseExited == null ? null : onMouseExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
        if (onMouseExited == null) {
            onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseExited&quot;;
                }
            };
        }
        return onMouseExited;
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Scene} but no buttons have been pushed.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;

    public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return onMouseMoved == null ? null : onMouseMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
        if (onMouseMoved == null) {
            onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseMoved&quot;;
                }
            };
        }
        return onMouseMoved;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;

    public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return onMousePressed == null ? null : onMousePressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
        if (onMousePressed == null) {
            onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMousePressed&quot;;
                }
            };
        }
        return onMousePressed;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;

    public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return onMouseReleased == null ? null : onMouseReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
        if (onMouseReleased == null) {
            onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseReleased&quot;;
                }
            };
        }
        return onMouseReleased;
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;

    public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return onDragDetected == null ? null : onDragDetected.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
        if (onDragDetected == null) {
            onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.DRAG_DETECTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDetected&quot;;
                }
            };
        }
        return onDragDetected;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;

    public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return onMouseDragOver == null ? null : onMouseDragOver.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
        if (onMouseDragOver == null) {
            onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragOver&quot;;
                }
            };
        }
        return onMouseDragOver;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;

    public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return onMouseDragReleased == null ? null : onMouseDragReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
        if (onMouseDragReleased == null) {
            onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragReleased&quot;;
                }
            };
        }
        return onMouseDragReleased;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;

    public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return onMouseDragEntered == null ? null : onMouseDragEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
        if (onMouseDragEntered == null) {
            onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragEntered&quot;;
                }
            };
        }
        return onMouseDragEntered;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * exits this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;

    public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return onMouseDragExited == null ? null : onMouseDragExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
        if (onMouseDragExited == null) {
            onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragExited&quot;;
                }
            };
        }
        return onMouseDragExited;
    }


    /***************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;

    public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return onScrollStarted == null ? null : onScrollStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
        if (onScrollStarted == null) {
            onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollStarted&quot;;
                }
            };
        }
        return onScrollStarted;
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;

    public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return onScroll == null ? null : onScroll.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
        if (onScroll == null) {
            onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScroll&quot;;
                }
            };
        }
        return onScroll;
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;

    public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return onScrollFinished == null ? null : onScrollFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
        if (onScrollFinished == null) {
            onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollFinished&quot;;
                }
            };
        }
        return onScrollFinished;
    }

    /**
     * Defines a function to be called when a rotating gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;

    public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return onRotationStarted == null ? null : onRotationStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
        if (onRotationStarted == null) {
            onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationStarted&quot;;
                }
            };
        }
        return onRotationStarted;
    }

    /**
     * Defines a function to be called when user performs a rotating action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;

    public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return onRotate == null ? null : onRotate.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
        if (onRotate == null) {
            onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotate&quot;;
                }
            };
        }
        return onRotate;
    }

    /**
     * Defines a function to be called when a rotating gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;

    public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return onRotationFinished == null ? null : onRotationFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
        if (onRotationFinished == null) {
            onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationFinished&quot;;
                }
            };
        }
        return onRotationFinished;
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;

    public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return onZoomStarted == null ? null : onZoomStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
        if (onZoomStarted == null) {
            onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomStarted&quot;;
                }
            };
        }
        return onZoomStarted;
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;

    public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return onZoom == null ? null : onZoom.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
        if (onZoom == null) {
            onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoom&quot;;
                }
            };
        }
        return onZoom;
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;

    public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return onZoomFinished == null ? null : onZoomFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
        if (onZoomFinished == null) {
            onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomFinished&quot;;
                }
            };
        }
        return onZoomFinished;
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;

    public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return onSwipeUp == null ? null : onSwipeUp.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
        if (onSwipeUp == null) {
            onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_UP, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeUp&quot;;
                }
            };
        }
        return onSwipeUp;
    }

    /**
     * Defines a function to be called when an downward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;

    public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return onSwipeDown == null ? null : onSwipeDown.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
        if (onSwipeDown == null) {
            onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_DOWN, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeDown&quot;;
                }
            };
        }
        return onSwipeDown;
    }

    /**
     * Defines a function to be called when an leftward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;

    public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return onSwipeLeft == null ? null : onSwipeLeft.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
        if (onSwipeLeft == null) {
            onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_LEFT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeLeft&quot;;
                }
            };
        }
        return onSwipeLeft;
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;

    public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return onSwipeRight == null ? null : onSwipeRight.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
        if (onSwipeRight == null) {
            onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeRight&quot;;
                }
            };
        }
        return onSwipeRight;
    }

    /***************************************************************************
     *                                                                         *
     *                            Touch Handling                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;

    public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return onTouchPressed == null ? null : onTouchPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
        if (onTouchPressed == null) {
            onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchPressed&quot;;
                }
            };
        }
        return onTouchPressed;
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;

    public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return onTouchMoved == null ? null : onTouchMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
        if (onTouchMoved == null) {
            onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchMoved&quot;;
                }
            };
        }
        return onTouchMoved;
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;

    public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return onTouchReleased == null ? null : onTouchReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
        if (onTouchReleased == null) {
            onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchReleased&quot;;
                }
            };
        }
        return onTouchReleased;
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;

    public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return onTouchStationary == null ? null : onTouchStationary.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
        if (onTouchStationary == null) {
            onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchStationary&quot;;
                }
            };
        }
        return onTouchStationary;
    }

    /*
     * This class provides reordering and ID mapping of particular touch points.
     * Platform may report arbitrary touch point IDs and they may be reused
     * during one gesture. This class keeps track of it and provides
     * sequentially sorted IDs, unique in scope of a gesture.
     *
     * Some platforms report always small numbers, these take fast paths through
     * the algorithm, directly indexing an array. Bigger numbers take a slow
     * path using a hash map.
     *
     * The algorithm performance was measured and it doesn't impose
     * any significant slowdown on the event delivery.
     */
    private static class TouchMap {
        private static final int FAST_THRESHOLD = 10;
        int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
        List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
        List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
        int counter = 0;
        int active = 0;

        public int add(long id) {
            counter++;
            active++;
            if (id &lt; FAST_THRESHOLD) {
                fastMap[(int) id] = counter;
            } else {
                slowMap.put(id, counter);
            }
            order.add(counter);
            return counter;
        }

        public void remove(long id) {
            // book the removal - it needs to be done after all touch points
            // of an event are processed - see cleanup()
            removed.add(id);
        }

        public int get(long id) {
            if (id &lt; FAST_THRESHOLD) {
                int result = fastMap[(int) id];
                if (result == 0) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
                return result;
            } else {
                try {
                    return slowMap.get(id);
                } catch (NullPointerException e) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
            }
        }

        public int getOrder(int id) {
            return order.indexOf(id);
        }

        // returns true if gesture finished (no finger is touched)
        public boolean cleanup() {
            for (long id : removed) {
                active--;
                order.remove(Integer.valueOf(get(id)));
                if (id &lt; FAST_THRESHOLD) {
                    fastMap[(int) id] = 0;
                } else {
                    slowMap.remove(id);
                }
                if (active == 0) {
                    // gesture finished
                    counter = 0;
                }
            }
            removed.clear();
            return active == 0;
        }
    }


    /***************************************************************************
     *                                                                         *
     *                         Drag and Drop Handling                          *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;

    public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return onDragEntered == null ? null : onDragEntered.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Scene}.
     * @return function to be called when drag gesture enters this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
        if (onDragEntered == null) {
            onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragEntered&quot;;
                }
            };
        }
        return onDragEntered;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;

    public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return onDragExited == null ? null : onDragExited.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Scene}.
     * @return the function to be called when drag gesture exits this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
        if (onDragExited == null) {
            onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragExited&quot;;
                }
            };
        }
        return onDragExited;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;

    public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return onDragOver == null ? null : onDragOver.get();
    }

    /**
     * Defines a function to be called when drag gesture progresses
     * within this {@code Scene}.
     * @return the function to be called when drag gesture progresses within
     * this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
        if (onDragOver == null) {
            onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragOver&quot;;
                }
            };
        }
        return onDragOver;
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
//
//    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
//    }
//
//    /**
//     * Defines a function to be called this {@code Scene} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
//        if (onDragTransferModeChanged == null) {
//            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
//
//                @Override
//                protected void invalidated() {
//                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
//                }
//            };
//        }
//        return onDragTransferModeChanged;
//    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;

    public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return onDragDropped == null ? null : onDragDropped.get();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Scene} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the function to be called when the mouse button is released on
     * this scene during drag and drop gesture
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
        if (onDragDropped == null) {
            onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DROPPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDropped&quot;;
                }
            };
        }
        return onDragDropped;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;

    public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return onDragDone == null ? null : onDragDone.get();
    }

    /**
     * Defines a function to be called when this {@code Scene} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * Positional data for the {@code DragEvent} is invalid.  Valid positional
     * data for the {@code DragEvent} is presented in the
     * {@link #onDragDroppedProperty() onDragDropped} event handler.
     * @return the function to be called when this scene is a drag and drop
     * gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
        if (onDragDone == null) {
            onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DONE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDone&quot;;
                }
            };
        }
        return onDragDone;
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Scene}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Scene}'s data on the
     * {@link Dragboard} also identifies this {@code Scene} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Scene}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        return startDragAndDrop(this, transferModes);
    }

    /**
     * Starts a full press-drag-release gesture with this scene as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        startFullDrag(this);
    }


    Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture == null ||
            (dndGesture.dragDetected != DragDetectedState.PROCESSING))
        {
            throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
        for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
            set.add(tm);
        }
        return dndGesture.startDrag(source, set);
    }

    void startFullDrag(EventTarget source) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
            throw new IllegalStateException(&quot;Cannot start full drag &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        if (dndGesture != null) {
            dndGesture.startFullPDR(source);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag when &quot;
                + &quot;mouse button is not pressed&quot;);
    }

    /***************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;

    public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return onKeyPressed == null ? null : onKeyPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
        if (onKeyPressed == null) {
            onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyPressed&quot;;
                }
            };
        }
        return onKeyPressed;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;

    public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return onKeyReleased == null ? null : onKeyReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
        if (onKeyReleased == null) {
            onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyReleased&quot;;
                }
            };
        }
        return onKeyReleased;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set( value);

    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
            ) {
        return onKeyTyped == null ? null : onKeyTyped.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
    ) {
        if (onKeyTyped == null) {
            onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_TYPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyTyped&quot;;
                }
            };
        }
        return onKeyTyped;
    }

    /***************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     */
    private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set( value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
        return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
        if (onInputMethodTextChanged == null) {
            onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onInputMethodTextChanged&quot;;
                }
            };
        }
        return onInputMethodTextChanged;
    }

    /*
     * This class represents a picked target - either node, or scne, or null.
     * It provides functionality needed for the targets and covers the fact
     * that they are different kinds of animals.
     */
    private static class TargetWrapper {
        private Scene scene;
        private Node node;
        private PickResult result;

        /**
         * Fills the list with the target and all its parents (including scene)
         */
        public void fillHierarchy(final List&lt;EventTarget&gt; list) {
            list.clear();
            Node n = node;
            while(n != null) {
                list.add(n);
                final Parent p = n.getParent();
                n = p != null ? p : n.getSubScene();
            }

            if (scene != null) {
                list.add(scene);
            }
        }

        public EventTarget getEventTarget() {
            return node != null ? node : scene;
        }

        public Cursor getCursor() {
            Cursor cursor = null;
            if (node != null) {
                cursor = node.getCursor();
                Node n = node.getParent();
                while (cursor == null &amp;&amp; n != null) {
                    cursor = n.getCursor();

                    final Parent p = n.getParent();
                    n = p != null ? p : n.getSubScene();
                }
            }
            return cursor;
        }

        public void clear() {
            set(null, null);
            result = null;
        }

        public void setNodeResult(PickResult result) {
            if (result != null) {
                this.result = result;
                final Node n = result.getIntersectedNode();
                set(n, n.getScene());
            }
        }

        // Pass null scene if the mouse is outside of the window content
        public void setSceneResult(PickResult result, Scene scene) {
            if (result != null) {
                this.result = result;
                set(null, scene);
            }
        }

        public PickResult getResult() {
            return result;
        }

        public void copy(TargetWrapper tw) {
            node = tw.node;
            scene = tw.scene;
            result = tw.result;
        }

        private void set(Node n, Scene s) {
            node = n;
            scene = s;
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this scene
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      *
      * @since JavaFX 8u40
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Scene has properties.
     * @return true if node has properties.
     *
     * @since JavaFX 8u40
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Scene#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Scene#getUserData()}.
     *
     * @since JavaFX 8u40
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     *
     * @since JavaFX 8u40
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private static final NodeOrientation defaultNodeOrientation =
        AccessController.doPrivileged(
                (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;



    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private NodeOrientation effectiveNodeOrientation;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
    }

    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
                @Override
                protected void invalidated() {
                    sceneEffectiveOrientationInvalidated();
                    getRoot().applyCss();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not yet supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }
            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        if (effectiveNodeOrientation == null) {
            effectiveNodeOrientation = calcEffectiveNodeOrientation();
        }

        return effectiveNodeOrientation;
    }

    /**
     * The effective node orientation of a scene resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the effective node orientation of this scene
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    private void parentEffectiveOrientationInvalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            sceneEffectiveOrientationInvalidated();
        }
    }

    private void sceneEffectiveOrientationInvalidated() {
        effectiveNodeOrientation = null;

        if (effectiveNodeOrientationProperty != null) {
            effectiveNodeOrientationProperty.invalidate();
        }

        getRoot().parentResolvedOrientationInvalidated();
    }

    private NodeOrientation calcEffectiveNodeOrientation() {
        NodeOrientation orientation = getNodeOrientation();
        if (orientation == NodeOrientation.INHERIT) {
            Window window = getWindow();
            if (window != null) {
                Window parent = null;
                if (window instanceof Stage) {
                    parent = ((Stage)window).getOwner();
                } else {
                    if (window instanceof PopupWindow) {
                        parent = ((PopupWindow)window).getOwnerWindow();
                    }
                }
                if (parent != null) {
                    Scene scene = parent.getScene();
                    if (scene != null) return scene.getEffectiveNodeOrientation();
                }
            }
            return NodeOrientation.LEFT_TO_RIGHT;
        }
        return orientation;
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Scene.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    private Map&lt;Node, Accessible&gt; accMap;
    Accessible removeAccessible(Node node) {
        if (accMap == null) return null;
        return accMap.remove(node);
    }

    void addAccessible(Node node, Accessible acc) {
        if (accMap == null) {
            accMap = new HashMap&lt;Node, Accessible&gt;();
        }
        accMap.put(node, acc);
    }

    private void disposeAccessibles() {
        if (accMap != null) {
            for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
                Node node = entry.getKey();
                Accessible acc = entry.getValue();
                if (node.accessible != null) {
                    /* This node has already been initialized to another scene.
                     * Note an accessible can be returned to the node before the
                     * pulse if getAccessible() is called. In which case it must
                     * already being removed from accMap.
                     */
                    if (node.accessible == acc) {
                        System.err.println(&quot;[A11y] 'node.accessible == acc' should never happen.&quot;);
                    }
                    if (node.getScene() == this) {
                        System.err.println(&quot;[A11y] 'node.getScene() == this' should never happen.&quot;);
                    }
                    acc.dispose();
                } else {
                    if (node.getScene() == this) {
                        node.accessible = acc;
                    } else {
                        acc.dispose();
                    }
                }
            }
            accMap.clear();
        }
    }

    private Accessible accessible;
    Accessible getAccessible() {
        /*
         * The accessible for the Scene should never be
         * requested when the peer is not set.
         * This can only happen in a error case where a
         * descender of this Scene was not disposed and
         * it still being used by the AT client and trying
         * to reach to the top level window.
         */
        if (peer == null) return null;
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @Override public AccessControlContext getAccessControlContext() {
                    return getPeer().getAccessControlContext();
                }

                @Override public Object getAttribute(AccessibleAttribute attribute,
                                                     Object... parameters) {
                    switch (attribute) {
                        case CHILDREN: {
                            Parent root = getRoot();
                            if (root != null) {
                                return FXCollections.observableArrayList(root);
                            }
                            break;
                        }
                        case TEXT: {
                            Window w = getWindow();
                            if (w instanceof Stage) {
                                return ((Stage)w).getTitle();
                            }
                            break;
                        }
                        case NODE_AT_POINT: {
                            Window window = getWindow();
                            /* is this screen to scene translation correct ? not considering camera ? */
                            Point2D pt = (Point2D)parameters[0];
                            PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
                            if (res != null) {
                                Node node = res.getIntersectedNode();
                                if (node != null) return node;
                            }
                            return getRoot();//not sure
                        }
                        case ROLE: return AccessibleRole.PARENT;
                        case SCENE: return Scene.this;
                        case FOCUS_NODE: {
                            if (transientFocusContainer != null) {
                                return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
                            }
                            return getFocusOwner();
                        }
                        default:
                    }
                    return super.getAttribute(attribute, parameters);
                }
            });
            PlatformImpl.accessibilityActiveProperty().set(true);
        }
        return accessible;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/theme/RenderThemeImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.theme;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.geometry.Orientation;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.Control;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.RadioButton;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Region;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.webkit.Accessor;
import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.graphics.Ref;
import com.sun.webkit.graphics.RenderTheme;
import com.sun.webkit.graphics.WCGraphicsContext;
import com.sun.webkit.graphics.WCSize;
import javafx.application.Application;

public final class RenderThemeImpl extends RenderTheme {
    private final static PlatformLogger log = PlatformLogger.getLogger(RenderThemeImpl.class.getName());

    enum WidgetType {
        TEXTFIELD      (0),
        BUTTON         (1),
        CHECKBOX       (2),
        RADIOBUTTON    (3),
        MENULIST       (4),
        MENULISTBUTTON (5),
        SLIDER         (6),
        PROGRESSBAR    (7),
        METER          (8),
        SCROLLBAR      (9);

        private static final HashMap&lt;Integer, WidgetType&gt; map = new HashMap&lt;Integer, WidgetType&gt;();
        private final int value;

        private WidgetType(int value) { this.value = value; }

        static { for (WidgetType v: values()) map.put(v.value, v); }

        private static WidgetType convert(int index) { return map.get(index); }
    };

    private Accessor accessor;
    private boolean isDefault; // indicates if the instance is used in non-page context

    private Pool&lt;FormControl&gt; pool;

    /**
     * A pool of controls.
     * Based on a hash map where a control is the value and its ID is the key.
     * The pool size is limited. When a new control is added to the pool and
     * the limit is reached, a control which is used most rarely is removed.
     */
    static final class Pool&lt;T extends Widget&gt; {
        private static final int INITIAL_CAPACITY = 100;

        private int capacity = INITIAL_CAPACITY;

        // A map of control IDs used to track the rate of accociated controls
        // based on their &quot;popularity&quot;.
        // Maps an ID to an updateContentCycleID corresponding to the cycle
        // at which the control was added to the pool.
        private final LinkedHashMap&lt;Long, Integer&gt; ids = new LinkedHashMap&lt;&gt;();

        // A map b/w the IDs and associated controls.
        // The {@code ids} map is kept in sync with the set of keys.
        private final Map&lt;Long, WeakReference&lt;T&gt;&gt; pool = new HashMap&lt;&gt;();

        private final Notifier&lt;T&gt; notifier;
        private final String type; // used for logging

        /**
         * An interface used to notify the implementor of removal
         * of a control from the pool.
         */
        interface Notifier&lt;T&gt; {
            public void notifyRemoved(T control);
        }

        Pool(Notifier&lt;T&gt; notifier, Class&lt;T&gt; type) {
            this.notifier = notifier;
            this.type = type.getSimpleName();
        }

        T get(long id) {
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;type: {0}, size: {1}, id: 0x{2}&quot;,
                        new Object[] {type, pool.size(), Long.toHexString(id)});
            }
            assert ids.size() == pool.size();

            WeakReference&lt;T&gt; controlRef = pool.get(id);
            if (controlRef == null) {
                return null;
            }

            T control = controlRef.get();
            if (control == null) {
                return null;
            }

            // &quot;Bubble&quot; the id.
            Integer value = ids.remove(Long.valueOf(id));
            ids.put(id, value);

            return control;
        }

        void put(long id, T control, int updateContentCycleID) {
            if (log.isLoggable(Level.FINEST)) {
                log.finest(&quot;size: {0}, id: 0x{1}, control: {2}&quot;,
                        new Object[] {pool.size(), Long.toHexString(id), control.getType()});
            }
            if (ids.size() &gt;= capacity) {
                // Pull a control from the bottom of the map, least used.
                Long _id = ids.keySet().iterator().next();
                Integer cycleID = ids.get(_id);
                // Remove that &quot;unpopular&quot; control in case it wasn't added
                // during the current update cycle.
                if (cycleID != updateContentCycleID) {
                    ids.remove(_id);
                    T _control = pool.remove(_id).get();
                    if (_control != null) {
                        notifier.notifyRemoved(_control);
                    }
                // Otherwise, double the pool capacity.
                } else {
                    capacity = Math.min(capacity, (int)Math.ceil(Integer.MAX_VALUE/2)) * 2;
                }
            }
            ids.put(id, updateContentCycleID);
            pool.put(id, new WeakReference&lt;T&gt;(control));
        }

        void clear() {
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;size: &quot; + pool.size() + &quot;, controls: &quot; + pool.values());
            }
            if (pool.size() == 0) {
                return;
            }
            ids.clear();
            for (WeakReference&lt;T&gt; controlRef : pool.values()) {
                T control = controlRef.get();
                if (control != null) {
                    notifier.notifyRemoved(control);
                }
            }
            pool.clear();
            capacity = INITIAL_CAPACITY;
        }
    }

    static class ViewListener implements InvalidationListener {
        private final Pool pool;
        private final Accessor accessor;
        private LoadListenerClient loadListener;

        ViewListener(Pool pool, Accessor accessor) {
            this.pool = pool;
            this.accessor = accessor;
        }

        @Override public void invalidated(Observable ov) {
            pool.clear(); // clear the pool when WebView changes

            // Add the LoadListenerClient when the page is available.
            if (accessor.getPage() != null &amp;&amp; loadListener == null) {
                loadListener = new LoadListenerClient() {
                    @Override
                    public void dispatchLoadEvent(long frame, int state, String url,
                                                  String contentType, double progress, int errorCode)
                    {
                        if (state == LoadListenerClient.PAGE_STARTED) {
                            // An html page with new content is being loaded.
                            // Clear the controls associated with the previous html page.
                            pool.clear();
                        }
                    }
                    @Override
                    public void dispatchResourceLoadEvent(long frame, int state, String url,
                                                          String contentType, double progress,
                                                          int errorCode) {}
                };
                accessor.getPage().addLoadListenerClient(loadListener);
            }
        }
    }

    public RenderThemeImpl(final Accessor accessor) {
        this.accessor = accessor;
        pool = new Pool&lt;FormControl&gt;(fc -&gt; {
            // Remove the control from WebView when it's removed from the pool.
            accessor.removeChild(fc.asControl());
        }, FormControl.class);
        accessor.addViewListener(new ViewListener(pool, accessor));
    }

    public RenderThemeImpl() {
        isDefault = true;
    }

    private void ensureNotDefault() {
        if (isDefault) {
            throw new IllegalStateException(&quot;the method should not be called in this context&quot;);
        }
    }

    @Override
    protected Ref createWidget(
        long id,
        int widgetIndex,
        int state,
        int w, int h,
        int bgColor,
        ByteBuffer extParams)
    {
        ensureNotDefault();

        FormControl fc = pool.get(id);
        WidgetType type = WidgetType.convert(widgetIndex);

        if (fc == null || fc.getType() != type) {
            if (fc  != null) {
                // Remove the unmatching control.
                accessor.removeChild(fc.asControl());
            }
            switch (type) {
                case TEXTFIELD:
                    fc = new FormTextField();
                    break;
                case BUTTON:
                    fc = new FormButton();
                    break;
                case CHECKBOX:
                    fc = new FormCheckBox();
                    break;
                case RADIOBUTTON:
                    fc = new FormRadioButton();
                    break;
                case MENULIST:
                    fc = new FormMenuList();
                    break;
                case MENULISTBUTTON:
                    fc = new FormMenuListButton();
                    break;
                case SLIDER:
                    fc = new FormSlider();
                    break;
                case PROGRESSBAR:
                    fc = new FormProgressBar(WidgetType.PROGRESSBAR);
                    break;
                case METER:
                    fc = new FormProgressBar(WidgetType.METER);
                    break;
                default:
                    log.severe(&quot;unknown widget index: {0}&quot;, widgetIndex);
                    return null;
            }
            fc.asControl().setFocusTraversable(false);
            pool.put(id, fc, accessor.getPage().getUpdateContentCycleID()); // put or replace the entry
            accessor.addChild(fc.asControl());
        }

        fc.setState(state);
        Control ctrl = fc.asControl();
        if (ctrl.getWidth() != w || ctrl.getHeight() != h) {
            ctrl.resize(w, h);
        }
        if (ctrl.isManaged()) {
            ctrl.setManaged(false);
        }

        if (extParams != null) {
            if (type == WidgetType.SLIDER) {
                Slider slider = (Slider)ctrl;
                extParams.order(ByteOrder.nativeOrder());
                slider.setOrientation(extParams.getInt()==0
                    ? Orientation.HORIZONTAL
                    : Orientation.VERTICAL);
                slider.setMax(extParams.getFloat());
                slider.setMin(extParams.getFloat());
                slider.setValue(extParams.getFloat());
            } else if (type == WidgetType.PROGRESSBAR) {
                ProgressBar progress = (ProgressBar)ctrl;
                extParams.order(ByteOrder.nativeOrder());
                progress.setProgress(extParams.getInt() == 1
                        ? extParams.getFloat()
                        : progress.INDETERMINATE_PROGRESS);
            } else if (type == WidgetType.METER) {
                ProgressBar progress = (ProgressBar) ctrl;
                extParams.order(ByteOrder.nativeOrder());
                progress.setProgress(extParams.getFloat());
                progress.setStyle(getMeterStyle(extParams.getInt()));
            }
        }
        return new FormControlRef(fc);
    }

    private String getMeterStyle(int region) {
        // see GaugeRegion in HTMLMeterElement.h
        switch (region) {
            case 1: // GaugeRegionSuboptimal
                return &quot;-fx-accent: yellow&quot;;
            case 2: // GaugeRegionEvenLessGood
                return &quot;-fx-accent: red&quot;;
            default: // GaugeRegionOptimum
                return &quot;-fx-accent: green&quot;;
        }
    }

    @Override
    public void drawWidget(
        WCGraphicsContext g,
        final Ref widget,
        int x, int y)
    {
        ensureNotDefault();

        FormControl fcontrol = ((FormControlRef) widget).asFormControl();
        if (fcontrol != null) {
            Control control = fcontrol.asControl();
            if (control != null) {
                g.saveState();
                g.translate(x, y);
                Renderer.getRenderer().render(control, g);
                g.restoreState();
            }
        }
    }

    @Override
    public WCSize getWidgetSize(Ref widget) {
        ensureNotDefault();

        FormControl fcontrol = ((FormControlRef)widget).asFormControl();
        if (fcontrol != null) {
            Control control = fcontrol.asControl();
            return new WCSize((float)control.getWidth(), (float)control.getHeight());
        }
        return new WCSize(0, 0);
    }

    @Override
    protected int getRadioButtonSize() {
        String style = Application.getUserAgentStylesheet();
        if (Application.STYLESHEET_MODENA.equalsIgnoreCase(style)) {
            return 20; // 18 + 2; size + focus outline
        } else if (Application.STYLESHEET_CASPIAN.equalsIgnoreCase(style)) {
            return 19; // 16 + 3; size + focus outline
        }
        return 20;
    }

    // TODO: get theme value
    @Override
    protected int getSelectionColor(int index) {
        switch (index) {
            case BACKGROUND: return 0xff0093ff;
            case FOREGROUND: return 0xffffffff;
            default: return 0;
        }
    }

    private static boolean hasState(int state, int mask) {
        return (state &amp; mask) != 0;
    }

    private static final class FormControlRef extends Ref {
        private final WeakReference&lt;FormControl&gt; fcRef;

        private FormControlRef(FormControl fc) {
            this.fcRef = new WeakReference&lt;FormControl&gt;(fc);
        }

        private FormControl asFormControl() {
            return fcRef.get();
        }
    }

    interface Widget {
        public WidgetType getType();
    }

    private interface FormControl extends Widget {
        public Control asControl();
        public void setState(int state);
    }

    private static final class FormButton extends Button implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setPressed(hasState(state, RenderTheme.PRESSED));
            if (isPressed()) arm(); else disarm();
        }

        @Override public WidgetType getType() { return WidgetType.BUTTON; };
    }

    private static final class FormTextField extends TextField implements FormControl {

        private FormTextField() {
            setStyle(&quot;-fx-display-caret: false&quot;);
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setEditable(hasState(state, RenderTheme.READ_ONLY));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.TEXTFIELD; };
    }

    private static final class FormCheckBox extends CheckBox implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setSelected(hasState(state, RenderTheme.CHECKED));
        }

        @Override public WidgetType getType() { return WidgetType.CHECKBOX; };
    }

    private static final class FormRadioButton extends RadioButton implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setSelected(hasState(state, RenderTheme.CHECKED));
        }

        @Override public WidgetType getType() { return WidgetType.RADIOBUTTON; };
    }

    private static final class FormSlider extends Slider implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.SLIDER; };
    }

    private static final class FormProgressBar extends ProgressBar implements FormControl {
        private final WidgetType type;

        private FormProgressBar(WidgetType type) {
            this.type = type;
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return type; };
    }

    private static final class FormMenuList extends ChoiceBox implements FormControl {
<A NAME="33"></A>
        private FormMenuList() {
            // Adding a dummy item to please ChoiceBox.
            <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#33',2,'match34-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>List&lt;String&gt; l = new ArrayList&lt;String&gt;();
            l.add(&quot;&quot;);
            setItems(FXCollections.observableList(l));
        }

        @Override public Control asControl() {</B></FONT> return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.MENULIST; };
    }

    private static final class FormMenuListButton extends Button implements FormControl {

        private static final int MAX_WIDTH = 20;
        private static final int MIN_WIDTH = 16;

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setHover(hasState(state, RenderTheme.HOVERED));
            setPressed(hasState(state, RenderTheme.PRESSED));
            if (isPressed()) arm(); else disarm();
        }

        private FormMenuListButton() {
            setSkin(new Skin());
            setFocusTraversable(false);
            getStyleClass().add(&quot;form-select-button&quot;);
        }

        /**
         * @param height is the height of the FormMenuList widget
         * @param width is passed equal to height
         */
        @Override public void resize(double width, double height) {
            width = height &gt; MAX_WIDTH ? MAX_WIDTH : height &lt; MIN_WIDTH ? MIN_WIDTH : height;

            super.resize(width, height);

            // [x] is originally aligned with the right edge of
            // the menulist control, and here we adjust it
            setTranslateX(-width);
        }

        private final class Skin extends SkinBase {
            Skin() {
                super(FormMenuListButton.this);

                Region arrow = new Region();
                arrow.getStyleClass().add(&quot;arrow&quot;);
                arrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
                BorderPane pane = new BorderPane();
                pane.setCenter(arrow);
                getChildren().add(pane);
            }
        }

        @Override public WidgetType getType() { return WidgetType.MENULISTBUTTON; };
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/javafx/scene/web/HTMLEditorSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.web;

import java.util.ResourceBundle;

import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;
import javafx.css.PseudoClass;
import javafx.geometry.Orientation;
import org.w3c.dom.html.HTMLDocument;
import org.w3c.dom.html.HTMLElement;

import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.css.StyleableProperty;
import javafx.geometry.NodeOrientation;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.Separator;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.ToolBar;
import javafx.scene.control.Tooltip;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Priority;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.util.Callback;

import com.sun.javafx.scene.control.skin.FXVK;
import com.sun.javafx.scene.web.behavior.HTMLEditorBehavior;
import com.sun.webkit.WebPage;
import com.sun.javafx.webkit.Accessor;

import java.security.AccessController;
import java.security.PrivilegedAction;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.collections.ListChangeListener;

import static javafx.geometry.NodeOrientation.*;
import javafx.print.PrinterJob;

import static javafx.scene.web.HTMLEditorSkin.Command.*;

/**
 * HTML editor skin.
 *
 * @see HTMLEditor
 * @since 9
 */
public class HTMLEditorSkin extends SkinBase&lt;HTMLEditor&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private GridPane gridPane;

    private ToolBar toolbar1;
    private ToolBar toolbar2;

    private Button cutButton;
    private Button copyButton;
    private Button pasteButton;

//    private Button undoButton;
//    private Button redoButton;

    private Button insertHorizontalRuleButton;

    private ToggleGroup alignmentToggleGroup;
    private ToggleButton alignLeftButton;
    private ToggleButton alignCenterButton;
    private ToggleButton alignRightButton;
    private ToggleButton alignJustifyButton;

    private ToggleButton bulletsButton;
    private ToggleButton numbersButton;

    private Button indentButton;
    private Button outdentButton;

    private ComboBox&lt;String&gt; formatComboBox;
    private Map&lt;String, String&gt; formatStyleMap;
    private Map&lt;String, String&gt; styleFormatMap;

    private ComboBox&lt;String&gt; fontFamilyComboBox;

    private ComboBox&lt;String&gt; fontSizeComboBox;
    private Map&lt;String, String&gt; fontSizeMap;
    private Map&lt;String, String&gt; sizeFontMap;

    private ToggleButton boldButton;
    private ToggleButton italicButton;
    private ToggleButton underlineButton;
    private ToggleButton strikethroughButton;

    private ColorPicker fgColorButton;
    private ColorPicker bgColorButton;

    private WebView webView;
    private WebPage webPage;

    private ParentTraversalEngine engine;

    private boolean resetToolbarState = false;
    private String cachedHTMLText = &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body contenteditable=\&quot;true\&quot;&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
    private ResourceBundle resources;

    private boolean enableAtomicityCheck = false;
    private int atomicityCount = 0;
    private boolean isFirstRun = true;

    private static final int FONT_FAMILY_MENUBUTTON_WIDTH = 150;
    private static final int FONT_FAMILY_MENU_WIDTH = 100;
    private static final int FONT_SIZE_MENUBUTTON_WIDTH = 80;



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final Color DEFAULT_BG_COLOR = Color.WHITE;
    private static final Color DEFAULT_FG_COLOR = Color.BLACK;

    private static final String FORMAT_PARAGRAPH = &quot;&lt;p&gt;&quot;;
    private static final String FORMAT_HEADING_1 = &quot;&lt;h1&gt;&quot;;
    private static final String FORMAT_HEADING_2 = &quot;&lt;h2&gt;&quot;;
    private static final String FORMAT_HEADING_3 = &quot;&lt;h3&gt;&quot;;
    private static final String FORMAT_HEADING_4 = &quot;&lt;h4&gt;&quot;;
    private static final String FORMAT_HEADING_5 = &quot;&lt;h5&gt;&quot;;
    private static final String FORMAT_HEADING_6 = &quot;&lt;h6&gt;&quot;;

    private static final String SIZE_XX_SMALL = &quot;1&quot;;
    private static final String SIZE_X_SMALL = &quot;2&quot;;
    private static final String SIZE_SMALL = &quot;3&quot;;
    private static final String SIZE_MEDIUM = &quot;4&quot;;
    private static final String SIZE_LARGE = &quot;5&quot;;
    private static final String SIZE_X_LARGE = &quot;6&quot;;
    private static final String SIZE_XX_LARGE = &quot;7&quot;;

    // As per RT-16330: default format -&gt; bold/size mappings are as follows:
    private static final String[][] DEFAULT_FORMAT_MAPPINGS = {
        { FORMAT_PARAGRAPH,   &quot;&quot;,                  SIZE_SMALL     },
        { FORMAT_HEADING_1,   BOLD.getCommand(),   SIZE_X_LARGE   },
        { FORMAT_HEADING_2,   BOLD.getCommand(),   SIZE_LARGE     },
        { FORMAT_HEADING_3,   BOLD.getCommand(),   SIZE_MEDIUM    },
        { FORMAT_HEADING_4,   BOLD.getCommand(),   SIZE_SMALL     },
        { FORMAT_HEADING_5,   BOLD.getCommand(),   SIZE_X_SMALL   },
        { FORMAT_HEADING_6,   BOLD.getCommand(),   SIZE_XX_SMALL  },
    };

    private static PseudoClass CONTAINS_FOCUS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;contains-focus&quot;);



    /***************************************************************************
     *                                                                         *
     * Static Methods                                                          *
     *                                                                         *
     **************************************************************************/



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private ListChangeListener&lt;Node&gt; itemsListener = c -&gt; {
        while (c.next()) {
            if (c.getRemovedSize() &gt; 0) {
                for (Node n : c.getList()) {
                    if (n instanceof WebView) {
                        // RT-28611 webView removed - set associated webPage to null
                        webPage.dispose();
                    }
                }
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new HTMLEditorSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public HTMLEditorSkin(HTMLEditor control) {
        super(control);

        // install default input map for the HTMLEditor control
        HTMLEditorBehavior behavior = new HTMLEditorBehavior(control);
//        htmlEditor.setInputMap(behavior.getInputMap());

        getChildren().clear();

        gridPane = new GridPane();
        gridPane.getStyleClass().add(&quot;grid&quot;);
        getChildren().addAll(gridPane);

        toolbar1 = new ToolBar();
        toolbar1.getStyleClass().add(&quot;top-toolbar&quot;);
        gridPane.add(toolbar1, 0, 0);

        toolbar2 = new ToolBar();
        toolbar2.getStyleClass().add(&quot;bottom-toolbar&quot;);
        gridPane.add(toolbar2, 0, 1);

//        populateToolbars();

        webView = new WebView();
        gridPane.add(webView, 0, 2);

        ColumnConstraints column = new ColumnConstraints();
        column.setHgrow(Priority.ALWAYS);
        gridPane.getColumnConstraints().add(column);

        webPage = Accessor.getPageFor(webView.getEngine());

        webView.addEventHandler(MouseEvent.MOUSE_RELEASED, event2 -&gt; {
            Platform.runLater(new Runnable() {
                @Override public void run() {
                    enableAtomicityCheck = true;
                    updateToolbarState(true);
                    enableAtomicityCheck = false;
                }
            });
        });


        webView.addEventHandler(KeyEvent.KEY_PRESSED, event -&gt; {
            applyTextFormatting();
            if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
                return;
            }
            if (event.getCode() == KeyCode.TAB &amp;&amp; !event.isControlDown()) {
                if (!event.isShiftDown()) {
                    /*
                    ** if we are in either Bullet or Numbers mode then the
                    ** TAB key tells us to indent again.
                    */
                    if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
                        executeCommand(INDENT.getCommand(), null);
                    }
                    else {
                        executeCommand(INSERT_TAB.getCommand(), null);
                    }
                }
                else {
                    /*
                    ** if we are in either Bullet or Numbers mode then the
                    ** Shift-TAB key tells us to outdent.
                    */
                    if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
                        executeCommand(OUTDENT.getCommand(), null);
                    }
                }
                return;
            }
            // Work around for bug that sends events from ColorPicker to this Scene
            if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
                (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
                return;
            }
            Platform.runLater(() -&gt; {
                if (webPage.getClientSelectedText().isEmpty()) {
                    if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
                            event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
                            event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
                        updateToolbarState(true);
                    } else if (event.isControlDown() || event.isMetaDown()) {
                        if (event.getCode() == KeyCode.B) {
                            performCommand(BOLD);
                        } else if (event.getCode() == KeyCode.I) {
                            performCommand(ITALIC);
                        } else if (event.getCode() == KeyCode.U) {
                            performCommand(UNDERLINE);
                        }
                        updateToolbarState(true);
                    } else {
                        resetToolbarState = event.getCode() == KeyCode.ENTER;
                        if (resetToolbarState) {
                            if (getCommandState(BOLD.getCommand()) != boldButton.selectedProperty().getValue()) {
                                executeCommand(BOLD.getCommand(), boldButton.selectedProperty().getValue().toString());
                            }
                        }
                        updateToolbarState(false);
                    }
                    resetToolbarState = false;
                } else if (event.isShiftDown() &amp;&amp;
                        (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
                         event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
                         event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END)) {
                    updateToolbarState(true);
                } else if ((event.isControlDown() || event.isMetaDown()) &amp;&amp;
                            event.getCode() == KeyCode.A) {
                    updateToolbarState(true);
                }
            });
        });

        webView.addEventHandler(KeyEvent.KEY_RELEASED, event -&gt; {
            if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
                return;
            }
            // Work around for bug that sends events from ColorPicker to this Scene
            if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
                (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
                return;
            }
            Platform.runLater(() -&gt; {
                if (webPage.getClientSelectedText().isEmpty()) {
                    if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
                            event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
                            event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
                        updateToolbarState(true);
                    } else if (event.isControlDown() || event.isMetaDown()) {
                        if (event.getCode() == KeyCode.B) {
                            performCommand(BOLD);
                        } else if (event.getCode() == KeyCode.I) {
                            performCommand(ITALIC);
                        } else if (event.getCode() == KeyCode.U) {
                            performCommand(UNDERLINE);
                        }
                        updateToolbarState(true);
                    } else {
                        resetToolbarState = event.getCode() == KeyCode.ENTER;
                        if (!resetToolbarState) {
                            updateToolbarState(false);
                        }
                    }
                    resetToolbarState = false;
                }
            });
        });

        getSkinnable().focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            Platform.runLater(new Runnable() {
                @Override public void run() {
                    if (newValue) {
                        webView.requestFocus();
                    }
                }
            });
        });

        webView.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            // disabling as a fix for RT-30081
//                if (newValue) {
//                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_GAINED, WCFocusEvent.FORWARD));
//                    enableToolbar(true);
//                } else {
//                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_LOST, WCFocusEvent.FORWARD));
//                    enableToolbar(false);
//                }

            pseudoClassStateChanged(CONTAINS_FOCUS_PSEUDOCLASS_STATE, newValue);

            Platform.runLater(new Runnable() {
                @Override public void run() {
                    updateToolbarState(true);

                    if (PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
                        Scene scene = getSkinnable().getScene();
                        if (newValue) {
                            FXVK.attach(webView);
                        } else if (scene == null ||
                                   scene.getWindow() == null ||
                                   !scene.getWindow().isFocused() ||
                                   !(scene.getFocusOwner() instanceof TextInputControl /*||
                                     getScene().getFocusOwner() instanceof WebView*/)) {
                            FXVK.detach();
                        }
                    }
                }
            });
        });

        webView.getEngine().getLoadWorker().workDoneProperty().addListener((observable, oldValue, newValue) -&gt; {
            Platform.runLater(() -&gt; {
                webView.requestLayout();
            });

            double totalWork = webView.getEngine().getLoadWorker().getTotalWork();
            if (newValue.doubleValue() == totalWork) {
                cachedHTMLText = null;
                Platform.runLater(() -&gt; {
                    setContentEditable(true);
                    updateToolbarState(true);
                    updateNodeOrientation();
                    executeCommand(STYLEWITHCSS.getCommand(), &quot;true&quot;);
                });
            }
        });

        enableToolbar(true);
        setHTMLText(cachedHTMLText);

        engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                return cutButton;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                return cutButton;
            }

            @Override
            public Node selectLast(TraversalContext context) {
                return cutButton;
            }
        });
        ParentHelper.setTraversalEngine(getSkinnable(), engine);
        webView.setFocusTraversable(true);
        gridPane.getChildren().addListener(itemsListener);
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Special-case handling for certain commands. Over time this may be extended
     * to handle additional commands. The current list of supported commands is:
     *
     * &lt;ul&gt;
     *     &lt;li&gt;BOLD&lt;/li&gt;
     *     &lt;li&gt;ITALIC&lt;/li&gt;
     *     &lt;li&gt;UNDERLINE&lt;/li&gt;
     * &lt;/ul&gt;
     * @param command the command
     */
    public void performCommand(final Command command) {
        switch (command) {
            case BOLD: boldButton.fire(); break;
            case ITALIC: italicButton.setSelected(!italicButton.isSelected()); break;
            case UNDERLINE: underlineButton.setSelected(!underlineButton.isSelected()); break;
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                  final double w, final double h) {

        if (isFirstRun) {
            populateToolbars();
            isFirstRun = false;
        }
        super.layoutChildren(x,y,w,h);
        double toolbarWidth = Math.max(toolbar1.prefWidth(-1), toolbar2.prefWidth(-1));
        toolbar1.setMinWidth(toolbarWidth);
        toolbar1.setPrefWidth(toolbarWidth);
        toolbar2.setMinWidth(toolbarWidth);
        toolbar2.setPrefWidth(toolbarWidth);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    final String getHTMLText() {
        // RT17203 setHTMLText is asynchronous.  We use the cached version of
        // the html text until the page finishes loading.
        return cachedHTMLText != null ? cachedHTMLText : webPage.getHtml(webPage.getMainFrame());
    }

    final void setHTMLText(String htmlText) {
        cachedHTMLText = htmlText;
        webPage.load(webPage.getMainFrame(), htmlText, &quot;text/html&quot;);

        Platform.runLater(() -&gt; {
            updateToolbarState(true);
        });
    }

    private void populateToolbars() {
        resources = ResourceBundle.getBundle(HTMLEditorSkin.class.getName());

        // Toolbar 1
        cutButton = addButton(toolbar1, resources.getString(&quot;cutIcon&quot;), resources.getString(&quot;cut&quot;), CUT.getCommand(), &quot;html-editor-cut&quot;);
        copyButton = addButton(toolbar1, resources.getString(&quot;copyIcon&quot;), resources.getString(&quot;copy&quot;), COPY.getCommand(), &quot;html-editor-copy&quot;);
        pasteButton = addButton(toolbar1, resources.getString(&quot;pasteIcon&quot;), resources.getString(&quot;paste&quot;), PASTE.getCommand(), &quot;html-editor-paste&quot;);

        toolbar1.getItems().add(new Separator(Orientation.VERTICAL));

//        undoButton = addButton(toolbar1, &quot;undoIcon&quot;, resources.getString(&quot;undo&quot;), UNDO.getCommand());
//        redoButton = addButton(toolbar1, &quot;redoIcon&quot;, resources.getString(&quot;redo&quot;), REDO.getCommand());//
//        toolbar1.getItems().add(new Separator());

         alignmentToggleGroup = new ToggleGroup();
         alignLeftButton = addToggleButton(toolbar1, alignmentToggleGroup,
            resources.getString(&quot;alignLeftIcon&quot;), resources.getString(&quot;alignLeft&quot;), ALIGN_LEFT.getCommand(), &quot;html-editor-align-left&quot;);
         alignCenterButton = addToggleButton(toolbar1, alignmentToggleGroup,
            resources.getString(&quot;alignCenterIcon&quot;), resources.getString(&quot;alignCenter&quot;), ALIGN_CENTER.getCommand(), &quot;html-editor-align-center&quot;);
         alignRightButton = addToggleButton(toolbar1, alignmentToggleGroup,
            resources.getString(&quot;alignRightIcon&quot;), resources.getString(&quot;alignRight&quot;), ALIGN_RIGHT.getCommand(), &quot;html-editor-align-right&quot;);
         alignJustifyButton = addToggleButton(toolbar1, alignmentToggleGroup,
            resources.getString(&quot;alignJustifyIcon&quot;), resources.getString(&quot;alignJustify&quot;), ALIGN_JUSTIFY.getCommand(), &quot;html-editor-align-justify&quot;);

        toolbar1.getItems().add(new Separator(Orientation.VERTICAL));

        outdentButton = addButton(toolbar1, resources.getString(&quot;outdentIcon&quot;), resources.getString(&quot;outdent&quot;), OUTDENT.getCommand(), &quot;html-editor-outdent&quot;);
        if (outdentButton.getGraphic() != null) outdentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
        indentButton = addButton(toolbar1, resources.getString(&quot;indentIcon&quot;), resources.getString(&quot;indent&quot;), INDENT.getCommand(), &quot;html-editor-indent&quot;);
        if (indentButton.getGraphic() != null) indentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);

        toolbar1.getItems().add(new Separator(Orientation.VERTICAL));

         ToggleGroup listStyleToggleGroup = new ToggleGroup();
         bulletsButton = addToggleButton(toolbar1, listStyleToggleGroup,
            resources.getString(&quot;bulletsIcon&quot;), resources.getString(&quot;bullets&quot;), BULLETS.getCommand(), &quot;html-editor-bullets&quot;);
         if (bulletsButton.getGraphic() != null) bulletsButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
         numbersButton = addToggleButton(toolbar1, listStyleToggleGroup,
            resources.getString(&quot;numbersIcon&quot;), resources.getString(&quot;numbers&quot;), NUMBERS.getCommand(), &quot;html-editor-numbers&quot;);

        toolbar1.getItems().add(new Separator(Orientation.VERTICAL));

        //toolbar1.getItems().add(new Separator());

        // Toolbar 2
        formatComboBox = new ComboBox&lt;String&gt;();
        formatComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
        formatComboBox.setFocusTraversable(false);
        formatComboBox.setMinWidth(Region.USE_PREF_SIZE);
        toolbar2.getItems().add(formatComboBox);

        formatStyleMap = new HashMap&lt;String, String&gt;();
        styleFormatMap = new HashMap&lt;String, String&gt;();

        createFormatMenuItem(FORMAT_PARAGRAPH, resources.getString(&quot;paragraph&quot;));
        Platform.runLater(() -&gt; {
            formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
        });
        createFormatMenuItem(FORMAT_HEADING_1, resources.getString(&quot;heading1&quot;));
        createFormatMenuItem(FORMAT_HEADING_2, resources.getString(&quot;heading2&quot;));
        createFormatMenuItem(FORMAT_HEADING_3, resources.getString(&quot;heading3&quot;));
        createFormatMenuItem(FORMAT_HEADING_4, resources.getString(&quot;heading4&quot;));
        createFormatMenuItem(FORMAT_HEADING_5, resources.getString(&quot;heading5&quot;));
        createFormatMenuItem(FORMAT_HEADING_6, resources.getString(&quot;heading6&quot;));

//        formatComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
//            @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
//                final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
//                    @Override public void updateItem(String item, boolean empty) {
//                        super.updateItem(item, empty);
//                        if (item != null) {
//                            setText(item);
//                        }
//                    }
//                };
//                return cell;
//            }
//        });

        formatComboBox.setTooltip(new Tooltip(resources.getString(&quot;format&quot;)));

        formatComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (newValue == null) {
                formatComboBox.setValue(null);
            } else {
                String formatValue = formatStyleMap.get(newValue);
                executeCommand(FORMAT.getCommand(), formatValue);
                updateToolbarState(false);

                // RT-16330 match the new font format with the required weight and size
                for (int i = 0; i &lt; DEFAULT_FORMAT_MAPPINGS.length; i++) {
                    String[] mapping = DEFAULT_FORMAT_MAPPINGS[i];
                    if (mapping[0].equalsIgnoreCase(formatValue)) {
                        executeCommand(FONT_SIZE.getCommand(), mapping[2]);
                        updateToolbarState(false);
                        break;
                    }
                }
            }
        });

        fontFamilyComboBox = new ComboBox&lt;String&gt;();
        fontFamilyComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
        fontFamilyComboBox.setMinWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
        fontFamilyComboBox.setPrefWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
        fontFamilyComboBox.setMaxWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
        fontFamilyComboBox.setFocusTraversable(false);
        fontFamilyComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontFamily&quot;)));
        toolbar2.getItems().add(fontFamilyComboBox);

        // Fix for RT-32906, where all rows were being put through the cell factory
        // so that they could be measured. Because we have a fixed width for the
        // button this is unnecessary and so we tell the ComboBox to not measure
        // any rows.
        fontFamilyComboBox.getProperties().put(&quot;comboBoxRowsToMeasureWidth&quot;, 0);

        fontFamilyComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
            @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
                final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
                    @Override public void updateItem(String item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null) {
                            setText(item);
                            setFont(new Font(item, 12));
                        }
                    }
                };
                cell.setMinWidth(FONT_FAMILY_MENU_WIDTH);
                cell.setPrefWidth(FONT_FAMILY_MENU_WIDTH);
                cell.setMaxWidth(FONT_FAMILY_MENU_WIDTH);
                return cell;
            }
        });

        Platform.runLater(() -&gt; {
            final ObservableList&lt;String&gt; fonts = FXCollections.observableArrayList(Font.getFamilies());
            fonts.add(0, &quot;&quot;);
            for (String fontFamily : fonts) {
                fontFamilyComboBox.setValue(&quot;&quot;);
                fontFamilyComboBox.setItems(fonts);
            }
        });

        fontFamilyComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
            executeCommand(FONT_FAMILY.getCommand(), (&quot;&quot;.equals(newValue)) ? &quot;''&quot; : newValue);
        });

        fontSizeComboBox = new ComboBox&lt;String&gt;();
        fontSizeComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
        fontSizeComboBox.setFocusTraversable(false);
        toolbar2.getItems().add(fontSizeComboBox);

        fontSizeMap = new HashMap&lt;String, String&gt;();
        sizeFontMap = new HashMap&lt;String, String&gt;();

        createFontSizeMenuItem(SIZE_XX_SMALL, resources.getString(&quot;extraExtraSmall&quot;));
        createFontSizeMenuItem(SIZE_X_SMALL, resources.getString(&quot;extraSmall&quot;));
        createFontSizeMenuItem(SIZE_SMALL, resources.getString(&quot;small&quot;));
        Platform.runLater(() -&gt; {
            fontSizeComboBox.setValue(resources.getString(&quot;small&quot;));
        });
        createFontSizeMenuItem(SIZE_MEDIUM, resources.getString(&quot;medium&quot;));
        createFontSizeMenuItem(SIZE_LARGE, resources.getString(&quot;large&quot;));
        createFontSizeMenuItem(SIZE_X_LARGE, resources.getString(&quot;extraLarge&quot;));
        createFontSizeMenuItem(SIZE_XX_LARGE, resources.getString(&quot;extraExtraLarge&quot;));
        fontSizeComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontSize&quot;)));

        fontSizeComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
            @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
                final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
                    @Override public void updateItem(String item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null) {
                            setText(item);
                            // Remove trailing non-digits to get the size (don't assume there's a space).
                            String size = item.replaceFirst(&quot;[^0-9.].*$&quot;, &quot;&quot;);
                            setFont(new Font((String)fontFamilyComboBox.getValue(), Double.valueOf(size)));
                        }
                    }
                };
                return cell;
            }
        });


        fontSizeComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
            Object fontSizeValue = getCommandValue(FONT_SIZE.getCommand());
            if (!newValue.equals(fontSizeValue)) {
                executeCommand(FONT_SIZE.getCommand(), fontSizeMap.get(newValue));
            }
        });

        toolbar2.getItems().add(new Separator(Orientation.VERTICAL));

        boldButton = addToggleButton(toolbar2, null,
            resources.getString(&quot;boldIcon&quot;), resources.getString(&quot;bold&quot;), BOLD.getCommand(), &quot;html-editor-bold&quot;);
        boldButton.setOnAction(event1 -&gt; {
            // Only use the bold button for paragraphs.  We don't
            // want to turn bold off for headings.

            if (&quot;&lt;p&gt;&quot;.equals(formatStyleMap.get(formatComboBox.getValue())))  {
                executeCommand(BOLD.getCommand(), boldButton.selectedProperty().getValue().toString());
            }
        });
        italicButton = addToggleButton(toolbar2, null,
            resources.getString(&quot;italicIcon&quot;), resources.getString(&quot;italic&quot;), ITALIC.getCommand(), &quot;html-editor-italic&quot;);
        underlineButton = addToggleButton(toolbar2, null,
            resources.getString(&quot;underlineIcon&quot;), resources.getString(&quot;underline&quot;), UNDERLINE.getCommand(), &quot;html-editor-underline&quot;);
        strikethroughButton = addToggleButton(toolbar2, null,
            resources.getString(&quot;strikethroughIcon&quot;), resources.getString(&quot;strikethrough&quot;), STRIKETHROUGH.getCommand(), &quot;html-editor-strike&quot;);

        toolbar2.getItems().add(new Separator(Orientation.VERTICAL));

        insertHorizontalRuleButton = addButton(toolbar2, resources.getString(&quot;insertHorizontalRuleIcon&quot;),
            resources.getString(&quot;insertHorizontalRule&quot;), INSERT_HORIZONTAL_RULE.getCommand(), &quot;html-editor-hr&quot;);
        // We override setOnAction to insert a new line.  This fixes RT-16453
        insertHorizontalRuleButton.setOnAction(event -&gt; {
            executeCommand(INSERT_NEW_LINE.getCommand(), null);
            executeCommand(INSERT_HORIZONTAL_RULE.getCommand(), null);
            updateToolbarState(false);
        });

        fgColorButton = new ColorPicker();
        fgColorButton.getStyleClass().add(&quot;html-editor-foreground&quot;);
        fgColorButton.setFocusTraversable(false);
        toolbar1.getItems().add(fgColorButton);

        // JDK-8115747: Icon URLs are now specified in CSS.
        // fgColorButton.applyCss();
        // ColorPickerSkin fgColorPickerSkin = (ColorPickerSkin) fgColorButton.getSkin();
        // String fgIcon = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; HTMLEditorSkin.class.getResource(resources.getString(&quot;foregroundColorIcon&quot;)).toString());
        // ((StyleableProperty)fgColorPickerSkin.imageUrlProperty()).applyStyle(null,fgIcon);

        fgColorButton.setValue(DEFAULT_FG_COLOR);
        fgColorButton.setTooltip(new Tooltip(resources.getString(&quot;foregroundColor&quot;)));
        fgColorButton.setOnAction(ev1 -&gt; {
            Color newValue = fgColorButton.getValue();
            if (newValue != null) {
                executeCommand(FOREGROUND_COLOR.getCommand(), colorValueToRGBA(newValue));
                fgColorButton.hide();
            }
        });

        bgColorButton = new ColorPicker();
        bgColorButton.getStyleClass().add(&quot;html-editor-background&quot;);
        bgColorButton.setFocusTraversable(false);
        toolbar1.getItems().add(bgColorButton);

        // JDK-8115747: Icon URLs are now specified in CSS.
        // bgColorButton.applyCss();
        // ColorPickerSkin  bgColorPickerSkin = (ColorPickerSkin) bgColorButton.getSkin();
        // String bgIcon = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; HTMLEditorSkin.class.getResource(resources.getString(&quot;backgroundColorIcon&quot;)).toString());
        // ((StyleableProperty)bgColorPickerSkin.imageUrlProperty()).applyStyle(null,bgIcon);

        bgColorButton.setValue(DEFAULT_BG_COLOR);
        bgColorButton.setTooltip(new Tooltip(resources.getString(&quot;backgroundColor&quot;)));

        bgColorButton.setOnAction(ev -&gt; {
            Color newValue = bgColorButton.getValue();
            if (newValue != null) {
                executeCommand(BACKGROUND_COLOR.getCommand(), colorValueToRGBA(newValue));
                bgColorButton.hide();
            }
        });
    }

    private String colorValueToRGBA(Color c) {
        return String.format((Locale)null, &quot;rgba(%d, %d, %d, %.5f)&quot;,
                             Math.round(c.getRed() * 255),
                             Math.round(c.getGreen() * 255),
                             Math.round(c.getBlue() * 255),
                             c.getOpacity());
    }

    private Button addButton(ToolBar toolbar, final String iconName, String tooltipText,
            final String command, final String styleClass) {
        Button button = new Button();
        button.setFocusTraversable(false);
        button.getStyleClass().add(styleClass);
        toolbar.getItems().add(button);

        Image icon = AccessController.doPrivileged((PrivilegedAction&lt;Image&gt;) () -&gt; new Image(HTMLEditorSkin.class.getResource(iconName).toString()));
//        button.setGraphic(new ImageView(icon));
        ((StyleableProperty)button.graphicProperty()).applyStyle(null, new ImageView(icon));
        button.setTooltip(new Tooltip(tooltipText));

        button.setOnAction(event -&gt; {
            executeCommand(command, null);
            updateToolbarState(false);
        });

        return button;
    }

    private ToggleButton addToggleButton(ToolBar toolbar, ToggleGroup toggleGroup,
            final String iconName, String tooltipText, final String command, final String styleClass) {
        ToggleButton toggleButton = new ToggleButton();
        toggleButton.setUserData(command);
        toggleButton.setFocusTraversable(false);
        toggleButton.getStyleClass().add(styleClass);
        toolbar.getItems().add(toggleButton);
        if (toggleGroup != null) {
            toggleButton.setToggleGroup(toggleGroup);
        }

        Image icon = AccessController.doPrivileged((PrivilegedAction&lt;Image&gt;) () -&gt; new Image(HTMLEditorSkin.class.getResource(iconName).toString()));
        ((StyleableProperty)toggleButton.graphicProperty()).applyStyle(null, new ImageView(icon));
//        toggleButton.setGraphic(new ImageView(icon));

        toggleButton.setTooltip(new Tooltip(tooltipText));

        if (!BOLD.getCommand().equals(command)) {
            toggleButton.selectedProperty().addListener((observable, oldValue, newValue) -&gt; {
                if (getCommandState(command) != newValue.booleanValue()) {
                    executeCommand(command, null);
                }
            });
        }
        return toggleButton;
    }

    private void createFormatMenuItem(String formatValue, String label) {
        formatComboBox.getItems().add(label);
        formatStyleMap.put(label, formatValue);
        styleFormatMap.put(formatValue, label);
    }

    private void createFontSizeMenuItem(String fontSizeValue, String label) {
        fontSizeComboBox.getItems().add(label);
        fontSizeMap.put(label, fontSizeValue);
        sizeFontMap.put(fontSizeValue, label);
    }

    private void updateNodeOrientation() {
        NodeOrientation orientation = getSkinnable().getEffectiveNodeOrientation();

        HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
        HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
        if (htmlDocumentElement.getAttribute(&quot;dir&quot;) == null) {
            htmlDocumentElement.setAttribute(&quot;dir&quot;, (orientation == RIGHT_TO_LEFT) ? &quot;rtl&quot; : &quot;ltr&quot;);
        }

    }

    private void updateToolbarState(final boolean updateAlignment) {
        if (!webView.isFocused()) {
            return;
        }

        atomicityCount++;

        // These command aways return true.
        copyButton.setDisable(!isCommandEnabled(CUT.getCommand()));
        cutButton.setDisable(!isCommandEnabled(COPY.getCommand()));
        pasteButton.setDisable(!isCommandEnabled(PASTE.getCommand()));

        // undoButton.setDisable(!isCommandEnabled(UNDO.getCommand()));
        // redoButton.setDisable(!isCommandEnabled(REDO.getCommand()));

//        undoButton.setDisable(!isCommandEnabled(FORMAT.getCommand()));
//        redoButton.setDisable(!isCommandEnabled(FORMAT.getCommand()));

        insertHorizontalRuleButton.setDisable(!isCommandEnabled(INSERT_HORIZONTAL_RULE.getCommand()));

        if (updateAlignment) {
            alignLeftButton.setDisable(!isCommandEnabled(ALIGN_LEFT.getCommand()));
            alignLeftButton.setSelected(getCommandState(ALIGN_LEFT.getCommand()));
            alignCenterButton.setDisable(!isCommandEnabled(ALIGN_CENTER.getCommand()));
            alignCenterButton.setSelected(getCommandState(ALIGN_CENTER.getCommand()));
            alignRightButton.setDisable(!isCommandEnabled(ALIGN_RIGHT.getCommand()));
            alignRightButton.setSelected(getCommandState(ALIGN_RIGHT.getCommand()));
            alignJustifyButton.setDisable(!isCommandEnabled(ALIGN_JUSTIFY.getCommand()));
            alignJustifyButton.setSelected(getCommandState(ALIGN_JUSTIFY.getCommand()));
        } else {
            if (alignmentToggleGroup.getSelectedToggle() != null) {
                String command = alignmentToggleGroup.getSelectedToggle().getUserData().toString();
                if (isCommandEnabled(command) &amp;&amp; !getCommandState(command) ) {
                    executeCommand(command, null);
                }
            }
        }

        if (alignmentToggleGroup.getSelectedToggle() == null
                &amp;&amp; webPage.getClientSelectedText().isEmpty()) {
            alignmentToggleGroup.selectToggle(alignLeftButton);
        }

        bulletsButton.setDisable(!isCommandEnabled(BULLETS.getCommand()));
        bulletsButton.setSelected(getCommandState(BULLETS.getCommand()));
        numbersButton.setDisable(!isCommandEnabled(NUMBERS.getCommand()));
        numbersButton.setSelected(getCommandState(NUMBERS.getCommand()));

        indentButton.setDisable(!isCommandEnabled(INDENT.getCommand()));
        outdentButton.setDisable(!isCommandEnabled(OUTDENT.getCommand()));

        formatComboBox.setDisable(!isCommandEnabled(FORMAT.getCommand()));


        String formatValue = getCommandValue(FORMAT.getCommand());
        if (formatValue != null) {
            String htmlTag = &quot;&lt;&quot; + formatValue + &quot;&gt;&quot;;
            String comboFormatValue = styleFormatMap.get(htmlTag);
            String format = formatComboBox.getValue();

            // if the format value is then we assume that we're dealing with a paragraph,
            // which seems to correspond with the HTML output we receive.
            if ((resetToolbarState || htmlTag.equals(&quot;&lt;&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;div&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;blockquote&gt;&quot;))) {
                formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
            } else if (format != null &amp;&amp; ! format.equalsIgnoreCase(comboFormatValue)) {
                formatComboBox.setValue(comboFormatValue);
            }
        }

        fontFamilyComboBox.setDisable(!isCommandEnabled(FONT_FAMILY.getCommand()));
        final String fontFamilyValue = getCommandValue(FONT_FAMILY.getCommand());
        if (fontFamilyValue != null) {
            String fontFamilyStr = fontFamilyValue;

            // stripping out apostrophe characters, which are appended to either
            // end of the font face name when the font face has one or more spaces.
            if (fontFamilyStr.startsWith(&quot;'&quot;)) {
                fontFamilyStr = fontFamilyStr.substring(1);
            }
            if (fontFamilyStr.endsWith(&quot;'&quot;)) {
                fontFamilyStr = fontFamilyStr.substring(0,fontFamilyStr.length() - 1);
            }

            Object selectedFont = fontFamilyComboBox.getValue();
            if (selectedFont instanceof String) {
                if (!selectedFont.equals(fontFamilyStr)) {

                    ObservableList&lt;String&gt; fontFamilyItems = fontFamilyComboBox.getItems();
                    String selectedComboFont = null;
                    for (String comboFontFamilyValue : fontFamilyItems) {

                        if (comboFontFamilyValue.equals(fontFamilyStr)) {
                            selectedComboFont = comboFontFamilyValue;
                            break;
                        }
                        // Note: By default, 'Dialog' is the font returned from webview.
                        // For presidio, we're just mapping to the default font.
                        if (comboFontFamilyValue.equals(&quot;&quot;) &amp;&amp; fontFamilyStr.equals(&quot;Dialog&quot;)) {
                            selectedComboFont = comboFontFamilyValue;
                            break;
                        }
                    }

                    if (selectedComboFont != null) {
                        fontFamilyComboBox.setValue(selectedComboFont);
                    }
                }
            }
        }

        fontSizeComboBox.setDisable(!isCommandEnabled(FONT_SIZE.getCommand()));
        String fontSizeValue = getCommandValue(FONT_SIZE.getCommand());

        // added test for fontSizeValue == null to combat RT-28847
        if (resetToolbarState &amp;&amp; fontSizeValue == null) {
            fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
        } else {
            if (fontSizeValue != null) {
                if (!fontSizeComboBox.getValue().equals(sizeFontMap.get(fontSizeValue))) {
                    fontSizeComboBox.setValue(sizeFontMap.get(fontSizeValue));
                }
            }
            else {
                /*
                ** these is no font size set in webview,
                ** let's just use the default....
                */
                if ((fontSizeComboBox.getValue() == null) || !fontSizeComboBox.getValue().equals(sizeFontMap.get(SIZE_SMALL))) {
                    fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
                }
            }
        }

        boldButton.setDisable(!isCommandEnabled(BOLD.getCommand()));
        boldButton.setSelected(getCommandState(BOLD.getCommand()));
        italicButton.setDisable(!isCommandEnabled(ITALIC.getCommand()));
        italicButton.setSelected(getCommandState(ITALIC.getCommand()));
        underlineButton.setDisable(!isCommandEnabled(UNDERLINE.getCommand()));
        underlineButton.setSelected(getCommandState(UNDERLINE.getCommand()));
        strikethroughButton.setDisable(!isCommandEnabled(STRIKETHROUGH.getCommand()));
        strikethroughButton.setSelected(getCommandState(STRIKETHROUGH.getCommand()));

        fgColorButton.setDisable(!isCommandEnabled(FOREGROUND_COLOR.getCommand()));
        String foregroundColorValue = getCommandValue(FOREGROUND_COLOR.getCommand());
        if (foregroundColorValue != null) {
            fgColorButton.setValue(getColor(foregroundColorValue));
        }

        bgColorButton.setDisable(!isCommandEnabled(BACKGROUND_COLOR.getCommand()));
        String backgroundColorValue = getCommandValue(BACKGROUND_COLOR.getCommand());
        if (backgroundColorValue != null) {
            bgColorButton.setValue(getColor(backgroundColorValue));
        }

        atomicityCount = atomicityCount == 0 ? 0 : --atomicityCount;
    }

    private void enableToolbar(final boolean enable) {
        Platform.runLater(() -&gt; {

            // Make sure buttons have been created to avoid NPE
            if (copyButton == null) return;

            /*
            ** if we're to enable, we still only enable
            ** the cut/copy/paste buttons that make sense
            */
            if (enable) {
                copyButton.setDisable(!isCommandEnabled(COPY.getCommand()));
                cutButton.setDisable(!isCommandEnabled(CUT.getCommand()));
                pasteButton.setDisable(!isCommandEnabled(PASTE.getCommand()));
            } else {
                copyButton.setDisable(true);
                cutButton.setDisable(true);
                pasteButton.setDisable(true);
            }

//                undoButton.setDisable(!enable);
//                redoButton.setDisable(!enable);
            insertHorizontalRuleButton.setDisable(!enable);
            alignLeftButton.setDisable(!enable);
            alignCenterButton.setDisable(!enable);
            alignRightButton.setDisable(!enable);
            alignJustifyButton.setDisable(!enable);
            bulletsButton.setDisable(!enable);
            numbersButton.setDisable(!enable);
            indentButton.setDisable(!enable);
            outdentButton.setDisable(!enable);
<A NAME="17"></A>            formatComboBox.setDisable(!enable);
            fontFamilyComboBox.setDisable(!enable);
            fontSizeComboBox.setDisable(!enable);
            <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#17',2,'match34-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>boldButton.setDisable(!enable);
            italicButton.setDisable(!enable);
            underlineButton.setDisable(!enable);
            strikethroughButton.setDisable(!enable);
            fgColorButton.setDisable(!enable);
            bgColorButton.setDisable(!enable);
        });
    }

    private boolean executeCommand(String command, String value) {
        // The mentions of atomicity throughout this class relate back to RT-39941,
        // refer to that jira issue for more context.
        if</B></FONT> (!enableAtomicityCheck || (enableAtomicityCheck &amp;&amp; atomicityCount == 0)) {
            return webPage.executeCommand(command, value);
        }
        return false;
    }

    private boolean isCommandEnabled(String command) {
        return webPage.queryCommandEnabled(command);
    }

    private void setContentEditable(boolean b) {
        HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
        HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
        HTMLElement htmlBodyElement = (HTMLElement)htmlDocumentElement.getElementsByTagName(&quot;body&quot;).item(0);
        htmlBodyElement.setAttribute(&quot;contenteditable&quot;, Boolean.toString(b));
    }

    private boolean getCommandState(String command) {
        return webPage.queryCommandState(command);
    }

    private String getCommandValue(String command) {
        return webPage.queryCommandValue(command);
    }

    private Color getColor(String value) {
        Color color = Color.web(value);
        /* The default background color for WebView, according to the HTML
         * standard is rgba=#00000000 (transparent). The canvas background is expected
         * to be white.
         */
        if (color.equals(Color.TRANSPARENT)) {
            color = Color.WHITE;
        }
        return color;
    }

    private void applyTextFormatting() {
        if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
            return;
        }

        if (webPage.getClientCommittedTextLength() == 0) {
            String format = formatStyleMap.get(formatComboBox.getValue());
            String font   = fontFamilyComboBox.getValue().toString();

            executeCommand(FORMAT.getCommand(), format);
            executeCommand(FONT_FAMILY.getCommand(), font);
        }
    }

    void print(PrinterJob job) {
        webView.getEngine().print(job);
    }



    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Represents commands that can be passed into the HTMLEditor web engine.
     */
    public enum Command {
        CUT(&quot;cut&quot;),
        COPY(&quot;copy&quot;),
        PASTE(&quot;paste&quot;),

        UNDO(&quot;undo&quot;),
        REDO(&quot;redo&quot;),

        INSERT_HORIZONTAL_RULE(&quot;inserthorizontalrule&quot;),

        ALIGN_LEFT(&quot;justifyleft&quot;),
        ALIGN_CENTER(&quot;justifycenter&quot;),
        ALIGN_RIGHT(&quot;justifyright&quot;),
        ALIGN_JUSTIFY(&quot;justifyfull&quot;),

        BULLETS(&quot;insertUnorderedList&quot;),
        NUMBERS(&quot;insertOrderedList&quot;),

        INDENT(&quot;indent&quot;),
        OUTDENT(&quot;outdent&quot;),

        FORMAT(&quot;formatblock&quot;),
        FONT_FAMILY(&quot;fontname&quot;),
        FONT_SIZE(&quot;fontsize&quot;),

        BOLD(&quot;bold&quot;),
        ITALIC(&quot;italic&quot;),
        UNDERLINE(&quot;underline&quot;),
        STRIKETHROUGH(&quot;strikethrough&quot;),

        FOREGROUND_COLOR(&quot;forecolor&quot;),
        BACKGROUND_COLOR(&quot;backcolor&quot;),
        STYLEWITHCSS(&quot;styleWithCSS&quot;),

        INSERT_NEW_LINE(&quot;insertnewline&quot;),
        INSERT_TAB(&quot;inserttab&quot;);

        private final String command;

        Command(String command) {
            this.command = command;
        }

        public String getCommand() {
            return command;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/TimeBar.java</CENTER></H3><HR>
<PRE>
package sample.View;

import javafx.animation.KeyFrame;
<A NAME="0"></A>import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.scene.layout.AnchorPane;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#0',2,'match34-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;


public class TimeBar extends AnchorPane{
    private Timeline timeline;

    public TimeBar() {
        //Create rectangle
        Rectangle rectangle = new Rectangle(1280, 30)</B></FONT>;
        rectangle.setFill(Color.YELLOW);
        // Create pane and add rectangle to it
        Pane pane = new Pane();
        pane.getChildren().add(rectangle);
        pane.setStyle(&quot;-fx-background-color: white;&quot;);
        AnchorPane.setTopAnchor(pane, 0.0);
        AnchorPane.setLeftAnchor(pane, 0.0);
        AnchorPane.setRightAnchor(pane, 0.0);
        AnchorPane.setBottomAnchor(pane,0.0);
        getChildren().addAll(pane);
        // Create Timeline animation
        double paneWidth = pane.getWidth(); //
        double rectangleWidth = rectangle.getLayoutBounds().getWidth();
        KeyValue initKeyValue1 = new KeyValue(rectangle.translateXProperty(), paneWidth);
        KeyValue initKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 1.0);
        KeyFrame initFrame = new KeyFrame(Duration.ZERO, initKeyValue1, initKeyValue2);
        KeyValue endKeyValue1 = new KeyValue(rectangle.translateXProperty(), -1.0 * rectangleWidth);
        KeyValue endKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 0.2);
        KeyFrame endFrame = new KeyFrame(Duration.minutes(2), endKeyValue1, endKeyValue2);
        setTimeline(new Timeline(25 , initFrame, endFrame));
        getTimeline().setCycleCount(1);
        getTimeline().setRate(1);
        getTimeline().setAutoReverse(false);
        getTimeline().play();
    }

    private Timeline getTimeline() {
        return timeline;
    }

    private void setTimeline(Timeline timeline) {
        this.timeline = timeline;
    }
}
</PRE>

</BODY>
</HTML>
