<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.temporal.ChronoUnit;
import java.time.temporal.ValueRange;
import java.time.temporal.WeekFields;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;
import static java.time.temporal.ChronoUnit.*;

import com.sun.javafx.scene.control.skin.*;
import javafx.application.Platform;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WeakChangeListener;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.layout.StackPane;

import com.sun.javafx.scene.control.skin.resources.ControlResources;
import com.sun.javafx.scene.traversal.Direction;

import static com.sun.javafx.PlatformUtil.*;
import com.sun.javafx.scene.NodeHelper;

/**
 * The full content for the DatePicker popup. This class could
 * probably be used more or less as-is with an embeddable type of date
 * picker that doesn't use a popup.
 */
public class DatePickerContent extends VBox {
    protected DatePicker datePicker;
    private Button backMonthButton;
    private Button forwardMonthButton;
    private Button backYearButton;
    private Button forwardYearButton;
    private Label monthLabel;
    private Label yearLabel;
    protected GridPane gridPane;

    private int daysPerWeek;
    private List&lt;DateCell&gt; dayNameCells = new ArrayList&lt;DateCell&gt;();
    private List&lt;DateCell&gt; weekNumberCells = new ArrayList&lt;DateCell&gt;();
    protected List&lt;DateCell&gt; dayCells = new ArrayList&lt;DateCell&gt;();
    private LocalDate[] dayCellDates;
    private DateCell lastFocusedDayCell = null;

    final DateTimeFormatter monthFormatter =
        DateTimeFormatter.ofPattern(&quot;MMMM&quot;);

    final DateTimeFormatter monthFormatterSO =
            DateTimeFormatter.ofPattern(&quot;LLLL&quot;); // Standalone month name

    final DateTimeFormatter yearFormatter =
        DateTimeFormatter.ofPattern(&quot;y&quot;);

    final DateTimeFormatter yearWithEraFormatter =
        DateTimeFormatter.ofPattern(&quot;GGGGy&quot;); // For Japanese. What to use for others??

    final DateTimeFormatter weekNumberFormatter =
        DateTimeFormatter.ofPattern(&quot;w&quot;);

    final DateTimeFormatter weekDayNameFormatter =
            DateTimeFormatter.ofPattern(&quot;ccc&quot;); // Standalone day name

    final DateTimeFormatter dayCellFormatter =
        DateTimeFormatter.ofPattern(&quot;d&quot;);

    static String getString(String key) {
        return ControlResources.getString(&quot;DatePicker.&quot;+key);
    }

    public DatePickerContent(final DatePicker datePicker) {
        this.datePicker = datePicker;

        getStyleClass().add(&quot;date-picker-popup&quot;);

        daysPerWeek = getDaysPerWeek();

        {
            LocalDate date = datePicker.getValue();
            displayedYearMonth.set((date != null) ? YearMonth.from(date) : YearMonth.now());
        }

        displayedYearMonth.addListener((observable, oldValue, newValue) -&gt; {
            updateValues();
        });


        getChildren().add(createMonthYearPane());

        gridPane = new GridPane() {
            @Override protected double computePrefWidth(double height) {
                final double width = super.computePrefWidth(height);

                // RT-30903: Make sure width snaps to pixel when divided by
                // number of columns. GridPane doesn't do this with percentage
                // width constraints. See GridPane.adjustColumnWidths().
                final int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);
                final double snaphgap = snapSpaceX(getHgap());
                final double left = snapSpaceX(getInsets().getLeft());
                final double right = snapSpaceX(getInsets().getRight());
                final double hgaps = snaphgap * (nCols - 1);
                final double contentWidth = width - left - right - hgaps;
                return ((snapSizeX(contentWidth / nCols)) * nCols) + left + right + hgaps;
            }

            @Override protected void layoutChildren() {
                // Prevent AssertionError in GridPane
                if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
                    super.layoutChildren();
                }
            }
        };
        gridPane.setFocusTraversable(true);
        gridPane.getStyleClass().add(&quot;calendar-grid&quot;);
        gridPane.setVgap(-1);
        gridPane.setHgap(-1);

        // Add a focus owner listener to Scene when it becomes available.
        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
            new WeakChangeListener&lt;Node&gt;((ov2, oldFocusOwner, newFocusOwner) -&gt; {
                if (newFocusOwner == gridPane) {
                    if (oldFocusOwner instanceof DateCell) {
                        // Backwards traversal, skip gridPane.
                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);
                    } else {
                        // Forwards traversal, pass focus to day cell.
                        if (lastFocusedDayCell != null) {
                            Platform.runLater(() -&gt; {
                                lastFocusedDayCell.requestFocus();
                            });
                        } else {
                            clearFocus();
                        }
                    }
                }
            });
        gridPane.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;((ov, oldScene, newScene) -&gt; {
            if (oldScene != null) {
                oldScene.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newScene != null) {
                Platform.runLater(() -&gt; {
                    newScene.focusOwnerProperty().addListener(weakFocusOwnerListener);
                });
            }
        }));
        if (gridPane.getScene() != null) {
            gridPane.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // get the weekday labels starting with the weekday that is the
        // first-day-of-the-week according to the locale in the
        // displayed LocalDate
        for (int i = 0; i &lt; daysPerWeek; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;day-name-cell&quot;);
            dayNameCells.add(cell);
        }

        // Week number column
        for (int i = 0; i &lt; 6; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;week-number-cell&quot;);
            weekNumberCells.add(cell);
        }

        createDayCells();
        updateGrid();
        getChildren().add(gridPane);

        refresh();

        // RT-30511: This prevents key events from reaching the popup's owner.
        addEventHandler(KeyEvent.ANY, e -&gt; {
            Node node = getScene().getFocusOwner();
            if (node instanceof DateCell) {
                lastFocusedDayCell = (DateCell)node;
            }

            if (e.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (e.getCode()) {
                  case HOME:
                      goToDate(LocalDate.now(), true);
                      e.consume();
                      break;


                  case PAGE_UP:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!backYearButton.isDisabled()) {
                              forward(-1, YEARS, true);
                          }
                      } else {
                          if (!backMonthButton.isDisabled()) {
                              forward(-1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;

                  case PAGE_DOWN:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!forwardYearButton.isDisabled()) {
                              forward(1, YEARS, true);
                          }
                      } else {
                          if (!forwardMonthButton.isDisabled()) {
                              forward(1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;
                }

                node = getScene().getFocusOwner();
                if (node instanceof DateCell) {
                    lastFocusedDayCell = (DateCell)node;
                }
            }

            // Consume all key events except those that control
            // showing the popup and traversal.
            switch (e.getCode()) {
              case F4:
              case F10:
              case UP:
              case DOWN:
              case LEFT:
              case RIGHT:
              case TAB:
                    break;

              case ESCAPE:
                datePicker.hide();
                e.consume();
                break;

              default:
                e.consume();
            }
        });
    }

    private ObjectProperty&lt;YearMonth&gt; displayedYearMonth =
        new SimpleObjectProperty&lt;YearMonth&gt;(this, &quot;displayedYearMonth&quot;);

    public ObjectProperty&lt;YearMonth&gt; displayedYearMonthProperty() {
        return displayedYearMonth;
    }


    protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = new BorderPane();
        monthYearPane.getStyleClass().add(&quot;month-year-pane&quot;);

        // Month spinner

        HBox monthSpinner = new HBox();
        monthSpinner.getStyleClass().add(&quot;spinner&quot;);

        backMonthButton = new Button();
        backMonthButton.getStyleClass().add(&quot;left-button&quot;);

        forwardMonthButton = new Button();
        forwardMonthButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftMonthArrow = new StackPane();
        leftMonthArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backMonthButton.setGraphic(leftMonthArrow);

        StackPane rightMonthArrow = new StackPane();
        rightMonthArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardMonthButton.setGraphic(rightMonthArrow);


        backMonthButton.setOnAction(t -&gt; {
            forward(-1, MONTHS, false);
        });

        monthLabel = new Label();
        monthLabel.getStyleClass().add(&quot;spinner-label&quot;);
        monthLabel.fontProperty().addListener((o, ov, nv) -&gt; {
            updateMonthLabelWidth();
        });

        forwardMonthButton.setOnAction(t -&gt; {
            forward(1, MONTHS, false);
        });

        monthSpinner.getChildren().addAll(backMonthButton, monthLabel, forwardMonthButton);
        monthYearPane.setLeft(monthSpinner);

        // Year spinner

        HBox yearSpinner = new HBox();
        yearSpinner.getStyleClass().add(&quot;spinner&quot;);

        backYearButton = new Button();
        backYearButton.getStyleClass().add(&quot;left-button&quot;);

        forwardYearButton = new Button();
        forwardYearButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftYearArrow = new StackPane();
        leftYearArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backYearButton.setGraphic(leftYearArrow);

        StackPane rightYearArrow = new StackPane();
        rightYearArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardYearButton.setGraphic(rightYearArrow);


        backYearButton.setOnAction(t -&gt; {
            forward(-1, YEARS, false);
        });

<A NAME="10"></A>        yearLabel = new Label();
        yearLabel.getStyleClass().add(&quot;spinner-label&quot;);

        <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#10',2,'match58-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>forwardYearButton.setOnAction(t -&gt; {
            forward(1, YEARS, false);
        });

        yearSpinner.getChildren().addAll(backYearButton, yearLabel, forwardYearButton);
        yearSpinner.setFillHeight(false);
        monthYearPane.setRight(yearSpinner);

        return monthYearPane;
    }

    private void refresh() {</B></FONT>
        updateMonthLabelWidth();
        updateDayNameCells();
        updateValues();
    }

    public void updateValues() {
        // Note: Preserve this order, as DatePickerHijrahContent needs
        // updateDayCells before updateMonthYearPane().
        updateWeeknumberDateCells();
        updateDayCells();
        updateMonthYearPane();
    }

    public void updateGrid() {
        gridPane.getColumnConstraints().clear();
        gridPane.getChildren().clear();

        int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);

        ColumnConstraints columnConstraints = new ColumnConstraints();
        columnConstraints.setPercentWidth(100); // Treated as weight
        for (int i = 0; i &lt; nCols; i++) {
            gridPane.getColumnConstraints().add(columnConstraints);
        }

        for (int i = 0; i &lt; daysPerWeek; i++) {
            gridPane.add(dayNameCells.get(i), i + nCols - daysPerWeek, 1);  // col, row
        }

        // Week number column
        if (datePicker.isShowWeekNumbers()) {
            for (int i = 0; i &lt; 6; i++) {
                gridPane.add(weekNumberCells.get(i), 0, i + 2);  // col, row
            }
        }

        // setup: 6 rows of daysPerWeek (which is the maximum number of cells required in the worst case layout)
        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                gridPane.add(dayCells.get(row*daysPerWeek+col), col + nCols - daysPerWeek, row + 2);
            }
        }
    }

    public void updateDayNameCells() {
        // first day of week, 1 = monday, 7 = sunday
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();

        // july 13th 2009 is a Monday, so a firstDayOfWeek=1 must come out of the 13th
        LocalDate date = LocalDate.of(2009, 7, 12 + firstDayOfWeek);
        for (int i = 0; i &lt; daysPerWeek; i++) {
            String name = weekDayNameFormatter.withLocale(getLocale()).format(date.plus(i, DAYS));
            dayNameCells.get(i).setText(titleCaseWord(name));
        }
    }

    public void updateWeeknumberDateCells() {
        if (datePicker.isShowWeekNumbers()) {
            final Locale locale = getLocale();
            final int maxWeeksPerMonth = 6; // TODO: Get this from chronology?

            LocalDate firstOfMonth = displayedYearMonth.get().atDay(1);
            for (int i = 0; i &lt; maxWeeksPerMonth; i++) {
                LocalDate date = firstOfMonth.plus(i, WEEKS);
                // Use a formatter to ensure correct localization,
                // such as when Thai numerals are required.
                String cellText =
                    weekNumberFormatter.withLocale(locale)
                                       .withDecimalStyle(DecimalStyle.of(locale))
                                       .format(date);
                weekNumberCells.get(i).setText(cellText);
            }
        }
    }

    public void updateDayCells() {
        Locale locale = getLocale();
        Chronology chrono = getPrimaryChronology();
        int firstOfMonthIdx = determineFirstOfMonthDayOfWeek();
        YearMonth curMonth = displayedYearMonth.get();

        // RT-31075: The following are now set in the try-catch block.
        YearMonth prevMonth = null;
        YearMonth nextMonth = null;
        int daysInCurMonth = -1;
        int daysInPrevMonth = -1;
        int daysInNextMonth = -1;

        for (int i = 0; i &lt; 6 * daysPerWeek; i++) {
            DateCell dayCell = dayCells.get(i);
            dayCell.getStyleClass().setAll(&quot;cell&quot;, &quot;date-cell&quot;, &quot;day-cell&quot;);
            dayCell.setDisable(false);
            dayCell.setStyle(null);
            dayCell.setGraphic(null);
            dayCell.setTooltip(null);

            try {
                if (daysInCurMonth == -1) {
                    daysInCurMonth = curMonth.lengthOfMonth();
                }
                YearMonth month = curMonth;
                int day = i - firstOfMonthIdx + 1;
                //int index = firstOfMonthIdx + i - 1;
                if (i &lt; firstOfMonthIdx) {
                    if (prevMonth == null) {
                        prevMonth = curMonth.minusMonths(1);
                        daysInPrevMonth = prevMonth.lengthOfMonth();
                    }
                    month = prevMonth;
                    day = i + daysInPrevMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;previous-month&quot;);
                } else if (i &gt;= firstOfMonthIdx + daysInCurMonth) {
                    if (nextMonth == null) {
                        nextMonth = curMonth.plusMonths(1);
                        daysInNextMonth = nextMonth.lengthOfMonth();
                    }
                    month = nextMonth;
                    day = i - daysInCurMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;next-month&quot;);
                }
                LocalDate date = month.atDay(day);
                dayCellDates[i] = date;
                ChronoLocalDate cDate = chrono.date(date);

                dayCell.setDisable(false);

                if (isToday(date)) {
                    dayCell.getStyleClass().add(&quot;today&quot;);
                }

                if (date.equals(datePicker.getValue())) {
                    dayCell.getStyleClass().add(&quot;selected&quot;);
                }

                String cellText =
                    dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);
                dayCell.setText(cellText);

                dayCell.updateItem(date, false);
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                dayCell.setText(&quot; &quot;);
                dayCell.setDisable(true);
            }
        }
    }

    private int getDaysPerWeek() {
        ValueRange range = getPrimaryChronology().range(DAY_OF_WEEK);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private int getMonthsPerYear() {
        ValueRange range = getPrimaryChronology().range(MONTH_OF_YEAR);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private void updateMonthLabelWidth() {
        if (monthLabel != null) {
            int monthsPerYear = getMonthsPerYear();
            double width = 0;
            for (int i = 0; i &lt; monthsPerYear; i++) {
                YearMonth yearMonth = displayedYearMonth.get().withMonth(i + 1);
                String name = monthFormatterSO.withLocale(getLocale()).format(yearMonth);
                if (Character.isDigit(name.charAt(0))) {
                    // Fallback. The standalone format returned a number, so use standard format instead.
                    name = monthFormatter.withLocale(getLocale()).format(yearMonth);
                }
                width = Math.max(width, Utils.computeTextWidth(monthLabel.getFont(), name, 0));
            }
            monthLabel.setMinWidth(width);
        }
    }

    protected void updateMonthYearPane() {
        YearMonth yearMonth = displayedYearMonth.get();
        String str = formatMonth(yearMonth);
        monthLabel.setText(str);

        str = formatYear(yearMonth);
        yearLabel.setText(str);
        double width = Utils.computeTextWidth(yearLabel.getFont(), str, 0);
        if (width &gt; yearLabel.getMinWidth()) {
            yearLabel.setMinWidth(width);
        }

        Chronology chrono = datePicker.getChronology();
        LocalDate firstDayOfMonth = yearMonth.atDay(1);
        backMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, DAYS));
        forwardMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, MONTHS));
        backYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, YEARS));
        forwardYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, YEARS));
    }

    private String formatMonth(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));

            String str = monthFormatterSO.withLocale(getLocale())
                                         .withChronology(chrono)
                                         .format(cDate);
            if (Character.isDigit(str.charAt(0))) {
                // Fallback. The standalone format returned a number, so use standard format instead.
                str = monthFormatter.withLocale(getLocale())
                                    .withChronology(chrono)
                                    .format(cDate);
            }
            return titleCaseWord(str);
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    private String formatYear(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            DateTimeFormatter formatter = yearFormatter;
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));
            int era = cDate.getEra().getValue();
            int nEras = chrono.eras().size();

            /*if (cDate.get(YEAR) &lt; 0) {
                formatter = yearForNegYearFormatter;
            } else */
            if ((nEras == 2 &amp;&amp; era == 0) || nEras &gt; 2) {
                formatter = yearWithEraFormatter;
            }

            // Fixme: Format Japanese era names with Japanese text.
            String str = formatter.withLocale(getLocale())
                                  .withChronology(chrono)
                                  .withDecimalStyle(DecimalStyle.of(getLocale()))
                                  .format(cDate);

            return str;
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    // Ensures that month and day names are titlecased (capitalized).
    private String titleCaseWord(String str) {
        if (str.length() &gt; 0) {
            int firstChar = str.codePointAt(0);
            if (!Character.isTitleCase(firstChar)) {
                str = new String(new int[] { Character.toTitleCase(firstChar) }, 0, 1) +
                      str.substring(Character.offsetByCodePoints(str, 0, 1));
            }
        }
        return str;
    }



    /**
     * determine on which day of week idx the first of the months is
     */
    private int determineFirstOfMonthDayOfWeek() {
        // determine with which cell to start
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();
        int firstOfMonthIdx = displayedYearMonth.get().atDay(1).getDayOfWeek().getValue() - firstDayOfWeek;
        if (firstOfMonthIdx &lt; 0) {
            firstOfMonthIdx += daysPerWeek;
        }
        return firstOfMonthIdx;
    }

    private boolean isToday(LocalDate localDate) {
        return (localDate.equals(LocalDate.now()));
    }

    protected LocalDate dayCellDate(DateCell dateCell) {
        assert (dayCellDates != null);
        return dayCellDates[dayCells.indexOf(dateCell)];
    }

    // public for behavior class
    public void goToDayCell(DateCell dateCell, int offset, ChronoUnit unit, boolean focusDayCell) {
        goToDate(dayCellDate(dateCell).plus(offset, unit), focusDayCell);
    }

    protected void forward(int offset, ChronoUnit unit, boolean focusDayCell) {
        YearMonth yearMonth = displayedYearMonth.get();
        DateCell dateCell = lastFocusedDayCell;
        if (dateCell == null || !dayCellDate(dateCell).getMonth().equals(yearMonth.getMonth())) {
            dateCell = findDayCellForDate(yearMonth.atDay(1));
        }
        goToDayCell(dateCell, offset, unit, focusDayCell);
    }

    // public for behavior class
    public void goToDate(LocalDate date, boolean focusDayCell) {
        if (isValidDate(datePicker.getChronology(), date)) {
            displayedYearMonth.set(YearMonth.from(date));
            if (focusDayCell) {
                findDayCellForDate(date).requestFocus();
            }
        }
    }

    // public for behavior class
    public void selectDayCell(DateCell dateCell) {
        datePicker.setValue(dayCellDate(dateCell));
        datePicker.hide();
    }

    private DateCell findDayCellForDate(LocalDate date) {
        for (int i = 0; i &lt; dayCellDates.length; i++) {
            if (date.equals(dayCellDates[i])) {
                return dayCells.get(i);
            }
        }
        return dayCells.get(dayCells.size()/2+1);
    }

    public void clearFocus() {
        LocalDate focusDate = datePicker.getValue();
        if (focusDate == null) {
            focusDate = LocalDate.now();
        }
        if (YearMonth.from(focusDate).equals(displayedYearMonth.get())) {
            // focus date
            goToDate(focusDate, true);
        } else {
            // focus month spinner (should not happen)
            backMonthButton.requestFocus();
        }

        // RT-31857
        if (backMonthButton.getWidth() == 0) {
            backMonthButton.requestLayout();
            forwardMonthButton.requestLayout();
            backYearButton.requestLayout();
            forwardYearButton.requestLayout();
        }
    }

    protected void createDayCells() {
        final EventHandler&lt;MouseEvent&gt; dayCellActionHandler = ev -&gt; {
            if (ev.getButton() != MouseButton.PRIMARY) {
                return;
            }

            DateCell dayCell = (DateCell)ev.getSource();
            selectDayCell(dayCell);
            lastFocusedDayCell = dayCell;
        };

        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                DateCell dayCell = createDayCell();
                dayCell.addEventHandler(MouseEvent.MOUSE_CLICKED, dayCellActionHandler);
                dayCells.add(dayCell);
            }
        }

        dayCellDates = new LocalDate[6 * daysPerWeek];
    }

    private DateCell createDayCell() {
        DateCell cell = null;
        if (datePicker.getDayCellFactory() != null) {
            cell = datePicker.getDayCellFactory().call(datePicker);
        }
        if (cell == null) {
            cell = new DateCell();
        }

        return cell;
    }

    protected Locale getLocale() {
        return Locale.getDefault(Locale.Category.FORMAT);
    }

    /**
     * The primary chronology for display. This may be overridden to
     * be different than the DatePicker chronology. For example
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    protected Chronology getPrimaryChronology() {
        return datePicker.getChronology();
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date, int offset, ChronoUnit unit) {
        if (date != null) {
            try {
                return isValidDate(chrono, date.plus(offset, unit));
            } catch (DateTimeException ex) {
            }
        }
        return false;
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date) {
        try {
            if (date != null) {
                chrono.date(date);
            }
            return true;
        } catch (DateTimeException ex) {
            return false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/MenuButtonBehaviorBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import javafx.geometry.Side;
import javafx.scene.control.MenuButton;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;

import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static javafx.scene.input.KeyCode.*;

/**
 * The base behavior for a MenuButton.
 */
public abstract class MenuButtonBehaviorBase&lt;C extends MenuButton&gt; extends ButtonBehavior&lt;C&gt; {

    private final InputMap&lt;C&gt; buttonInputMap;

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public MenuButtonBehaviorBase(final C menuButton) {
        super(menuButton);

        // pull down the parent input map, no need to add focus traversal
        // mappings - added in ButtonBehavior.
        buttonInputMap = super.getInputMap();

        // We want to remove the maping for MOUSE_RELEASED, as the event is
        // handled by the skin instead, which calls the mouseReleased method below.
        removeMapping(MouseEvent.MOUSE_RELEASED);

        /**
         * The base key bindings for a MenuButton. These basically just define the
         * bindings to close an open menu. Subclasses will tell you what can be done
         * to open it.
         */
        addDefaultMapping(new KeyMapping(ESCAPE, e -&gt; getNode().hide()));
        addDefaultMapping(new KeyMapping(CANCEL, e -&gt; getNode().hide()));

        // we create a child input map, as we want to override some of the
        // focus traversal behaviors (and child maps take precedence over parent maps)
        InputMap&lt;C&gt; customFocusInputMap = new InputMap&lt;&gt;(menuButton);
        addDefaultMapping(customFocusInputMap, new KeyMapping(UP, this::overrideTraversalInput));
        addDefaultMapping(customFocusInputMap, new KeyMapping(DOWN, this::overrideTraversalInput));
        addDefaultMapping(customFocusInputMap, new KeyMapping(LEFT, this::overrideTraversalInput));
        addDefaultMapping(customFocusInputMap, new KeyMapping(RIGHT, this::overrideTraversalInput));
        addDefaultChildMap(buttonInputMap, customFocusInputMap);
    }


    /***************************************************************************
     *                                                                         *
     * Key event handling                                                      *
     *                                                                         *
     **************************************************************************/

    private void overrideTraversalInput(KeyEvent event) {
        final MenuButton button = getNode();
        final Side popupSide = button.getPopupSide();
        if (!button.isShowing() &amp;&amp;
                (event.getCode() == UP    &amp;&amp; popupSide == Side.TOP)    ||
                (event.getCode() == DOWN  &amp;&amp; (popupSide == Side.BOTTOM || popupSide == Side.TOP))  ||
                (event.getCode() == LEFT  &amp;&amp; (popupSide == Side.RIGHT  || popupSide == Side.LEFT)) ||
                (event.getCode() == RIGHT &amp;&amp; (popupSide == Side.RIGHT  || popupSide == Side.LEFT))) {
            // Show the menu when arrow key matches the popupSide
            // direction -- but also allow RIGHT key for LEFT position and
            // DOWN key for TOP position. To be symmetrical, we also allow for
            // the LEFT key to work when in the RIGHT position. This is needed
            // because the skin only paints right- and down-facing arrows in
            // these cases.
            button.show();
<A NAME="4"></A>        }
    }

    protected void openAction() <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#4',2,'match58-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        if (getNode().isShowing()) {
            getNode().hide();
        } else {
            getNode().show();
        }
    }</B></FONT>

    /***************************************************************************
     *                                                                         *
     * Mouse event handling                                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * When a mouse button is pressed, we either want to behave like a button or
     * show the popup.  This will be called by the skin.
     *
     * @param e the mouse press event
     * @param behaveLikeButton if true, this should act just like a button
     */
    public void mousePressed(MouseEvent e, boolean behaveLikeButton) {
        final C control = getNode();

        /*
         * Behaving like a button is easy - we just call super. But, we cannot
         * call super if all we want to do is show the popup. The reason for
         * this is that super also handles all the arm/disarm/fire logic, and
         * this can inadvertently cause actions to fire when we don't want them
         * to fire. So, we unfortunately need to duplicate the focus
         * handling code here.
         */
        if (behaveLikeButton) {
            if (control.isShowing()) {
                control.hide();
            }
            super.mousePressed(e);
        } else {
            if (!control.isFocused() &amp;&amp; control.isFocusTraversable()) {
                control.requestFocus();
            }
            if (control.isShowing()) {
                control.hide();
            } else {
                if (e.getButton() == MouseButton.PRIMARY) {
                    control.show();
                }
            }
        }
    }

    /**
     * Handles mouse release events.  This will be called by the skin.
     *
     * @param e the mouse press event
     * @param behaveLikeButton if true, this should act just like a button
     */
    public void mouseReleased(MouseEvent e, boolean behaveLikeButton) {
        if (behaveLikeButton) {
            super.mouseReleased(e);
        } else {
            if (getNode().isShowing() &amp;&amp; !getNode().contains(e.getX(), e.getY())) {
                getNode().hide();
            }
            getNode().disarm();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/SpinnerBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.KeyEvent;
import javafx.util.Duration;

import java.util.List;

import static javafx.scene.input.KeyCode.*;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;

public class SpinnerBehavior&lt;T&gt; extends BehaviorBase&lt;Spinner&lt;T&gt;&gt; {

    // this specifies how long the mouse has to be pressed on a button
    // before the value steps. As the mouse is held down longer, we begin
    // to cut down the duration of subsequent steps (and also increase the
    // step size)
    private static final double INITIAL_DURATION_MS = 750;

    private final InputMap&lt;Spinner&lt;T&gt;&gt; spinnerInputMap;

    private static final int STEP_AMOUNT = 1;

    private boolean isIncrementing = false;

    private Timeline timeline;

    final EventHandler&lt;ActionEvent&gt; spinningKeyFrameEventHandler = event -&gt; {
        final SpinnerValueFactory&lt;T&gt; valueFactory = getNode().getValueFactory();
        if (valueFactory == null) {
            return;
        }

        if (isIncrementing) {
            increment(STEP_AMOUNT);
        } else {
            decrement(STEP_AMOUNT);
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public SpinnerBehavior(Spinner&lt;T&gt; spinner) {
        super(spinner);

        // create a map for spinner-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        spinnerInputMap = createInputMap();

        // then spinner-specific mappings for key and mouse input
        addDefaultMapping(spinnerInputMap,
            new KeyMapping(UP, KeyEvent.KEY_PRESSED, e -&gt; {
                if (arrowsAreVertical()) increment(1); else FocusTraversalInputMap.traverseUp(e);
            }),
            new KeyMapping(RIGHT, KeyEvent.KEY_PRESSED, e -&gt; {
                if (! arrowsAreVertical()) increment(1); else FocusTraversalInputMap.traverseRight(e);
            }),
            new KeyMapping(LEFT, KeyEvent.KEY_PRESSED, e -&gt; {
                if (! arrowsAreVertical()) decrement(1); else FocusTraversalInputMap.traverseLeft(e);
            }),
            new KeyMapping(DOWN, KeyEvent.KEY_PRESSED, e -&gt; {
                if (arrowsAreVertical()) decrement(1); else FocusTraversalInputMap.traverseDown(e);
            })
        );
    }



    /***************************************************************************
     *                                                                         *
     * API                                                                     *
     *                                                                         *
     **************************************************************************/

    @Override public InputMap&lt;Spinner&lt;T&gt;&gt; getInputMap() {
        return spinnerInputMap;
    }

    public void increment(int steps) {
        getNode().increment(steps);
    }

    public void decrement(int steps) {
        getNode().decrement(steps);
    }

    public void startSpinning(boolean increment) {
        isIncrementing = increment;

        if (timeline != null) {
<A NAME="17"></A>            timeline.stop();
        }
        timeline = new Timeline();
        <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#17',2,'match58-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>timeline.setCycleCount(Timeline.INDEFINITE);
        timeline.setDelay(getNode().getInitialDelay());
        final KeyFrame start = new KeyFrame(Duration.ZERO, spinningKeyFrameEventHandler);
        final KeyFrame repeat = new KeyFrame(getNode().getRepeatDelay());
        timeline.getKeyFrames().setAll(start, repeat);
        timeline.playFromStart();

        spinningKeyFrameEventHandler.handle</B></FONT>(null);
    }

    public void stopSpinning() {
        if (timeline != null) {
            timeline.stop();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Implementation                                                          *
     *                                                                         *
     **************************************************************************/

    private boolean arrowsAreVertical() {
        final List&lt;String&gt; styleClass = getNode().getStyleClass();

        return ! (styleClass.contains(Spinner.STYLE_CLASS_ARROWS_ON_LEFT_HORIZONTAL)  ||
                  styleClass.contains(Spinner.STYLE_CLASS_ARROWS_ON_RIGHT_HORIZONTAL) ||
                  styleClass.contains(Spinner.STYLE_CLASS_SPLIT_ARROWS_HORIZONTAL));
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/FXVKSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.SkinBase;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.TextField;
import javafx.scene.control.TextArea;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.Scene;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.input.InputEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.Region;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Window;
import javafx.util.Duration;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.HashMap;
import static javafx.scene.input.MouseEvent.MOUSE_PRESSED;
import static javafx.scene.input.TouchEvent.TOUCH_PRESSED;
import static javafx.scene.layout.Region.USE_PREF_SIZE;
import java.security.AccessController;
import java.security.PrivilegedAction;


public class FXVKSkin extends SkinBase&lt;FXVK&gt; {

    private static final int GAP = 6;

    private List&lt;List&lt;Key&gt;&gt; currentBoard;
    private static HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt; boardMap = new HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt;();
    private int numCols;

    private boolean capsDown = false;
    private boolean shiftDown = false;
    private boolean isSymbol = false;
    long lastTime = -1L;

    void clearShift() {
        if (shiftDown &amp;&amp; !capsDown) {
            shiftDown = false;
            updateKeys();
        }
        lastTime = -1L;
    }

    void pressShift() {
        long time = System.currentTimeMillis();

        //potential for a shift lock
        if (shiftDown &amp;&amp; !capsDown) {
            if (lastTime &gt; 0L &amp;&amp; time - lastTime &lt; 400L) {
                //set caps lock
                shiftDown = false;
                capsDown =  true;
            } else {
                //set normal
                shiftDown = false;
                capsDown =  false;
            }
        } else if (!shiftDown &amp;&amp; !capsDown) {
            // set shift
            shiftDown=true;
        } else {
            //set to normal
            shiftDown = false;
            capsDown =  false;
        }

        updateKeys();
        lastTime = time;
    }

    void clearSymbolABC() {
        isSymbol = false;
        updateKeys();
    }

    void pressSymbolABC() {
        isSymbol = !isSymbol;
        updateKeys();
    }

    void clearStateKeys() {
        capsDown = false;
        shiftDown = false;
        isSymbol = false;
        lastTime = -1L;
        updateKeys();
<A NAME="11"></A>    }

    private void updateKeys() {
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#11',2,'match58-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                key.update(capsDown, shiftDown, isSymbol);
            }
        }</B></FONT>
    }

    private static Popup vkPopup;
    private static Popup secondaryPopup;
    private static FXVK primaryVK;

    private static Timeline slideInTimeline = new Timeline();
    private static Timeline slideOutTimeline = new Timeline();
    private static boolean hideAfterSlideOut = false;

    private static FXVK secondaryVK;
    private static Timeline secondaryVKDelay;
    private static CharKey secondaryVKKey;
    private static TextInputKey repeatKey;

    private static Timeline repeatInitialDelay;
    private static Timeline repeatSubsequentDelay;

    // key repeat initial delay (ms)
    private static double KEY_REPEAT_DELAY = 400;
    private static double KEY_REPEAT_DELAY_MIN = 100;
    private static double KEY_REPEAT_DELAY_MAX = 1000;

    // key repeat rate (cps)
    private static double KEY_REPEAT_RATE = 25;
    private static double KEY_REPEAT_RATE_MIN = 2;
    private static double KEY_REPEAT_RATE_MAX = 50;

    private Node attachedNode;
    private String vkType = null;

    FXVK fxvk;

    static final double VK_HEIGHT = 243;
    static final double VK_SLIDE_MILLIS = 250;
    static final double PREF_PORTRAIT_KEY_WIDTH = 40;
    static final double PREF_KEY_HEIGHT = 56;

    static boolean vkAdjustWindow = false;
    static boolean vkLookup = false;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String s = System.getProperty(&quot;com.sun.javafx.vk.adjustwindow&quot;);
            if (s != null) {
                vkAdjustWindow = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.sqe.vk.lookup&quot;);
            if (s != null) {
                vkLookup = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatDelay&quot;);
            if (s != null) {
                Double delay = Double.valueOf(s);
                KEY_REPEAT_DELAY = Math.min(Math.max(delay, KEY_REPEAT_DELAY_MIN), KEY_REPEAT_DELAY_MAX);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatRate&quot;);
            if (s != null) {
                Double rate = Double.valueOf(s);
                if (rate &lt;= 0) {
                    //disable key repeat
                    KEY_REPEAT_RATE = 0;
                } else {
                    KEY_REPEAT_RATE = Math.min(Math.max(rate, KEY_REPEAT_RATE_MIN), KEY_REPEAT_RATE_MAX);
                }
            }
            return null;
        });
    }

    // Proxy for read-only Window.yProperty() so we can animate.
    private static DoubleProperty winY = new SimpleDoubleProperty();
    static {
        winY.addListener(valueModel -&gt; {
            if (vkPopup != null) {
                vkPopup.setY(winY.get());
            }
        });
    }

    private static void startSlideIn() {
        slideOutTimeline.stop();
        slideInTimeline.playFromStart();
    }

    private static void startSlideOut(boolean doHide) {
        hideAfterSlideOut = doHide;
        slideInTimeline.stop();
        slideOutTimeline.playFromStart();
    }

    private void adjustWindowPosition(final Node node) {
        if ( !(node instanceof TextInputControl) ) {
            return;
        }

        // attached node y position in window coordinates
        double inputControlMinY = node.localToScene(0.0, 0.0).getY() + node.getScene().getY();
        double inputControlHeight = ((TextInputControl) node).getHeight();
        double inputControlMaxY = inputControlMinY + inputControlHeight;

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(node).getBounds().getHeight();
        double visibleAreaMaxY = screenHeight - VK_HEIGHT;

        double inputLineCenterY = 0.0;
        double inputLineBottomY = 0.0;
        double newWindowYPos = 0.0;
        double screenTopOffset = 10.0;

        if (node instanceof TextField) {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            //check for combo box
            Parent parent = attachedNode.getParent();
            if (parent instanceof ComboBoxBase) {
                //combo box
                // position near screen top
                newWindowYPos = Math.min(screenTopOffset - inputControlMinY, 0);
            } else {
                // position at center of visible screen area
                newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin textAreaSkin = (TextAreaSkin)((TextArea)node).getSkin();
            Bounds caretBounds = textAreaSkin.getCaretBounds();
            double caretMinY = caretBounds.getMinY();
            double caretMaxY = caretBounds.getMaxY();
            inputLineCenterY = inputControlMinY + ( caretMinY + caretMaxY ) / 2;
            inputLineBottomY = inputControlMinY + caretMaxY;

            if (inputControlHeight &lt; visibleAreaMaxY) {
                // position at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - (inputControlMinY + inputControlHeight / 2);
            } else {
                // position the line containing the caret at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - inputLineCenterY;
            }
            newWindowYPos = Math.min(newWindowYPos, 0);

        } else {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            // position at center of visible screen area
            newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
        }

        Window w = node.getScene().getWindow();
        if (origWindowYPos + inputLineBottomY &gt; visibleAreaMaxY) {
            w.setY(newWindowYPos);
        } else {
            w.setY(origWindowYPos);
        }
    }

    private void saveWindowPosition(final Node node) {
        Window w = node.getScene().getWindow();
        origWindowYPos = w.getY();
    }

    private void restoreWindowPosition(final Node node) {
        if (node != null) {
            Scene scene = node.getScene();
            if (scene != null) {
                Window window = scene.getWindow();
                if (window != null) {
                    window.setY(origWindowYPos);
                }
            }
        }
    }

    EventHandler&lt;InputEvent&gt; unHideEventHandler;

    private boolean isVKHidden = false;
    private Double origWindowYPos = null;

    private void registerUnhideHandler(final Node node) {
        if (unHideEventHandler == null) {
            unHideEventHandler = event -&gt; {
                if (attachedNode != null &amp;&amp; isVKHidden) {
                    double screenHeight = com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds().getHeight();
                    if (fxvk.getHeight() &gt; 0 &amp;&amp; (vkPopup.getY() &gt; screenHeight - fxvk.getHeight())) {
                        if (slideInTimeline.getStatus() != Animation.Status.RUNNING) {
                            startSlideIn();
                            if (vkAdjustWindow) {
                                adjustWindowPosition(attachedNode);
                            }
                        }
                    }
                }
                isVKHidden = false;
            };
        }
        node.addEventHandler(TOUCH_PRESSED, unHideEventHandler);
        node.addEventHandler(MOUSE_PRESSED, unHideEventHandler);
    }

    private void unRegisterUnhideHandler(Node node) {
        if (unHideEventHandler != null) {
            node.removeEventHandler(TOUCH_PRESSED, unHideEventHandler);
            node.removeEventHandler(MOUSE_PRESSED, unHideEventHandler);
        }
    }

    private String getNodeVKType(Node node) {
        Integer vkType = (Integer)node.getProperties().get(FXVK.VK_TYPE_PROP_KEY);
        String typeStr = null;
        if (vkType != null) {
            Object typeValue = FXVK.VK_TYPE_NAMES[vkType];
            if (typeValue instanceof String) {
                typeStr = ((String)typeValue).toLowerCase(Locale.ROOT);
            }
        }
        return (typeStr != null ? typeStr : &quot;text&quot;);
    }

    private void updateKeyboardType(Node node) {
        String oldType = vkType;
        vkType = getNodeVKType(node);
        //VK type changed, rebuild
        if ( oldType == null || !vkType.equals(oldType) ) {
            rebuildPrimaryVK(vkType);
        }
    }

    private void closeSecondaryVK() {
        if (secondaryVK != null) {
            secondaryVK.setAttachedNode(null);
            secondaryPopup.hide();
        }
    }

    private void setupPrimaryVK() {
        fxvk.setFocusTraversable(false);
        fxvk.setVisible(true);

        // init popup window and slide animations
        if (vkPopup == null) {
            vkPopup = new Popup();
            vkPopup.setAutoFix(false);
        }
        vkPopup.getContent().setAll(fxvk);

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getHeight();
        double width = com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getWidth();

        //Setup VK slide animations
        slideInTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                         new KeyValue(winY, screenHeight - VK_HEIGHT,
                                      Interpolator.EASE_BOTH)));
        slideOutTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                    event -&gt; {
                        if (hideAfterSlideOut &amp;&amp; vkPopup.isShowing()) {
                            vkPopup.hide();
                        }
                    },
                new KeyValue(winY, screenHeight, Interpolator.EASE_BOTH)));

        //Set VK size
        fxvk.setPrefWidth(width);
        fxvk.setMinWidth(USE_PREF_SIZE);
        fxvk.setMaxWidth(USE_PREF_SIZE);

        fxvk.setPrefHeight(VK_HEIGHT);
        fxvk.setMinHeight(USE_PREF_SIZE);


        //set up long-press triger for secondary VK
        if (secondaryVKDelay == null) {
            secondaryVKDelay = new Timeline();
        }
        KeyFrame kf = new KeyFrame(Duration.millis(500), event -&gt; {
            if (secondaryVKKey != null) {
                showSecondaryVK(secondaryVKKey);
            }
        });
        secondaryVKDelay.getKeyFrames().setAll(kf);

        //Setup key repeat animations
        if (KEY_REPEAT_RATE &gt; 0) {
            repeatInitialDelay = new Timeline(new KeyFrame(
                    Duration.millis(KEY_REPEAT_DELAY),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                        //Start repeat animation
                        repeatSubsequentDelay.playFromStart();
                    }
            ));
            repeatSubsequentDelay = new Timeline(new KeyFrame(
                    Duration.millis(1000.0 / KEY_REPEAT_RATE),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                    }
            ));
            repeatSubsequentDelay.setCycleCount(Animation.INDEFINITE);
        }
    }

    void prerender(Node node) {
        if (fxvk != primaryVK) {
            return;
        }

        //Preload all boards
        loadBoard(&quot;text&quot;);
        loadBoard(&quot;numeric&quot;);
        loadBoard(&quot;url&quot;);
        loadBoard(&quot;email&quot;);

        updateKeyboardType(node);
        fxvk.setVisible(true);

        if (!vkPopup.isShowing()) {
            Rectangle2D screenBounds =
                com.sun.javafx.util.Utils.getScreen(node).getBounds();

            vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
            winY.set(screenBounds.getHeight());
            vkPopup.show(node.getScene().getWindow());
        }
    }

    public FXVKSkin(final FXVK fxvk) {
        super(fxvk);
        this.fxvk = fxvk;
        if (fxvk == FXVK.vk) {
            primaryVK = fxvk;
        }

        if (fxvk == primaryVK) {
            setupPrimaryVK();
        }

        fxvk.attachedNodeProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                Node oldNode = attachedNode;
                attachedNode = fxvk.getAttachedNode();
                if (fxvk != primaryVK) {
                    return;
                }

                closeSecondaryVK();

                if (attachedNode != null) {
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    registerUnhideHandler(attachedNode);
                    updateKeyboardType(attachedNode);

                    //owner window has changed so hide VK and show with new owner
                    if (oldNode == null || oldNode.getScene() == null || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                        if (vkPopup.isShowing()) {
                            vkPopup.hide();
                        } else {
                        }
                    }

                    if (!vkPopup.isShowing()) {
                        Rectangle2D screenBounds =
                            com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds();

                        vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
                        if (oldNode == null || isVKHidden) {
                            //position off screen
                            winY.set(screenBounds.getHeight());
                        } else {
                            //position on screen (no slide in)
                            winY.set(screenBounds.getHeight() - VK_HEIGHT);
                        }
                        vkPopup.show(attachedNode.getScene().getWindow());
                    }

                    if (oldNode == null || isVKHidden) {
                        startSlideIn();
                    }

                    if (vkAdjustWindow) {
                        //update previous window position only if moving from non-input control node or window has changed.
                        if (oldNode == null || oldNode.getScene() == null
                            || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                            saveWindowPosition(attachedNode);
                        }
                        // Move window containing input node
                        adjustWindowPosition(attachedNode);
                    }
                } else { // attachedNode == null
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    startSlideOut(true);
                    // Restore window position
                    if (vkAdjustWindow) {
                        restoreWindowPosition(oldNode);
                    }
                }
                isVKHidden = false;
            }
        });
    }

    /**
     * builds secondary (long-press) VK
     */
    private void rebuildSecondaryVK() {
        if (secondaryVK.chars == null) {
        } else {
            int nKeys = secondaryVK.chars.length;
            int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
            int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

            Key tmpKey;
            List&lt;List&lt;Key&gt;&gt; rows = new ArrayList&lt;List&lt;Key&gt;&gt;(2);

            for (int i = 0; i &lt; nRows; i++) {
                int start = i * nKeysPerRow;
                int end = Math.min(start + nKeysPerRow, nKeys);
                if (start &gt;= end)
                    break;

                List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(nKeysPerRow);
                for (int j = start; j &lt; end; j++) {
                    tmpKey = new CharKey(secondaryVK.chars[j], null, null);
                    tmpKey.col= (j - start) * 2;
                    tmpKey.colSpan = 2;
                    for (String sc : tmpKey.getStyleClass()) {
                        tmpKey.text.getStyleClass().add(sc + &quot;-text&quot;);
                        tmpKey.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                        tmpKey.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                    }
                    if (secondaryVK.chars[j] != null &amp;&amp; secondaryVK.chars[j].length() &gt; 1) {
                        tmpKey.text.getStyleClass().add(&quot;multi-char-text&quot;);
                    }
                    keys.add(tmpKey);
                }
                rows.add(keys);
            }
            currentBoard = rows;

            getChildren().clear();
            numCols = 0;
            for (List&lt;Key&gt; row : currentBoard) {
                for (Key key : row) {
                    numCols = Math.max(numCols, key.col + key.colSpan);
                }
                getChildren().addAll(row);
            }
        }
    }

    /**
     * builds primary VK based on the keyboard
     * type set on the VirtualKeyboard.
     */
    private void rebuildPrimaryVK(String type) {
        currentBoard = loadBoard(type);

        //Clear all state keys and updates current board
        clearStateKeys();

        getChildren().clear();
        numCols = 0;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                numCols = Math.max(numCols, key.col + key.colSpan);
            }
            getChildren().addAll(row);
        }
    }

    // This skin is designed such that it gives equal widths to all columns. So
    // the pref width is just some hard-coded value (although I could have maybe
    // done it based on the pref width of a text node with the right font).
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return leftInset + (56 * numCols) + rightInset;
    }

    // Pref height is just some value. This isn't overly important.
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + (80 * 5) + bottomInset;
    }

    // Lays the buttons comprising the current keyboard out.
    @Override
    protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        // I have fixed width columns, all the same.
        int numRows = currentBoard.size();
        final double colWidth = ((contentWidth - ((numCols - 1) * GAP)) / numCols);
        double rowHeight = ((contentHeight - ((numRows - 1) * GAP)) / numRows);
        double rowY = contentY;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                double startX = contentX + (key.col * (colWidth + GAP));
                double width = (key.colSpan * (colWidth + GAP)) - GAP;
                key.resizeRelocate((int)(startX + .5), (int)(rowY + .5),
                                   width, rowHeight);
            }
            rowY += rowHeight + GAP;
        }
    }


    /**
     * A Key on the virtual keyboard. This is simply a Region. Some information
     * about the key relative to other keys on the layout is given by the col
     * and colSpan fields.
     */
    private class Key extends Region {
        int col = 0;
        int colSpan = 1;
        protected final Text text;
        protected final Text altText;
        protected final Region icon;

        protected Key() {
            icon = new Region();
            text = new Text();
            text.setTextOrigin(VPos.TOP);
            altText = new Text();
            altText.setTextOrigin(VPos.TOP);
            getChildren().setAll(text, altText, icon);
            getStyleClass().setAll(&quot;key&quot;);
            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    press();
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    release();
            });
        }
        protected void press() { }
        protected void release() {
            clearShift();
        }

        public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) { }

        @Override protected void layoutChildren() {
            final double left = snappedLeftInset();
            final double top = snappedTopInset();
            final double width = getWidth() - left - snappedRightInset();
            final double height = getHeight() - top - snappedBottomInset();

            text.setVisible(icon.getBackground() == null);
            double contentPrefWidth = text.prefWidth(-1);
            double contentPrefHeight = text.prefHeight(-1);
            text.resizeRelocate(
                    (int) (left + ((width - contentPrefWidth) / 2) + .5),
                    (int) (top + ((height - contentPrefHeight) / 2) + .5),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            altText.setVisible(icon.getBackground() == null &amp;&amp; altText.getText().length() &gt; 0);
            contentPrefWidth = altText.prefWidth(-1);
            contentPrefHeight = altText.prefHeight(-1);
            altText.resizeRelocate(
                    (int) left + (width - contentPrefWidth) + .5,
                    (int) (top + ((height - contentPrefHeight) / 2) + .5 - height/2),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            icon.resizeRelocate(left-8, top-8, width+16, height+16);
        }

    }

    /**
     * Any key on the keyboard which will send a KeyEvent to the client. This
     * class just maintains the state and logic for firing an event, using the
     * &quot;chars&quot; and &quot;code&quot; as the values sent in the event. A subclass must set
     * these appropriately.
     */
    private class TextInputKey extends Key {
        String chars = &quot;&quot;;

        protected void press() {
        }
        protected void release() {
            if (fxvk != secondaryVK &amp;&amp; secondaryPopup != null &amp;&amp; secondaryPopup.isShowing()) {
                return;
            }
            sendKeyEvents();
            if (fxvk == secondaryVK) {
                showSecondaryVK(null);
            }
            super.release();
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                if (chars != null) {
                    target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                }
            }
        }
    }

    /**
     * A key which has a letter, a number or symbol on it
     *
     */
    private class CharKey extends TextInputKey {
        private final String letterChars;
        private final String altChars;
        private final String[] moreChars;

        private CharKey(String letter, String alt, String[] moreChars, String id) {
            this.letterChars = letter;
            this.altChars = alt;
            this.moreChars = moreChars;
            this.chars = this.letterChars;

            text.setText(this.chars);
            altText.setText(this.altChars);
            if (vkLookup) {
                setId((id != null ? id : chars).replaceAll(&quot;\\.&quot;, &quot;&quot;));
            }
        }

        private CharKey(String letter, String alt, String[] moreChars) {
            this(letter, alt, moreChars, null);
        }

        protected void press() {
            super.press();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                showSecondaryVK(null);
                secondaryVKKey = CharKey.this;
                secondaryVKDelay.playFromStart();
            }
        }

        protected void release() {
            super.release();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                secondaryVKDelay.stop();
            }
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            if (isSymbol) {
                chars = altChars;
                text.setText(chars);
                if (moreChars != null &amp;&amp; moreChars.length &gt; 0 &amp;&amp; !Character.isLetter(moreChars[0].charAt(0))) {
                    altText.setText(moreChars[0]);
                } else {
                    altText.setText(null);
                }
            } else {
                chars = (capsDown || shiftDown) ? letterChars.toUpperCase() : letterChars.toLowerCase();
                text.setText(chars);
                altText.setText(altChars);
            }
        }
    }

    /**
     * One of several TextInputKeys which have super powers, such as &quot;Tab&quot; and
     * &quot;Return&quot; and &quot;Backspace&quot;. These keys still send events to the client,
     * but may also have additional state related functionality on the keyboard
     * such as the &quot;Shift&quot; key.
     */
    private class SuperKey extends TextInputKey {
        private SuperKey(String letter, String code) {
            this.chars = code;
            text.setText(letter);
            getStyleClass().add(&quot;special&quot;);
            if (vkLookup) {
                setId(letter);
            }
        }
    }

    /**
     * Some keys actually do need to use KeyCode for pressed / released events,
     * and BackSpace is one of them.
     */
    private class KeyCodeKey extends SuperKey {
        private KeyCode code;

        private KeyCodeKey(String letter, String c, KeyCode code) {
            super(letter, c);
            this.code = code;
            if (vkLookup) {
                setId(letter);
            }
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                target.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_RELEASED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
            }
        }
    }

    /**
     * These keys only manipulate the state of the keyboard and never
     * send key events to the client. For example, &quot;Hide&quot;, &quot;Caps Lock&quot;,
     * etc are all KeyboardStateKeys.
     */
    private class KeyboardStateKey extends Key {
        private final String defaultText;
        private final String toggledText;

        private KeyboardStateKey(String defaultText, String toggledText, String id) {
            this.defaultText = defaultText;
            this.toggledText = toggledText;
            text.setText(this.defaultText);
            if (vkLookup &amp;&amp; id != null) {
                setId(id);
            }
            getStyleClass().add(&quot;special&quot;);
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            //change icon

            if (isSymbol) {
                text.setText(this.toggledText);
            } else {
                text.setText(this.defaultText);
            }
        }
    }

    private void showSecondaryVK(final CharKey key) {
        if (key != null) {
            final Node textInput = primaryVK.getAttachedNode();

            if (secondaryVK == null) {
                secondaryVK = new FXVK();
                //secondaryVK.getStyleClass().addAll(&quot;fxvk-secondary&quot;, &quot;fxvk-portrait&quot;);
                secondaryVK.setSkin(new FXVKSkin(secondaryVK));
                secondaryVK.getStyleClass().setAll(&quot;fxvk-secondary&quot;);
                secondaryPopup = new Popup();
                secondaryPopup.setAutoHide(true);
                secondaryPopup.getContent().add(secondaryVK);
            }

            secondaryVK.chars=null;
            ArrayList&lt;String&gt; secondaryList = new ArrayList&lt;String&gt;();

            // Add primary character
            if (!isSymbol) {
                if (key.letterChars != null &amp;&amp; key.letterChars.length() &gt; 0) {
                    if (shiftDown || capsDown) {
                        secondaryList.add(key.letterChars.toUpperCase());
                    } else {
                        secondaryList.add(key.letterChars);
                    }
                }
            }

            // Add secondary character
            if (key.altChars != null &amp;&amp; key.altChars.length() &gt; 0) {
                if (shiftDown || capsDown) {
                    secondaryList.add(key.altChars.toUpperCase());
                } else {
                    secondaryList.add(key.altChars);
                }
            }

            // Add more letters
            if (key.moreChars != null &amp;&amp; key.moreChars.length &gt; 0) {
                if (isSymbol) {
                    //Add non-letters
                    for (String ch : key.moreChars) {
                        if (!Character.isLetter(ch.charAt(0))) {
                            secondaryList.add(ch);
                        }
                    }
                 } else {
                    //Add letters
                    for (String ch : key.moreChars) {
                        if (Character.isLetter(ch.charAt(0))) {
                            if (shiftDown || capsDown) {
                                secondaryList.add(ch.toUpperCase());
                            } else {
                                secondaryList.add(ch);
                            }
                        }
                    }
                }
            }

            boolean isMultiChar = false;
            for (String s : secondaryList) {
                if (s.length() &gt; 1 ) {
                    isMultiChar = true;
                }
            }

            secondaryVK.chars = secondaryList.toArray(new String[secondaryList.size()]);

            if (secondaryVK.chars.length &gt; 1) {
                if (secondaryVK.getSkin() != null) {
                    ((FXVKSkin)secondaryVK.getSkin()).rebuildSecondaryVK();
                }

                secondaryVK.setAttachedNode(textInput);
                FXVKSkin primarySkin = (FXVKSkin)primaryVK.getSkin();
                FXVKSkin secondarySkin = (FXVKSkin)secondaryVK.getSkin();
                //Insets insets = secondarySkin.getInsets();
                int nKeys = secondaryVK.chars.length;
                int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
                int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

                final double w = snappedLeftInset() + snappedRightInset() +
                                 nKeysPerRow * PREF_PORTRAIT_KEY_WIDTH * (isMultiChar ? 2 : 1) + (nKeysPerRow - 1) * GAP;
                final double h = snappedTopInset() + snappedBottomInset() +
                                 nRows * PREF_KEY_HEIGHT + (nRows-1) * GAP;

                secondaryVK.setPrefWidth(w);
                secondaryVK.setMinWidth(USE_PREF_SIZE);
                secondaryVK.setPrefHeight(h);
                secondaryVK.setMinHeight(USE_PREF_SIZE);
                Platform.runLater(() -&gt; {
                    // Position popup on screen
                    Point2D nodePoint =
                        com.sun.javafx.util.Utils.pointRelativeTo(key, w, h, HPos.CENTER, VPos.TOP,
                                                             5, -3, true);
                    double x = nodePoint.getX();
                    double y = nodePoint.getY();
                    Scene scene = key.getScene();
                    x = Math.min(x, scene.getWindow().getX() + scene.getWidth() - w);
                    secondaryPopup.show(key.getScene().getWindow(), x, y);
                });
            }
        } else {
            closeSecondaryVK();
        }
    }


    private List&lt;List&lt;Key&gt;&gt; loadBoard(String type) {
        List&lt;List&lt;Key&gt;&gt; tmpBoard = boardMap.get(type);
        if (tmpBoard != null) {
            return tmpBoard;
        }

        String boardFileName = type.substring(0,1).toUpperCase() + type.substring(1).toLowerCase() + &quot;Board.txt&quot;;
        try {
            tmpBoard = new ArrayList&lt;List&lt;Key&gt;&gt;(5);
            List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(20);

            InputStream boardFile = FXVKSkin.class.getResourceAsStream(boardFileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(boardFile, &quot;UTF-8&quot;));
            String line;
            // A pointer to the current column. This will be incremented for every string
            // of text, or space.
            int c = 0;
            // The col at which the key will be placed
            int col = 0;
            // The number of columns that the key will span
            int colSpan = 1;
            // Whether the &quot;chars&quot; is an identifier, like $shift or $SymbolBoard, etc.
            boolean identifier = false;
            // The textual content of the Key
            List&lt;String&gt; charsList = new ArrayList&lt;String&gt;(10);

            while ((line = reader.readLine()) != null) {
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                // A single line represents a single row of buttons
                for (int i=0; i&lt;line.length(); i++) {
                    char ch = line.charAt(i);

                    // Process the char
                    if (ch == ' ') {
                        c++;
                    } else if (ch == '[') {
                        // Start of a key
                        col = c;
                        charsList = new ArrayList&lt;String&gt;(10);
                        identifier = false;
                    } else if (ch == ']') {
                        String chars = &quot;&quot;;
                        String alt = null;
                        String[] moreChars = null;

                        for (int idx = 0; idx &lt; charsList.size(); idx++) {
                            charsList.set(idx, FXVKCharEntities.get(charsList.get(idx)));
                        }

                        int listSize = charsList.size();
                        if (listSize &gt; 0) {
                            chars = charsList.get(0);
                            if (listSize &gt; 1) {
                                alt = charsList.get(1);
                                if (listSize &gt; 2) {
                                    moreChars = charsList.subList(2, listSize).toArray(new String[listSize - 2]);
                                }
                            }
                        }

                        // End of a key
                        colSpan = c - col;
                        Key key;
                        if (identifier) {
                            if (&quot;$shift&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;&quot;, null, &quot;shift&quot;) {
                                    @Override protected void release() {
                                        pressShift();
                                    }

                                    @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
                                        if (isSymbol) {
                                            this.setDisable(true);
                                            this.setVisible(false);
                                        } else {
                                            if (capsDown) {
                                                icon.getStyleClass().remove(&quot;shift-icon&quot;);
                                                icon.getStyleClass().add(&quot;capslock-icon&quot;);
                                            } else {
                                                icon.getStyleClass().remove(&quot;capslock-icon&quot;);
                                                icon.getStyleClass().add(&quot;shift-icon&quot;);
                                            }
                                            this.setDisable(false);
                                            this.setVisible(true);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;shift&quot;);

                            } else if (&quot;$SymbolABC&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;!#123&quot;, &quot;ABC&quot;, &quot;symbol&quot;) {
                                    @Override protected void release() {
                                        pressSymbolABC();
                                    }
                                };
                            } else if (&quot;$backspace&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;backspace&quot;, &quot;\b&quot;, KeyCode.BACK_SPACE) {
                                    @Override protected void press() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            clearShift();
                                            sendKeyEvents();
                                            repeatKey = this;
                                            repeatInitialDelay.playFromStart();
                                        } else {
                                            super.press();
                                        }
                                    }
                                    @Override protected void release() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            repeatInitialDelay.stop();
                                            repeatSubsequentDelay.stop();
                                        } else {
                                            super.release();
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;backspace&quot;);
                            } else if (&quot;$enter&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;enter&quot;, &quot;\n&quot;, KeyCode.ENTER);
                                key.getStyleClass().add(&quot;enter&quot;);
                            } else if (&quot;$tab&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;tab&quot;, &quot;\t&quot;, KeyCode.TAB);
                            } else if (&quot;$space&quot;.equals(chars)) {
                                key = new CharKey(&quot; &quot;, &quot; &quot;, null, &quot;space&quot;);
                            } else if (&quot;$clear&quot;.equals(chars)) {
                                key = new SuperKey(&quot;clear&quot;, &quot;&quot;);
                            } else if (&quot;$.org&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.org&quot;, &quot;.org&quot;);
                            } else if (&quot;$.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.com&quot;, &quot;.com&quot;);
                            } else if (&quot;$.net&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.net&quot;, &quot;.net&quot;);
                            } else if (&quot;$oracle.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;oracle.com&quot;, &quot;oracle.com&quot;);
                            } else if (&quot;$gmail.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;gmail.com&quot;, &quot;gmail.com&quot;);
                            } else if (&quot;$hide&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;hide&quot;, null, &quot;hide&quot;) {
                                    @Override protected void release() {
                                        isVKHidden = true;
                                        startSlideOut(false);
                                        // Restore window position
                                        if (vkAdjustWindow) {
                                            restoreWindowPosition(attachedNode);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;hide&quot;);
                            } else if (&quot;$undo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;undo&quot;, &quot;&quot;);
                            } else if (&quot;$redo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;redo&quot;, &quot;&quot;);
                            } else {
                                //Unknown Key
                                key = null;
                            }
                        } else {
                            key = new CharKey(chars, alt, moreChars);
                        }
                        if (key != null) {
                            key.col = col;
                            key.colSpan = colSpan;
                            for (String sc : key.getStyleClass()) {
                                key.text.getStyleClass().add(sc + &quot;-text&quot;);
                                key.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                                key.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                            }
                            if (chars != null &amp;&amp; chars.length() &gt; 1) {
                                key.text.getStyleClass().add(&quot;multi-char-text&quot;);
                            }
                            if (alt != null &amp;&amp; alt.length() &gt; 1) {
                                key.altText.getStyleClass().add(&quot;multi-char-text&quot;);
                            }

                            keys.add(key);
                        }
                    } else {
                        // Normal textual characters. Read all the way up to the
                        // next ] or space
                        for (int j=i; j&lt;line.length(); j++) {
                            char c2 = line.charAt(j);
                            boolean e = false;
                            if (c2 == '\\') {
                                j++;
                                i++;
                                e = true;
                                c2 = line.charAt(j);
                            }

                            if (c2 == '$' &amp;&amp; !e) {
                                identifier = true;
                            }

                            if (c2 == '|' &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j + 1;
                            } else if ((c2 == ']' || c2 == ' ') &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j-1;
                                break;
                            }
                        }
                        c++;
                    }
                }

                c = 0;
                col = 0;
                tmpBoard.add(keys);
                keys = new ArrayList&lt;Key&gt;(20);
            }
            reader.close();
            boardMap.put(type, tmpBoard);
            return tmpBoard;
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextInputControl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.text.Font;

import java.text.BreakIterator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.util.Utils;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.scene.NodeHelper;
import javafx.util.StringConverter;

/**
 * Abstract base class for text input controls.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public abstract class TextInputControl extends Control {
    /**
     * Interface representing a text input's content. Since it is an ObservableStringValue,
     * you can also bind to, or observe the content.
     * @since JavaFX 2.0
     */
    protected interface Content extends ObservableStringValue {
        /**
         * Retrieves a subset of the content.
         *
         * @param start the start
         * @param end the end
         * @return a subset of the content
         */
        public String get(int start, int end);

        /**
         * Inserts a sequence of characters into the content.
         *
         * @param index the index
         * @param text the text string
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void insert(int index, String text, boolean notifyListeners);

        /**
         * Removes a sequence of characters from the content.
         *
         * @param start the start
         * @param end the end
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void delete(int start, int end, boolean notifyListeners);

        /**
         * Returns the number of characters represented by the content.
         * @return the number of characters
         */
        public int length();
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TextInputControl. The content is an immutable property and
     * must be specified (as non-null) at the time of construction.
     *
     * @param content a non-null implementation of Content.
     */
    protected TextInputControl(final Content content) {
        this.content = content;

        // Add a listener so that whenever the Content is changed, we notify
        // listeners of the text property that it is invalid.
        content.addListener(observable -&gt; {
            if (content.length() &gt; 0) {
                text.textIsNull = false;
            }
            text.controlContentHasChanged();
        });

        // Bind the length to be based on the length of the text property
        length.bind(new IntegerBinding() {
            { bind(text); }
            @Override protected int computeValue() {
                String txt = text.get();
                return txt == null ? 0 : txt.length();
            }
        });

        // Bind the selected text to be based on the selection and text properties
        selectedText.bind(new StringBinding() {
            { bind(selection, text); }
            @Override protected String computeValue() {
                String txt = text.get();
                IndexRange sel = selection.get();
                if (txt == null || sel == null) return &quot;&quot;;

                int start = sel.getStart();
                int end = sel.getEnd();
                int length = txt.length();
                if (end &gt; start + length) end = length;
                if (start &gt; length-1) start = end = 0;
                return txt.substring(start, end);
            }
        });

        focusedProperty().addListener((ob, o, n) -&gt; {
            if (n) {
                if (getTextFormatter() != null) {
<A NAME="6"></A>                    updateText(getTextFormatter());
                }
            } else {
                <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#6',2,'match58-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>commitValue();
            }
        });

        // Specify the default style class
        getStyleClass().add(&quot;text-input&quot;);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The default font to use for text in the TextInputControl. If the TextInputControl's text is
     * rich text then this font may or may not be used depending on the font
     * information embedded in the rich text, but in any case where a default
     * font is required, this font will be used.
     * @return the font property
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Font&gt; fontProperty() {</B></FONT>
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {


                private boolean fontSetByCss = false;

                @Override
                public void applyStyle(StyleOrigin newOrigin, Font value) {

                    //
                    // RT-20727 - if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS
                    //
                    try {
                        // super.applyStyle calls set which might throw if value is bound.
                        // Have to make sure fontSetByCss is reset.
                        fontSetByCss = true;
                        super.applyStyle(newOrigin, value);
                    } catch(Exception e) {
                        throw e;
                    } finally {
                        fontSetByCss = false;
                    }

                }


                @Override
                public void set(Font value) {
                    final Font oldValue = get();
                    if (value == null ? oldValue == null : value.equals(oldValue)) {
                        return;
                    }
                    super.set(value);
                }

                @Override
                protected void invalidated() {
                    // RT-20727 - if font is changed by calling setFont, then
                    // css might need to be reapplied since font size affects
                    // calculated values for styles with relative values
                    if(fontSetByCss == false) {
                        NodeHelper.reapplyCSS(TextInputControl.this);
                    }
                }

                @Override
                public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }

                @Override
                public Object getBean() {
                    return TextInputControl.this;
                }

                @Override
                public String getName() {
                    return &quot;font&quot;;
                }
            };
        }
        return font;
    }

    private ObjectProperty&lt;Font&gt; font;
    public final void setFont(Font value) { fontProperty().setValue(value); }
    public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }

    /**
     * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
     * prompt text is displayed.
     *
     * @defaultValue An empty String
     * @since JavaFX 2.2
     */
    private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
        @Override protected void invalidated() {
            // Strip out newlines
            String txt = get();
            if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
                txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
                set(txt);
            }
        }
    };
    public final StringProperty promptTextProperty() { return promptText; }
    public final String getPromptText() { return promptText.get(); }
    public final void setPromptText(String value) { promptText.set(value); }


    /**
     * The property contains currently attached {@link TextFormatter}.
     * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
     *
     * @defaultValue null
     * @since JavaFX 8u40
     */
    private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {

        private TextFormatter&lt;?&gt; oldFormatter = null;

        @Override
        public Object getBean() {
            return TextInputControl.this;
        }

        @Override
        public String getName() {
            return &quot;textFormatter&quot;;
        }

        @Override
        protected void invalidated() {
            final TextFormatter&lt;?&gt; formatter = get();
            try {
                if (formatter != null) {
                    try {
                        formatter.bindToControl(f -&gt; updateText(f));
                    } catch (IllegalStateException e) {
                        if (isBound()) {
                            unbind();
                        }
                        set(null);
                        throw e;
                    }
                    if (!isFocused()) {
                        updateText(get());
                    }
                }

                if (oldFormatter != null) {
                    oldFormatter.unbindFromControl();
                }
            } finally {
                oldFormatter = formatter;
            }
        }
    };
    public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
    public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
    public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }

    private final Content content;
    /**
     * Returns the text input's content model.
     * @return the text input's content model
     */
    protected final Content getContent() {
        return content;
    }

    /**
     * The textual content of this TextInputControl.
     */
    private TextProperty text = new TextProperty();
    public final String getText() { return text.get(); }
    public final void setText(String value) { text.set(value); }
    public final StringProperty textProperty() { return text; }

    /**
     * The number of characters in the text input.
     */
    private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
    public final int getLength() { return length.get(); }
    public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }

    /**
     * Indicates whether this TextInputControl can be edited by the user.
     */
    private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
        }
    };
    public final boolean isEditable() { return editable.getValue(); }
    public final void setEditable(boolean value) { editable.setValue(value); }
    public final BooleanProperty editableProperty() { return editable; }

    /**
     * The current selection.
     */
    private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
    public final IndexRange getSelection() { return selection.getValue(); }
    public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }

    /**
     * Defines the characters in the TextInputControl which are selected
     */
    private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
    public final String getSelectedText() { return selectedText.get(); }
    public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }

    /**
     * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the anchor might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
    public final int getAnchor() { return anchor.get(); }
    public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }

    /**
     * The current position of the caret within the text.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the caretPosition might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
    public final int getCaretPosition() { return caretPosition.get(); }
    public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }

    private UndoRedoChange undoChangeHead = new UndoRedoChange();
    private UndoRedoChange undoChange = undoChangeHead;
    private boolean createNewUndoRecord = false;

    /**
     * The property describes if it's currently possible to undo the latest change of the content that was done.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
    public final boolean isUndoable() { return undoable.get(); }
    public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }


    /**
     * The property describes if it's currently possible to redo the latest change of the content that was undone.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
    public final boolean isRedoable() { return redoable.get(); }
    public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a subset of the text input's content.
     *
     * @param start must be a value between 0 and end - 1.
     * @param end must be less than or equal to the length
     * @return the subset of the text input's content
     */
    public String getText(int start, int end) {
        if (start &gt; end) {
            throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        return getContent().get(start, end);
    }

    /**
     * Appends a sequence of characters to the content.
     *
     * @param text a non null String
     */
    public void appendText(String text) {
        insertText(getLength(), text);
    }

    /**
     * Inserts a sequence of characters into the content.
     *
     * @param index The location to insert the text.
     * @param text The text to insert.
     */
    public void insertText(int index, String text) {
        replaceText(index, index, text);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param range The range of text to delete. The range object must not be null.
     *
     * @see #deleteText(int, int)
     */
    public void deleteText(IndexRange range) {
        replaceText(range, &quot;&quot;);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     */
    public void deleteText(int start, int end) {
        replaceText(start, end, &quot;&quot;);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param range The range of text to replace. The range object must not be null.
     * @param text The text that is to replace the range. This must not be null.
     *
     * @see #replaceText(int, int, String)
     */
    public void replaceText(IndexRange range, String text) {
        final int start = range.getStart();
        final int end = start + range.getLength();
        replaceText(start, end, text);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param text The text that is to replace the range. This must not be null.
     */
    public void replaceText(final int start, final int end, final String text) {
        if (start &gt; end) {
            throw new IllegalArgumentException();
        }

        if (text == null) {
            throw new NullPointerException();
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        if (!this.text.isBound()) {
            final int oldLength = getLength();
            TextFormatter&lt;?&gt; formatter = getTextFormatter();
            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
            if (formatter != null &amp;&amp; formatter.getFilter() != null) {
                change = formatter.getFilter().apply(change);
                if (change == null) {
                    return;
                }
            }

            // Update the content
            updateContent(change, oldLength == 0);

        }
    }

    private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
        final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
        String oldText = getText(change.start, change.end);
        int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
        if (newText.equals(oldText)) {
            // Undo record not required as there is no change in the text.
            return;
        }

        /*
         * A new undo record is created, if
         * 1. createNewUndoRecord is true, currently it is set to true for paste operation
         * 2. Text is selected and a character is typed
         * 3. This is the first operation to be added to undo record
         * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
         * 5. Space character is typed
         * 6. 2500 milliseconds are elapsed since the undo record was created
         * 7. Cursor position is changed and a character is typed
         * 8. A range of text is replaced programmatically using replaceText()
         * Otherwise, the last undo record is updated or discarded.
         */

        int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
        boolean isNewSpaceChar = false;
        if (newText.equals(&quot; &quot;)) {
            if (!UndoRedoChange.isSpaceCharSequence()) {
                isNewSpaceChar = true;
                UndoRedoChange.setSpaceCharSequence(true);
            }
        } else {
            UndoRedoChange.setSpaceCharSequence(false);
        }
        if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
                isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
                (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
            undoChange = undoChange.add(change.start, oldText, newText);
        } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
            // I know I am deleting, and am located at the end of the range of the current undo record
            if (undoChange.newText.length() &gt; 0) {
                undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
                if (undoChange.newText.isEmpty()) {
                    // throw away this undo change record
                    undoChange = undoChange.discard();
                }
            } else {
                if (change.start == endOfUndoChange) {
                    undoChange.oldText += oldText;
                } else { // end == endOfUndoChange
                    undoChange.oldText = oldText + undoChange.oldText;
                    undoChange.start--;
                }
            }
        } else {
            // I know I am adding, and am located at the end of the range of the current undo record
            undoChange.newText += newText;
        }
        updateUndoRedoState();
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * removing the current selection.
     */
    public void cut() {
        copy();
        IndexRange selection = getSelection();
        deleteText(selection.getStart(), selection.getEnd());
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * leaving the current selection.
     */
     public void copy() {
        final String selectedText = getSelectedText();
        if (selectedText.length() &gt; 0) {
            final ClipboardContent content = new ClipboardContent();
            content.putString(selectedText);
            Clipboard.getSystemClipboard().setContent(content);
        }
    }

    /**
     * Transfers the contents in the clipboard into this text,
     * replacing the current selection.  If there is no selection, the contents
     * in the clipboard is inserted at the current caret position.
     */
    public void paste() {
        final Clipboard clipboard = Clipboard.getSystemClipboard();
        if (clipboard.hasString()) {
            final String text = clipboard.getString();
            if (text != null) {
                createNewUndoRecord = true;
                try {
                    replaceSelection(text);
                } finally {
                    createNewUndoRecord = false;
                }
            }
        }
    }

    /**
     * Moves the selection backward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caretPosition.
     */
    public void selectBackward() {
        if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
            // because the anchor stays put, by moving the caret to the left
            // we ensure that a selection is registered and that it is correct
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
        }
    }

    /**
     * Moves the selection forward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caret forward.
     */
    public void selectForward() {
        final int textLength = getLength();
        if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.following(getCaretPosition()));
        }
    }

    /**
     * The break iterator instances for navigation over words and complex characters.
     */
    private BreakIterator charIterator;
    private BreakIterator wordIterator;

    /**
     * Moves the caret to the beginning of previous word. This function
     * also has the effect of clearing the selection.
     */
    public void previousWord() {
        previousWord(false);
    }

    /**
     * Moves the caret to the beginning of next word. This function
     * also has the effect of clearing the selection.
     */
    public void nextWord() {
        nextWord(false);
    }

    /**
     * Moves the caret to the end of the next word. This function
     * also has the effect of clearing the selection.
     */
    public void endOfNextWord() {
        endOfNextWord(false);
    }

    /**
     * Moves the caret to the beginning of previous word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of previous word.
     */
    public void selectPreviousWord() {
        previousWord(true);
    }

    /**
     * Moves the caret to the beginning of next word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of next word.
     */
    public void selectNextWord() {
        nextWord(true);
    }

    /**
     * Moves the caret to the end of the next word. This does not cause
     * the selection to be cleared.
     */
    public void selectEndOfNextWord() {
        endOfNextWord(true);
    }

    private void previousWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));

        // Skip the non-word region, then move/select to the beginning of the word.
        while (pos != BreakIterator.DONE &amp;&amp;
               !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
            pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
        }

        // move/select
        selectRange(select ? getAnchor() : pos, pos);
    }

    private void nextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
        int current = wordIterator.next();

        // Skip whitespace characters to the beginning of next word, but
        // stop at newline. Then move the caret or select a range.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                char ch = text.charAt(Utils.clamp(0, p, textLength-1));
                // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
                // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
                if (ch != ' ' &amp;&amp; ch != '\t') {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    private void endOfNextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
        int current = wordIterator.next();

        // skip the non-word region, then move/select to the end of the word.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    /**
     * Selects all text in the text input.
     */
    public void selectAll() {
        selectRange(0, getLength());
    }

    /**
     * Moves the caret to before the first char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void home() {
        // user wants to go to start
        selectRange(0, 0);
    }

    /**
     * Moves the caret to after the last char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void end() {
        // user wants to go to end
        final int textLength = getLength();
        if (textLength &gt; 0) {
            selectRange(textLength, textLength);
        }
    }

    /**
     * Moves the caret to before the first char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to before the first char.
     */
    public void selectHome() {
        selectRange(getAnchor(), 0);
    }

    /**
     * Moves the caret to after the last char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to after the last char.
     */
    public void selectEnd() {
        final int textLength = getLength();
        if (textLength &gt; 0) selectRange(getAnchor(), textLength);
    }

    /**
     * Deletes the character that precedes the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deletePreviousChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (dot &gt; 0) {
                // The caret is not at the beginning, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                // Note: Do not use charIterator here, because we do want to
                // break up clusters when deleting backwards.
                int p = Character.offsetByCodePoints(text, dot, -1);
                deleteText(p, dot);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Deletes the character that follows the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deleteNextChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final int textLength = getLength();
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
                // The caret is not at the end, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                if (charIterator == null) {
                    charIterator = BreakIterator.getCharacterInstance();
                }
                charIterator.setText(text);
                int p = charIterator.following(dot);
                deleteText(dot, p);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Moves the caret position forward. If there is no selection, then the
     * caret position is moved one character forward. If there is a selection,
     * then the caret position is moved to the end of the selection and
     * the selection cleared.
     */
    public void forward() {
        // user has moved caret to the right
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.max(dot, mark);
            selectRange(pos, pos);
        } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.following(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Moves the caret position backward. If there is no selection, then the
     * caret position is moved one character backward. If there is a selection,
     * then the caret position is moved to the beginning of the selection and
     * the selection cleared.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void backward() {
        // user has moved caret to the left
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.min(dot, mark);
            selectRange(pos, pos);
        } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.preceding(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Positions the caret to the position indicated by {@code pos}. This
     * function will also clear the selection.
     * @param pos the position
     */
    public void positionCaret(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        selectRange(p, p);
    }

    /**
     * Positions the caret to the position indicated by {@code pos} and extends
     * the selection, if there is one. If there is no selection, then a
     * selection is formed where the anchor is at the current caret position
     * and the caretPosition is moved to pos.
     * @param pos the position
     */
    public void selectPositionCaret(int pos) {
        selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
    }

    /**
     * Positions the anchor and caretPosition explicitly.
     * @param anchor the anchor
     * @param caretPosition the caretPosition
     */
    public void selectRange(int anchor, int caretPosition) {
        caretPosition = Utils.clamp(0, caretPosition, getLength());
        anchor = Utils.clamp(0, anchor, getLength());

        TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        if (formatter != null &amp;&amp; formatter.getFilter() != null) {
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return;
            }
        }

        updateContent(change, false);
    }

    private void doSelectRange(int anchor, int caretPosition) {
        this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
        this.anchor.set(Utils.clamp(0, anchor, getLength()));
        this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
        notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
    }

    /**
     * This function will extend the selection to include the specified pos.
     * This is different from selectPositionCaret in that it does not simply
     * move the caret. Rather, it will reposition the caret and anchor as necessary
     * to ensure that pos becomes the new caret and the far other end of the
     * selection becomes the anchor.
     * @param pos the position
     */
    public void extendSelection(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        int start = Math.min(dot, mark);
        int end = Math.max(dot, mark);
        if (p &lt; start) {
            selectRange(end, p);
        } else {
            selectRange(start, p);
        }
    }

    /**
     * Clears the text.
     */
    public void clear() {
        deselect();
        if (!text.isBound()) {
            setText(&quot;&quot;);
        }
    }

    /**
     * Clears the selection.
     */
    public void deselect() {
        // set the anchor equal to the caret position, which clears the selection
        // while also preserving the caret position
        selectRange(getCaretPosition(), getCaretPosition());
    }

    /**
     * Replaces the selection with the given replacement String. If there is
     * no selection, then the replacement text is simply inserted at the current
     * caret position. If there was a selection, then the selection is cleared
     * and the given replacement text inserted.
     * @param replacement the replacement string
     */
    public void replaceSelection(String replacement) {
        replaceText(getSelection(), replacement);
    }

    /**
     * If possible, undoes the last modification. If {@link #isUndoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void undo() {
        if (isUndoable()) {
            // Apply reverse change here
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (newText != null) {
                getContent().delete(start, start + newText.length(), oldText.isEmpty());
            }

            if (oldText != null) {
                getContent().insert(start, oldText, true);
                doSelectRange(start, start + oldText.length());
            } else {
                doSelectRange(start, start + newText.length());
            }

            undoChange = undoChange.prev;
        }
        updateUndoRedoState();
    }

    /**
     * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void redo() {
        if (isRedoable()) {
            // Apply change here
            undoChange = undoChange.next;
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (oldText != null) {
                getContent().delete(start, start + oldText.length(), newText.isEmpty());
            }

            if (newText != null) {
                getContent().insert(start, newText, true);
                doSelectRange(start + newText.length(), start + newText.length());
            } else {
                doSelectRange(start, start);
            }
        }
        updateUndoRedoState();
        // else beep ?
    }

    // Used by TextArea, although there are probably other better ways of
    // doing this.
    void textUpdated() { }

    private void resetUndoRedoState() {
        undoChange = undoChangeHead;
        undoChange.next = null;
        updateUndoRedoState();
    }

    private void updateUndoRedoState() {
        undoable.set(undoChange != undoChangeHead);
        redoable.set(undoChange.next != null);
    }

    private boolean filterAndSet(String value) {
        // Send the new value through the textFormatter, if one exists.
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        int length = content.length();
        if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
            TextFormatter.Change change = new TextFormatter.Change(
                    TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return false;
            }
            replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        } else {
            replaceText(0, length, value, 0, 0);
        }
        return true;
    }

    /**
     * This is what is ultimately called by every code path that will update
     * the content (except for undo / redo). The input into this method has
     * already run through the textFormatter where appropriate.
     *
     * @param start            The start index into the existing text which
     *                         will be replaced by the new value
     * @param end              The end index into the existing text which will
     *                         be replaced by the new value. As with
     *                         String.replace this is a lastIndex+1 value
     * @param value            The new text value
     * @param anchor           The new selection anchor after the change is made
     * @param caretPosition    The new selection caretPosition after the change
     *                         is made.
     * @return The amount of adjustment made to the end / anchor / caretPosition to
     *         accommodate for subsequent filtering (such as the filtering of
     *         new lines by the TextField)
     */
    private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
        // RT-16566: Need to take into account stripping of chars into the
        // final anchor &amp; caret position
        int length = getLength();
        int adjustmentAmount = 0;
        if (end != start) {
            getContent().delete(start, end, value.isEmpty());
            length -= (end - start);
        }
        if (value != null) {
            getContent().insert(start, value, true);
            adjustmentAmount = value.length() - (getLength() - length);
            anchor -= adjustmentAmount;
            caretPosition -= adjustmentAmount;
        }
        doSelectRange(anchor, caretPosition);
        return adjustmentAmount;
    }

    private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
        T value = formatter.getValue();
        StringConverter&lt;T&gt; converter = formatter.getValueConverter();
        if (converter != null) {
            String text = converter.toString(value);
            if (text == null) text = &quot;&quot;;
            replaceText(0, getLength(), text, text.length(), text.length());
        }
    }

    /**
     * Commit the current text and convert it to a value.
     * @since JavaFX 8u40
     */
    public final void commitValue() {
        if (getTextFormatter() != null) {
            getTextFormatter().updateValue(getText());
        }
    }

    /**
     * If the field is currently being edited, this call will set text to the last commited value.
     * @since JavaFX 8u40
     */
    public final void cancelEdit() {
        if (getTextFormatter() != null) {
            updateText(getTextFormatter());
        }
    }

    private FormatterAccessor accessor;

    private FormatterAccessor getFormatterAccessor() {
        if (accessor == null) {
            accessor = new TextInputControlFromatterAccessor();
        }
        return accessor;
    }


    /**
     * A little utility method for stripping out unwanted characters.
     *
     * @param txt
     * @param stripNewlines
     * @param stripTabs
     * @return The string after having the unwanted characters stripped out.
     */
    static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
        // Most of the time, when text is inserted, there are no illegal
        // characters. So we'll do a &quot;cheap&quot; check for illegal characters.
        // If we find one, we'll do a longer replace algorithm. In the
        // case of illegal characters, this may at worst be an O(2n) solution.
        // Strip out any characters that are outside the printed range
        if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
            StringBuilder s = new StringBuilder(txt.length());
            for (int i=0; i&lt;txt.length(); i++) {
                final char c = txt.charAt(i);
                if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
                    s.append(c);
                }
            }
            txt = s.toString();
        }
        return txt;
    }

    static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
        for (int i=0; i&lt;txt.length(); i++) {
            final char c = txt.charAt(i);
            if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
        }
        return false;
    }

    private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
        if (c == 0x7F) return true;
        if (c == 0xA) return newlineIllegal;
        if (c == 0x9) return tabIllegal;
        if (c &lt; 0x20) return true;
        return false;
    }

    // It can be bound, in which case we will force it to be an eager
    // binding so that we update the content eagerly
    // It can be bidirectionally bound, which basically will just work
    // If somebody changes the content directly, it will be notified and
    // send an invalidation event.
    private class TextProperty extends StringProperty {
        // This is used only when the property is bound
        private ObservableValue&lt;? extends String&gt; observable = null;
        // Added to the observable when bound
        private InvalidationListener listener = null;
        // Used for event handling
        private ExpressionHelper&lt;String&gt; helper = null;
        // The developer my set the Text property to null. Although
        // the Content must be given an empty String, we must still
        // treat the value as though it were null, so that a subsequent
        // getText() will return null.
        private boolean textIsNull = false;

        @Override public String get() {
            // Since we force eager binding and content is always up to date,
            // we just need to get it from content and not through the binding
            return textIsNull ? null : content.get();
        }

        @Override public void set(String value) {
            if (isBound()) {
                throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
            }
            doSet(value);
            markInvalid();
        }

        /**
         * Called whenever the content on the control has changed (as determined
         * by a listener on the content).
         */
        private void controlContentHasChanged() {
            markInvalid();
            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        }

        @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
            if (observable == null) {
                throw new NullPointerException(&quot;Cannot bind to null&quot;);
            }
            if (!observable.equals(this.observable)) {
                unbind();
                this.observable = observable;
                if (listener == null) {
                    listener = new Listener();
                }
                this.observable.addListener(listener);
                markInvalid();
                doSet(observable.getValue());
            }
        }

        @Override public void unbind() {
            if (observable != null) {
                doSet(observable.getValue());
                observable.removeListener(listener);
                observable = null;
            }
        }

        @Override public boolean isBound() {
            return observable != null;
        }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public Object getBean() {
            return TextInputControl.this;
        }

        @Override public String getName() {
            return &quot;text&quot;;
        }

        private void fireValueChangedEvent() {
            ExpressionHelper.fireValueChangedEvent(helper);
        }

        private void markInvalid() {
            fireValueChangedEvent();
        }

        /**
         * doSet is called whenever the setText() method was called directly
         * on the TextInputControl, or when the text property was bound,
         * unbound, or reacted to a binding invalidation. It is *not* called
         * when modifications to the content happened indirectly, such as
         * through the replaceText / replaceSelection methods.
         *
         * @param value The new value
         */
        private void doSet(String value) {
            // Guard against the null value.
            textIsNull = value == null;
            if (value == null) value = &quot;&quot;;

            if (!filterAndSet(value)) return;

            if (getTextFormatter() != null) {
                getTextFormatter().updateValue(getText());
            }

            textUpdated();

            // If the programmer has directly manipulated the text property
            // or has it bound up, then we will clear out any modifications
            // from the undo manager as we must suppose that the control is
            // being reused, for example, between forms.
            resetUndoRedoState();
        }

        private class Listener implements InvalidationListener {
            @Override
            public void invalidated(Observable valueModel) {
                // We now need to force it to be eagerly recomputed
                // because we need to push these changes to the
                // content model. Because changing the model ends
                // up calling invalidate and markInvalid, the
                // listeners will all be notified.
                doSet(observable.getValue());
            }
        }
    }

    /**
     * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
     * records the old and new text, and the start index. It also has
     * the links to the previous and next Changes in the chain. There
     * are two special UndoRedoChange objects in this chain representing the
     * head and the tail so we can have beforeFirst and afterLast
     * behavior as necessary.
     */
    static class UndoRedoChange {
        static long prevRecordTime;
        static final long CHANGE_DURATION = 2500; // milliseconds
        static boolean spaceCharSequence = false;
        int start;
        String oldText;
        String newText;
        UndoRedoChange prev;
        UndoRedoChange next;

        UndoRedoChange() { }

        public UndoRedoChange add(int start, String oldText, String newText) {
            UndoRedoChange c = new UndoRedoChange();
            c.start = start;
            c.oldText = oldText;
            c.newText = newText;
            c.prev = this;
            next = c;
            prevRecordTime = System.currentTimeMillis();
            return c;
        }

        static boolean hasChangeDurationElapsed() {
            return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
        }

        static void setSpaceCharSequence(boolean value) {
            spaceCharSequence = value;
        }
        static boolean isSpaceCharSequence() {
            return spaceCharSequence;
        }

        public UndoRedoChange discard() {
            prev.next = next;
            return prev;
        }

        // Handy to use when debugging, just put it in undo or redo
        // method or replaceText to see what is happening to the undo
        // history as it occurs.
        void debugPrint() {
            UndoRedoChange c = this;
            System.out.print(&quot;[&quot;);
            while (c != null) {
                System.out.print(c.toString());
                if (c.next != null) System.out.print(&quot;, &quot;);
                c = c.next;
            }
            System.out.println(&quot;]&quot;);
        }

        @Override public String toString() {
            if (oldText == null &amp;&amp; newText == null) {
                return &quot;head&quot;;
            }
            if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;added '&quot; + newText + &quot;' at index &quot; + start;
            } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;replaced '&quot; + oldText + &quot;' with '&quot; + newText + &quot;' at index &quot; + start;
            } else {
                return &quot;deleted '&quot; + oldText + &quot;' at index &quot; + start;
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/


    private static final PseudoClass PSEUDO_CLASS_READONLY
            = PseudoClass.getPseudoClass(&quot;readonly&quot;);

    private static class StyleableProperties {
        private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
            new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(TextInputControl n) {
                return n.font == null || !n.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
                return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FONT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                String text = getText();
                if (text == null || text.isEmpty()) {
                    text = getPromptText();
                }
                return text;
            }
            case EDITABLE: return isEditable();
            case SELECTION_START: return getSelection().getStart();
            case SELECTION_END: return getSelection().getEnd();
            case CARET_OFFSET: return getCaretPosition();
            case FONT: return getFont();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SET_TEXT: {
                String value = (String) parameters[0];
                if (value != null) setText(value);
                break;
            }
            case SET_TEXT_SELECTION: {
                Integer start = (Integer) parameters[0];
                Integer end = (Integer) parameters[1];
                if (start != null &amp;&amp; end != null) {
                    selectRange(start,  end);
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }

    private class TextInputControlFromatterAccessor implements FormatterAccessor {
        @Override
        public int getTextLength() {
            return TextInputControl.this.getLength();
        }

        @Override
        public String getText(int begin, int end) {
            return TextInputControl.this.getText(begin, end);
        }

        @Override
        public int getCaret() {
            return TextInputControl.this.getCaretPosition();
        }

        @Override
        public int getAnchor() {
            return TextInputControl.this.getAnchor();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ColorPalette.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.CustomColorDialog;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.ColorPicker;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Hyperlink;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PopupControl;
import javafx.scene.control.Separator;
import javafx.scene.control.Tooltip;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.StrokeType;

import java.util.List;

import static com.sun.javafx.scene.control.Properties.getColorPickerString;

// Not public API - this is (presently) an implementation detail only
class ColorPalette extends Region {

    private static final int SQUARE_SIZE = 15;

    // package protected for testing purposes
    ColorPickerGrid colorPickerGrid;
    final Hyperlink customColorLink = new Hyperlink(getColorPickerString(&quot;customColorLink&quot;));
    CustomColorDialog customColorDialog = null;

    private ColorPicker colorPicker;
    private final GridPane standardColorGrid = new GridPane();
    private final GridPane customColorGrid = new GridPane();
    private final Separator separator = new Separator();
    private final Label customColorLabel = new Label(getColorPickerString(&quot;customColorLabel&quot;));

    private PopupControl popupControl;
    private ColorSquare focusedSquare;
    private ContextMenu contextMenu = null;

    private Color mouseDragColor = null;
    private boolean dragDetected = false;

    // Metrics for custom colors
    private int customColorNumber = 0;
    private int customColorRows = 0;
    private int customColorLastRowLength = 0;

    private final ColorSquare hoverSquare = new ColorSquare();

    public ColorPalette(final ColorPicker colorPicker) {
        getStyleClass().add(&quot;color-palette-region&quot;);
        this.colorPicker = colorPicker;
        colorPickerGrid = new ColorPickerGrid();
        colorPickerGrid.getChildren().get(0).requestFocus();
        customColorLabel.setAlignment(Pos.CENTER_LEFT);
        customColorLink.setPrefWidth(colorPickerGrid.prefWidth(-1));
        customColorLink.setAlignment(Pos.CENTER);
        customColorLink.setFocusTraversable(true);
        customColorLink.setVisited(true); // so that it always appears blue
        customColorLink.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override public void handle(ActionEvent t) {
                if (customColorDialog == null) {
                    customColorDialog = new CustomColorDialog(popupControl);
                    customColorDialog.customColorProperty().addListener((ov, t1, t2) -&gt; {
                        colorPicker.setValue(customColorDialog.customColorProperty().get());
                    });
                    customColorDialog.setOnSave(() -&gt; {
                        Color customColor = customColorDialog.customColorProperty().get();
                        buildCustomColors();
                        colorPicker.getCustomColors().add(customColor);
                        updateSelection(customColor);
                        Event.fireEvent(colorPicker, new ActionEvent());
                        colorPicker.hide();
                    });
                    customColorDialog.setOnUse(() -&gt; {
                        Event.fireEvent(colorPicker, new ActionEvent());
                        colorPicker.hide();
                    });
                }
                customColorDialog.setCurrentColor(colorPicker.valueProperty().get());
                if (popupControl != null) popupControl.setAutoHide(false);
                customColorDialog.show();
                 customColorDialog.setOnHidden(event -&gt; {
                    if (popupControl != null) popupControl.setAutoHide(true);
                 });
            }
        });

        initNavigation();

        buildStandardColors();
        standardColorGrid.getStyleClass().add(&quot;color-picker-grid&quot;);
        standardColorGrid.setVisible(true);
        customColorGrid.getStyleClass().add(&quot;color-picker-grid&quot;);
        customColorGrid.setVisible(false);
        buildCustomColors();
        colorPicker.getCustomColors().addListener(new ListChangeListener&lt;Color&gt;() {
            @Override public void onChanged(Change&lt;? extends Color&gt; change) {
                buildCustomColors();
            }
        });

        VBox paletteBox = new VBox();
        paletteBox.getStyleClass().add(&quot;color-palette&quot;);
        paletteBox.getChildren().addAll(standardColorGrid, colorPickerGrid, customColorLabel, customColorGrid, separator, customColorLink);

        hoverSquare.setMouseTransparent(true);
        hoverSquare.getStyleClass().addAll(&quot;hover-square&quot;);
        setFocusedSquare(null);

        getChildren().addAll(paletteBox, hoverSquare);
    }

    private void setFocusedSquare(ColorSquare square) {
        if (square == focusedSquare) {
            return;
        }
        focusedSquare = square;

        hoverSquare.setVisible(focusedSquare != null);
        if (focusedSquare == null) {
            return;
        }

        if (!focusedSquare.isFocused()) {
            focusedSquare.requestFocus();
        }

        hoverSquare.rectangle.setFill(focusedSquare.rectangle.getFill());

        Bounds b = square.localToScene(square.getLayoutBounds());

        double x = b.getMinX();
        double y = b.getMinY();

        double xAdjust;
        double scaleAdjust = hoverSquare.getScaleX() == 1.0 ? 0 : hoverSquare.getWidth() / 4.0;

        if (colorPicker.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
            x = focusedSquare.getLayoutX();
            xAdjust = -focusedSquare.getWidth() + scaleAdjust;
        } else {
            xAdjust = focusedSquare.getWidth() / 2.0 + scaleAdjust;
<A NAME="5"></A>        }

        hoverSquare.setLayoutX(snapPositionX(x) - xAdjust);
        hoverSquare.setLayoutY(snapPositionY(y) - focusedSquare.getHeight() / 2.0 + (<FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#5',2,'match58-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>hoverSquare.getScaleY() == 1.0 ? 0 : focusedSquare.getHeight() / 4.0));
    }

    private void buildStandardColors() {
        // WARNING:
        // Make sure that the number of standard colors is equal to NUM_OF_COLUMNS
        // Currently, 12 standard colors are supported in a single row
        // Note : Creation &amp; access logic of standardColorGrid needs to be updated
        // in case more colors are added as separate row(s) in future.

        final Color[] STANDARD_COLORS = {
            Color.AQUA,
            Color.TEAL,
            Color.BLUE,
            Color.NAVY,
            Color.FUCHSIA,
            Color.PURPLE,
            Color.RED,
            Color.MAROON,
            Color.YELLOW,
            Color.OLIVE,
            Color.GREEN,
            Color.LIME
        };

        standardColorGrid.getChildren</B></FONT>().clear();

        for (int i = 0; i &lt; NUM_OF_COLUMNS; i++) {
            standardColorGrid.add(new ColorSquare(STANDARD_COLORS[i], i, ColorType.STANDARD), i, 0);
        }
    }

    private void buildCustomColors() {
        final ObservableList&lt;Color&gt; customColors = colorPicker.getCustomColors();
        customColorNumber = customColors.size();

        customColorGrid.getChildren().clear();
        if (customColors.isEmpty()) {
            customColorLabel.setVisible(false);
            customColorLabel.setManaged(false);
            customColorGrid.setVisible(false);
            customColorGrid.setManaged(false);
            return;
        } else {
            customColorLabel.setVisible(true);
            customColorLabel.setManaged(true);
            customColorGrid.setVisible(true);
            customColorGrid.setManaged(true);
            if (contextMenu == null) {
                MenuItem item = new MenuItem(getColorPickerString(&quot;removeColor&quot;));
                item.setOnAction(e -&gt; {
                    ColorSquare square = (ColorSquare)contextMenu.getOwnerNode();
                    customColors.remove(square.rectangle.getFill());
                    buildCustomColors();
                });
                contextMenu = new ContextMenu(item);
            }
        }

        int customColumnIndex = 0;
        int customRowIndex = 0;
        int remainingSquares = customColors.size() % NUM_OF_COLUMNS;
        int numEmpty = (remainingSquares == 0) ? 0 : NUM_OF_COLUMNS - remainingSquares;
        customColorLastRowLength = remainingSquares == 0 ? 12 : remainingSquares;

        for (int i = 0; i &lt; customColors.size(); i++) {
            Color c = customColors.get(i);
            ColorSquare square = new ColorSquare(c, i, ColorType.CUSTOM);
            square.addEventHandler(KeyEvent.KEY_PRESSED, e -&gt; {
                if (e.getCode() == KeyCode.DELETE) {
                    customColors.remove(square.rectangle.getFill());
                    buildCustomColors();
                }
            });
            customColorGrid.add(square, customColumnIndex, customRowIndex);
            customColumnIndex++;
            if (customColumnIndex == NUM_OF_COLUMNS) {
                customColumnIndex = 0;
                customRowIndex++;
            }
        }
        for (int i = 0; i &lt; numEmpty; i++) {
            ColorSquare emptySquare = new ColorSquare();
            emptySquare.setDisable(true);
            customColorGrid.add(emptySquare, customColumnIndex, customRowIndex);
            customColumnIndex++;
        }
        customColorRows = customRowIndex + 1;
        requestLayout();

    }

    private void initNavigation() {
        setOnKeyPressed(ke -&gt; {
            switch (ke.getCode()) {
                case SPACE:
                case ENTER:
                    processSelectKey(ke);
                    ke.consume();
                    break;
                default: // no-op
            }
        });

        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {
            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                final Node subsequentNode = context.selectInSubtree(context.getRoot(), owner, dir);
                switch (dir) {
                    case NEXT:
                    case NEXT_IN_LINE:
                    case PREVIOUS:
                        return subsequentNode;
                    // Here, we need to intercept the standard algorithm in a few cases to get the desired traversal
                    // For right or left direction we want to continue on the next or previous row respectively
                    // For up and down, the custom color panel might be skipped by the standard algorithm (if not wide enough
                    // to be between the current color and custom color button), so we need to include it in the path explicitly.
                    case LEFT:
                    case RIGHT:
                    case UP:
                    case DOWN:
                        if (owner instanceof ColorSquare) {
                            Node result =  processArrow((ColorSquare)owner, dir);
                            return result != null ? result : subsequentNode;
                        } else {
                            return subsequentNode;
                        }
                }
                return null;
            }

            private Node processArrow(ColorSquare owner, Direction dir) {
                int row = 0;
                int column = 0;

                if (owner.colorType == ColorType.STANDARD) {
                    row = 0;
                    column = owner.index;
                } else {
                    row = owner.index / NUM_OF_COLUMNS;
                    column = owner.index % NUM_OF_COLUMNS;
                }

                // Adjust the direction according to color picker orientation
                dir = dir.getDirectionForNodeOrientation(colorPicker.getEffectiveNodeOrientation());
                // This returns true for all the cases which we need to override
                if (isAtBorder(dir, row, column, (owner.colorType == ColorType.CUSTOM))) {
                    // There's no other node in the direction from the square, so we need to continue on some other row
                    // or cycle
                    int subsequentRow = row;
                    int subsequentColumn = column;
                    boolean subSequentSquareCustom = (owner.colorType == ColorType.CUSTOM);
                    boolean subSequentSquareStandard = (owner.colorType == ColorType.STANDARD);
                    switch (dir) {
                        case LEFT:
                        case RIGHT:
                            // The next row is either the first or the last, except when cycling in custom colors, the last row
                            // might have different number of columns
                            if (owner.colorType == ColorType.STANDARD) {
                                subsequentRow = 0;
                                subsequentColumn = (dir == Direction.LEFT)? NUM_OF_COLUMNS - 1 : 0;
                            }
                            else if (owner.colorType == ColorType.CUSTOM) {
                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, customColorRows);
                                subsequentColumn = dir == Direction.LEFT ? subsequentRow == customColorRows - 1 ?
                                        customColorLastRowLength - 1 : NUM_OF_COLUMNS - 1 : 0;
                            } else {
                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, NUM_OF_ROWS);
                                subsequentColumn = dir == Direction.LEFT ? NUM_OF_COLUMNS - 1 : 0;
                            }
                            break;
                        case UP: // custom color are not handled here
                            if (owner.colorType == ColorType.NORMAL &amp;&amp; row == 0) {
                                subSequentSquareStandard = true;
                            }
                            break;
                        case DOWN: // custom color are not handled here
                            if (customColorNumber &gt; 0) {
                                subSequentSquareCustom = true;
                                subsequentRow = 0;
                                subsequentColumn = customColorRows &gt; 1 ? column : Math.min(customColorLastRowLength - 1, column);
                                break;
                            } else {
                                return null; // Let the default algorithm handle this
                            }

                    }
                    if (subSequentSquareCustom) {
                        return customColorGrid.getChildren().get(subsequentRow * NUM_OF_COLUMNS + subsequentColumn);
                    } else if (subSequentSquareStandard) {
                        return standardColorGrid.getChildren().get(subsequentColumn);
                    } else {
                        return colorPickerGrid.getChildren().get(subsequentRow * NUM_OF_COLUMNS + subsequentColumn);
                    }
                }
                return null;
            }

            private boolean isAtBorder(Direction dir, int row, int column, boolean custom) {
                switch (dir) {
                    case LEFT:
                        return column == 0;
                    case RIGHT:
                        return custom &amp;&amp; row == customColorRows - 1 ?
                                column == customColorLastRowLength - 1 : column == NUM_OF_COLUMNS - 1;
                    case UP:
                        return !custom &amp;&amp; row == 0;
                    case DOWN:
                        return !custom &amp;&amp; row == NUM_OF_ROWS - 1;
                }
                return false;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                return standardColorGrid.getChildren().get(0);
            }

            @Override
            public Node selectLast(TraversalContext context) {
                return customColorLink;
            }
        }));
    }

    private void processSelectKey(KeyEvent ke) {
        if (focusedSquare != null) focusedSquare.selectColor(ke);
    }

    public void setPopupControl(PopupControl pc) {
        this.popupControl = pc;
    }

    public ColorPickerGrid getColorGrid() {
        return colorPickerGrid;
    }

    public boolean isCustomColorDialogShowing() {
        if (customColorDialog != null) return customColorDialog.isVisible();
        return false;
    }


    enum ColorType {
        NORMAL,
        STANDARD,
        CUSTOM
    };

    class ColorSquare extends StackPane {
        Rectangle rectangle;
        int index;
        boolean isEmpty;
        ColorType colorType = ColorType.NORMAL;

        public ColorSquare() {
            this(null, -1, ColorType.NORMAL);
        }

        public ColorSquare(Color color, int index) {
            this(color, index, ColorType.NORMAL);
        }

        public ColorSquare(Color color, int index, ColorType type) {
            // Add style class to handle selected color square
            getStyleClass().add(&quot;color-square&quot;);
            if (color != null) {
                setFocusTraversable(true);

                focusedProperty().addListener((s, ov, nv) -&gt; {
                    setFocusedSquare(nv ? this : null);
                });

                addEventHandler(MouseEvent.MOUSE_ENTERED, event -&gt; {
                    setFocusedSquare(ColorSquare.this);
                });
                addEventHandler(MouseEvent.MOUSE_EXITED, event -&gt; {
                    setFocusedSquare(null);
                });

                addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                    if (!dragDetected &amp;&amp; event.getButton() == MouseButton.PRIMARY &amp;&amp; event.getClickCount() == 1) {
                        if (!isEmpty) {
                            Color fill = (Color) rectangle.getFill();
                            colorPicker.setValue(fill);
                            colorPicker.fireEvent(new ActionEvent());
                            updateSelection(fill);
                            event.consume();
                        }
                        colorPicker.hide();
                    } else if (event.getButton() == MouseButton.SECONDARY ||
                            event.getButton() == MouseButton.MIDDLE) {
                        if ((colorType == ColorType.CUSTOM) &amp;&amp; contextMenu != null) {
                            if (!contextMenu.isShowing()) {
                                contextMenu.show(ColorSquare.this, Side.RIGHT, 0, 0);
                                Utils.addMnemonics(contextMenu, ColorSquare.this.getScene(), NodeHelper.isShowMnemonics(colorPicker));
                            } else {
                                contextMenu.hide();
                                Utils.removeMnemonics(contextMenu, ColorSquare.this.getScene());
                            }
                        }
                    }
                });
            }
            this.index = index;
            this.colorType = type;
            rectangle = new Rectangle(SQUARE_SIZE, SQUARE_SIZE);
            if (color == null) {
                rectangle.setFill(Color.WHITE);
                isEmpty = true;
            } else {
                rectangle.setFill(color);
            }

            rectangle.setStrokeType(StrokeType.INSIDE);

            String tooltipStr = ColorPickerSkin.tooltipString(color);
            Tooltip.install(this, new Tooltip((tooltipStr == null) ? &quot;&quot; : tooltipStr));

            rectangle.getStyleClass().add(&quot;color-rect&quot;);

            getChildren().add(rectangle);
        }

        public void selectColor(KeyEvent event) {
            if (rectangle.getFill() != null) {
                if (rectangle.getFill() instanceof Color) {
                    colorPicker.setValue((Color) rectangle.getFill());
                    colorPicker.fireEvent(new ActionEvent());
                }
                event.consume();
            }
            colorPicker.hide();
        }
    }

    // The skin can update selection if colorpicker value changes..
    public void updateSelection(Color color) {
        setFocusedSquare(null);

        // Check all color grids to find ColorSquare that matches color
        // if found, set focus to it

        List&lt;GridPane&gt; gridList = List.of(standardColorGrid, colorPickerGrid,
                                          customColorGrid);

        for (GridPane grid : gridList) {
            ColorSquare sq = findColorSquare(grid, color);
            if (sq != null) {
                setFocusedSquare(sq);
                return;
            }
        }
    }

    private ColorSquare findColorSquare(GridPane colorGrid, Color color) {
        for (Node n : colorGrid.getChildren()) {
            ColorSquare c = (ColorSquare) n;
            if (c.rectangle.getFill().equals(color)) {
                return c;
            }
        }
        return null;
    }

    class ColorPickerGrid extends GridPane {

        private final List&lt;ColorSquare&gt; squares;

        public ColorPickerGrid() {
            getStyleClass().add(&quot;color-picker-grid&quot;);
            setId(&quot;ColorCustomizerColorGrid&quot;);
            int columnIndex = 0, rowIndex = 0;
            squares = FXCollections.observableArrayList();
            final int numColors = RAW_VALUES.length / 3;
            Color[] colors = new Color[numColors];
            for (int i = 0; i &lt; numColors; i++) {
                colors[i] = new Color(RAW_VALUES[(i * 3)] / 255,
                        RAW_VALUES[(i * 3) + 1] / 255, RAW_VALUES[(i * 3) + 2] / 255,
                        1.0);
                ColorSquare cs = new ColorSquare(colors[i], i);
                squares.add(cs);
            }

            for (ColorSquare square : squares) {
                add(square, columnIndex, rowIndex);
                columnIndex++;
                if (columnIndex == NUM_OF_COLUMNS) {
                    columnIndex = 0;
                    rowIndex++;
                }
            }
            setOnMouseDragged(t -&gt; {
                if (!dragDetected) {
                    dragDetected = true;
                    mouseDragColor = colorPicker.getValue();
                }
                int xIndex = com.sun.javafx.util.Utils.clamp(0,
                        (int)t.getX()/(SQUARE_SIZE + 1), NUM_OF_COLUMNS - 1);
                int yIndex = com.sun.javafx.util.Utils.clamp(0,
                        (int)t.getY()/(SQUARE_SIZE + 1), NUM_OF_ROWS - 1);
                int index = xIndex + yIndex*NUM_OF_COLUMNS;
                colorPicker.setValue((Color) squares.get(index).rectangle.getFill());
                updateSelection(colorPicker.getValue());
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, t -&gt; {
                if(colorPickerGrid.getBoundsInLocal().contains(t.getX(), t.getY())) {
                    updateSelection(colorPicker.getValue());
                    colorPicker.fireEvent(new ActionEvent());
                    colorPicker.hide();
                } else {
                    // restore color as mouse release happened outside the grid.
                    if (mouseDragColor != null) {
                        colorPicker.setValue(mouseDragColor);
                        updateSelection(mouseDragColor);
                    }
                }
                dragDetected = false;
            });
        }

        public List&lt;ColorSquare&gt; getSquares() {
            return squares;
        }

        @Override protected double computePrefWidth(double height) {
            return (SQUARE_SIZE + 1)*NUM_OF_COLUMNS;
        }

        @Override protected double computePrefHeight(double width) {
            return (SQUARE_SIZE + 1)*NUM_OF_ROWS;
        }
    }

    private static final int NUM_OF_COLUMNS = 12;
    private static double[] RAW_VALUES = {
            // WARNING: always make sure the number of colors is a divisable by NUM_OF_COLUMNS
            255, 255, 255, // first row
            242, 242, 242,
            230, 230, 230,
            204, 204, 204,
            179, 179, 179,
            153, 153, 153,
            128, 128, 128,
            102, 102, 102,
            77, 77, 77,
            51, 51, 51,
            26, 26, 26,
            0, 0, 0,
            0, 51, 51, // second row
            0, 26, 128,
            26, 0, 104,
            51, 0, 51,
            77, 0, 26,
            153, 0, 0,
            153, 51, 0,
            153, 77, 0,
            153, 102, 0,
            153, 153, 0,
            102, 102, 0,
            0, 51, 0,
            26, 77, 77, // third row
            26, 51, 153,
            51, 26, 128,
            77, 26, 77,
            102, 26, 51,
            179, 26, 26,
            179, 77, 26,
            179, 102, 26,
            179, 128, 26,
            179, 179, 26,
            128, 128, 26,
            26, 77, 26,
            51, 102, 102, // fourth row
            51, 77, 179,
            77, 51, 153,
            102, 51, 102,
            128, 51, 77,
            204, 51, 51,
            204, 102, 51,
            204, 128, 51,
            204, 153, 51,
            204, 204, 51,
            153, 153, 51,
            51, 102, 51,
            77, 128, 128, // fifth row
            77, 102, 204,
            102, 77, 179,
            128, 77, 128,
            153, 77, 102,
            230, 77, 77,
            230, 128, 77,
            230, 153, 77,
            230, 179, 77,
            230, 230, 77,
            179, 179, 77,
            77, 128, 77,
            102, 153, 153, // sixth row
            102, 128, 230,
            128, 102, 204,
            153, 102, 153,
            179, 102, 128,
            255, 102, 102,
            255, 153, 102,
            255, 179, 102,
            255, 204, 102,
            255, 255, 77,
            204, 204, 102,
            102, 153, 102,
            128, 179, 179, // seventh row
            128, 153, 255,
            153, 128, 230,
            179, 128, 179,
            204, 128, 153,
            255, 128, 128,
            255, 153, 128,
            255, 204, 128,
            255, 230, 102,
            255, 255, 102,
            230, 230, 128,
            128, 179, 128,
            153, 204, 204, // eigth row
            153, 179, 255,
            179, 153, 255,
            204, 153, 204,
            230, 153, 179,
            255, 153, 153,
            255, 179, 128,
            255, 204, 153,
            255, 230, 128,
            255, 255, 128,
            230, 230, 153,
            153, 204, 153,
            179, 230, 230, // ninth row
            179, 204, 255,
            204, 179, 255,
            230, 179, 230,
            230, 179, 204,
            255, 179, 179,
            255, 179, 153,
            255, 230, 179,
            255, 230, 153,
            255, 255, 153,
            230, 230, 179,
            179, 230, 179,
            204, 255, 255, // tenth row
            204, 230, 255,
            230, 204, 255,
            255, 204, 255,
            255, 204, 230,
            255, 204, 204,
            255, 204, 179,
            255, 230, 204,
            255, 255, 179,
            255, 255, 204,
            230, 230, 204,
            204, 255, 204
    };

    private static final int NUM_OF_COLORS = RAW_VALUES.length / 3;
    private static final int NUM_OF_ROWS = NUM_OF_COLORS / NUM_OF_COLUMNS;
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ScrollPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.control.SkinBase;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import com.sun.javafx.util.Utils;
import com.sun.javafx.scene.control.behavior.ScrollPaneBehavior;
import static com.sun.javafx.scene.control.skin.Utils.*;
import javafx.geometry.Insets;

import java.util.function.Consumer;

/**
 * Default skin implementation for the {@link ScrollPane} control.
 *
 * @see ScrollPane
 * @since 9
 */
public class ScrollPaneSkin extends SkinBase&lt;ScrollPane&gt; {
    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final double DEFAULT_PREF_SIZE = 100.0;

    private static final double DEFAULT_MIN_SIZE = 36.0;

    private static final double DEFAULT_SB_BREADTH = 12.0;
    private static final double DEFAULT_EMBEDDED_SB_BREADTH = 8.0;

    private static final double PAN_THRESHOLD = 0.5;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    // state from the control

    private Node scrollNode;
    private final BehaviorBase&lt;ScrollPane&gt; behavior;

    private double nodeWidth;
    private double nodeHeight;
    private boolean nodeSizeInvalid = true;

    private double posX;
    private double posY;

    // working state

    private boolean hsbvis;
    private boolean vsbvis;
    private double hsbHeight;
    private double vsbWidth;

    // substructure

    private StackPane viewRect;
    private StackPane viewContent;
    private double contentWidth;
    private double contentHeight;
    private StackPane corner;
    ScrollBar hsb;
    ScrollBar vsb;

    double pressX;
    double pressY;
    double ohvalue;
    double ovvalue;
    private Cursor saveCursor =  null;
    private boolean dragDetected = false;
    private boolean touchDetected = false;
    private boolean mouseDown = false;

    Rectangle clipRect;

    Timeline sbTouchTimeline;
    KeyFrame sbTouchKF1;
    KeyFrame sbTouchKF2;
    Timeline contentsToViewTimeline;
    KeyFrame contentsToViewKF1;
    KeyFrame contentsToViewKF2;
    KeyFrame contentsToViewKF3;

    private boolean tempVisibility;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private final InvalidationListener nodeListener = new InvalidationListener() {
        @Override public void invalidated(Observable valueModel) {
            if (!nodeSizeInvalid) {
                final Bounds scrollNodeBounds = scrollNode.getLayoutBounds();
                final double scrollNodeWidth = scrollNodeBounds.getWidth();
                final double scrollNodeHeight = scrollNodeBounds.getHeight();

                /*
                ** if the new size causes scrollbar visibility to change, then need to relayout
                ** we also need to correct the thumb size when the scrollnode's size changes
                */
                if (vsbvis != determineVerticalSBVisible() || hsbvis != determineHorizontalSBVisible() ||
                        (scrollNodeWidth != 0.0  &amp;&amp; nodeWidth != scrollNodeWidth) ||
                        (scrollNodeHeight != 0.0 &amp;&amp; nodeHeight != scrollNodeHeight)) {
                    getSkinnable().requestLayout();
                } else {
                    /**
                     * we just need to update scrollbars based on new scrollNode size,
                     * but we don't do this while dragging, there's no need,
                     * and it jumps, as dragging updates the scrollbar too.
                     */
                    if (!dragDetected) {
                        updateVerticalSB();
                        updateHorizontalSB();
                    }
                }
            }
        }
    };


    /*
    ** The content of the ScrollPane has just changed bounds, check scrollBar positions.
    */
    private final ChangeListener&lt;Bounds&gt; boundsChangeListener = new ChangeListener&lt;Bounds&gt;() {
        @Override public void changed(ObservableValue&lt;? extends Bounds&gt; observable, Bounds oldBounds, Bounds newBounds) {

            /*
            ** For a height change then we want to reduce
            ** viewport vertical jumping as much as possible.
            ** We set a new vsb value to try to keep the same
            ** content position at the top of the viewport
            */
            double oldHeight = oldBounds.getHeight();
            double newHeight = newBounds.getHeight();
            if (oldHeight &gt; 0 &amp;&amp; oldHeight != newHeight) {
                double oldPositionY = (snapPositionY(snappedTopInset() - posY / (vsb.getMax() - vsb.getMin()) * (oldHeight - contentHeight)));
                double newPositionY = (snapPositionY(snappedTopInset() - posY / (vsb.getMax() - vsb.getMin()) * (newHeight - contentHeight)));

                double newValueY = (oldPositionY/newPositionY)*vsb.getValue();
                if (newValueY &lt; 0.0) {
                    vsb.setValue(0.0);
                }
                else if (newValueY &lt; 1.0) {
                    vsb.setValue(newValueY);
                }
                else if (newValueY &gt; 1.0) {
                    vsb.setValue(1.0);
                }
            }

            /*
            ** For a width change then we want to reduce
            ** viewport horizontal jumping as much as possible.
            ** We set a new hsb value to try to keep the same
            ** content position to the left of the viewport
            */
            double oldWidth = oldBounds.getWidth();
            double newWidth = newBounds.getWidth();
            if (oldWidth &gt; 0 &amp;&amp; oldWidth != newWidth) {
                double oldPositionX = (snapPositionX(snappedLeftInset() - posX / (hsb.getMax() - hsb.getMin()) * (oldWidth - contentWidth)));
                double newPositionX = (snapPositionX(snappedLeftInset() - posX / (hsb.getMax() - hsb.getMin()) * (newWidth - contentWidth)));

                double newValueX = (oldPositionX/newPositionX)*hsb.getValue();
                if (newValueX &lt; 0.0) {
                    hsb.setValue(0.0);
                }
                else if (newValueX &lt; 1.0) {
                    hsb.setValue(newValueX);
                }
                else if (newValueX &gt; 1.0) {
                    hsb.setValue(1.0);
                }
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ScrollPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ScrollPaneSkin(final ScrollPane control) {
        super(control);

        // install default input map for the ScrollPane control
        behavior = new ScrollPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        initialize();

        // Register listeners
        Consumer&lt;ObservableValue&lt;?&gt;&gt; viewportSizeHintConsumer = e -&gt; {
            // change affects pref size, so requestLayout on control
            getSkinnable().requestLayout();
        };
        registerChangeListener(control.contentProperty(), e -&gt; {
            if (scrollNode != getSkinnable().getContent()) {
                if (scrollNode != null) {
                    scrollNode.layoutBoundsProperty().removeListener(nodeListener);
                    scrollNode.layoutBoundsProperty().removeListener(boundsChangeListener);
                    viewContent.getChildren().remove(scrollNode);
                }
                scrollNode = getSkinnable().getContent();
                if (scrollNode != null) {
                    nodeWidth = snapSizeX(scrollNode.getLayoutBounds().getWidth());
                    nodeHeight = snapSizeY(scrollNode.getLayoutBounds().getHeight());
                    viewContent.getChildren().setAll(scrollNode);
                    scrollNode.layoutBoundsProperty().addListener(nodeListener);
                    scrollNode.layoutBoundsProperty().addListener(boundsChangeListener);
                }
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.fitToWidthProperty(), e -&gt; {
            getSkinnable().requestLayout();
            viewRect.requestLayout();
        });
        registerChangeListener(control.fitToHeightProperty(), e -&gt; {
            getSkinnable().requestLayout();
            viewRect.requestLayout();
        });
        registerChangeListener(control.hbarPolicyProperty(), e -&gt; {
            // change might affect pref size, so requestLayout on control
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.vbarPolicyProperty(), e -&gt; {
            // change might affect pref size, so requestLayout on control
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.hvalueProperty(), e -&gt; hsb.setValue(getSkinnable().getHvalue()));
        registerChangeListener(control.hmaxProperty(), e -&gt; hsb.setMax(getSkinnable().getHmax()));
        registerChangeListener(control.hminProperty(), e -&gt; hsb.setMin(getSkinnable().getHmin()));
        registerChangeListener(control.vvalueProperty(), e -&gt; vsb.setValue(getSkinnable().getVvalue()));
        registerChangeListener(control.vmaxProperty(), e -&gt; vsb.setMax(getSkinnable().getVmax()));
        registerChangeListener(control.vminProperty(), e -&gt; vsb.setMin(getSkinnable().getVmin()));
        registerChangeListener(control.prefViewportWidthProperty(), viewportSizeHintConsumer);
        registerChangeListener(control.prefViewportHeightProperty(), viewportSizeHintConsumer);
        registerChangeListener(control.minViewportWidthProperty(), viewportSizeHintConsumer);
        registerChangeListener(control.minViewportHeightProperty(), viewportSizeHintConsumer);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private DoubleProperty contentPosX;
    private final void setContentPosX(double value) { contentPosXProperty().set(value); }
    private final double getContentPosX() { return contentPosX == null ? 0.0 : contentPosX.get(); }
    private final DoubleProperty contentPosXProperty() {
        if (contentPosX == null) {
            contentPosX = new DoublePropertyBase() {
                @Override protected void invalidated() {
                    hsb.setValue(getContentPosX());
                    getSkinnable().requestLayout();
                }

                @Override
                public Object getBean() {
                    return ScrollPaneSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;contentPosX&quot;;
                }
            };
        }
        return contentPosX;
    }

    private DoubleProperty contentPosY;
    private final void setContentPosY(double value) { contentPosYProperty().set(value); }
    private final double getContentPosY() { return contentPosY == null ? 0.0 : contentPosY.get(); }
    private final DoubleProperty contentPosYProperty() {
        if (contentPosY == null) {
            contentPosY = new DoublePropertyBase() {
                @Override protected void invalidated() {
                    vsb.setValue(getContentPosY());
                    getSkinnable().requestLayout();
                }

                @Override
                public Object getBean() {
                    return ScrollPaneSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;contentPosY&quot;;
                }
            };
        }
        return contentPosY;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /**
     * Returns the horizontal {@link ScrollBar} used in this ScrollPaneSkin
     * instance.
     * @return the horizontal ScrollBar used in this ScrollPaneSkin instance
     */
    public final ScrollBar getHorizontalScrollBar() {
        return hsb;
    }

    /**
     * Returns the vertical {@link ScrollBar} used in this ScrollPaneSkin
     * instance.
     * @return the vertical ScrollBar used in this ScrollPaneSkin instance
     */
    public final ScrollBar getVerticalScrollBar() {
        return vsb;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double vsbWidth = computeVsbSizeHint(sp);
        double minWidth = vsbWidth + snappedLeftInset() + snappedRightInset();

        if (sp.getPrefViewportWidth() &gt; 0) {
            return (sp.getPrefViewportWidth() + minWidth);
        }
        else if (sp.getContent() != null) {
            return (sp.getContent().prefWidth(height) + minWidth);
        }
        else {
            return Math.max(minWidth, DEFAULT_PREF_SIZE);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double hsbHeight = computeHsbSizeHint(sp);
        double minHeight = hsbHeight + snappedTopInset() + snappedBottomInset();

        if (sp.getPrefViewportHeight() &gt; 0) {
            return (sp.getPrefViewportHeight() + minHeight);
        }
        else if (sp.getContent() != null) {
            return (sp.getContent().prefHeight(width) + minHeight);
        }
        else {
            return Math.max(minHeight, DEFAULT_PREF_SIZE);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double vsbWidth = computeVsbSizeHint(sp);
        double minWidth = vsbWidth + snappedLeftInset() + snappedRightInset();

        if (sp.getMinViewportWidth() &gt; 0) {
            return (sp.getMinViewportWidth() + minWidth);
        } else {
            double w = corner.minWidth(-1);
            return (w &gt; 0) ? (3 * w) : (DEFAULT_MIN_SIZE);
        }

    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double hsbHeight = computeHsbSizeHint(sp);
        double minHeight = hsbHeight + snappedTopInset() + snappedBottomInset();

        if (sp.getMinViewportHeight() &gt; 0) {
            return (sp.getMinViewportHeight() + minHeight);
        } else {
            double h = corner.minHeight(-1);
            return (h &gt; 0) ? (3 * h) : (DEFAULT_MIN_SIZE);
        }
    }

    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        final ScrollPane control = getSkinnable();
        final Insets padding = control.getPadding();
        final double rightPadding = snapSizeX(padding.getRight());
        final double leftPadding = snapSizeX(padding.getLeft());
        final double topPadding = snapSizeY(padding.getTop());
        final double bottomPadding = snapSizeY(padding.getBottom());

        vsb.setMin(control.getVmin());
        vsb.setMax(control.getVmax());

        //should only do this on css setup
        hsb.setMin(control.getHmin());
        hsb.setMax(control.getHmax());

        contentWidth = w;
        contentHeight = h;

        /*
        ** we want the scrollbars to go right to the border
        */
        double hsbWidth = 0;
        double vsbHeight = 0;

        computeScrollNodeSize(contentWidth, contentHeight);
        computeScrollBarSize();

        for (int i = 0; i &lt; 2; ++i) {
            vsbvis = determineVerticalSBVisible();
            hsbvis = determineHorizontalSBVisible();

            if (vsbvis &amp;&amp; !Properties.IS_TOUCH_SUPPORTED) {
                contentWidth = w - vsbWidth;
            }
            hsbWidth = w + leftPadding + rightPadding - (vsbvis ? vsbWidth : 0);
            if (hsbvis &amp;&amp; !Properties.IS_TOUCH_SUPPORTED) {
                contentHeight = h - hsbHeight;
            }
            vsbHeight = h + topPadding + bottomPadding - (hsbvis ? hsbHeight : 0);
        }


        if (scrollNode != null &amp;&amp; scrollNode.isResizable()) {
            // maybe adjust size now that scrollbars may take up space
            if (vsbvis &amp;&amp; hsbvis) {
                // adjust just once to accommodate
                computeScrollNodeSize(contentWidth, contentHeight);

            } else if (hsbvis &amp;&amp; !vsbvis) {
                computeScrollNodeSize(contentWidth, contentHeight);
                vsbvis = determineVerticalSBVisible();
                if (vsbvis) {
                    // now both are visible
                    contentWidth -= vsbWidth;
                    hsbWidth -= vsbWidth;
                    computeScrollNodeSize(contentWidth, contentHeight);
                }
            } else if (vsbvis &amp;&amp; !hsbvis) {
                computeScrollNodeSize(contentWidth, contentHeight);
                hsbvis = determineHorizontalSBVisible();
                if (hsbvis) {
                    // now both are visible
                    contentHeight -= hsbHeight;
                    vsbHeight -= hsbHeight;
                    computeScrollNodeSize(contentWidth, contentHeight);
                }
            }
        }

        // figure out the content area that is to be filled
        double cx = snappedLeftInset() - leftPadding;
        double cy = snappedTopInset() - topPadding;

        vsb.setVisible(vsbvis);
        if (vsbvis) {
            /*
            ** round up position of ScrollBar, round down it's size.
            **
            ** Positioning the ScrollBar
            **  The Padding should go between the content and the edge,
            **  otherwise changes in padding move the ScrollBar, and could
            **  in extreme cases size the ScrollBar to become unusable.
            **  The -1, +1 plus one bit :
            **   If padding in =&gt; 1 then we allow one pixel to appear as the
            **   outside border of the Scrollbar, and the rest on the inside.
            **   If padding is &lt; 1 then we just stick to the edge.
            */
            vsb.resizeRelocate(snappedLeftInset() + w - vsbWidth + (rightPadding &lt; 1 ? 0 : rightPadding - 1) ,
                    cy, vsbWidth, vsbHeight);
        }
        updateVerticalSB();

        hsb.setVisible(hsbvis);
        if (hsbvis) {
            /*
            ** round up position of ScrollBar, round down it's size.
            **
            ** Positioning the ScrollBar
            **  The Padding should go between the content and the edge,
            **  otherwise changes in padding move the ScrollBar, and could
            **  in extreme cases size the ScrollBar to become unusable.
            **  The -1, +1 plus one bit :
            **   If padding in =&gt; 1 then we allow one pixel to appear as the
            **   outside border of the Scrollbar, and the rest on the inside.
            **   If padding is &lt; 1 then we just stick to the edge.
            */
            hsb.resizeRelocate(cx, snappedTopInset() + h - hsbHeight + (bottomPadding &lt; 1 ? 0 : bottomPadding - 1),
                    hsbWidth, hsbHeight);
        }
        updateHorizontalSB();

        viewRect.resizeRelocate(snappedLeftInset(), snappedTopInset(), snapSizeX(contentWidth), snapSizeY(contentHeight));
        resetClip();

        if (vsbvis &amp;&amp; hsbvis) {
            corner.setVisible(true);
            double cornerWidth = vsbWidth;
            double cornerHeight = hsbHeight;
            corner.resizeRelocate(snapPositionX(vsb.getLayoutX()), snapPositionY(hsb.getLayoutY()), snapSizeX(cornerWidth), snapSizeY(cornerHeight));
        } else {
            corner.setVisible(false);
        }
        control.setViewportBounds(new BoundingBox(snapPositionX(viewContent.getLayoutX()), snapPositionY(viewContent.getLayoutY()), snapSizeX(contentWidth), snapSizeY(contentHeight)));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case VERTICAL_SCROLLBAR: return vsb;
            case HORIZONTAL_SCROLLBAR: return hsb;
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void initialize() {
        // requestLayout calls below should not trigger requestLayout above ScrollPane
//        setManaged(false);

        ScrollPane control = getSkinnable();
        scrollNode = control.getContent();

        ParentTraversalEngine traversalEngine = new ParentTraversalEngine(getSkinnable());
        traversalEngine.addTraverseListener((node, bounds) -&gt; {
            // auto-scroll so node is within (0,0),(contentWidth,contentHeight)
            scrollBoundsIntoView(bounds);
        });
        ParentHelper.setTraversalEngine(getSkinnable(), traversalEngine);

        if (scrollNode != null) {
            scrollNode.layoutBoundsProperty().addListener(nodeListener);
            scrollNode.layoutBoundsProperty().addListener(boundsChangeListener);
        }

        viewRect = new StackPane() {
            @Override protected void layoutChildren() {
                viewContent.resize(getWidth(), getHeight());
            }
        };
        // prevent requestLayout requests from within scrollNode from percolating up
        viewRect.setManaged(false);
        viewRect.setCache(true);
        viewRect.getStyleClass().add(&quot;viewport&quot;);

        clipRect = new Rectangle();
        viewRect.setClip(clipRect);

        hsb = new ScrollBar();

        vsb = new ScrollBar();
        vsb.setOrientation(Orientation.VERTICAL);

        EventHandler&lt;MouseEvent&gt; barHandler = ev -&gt; {
            if (getSkinnable().isFocusTraversable()) {
                getSkinnable().requestFocus();
            }
        };

        hsb.addEventFilter(MouseEvent.MOUSE_PRESSED, barHandler);
        vsb.addEventFilter(MouseEvent.MOUSE_PRESSED, barHandler);

        corner = new StackPane();
        corner.getStyleClass().setAll(&quot;corner&quot;);

        viewContent = new StackPane() {
            @Override public void requestLayout() {
                // if scrollNode requested layout, will want to recompute
                nodeSizeInvalid = true;

                super.requestLayout(); // add as layout root for next layout pass

                // Need to layout the ScrollPane as well in case scrollbars
                // appeared or disappeared.
                ScrollPaneSkin.this.getSkinnable().requestLayout();
            }
            @Override protected void layoutChildren() {
                if (nodeSizeInvalid) {
                    computeScrollNodeSize(getWidth(),getHeight());
                }
                if (scrollNode != null &amp;&amp; scrollNode.isResizable()) {
                    scrollNode.resize(snapSize(nodeWidth), snapSize(nodeHeight));
                    if (vsbvis != determineVerticalSBVisible() || hsbvis != determineHorizontalSBVisible()) {
                        getSkinnable().requestLayout();
                    }
                }
                if (scrollNode != null) {
                    scrollNode.relocate(0,0);
                }
            }
        };
        viewRect.getChildren().add(viewContent);

        if (scrollNode != null) {
            viewContent.getChildren().add(scrollNode);
            viewRect.nodeOrientationProperty().bind(scrollNode.nodeOrientationProperty());
        }

        getChildren().clear();
        getChildren().addAll(viewRect, vsb, hsb, corner);

        /*
        ** listeners, and assorted housekeeping
        */
        InvalidationListener vsbListener = valueModel -&gt; {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                posY = Utils.clamp(getSkinnable().getVmin(), vsb.getValue(), getSkinnable().getVmax());
            }
            else {
                posY = vsb.getValue();
            }
            updatePosY();
        };
        vsb.valueProperty().addListener(vsbListener);

        InvalidationListener hsbListener = valueModel -&gt; {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                posX = Utils.clamp(getSkinnable().getHmin(), hsb.getValue(), getSkinnable().getHmax());
            }
            else {
                posX = hsb.getValue();
            }
            updatePosX();
        };
        hsb.valueProperty().addListener(hsbListener);

        viewRect.setOnMousePressed(e -&gt; {
            mouseDown = true;
            if (Properties.IS_TOUCH_SUPPORTED) {
                startSBReleasedAnimation();
            }
            pressX = e.getX();
            pressY = e.getY();
            ohvalue = hsb.getValue();
            ovvalue = vsb.getValue();
        });


        viewRect.setOnDragDetected(e -&gt; {
             if (Properties.IS_TOUCH_SUPPORTED) {
                 startSBReleasedAnimation();
             }
            if (getSkinnable().isPannable()) {
              dragDetected = true;
              if (saveCursor == null) {
                  saveCursor = getSkinnable().getCursor();
                  if (saveCursor == null) {
                      saveCursor = Cursor.DEFAULT;
                  }
                  getSkinnable().setCursor(Cursor.MOVE);
                  getSkinnable().requestLayout();
              }
            }
        });

        viewRect.addEventFilter(MouseEvent.MOUSE_RELEASED, e -&gt; {
             mouseDown = false;
             if (dragDetected == true) {
                 if (saveCursor != null) {
                     getSkinnable().setCursor(saveCursor);
                     saveCursor = null;
                     getSkinnable().requestLayout();
                 }
                 dragDetected = false;
             }

             /*
             ** if the contents need repositioning, and there's is no
             ** touch event in progress, then start the repositioning.
             */
             if ((posY &gt; getSkinnable().getVmax() || posY &lt; getSkinnable().getVmin() ||
                 posX &gt; getSkinnable().getHmax() || posX &lt; getSkinnable().getHmin()) &amp;&amp; !touchDetected) {
                 startContentsToViewport();
             }
        });
        viewRect.setOnMouseDragged(e -&gt; {
             if (Properties.IS_TOUCH_SUPPORTED) {
                 startSBReleasedAnimation();
             }
            /*
            ** for mobile-touch we allow drag, even if not pannagle
            */
            if (getSkinnable().isPannable() || Properties.IS_TOUCH_SUPPORTED) {
                double deltaX = pressX - e.getX();
                double deltaY = pressY - e.getY();
                /*
                ** we only drag if not all of the content is visible.
                */
                if (hsb.getVisibleAmount() &gt; 0.0 &amp;&amp; hsb.getVisibleAmount() &lt; hsb.getMax()) {
                    if (Math.abs(deltaX) &gt; PAN_THRESHOLD) {
                        if (isReverseNodeOrientation()) {
                            deltaX = -deltaX;
                        }
                        double newHVal = (ohvalue + deltaX / (nodeWidth - viewRect.getWidth()) * (hsb.getMax() - hsb.getMin()));
                        if (!Properties.IS_TOUCH_SUPPORTED) {
                            if (newHVal &gt; hsb.getMax()) {
                                newHVal = hsb.getMax();
                            }
                            else if (newHVal &lt; hsb.getMin()) {
                                newHVal = hsb.getMin();
                            }
                            hsb.setValue(newHVal);
                        }
                        else {
                            hsb.setValue(newHVal);
                        }
                    }
                }
                /*
                ** we only drag if not all of the content is visible.
                */
                if (vsb.getVisibleAmount() &gt; 0.0 &amp;&amp; vsb.getVisibleAmount() &lt; vsb.getMax()) {
                    if (Math.abs(deltaY) &gt; PAN_THRESHOLD) {
                        double newVVal = (ovvalue + deltaY / (nodeHeight - viewRect.getHeight()) * (vsb.getMax() - vsb.getMin()));
                        if (!Properties.IS_TOUCH_SUPPORTED) {
                            if (newVVal &gt; vsb.getMax()) {
                                newVVal = vsb.getMax();
                            }
                            else if (newVVal &lt; vsb.getMin()) {
                                newVVal = vsb.getMin();
                            }
                            vsb.setValue(newVVal);
                        }
                        else {
                            vsb.setValue(newVVal);
                        }
                    }
                }
            }
            /*
            ** we need to consume drag events, as we don't want
            ** the scrollpane itself to be dragged on every mouse click
            */
            e.consume();
        });


        /*
        ** don't allow the ScrollBar to handle the ScrollEvent,
        ** In a ScrollPane a vertical scroll should scroll on the vertical only,
        ** whereas in a horizontal ScrollBar it can scroll horizontally.
        */
        // block the event from being passed down to children
        final EventDispatcher blockEventDispatcher = (event, tail) -&gt; event;
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldHsbEventDispatcher = hsb.getEventDispatcher();
        hsb.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldHsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldHsbEventDispatcher.dispatchEvent(event, tail);
        });
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldVsbEventDispatcher = vsb.getEventDispatcher();
        vsb.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldVsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldVsbEventDispatcher.dispatchEvent(event, tail);
        });

        /*
         * listen for ScrollEvents over the whole of the ScrollPane
         * area, the above dispatcher having removed the ScrollBars
         * scroll event handling.
         *
         * Note that we use viewRect here, rather than setting the eventHandler
         * on the ScrollPane itself. This is for RT-31582, and effectively
         * allows for us to prioritise handling (and consuming) the event
         * internally, before it is made available to users listening to events
         * on the control. This is consistent with the VirtualFlow-based controls.
         */
        viewRect.addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            if (Properties.IS_TOUCH_SUPPORTED) {
                startSBReleasedAnimation();
            }
            /*
            ** if we're completely visible then do nothing....
            ** we only consume an event that we've used.
            */
            if (vsb.getVisibleAmount() &lt; vsb.getMax()) {
                double vRange = getSkinnable().getVmax()-getSkinnable().getVmin();
                double vPixelValue;
                if (nodeHeight &gt; 0.0) {
                    vPixelValue = vRange / nodeHeight;
                }
                else {
                    vPixelValue = 0.0;
                }
                double newValue = vsb.getValue()+(-event.getDeltaY())*vPixelValue;
                if (!Properties.IS_TOUCH_SUPPORTED) {
                    if ((event.getDeltaY() &gt; 0.0 &amp;&amp; vsb.getValue() &gt; vsb.getMin()) ||
                        (event.getDeltaY() &lt; 0.0 &amp;&amp; vsb.getValue() &lt; vsb.getMax())) {
                        vsb.setValue(newValue);
                        event.consume();
                    }
                }
                else {
                    /*
                    ** if there is a repositioning in progress then we only
                    ** set the value for 'real' events
                    */
                    if (!(((ScrollEvent)event).isInertia()) || (((ScrollEvent)event).isInertia()) &amp;&amp; (contentsToViewTimeline == null || contentsToViewTimeline.getStatus() == Status.STOPPED)) {
                        vsb.setValue(newValue);
                        if ((newValue &gt; vsb.getMax() || newValue &lt; vsb.getMin()) &amp;&amp; (!mouseDown &amp;&amp; !touchDetected)) {
                            startContentsToViewport();
                        }
                        event.consume();
                    }
                }
            }

            if (hsb.getVisibleAmount() &lt; hsb.getMax()) {
                double hRange = getSkinnable().getHmax()-getSkinnable().getHmin();
                double hPixelValue;
                if (nodeWidth &gt; 0.0) {
                    hPixelValue = hRange / nodeWidth;
                }
                else {
                    hPixelValue = 0.0;
                }

                double newValue = hsb.getValue()+(-event.getDeltaX())*hPixelValue;
                if (!Properties.IS_TOUCH_SUPPORTED) {
                    if ((event.getDeltaX() &gt; 0.0 &amp;&amp; hsb.getValue() &gt; hsb.getMin()) ||
                        (event.getDeltaX() &lt; 0.0 &amp;&amp; hsb.getValue() &lt; hsb.getMax())) {
                        hsb.setValue(newValue);
                        event.consume();
                    }
                }
                else {
                    /*
                    ** if there is a repositioning in progress then we only
                    ** set the value for 'real' events
                    */
                    if (!(((ScrollEvent)event).isInertia()) || (((ScrollEvent)event).isInertia()) &amp;&amp; (contentsToViewTimeline == null || contentsToViewTimeline.getStatus() == Status.STOPPED)) {
                        hsb.setValue(newValue);

                        if ((newValue &gt; hsb.getMax() || newValue &lt; hsb.getMin()) &amp;&amp; (!mouseDown &amp;&amp; !touchDetected)) {
                            startContentsToViewport();
                        }
                        event.consume();
                    }
                }
            }
        });

        /*
        ** there are certain animations that need to know if the touch is
        ** happening.....
        */
        getSkinnable().addEventHandler(TouchEvent.TOUCH_PRESSED, e -&gt; {
            touchDetected = true;
            startSBReleasedAnimation();
            e.consume();
        });

        getSkinnable().addEventHandler(TouchEvent.TOUCH_RELEASED, e -&gt; {
            touchDetected = false;
            e.consume();
        });

        // ScrollPanes do not block all MouseEvents by default, unlike most other UI Controls.
        consumeMouseEvents(false);

        // update skin initial state to match control (see RT-35554)
        hsb.setValue(control.getHvalue());
        vsb.setValue(control.getVvalue());
    }

    void scrollBoundsIntoView(Bounds b) {
        double dx = 0.0;
        double dy = 0.0;
        if (b.getMaxX() &gt; contentWidth) {
            dx = b.getMinX() - snappedLeftInset();
        }
        if (b.getMinX() &lt; snappedLeftInset()) {
            dx = b.getMaxX() - contentWidth - snappedLeftInset();
        }
        if (b.getMaxY() &gt; snappedTopInset() + contentHeight) {
            dy = b.getMinY() - snappedTopInset();
        }
        if (b.getMinY() &lt; snappedTopInset()) {
            dy = b.getMaxY() - contentHeight - snappedTopInset();
        }
        // We want to move contentPanel's layoutX,Y by (dx,dy).
        // But to do this we have to set the scrollbars' values appropriately.

        if (dx != 0) {
            double sdx = dx * (hsb.getMax() - hsb.getMin()) / (nodeWidth - contentWidth);
            // Adjust back for some amount so that the Node border is not too close to view border
            sdx += -1 * Math.signum(sdx) * hsb.getUnitIncrement() / 5; // This accounts to 2% of view width
            hsb.setValue(hsb.getValue() + sdx);
            getSkinnable().requestLayout();
        }
        if (dy != 0) {
            double sdy = dy * (vsb.getMax() - vsb.getMin()) / (nodeHeight - contentHeight);
            // Adjust back for some amount so that the Node border is not too close to view border
            sdy += -1 * Math.signum(sdy) * vsb.getUnitIncrement() / 5; // This accounts to 2% of view height
            vsb.setValue(vsb.getValue() + sdy);
            getSkinnable().requestLayout();
        }

    }

    /**
     * Computes the size that should be reserved for horizontal scrollbar in size hints (min/pref height)
     */
    private double computeHsbSizeHint(ScrollPane sp) {
        return ((sp.getHbarPolicy() == ScrollBarPolicy.ALWAYS) ||
                (sp.getHbarPolicy() == ScrollBarPolicy.AS_NEEDED &amp;&amp; (sp.getPrefViewportHeight() &gt; 0 || sp.getMinViewportHeight() &gt; 0)))
                ? hsb.prefHeight(ScrollBar.USE_COMPUTED_SIZE)
                : 0;
    }

    /**
     * Computes the size that should be reserved for vertical scrollbar in size hints (min/pref width)
     */
    private double computeVsbSizeHint(ScrollPane sp) {
        return ((sp.getVbarPolicy() == ScrollBarPolicy.ALWAYS) ||
                (sp.getVbarPolicy() == ScrollBarPolicy.AS_NEEDED &amp;&amp; (sp.getPrefViewportWidth() &gt; 0
                        || sp.getMinViewportWidth() &gt; 0)))
                ? vsb.prefWidth(ScrollBar.USE_COMPUTED_SIZE)
                : 0;
    }

    private void computeScrollNodeSize(double contentWidth, double contentHeight) {
        if (scrollNode != null) {
            if (scrollNode.isResizable()) {
                ScrollPane control = getSkinnable();
                Orientation bias = scrollNode.getContentBias();
                if (bias == null) {
                    nodeWidth = snapSizeX(boundedSize(control.isFitToWidth()? contentWidth : scrollNode.prefWidth(-1),
                                                         scrollNode.minWidth(-1),scrollNode.maxWidth(-1)));
                    nodeHeight = snapSizeY(boundedSize(control.isFitToHeight()? contentHeight : scrollNode.prefHeight(-1),
                                                          scrollNode.minHeight(-1), scrollNode.maxHeight(-1)));

                } else if (bias == Orientation.HORIZONTAL) {
                    nodeWidth = snapSizeX(boundedSize(control.isFitToWidth()? contentWidth : scrollNode.prefWidth(-1),
                                                         scrollNode.minWidth(-1),scrollNode.maxWidth(-1)));
                    nodeHeight = snapSizeY(boundedSize(control.isFitToHeight()? contentHeight : scrollNode.prefHeight(nodeWidth),
                                                          scrollNode.minHeight(nodeWidth),scrollNode.maxHeight(nodeWidth)));

                } else { // bias == VERTICAL
                    nodeHeight = snapSizeY(boundedSize(control.isFitToHeight()? contentHeight : scrollNode.prefHeight(-1),
                                                          scrollNode.minHeight(-1), scrollNode.maxHeight(-1)));
                    nodeWidth = snapSizeX(boundedSize(control.isFitToWidth()? contentWidth : scrollNode.prefWidth(nodeHeight),
                                                         scrollNode.minWidth(nodeHeight),scrollNode.maxWidth(nodeHeight)));
                }

            } else {
                nodeWidth = snapSizeX(scrollNode.getLayoutBounds().getWidth());
                nodeHeight = snapSizeY(scrollNode.getLayoutBounds().getHeight());
            }
            nodeSizeInvalid = false;
        }
    }

    private boolean isReverseNodeOrientation() {
        return (scrollNode != null &amp;&amp;
                getSkinnable().getEffectiveNodeOrientation() !=
                            scrollNode.getEffectiveNodeOrientation());
    }

    private boolean determineHorizontalSBVisible() {
        final ScrollPane sp = getSkinnable();

        if (Properties.IS_TOUCH_SUPPORTED) {
            return (tempVisibility &amp;&amp; (nodeWidth &gt; contentWidth));
        }
        else {
            // RT-17395: ScrollBarPolicy might be null. If so, treat it as &quot;AS_NEEDED&quot;, which is the default
            ScrollBarPolicy hbarPolicy = sp.getHbarPolicy();
            return (ScrollBarPolicy.NEVER == hbarPolicy) ? false :
                   ((ScrollBarPolicy.ALWAYS == hbarPolicy) ? true :
                   ((sp.isFitToWidth() &amp;&amp; scrollNode != null ? scrollNode.isResizable() : false) ?
                   (nodeWidth &gt; contentWidth &amp;&amp; scrollNode.minWidth(-1) &gt; contentWidth) : (nodeWidth &gt; contentWidth)));
        }
    }

    private boolean determineVerticalSBVisible() {
        final ScrollPane sp = getSkinnable();

        if (Properties.IS_TOUCH_SUPPORTED) {
            return (tempVisibility &amp;&amp; (nodeHeight &gt; contentHeight));
        }
        else {
            // RT-17395: ScrollBarPolicy might be null. If so, treat it as &quot;AS_NEEDED&quot;, which is the default
            ScrollBarPolicy vbarPolicy = sp.getVbarPolicy();
            return (ScrollBarPolicy.NEVER == vbarPolicy) ? false :
                   ((ScrollBarPolicy.ALWAYS == vbarPolicy) ? true :
                   ((sp.isFitToHeight() &amp;&amp; scrollNode != null ? scrollNode.isResizable() : false) ?
                   (nodeHeight &gt; contentHeight &amp;&amp; scrollNode.minHeight(-1) &gt; contentHeight) : (nodeHeight &gt; contentHeight)));
        }
    }

    private void computeScrollBarSize() {
        vsbWidth = snapSizeX(vsb.prefWidth(-1));
        if (vsbWidth == 0) {
            //            println(&quot;*** WARNING ScrollPaneSkin: can't get scroll bar width, using {DEFAULT_SB_BREADTH}&quot;);
            if (Properties.IS_TOUCH_SUPPORTED) {
                vsbWidth = DEFAULT_EMBEDDED_SB_BREADTH;
            }
            else {
                vsbWidth = DEFAULT_SB_BREADTH;
            }
        }
        hsbHeight = snapSizeY(hsb.prefHeight(-1));
        if (hsbHeight == 0) {
            //            println(&quot;*** WARNING ScrollPaneSkin: can't get scroll bar height, using {DEFAULT_SB_BREADTH}&quot;);
            if (Properties.IS_TOUCH_SUPPORTED) {
                hsbHeight = DEFAULT_EMBEDDED_SB_BREADTH;
            }
            else {
                hsbHeight = DEFAULT_SB_BREADTH;
            }
        }
    }

    private void updateHorizontalSB() {
        double contentRatio = nodeWidth * (hsb.getMax() - hsb.getMin());
        if (contentRatio &gt; 0.0) {
            hsb.setVisibleAmount(contentWidth / contentRatio);
            hsb.setBlockIncrement(0.9 * hsb.getVisibleAmount());
            hsb.setUnitIncrement(0.1 * hsb.getVisibleAmount());
        }
        else {
            hsb.setVisibleAmount(0.0);
            hsb.setBlockIncrement(0.0);
            hsb.setUnitIncrement(0.0);
        }

        if (hsb.isVisible()) {
            updatePosX();
        } else {
            if (nodeWidth &gt; contentWidth) {
                updatePosX();
            } else {
                viewContent.setLayoutX(0);
            }
        }
    }

    private void updateVerticalSB() {
        double contentRatio = nodeHeight * (vsb.getMax() - vsb.getMin());
        if (contentRatio &gt; 0.0) {
            vsb.setVisibleAmount(contentHeight / contentRatio);
            vsb.setBlockIncrement(0.9 * vsb.getVisibleAmount());
            vsb.setUnitIncrement(0.1 * vsb.getVisibleAmount());
        }
        else {
            vsb.setVisibleAmount(0.0);
            vsb.setBlockIncrement(0.0);
            vsb.setUnitIncrement(0.0);
        }

        if (vsb.isVisible()) {
            updatePosY();
        } else {
            if (nodeHeight &gt; contentHeight) {
                updatePosY();
            } else {
                viewContent.setLayoutY(0);
            }
        }
    }

    private double updatePosX() {
        final ScrollPane sp = getSkinnable();
        double x = isReverseNodeOrientation() ? (hsb.getMax() - (posX - hsb.getMin())) : posX;
        double minX = Math.min((- x / (hsb.getMax() - hsb.getMin()) * (nodeWidth - contentWidth)), 0);
        viewContent.setLayoutX(snapPositionX(minX));
        if (!sp.hvalueProperty().isBound()) sp.setHvalue(Utils.clamp(sp.getHmin(), posX, sp.getHmax()));
        return posX;
    }

    private double updatePosY() {
        final ScrollPane sp = getSkinnable();
        double minY = Math.min((- posY / (vsb.getMax() - vsb.getMin()) * (nodeHeight - contentHeight)), 0);
        viewContent.setLayoutY(snapPositionY(minY));
        if (!sp.vvalueProperty().isBound()) sp.setVvalue(Utils.clamp(sp.getVmin(), posY, sp.getVmax()));
        return posY;
    }

    private void resetClip() {
        clipRect.setWidth(snapSizeX(contentWidth));
        clipRect.setHeight(snapSizeY(contentHeight));
    }

    private void startSBReleasedAnimation() {
        if (sbTouchTimeline == null) {
            /*
            ** timeline to leave the scrollbars visible for a short
            ** while after a scroll/drag
            */
            sbTouchTimeline = new Timeline();
            sbTouchKF1 = new KeyFrame(Duration.millis(0), event -&gt; {
                tempVisibility = true;
                if (touchDetected == true || mouseDown == true) {
                    sbTouchTimeline.playFromStart();
                }
            });

            sbTouchKF2 = new KeyFrame(Duration.millis(1000), event -&gt; {
                tempVisibility = false;
                getSkinnable().requestLayout();
            });
            sbTouchTimeline.getKeyFrames().addAll(sbTouchKF1, sbTouchKF2);
        }
        sbTouchTimeline.playFromStart();
    }

    private void startContentsToViewport() {
        double newPosX = posX;
        double newPosY = posY;

        setContentPosX(posX);
<A NAME="15"></A>        setContentPosY(posY);

        if (posY &gt; getSkinnable().getVmax()) {
            newPosY = <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#15',2,'match58-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getSkinnable().getVmax();
        }
        else if (posY &lt; getSkinnable().getVmin()) {
            n</B></FONT>ewPosY = getSkinnable().getVmin();
        }


        if (posX &gt; getSkinnable().getHmax()) {
            newPosX = getSkinnable().getHmax();
        }
        else if (posX &lt; getSkinnable().getHmin()) {
            newPosX = getSkinnable().getHmin();
        }

        if (!Properties.IS_TOUCH_SUPPORTED) {
            startSBReleasedAnimation();
        }

        /*
        ** timeline to return the contents of the scrollpane to the viewport
        */
        if (contentsToViewTimeline != null) {
            contentsToViewTimeline.stop();
        }
        contentsToViewTimeline = new Timeline();
        /*
        ** short pause before animation starts
        */
        contentsToViewKF1 = new KeyFrame(Duration.millis(50));
        /*
        ** reposition
        */
        contentsToViewKF2 = new KeyFrame(Duration.millis(150), event -&gt; {
            getSkinnable().requestLayout();
        },
                new KeyValue(contentPosX, newPosX),
                new KeyValue(contentPosY, newPosY)
        );
        /*
        ** block out 'aftershocks', but real events will
        ** still reactivate
        */
        contentsToViewKF3 = new KeyFrame(Duration.millis(1500));
        contentsToViewTimeline.getKeyFrames().addAll(contentsToViewKF1, contentsToViewKF2, contentsToViewKF3);
        contentsToViewTimeline.playFromStart();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

<A NAME="8"></A>        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#8',2,'match58-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        }</B></FONT>;

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableViewSkinBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.Properties;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.geometry.Insets;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.control.*;

import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.util.Callback;

import javafx.collections.WeakListChangeListener;
import com.sun.javafx.scene.control.skin.resources.ControlResources;

import java.lang.ref.WeakReference;
import java.util.List;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.geometry.HPos;
import javafx.geometry.VPos;

import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * TableViewSkinBase is the base skin class used by controls such as
 * {@link javafx.scene.control.TableView} and {@link javafx.scene.control.TreeTableView}
 * (the concrete classes are {@link TableViewSkin} and {@link TreeTableViewSkin},
 * respectively).
 *
 * @param &lt;M&gt; The type of the item stored in each row (for TableView, this is the type
 *           of the items list, and for TreeTableView, this is the type of the
 *           TreeItem).
 * @param &lt;S&gt; The type of the item, as represented by the selection model (for
 *           TableView, this is, again, the type of the items list, and for
 *           TreeTableView, this is TreeItem typed to the same type as M).
 * @param &lt;C&gt; The type of the virtualised control (e.g TableView, TreeTableView)
 * @param &lt;I&gt; The type of cell used by this virtualised control (e.g. TableRow, TreeTableRow)
 * @param &lt;TC&gt; The type of TableColumnBase used by this virtualised control (e.g. TableColumn, TreeTableColumn)
 *
 * @since 9
 * @see TableView
 * @see TreeTableView
 * @see TableViewSkin
 * @see TreeTableViewSkin
 */
public abstract class TableViewSkinBase&lt;M, S, C extends Control, I extends IndexedCell&lt;M&gt;, TC extends TableColumnBase&lt;S,?&gt;&gt; extends VirtualContainerBase&lt;C, I&gt; {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;

    // RT-34744 : IS_PANNABLE will be false unless
    // javafx.scene.control.skin.TableViewSkin.pannable
    // is set to true. This is done in order to make TableView functional
    // on embedded systems with touch screens which do not generate scroll
    // events for touch drag gestures.
    private static final boolean IS_PANNABLE =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.control.skin.TableViewSkin.pannable&quot;));



    /***************************************************************************
     *                                                                         *
     * Internal Fields                                                         *
     *                                                                         *
     **************************************************************************/

    // JDK-8090129: These constants should not be static, because the
    // Locale may change between instances.
    private final String EMPTY_TABLE_TEXT = ControlResources.getString(&quot;TableView.noContent&quot;);
    private final String NO_COLUMNS_TEXT = ControlResources.getString(&quot;TableView.noColumns&quot;);

    VirtualFlow&lt;I&gt; flow;

    private boolean contentWidthDirty = true;

    /**
     * This region is used to overlay atop the table when the user is performing
     * a column resize operation or a column reordering operation. It is a line
     * that runs the height of the table to indicate either the final width of
     * of the selected column, or the position the column will be 'dropped' into
     * when the reordering operation completes.
     */
    private Region columnReorderLine;

    /**
     * A region which is resized and positioned such that it perfectly matches
     * the dimensions of any TableColumn that is being reordered by the user.
     * This is useful, for example, as a semi-transparent overlay to give
     * feedback to the user as to which column is currently being moved.
     */
    private Region columnReorderOverlay;

    /**
     * The entire header region for all columns. This header region handles
     * column reordering and resizing. It also handles the positioning and
     * resizing of thte columnReorderLine and columnReorderOverlay.
     */
    private TableHeaderRow tableHeaderRow;

    private Callback&lt;C, I&gt; rowFactory;

    /**
     * Region placed over the top of the flow (and possibly the header row) if
     * there is no data and/or there are no columns specified.
     */
    private StackPane placeholderRegion;
    private Label placeholderLabel;

    private int visibleColCount;

    boolean needCellsRecreated = true;
    boolean needCellsReconfigured = false;

    private int itemCount = -1;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private MapChangeListener&lt;Object, Object&gt; propertiesMapListener = c -&gt; {
<A NAME="14"></A>        if (! c.wasAdded()) return;
        if (Properties.REFRESH.equals(c.getKey())) {
            refreshView();
            <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#14',2,'match58-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getSkinnable().getProperties().remove(Properties.REFRESH);
        } else if (Properties.RECREATE.equals(c.getKey())) {
            n</B></FONT>eedCellsRecreated = true;
            refreshView();
            getSkinnable().getProperties().remove(Properties.RECREATE);
        }
    };

    private ListChangeListener&lt;S&gt; rowCountListener = c -&gt; {
        while (c.next()) {
            if (c.wasReplaced()) {
                // RT-28397: Support for when an item is replaced with itself (but
                // updated internal values that should be shown visually).

                // The ListViewSkin equivalent code here was updated to use the
                // flow.setDirtyCell(int) API, but it was left alone here, otherwise
                // our unit test for RT-36220 fails as we do not handle the case
                // where the TableCell gets updated (only the TableRow does).
                // Ideally we would use the dirtyCell API:
                //
                // for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                //     flow.setCellDirty(i);
                // }
                itemCount = 0;
                break;
            } else if (c.getRemovedSize() == itemCount) {
                // RT-22463: If the user clears out an items list then we
                // should reset all cells (in particular their contained
                // items) such that a subsequent addition to the list of
                // an item which equals the old item (but is rendered
                // differently) still displays as expected (i.e. with the
                // updated display, not the old display).
                itemCount = 0;
                break;
            }
        }

        // fix for RT-37853
        if (getSkinnable() instanceof TableView) {
            ((TableView)getSkinnable()).edit(-1, null);
        }

        markItemCountDirty();
        getSkinnable().requestLayout();
    };

    private ListChangeListener&lt;TC&gt; visibleLeafColumnsListener = c -&gt; {
        updateVisibleColumnCount();
        while (c.next()) {
            updateVisibleLeafColumnWidthListeners(c.getAddedSubList(), c.getRemoved());
        }
    };

    private InvalidationListener widthListener = observable -&gt; {
        // This forces the horizontal scrollbar to show when the column
        // resizing occurs. It is not ideal, but will work for now.

        // using 'needCellsReconfigured' here rather than 'needCellsRebuilt'
        // as otherwise performance suffers massively (RT-27831)
        needCellsReconfigured = true;
        if (getSkinnable() != null) {
            getSkinnable().requestLayout();
        }
    };

    private InvalidationListener itemsChangeListener;

    private WeakListChangeListener&lt;S&gt; weakRowCountListener =
            new WeakListChangeListener&lt;&gt;(rowCountListener);
    private WeakListChangeListener&lt;TC&gt; weakVisibleLeafColumnsListener =
            new WeakListChangeListener&lt;&gt;(visibleLeafColumnsListener);
    private WeakInvalidationListener weakWidthListener =
            new WeakInvalidationListener(widthListener);
    private WeakInvalidationListener weakItemsChangeListener;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     *
     * @param control the control
     */
    public TableViewSkinBase(final C control) {
        super(control);

        // init the VirtualFlow
        flow = getVirtualFlow();
        flow.setPannable(IS_PANNABLE);
//        flow.setCellFactory(flow1 -&gt; TableViewSkinBase.this.createCell());

        /*
         * Listening for scrolling along the X axis, but we need to be careful
         * to handle the situation appropriately when the hbar is invisible.
         */
        flow.getHbar().valueProperty().addListener(o -&gt; horizontalScroll());

        // RT-37152
        flow.getHbar().setUnitIncrement(15);
        flow.getHbar().setBlockIncrement(TableColumnHeader.DEFAULT_COLUMN_WIDTH);

        columnReorderLine = new Region();
        columnReorderLine.getStyleClass().setAll(&quot;column-resize-line&quot;);
        columnReorderLine.setManaged(false);
        columnReorderLine.setVisible(false);

        columnReorderOverlay = new Region();
        columnReorderOverlay.getStyleClass().setAll(&quot;column-overlay&quot;);
        columnReorderOverlay.setVisible(false);
        columnReorderOverlay.setManaged(false);

        tableHeaderRow = createTableHeaderRow();
//        tableHeaderRow.setColumnReorderLine(columnReorderLine);
        tableHeaderRow.setFocusTraversable(false);

        getChildren().addAll(tableHeaderRow, flow, columnReorderOverlay, columnReorderLine);

        updateVisibleColumnCount();
        updateVisibleLeafColumnWidthListeners(getVisibleLeafColumns(), FXCollections.&lt;TC&gt;emptyObservableList());

        tableHeaderRow.reorderingProperty().addListener(valueModel -&gt; {
            getSkinnable().requestLayout();
        });

        getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);

        final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty = TableSkinUtils.itemsProperty(this);
        updateTableItems(null, itemsProperty.get());
        itemsChangeListener = new InvalidationListener() {
            private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(itemsProperty.get());

            @Override public void invalidated(Observable observable) {
                ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                weakItemsRef = new WeakReference&lt;&gt;(itemsProperty.get());
                updateTableItems(oldItems, itemsProperty.get());
            }
        };
        weakItemsChangeListener = new WeakInvalidationListener(itemsChangeListener);
        itemsProperty.addListener(weakItemsChangeListener);

        final ObservableMap&lt;Object, Object&gt; properties = control.getProperties();
        properties.remove(Properties.REFRESH);
        properties.remove(Properties.RECREATE);
        properties.addListener(propertiesMapListener);

        control.addEventHandler(ScrollToEvent.&lt;TC&gt;scrollToColumn(), event -&gt; {
            scrollHorizontally(event.getScrollTarget());
        });

        // flow and flow.vbar width observer
        InvalidationListener widthObserver = valueModel -&gt; {
            contentWidthDirty = true;
            getSkinnable().requestLayout();
        };
        flow.widthProperty().addListener(widthObserver);
        flow.getVbar().widthProperty().addListener(widthObserver);

        final ObjectProperty&lt;Callback&lt;C, I&gt;&gt; rowFactoryProperty = TableSkinUtils.rowFactoryProperty(this);
        registerChangeListener(rowFactoryProperty, e -&gt; {
            Callback&lt;C, I&gt; oldFactory = rowFactory;
            rowFactory = rowFactoryProperty.get();
            if (oldFactory != rowFactory) {
                requestRebuildCells();
            }
        });
        registerChangeListener(TableSkinUtils.placeholderProperty(this), e -&gt; updatePlaceholderRegionVisibility());
        registerChangeListener(flow.getVbar().visibleProperty(), e -&gt; updateContentWidth());
    }



    /***************************************************************************
     *                                                                         *
     * Abstract Methods                                                        *
     *                                                                         *
     **************************************************************************/





    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty = TableSkinUtils.itemsProperty(this);

        getVisibleLeafColumns().removeListener(weakVisibleLeafColumnsListener);
        itemsProperty.removeListener(weakItemsChangeListener);
        getSkinnable().getProperties().removeListener(propertiesMapListener);
        updateTableItems(itemsProperty.get(), null);

        super.dispose();
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return 400;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefHeight = computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);

        List&lt;? extends TC&gt; cols = getVisibleLeafColumns();
        if (cols == null || cols.isEmpty()) {
            return prefHeight * GOLDEN_RATIO_MULTIPLIER;
        }

        double pw = leftInset + rightInset;
        for (int i = 0, max = cols.size(); i &lt; max; i++) {
            TC tc = cols.get(i);
            pw += Math.max(tc.getPrefWidth(), tc.getMinWidth());
        }
//        return pw;
        return Math.max(pw, prefHeight * GOLDEN_RATIO_MULTIPLIER);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, double y,
            final double w, final double h) {

        C table = getSkinnable();

        // an unlikely scenario, but it does pop up in unit tests, so guarding
        // here to prevent test failures seems ok.
        if (table == null) {
            return;
        }

        super.layoutChildren(x, y, w, h);

        if (needCellsRecreated) {
            flow.recreateCells();
        } else if (needCellsReconfigured) {
            flow.reconfigureCells();
        }

        needCellsRecreated = false;
        needCellsReconfigured = false;

        final double baselineOffset = table.getLayoutBounds().getHeight() / 2;

        // position the table header
        double tableHeaderRowHeight = tableHeaderRow.prefHeight(-1);
        layoutInArea(tableHeaderRow, x, y, w, tableHeaderRowHeight, baselineOffset,
                HPos.CENTER, VPos.CENTER);
        y += tableHeaderRowHeight;

        // let the virtual flow take up all remaining space
        // TODO this calculation is to ensure the bottom border is visible when
        // placed in a Pane. It is not ideal, but will suffice for now. See
        // RT-14335 for more information.
        double flowHeight = Math.floor(h - tableHeaderRowHeight);
        if (getItemCount() == 0 || visibleColCount == 0) {
            // show message overlay instead of empty table
            layoutInArea(placeholderRegion, x, y,
                    w, flowHeight,
                    baselineOffset, HPos.CENTER, VPos.CENTER);
        } else {
            layoutInArea(flow, x, y,
                    w, flowHeight,
                    baselineOffset, HPos.CENTER, VPos.CENTER);
        }

        // painting the overlay over the column being reordered
        if (tableHeaderRow.getReorderingRegion() != null) {
            TableColumnHeader reorderingColumnHeader = tableHeaderRow.getReorderingRegion();
            TableColumnBase reorderingColumn = reorderingColumnHeader.getTableColumn();
            if (reorderingColumn != null) {
                Node n = tableHeaderRow.getReorderingRegion();

                // determine where to draw the column header overlay, it's
                // either from the left-edge of the column, or 0, if the column
                // is off the left-side of the TableView (i.e. horizontal
                // scrolling has occured).
                double minX = tableHeaderRow.sceneToLocal(n.localToScene(n.getBoundsInLocal())).getMinX();
                double overlayWidth = reorderingColumnHeader.getWidth();
                if (minX &lt; 0) {
                    overlayWidth += minX;
                }
                minX = minX &lt; 0 ? 0 : minX;

                // prevent the overlay going out the right-hand side of the
                // TableView
                if (minX + overlayWidth &gt; w) {
                    overlayWidth = w - minX;

                    if (flow.getVbar().isVisible()) {
                        overlayWidth -= flow.getVbar().getWidth() - 1;
                    }
                }

                double contentAreaHeight = flowHeight;
                if (flow.getHbar().isVisible()) {
                    contentAreaHeight -= flow.getHbar().getHeight();
                }

                columnReorderOverlay.resize(overlayWidth, contentAreaHeight);

                columnReorderOverlay.setLayoutX(minX);
                columnReorderOverlay.setLayoutY(tableHeaderRow.getHeight());
            }

            // paint the reorder line as well
            double cw = columnReorderLine.snappedLeftInset() + columnReorderLine.snappedRightInset();
            double lineHeight = h - (flow.getHbar().isVisible() ? flow.getHbar().getHeight() - 1 : 0);
            columnReorderLine.resizeRelocate(0, columnReorderLine.snappedTopInset(), cw, lineHeight);
        }

        columnReorderLine.setVisible(tableHeaderRow.isReordering());
        columnReorderOverlay.setVisible(tableHeaderRow.isReordering());

        checkContentWidthState();
    }

    /**
     * Creates a new TableHeaderRow instance. By default this method should not be overridden, but in some
     * circumstances it makes sense (e.g. testing, or when extreme customization is desired).
     *
     * @return A new TableHeaderRow instance.
     */
    protected TableHeaderRow createTableHeaderRow() {
        return new TableHeaderRow(this);
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    final TableHeaderRow getTableHeaderRow() {
        return tableHeaderRow;
    }

    private TableSelectionModel&lt;S&gt; getSelectionModel() {
        return TableSkinUtils.getSelectionModel(this);
    }

    private TableFocusModel&lt;M,?&gt; getFocusModel() {
        return TableSkinUtils.getFocusModel(this);
    }

    // returns the currently focused cell in the focus model
    private TablePositionBase&lt;? extends TC&gt; getFocusedCell() {
        return TableSkinUtils.getFocusedCell(this);
    }

    // returns an ObservableList of the visible leaf columns of the control
    private ObservableList&lt;? extends TC&gt; getVisibleLeafColumns() {
        return TableSkinUtils.getVisibleLeafColumns(this);
    }

    /** {@inheritDoc} */
    @Override protected void updateItemCount() {
        updatePlaceholderRegionVisibility();

        int oldCount = itemCount;
        int newCount = getItemCount();

        itemCount = newCount;

        if (itemCount == 0) {
            flow.getHbar().setValue(0.0);
        }

        // if this is not called even when the count is the same, we get a
        // memory leak in VirtualFlow.sheet.children. This can probably be
        // optimised in the future when time permits.
        flow.setCellCount(newCount);

        if (newCount != oldCount) {
            // FIXME updateItemCount is called _a lot_. Perhaps we can make rebuildCells
            // smarter. Imagine if items has one million items added - do we really
            // need to rebuildCells a million times? Maybe this is better now that
            // we do rebuildCells instead of recreateCells.
            requestRebuildCells();
        } else {
            needCellsReconfigured = true;
        }
    }

    private void checkContentWidthState() {
        // we test for item count here to resolve RT-14855, where the column
        // widths weren't being resized properly when in constrained layout mode
        // if there were no items.
        if (contentWidthDirty || getItemCount() == 0) {
            updateContentWidth();
            contentWidthDirty = false;
        }
    }

    void horizontalScroll() {
        tableHeaderRow.updateScrollX();
    }

    void onFocusPreviousCell() {
        TableFocusModel&lt;M,?&gt; fm = getFocusModel();
        if (fm == null) return;

        flow.scrollTo(fm.getFocusedIndex());
    }

    void onFocusNextCell() {
        TableFocusModel&lt;M,?&gt; fm = getFocusModel();
        if (fm == null) return;

        flow.scrollTo(fm.getFocusedIndex());
    }

    void onSelectPreviousCell() {
        SelectionModel&lt;S&gt; sm = getSelectionModel();
        if (sm == null) return;

        flow.scrollTo(sm.getSelectedIndex());
    }

    void onSelectNextCell() {
        SelectionModel&lt;S&gt; sm = getSelectionModel();
        if (sm == null) return;

        flow.scrollTo(sm.getSelectedIndex());
    }

    void onSelectLeftCell() {
        scrollHorizontally();
    }

    void onSelectRightCell() {
        scrollHorizontally();
    }

    void onMoveToFirstCell() {
        flow.scrollTo(0);
        flow.setPosition(0);
    }

    void onMoveToLastCell() {
        int endPos = getItemCount();
        flow.scrollTo(endPos);
        flow.setPosition(1);
    }

    private void updateTableItems(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
        if (oldList != null) {
            oldList.removeListener(weakRowCountListener);
        }

        if (newList != null) {
            newList.addListener(weakRowCountListener);
        }

        markItemCountDirty();
        getSkinnable().requestLayout();
    }

    Region getColumnReorderLine() {
        return columnReorderLine;
    }

    /**
     * Function used to scroll the container down by one 'page', although
     * if this is a horizontal container, then the scrolling will be to the right.
     */
    int onScrollPageDown(boolean isFocusDriven) {
        TableSelectionModel&lt;S&gt; sm = getSelectionModel();
        if (sm == null) return -1;

        final int itemCount = getItemCount();

        I lastVisibleCell = flow.getLastVisibleCellWithinViewPort();
        if (lastVisibleCell == null) return -1;

        int lastVisibleCellIndex = lastVisibleCell.getIndex();

        // we include this test here as the virtual flow will return cells that
        // exceed past the item count, so we need to clamp here (and further down
        // in this method also). See RT-19053 for more information.
        lastVisibleCellIndex = lastVisibleCellIndex &gt;= itemCount ? itemCount - 1 : lastVisibleCellIndex;

        // isSelected represents focus OR selection
        boolean isSelected;
        if (isFocusDriven) {
            isSelected = lastVisibleCell.isFocused() || isCellFocused(lastVisibleCellIndex);
        } else {
            isSelected = lastVisibleCell.isSelected() || isCellSelected(lastVisibleCellIndex);
        }

        if (isSelected) {
            boolean isLeadIndex = isLeadIndex(isFocusDriven, lastVisibleCellIndex);

            if (isLeadIndex) {
                // if the last visible cell is selected, we want to shift that cell up
                // to be the top-most cell, or at least as far to the top as we can go.
                flow.scrollToTop(lastVisibleCell);

                I newLastVisibleCell = flow.getLastVisibleCellWithinViewPort();
                lastVisibleCell = newLastVisibleCell == null ? lastVisibleCell : newLastVisibleCell;
            }
        }

        int newSelectionIndex = lastVisibleCell.getIndex();
        newSelectionIndex = newSelectionIndex &gt;= itemCount ? itemCount - 1 : newSelectionIndex;
        flow.scrollTo(newSelectionIndex);
        return newSelectionIndex;
    }

    /**
     * Function used to scroll the container up by one 'page', although
     * if this is a horizontal container, then the scrolling will be to the left.
     */
    int onScrollPageUp(boolean isFocusDriven) {
        I firstVisibleCell = flow.getFirstVisibleCellWithinViewPort();
        if (firstVisibleCell == null) return -1;

        int firstVisibleCellIndex = firstVisibleCell.getIndex();

        // isSelected represents focus OR selection
        boolean isSelected = false;
        if (isFocusDriven) {
            isSelected = firstVisibleCell.isFocused() || isCellFocused(firstVisibleCellIndex);
        } else {
            isSelected = firstVisibleCell.isSelected() || isCellSelected(firstVisibleCellIndex);
        }

        if (isSelected) {
            boolean isLeadIndex = isLeadIndex(isFocusDriven, firstVisibleCellIndex);

            if (isLeadIndex) {
                // if the first visible cell is selected, we want to shift that cell down
                // to be the bottom-most cell, or at least as far to the bottom as we can go.
                flow.scrollToBottom(firstVisibleCell);

                I newFirstVisibleCell = flow.getFirstVisibleCellWithinViewPort();
                firstVisibleCell = newFirstVisibleCell == null ? firstVisibleCell : newFirstVisibleCell;
            }
        }

        int newSelectionIndex = firstVisibleCell.getIndex();
        flow.scrollTo(newSelectionIndex);
        return newSelectionIndex;
    }

    private boolean isLeadIndex(boolean isFocusDriven, int index) {
        final TableSelectionModel&lt;S&gt; sm = getSelectionModel();
        final FocusModel&lt;M&gt; fm = getFocusModel();

        return (isFocusDriven &amp;&amp; fm.getFocusedIndex() == index)
                || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == index);
    }

    /**
     * Keeps track of how many leaf columns are currently visible in this table.
     */
    private void updateVisibleColumnCount() {
        visibleColCount = getVisibleLeafColumns().size();

        updatePlaceholderRegionVisibility();
        requestRebuildCells();
    }

    private void updateVisibleLeafColumnWidthListeners(
            List&lt;? extends TC&gt; added, List&lt;? extends TC&gt; removed) {

        for (int i = 0, max = removed.size(); i &lt; max; i++) {
            TC tc = removed.get(i);
            tc.widthProperty().removeListener(weakWidthListener);
        }
        for (int i = 0, max = added.size(); i &lt; max; i++) {
            TC tc = added.get(i);
            tc.widthProperty().addListener(weakWidthListener);
        }
        requestRebuildCells();
    }

    final void updatePlaceholderRegionVisibility() {
        boolean visible = visibleColCount == 0 || getItemCount() == 0;

        if (visible) {
            if (placeholderRegion == null) {
                placeholderRegion = new StackPane();
                placeholderRegion.getStyleClass().setAll(&quot;placeholder&quot;);
                getChildren().add(placeholderRegion);
            }

            Node placeholderNode = TableSkinUtils.placeholderProperty(this).get();

            if (placeholderNode == null) {
                if (placeholderLabel == null) {
                    placeholderLabel = new Label();
                }
                String s = visibleColCount == 0 ? NO_COLUMNS_TEXT : EMPTY_TABLE_TEXT;
                placeholderLabel.setText(s);

                placeholderRegion.getChildren().setAll(placeholderLabel);
            } else {
                placeholderRegion.getChildren().setAll(placeholderNode);
            }
        }

        flow.setVisible(! visible);
        if (placeholderRegion != null) {
            placeholderRegion.setVisible(visible);
        }
    }

    /*
     * It's often important to know how much width is available for content
     * within the table, and this needs to exclude the width of any vertical
     * scrollbar.
     */
    private void updateContentWidth() {
        double contentWidth = flow.getWidth();

        if (flow.getVbar().isVisible()) {
            contentWidth -= flow.getVbar().getWidth();
        }

        if (contentWidth &lt;= 0) {
            // Fix for RT-14855 when there is no content in the TableView.
            Control c = getSkinnable();
            contentWidth = c.getWidth() - (snappedLeftInset() + snappedRightInset());
        }

        contentWidth = Math.max(0.0, contentWidth);

        // FIXME this isn't perfect, but it prevents RT-14885, which results in
        // undesired horizontal scrollbars when in constrained resize mode
        getSkinnable().getProperties().put(&quot;TableView.contentWidth&quot;, Math.floor(contentWidth));
    }

    private void refreshView() {
        markItemCountDirty();
        Control c = getSkinnable();
        if (c != null) {
            c.requestLayout();
        }
    }

    // Handles the horizontal scrolling when the selection mode is cell-based
    // and the newly selected cell belongs to a column which is not totally
    // visible.
    void scrollHorizontally() {
        TableFocusModel&lt;M,?&gt; fm = getFocusModel();
        if (fm == null) return;

        TC col = getFocusedCell().getTableColumn();
        scrollHorizontally(col);
    }

    void scrollHorizontally(TC col) {
        if (col == null || !col.isVisible()) return;

        final Control control = getSkinnable();

        // RT-37060 - if we are trying to scroll to a column that has not
        // yet even been rendered, we must wait until the layout pass has
        // happened and then do the scroll. The laziest way to do this is to
        // queue up the task to run later, at which point we will have hopefully
        // fully run the column through layout and css.
        TableColumnHeader header = tableHeaderRow.getColumnHeaderFor(col);
        if (header == null || header.getWidth() &lt;= 0) {
            Platform.runLater(() -&gt; scrollHorizontally(col));
            return;
        }

        // work out where this column header is, and it's width (start -&gt; end)
        double start = 0;
        for (TC c : getVisibleLeafColumns()) {
            if (c.equals(col)) break;
            start += c.getWidth();
        }
        double end = start + col.getWidth();

        // determine the visible width of the table
        double headerWidth = control.getWidth() - snappedLeftInset() - snappedRightInset();

        // determine by how much we need to translate the table to ensure that
        // the start position of this column lines up with the left edge of the
        // tableview, and also that the columns don't become detached from the
        // right edge of the table
        double pos = flow.getHbar().getValue();
        double max = flow.getHbar().getMax();
        double newPos;

        if (start &lt; pos &amp;&amp; start &gt;= 0) {
            newPos = start;
        } else {
            double delta = start &lt; 0 || end &gt; headerWidth ? start - pos : 0;
            newPos = pos + delta &gt; max ? max : pos + delta;
        }

        // FIXME we should add API in VirtualFlow so we don't end up going
        // direct to the hbar.
        // actually shift the flow - this will result in the header moving
        // as well
        flow.getHbar().setValue(newPos);
    }

    private boolean isCellSelected(int row) {
        TableSelectionModel&lt;S&gt; sm = getSelectionModel();
        if (sm == null) return false;
        if (! sm.isCellSelectionEnabled()) return false;

        int columnCount = getVisibleLeafColumns().size();
        for (int col = 0; col &lt; columnCount; col++) {
            if (sm.isSelected(row, TableSkinUtils.getVisibleLeafColumn(this,col))) {
                return true;
            }
        }

        return false;
    }

    private boolean isCellFocused(int row) {
        TableFocusModel&lt;S,TC&gt; fm = (TableFocusModel&lt;S,TC&gt;)(Object)getFocusModel();
        if (fm == null) return false;

        int columnCount = getVisibleLeafColumns().size();
        for (int col = 0; col &lt; columnCount; col++) {
            if (fm.isFocused(row, TableSkinUtils.getVisibleLeafColumn(this,col))) {
                return true;
            }
        }

        return false;
    }



    /***************************************************************************
     *                                                                         *
     * A11y                                                                    *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: {
                TableFocusModel&lt;M,?&gt; fm = getFocusModel();
                int focusedIndex = fm.getFocusedIndex();
                if (focusedIndex == -1) {
                    if (placeholderRegion != null &amp;&amp; placeholderRegion.isVisible()) {
                        return placeholderRegion.getChildren().get(0);
                    }
                    if (getItemCount() &gt; 0) {
                        focusedIndex = 0;
                    } else {
                        return null;
                    }
                }
                return flow.getPrivateCell(focusedIndex);
            }
            case CELL_AT_ROW_COLUMN: {
                int rowIndex = (Integer)parameters[0];
                return flow.getPrivateCell(rowIndex);
            }
            case COLUMN_AT_INDEX: {
                int index = (Integer)parameters[0];
                TableColumnBase&lt;S,?&gt; column = TableSkinUtils.getVisibleLeafColumn(this,index);
                return getTableHeaderRow().getColumnHeaderFor(column);
            }
            case HEADER: {
                /* Not sure how this is used by Accessibility, but without this VoiceOver will not
                 * look for column headers */
                return getTableHeaderRow();
            }
            case VERTICAL_SCROLLBAR: return flow.getVbar();
            case HORIZONTAL_SCROLLBAR: return flow.getHbar();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/application/PlatformImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

<A NAME="0"></A>package com.sun.javafx.application;

import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#0',2,'match58-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.javafx.PlatformUtil;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.tk.TKListener;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.util.ModuleHelper;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;

import javafx.application.Application;
import javafx.application.ConditionalFeature;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.scene.Scene;
import javafx.util.FXPermission;

public class PlatformImpl {

    private static AtomicBoolean initialized = new AtomicBoolean(false);
    private static AtomicBoolean platformExit = new AtomicBoolean(false);
    private static AtomicBoolean toolkitExit = new AtomicBoolean(false);
    private static CountDownLatch startupLatch = new CountDownLatch(1);
    private static AtomicBoolean listenersRegistered = new</B></FONT> AtomicBoolean(false);
    private static TKListener toolkitListener = null;
    private static volatile boolean implicitExit = true;
    private static boolean taskbarApplication = true;
    private static boolean contextual2DNavigation;
    private static AtomicInteger pendingRunnables = new AtomicInteger(0);
    private static AtomicInteger numWindows = new AtomicInteger(0);
    private static volatile boolean firstWindowShown = false;
    private static volatile boolean lastWindowClosed = false;
    private static AtomicBoolean reallyIdle = new AtomicBoolean(false);
    private static Set&lt;FinishListener&gt; finishListeners =
            new CopyOnWriteArraySet&lt;FinishListener&gt;();
    private final static Object runLaterLock = new Object();
    private static Boolean isGraphicsSupported;
    private static Boolean isControlsSupported;
    private static Boolean isMediaSupported;
    private static Boolean isWebSupported;
    private static Boolean isSWTSupported;
    private static Boolean isSwingSupported;
    private static Boolean isFXMLSupported;
    private static Boolean hasTwoLevelFocus;
    private static Boolean hasVirtualKeyboard;
    private static Boolean hasTouch;
    private static Boolean hasMultiTouch;
    private static Boolean hasPointer;
    private static boolean isThreadMerged = false;
    private static String applicationType = &quot;&quot;;
    private static BooleanProperty accessibilityActive = new SimpleBooleanProperty();
    private static CountDownLatch allNestedLoopsExitedLatch = new CountDownLatch(1);

    private static final boolean verbose
            = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
                Boolean.getBoolean(&quot;javafx.verbose&quot;));

    private static final boolean DEBUG
            = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ()
                    -&gt; Boolean.getBoolean(&quot;com.sun.javafx.application.debug&quot;));

    // Internal permission used by FXCanvas (SWT interop)
    private static final FXPermission FXCANVAS_PERMISSION =
            new FXPermission(&quot;accessFXCanvasInternals&quot;);

    /**
     * Set a flag indicating whether this application should show up in the
     * task bar. The default value is true.
     *
     * @param taskbarApplication the new value of this attribute
     */
    public static void setTaskbarApplication(boolean taskbarApplication) {
        PlatformImpl.taskbarApplication = taskbarApplication;
    }

    /**
     * Returns the current value of the taskBarApplication flag.
     *
     * @return the current state of the flag.
     */
    public static boolean isTaskbarApplication() {
        return taskbarApplication;
    }

    /**
     * Sets the name of the this application based on the Application class.
     * This method is called by the launcher, and is not
     * called from the FX Application Thread, so we need to do it in a runLater.
     * We do not need to wait for the result since it will complete before the
     * Application start() method is called regardless.
     *
     * @param appClass the Application class.
     */
    public static void setApplicationName(final Class appClass) {
        runLater(() -&gt; com.sun.glass.ui.Application.GetApplication().setName(appClass.getName()));
    }

    /**
     * Return whether or not focus navigation between controls is context-
     * sensitive.
     * @return true if the context-sensitive algorithm for focus navigation is
     * used
     */
     public static boolean isContextual2DNavigation() {
         return contextual2DNavigation;
     }

    /**
     * This method is invoked typically on the main thread. At this point,
     * the JavaFX Application Thread has not been started. Any attempt
     * to call startup more than once results in all subsequent calls turning into
     * nothing more than a runLater call with the provided Runnable being called.
     * @param r
     */
    public static void startup(final Runnable r) {
        startup(r, false);
    }

    /**
     * This method is invoked typically on the main thread. At this point,
     * the JavaFX Application Thread has not been started. If preventDuplicateCalls
     * is true, calling this method multiple times will result in an
     * IllegalStateException. If it is false, calling this method multiple times
     * will result in all subsequent calls turning into
     * nothing more than a runLater call with the provided Runnable being called.
     * @param r
     * @param preventDuplicateCalls
     */
    public static void startup(final Runnable r, boolean preventDuplicateCalls) {

        // NOTE: if we ever support re-launching an application and/or
        // launching a second application in the same VM/classloader
        // this will need to be changed.
        if (platformExit.get()) {
            throw new IllegalStateException(&quot;Platform.exit has been called&quot;);
        }

        if (initialized.getAndSet(true)) {
            if (preventDuplicateCalls) {
                throw new IllegalStateException(&quot;Toolkit already initialized&quot;);
            }

            // If we've already initialized, just put the runnable on the queue.
            runLater(r);
            return;
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            applicationType = System.getProperty(&quot;com.sun.javafx.application.type&quot;);
            if (applicationType == null) applicationType = &quot;&quot;;

            contextual2DNavigation = Boolean.getBoolean(
                    &quot;com.sun.javafx.isContextual2DNavigation&quot;);
            String s = System.getProperty(&quot;com.sun.javafx.twoLevelFocus&quot;);
            if (s != null) {
                hasTwoLevelFocus = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard&quot;);
            if (s != null) {
                if (s.equalsIgnoreCase(&quot;none&quot;)) {
                    hasVirtualKeyboard = false;
                } else if (s.equalsIgnoreCase(&quot;javafx&quot;)) {
                    hasVirtualKeyboard = true;
                } else if (s.equalsIgnoreCase(&quot;native&quot;)) {
                    hasVirtualKeyboard = true;
                }
            }
            s = System.getProperty(&quot;com.sun.javafx.touch&quot;);
            if (s != null) {
                hasTouch = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.multiTouch&quot;);
            if (s != null) {
                hasMultiTouch = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.pointer&quot;);
            if (s != null) {
                hasPointer = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;javafx.embed.singleThread&quot;);
            if (s != null) {
                isThreadMerged = Boolean.valueOf(s);
                if (isThreadMerged &amp;&amp; !isSupported(ConditionalFeature.SWING)) {
                    isThreadMerged = false;
                    if (verbose) {
                        System.err.println(
                        &quot;WARNING: javafx.embed.singleThread ignored (javafx.swing module not found)&quot;);
                    }
                }
            }
            return null;
        });

        if (DEBUG) {
            System.err.println(&quot;PlatformImpl::startup : applicationType = &quot;
                    + applicationType);
        }
        if (&quot;FXCanvas&quot;.equals(applicationType)) {
            initFXCanvas();
        }

        if (!taskbarApplication) {
            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                System.setProperty(&quot;glass.taskbarApplication&quot;, &quot;false&quot;);
                return null;
            });
        }

        // Create Toolkit listener and register it with the Toolkit.
        // Call notifyFinishListeners when we get notified.
        toolkitListener = new TKListener() {
            @Override public void changedTopLevelWindows(List&lt;TKStage&gt; windows) {
                numWindows.set(windows.size());
                checkIdle();
            }

            @Override
            public void exitedLastNestedLoop() {
                if (platformExit.get()) {
                    allNestedLoopsExitedLatch.countDown();
                }
                checkIdle();
            }
        };
        Toolkit.getToolkit().addTkListener(toolkitListener);

        Toolkit.getToolkit().startup(() -&gt; {
            startupLatch.countDown();
            r.run();
        });

        //Initialize the thread merging mechanism
        if (isThreadMerged) {
            installFwEventQueue();
        }
    }

    // Pass certain system properties to glass via the device details Map
    private static void initDeviceDetailsFXCanvas() {
        // Read the javafx.embed.eventProc system property and store
        // it in an entry in the glass Application device details map
        final String eventProcProperty = &quot;javafx.embed.eventProc&quot;;
        final long eventProc = AccessController.doPrivileged((PrivilegedAction&lt;Long&gt;) () -&gt;
                Long.getLong(eventProcProperty, 0));
        if (eventProc != 0L) {
            // Set the value for the javafx.embed.eventProc
            // key in the glass Application map
            Map map = com.sun.glass.ui.Application.getDeviceDetails();
            if (map == null) {
                map = new HashMap();
                com.sun.glass.ui.Application.setDeviceDetails(map);
            }
            if (map.get(eventProcProperty) == null) {
                map.put(eventProcProperty, eventProc);
            }
        }
    }

    // Add the necessary qualified exports to the calling module
    private static void addExportsToFXCanvas(Class&lt;?&gt; fxCanvasClass) {
        final String[] swtNeededPackages = {
            &quot;com.sun.glass.ui&quot;,
            &quot;com.sun.javafx.cursor&quot;,
            &quot;com.sun.javafx.embed&quot;,
            &quot;com.sun.javafx.stage&quot;,
            &quot;com.sun.javafx.tk&quot;
        };

        if (DEBUG) {
            System.err.println(&quot;addExportsToFXCanvas: class = &quot; + fxCanvasClass);
        }
        Object thisModule = ModuleHelper.getModule(PlatformImpl.class);
        Object javafxSwtModule = ModuleHelper.getModule(fxCanvasClass);
        for (String pkg : swtNeededPackages) {
            if (DEBUG) {
                System.err.println(&quot;add export of &quot; + pkg + &quot; from &quot;
                        + thisModule + &quot; to &quot; + javafxSwtModule);
            }
            ModuleHelper.addExports(thisModule, pkg, javafxSwtModule);
        }
    }

    // FXCanvas-specific initialization
    private static void initFXCanvas() {
        // Verify that we have the appropriate permission
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            try {
                sm.checkPermission(FXCANVAS_PERMISSION);
            } catch (SecurityException ex) {
                System.err.println(&quot;FXCanvas: no permission to access JavaFX internals&quot;);
                ex.printStackTrace();
                return;
            }
        }

        // Find the calling class, ignoring any stack frames from FX application classes
        Predicate&lt;StackWalker.StackFrame&gt; classFilter = f -&gt;
                !f.getClassName().startsWith(&quot;javafx.application.&quot;)
                        &amp;&amp; !f.getClassName().startsWith(&quot;com.sun.javafx.application.&quot;);

        final StackWalker walker = AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
                StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));
        Optional&lt;StackWalker.StackFrame&gt; frame = walker.walk(
                s -&gt; s.filter(classFilter).findFirst());

        if (frame.isPresent()) {
            Class&lt;?&gt; caller = frame.get().getDeclaringClass();
            if (DEBUG) {
                System.err.println(&quot;callerClassName = &quot; + caller);
            }

            // Verify that the caller is javafx.embed.swt.FXCanvas
            if (&quot;javafx.embed.swt.FXCanvas&quot;.equals(caller.getName())) {
                initDeviceDetailsFXCanvas();
                addExportsToFXCanvas(caller);
            }
        }
    }

    private static void installFwEventQueue() {
        invokeSwingFXUtilsMethod(&quot;installFwEventQueue&quot;);
    }

    private static void removeFwEventQueue() {
        invokeSwingFXUtilsMethod(&quot;removeFwEventQueue&quot;);
    }

    private static void invokeSwingFXUtilsMethod(final String methodName) {
        //Use reflection in case we are running compact profile
        try {
            Class swingFXUtilsClass = Class.forName(&quot;com.sun.javafx.embed.swing.SwingFXUtilsImpl&quot;);
            Method installFwEventQueue = swingFXUtilsClass.getDeclaredMethod(methodName);

            waitForStart();
            installFwEventQueue.invoke(null);

        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException e) {
            throw new RuntimeException(&quot;Property javafx.embed.singleThread is not supported&quot;);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    private static void waitForStart() {
        // If the startup runnable has not yet been called, then wait it.
        // Note that we check the count before calling await() to avoid
        // the try/catch which is unnecessary after startup.
        if (startupLatch.getCount() &gt; 0) {
            try {
                startupLatch.await();
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static boolean isFxApplicationThread() {
        return Toolkit.getToolkit().isFxUserThread();
    }

    public static void runLater(final Runnable r) {
        runLater(r, false);
    }

    private static void runLater(final Runnable r, boolean exiting) {
        if (!initialized.get()) {
            throw new IllegalStateException(&quot;Toolkit not initialized&quot;);
        }

        pendingRunnables.incrementAndGet();
        waitForStart();

        synchronized (runLaterLock) {
            if (!exiting &amp;&amp; toolkitExit.get()) {
                // Don't schedule a runnable after we have exited the toolkit
                pendingRunnables.decrementAndGet();
                return;
            }

            final AccessControlContext acc = AccessController.getContext();
            // Don't catch exceptions, they are handled by Toolkit.defer()
            Toolkit.getToolkit().defer(() -&gt; {
                try {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        r.run();
                        return null;
                    }, acc);
                } finally {
                    pendingRunnables.decrementAndGet();
                    checkIdle();
                }
            });
        }
    }

    public static void runAndWait(final Runnable r) {
        runAndWait(r, false);
    }

    private static void runAndWait(final Runnable r, boolean exiting) {
        if (isFxApplicationThread()) {
             try {
                 r.run();
             } catch (Throwable t) {
                 System.err.println(&quot;Exception in runnable&quot;);
                 t.printStackTrace();
             }
        } else {
            final CountDownLatch doneLatch = new CountDownLatch(1);
            runLater(() -&gt; {
                try {
                    r.run();
                } finally {
                    doneLatch.countDown();
                }
            }, exiting);

            if (!exiting &amp;&amp; toolkitExit.get()) {
                throw new IllegalStateException(&quot;Toolkit has exited&quot;);
            }

            try {
                doneLatch.await();
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void setImplicitExit(boolean implicitExit) {
        PlatformImpl.implicitExit = implicitExit;
        checkIdle();
    }

    public static boolean isImplicitExit() {
        return implicitExit;
    }

    public static void addListener(FinishListener l) {
        listenersRegistered.set(true);
        finishListeners.add(l);
    }

    public static void removeListener(FinishListener l) {
        finishListeners.remove(l);
        listenersRegistered.set(!finishListeners.isEmpty());
        if (!listenersRegistered.get()) {
            checkIdle();
        }
    }

    private static void notifyFinishListeners(boolean exitCalled) {
        // Notify listeners if any are registered, else exit directly
        if (listenersRegistered.get()) {
            for (FinishListener l : finishListeners) {
                if (exitCalled) {
                    l.exitCalled();
                } else {
                    l.idle(implicitExit);
                }
            }
        } else if (implicitExit || platformExit.get()) {
            tkExit();
        }
    }

    // Check for idle, meaning the last top-level window has been closed and
    // there are no pending Runnables waiting to be run.
    private static void checkIdle() {
        // If we aren't initialized yet, then this method is a no-op.
        if (!initialized.get()) {
            return;
        }

        if (!isFxApplicationThread()) {
            // Add a dummy runnable to the runLater queue, which will then call
            // checkIdle() on the FX application thread.
            runLater(() -&gt; {
            });
            return;
        }

        boolean doNotify = false;

        synchronized (PlatformImpl.class) {
            int numWin = numWindows.get();
            if (numWin &gt; 0) {
                firstWindowShown = true;
                lastWindowClosed = false;
                reallyIdle.set(false);
            } else if (numWin == 0 &amp;&amp; firstWindowShown) {
                lastWindowClosed = true;
            }

            // In case there is an event in process, allow for it to show
            // another window. If no new window is shown before all pending
            // runnables (including this one) are done and there is no running
            // nested loops, then we will shutdown.
            if (lastWindowClosed &amp;&amp; pendingRunnables.get() == 0
                    &amp;&amp; (toolkitExit.get() || !Toolkit.getToolkit().isNestedLoopRunning())) {
//                System.err.println(&quot;Last window closed and no pending runnables&quot;);
                if (reallyIdle.getAndSet(true)) {
//                    System.err.println(&quot;Really idle now&quot;);
                    doNotify = true;
                    lastWindowClosed = false;
                } else {
//                    System.err.println(&quot;Queuing up a dummy idle check runnable&quot;);
                    runLater(() -&gt; {
//                            System.err.println(&quot;Dummy runnable&quot;);
                    });
                }
            }
        }

        if (doNotify) {
            notifyFinishListeners(false);
        }
    }

    // package scope method for testing
    private static final CountDownLatch platformExitLatch = new CountDownLatch(1);
    static CountDownLatch test_getPlatformExitLatch() {
        return platformExitLatch;
    }

    public static void tkExit() {
        if (toolkitExit.getAndSet(true)) {
            return;
        }

        if (initialized.get()) {
            if (platformExit.get()) {
                PlatformImpl.runAndWait(() -&gt; {
                    if (Toolkit.getToolkit().isNestedLoopRunning()) {
                        Toolkit.getToolkit().exitAllNestedEventLoops();
                    } else {
                        allNestedLoopsExitedLatch.countDown();
                    }
                }, true);

                try {
                    allNestedLoopsExitedLatch.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(&quot;Could not exit all nested event loops&quot;);
                }
            }

            // Always call toolkit exit on FX app thread
//            System.err.println(&quot;PlatformImpl.tkExit: scheduling Toolkit.exit&quot;);
            PlatformImpl.runAndWait(() -&gt; {
//                System.err.println(&quot;PlatformImpl.tkExit: calling Toolkit.exit&quot;);
                Toolkit.getToolkit().exit();
            }, true);

            if (isThreadMerged) {
                removeFwEventQueue();
            }

            Toolkit.getToolkit().removeTkListener(toolkitListener);
            toolkitListener = null;
            platformExitLatch.countDown();
        }
    }

    public static BooleanProperty accessibilityActiveProperty() {
        return accessibilityActive;
    }

    public static void exit() {
        platformExit.set(true);
        notifyFinishListeners(true);
    }

    private static Boolean checkForClass(String classname) {
        try {
            Class.forName(classname, false, PlatformImpl.class.getClassLoader());
            return Boolean.TRUE;
        } catch (ClassNotFoundException cnfe) {
            return Boolean.FALSE;
        }
    }

    public static boolean isSupported(ConditionalFeature feature) {
        final boolean supported = isSupportedImpl(feature);
        if (supported &amp;&amp; (feature == ConditionalFeature.TRANSPARENT_WINDOW)) {
            // some features require the application to have the corresponding
            // permissions, if the application doesn't have them, the platform
            // will behave as if the feature wasn't supported
            final SecurityManager securityManager =
                    System.getSecurityManager();
            if (securityManager != null) {
                try {
                    securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);
                } catch (final SecurityException e) {
                    return false;
                }
            }

            return true;
        }

        return supported;
   }

    public static interface FinishListener {
        public void idle(boolean implicitExit);
        public void exitCalled();
    }

    /**
     * Set the platform user agent stylesheet to the default.
     */
    public static void setDefaultPlatformUserAgentStylesheet() {
        setPlatformUserAgentStylesheet(Application.STYLESHEET_MODENA);
    }

    private static boolean isModena = false;
    private static boolean isCaspian = false;

    /**
     * Current Platform User Agent Stylesheet is Modena.
     *
     * Note: Please think hard before using this as we really want to avoid special cases in the platform for specific
     * themes. This was added to allow tempory work arounds in the platform for bugs.
     *
     * @return true if using modena stylesheet
     */
    public static boolean isModena() {
        return isModena;
    }

    /**
     * Current Platform User Agent Stylesheet is Caspian.
     *
     * Note: Please think hard before using this as we really want to avoid special cases in the platform for specific
     * themes. This was added to allow tempory work arounds in the platform for bugs.
     *
     * @return true if using caspian stylesheet
     */
    public static boolean isCaspian() {
        return isCaspian;
    }

    /**
     * Set the platform user agent stylesheet to the given URL. This method has special handling for platform theme
     * name constants.
     */
    public static void setPlatformUserAgentStylesheet(final String stylesheetUrl) {
        if (isFxApplicationThread()) {
            _setPlatformUserAgentStylesheet(stylesheetUrl);
        } else {
            runLater(() -&gt; _setPlatformUserAgentStylesheet(stylesheetUrl));
        }
    }

    private static String accessibilityTheme;
    public static boolean setAccessibilityTheme(String platformTheme) {

        if (accessibilityTheme != null) {
            StyleManager.getInstance().removeUserAgentStylesheet(accessibilityTheme);
            accessibilityTheme = null;
        }

        _setAccessibilityTheme(platformTheme);

        if (accessibilityTheme != null) {
            StyleManager.getInstance().addUserAgentStylesheet(accessibilityTheme);
            return true;
        }
        return false;

    }

    private static void _setAccessibilityTheme(String platformTheme) {

        // check to see if there is an override to enable a high-contrast theme
        final String userTheme = AccessController.doPrivileged(
                (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;com.sun.javafx.highContrastTheme&quot;));

        if (isCaspian()) {
            if (platformTheme != null || userTheme != null) {
                // caspian has only one high contrast theme, use it regardless of the user or platform theme.
                accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/caspian/highcontrast.css&quot;;
            }
        } else if (isModena()) {
            // User-defined property takes precedence
            if (userTheme != null) {
                switch (userTheme.toUpperCase()) {
                    case &quot;BLACKONWHITE&quot;:
                        accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/blackOnWhite.css&quot;;
                        break;
                    case &quot;WHITEONBLACK&quot;:
                        accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/whiteOnBlack.css&quot;;
                        break;
                    case &quot;YELLOWONBLACK&quot;:
                        accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/yellowOnBlack.css&quot;;
                        break;
                    default:
                }
            } else {
                if (platformTheme != null) {
                    // The following names are Platform specific (Windows 7 and 8)
                    switch (platformTheme) {
                        case &quot;High Contrast White&quot;:
                            accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/blackOnWhite.css&quot;;
                            break;
                        case &quot;High Contrast Black&quot;:
                            accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/whiteOnBlack.css&quot;;
                            break;
                        case &quot;High Contrast #1&quot;:
                        case &quot;High Contrast #2&quot;: //TODO #2 should be green on black
                            accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/yellowOnBlack.css&quot;;
                            break;
                        default:
                    }
                }
            }
        }
    }

    private static void _setPlatformUserAgentStylesheet(String stylesheetUrl) {
        isModena = isCaspian = false;
        // check for command line override
        final String overrideStylesheetUrl = AccessController.doPrivileged(
                (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;javafx.userAgentStylesheetUrl&quot;));

        if (overrideStylesheetUrl != null) {
            stylesheetUrl = overrideStylesheetUrl;
        }

        final List&lt;String&gt; uaStylesheets = new ArrayList&lt;&gt;();

        // check for named theme constants for modena and caspian
        if (Application.STYLESHEET_CASPIAN.equalsIgnoreCase(stylesheetUrl)) {
            isCaspian = true;

            uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/caspian.css&quot;);

            if (isSupported(ConditionalFeature.INPUT_TOUCH)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/embedded.css&quot;);
                if (com.sun.javafx.util.Utils.isQVGAScreen()) {
                    uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/embedded-qvga.css&quot;);
                }
                if (PlatformUtil.isAndroid()) {
                    uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/android.css&quot;);
                }
            }

            if (isSupported(ConditionalFeature.TWO_LEVEL_FOCUS)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/two-level-focus.css&quot;);
            }

            if (isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/fxvk.css&quot;);
            }

            if (!isSupported(ConditionalFeature.TRANSPARENT_WINDOW)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/caspian-no-transparency.css&quot;);
            }

        } else if (Application.STYLESHEET_MODENA.equalsIgnoreCase(stylesheetUrl)) {
            isModena = true;

            uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/modena.css&quot;);

            if (isSupported(ConditionalFeature.INPUT_TOUCH)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/touch.css&quot;);
            }
            // when running on embedded add a extra stylesheet to tune performance of modena theme
            if (PlatformUtil.isEmbedded()) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/modena-embedded-performance.css&quot;);
            }
            if (PlatformUtil.isAndroid()) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/android.css&quot;);
            }

            if (isSupported(ConditionalFeature.TWO_LEVEL_FOCUS)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/two-level-focus.css&quot;);
            }

            if (isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/fxvk.css&quot;);
            }

            if (!isSupported(ConditionalFeature.TRANSPARENT_WINDOW)) {
                uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/modena-no-transparency.css&quot;);
            }

        } else {
            uaStylesheets.add(stylesheetUrl);
        }

        // Ensure that accessibility starts right
        _setAccessibilityTheme(Toolkit.getToolkit().getThemeName());
        if (accessibilityTheme != null) {
            uaStylesheets.add(accessibilityTheme);
        }

        AccessController.doPrivileged((PrivilegedAction) () -&gt; {
            StyleManager.getInstance().setUserAgentStylesheets(uaStylesheets);
            return null;
        });

    }

    public static void addNoTransparencyStylesheetToScene(final Scene scene) {
        if (PlatformImpl.isCaspian()) {
            AccessController.doPrivileged((PrivilegedAction) () -&gt; {
                StyleManager.getInstance().addUserAgentStylesheet(scene,
                        &quot;com/sun/javafx/scene/control/skin/caspian/caspian-no-transparency.css&quot;);
                return null;
            });
        } else if (PlatformImpl.isModena()) {
            AccessController.doPrivileged((PrivilegedAction) () -&gt; {
                StyleManager.getInstance().addUserAgentStylesheet(scene,
                        &quot;com/sun/javafx/scene/control/skin/modena/modena-no-transparency.css&quot;);
                return null;
            });
        }
    }

    private static boolean isSupportedImpl(ConditionalFeature feature) {
        switch (feature) {
            case GRAPHICS:
                if (isGraphicsSupported == null) {
                    isGraphicsSupported = checkForClass(&quot;javafx.stage.Stage&quot;);
                }
                return isGraphicsSupported;
            case CONTROLS:
                if (isControlsSupported == null) {
                    isControlsSupported = checkForClass(
                            &quot;javafx.scene.control.Control&quot;);
                }
                return isControlsSupported;
            case MEDIA:
                if (isMediaSupported == null) {
                    isMediaSupported = checkForClass(
                            &quot;javafx.scene.media.MediaView&quot;);
                    if (isMediaSupported &amp;&amp; PlatformUtil.isEmbedded()) {
                        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                            String s = System.getProperty(
                                    &quot;com.sun.javafx.experimental.embedded.media&quot;,
                                    &quot;false&quot;);
                            isMediaSupported = Boolean.valueOf(s);
                            return null;

                        });
                    }
                }
                return isMediaSupported;
            case WEB:
                if (isWebSupported == null) {
                    isWebSupported = checkForClass(&quot;javafx.scene.web.WebView&quot;);
                    if (isWebSupported &amp;&amp; PlatformUtil.isEmbedded()) {
                        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                            String s = System.getProperty(
                                    &quot;com.sun.javafx.experimental.embedded.web&quot;,
                                    &quot;false&quot;);
                            isWebSupported = Boolean.valueOf(s);
                            return null;

                        });
                    }
                }
                return isWebSupported;
            case SWT:
                if (isSWTSupported == null) {
                    isSWTSupported = checkForClass(&quot;javafx.embed.swt.FXCanvas&quot;);
                }
                return isSWTSupported;
            case SWING:
                if (isSwingSupported == null) {
                    isSwingSupported =
                        // check for JComponent first, it may not be present
                        checkForClass(&quot;javax.swing.JComponent&quot;) &amp;&amp;
                        checkForClass(&quot;javafx.embed.swing.JFXPanel&quot;);
                }
                return isSwingSupported;
            case FXML:
                if (isFXMLSupported == null) {
                    isFXMLSupported = checkForClass(&quot;javafx.fxml.FXMLLoader&quot;)
                            &amp;&amp; checkForClass(&quot;javax.xml.stream.XMLInputFactory&quot;);
                }
                return isFXMLSupported;
            case TWO_LEVEL_FOCUS:
                if (hasTwoLevelFocus == null) {
                    return Toolkit.getToolkit().isSupported(feature);
                }
                return hasTwoLevelFocus;
            case VIRTUAL_KEYBOARD:
                if (hasVirtualKeyboard == null) {
                    return Toolkit.getToolkit().isSupported(feature);
                }
                return hasVirtualKeyboard;
            case INPUT_TOUCH:
                if (hasTouch == null) {
                    return Toolkit.getToolkit().isSupported(feature);
                }
                return hasTouch;
            case INPUT_MULTITOUCH:
                if (hasMultiTouch == null) {
                    return Toolkit.getToolkit().isSupported(feature);
                }
                return hasMultiTouch;
            case INPUT_POINTER:
                if (hasPointer == null) {
                    return Toolkit.getToolkit().isSupported(feature);
                }
                return hasPointer;
            default:
                return Toolkit.getToolkit().isSupported(feature);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/Toolkit.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk;

import javafx.application.ConditionalFeature;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.geometry.Dimension2D;
import javafx.scene.Scene;
import javafx.scene.effect.BlurType;
import javafx.scene.image.Image;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.WritableImage;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputMethodRequests;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.paint.Color;
import javafx.scene.paint.ImagePattern;
import javafx.scene.paint.LinearGradient;
import javafx.scene.paint.Paint;
import javafx.scene.paint.RadialGradient;
import javafx.scene.paint.Stop;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.SVGPath;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;
import javafx.stage.FileChooser.ExtensionFilter;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import com.sun.glass.ui.CommonDialogs.FileChooserResult;
import com.sun.glass.ui.GlassRobot;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.beans.event.AbstractNotifyListener;
import com.sun.javafx.embed.HostInterface;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.runtime.VersionInfo;
import com.sun.javafx.runtime.async.AsyncOperation;
import com.sun.javafx.runtime.async.AsyncOperationListener;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.text.TextLayoutFactory;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.util.Utils;
import com.sun.scenario.DelayedRunnable;
import com.sun.scenario.animation.AbstractMasterTimer;
import com.sun.scenario.effect.AbstractShadow.ShadowMode;
import com.sun.scenario.effect.Color4f;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;


public abstract class Toolkit {
    private static String tk;
    private static Toolkit TOOLKIT;
    private static Thread fxUserThread = null;

    private static final String QUANTUM_TOOLKIT     = &quot;com.sun.javafx.tk.quantum.QuantumToolkit&quot;;
    private static final String DEFAULT_TOOLKIT     = QUANTUM_TOOLKIT;

    private static final Map gradientMap = new WeakHashMap();

    private static final boolean verbose = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.verbose&quot;));

    private static final String[] msLibNames = {
        &quot;api-ms-win-core-console-l1-1-0&quot;,
        &quot;api-ms-win-core-datetime-l1-1-0&quot;,
        &quot;api-ms-win-core-debug-l1-1-0&quot;,
        &quot;api-ms-win-core-errorhandling-l1-1-0&quot;,
        &quot;api-ms-win-core-file-l1-1-0&quot;,
        &quot;api-ms-win-core-file-l1-2-0&quot;,
        &quot;api-ms-win-core-file-l2-1-0&quot;,
        &quot;api-ms-win-core-handle-l1-1-0&quot;,
        &quot;api-ms-win-core-heap-l1-1-0&quot;,
        &quot;api-ms-win-core-interlocked-l1-1-0&quot;,
        &quot;api-ms-win-core-libraryloader-l1-1-0&quot;,
        &quot;api-ms-win-core-localization-l1-2-0&quot;,
        &quot;api-ms-win-core-memory-l1-1-0&quot;,
        &quot;api-ms-win-core-namedpipe-l1-1-0&quot;,
        &quot;api-ms-win-core-processenvironment-l1-1-0&quot;,
        &quot;api-ms-win-core-processthreads-l1-1-0&quot;,
        &quot;api-ms-win-core-processthreads-l1-1-1&quot;,
        &quot;api-ms-win-core-profile-l1-1-0&quot;,
        &quot;api-ms-win-core-rtlsupport-l1-1-0&quot;,
        &quot;api-ms-win-core-string-l1-1-0&quot;,
        &quot;api-ms-win-core-synch-l1-1-0&quot;,
        &quot;api-ms-win-core-synch-l1-2-0&quot;,
        &quot;api-ms-win-core-sysinfo-l1-1-0&quot;,
        &quot;api-ms-win-core-timezone-l1-1-0&quot;,
        &quot;api-ms-win-core-util-l1-1-0&quot;,
        &quot;api-ms-win-crt-conio-l1-1-0&quot;,
        &quot;api-ms-win-crt-convert-l1-1-0&quot;,
        &quot;api-ms-win-crt-environment-l1-1-0&quot;,
        &quot;api-ms-win-crt-filesystem-l1-1-0&quot;,
        &quot;api-ms-win-crt-heap-l1-1-0&quot;,
        &quot;api-ms-win-crt-locale-l1-1-0&quot;,
        &quot;api-ms-win-crt-math-l1-1-0&quot;,
        &quot;api-ms-win-crt-multibyte-l1-1-0&quot;,
        &quot;api-ms-win-crt-private-l1-1-0&quot;,
        &quot;api-ms-win-crt-process-l1-1-0&quot;,
        &quot;api-ms-win-crt-runtime-l1-1-0&quot;,
        &quot;api-ms-win-crt-stdio-l1-1-0&quot;,
        &quot;api-ms-win-crt-string-l1-1-0&quot;,
        &quot;api-ms-win-crt-time-l1-1-0&quot;,
        &quot;api-ms-win-crt-utility-l1-1-0&quot;,
        &quot;ucrtbase&quot;,

        // Finally load VS 2017 DLLs in the following order
        &quot;vcruntime140&quot;,
        &quot;msvcp140&quot;,
        &quot;concrt140&quot;
};

    private static String lookupToolkitClass(String name) {
        if (&quot;prism&quot;.equalsIgnoreCase(name)) {
            return QUANTUM_TOOLKIT;
        } else if (&quot;quantum&quot;.equalsIgnoreCase(name)) {
            return QUANTUM_TOOLKIT;
        }
        return name;
    }

    public static synchronized void loadMSWindowsLibraries() {
        for (String libName : msLibNames) {
            try {
                NativeLibLoader.loadLibrary(libName);
            } catch (Throwable t) {
                if (verbose) {
                    System.err.println(&quot;Error: failed to load &quot;
                            + libName + &quot;.dll : &quot; + t);
                }
            }
        }
    }

    private static String getDefaultToolkit() {
        if (PlatformUtil.isWindows()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isMac()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isLinux()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isIOS()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isAndroid()) {
           return DEFAULT_TOOLKIT;
        }

        throw new UnsupportedOperationException(System.getProperty(&quot;os.name&quot;) + &quot; is not supported&quot;);
    }

    public static synchronized Toolkit getToolkit() {
        if (TOOLKIT != null) {
            return TOOLKIT;
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            // Get the javafx.version and javafx.runtime.version from a preconstructed
            // java class, VersionInfo, created at build time.
            VersionInfo.setupSystemProperties();
            return null;
        });

        // This loading of msvcp140.dll and vcruntime140.dll (VS2017) is required on Windows platforms
        if (PlatformUtil.isWindows()) {
            loadMSWindowsLibraries();
        }

        boolean userSpecifiedToolkit = true;

        // Check a system property to see if there is a specific toolkit to use.
        // This is not a doPriviledged check so that applets cannot use this.
        String forcedToolkit = null;
        try {
            forcedToolkit = System.getProperty(&quot;javafx.toolkit&quot;);
        } catch (SecurityException ex) {}

        if (forcedToolkit == null) {
            forcedToolkit = tk;
        }
        if (forcedToolkit == null) {
            userSpecifiedToolkit = false;
            forcedToolkit = getDefaultToolkit();
        }

        if (forcedToolkit.indexOf('.') == -1) {
            // Turn a short name into a fully qualified classname
            forcedToolkit = lookupToolkitClass(forcedToolkit);
        }

        boolean printToolkit = verbose
                || (userSpecifiedToolkit &amp;&amp; !forcedToolkit.endsWith(&quot;StubToolkit&quot;));

        try {
            Class clz = null;

            try {
                // try our priveledged loader first
                final ClassLoader loader = Toolkit.class.getClassLoader();
                clz = Class.forName(forcedToolkit, false, loader);
            } catch (ClassNotFoundException e) {
                // fall back and try the application class loader
                final ClassLoader loader = Thread.currentThread().getContextClassLoader();
                clz = Class.forName(forcedToolkit, false, loader);
            }

            // Check that clz is a subclass of Toolkit
            if (!Toolkit.class.isAssignableFrom(clz)) {
                throw new IllegalArgumentException(&quot;Unrecognized FX Toolkit class: &quot;
                        + forcedToolkit);
            }

            TOOLKIT = (Toolkit)clz.newInstance();
            if (TOOLKIT.init()) {
                if (printToolkit) {
                    System.err.println(&quot;JavaFX: using &quot; + forcedToolkit);
                }
                return TOOLKIT;
            }
            TOOLKIT = null;
        } catch (Exception any) {
            TOOLKIT = null;
            any.printStackTrace();
        }

        throw new RuntimeException(&quot;No toolkit found&quot;);
    }

    protected static Thread getFxUserThread() {
        return fxUserThread;
    }

    protected static void setFxUserThread(Thread t) {
        if (fxUserThread != null) {
            throw new IllegalStateException(&quot;Error: FX User Thread already initialized&quot;);
        }

        fxUserThread = t;
    }

    public void checkFxUserThread() {
        // Throw exception if not on FX user thread
        if (!isFxUserThread()) {
            throw new IllegalStateException(&quot;Not on FX application thread; currentThread = &quot;
                    + Thread.currentThread().getName());
        }
    }

    // Toolkit can override this if needed
    public boolean isFxUserThread() {
        return Thread.currentThread() == fxUserThread;
    }

    protected Toolkit() {
    }

    public abstract boolean init();

    /**
     * Indicates whether or not a nested event loop can be started
     * from the current thread in the current state. Note that a nested
     * event loop is not allowed outside of an event handler.
     *
     * @return flag indicating whether a nested event loop can be started.
     */
    public abstract boolean canStartNestedEventLoop();

    /**
     * Enter a nested event loop and block until the corresponding
     * exitNestedEventLoop call is made.
     * The key passed into this method is used to
     * uniquely identify the matched enter/exit pair. This method creates a
     * new nested event loop and blocks until the corresponding
     * exitNestedEventLoop method is called with the same key.
     * The return value of this method will be the {@code rval}
     * object supplied to the exitNestedEventLoop method call that unblocks it.
     *
     * @param key the Object that identifies the nested event loop, which
     * must not be null
     *
     * @throws IllegalArgumentException if the specified key is associated
     * with a nested event loop that has not yet returned
     *
     * @throws NullPointerException if the key is null
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the FX Application thread
     *
     * @return the value passed into the corresponding call to exitEventLoop
     */
    public abstract Object enterNestedEventLoop(Object key);

    /**
     * Exit a nested event loop and unblock the caller of the
     * corresponding enterNestedEventLoop.
     * The key passed into this method is used to
     * uniquely identify the matched enter/exit pair. This method causes the
     * nested event loop that was previously created with the key to exit and
     * return control to the caller. If the specified nested event loop is not
     * the inner-most loop then it will not return until all other inner loops
     * also exit.
     *
     * @param key the Object that identifies the nested event loop, which
     * must not be null
     *
     * @param rval an Object that is returned to the caller of the
     * corresponding enterNestedEventLoop. This may be null.
     *
     * @throws IllegalArgumentException if the specified key is not associated
     * with an active nested event loop
     *
     * @throws NullPointerException if the key is null
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the FX Application thread
     */
    public abstract void exitNestedEventLoop(Object key, Object rval);

    public abstract void exitAllNestedEventLoops();

    public abstract boolean isNestedLoopRunning();

    public abstract TKStage createTKStage(Window peerWindow, boolean securityDialog, StageStyle stageStyle, boolean primary, Modality modality, TKStage owner, boolean rtl, AccessControlContext acc);

    public abstract TKStage createTKPopupStage(Window peerWindow, StageStyle popupStyle, TKStage owner, AccessControlContext acc);
    public abstract TKStage createTKEmbeddedStage(HostInterface host, AccessControlContext acc);

    /**
     * Creates an AppletWindow using the provided window pointer as the parent
     * window.
     *
     * @param parent the native parent which will contain the primary stage
     * window(s). Used on Windows/Linux platforms.
     *
     * @param serverName the name of CARemoteLayerServer which
     * will be used to register native layer. Used on Mac platform.
     */
    public abstract AppletWindow createAppletWindow(long parent, String serverName);

    /**
     * Perform cleanup in preparation for applet termination, including closing
     * the applet window.
     */
    public abstract void closeAppletWindow();

    private final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseListeners =
            new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
    private final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseListeners =
            new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
    private final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseListeners =
            new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
    private final Map&lt;TKListener,AccessControlContext&gt; toolkitListeners =
            new WeakHashMap&lt;TKListener,AccessControlContext&gt;();

    // The set of shutdown hooks is strongly held to avoid premature GC.
    private final Set&lt;Runnable&gt; shutdownHooks = new HashSet&lt;Runnable&gt;();

    private void runPulse(final TKPulseListener listener,
            final AccessControlContext acc) {

        if (acc == null) {
            throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
<A NAME="9"></A>            listener.pulse();
            return null;
        }, acc);
    <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#9',2,'match58-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public void firePulse() {
        // Stages need to be notified of pulses before scenes so the Stage can resized
        // and those changes propogated to scene before it gets its pulse to update

        // Copy of listener map
        final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseList =
                new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
        final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseList =
                new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
        final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseList =
                new</B></FONT> WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();

        synchronized (this) {
            stagePulseList.putAll(stagePulseListeners);
            scenePulseList.putAll(scenePulseListeners);
            postScenePulseList.putAll(postScenePulseListeners);
        }
        for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : stagePulseList.entrySet()) {
            runPulse(entry.getKey(), entry.getValue());
        }
        for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : scenePulseList.entrySet()) {
            runPulse(entry.getKey(), entry.getValue());
        }
        for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : postScenePulseList.entrySet()) {
            runPulse(entry.getKey(), entry.getValue());
        }

        if (lastTkPulseListener != null) {
            runPulse(lastTkPulseListener, lastTkPulseAcc);
        }
    }
    public void addStageTkPulseListener(TKPulseListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (this) {
            AccessControlContext acc = AccessController.getContext();
            stagePulseListeners.put(listener, acc);
        }
    }
    public void removeStageTkPulseListener(TKPulseListener listener) {
        synchronized (this) {
            stagePulseListeners.remove(listener);
        }
    }
    public void addSceneTkPulseListener(TKPulseListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (this) {
            AccessControlContext acc = AccessController.getContext();
            scenePulseListeners.put(listener, acc);
        }
    }
    public void removeSceneTkPulseListener(TKPulseListener listener) {
        synchronized (this) {
            scenePulseListeners.remove(listener);
        }
    }
    public void addPostSceneTkPulseListener(TKPulseListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (this) {
            AccessControlContext acc = AccessController.getContext();
            postScenePulseListeners.put(listener, acc);
        }
    }
    public void removePostSceneTkPulseListener(TKPulseListener listener) {
        synchronized (this) {
            postScenePulseListeners.remove(listener);
        }
    }

    public void addTkListener(TKListener listener) {
        if (listener == null) {
            return;
        }
        AccessControlContext acc = AccessController.getContext();
        toolkitListeners.put(listener, acc);
    }

    public void removeTkListener(TKListener listener) {
        toolkitListeners.remove(listener);
    }

    private TKPulseListener lastTkPulseListener = null;
    private AccessControlContext lastTkPulseAcc = null;
    public void setLastTkPulseListener(TKPulseListener listener) {
        lastTkPulseAcc = AccessController.getContext();
        lastTkPulseListener = listener;
    }

    public void addShutdownHook(Runnable hook) {
        if (hook == null) {
            return;
        }
        synchronized (shutdownHooks) {
            shutdownHooks.add(hook);
        }
    }

    public void removeShutdownHook(Runnable hook) {
        synchronized (shutdownHooks) {
            shutdownHooks.remove(hook);
        }
    }

    protected void notifyShutdownHooks() {
        List&lt;Runnable&gt; hooks;
        synchronized (shutdownHooks) {
            hooks = new ArrayList&lt;Runnable&gt;(shutdownHooks);
            shutdownHooks.clear();
        }

        for (Runnable hook : hooks) {
            hook.run();
        }
    }

    public void notifyWindowListeners(final List&lt;TKStage&gt; windows) {
        for (Map.Entry&lt;TKListener,AccessControlContext&gt; entry : toolkitListeners.entrySet()) {
            final TKListener listener = entry.getKey();
            final AccessControlContext acc = entry.getValue();
            if (acc == null) {
                throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
            }

            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                listener.changedTopLevelWindows(windows);
                return null;
            }, acc);
        }
    }

    public void notifyLastNestedLoopExited() {
        for (TKListener listener: toolkitListeners.keySet()) {
            listener.exitedLastNestedLoop();
        }
    }

    // notify the pulse timer code that we need the next pulse to happen
    // this flag is cleared each cycle so subsequent pulses must be requested
    public abstract void requestNextPulse();

    public abstract Future addRenderJob(RenderJob rj);

    public abstract ImageLoader loadImage(String url,
                                          double width, double height,
                                          boolean preserveRatio,
                                          boolean smooth);
    public abstract ImageLoader loadImage(InputStream stream,
                                          double width, double height,
                                          boolean preserveRatio,
                                          boolean smooth);
    public abstract AsyncOperation loadImageAsync(
                                          AsyncOperationListener&lt;? extends ImageLoader&gt; listener,
                                          String url,
                                          double width, double height,
                                          boolean preserveRatio,
                                          boolean smooth);

    /*
     * The loadPlatformImage method supports the following image types:
     *   - an object returned by the renderToImage method
     *   - an instance of com.sun.prism.Image (in case of prism)
     *   - an instance of an external image object, which can be a BufferedImage
     * If JavaFX Image had one more constructor Image(ImageLoader),
     * we could introduce a different method for external image loading support.
     */

    public abstract ImageLoader loadPlatformImage(Object platformImage);

    public abstract PlatformImage createPlatformImage(int w, int h);

    // Indicates the default state of smooth for ImageView and MediaView
    // Subclasses may override this to provide a platform-specific default
    public boolean getDefaultImageSmooth() { return true; }

    public abstract void startup(Runnable runnable);
    public abstract void defer(Runnable runnable);
    public void exit() {
        fxUserThread = null;
    }

    public abstract Map&lt;Object, Object&gt; getContextMap();
    public abstract int getRefreshRate();
    public abstract void setAnimationRunnable(DelayedRunnable animationRunnable);
    public abstract PerformanceTracker getPerformanceTracker();
    public abstract PerformanceTracker createPerformanceTracker();

    //to be used for testing only
    public abstract void waitFor(Task t);

    private Object checkSingleColor(List&lt;Stop&gt; stops) {
        if (stops.size() == 2) {
            Color c = stops.get(0).getColor();
            if (c.equals(stops.get(1).getColor())) {
                return Toolkit.getPaintAccessor().getPlatformPaint(c);
            }
        }
        return null;
    }

    private Object getPaint(LinearGradient paint) {
        Object p = gradientMap.get(paint);
        if (p != null) {
            return p;
        }
        p = checkSingleColor(paint.getStops());
        if (p == null) {
            p = createLinearGradientPaint(paint);
        }
        gradientMap.put(paint, p);
        return p;
    }

    private Object getPaint(RadialGradient paint) {
        Object p = gradientMap.get(paint);
        if (p != null) {
            return p;
        }
        p = checkSingleColor(paint.getStops());
        if (p == null) {
            p = createRadialGradientPaint(paint);
        }
        gradientMap.put(paint, p);
        return p;
    }

    public Object getPaint(Paint paint) {
        if (paint instanceof Color) {
            return createColorPaint((Color) paint);
        }

        if (paint instanceof LinearGradient) {
            return getPaint((LinearGradient) paint);
        }

        if (paint instanceof RadialGradient) {
            return getPaint((RadialGradient) paint);
        }

        if (paint instanceof ImagePattern) {
            return createImagePatternPaint((ImagePattern) paint);
        }

        return null;
    }

    protected static final double clampStopOffset(double offset) {
        return (offset &gt; 1.0) ? 1.0 :
               (offset &lt; 0.0) ? 0.0 : offset;
    }

    protected abstract Object createColorPaint(Color paint);
    protected abstract Object createLinearGradientPaint(LinearGradient paint);
    protected abstract Object createRadialGradientPaint(RadialGradient paint);
    protected abstract Object createImagePatternPaint(ImagePattern paint);

    public abstract void
        accumulateStrokeBounds(com.sun.javafx.geom.Shape shape,
                               float bbox[],
                               StrokeType type,
                               double strokewidth,
                               StrokeLineCap cap,
                               StrokeLineJoin join,
                               float miterLimit,
                               BaseTransform tx);

    public abstract boolean
        strokeContains(com.sun.javafx.geom.Shape shape,
                       double x, double y,
                       StrokeType type,
                       double strokewidth,
                       StrokeLineCap cap,
                       StrokeLineJoin join,
                       float miterLimit);

    public abstract com.sun.javafx.geom.Shape
        createStrokedShape(com.sun.javafx.geom.Shape shape,
                           StrokeType type,
                           double strokewidth,
                           StrokeLineCap cap,
                           StrokeLineJoin join,
                           float miterLimit,
                           float[] dashArray,
                           float dashOffset);

    public abstract int getKeyCodeForChar(String character);
    public abstract Dimension2D getBestCursorSize(int preferredWidth, int preferredHeight);
    public abstract int getMaximumCursorColors();
    public abstract PathElement[] convertShapeToFXPath(Object shape);

    public abstract Filterable toFilterable(Image img);
    public abstract FilterContext getFilterContext(Object config);

    public abstract boolean isForwardTraversalKey(KeyEvent e);
    public abstract boolean isBackwardTraversalKey(KeyEvent e);

    public abstract AbstractMasterTimer getMasterTimer();

    public abstract FontLoader getFontLoader();
    public abstract TextLayoutFactory getTextLayoutFactory();

    public abstract Object createSVGPathObject(SVGPath svgpath);
    public abstract Path2D createSVGPath2D(SVGPath svgpath);

    /**
     * Tests whether the pixel on the given coordinates in the given image
     * is non-empty (not fully transparent). Return value is not defined
     * for pixels out of the image bounds.
     */
    public abstract boolean imageContains(Object image, float x, float y);

    public abstract TKClipboard getSystemClipboard();

    public TKClipboard createLocalClipboard() {
        return new LocalClipboard();
    }

    public abstract TKSystemMenu getSystemMenu();

    public abstract TKClipboard getNamedClipboard(String name);

    public boolean isSupported(ConditionalFeature feature) { return false; }

    public boolean isMSAASupported() { return false; }

    public abstract ScreenConfigurationAccessor setScreenConfigurationListener(TKScreenConfigurationListener listener);

    public abstract Object getPrimaryScreen();

    public abstract List&lt;?&gt; getScreens();

    public abstract ScreenConfigurationAccessor getScreenConfigurationAccessor();

    public abstract void registerDragGestureListener(TKScene s, Set&lt;TransferMode&gt; tm, TKDragGestureListener l);

    /**
     * This function is called when a drag originates within a JavaFX application.
     * This means that drags that originate in other applications / from the OS
     * do not call this function.
     * The argument o represents an object used to identify a scene on which
     * the drag has started.
     */
    public abstract void startDrag(TKScene scene, Set&lt;TransferMode&gt; tm, TKDragSourceListener l, Dragboard dragboard);

    // template function which can be implemented by toolkit impls such that they
    // can be informed when a drag and drop operation has completed. This allows
    // for any cleanup that may need to be done.
    public void stopDrag(Dragboard dragboard) {
        // no-op
    }

    public abstract void enableDrop(TKScene s, TKDropTargetListener l);

    public interface Task {
        boolean isFinished();
    }

    public Color4f toColor4f(Color color) {
        return new Color4f((float)color.getRed(), (float)color.getGreen(), (float)color.getBlue(), (float)color.getOpacity());
    }


    public ShadowMode toShadowMode(BlurType blurType) {
        switch (blurType) {
            case ONE_PASS_BOX:
                return ShadowMode.ONE_PASS_BOX;
            case TWO_PASS_BOX:
                return ShadowMode.TWO_PASS_BOX;
            case THREE_PASS_BOX:
                return ShadowMode.THREE_PASS_BOX;
            default:
                return ShadowMode.GAUSSIAN;
        }
    }

    public abstract void installInputMethodRequests(TKScene scene, InputMethodRequests requests);

    /*
     * ImageRenderingContext holds the many parameters passed to
     * the renderToImage method.
     * The use of the parameters is specified by the renderToImage
     * method.
     * @see #renderToImage
     */
    public static class ImageRenderingContext {
        // Node to be rendered
        public NGNode root;

        // Viewport for rendering
        public int x;
        public int y;
        public int width;
        public int height;

        // Initial transform for root node
        public BaseTransform transform;

        // Rendering parameters either from Scene or SnapShotParams
        public boolean depthBuffer;
        public Object platformPaint;
        public NGCamera camera;
        public NGLightBase[] lights;

        // PlatformImage into which to render or null
        public Object platformImage;
    }

    /*
     * This method renders a PG-graph to a platform image object.
     * The returned object can be turned into a useable
     * scene graph image using the appropriate factor of the
     * Image class.
     * The scale specified in the params is used to scale the
     * entire rendering before any transforms in the nodes are
     * applied.
     * The width and height specified in the params represent
     * the user space dimensions to be rendered.  The returned
     * image will be large enough to hold these dimensions
     * scaled by the scale parameter.
     * The depthBuffer specified in the params is used to determine
     * with or without depthBuffer rendering should be performed.
     * The root node is the root of a tree of toolkit-specific
     * scene graph peer nodes to be rendered and should have
     * been previously created by this toolkit.
     * The platformPaint specified in the params must be
     * generated by the appropriate Toolkit.createPaint method
     * and is used to fill the background of the image before
     * rendering the scene graph.
     * The platformImage specified in the params may be non-null
     * and should be a previous return value from this method.
     * If it is non-null then it may be reused as the return value
     * of this method if it is still valid and large enough to
     * hold the requested size.
     *
     * @param context a ImageRenderingContext instance specifying
     *               the various rendering parameters
     * @return a platform specific image object
     * @see Toolkit.getImageAccessor().fromPlatformImage
     */

    public abstract Object renderToImage(ImageRenderingContext context);

    /**
     * Returns the key code for the key which is commonly used on the
     * corresponding platform as a modifier key in shortcuts. For example
     * it is {@code KeyCode.CONTROL} on Windows (Ctrl + C, Ctrl + V ...) and
     * {@code KeyCode.META} on MacOS (Cmd + C, Cmd + V ...).
     *
     * @return the key code for shortcut modifier key
     */
    public KeyCode getPlatformShortcutKey() {
        return PlatformUtil.isMac() ? KeyCode.META : KeyCode.CONTROL;
    }

    public abstract FileChooserResult showFileChooser(
            TKStage ownerWindow,
            String title,
            File initialDirectory,
            String initialFileName,
            FileChooserType fileChooserType,
            List&lt;ExtensionFilter&gt; extensionFilters,
            ExtensionFilter selectedFilter);

    public abstract File showDirectoryChooser(
            TKStage ownerWindow,
            String title,
            File initialDirectory);

    /*
     * Methods for obtaining &quot;double-click&quot; speed value.
     */
    public abstract long getMultiClickTime();
    public abstract int getMultiClickMaxX();
    public abstract int getMultiClickMaxY();

    private CountDownLatch pauseScenesLatch = null;

    public interface WritableImageAccessor {
        public void loadTkImage(WritableImage wimg, Object loader);
        public Object getTkImageLoader(WritableImage wimg);
    }

    private static WritableImageAccessor writableImageAccessor = null;

    public static void setWritableImageAccessor(WritableImageAccessor accessor) {
        writableImageAccessor = accessor;
    }

    public static WritableImageAccessor getWritableImageAccessor() {
        return writableImageAccessor;
    }

    public interface PaintAccessor {
        public boolean isMutable(Paint paint);
        public Object getPlatformPaint(Paint paint);
        public void addListener(Paint paint, AbstractNotifyListener platformChangeListener);
        public void removeListener(Paint paint, AbstractNotifyListener platformChangeListener);
    }

    private static PaintAccessor paintAccessor = null;

    public static void setPaintAccessor(PaintAccessor accessor) {
        paintAccessor = accessor;
    }

    public static PaintAccessor getPaintAccessor() {
        return paintAccessor;
    }

    public interface ImageAccessor {
        public boolean isAnimation(Image image);
        public ReadOnlyObjectProperty&lt;PlatformImage&gt;getImageProperty(Image image);
        public int[] getPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
        public int[] getNonPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
        public Object getPlatformImage(Image image);
        public Image fromPlatformImage(Object image);
    }

    private static ImageAccessor imageAccessor;

    static {
        // Need to ensure that the Image class is loaded since Toolkit class
        // is the provider of getImageAccessor method and sets the accessor.
        Utils.forceInit(Image.class);
    }

    public static void setImageAccessor(ImageAccessor accessor) {
        imageAccessor = accessor;
    }

    public static ImageAccessor getImageAccessor() {
        return imageAccessor;
    }

    public String getThemeName() {
        return null;
    }

    public abstract GlassRobot createRobot();
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/OverlayWarning.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import javafx.animation.Animation.Status;
import javafx.animation.FadeTransition;
import javafx.animation.PauseTransition;
import javafx.animation.SequentialTransition;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Rectangle2D;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.util.Duration;

public class OverlayWarning extends Group {
    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        OverlayWarningHelper.setOverlayWarningAccessor(
                new OverlayWarningHelper.OverlayWarningAccessor() {
            @Override
            public void doUpdatePeer(Node node) {
                ((OverlayWarning) node).doUpdatePeer();
            }

            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                ((OverlayWarning) node).doMarkDirty(dirtyBit);
            }
        });
    }

    private static final float  PAD      = 40f;
    private static final float  RECTW    = 600f;
    private static final float  RECTH    = 100f;
    private static final float  ARC      = 20f;
    private static final int    FONTSIZE = 24;

    private ViewScene               view;
    private SequentialTransition    overlayTransition;
    private boolean                 warningTransition;

    {
        // To initialize the class helper at the begining each constructor of this class
        OverlayWarningHelper.initHelper(this);
    }

    public OverlayWarning(final ViewScene vs) {
        view = vs;

        createOverlayGroup();

        PauseTransition pause = new PauseTransition(Duration.millis(4000));
        FadeTransition fade = new FadeTransition(Duration.millis(1000), this);
        fade.setFromValue(1);
        fade.setToValue(0);

        overlayTransition = new SequentialTransition();
        overlayTransition.getChildren().add(pause);
        overlayTransition.getChildren().add(fade);
        overlayTransition.setOnFinished(event -&gt; {
            warningTransition = false;
            view.getWindowStage().setWarning(null);
        });
    }

    protected ViewScene getView() {
        return view;
    }

    protected final void setView(ViewScene vs) {
        if (view != null) {
            view.getWindowStage().setWarning(null);
        }

        view = vs;
        view.entireSceneNeedsRepaint();
   }

    protected void warn(String msg) {
        text.setText(msg);

        warningTransition = true;
        overlayTransition.play();
    }

    protected void cancel() {
        if (overlayTransition != null &amp;&amp;
            overlayTransition.getStatus() == Status.RUNNING) {
            overlayTransition.stop();
            warningTransition = false;
        }
        view.getWindowStage().setWarning(null);
    }

    protected boolean inWarningTransition() {
        return warningTransition;
    }

<A NAME="3"></A>    private Text text = new Text();
    private Rectangle background;

    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#3',2,'match58-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private void createOverlayGroup() {
        final Font font = new Font(Font.getDefault().getFamily(), FONTSIZE);
        final Rectangle2D screenBounds = new Rectangle2D(0, 0,
                view.getSceneState().getScreenWidth(),
                view.getSceneState().getScreenHeight());

        String TEXT_CSS =</B></FONT>
            &quot;-fx-effect: dropshadow(two-pass-box, rgba(0,0,0,0.75), 3, 0.0, 0, 2);&quot;;
        text.setStroke(Color.WHITE);
        text.setFill(Color.WHITE);
        text.setFont(font);
        text.setWrappingWidth(RECTW - PAD - PAD);
        text.setStyle(TEXT_CSS);
        text.setTextAlignment(TextAlignment.CENTER);

        background = createBackground(text, screenBounds);

        getChildren().add(background);
        getChildren().add(text);
    }

    private Rectangle createBackground(Text text, Rectangle2D screen) {
        Rectangle rectangle = new Rectangle();
        double textW = text.getLayoutBounds().getWidth();
        double textH = text.getLayoutBounds().getHeight();
        double rectX = (screen.getWidth() - RECTW) / 2.0;
        double rectY = (screen.getHeight() / 2.0);

        rectangle.setWidth(RECTW);
        rectangle.setHeight(RECTH);
        rectangle.setX(rectX);
        rectangle.setY(rectY - RECTH);
        rectangle.setArcWidth(ARC);
        rectangle.setArcHeight(ARC);
        rectangle.setFill(Color.gray(0.0, 0.6));

        text.setX(rectX + ((RECTW - textW) / 2.0));
        text.setY(rectY - (RECTH  / 2.0) + ((textH - text.getBaselineOffset()) / 2.0));

        return rectangle;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        NodeHelper.updatePeer(text);
        NodeHelper.updatePeer(background);
    }

    @Override
    protected void updateBounds() {
        super.updateBounds();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        view.synchroniseOverlayWarning();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/marlin/TransformingPathConsumer2D.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.marlin;

import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathConsumer2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.marlin.Helpers.IndexStack;
import com.sun.marlin.Helpers.PolyStack;
import java.util.Arrays;

public final class TransformingPathConsumer2D {

    // higher uncertainty in float variant for huge shapes &gt; 10^7
    static final float CLIP_RECT_PADDING = 1.0f;

    private final RendererContext rdrCtx;

    // recycled ClosedPathDetector instance from detectClosedPath()
    private final ClosedPathDetector   cpDetector;

    // recycled PathClipFilter instance from pathClipper()
    private final PathClipFilter       pathClipper;

    // recycled PathConsumer2D instance from wrapPath2D()
    private final Path2DWrapper        wp_Path2DWrapper        = new Path2DWrapper();

    // recycled PathConsumer2D instances from deltaTransformConsumer()
    private final DeltaScaleFilter     dt_DeltaScaleFilter     = new DeltaScaleFilter();
    private final DeltaTransformFilter dt_DeltaTransformFilter = new DeltaTransformFilter();

    // recycled PathConsumer2D instances from inverseDeltaTransformConsumer()
    private final DeltaScaleFilter     iv_DeltaScaleFilter     = new DeltaScaleFilter();
    private final DeltaTransformFilter iv_DeltaTransformFilter = new DeltaTransformFilter();

    // recycled PathTracer instances from tracer...() methods
    private final PathTracer tracerInput      = new PathTracer(&quot;[Input]&quot;);
    private final PathTracer tracerCPDetector = new PathTracer(&quot;ClosedPathDetector&quot;);
    private final PathTracer tracerFiller     = new PathTracer(&quot;Filler&quot;);
    private final PathTracer tracerStroker    = new PathTracer(&quot;Stroker&quot;);
    private final PathTracer tracerDasher     = new PathTracer(&quot;Dasher&quot;);

    TransformingPathConsumer2D(final RendererContext rdrCtx) {
        // used by RendererContext
        this.rdrCtx = rdrCtx;
        this.cpDetector = new ClosedPathDetector(rdrCtx);
        this.pathClipper = new PathClipFilter(rdrCtx);
    }

    public PathConsumer2D wrapPath2D(Path2D p2d) {
        return wp_Path2DWrapper.init(p2d);
    }

    public PathConsumer2D traceInput(PathConsumer2D out) {
        return tracerInput.init(out);
    }

    public PathConsumer2D traceClosedPathDetector(PathConsumer2D out) {
        return tracerCPDetector.init(out);
    }

    public PathConsumer2D traceFiller(PathConsumer2D out) {
        return tracerFiller.init(out);
    }

    public PathConsumer2D traceStroker(PathConsumer2D out) {
        return tracerStroker.init(out);
    }

    public PathConsumer2D traceDasher(PathConsumer2D out) {
        return tracerDasher.init(out);
    }

    public PathConsumer2D detectClosedPath(PathConsumer2D out) {
        return cpDetector.init(out);
    }

    public PathConsumer2D pathClipper(PathConsumer2D out) {
        return pathClipper.init(out);
    }

    public PathConsumer2D deltaTransformConsumer(PathConsumer2D out,
                                                 BaseTransform at)
    {
        if (at == null) {
            return out;
        }
        final float mxx = (float) at.getMxx();
        final float mxy = (float) at.getMxy();
        final float myx = (float) at.getMyx();
        final float myy = (float) at.getMyy();

        if (mxy == 0.0f &amp;&amp; myx == 0.0f) {
            if (mxx == 1.0f &amp;&amp; myy == 1.0f) {
                return out;
            } else {
                // Scale only
                if (rdrCtx.doClip) {
                    // adjust clip rectangle (ymin, ymax, xmin, xmax):
                    rdrCtx.clipInvScale = adjustClipScale(rdrCtx.clipRect,
                        mxx, myy);
                }
                return dt_DeltaScaleFilter.init(out, mxx, myy);
            }
        } else {
            if (rdrCtx.doClip) {
                // adjust clip rectangle (ymin, ymax, xmin, xmax):
                rdrCtx.clipInvScale = adjustClipInverseDelta(rdrCtx.clipRect,
                    mxx, mxy, myx, myy);
            }
            return dt_DeltaTransformFilter.init(out, mxx, mxy, myx, myy);
        }
    }

    private static float adjustClipScale(final float[] clipRect,
                                         final float mxx, final float myy)
    {
        // Adjust the clipping rectangle (iv_DeltaScaleFilter):
        final float scaleY = 1.0f / myy;
        clipRect[0] *= scaleY;
        clipRect[1] *= scaleY;

        if (clipRect[1] &lt; clipRect[0]) {
            float tmp = clipRect[0];
            clipRect[0] = clipRect[1];
            clipRect[1] = tmp;
        }

        final float scaleX = 1.0f / mxx;
        clipRect[2] *= scaleX;
        clipRect[3] *= scaleX;

        if (clipRect[3] &lt; clipRect[2]) {
            float tmp = clipRect[2];
            clipRect[2] = clipRect[3];
            clipRect[3] = tmp;
        }

        if (MarlinConst.DO_LOG_CLIP) {
                MarlinUtils.logInfo(&quot;clipRect (ClipScale): &quot;
                                    + Arrays.toString(clipRect));
        }
        return 0.5f * (Math.abs(scaleX) + Math.abs(scaleY));
    }

    private static float adjustClipInverseDelta(final float[] clipRect,
                                                final float mxx, final float mxy,
                                                final float myx, final float myy)
    {
        // Adjust the clipping rectangle (iv_DeltaTransformFilter):
        final float det = mxx * myy - mxy * myx;
        final float imxx =  myy / det;
        final float imxy = -mxy / det;
        final float imyx = -myx / det;
        final float imyy =  mxx / det;

        float xmin, xmax, ymin, ymax;
        float x, y;
        // xmin, ymin:
        x = clipRect[2] * imxx + clipRect[0] * imxy;
        y = clipRect[2] * imyx + clipRect[0] * imyy;

        xmin = xmax = x;
        ymin = ymax = y;

        // xmax, ymin:
        x = clipRect[3] * imxx + clipRect[0] * imxy;
        y = clipRect[3] * imyx + clipRect[0] * imyy;

        if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
        if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }

        // xmin, ymax:
        x = clipRect[2] * imxx + clipRect[1] * imxy;
        y = clipRect[2] * imyx + clipRect[1] * imyy;

        if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
        if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }

        // xmax, ymax:
        x = clipRect[3] * imxx + clipRect[1] * imxy;
        y = clipRect[3] * imyx + clipRect[1] * imyy;

        if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
        if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }

        clipRect[0] = ymin;
        clipRect[1] = ymax;
        clipRect[2] = xmin;
        clipRect[3] = xmax;

        if (MarlinConst.DO_LOG_CLIP) {
                MarlinUtils.logInfo(&quot;clipRect (ClipInverseDelta): &quot;
                                    + Arrays.toString(clipRect));
        }

        final float scaleX = (float) Math.sqrt(imxx * imxx + imxy * imxy);
        final float scaleY = (float) Math.sqrt(imyx * imyx + imyy * imyy);

        return 0.5f * (scaleX + scaleY);
    }

    public PathConsumer2D inverseDeltaTransformConsumer(PathConsumer2D out,
                                                        BaseTransform at)
    {
        if (at == null) {
            return out;
        }
        float mxx = (float) at.getMxx();
        float mxy = (float) at.getMxy();
        float myx = (float) at.getMyx();
        float myy = (float) at.getMyy();

        if (mxy == 0.0f &amp;&amp; myx == 0.0f) {
            if (mxx == 1.0f &amp;&amp; myy == 1.0f) {
                return out;
            } else {
                return iv_DeltaScaleFilter.init(out, 1.0f / mxx, 1.0f / myy);
            }
        } else {
            final float det = mxx * myy - mxy * myx;
            return iv_DeltaTransformFilter.init(out,
                                                myy / det,
                                               -mxy / det,
                                               -myx / det,
                                                mxx / det);
        }
    }

    static final class DeltaScaleFilter implements PathConsumer2D {
        private PathConsumer2D out;
        private float sx, sy;

        DeltaScaleFilter() {}

        DeltaScaleFilter init(PathConsumer2D out,
                              float mxx, float myy)
        {
            this.out = out;
            sx = mxx;
            sy = myy;
            return this; // fluent API
        }

        @Override
        public void moveTo(float x0, float y0) {
            out.moveTo(x0 * sx, y0 * sy);
        }

        @Override
        public void lineTo(float x1, float y1) {
            out.lineTo(x1 * sx, y1 * sy);
        }

        @Override
        public void quadTo(float x1, float y1,
                           float x2, float y2)
        {
            out.quadTo(x1 * sx, y1 * sy,
                       x2 * sx, y2 * sy);
        }

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            out.curveTo(x1 * sx, y1 * sy,
                        x2 * sx, y2 * sy,
                        x3 * sx, y3 * sy);
        }

        @Override
        public void closePath() {
            out.closePath();
        }

        @Override
        public void pathDone() {
            out.pathDone();
        }
    }

    static final class DeltaTransformFilter implements PathConsumer2D {
        private PathConsumer2D out;
        private float mxx, mxy, myx, myy;

        DeltaTransformFilter() {}

        DeltaTransformFilter init(PathConsumer2D out,
                                  float mxx, float mxy,
                                  float myx, float myy)
        {
            this.out = out;
            this.mxx = mxx;
            this.mxy = mxy;
            this.myx = myx;
            this.myy = myy;
            return this; // fluent API
        }

        @Override
        public void moveTo(float x0, float y0) {
            out.moveTo(x0 * mxx + y0 * mxy,
                       x0 * myx + y0 * myy);
        }

        @Override
        public void lineTo(float x1, float y1) {
            out.lineTo(x1 * mxx + y1 * mxy,
                       x1 * myx + y1 * myy);
        }

        @Override
        public void quadTo(float x1, float y1,
                           float x2, float y2)
        {
            out.quadTo(x1 * mxx + y1 * mxy,
                       x1 * myx + y1 * myy,
                       x2 * mxx + y2 * mxy,
                       x2 * myx + y2 * myy);
        }

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            out.curveTo(x1 * mxx + y1 * mxy,
                        x1 * myx + y1 * myy,
                        x2 * mxx + y2 * mxy,
                        x2 * myx + y2 * myy,
                        x3 * mxx + y3 * mxy,
                        x3 * myx + y3 * myy);
        }

        @Override
        public void closePath() {
            out.closePath();
        }

        @Override
        public void pathDone() {
            out.pathDone();
        }
    }

    static final class Path2DWrapper implements PathConsumer2D {
        private Path2D p2d;

        Path2DWrapper() {}

        Path2DWrapper init(Path2D p2d) {
            this.p2d = p2d;
            return this;
        }

        @Override
        public void moveTo(float x0, float y0) {
            p2d.moveTo(x0, y0);
        }

        @Override
        public void lineTo(float x1, float y1) {
            p2d.lineTo(x1, y1);
        }

        @Override
        public void closePath() {
            p2d.closePath();
        }

        @Override
        public void pathDone() {}

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            p2d.curveTo(x1, y1, x2, y2, x3, y3);
        }

        @Override
        public void quadTo(float x1, float y1, float x2, float y2) {
            p2d.quadTo(x1, y1, x2, y2);
        }
    }

    static final class ClosedPathDetector implements PathConsumer2D {

        private final RendererContext rdrCtx;
        private final PolyStack stack;

        private PathConsumer2D out;

        ClosedPathDetector(final RendererContext rdrCtx) {
            this.rdrCtx = rdrCtx;
            this.stack = (rdrCtx.stats != null) ?
                new PolyStack(rdrCtx,
                        rdrCtx.stats.stat_cpd_polystack_types,
                        rdrCtx.stats.stat_cpd_polystack_curves,
                        rdrCtx.stats.hist_cpd_polystack_curves,
                        rdrCtx.stats.stat_array_cpd_polystack_curves,
                        rdrCtx.stats.stat_array_cpd_polystack_types)
                : new PolyStack(rdrCtx);
        }

        ClosedPathDetector init(PathConsumer2D out) {
            this.out = out;
            return this; // fluent API
        }

        /**
         * Disposes this instance:
         * clean up before reusing this instance
         */
        void dispose() {
            stack.dispose();
        }

        @Override
        public void pathDone() {
            // previous path is not closed:
            finish(false);
            out.pathDone();

            // TODO: fix possible leak if exception happened
            // Dispose this instance:
            dispose();
        }

        @Override
        public void closePath() {
            // path is closed
            finish(true);
            out.closePath();
        }

        @Override
        public void moveTo(float x0, float y0) {
            // previous path is not closed:
            finish(false);
            out.moveTo(x0, y0);
        }

        private void finish(final boolean closed) {
            rdrCtx.closedPath = closed;
            stack.pullAll(out);
        }

        @Override
        public void lineTo(float x1, float y1) {
            stack.pushLine(x1, y1);
        }

        @Override
        public void curveTo(float x3, float y3,
                            float x2, float y2,
                            float x1, float y1)
        {
            stack.pushCubic(x1, y1, x2, y2, x3, y3);
        }

        @Override
        public void quadTo(float x2, float y2, float x1, float y1) {
            stack.pushQuad(x1, y1, x2, y2);
        }
    }

    static final class PathClipFilter implements PathConsumer2D {

        private PathConsumer2D out;

        // Bounds of the drawing region, at pixel precision.
        private final float[] clipRect;

        private final float[] corners = new float[8];
        private boolean init_corners = false;

        private final IndexStack stack;

        // the current outcode of the current sub path
        private int cOutCode = 0;

        // the cumulated (and) outcode of the complete path
        private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;

        private boolean outside = false;

        // The current point (TODO stupid repeated info)
        private float cx0, cy0;

        // The current point OUTSIDE
        private float cox0, coy0;

        private boolean subdivide = MarlinConst.DO_CLIP_SUBDIVIDER;
        private final CurveClipSplitter curveSplitter;

        PathClipFilter(final RendererContext rdrCtx) {
            this.clipRect = rdrCtx.clipRect;
            this.curveSplitter = rdrCtx.curveClipSplitter;

            this.stack = (rdrCtx.stats != null) ?
                new IndexStack(rdrCtx,
                        rdrCtx.stats.stat_pcf_idxstack_indices,
                        rdrCtx.stats.hist_pcf_idxstack_indices,
                        rdrCtx.stats.stat_array_pcf_idxstack_indices)
                : new IndexStack(rdrCtx);
        }

        PathClipFilter init(final PathConsumer2D out) {
            this.out = out;

            if (MarlinConst.DO_CLIP_SUBDIVIDER) {
                // adjust padded clip rectangle:
                curveSplitter.init();
            }

            this.init_corners = true;
            this.gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;

            return this; // fluent API
        }

        /**
         * Disposes this instance:
         * clean up before reusing this instance
         */
        void dispose() {
            stack.dispose();
        }

        private void finishPath() {
            if (outside) {
                // criteria: inside or totally outside ?
                if (gOutCode == 0) {
                    finish();
                } else {
                    this.outside = false;
                    stack.reset();
                }
            }
        }

        private void finish() {
            this.outside = false;

            if (!stack.isEmpty()) {
                if (init_corners) {
                    init_corners = false;

                    final float[] _corners = corners;
                    final float[] _clipRect = clipRect;
                    // Top Left (0):
                    _corners[0] = _clipRect[2];
                    _corners[1] = _clipRect[0];
                    // Bottom Left (1):
                    _corners[2] = _clipRect[2];
                    _corners[3] = _clipRect[1];
                    // Top right (2):
                    _corners[4] = _clipRect[3];
                    _corners[5] = _clipRect[0];
                    // Bottom Right (3):
                    _corners[6] = _clipRect[3];
                    _corners[7] = _clipRect[1];
                }
                stack.pullAll(corners, out);
            }
            out.lineTo(cox0, coy0);
            this.cx0 = cox0;
            this.cy0 = coy0;
        }

        @Override
        public void pathDone() {
            finishPath();

            out.pathDone();

            // TODO: fix possible leak if exception happened
            // Dispose this instance:
            dispose();
        }

        @Override
        public void closePath() {
            finishPath();

            out.closePath();
        }

        @Override
        public void moveTo(final float x0, final float y0) {
            finishPath();

            this.cOutCode = Helpers.outcode(x0, y0, clipRect);
            this.outside = false;
            out.moveTo(x0, y0);
            this.cx0 = x0;
            this.cy0 = y0;
        }

        @Override
        public void lineTo(final float xe, final float ye) {
            final int outcode0 = this.cOutCode;
            final int outcode1 = Helpers.outcode(xe, ye, clipRect);

            // Should clip
            final int orCode = (outcode0 | outcode1);
            if (orCode != 0) {
                final int sideCode = (outcode0 &amp; outcode1);

                // basic rejection criteria:
                if (sideCode == 0) {
                    // ovelap clip:
                    if (subdivide) {
                        // avoid reentrance
                        subdivide = false;
                        boolean ret;
                        // subdivide curve =&gt; callback with subdivided parts:
                        if (outside) {
                            ret = curveSplitter.splitLine(cox0, coy0, xe, ye,
                                                          orCode, this);
                        } else {
                            ret = curveSplitter.splitLine(cx0, cy0, xe, ye,
                                                          orCode, this);
                        }
                        // reentrance is done:
                        subdivide = true;
                        if (ret) {
                            return;
                        }
                    }
                    // already subdivided so render it
                } else {
                    this.cOutCode = outcode1;
                    this.gOutCode &amp;= sideCode;
                    // keep last point coordinate before entering the clip again:
                    this.outside = true;
                    this.cox0 = xe;
                    this.coy0 = ye;

                    clip(sideCode, outcode0, outcode1);
                    return;
                }
            }

            this.cOutCode = outcode1;
            this.gOutCode = 0;

            if (outside) {
                finish();
            }
            // clipping disabled:
            out.lineTo(xe, ye);
            this.cx0 = xe;
            this.cy0 = ye;
        }

        private void clip(final int sideCode,
                          final int outcode0,
                          final int outcode1)
        {
            // corner or cross-boundary on left or right side:
            if ((outcode0 != outcode1)
                    &amp;&amp; ((sideCode &amp; MarlinConst.OUTCODE_MASK_L_R) != 0))
            {
                // combine outcodes:
                final int mergeCode = (outcode0 | outcode1);
                final int tbCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_T_B;
                final int lrCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_L_R;
                final int off = (lrCode == MarlinConst.OUTCODE_LEFT) ? 0 : 2;

                // add corners to outside stack:
                switch (tbCode) {
                    case MarlinConst.OUTCODE_TOP:
                        stack.push(off); // top
                        return;
                    case MarlinConst.OUTCODE_BOTTOM:
                        stack.push(off + 1); // bottom
                        return;
                    default:
                        // both TOP / BOTTOM:
                        if ((outcode0 &amp; MarlinConst.OUTCODE_TOP) != 0) {
                            // top to bottom
                            stack.push(off); // top
                            stack.push(off + 1); // bottom
                        } else {
                            // bottom to top
                            stack.push(off + 1); // bottom
                            stack.push(off); // top
                        }
                }
            }
        }

        @Override
        public void curveTo(final float x1, final float y1,
                            final float x2, final float y2,
                            final float xe, final float ye)
        {
            final int outcode0 = this.cOutCode;
            final int outcode1 = Helpers.outcode(x1, y1, clipRect);
            final int outcode2 = Helpers.outcode(x2, y2, clipRect);
            final int outcode3 = Helpers.outcode(xe, ye, clipRect);

            // Should clip
            final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
            if (orCode != 0) {
                final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;

                // basic rejection criteria:
                if (sideCode == 0) {
                    // ovelap clip:
                    if (subdivide) {
                        // avoid reentrance
                        subdivide = false;
                        // subdivide curve =&gt; callback with subdivided parts:
                        boolean ret;
                        if (outside) {
                            ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,
                                                           x2, y2, xe, ye,
                                                           orCode, this);
                        } else {
                            ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
                                                           x2, y2, xe, ye,
                                                           orCode, this);
                        }
                        // reentrance is done:
                        subdivide = true;
                        if (ret) {
                            return;
                        }
                    }
                    // already subdivided so render it
                } else {
                    this.cOutCode = outcode3;
                    this.gOutCode &amp;= sideCode;
                    // keep last point coordinate before entering the clip again:
                    this.outside = true;
                    this.cox0 = xe;
                    this.coy0 = ye;

                    clip(sideCode, outcode0, outcode3);
                    return;
                }
            }

            this.cOutCode = outcode3;
            this.gOutCode = 0;

            if (outside) {
                finish();
            }
            // clipping disabled:
            out.curveTo(x1, y1, x2, y2, xe, ye);
            this.cx0 = xe;
            this.cy0 = ye;
        }

        @Override
        public void quadTo(final float x1, final float y1,
                           final float xe, final float ye)
        {
            final int outcode0 = this.cOutCode;
            final int outcode1 = Helpers.outcode(x1, y1, clipRect);
            final int outcode2 = Helpers.outcode(xe, ye, clipRect);

            // Should clip
            final int orCode = (outcode0 | outcode1 | outcode2);
            if (orCode != 0) {
                final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;

                // basic rejection criteria:
                if (sideCode == 0) {
                    // ovelap clip:
                    if (subdivide) {
                        // avoid reentrance
                        subdivide = false;
                        // subdivide curve =&gt; callback with subdivided parts:
                        boolean ret;
                        if (outside) {
                            ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,
                                                          xe, ye, orCode, this);
                        } else {
                            ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
                                                          xe, ye, orCode, this);
                        }
                        // reentrance is done:
                        subdivide = true;
                        if (ret) {
                            return;
                        }
                    }
                    // already subdivided so render it
                } else {
                    this.cOutCode = outcode2;
                    this.gOutCode &amp;= sideCode;
                    // keep last point coordinate before entering the clip again:
                    this.outside = true;
                    this.cox0 = xe;
                    this.coy0 = ye;

                    clip(sideCode, outcode0, outcode2);
                    return;
                }
            }

            this.cOutCode = outcode2;
            this.gOutCode = 0;

            if (outside) {
                finish();
            }
            // clipping disabled:
            out.quadTo(x1, y1, xe, ye);
            this.cx0 = xe;
            this.cy0 = ye;
        }
    }

    static final class CurveClipSplitter {

        static final float LEN_TH = MarlinProperties.getSubdividerMinLength();
        static final boolean DO_CHECK_LENGTH = (LEN_TH &gt; 0.0f);

        private static final boolean TRACE = false;

        private static final int MAX_N_CURVES = 3 * 4;

        private final RendererContext rdrCtx;

        // scaled length threshold:
        private float minLength;

        // clip rectangle (ymin, ymax, xmin, xmax):
        final float[] clipRect;

        // clip rectangle (ymin, ymax, xmin, xmax) including padding:
        final float[] clipRectPad = new float[4];
        private boolean init_clipRectPad = false;

        // This is where the curve to be processed is put. We give it
        // enough room to store all curves.
        final float[] middle = new float[MAX_N_CURVES * 8 + 2];
        // t values at subdivision points
        private final float[] subdivTs = new float[MAX_N_CURVES];

        // dirty curve
        private final Curve curve;

        CurveClipSplitter(final RendererContext rdrCtx) {
            this.rdrCtx = rdrCtx;
            this.clipRect = rdrCtx.clipRect;
            this.curve = rdrCtx.curve;
        }

        void init() {
            this.init_clipRectPad = true;

            if (DO_CHECK_LENGTH) {
                this.minLength = (this.rdrCtx.clipInvScale == 0.0f) ? LEN_TH
                                    : (LEN_TH * this.rdrCtx.clipInvScale);

                if (MarlinConst.DO_LOG_CLIP) {
                    MarlinUtils.logInfo(&quot;CurveClipSplitter.minLength = &quot;
                                            + minLength);
                }
            }
        }

        private void initPaddedClip() {
            // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
            // adjust padded clip rectangle (ymin, ymax, xmin, xmax):
            // add a rounding error (curve subdivision ~ 0.1px):
            final float[] _clipRect = clipRect;
            final float[] _clipRectPad = clipRectPad;

            _clipRectPad[0] = _clipRect[0] - CLIP_RECT_PADDING;
            _clipRectPad[1] = _clipRect[1] + CLIP_RECT_PADDING;
            _clipRectPad[2] = _clipRect[2] - CLIP_RECT_PADDING;
            _clipRectPad[3] = _clipRect[3] + CLIP_RECT_PADDING;

            if (TRACE) {
                MarlinUtils.logInfo(&quot;clip: X [&quot; + _clipRectPad[2] + &quot; .. &quot; + _clipRectPad[3] +&quot;] &quot;
                                        + &quot;Y [&quot; + _clipRectPad[0] + &quot; .. &quot; + _clipRectPad[1] +&quot;]&quot;);
            }
        }

        boolean splitLine(final float x0, final float y0,
                          final float x1, final float y1,
                          final int outCodeOR,
                          final PathConsumer2D out)
        {
            if (TRACE) {
                MarlinUtils.logInfo(&quot;divLine P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;)&quot;);
            }

            if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastLineLen(x0, y0, x1, y1) &lt;= minLength) {
                return false;
            }

            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;

            return subdivideAtIntersections(4, outCodeOR, out);
        }

        boolean splitQuad(final float x0, final float y0,
                          final float x1, final float y1,
                          final float x2, final float y2,
                          final int outCodeOR,
                          final PathConsumer2D out)
        {
            if (TRACE) {
                MarlinUtils.logInfo(&quot;divQuad P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2 + &quot;)&quot;);
            }

            if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastQuadLen(x0, y0, x1, y1, x2, y2) &lt;= minLength) {
                return false;
            }

            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;

            return subdivideAtIntersections(6, outCodeOR, out);
        }

        boolean splitCurve(final float x0, final float y0,
                           final float x1, final float y1,
                           final float x2, final float y2,
                           final float x3, final float y3,
                           final int outCodeOR,
                           final PathConsumer2D out)
        {
            if (TRACE) {
                MarlinUtils.logInfo(&quot;divCurve P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2 + &quot;) P3(&quot; + x3 + &quot;, &quot; + y3 + &quot;)&quot;);
            }

            if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastCurvelen(x0, y0, x1, y1, x2, y2, x3, y3) &lt;= minLength) {
                return false;
            }

            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;
            mid[6] = x3;  mid[7] = y3;

            return subdivideAtIntersections(8, outCodeOR, out);
        }

        private boolean subdivideAtIntersections(final int type, final int outCodeOR,
                                                 final PathConsumer2D out)
        {
            final float[] mid = middle;
            final float[] subTs = subdivTs;

            if (init_clipRectPad) {
                init_clipRectPad = false;
                initPaddedClip();
            }

            final int nSplits = Helpers.findClipPoints(curve, mid, subTs, type,
                                                        outCodeOR, clipRectPad);

            if (TRACE) {
                MarlinUtils.logInfo(&quot;nSplits: &quot; + nSplits);
                MarlinUtils.logInfo(&quot;subTs: &quot; + Arrays.toString(Arrays.copyOfRange(subTs, 0, nSplits)));
            }
            if (nSplits == 0) {
                // only curve support shortcut
                return false;
            }
            float prevT = 0.0f;

            for (int i = 0, off = 0; i &lt; nSplits; i++, off += type) {
                final float t = subTs[i];

                Helpers.subdivideAt((t - prevT) / (1.0f - prevT),
                                     mid, off, mid, off, type);
                prevT = t;
            }

            for (int i = 0, off = 0; i &lt;= nSplits; i++, off += type) {
                if (TRACE) {
                    MarlinUtils.logInfo(&quot;Part Curve &quot; + Arrays.toString(Arrays.copyOfRange(mid, off, off + type)));
                }
                emitCurrent(type, mid, off, out);
            }
            return true;
        }

        static void emitCurrent(final int type, final float[] pts,
                                final int off, final PathConsumer2D out)
        {
            // if instead of switch (perf + most probable cases first)
            if (type == 8) {
                out.curveTo(pts[off + 2], pts[off + 3],
                            pts[off + 4], pts[off + 5],
                            pts[off + 6], pts[off + 7]);
            } else if (type == 4) {
                out.lineTo(pts[off + 2], pts[off + 3]);
            } else {
                out.quadTo(pts[off + 2], pts[off + 3],
                           pts[off + 4], pts[off + 5]);
            }
        }
    }

    public static final class CurveBasicMonotonizer {

        private static final int MAX_N_CURVES = 11;

        // squared half line width (for stroker)
        private float lw2;

        // number of splitted curves
        int nbSplits;

        // This is where the curve to be processed is put. We give it
        // enough room to store all curves.
        final float[] middle = new float[MAX_N_CURVES * 6 + 2];
        // t values at subdivision points
        private final float[] subdivTs = new float[MAX_N_CURVES - 1];

        // dirty curve
        private final Curve curve;

        CurveBasicMonotonizer(final RendererContext rdrCtx) {
            this.curve = rdrCtx.curve;
        }

        public void init(final float lineWidth) {
            this.lw2 = (lineWidth * lineWidth) / 4.0f;
        }

        CurveBasicMonotonizer curve(final float x0, final float y0,
                                    final float x1, final float y1,
                                    final float x2, final float y2,
                                    final float x3, final float y3)
        {
            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;
            mid[6] = x3;  mid[7] = y3;

            final float[] subTs = subdivTs;
            final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 8, lw2);

            float prevT = 0.0f;
            for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
                final float t = subTs[i];

                Helpers.subdivideCubicAt((t - prevT) / (1.0f - prevT),
                                          mid, off, mid, off, off + 6);
                prevT = t;
            }

            this.nbSplits = nSplits;
            return this;
        }

        CurveBasicMonotonizer quad(final float x0, final float y0,
                                   final float x1, final float y1,
                                   final float x2, final float y2)
        {
            final float[] mid = middle;
            mid[0] = x0;  mid[1] = y0;
            mid[2] = x1;  mid[3] = y1;
            mid[4] = x2;  mid[5] = y2;

            final float[] subTs = subdivTs;
            final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 6, lw2);

            float prevt = 0.0f;
            for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
                final float t = subTs[i];
                Helpers.subdivideQuadAt((t - prevt) / (1.0f - prevt),
                                         mid, off, mid, off, off + 4);
                prevt = t;
            }

            this.nbSplits = nSplits;
            return this;
        }
    }

    static final class PathTracer implements PathConsumer2D {
        private final String prefix;
        private PathConsumer2D out;

        PathTracer(String name) {
            this.prefix = name + &quot;: &quot;;
        }

        PathTracer init(PathConsumer2D out) {
            this.out = out;
            return this; // fluent API
        }

        @Override
        public void moveTo(float x0, float y0) {
            log(&quot;moveTo (&quot; + x0 + &quot;, &quot; + y0 + ')');
            out.moveTo(x0, y0);
        }

        @Override
        public void lineTo(float x1, float y1) {
            log(&quot;lineTo (&quot; + x1 + &quot;, &quot; + y1 + ')');
            out.lineTo(x1, y1);
        }

        @Override
        public void curveTo(float x1, float y1,
                            float x2, float y2,
                            float x3, float y3)
        {
            log(&quot;curveTo P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2  + &quot;) P3(&quot; + x3 + &quot;, &quot; + y3 + ')');
            out.curveTo(x1, y1, x2, y2, x3, y3);
        }

        @Override
        public void quadTo(float x1, float y1, float x2, float y2) {
            log(&quot;quadTo P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2  + ')');
            out.quadTo(x1, y1, x2, y2);
        }

        @Override
        public void closePath() {
            log(&quot;closePath&quot;);
            out.closePath();
        }
<A NAME="19"></A>
        @Override
        public void pathDone() {
            <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#19',2,'match58-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>log(&quot;pathDone&quot;);
            out.pathDone();
        }

        private void log(final String message) {
            MarlinUtils.logInfo(prefix + message);
        }
    }</B></FONT>
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/es2/ES2Context.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.es2;

import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGDefaultCamera;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.Material;
import com.sun.prism.RTTexture;
import com.sun.prism.RenderTarget;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.ps.BaseShaderContext;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderFactory;

<A NAME="1"></A>class ES2Context extends BaseShaderContext {

    // Temporary variables
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#1',2,'match58-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static GeneralTransform3D scratchTx = new GeneralTransform3D();
    private static final GeneralTransform3D flipTx = new GeneralTransform3D();
    private static final Affine3D scratchAffine3DTx = new Affine3D();
    // contains the combined projection/modelview matrix (elements 0-15)
    private static float rawMatrix[] = new float[GLContext.NUM_MATRIX_ELEMENTS];

    private GeneralTransform3D projViewTx = new GeneralTransform3D();
    private GeneralTransform3D worldTx = new GeneralTransform3D();
    private Vec3d cameraPos = new Vec3d();

    private RenderTarget currentTarget</B></FONT>;
    private final GLContext glContext;
    private final GLDrawable dummyGLDrawable;
    private final GLPixelFormat pixelFormat;
    private State state;
    private int quadIndices;
    // The drawable that is current to the glContext
    private GLDrawable currentDrawable = null;
    private int indexBuffer = 0;
    private int shaderProgram;

    public static final int NUM_QUADS = PrismSettings.superShader ? 4096 : 256;

    ES2Context(Screen screen, ShaderFactory factory) {
        super(screen, factory, NUM_QUADS);
        GLFactory glF = ES2Pipeline.glFactory;

        // NOTE: There is issue with the returned value of getNativeScreen.
        // HMonitor (Windows), GTKMonitor index (Linux) ...
        // We would prefer HDC (Windows) and screen number(index) (Linux)
        pixelFormat =
                glF.createGLPixelFormat(screen.getNativeScreen(),
                ES2Pipeline.pixelFormatAttributes);

        dummyGLDrawable = glF.createDummyGLDrawable(pixelFormat);
        glContext = glF.createGLContext(dummyGLDrawable, pixelFormat,
                glF.getShareContext(), PrismSettings.isVsyncEnabled);
        makeCurrent(dummyGLDrawable);

        glContext.enableVertexAttributes();
        quadIndices = genQuadsIndexBuffer(NUM_QUADS);
        setIndexBuffer(quadIndices);
        state = new State();
    }

    static short [] getQuadIndices16bit(int numQuads) {
        short data[] = new short[numQuads * 6];

        for (int i = 0; i != numQuads; ++i) {
            int vtx = i * 4;
            int idx = i * 6;
            data[idx+0] = (short) (vtx+0);
            data[idx+1] = (short) (vtx+1);
            data[idx+2] = (short) (vtx+2);

            data[idx+3] = (short) (vtx+2);
            data[idx+4] = (short) (vtx+1);
            data[idx+5] = (short) (vtx+3);
        }

        return data;
    }

    int genQuadsIndexBuffer(int numQuads) {
        if (numQuads * 6 &gt; 0x10000)
            throw new IllegalArgumentException(&quot;vertex indices overflow&quot;);

        return glContext.createIndexBuffer16(getQuadIndices16bit(numQuads));
    }

    final void clearContext() {
        if (currentDrawable != null) {
            currentDrawable.swapBuffers(glContext);
        }
    }

    final void setIndexBuffer(int ib) {
        if (indexBuffer != ib) {
            glContext.setIndexBuffer(indexBuffer = ib);
        }
    }

    GLContext getGLContext() {
        return glContext;
    }

    GLPixelFormat getPixelFormat() {
        return pixelFormat;
    }

    ES2Shader getPhongShader(ES2MeshView meshView) {
        return ES2PhongShader.getShader(meshView, this);
    }

    void makeCurrent(GLDrawable drawable) {
        if (drawable == null) {
            drawable = dummyGLDrawable;
        }
        if (drawable != currentDrawable) {
            glContext.makeCurrent(drawable);
            // Need to restore FBO to on screen framebuffer
            glContext.bindFBO(0);
            currentDrawable = drawable;
        }
    }

    /**
     * Called from ES2Graphics.updateRenderTarget() in response to a window
     * resize event.  This method ensures that the context is made current
     * after the resize event, which is required on Mac OS X in order to
     * force a call to [NSOpenGLContext update].
     */
    void forceRenderTarget(ES2Graphics g) {
        updateRenderTarget(g.getRenderTarget(), g.getCameraNoClone(),
                g.isDepthTest() &amp;&amp; g.isDepthBuffer());
    }

    int getShaderProgram() {
        return shaderProgram;
    }

    // Forcibly sets the current shader program to the given object.
    void setShaderProgram(int progid) {
        shaderProgram = progid;
        glContext.setShaderProgram(progid);
    }

    // Sets the current shader program to the given object only if it was
    // not already the current program.
    void updateShaderProgram(int progid) {
        if (progid != shaderProgram) {
            setShaderProgram(progid);
        }
    }

    @Override
    protected void init() {
        super.init();
    }

    @Override
    protected void releaseRenderTarget() {
        currentTarget = null;
        super.releaseRenderTarget();
    }

    @Override
    protected State updateRenderTarget(RenderTarget target, NGCamera camera,
            boolean depthTest) {
        int fboID = ((ES2RenderTarget)target).getFboID();
        glContext.bindFBO(fboID);

        boolean msaa = false;
        if (target instanceof ES2RTTexture) {
            // Attach a depth buffer to the currently bound FBO
            ES2RTTexture rtTarget = (ES2RTTexture)target;
            msaa = rtTarget.isMSAA();
            if (depthTest) {
                rtTarget.attachDepthBuffer(this);
            }
        }

        // update viewport
        int x = target.getContentX();
        int y = target.getContentY();
        int w = target.getContentWidth();
        int h = target.getContentHeight();
        glContext.updateViewportAndDepthTest(x, y, w, h, depthTest);
        glContext.updateMSAAState(msaa);

        if (camera instanceof NGDefaultCamera) {
            // update projection matrix; this will be uploaded to the shader
            // along with the modelview matrix in updateShaderTransform()
            ((NGDefaultCamera) camera).validate(w, h);
            scratchTx = camera.getProjViewTx(scratchTx);
        } else {
            scratchTx = camera.getProjViewTx(scratchTx);
            // TODO: verify that this is the right solution. There may be
            // other use-cases where rendering needs different viewport size.
            double vw = camera.getViewWidth();
            double vh = camera.getViewHeight();
            if (w != vw || h != vh) {
                scratchTx.scale(vw / w, vh / h, 1.0);
            }
        }

        if (target instanceof ES2RTTexture) {
            // Compute a flipped version of projViewTx
            projViewTx.set(flipTx);
            projViewTx.mul(scratchTx);
        } else {
            projViewTx.set(scratchTx);
        }

        // update camera position; this will be uploaded to the shader
        // when we switch to 3D state
        cameraPos = camera.getPositionInWorld(cameraPos);

        currentTarget = target;
        return state;
    }

    @Override
    protected void updateTexture(int texUnit, Texture tex) {
        glContext.updateActiveTextureUnit(texUnit);

        if (tex == null) {
            glContext.updateBoundTexture(0);
        } else {
            ES2Texture es2Tex = (ES2Texture)tex;
            glContext.updateBoundTexture(es2Tex.getNativeSourceHandle());
            es2Tex.updateWrapState();
            es2Tex.updateFilterState();
        }
    }

    @Override
    protected void updateShaderTransform(Shader shader, BaseTransform xform) {
        if (xform == null) {
            xform = BaseTransform.IDENTITY_TRANSFORM;
        }

        scratchTx.set(projViewTx);
        final GeneralTransform3D perspectiveTransform = getPerspectiveTransformNoClone();
        if (perspectiveTransform.isIdentity()) {
            updateRawMatrix(scratchTx.mul(xform));
        } else {
            updateRawMatrix(scratchTx.mul(xform).mul(perspectiveTransform));
        }

        ES2Shader es2shader = (ES2Shader) shader;
        es2shader.setMatrix(&quot;mvpMatrix&quot;, rawMatrix);
//        printRawMatrix(&quot;mvpMatrix&quot;);

        if (es2shader.isPixcoordUsed()) {
            // the gl_FragCoord variable is in window coordinates and
            // does not take the viewport origin into account (or the fact
            // that we do a y-flip of the projection matrix in the case
            // of onscreen windows for that matter); we need to update
            // the special jsl_pixCoordOffset param here so that the shader
            // can continue to treat pixcoord as if it were in the range
            // [0,0] to [contentWidth,contentHeight] of the destination surface
            float xoff = currentTarget.getContentX();
            float yoff = currentTarget.getContentY();
            float yinv, yflip;
            if (currentTarget instanceof ES2SwapChain) {
                // there is a y-flip in this case
                yinv = currentTarget.getPhysicalHeight();
                yflip = 1f;
            } else {
                // no y-flip for RTTextures
                yinv = 0f;
                yflip = -1f;
            }
            shader.setConstant(&quot;jsl_pixCoordOffset&quot;, xoff, yoff, yinv, yflip);
        }
    }

    @Override
    protected void updateWorldTransform(BaseTransform xform) {
        worldTx.setIdentity();
        if ((xform != null) &amp;&amp; (!xform.isIdentity())) {
            worldTx.mul(xform);
        }
    }

    @Override
    protected void updateClipRect(Rectangle clipRect) {
        if (clipRect == null || clipRect.isEmpty()) {
            glContext.scissorTest(false, 0, 0, 0, 0);
        } else {
            // the scissor rectangle is specified using the lower-left
            // origin of the clip region (in the framebuffer's coordinate
            // space), so we must account for the x/y offsets of the
            // destination surface, and use a flipped y origin when rendering
            // to an ES2SwapChain
            int w = clipRect.width;
            int h = clipRect.height;
            int x = currentTarget.getContentX();
            int y = currentTarget.getContentY();
            if (currentTarget instanceof ES2RTTexture) {
                x += clipRect.x;
                y += clipRect.y;
            } else {
                int dsth = currentTarget.getPhysicalHeight();
                x += clipRect.x;
                y += dsth - (clipRect.y + h);
            }
            glContext.scissorTest(true, x, y, w, h);
        }
    }

    @Override
    protected void updateCompositeMode(CompositeMode mode) {
        switch (mode) {
            case CLEAR:
                glContext.blendFunc(GLContext.GL_ZERO, GLContext.GL_ZERO);
                break;
            case SRC:
                glContext.blendFunc(GLContext.GL_ONE, GLContext.GL_ZERO);
                break;
            case SRC_OVER:
                glContext.blendFunc(GLContext.GL_ONE, GLContext.GL_ONE_MINUS_SRC_ALPHA);
                break;
            case DST_OUT:
                glContext.blendFunc(GLContext.GL_ZERO, GLContext.GL_ONE_MINUS_SRC_ALPHA);
                break;
            case ADD:
                glContext.blendFunc(GLContext.GL_ONE, GLContext.GL_ONE);
                break;
            default:
                throw new InternalError(&quot;Unrecognized composite mode: &quot; + mode);
        }
    }

    @Override
    public void setDeviceParametersFor2D() {
        // invalidate cache data
        indexBuffer = 0;
        shaderProgram = 0;
        glContext.setDeviceParametersFor2D();

        // Bind vertex attributes and index buffer
        glContext.enableVertexAttributes();
        setIndexBuffer(quadIndices);
    }

    @Override
    public void setDeviceParametersFor3D() {
        // unbind vertex attributes and index buffer
        glContext.disableVertexAttributes();
        glContext.setDeviceParametersFor3D();
    }

    long createES2Mesh() {
        return glContext.createES2Mesh();
    }

    // TODO: 3D - Should this be called dispose?
    void releaseES2Mesh(long nativeHandle) {
        glContext.releaseES2Mesh(nativeHandle);
    }

    boolean buildNativeGeometry(long nativeHandle, float[] vertexBuffer,
            int vertexBufferLength, short[] indexBuffer, int indexBufferLength) {
        return glContext.buildNativeGeometry(nativeHandle, vertexBuffer,
                vertexBufferLength, indexBuffer, indexBufferLength);
    }

    boolean buildNativeGeometry(long nativeHandle, float[] vertexBuffer,
            int vertexBufferLength, int[] indexBuffer, int indexBufferLength) {
        return glContext.buildNativeGeometry(nativeHandle, vertexBuffer,
                vertexBufferLength, indexBuffer, indexBufferLength);
    }

    long createES2PhongMaterial() {
        return glContext.createES2PhongMaterial();
    }

    // TODO: 3D - Should this be called dispose?
    void releaseES2PhongMaterial(long nativeHandle) {
        glContext.releaseES2PhongMaterial(nativeHandle);
    }

    void setSolidColor(long nativeHandle, float r, float g, float b, float a) {
        glContext.setSolidColor(nativeHandle, r, g, b, a);
    }

    void setMap(long nativeHandle, int mapType, int texID) {
        glContext.setMap(nativeHandle, mapType, texID);
    }

    long createES2MeshView(ES2Mesh mesh) {
        return glContext.createES2MeshView(mesh.getNativeHandle());
    }

    // TODO: 3D - Should this be called dispose?
    void releaseES2MeshView(long nativeHandle) {
        glContext.releaseES2MeshView(nativeHandle);
    }

    void setCullingMode(long nativeHandle, int cullingMode) {
        // NOTE: Native code has set clockwise order as front-facing
        glContext.setCullingMode(nativeHandle, cullingMode);
    }

    void setMaterial(long nativeHandle, Material material) {
        ES2PhongMaterial es2Material = (ES2PhongMaterial)material;

        glContext.setMaterial(nativeHandle,
                (es2Material).getNativeHandle());
    }

    void setWireframe(long nativeHandle, boolean wireframe) {
       glContext.setWireframe(nativeHandle, wireframe);
    }

    void setAmbientLight(long nativeHandle, float r, float g, float b) {
        glContext.setAmbientLight(nativeHandle, r, g, b);
    }

    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w) {
        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);
    }

    @Override
    public void blit(RTTexture srcRTT, RTTexture dstRTT,
                     int srcX0, int srcY0, int srcX1, int srcY1,
                     int dstX0, int dstY0, int dstX1, int dstY1)
    {
        // If dstRTT is null then will blit to currently bound fbo
        int dstFboID = dstRTT == null ? 0 : ((ES2RTTexture)dstRTT).getFboID();
        int srcFboID = ((ES2RTTexture)srcRTT).getFboID();
        glContext.blitFBO(srcFboID, dstFboID,
                          srcX0, srcY0, srcX1, srcY1,
                          dstX0, dstY0, dstX1, dstY1);
    }

    void renderMeshView(long nativeHandle, Graphics g, ES2MeshView meshView) {

        ES2Shader shader = (ES2Shader) getPhongShader(meshView);
        setShaderProgram(shader.getProgramObject());

        // Support retina display by scaling the projViewTx and pass it to the shader.
        float pixelScaleFactorX = g.getPixelScaleFactorX();
        float pixelScaleFactorY = g.getPixelScaleFactorY();
        if (pixelScaleFactorX != 1.0 || pixelScaleFactorY != 1.0) {
            scratchTx = scratchTx.set(projViewTx);
            scratchTx.scale(pixelScaleFactorX, pixelScaleFactorY, 1.0);
            updateRawMatrix(scratchTx);
        } else {
            updateRawMatrix(projViewTx);
        }
        shader.setMatrix(&quot;viewProjectionMatrix&quot;, rawMatrix);
        shader.setConstant(&quot;camPos&quot;, (float) cameraPos.x,
                (float) cameraPos.y, (float)cameraPos.z);

        // Undo the SwapChain scaling done in createGraphics() because 3D needs
        // this information in the shader (via projViewTx)
        BaseTransform xform = g.getTransformNoClone();
        if (pixelScaleFactorX != 1.0 || pixelScaleFactorY != 1.0) {
            scratchAffine3DTx.setToIdentity();
            scratchAffine3DTx.scale(1.0 / pixelScaleFactorX, 1.0 / pixelScaleFactorY);
            scratchAffine3DTx.concatenate(xform);
            updateWorldTransform(scratchAffine3DTx);
        } else {
            updateWorldTransform(xform);
        }
        updateRawMatrix(worldTx);

        shader.setMatrix(&quot;worldMatrix&quot;, rawMatrix);
//        printRawMatrix(&quot;worldMatrix&quot;);

        ES2PhongShader.setShaderParamaters(shader, meshView, this);

        glContext.renderMeshView(nativeHandle);
    }

    @Override
    protected void renderQuads(float coordArray[], byte colorArray[], int numVertices) {
        glContext.drawIndexedQuads(coordArray, colorArray, numVertices);
    }

    void printRawMatrix(String mesg) {
        System.err.println(mesg + &quot; = &quot;);
        for (int i = 0; i &lt; 4; i++) {
            System.err.println(rawMatrix[i] + &quot;, &quot; + rawMatrix[i+4]
                    + &quot;, &quot; + rawMatrix[i+8] + &quot;, &quot; + rawMatrix[i+12]);
        }
    }

    // Need to transpose the matrix because OpenGL stores its matrix in
    // column major (though matrix computation is done in row major)
    private void updateRawMatrix(GeneralTransform3D src) {
        rawMatrix[0]  = (float)src.get(0); // Scale X
        rawMatrix[1]  = (float)src.get(4); // Shear Y
        rawMatrix[2]  = (float)src.get(8);
        rawMatrix[3]  = (float)src.get(12);
        rawMatrix[4]  = (float)src.get(1); // Shear X
        rawMatrix[5]  = (float)src.get(5); // Scale Y
        rawMatrix[6]  = (float)src.get(9);
        rawMatrix[7]  = (float)src.get(13);
        rawMatrix[8]  = (float)src.get(2);
        rawMatrix[9]  = (float)src.get(6);
        rawMatrix[10] = (float)src.get(10);
        rawMatrix[11] = (float)src.get(14);
        rawMatrix[12] = (float)src.get(3);  // Translate X
        rawMatrix[13] = (float)src.get(7);  // Translate Y
        rawMatrix[14] = (float)src.get(11);
        rawMatrix[15] = (float)src.get(15);
    }

    static {
        BaseTransform tx = Affine2D.getScaleInstance(1.0, -1.0);
        flipTx.setIdentity();
        flipTx.mul(tx);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/print/J2DPrinterJob.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d.print;

import javafx.print.Collation;
import javafx.print.JobSettings;
import javafx.print.PageLayout;
import javafx.print.PageOrientation;
import javafx.print.PageRange;
import javafx.print.Paper;
import javafx.print.PaperSource;
import javafx.print.PrintColor;
import javafx.print.PrintResolution;
import javafx.print.PrintSides;
import javafx.print.Printer;
import javafx.print.Printer.MarginType;
import javafx.print.PrinterAttributes;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Window;
import javax.print.PrintService;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttribute;
import javax.print.attribute.PrintRequestAttributeSet;
import javax.print.attribute.ResolutionSyntax;
import javax.print.attribute.Size2DSyntax;
import javax.print.attribute.standard.Chromaticity;
import javax.print.attribute.standard.Copies;
import javax.print.attribute.standard.DialogTypeSelection;
import javax.print.attribute.standard.Media;
import javax.print.attribute.standard.MediaPrintableArea;
import javax.print.attribute.standard.MediaSize;
import javax.print.attribute.standard.MediaSizeName;
import javax.print.attribute.standard.MediaTray;
import javax.print.attribute.standard.OrientationRequested;
import javax.print.attribute.standard.PageRanges;
import javax.print.attribute.standard.PrintQuality;
import javax.print.attribute.standard.PrinterResolution;
import javax.print.attribute.standard.SheetCollate;
import javax.print.attribute.standard.Sides;
import java.awt.*;
import java.awt.print.PageFormat;
import java.awt.print.Pageable;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.util.ArrayList;
import java.util.Set;
import com.sun.glass.ui.Application;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.print.PrintHelper;
import com.sun.javafx.print.PrinterImpl;
import com.sun.javafx.print.PrinterJobImpl;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.Toolkit;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.prism.impl.PrismSettings;

import com.sun.prism.j2d.PrismPrintGraphics;

import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class J2DPrinterJob implements PrinterJobImpl {

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String libName = &quot;prism_common&quot;;

            if (PrismSettings.verbose) {
                System.out.println(&quot;Loading Prism common native library ...&quot;);
            }
            NativeLibLoader.loadLibrary(libName);
            if (PrismSettings.verbose) {
                System.out.println(&quot;\tsucceeded.&quot;);
            }
            return null;
        });
    }

    javafx.print.PrinterJob fxPrinterJob;
    java.awt.print.PrinterJob pJob2D;
    javafx.print.Printer fxPrinter;
    J2DPrinter j2dPrinter;

    private JobSettings settings;
    private PrintRequestAttributeSet printReqAttrSet;
    private volatile Object elo = null;

    private static Class onTopClass = null;
    PrintRequestAttribute getAlwaysOnTop(final long id) {
        return AccessController.doPrivileged(
            (PrivilegedAction&lt;PrintRequestAttribute&gt;) () -&gt; {

            PrintRequestAttribute alwaysOnTop = null;
            try {
                if (onTopClass == null) {
                    onTopClass =
                        Class.forName(&quot;javax.print.attribute.standard.DialogOwner&quot;);
                }
                if (id == 0) {
                    Constructor&lt;PrintRequestAttribute&gt;
                         cons = onTopClass.getConstructor();
                    alwaysOnTop = cons.newInstance();
                } else {
                    alwaysOnTop = getAlwaysOnTop(onTopClass, id);
                }
            } catch (Throwable t) {
            }
            return alwaysOnTop;
        });
    }

    private static native
        PrintRequestAttribute getAlwaysOnTop(Class onTopClass, long id);

    public J2DPrinterJob(javafx.print.PrinterJob fxJob) {

        fxPrinterJob = fxJob;
        fxPrinter = fxPrinterJob.getPrinter();
        j2dPrinter = getJ2DPrinter(fxPrinter);
        settings = fxPrinterJob.getJobSettings();
        pJob2D = java.awt.print.PrinterJob.getPrinterJob();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
        printReqAttrSet = new HashPrintRequestAttributeSet();
        printReqAttrSet.add(DialogTypeSelection.NATIVE);
        j2dPageable = new J2DPageable();
        pJob2D.setPageable(j2dPageable);
    }

    private void setEnabledState(Window owner, boolean state) {
        if (owner == null) {
           return;
        }
        final TKStage stage = WindowHelper.getPeer(owner);
        if (stage == null) { // just in case.
            return;
        }
        Application.invokeAndWait(() -&gt; stage.setEnabled(state));
    }

    public boolean showPrintDialog(Window owner) {

        if (jobRunning || jobDone) {
            return false;
        }

        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                rv = pJob2D.printDialog(printReqAttrSet);
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
              &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPrintDialogWithNestedLoop(owner);
            }
            if (rv) {
                updateSettingsFromDialog();
            }
        } finally {
            setEnabledState(owner, true);
        }
        return rv;
    }

    private class PrintDialogRunnable implements Runnable {

        public void run() {
            boolean rv = false;
            try {
                rv = pJob2D.printDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPrintDialogWithNestedLoop(Window owner) {
        PrintDialogRunnable dr = new PrintDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Print Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);

        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    public boolean showPageDialog(Window owner) {
        if (jobRunning || jobDone) {
            return false;
        }
        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                PageFormat pf = pJob2D.pageDialog(printReqAttrSet);
                rv = pf != null;
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
               &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPageDialogFromNestedLoop(owner);
            }
        } finally {
            setEnabledState(owner, true);
        }
        if (rv) {
            updateSettingsFromDialog();
        }
        return rv;
    }

    private class PageDialogRunnable implements Runnable {

        public void run() {
            PageFormat pf = null;
            try {
                pf = pJob2D.pageDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Boolean rv = Boolean.valueOf(pf != null);
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPageDialogFromNestedLoop(Window owner) {

        PageDialogRunnable dr = new PageDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Page Setup Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);
        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    /*
     * The update-Foo methods here are only used to update the
     * FX JobSettings as a result of changes by user interaction
     * with a print dialog. The new values are stored in the
     * PrintRequestAttributeSet and pulled from there in to the
     * equivalent FX public API JobSettings.
     */
    private void updateJobName() {
        String name =  pJob2D.getJobName();
        if (!name.equals(settings.getJobName())) {
            settings.setJobName(name);
        }
    }
    private void updateCopies() {
        int nCopies = pJob2D.getCopies();
        if (settings.getCopies() != nCopies) {
            settings.setCopies(nCopies);
        }
    }

    private void updatePageRanges() {
        PageRanges ranges = (PageRanges)printReqAttrSet.get(PageRanges.class);
        // JDK sets default to 1,Integer.MAX_VALUE
        // So in this case I think we can just check for non-null and
        // only set if its non-null.
        if (ranges != null) {
            int[][] members = ranges.getMembers();
            if (members.length == 1) {
                PageRange range = new PageRange(members[0][0], members[0][1]);
                settings.setPageRanges(range);
            } else if (members.length &gt; 0) {
                try {
                    ArrayList&lt;PageRange&gt; prList = new ArrayList&lt;PageRange&gt;();
                    int last = 0;
                    for (int i=0; i&lt;members.length;i++) {
                        int s = members[i][0];
                        int e = members[i][1];
                        if (s &lt;= last || e &lt; s) {
                            return;
                        }
                        last = e;
                        prList.add(new PageRange(s, e));
                    }
                    settings.setPageRanges(prList.toArray(new PageRange[0]));
                } catch (Exception e) {
                }
            }
        }
    }

    private void updateSides() {
        Sides sides = (Sides)printReqAttrSet.get(Sides.class);
        if (sides == null) {
            sides = (Sides)j2dPrinter.getService().
                getDefaultAttributeValue(Sides.class);
        }
        if (sides == Sides.ONE_SIDED) {
            settings.setPrintSides(PrintSides.ONE_SIDED);
        } else if (sides == Sides.DUPLEX) {
            settings.setPrintSides(PrintSides.DUPLEX);
        } else if (sides == Sides.TUMBLE) {
            settings.setPrintSides(PrintSides.TUMBLE);
        }
    }

    /* If the attribute set has an explicit setting for
     * collation, then its been set by the user at some point,
     * even if the current value is the printer default.
     * If there is no value for collation in the attribute set,
     * it means that we are u  sing the printer default.
     */
    private void updateCollation() {
        SheetCollate collate =
            (SheetCollate)printReqAttrSet.get(SheetCollate.class);
        if (collate == null) {
            collate = j2dPrinter.getDefaultSheetCollate();
        }
        if (collate == SheetCollate.UNCOLLATED) {
            settings.setCollation(Collation.UNCOLLATED);
        } else {
            settings.setCollation(Collation.COLLATED);
        }
    }

    private void updateColor() {
        Chromaticity color =
            (Chromaticity)printReqAttrSet.get(Chromaticity.class);
        if (color == null) {
            color = j2dPrinter.getDefaultChromaticity();
        }
        if (color == Chromaticity.COLOR) {
            settings.setPrintColor(PrintColor.COLOR);
        } else {
            settings.setPrintColor(PrintColor.MONOCHROME);
        }
    }

    private void updatePrintQuality() {
        PrintQuality quality =
            (PrintQuality)printReqAttrSet.get(PrintQuality.class);
        if (quality == null) {
            quality = j2dPrinter.getDefaultPrintQuality();
        }

        if (quality == PrintQuality.DRAFT) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.DRAFT);
        } else if (quality == PrintQuality.HIGH) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.HIGH);
        } else {
            settings.
                setPrintQuality(javafx.print.PrintQuality.NORMAL);
        }
    }

    private void updatePrintResolution() {
        PrinterResolution res =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (res == null) {
            res = j2dPrinter.getDefaultPrinterResolution();
        }
        int cfr = res.getCrossFeedResolution(ResolutionSyntax.DPI);
        int fr = res.getFeedResolution(ResolutionSyntax.DPI);
        settings.setPrintResolution(PrintHelper.createPrintResolution(cfr, fr));
    }

    private void updatePageLayout() {
        Media media = (Media)printReqAttrSet.get(Media.class);
        Paper paper = j2dPrinter.getPaperForMedia(media);
        OrientationRequested o = (OrientationRequested)
            printReqAttrSet.get(OrientationRequested.class);
        PageOrientation orient = J2DPrinter.reverseMapOrientation(o);
        MediaPrintableArea mpa =
            (MediaPrintableArea)printReqAttrSet.get(MediaPrintableArea.class);
        PageLayout newLayout;
        if (mpa == null) {
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   MarginType.DEFAULT);
        } else {
            double pWid = paper.getWidth();
            double pHgt = paper.getHeight();
            int INCH = MediaPrintableArea.INCH;
            double mpaX = mpa.getX(INCH) * 72;
            double mpaY = mpa.getY(INCH) * 72;
            double mpaW = mpa.getWidth(INCH) * 72;
            double mpaH = mpa.getHeight(INCH) * 72;
            double lm=0, rm=0, tm=0, bm=0;
            switch (orient) {
            case PORTRAIT:
                lm = mpaX;
                rm = pWid - mpaX - mpaW;
                tm = mpaY;
                bm = pHgt - mpaY - mpaH;
                break;
            case REVERSE_PORTRAIT:
                lm = pWid - mpaX - mpaW;
                rm = mpaX;
                tm = pHgt - mpaY - mpaH;
                bm = mpaY;
                break;
            case LANDSCAPE:
                lm = mpaY;
                rm = pHgt - mpaY - mpaH;
                tm = pWid - mpaX - mpaW;
                bm = mpaX;
                break;
            case REVERSE_LANDSCAPE:
                lm = pHgt - mpaY - mpaH;
                tm = mpaX;
                rm = mpaY;
                bm = pWid - mpaX - mpaW;
                break;
            }
            if (Math.abs(lm) &lt; 0.01) lm = 0;
            if (Math.abs(rm) &lt; 0.01) rm = 0;
            if (Math.abs(tm) &lt; 0.01) tm = 0;
            if (Math.abs(bm) &lt; 0.01) bm = 0;
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   lm, rm, tm, bm);
        }
        settings.setPageLayout(newLayout);
    }

    private void updatePaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m instanceof MediaTray) {
            PaperSource s = j2dPrinter.getPaperSource((MediaTray)m);
            if (s != null) {
                settings.setPaperSource(s);
            }
        }
    }

    private Printer getFXPrinterForService(PrintService service) {
        Set&lt;Printer&gt; printerSet = Printer.getAllPrinters();
        for (Printer p : printerSet) {
            J2DPrinter p2d = (J2DPrinter)PrintHelper.getPrinterImpl(p);
            PrintService s = p2d.getService();
            if (s.equals(service)) {
                return p;
            }
        }
        return fxPrinter; // current printer.
    }

    public void setPrinterImpl(PrinterImpl impl) {
        j2dPrinter = (J2DPrinter)impl;
        fxPrinter = j2dPrinter.getPrinter();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    public PrinterImpl getPrinterImpl() {
        return j2dPrinter;
    }

    private J2DPrinter getJ2DPrinter(Printer printer) {
        return (J2DPrinter)PrintHelper.getPrinterImpl(printer);
    }

    public Printer getPrinter() {
        return fxPrinter;
    }

    public void setPrinter(Printer printer) {
        fxPrinter = printer;
        j2dPrinter = getJ2DPrinter(printer);
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    private void updatePrinter() {
        PrintService currService = j2dPrinter.getService();
        PrintService jobService = pJob2D.getPrintService();
        if (currService.equals(jobService)) {
            return; // no change
        }
        Printer newFXPrinter = getFXPrinterForService(jobService);
        // The public setPrinter call also updates the job to be valid for
        // the new printer. Any old values not supported will be updated
        // to supported values. If we do that, then apply the new user
        // settings, any listener will see both sets of changes.
        // Its best to just see the single transition.
        fxPrinterJob.setPrinter(newFXPrinter);
    }

    private void updateSettingsFromDialog() {
        updatePrinter();
        updateJobName();
        updateCopies();
        updatePageRanges();
        updateSides();
        updateCollation();
        updatePageLayout();
        updatePaperSource();
        updateColor();
        updatePrintQuality();
        updatePrintResolution();
    }

    private void syncSettingsToAttributes() {
        syncJobName();
        syncCopies();
        syncPageRanges();
        syncSides();
        syncCollation();
        syncPageLayout();
        syncPaperSource();
        syncColor();
        syncPrintQuality();
        syncPrintResolution();
    }

    private void syncJobName() {
        pJob2D.setJobName(settings.getJobName());
    }

    private void syncCopies() {
        pJob2D.setCopies(settings.getCopies());
        printReqAttrSet.add(new Copies(settings.getCopies()));
    }

    private void syncPageRanges() {
        printReqAttrSet.remove(PageRanges.class);
<A NAME="12"></A>        PageRange[] prArr = settings.getPageRanges();
        if (prArr != null &amp;&amp; prArr.length&gt;0) {
            int len = prArr.length;
            <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#12',2,'match58-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int[][] ranges = new int[len][2];
            for (int i=0;i&lt;len;i++) {
                ranges[i][0] = prArr[i].getStartPage();
                ranges[i][1] = prArr[i].getEndPage();
            }</B></FONT>
            printReqAttrSet.add(new PageRanges(ranges));
        }
    }

    private void syncSides() {
        Sides j2dSides = Sides.ONE_SIDED;
        PrintSides sides = settings.getPrintSides();
        if (sides == PrintSides.DUPLEX) {
            j2dSides = Sides.DUPLEX;
        } else if (sides == PrintSides.TUMBLE) {
            j2dSides = Sides.TUMBLE;
        }
        printReqAttrSet.add(j2dSides);
    }

    private void syncCollation() {
        if (settings.getCollation() == Collation.UNCOLLATED) {
            printReqAttrSet.add(SheetCollate.UNCOLLATED);
        } else {
            printReqAttrSet.add(SheetCollate.COLLATED);
        }

    }

    private void syncPageLayout() {
        PageLayout layout = settings.getPageLayout();
        PageOrientation orient = layout.getPageOrientation();
        printReqAttrSet.add(J2DPrinter.mapOrientation(orient));
        double pWid = layout.getPaper().getWidth();
        double pHgt = layout.getPaper().getHeight();
        float widthInInches = (float)(pWid/72.0);
        float heightInInches = (float)(pHgt/72.0);
        MediaSizeName media = MediaSize.findMedia(widthInInches,
                                                  heightInInches,
                                                  Size2DSyntax.INCH);
        if (media == null) {
            media = MediaSizeName.NA_LETTER;
        }
        printReqAttrSet.add(media);
        double ix=0, iy=0, iw=pWid, ih=pHgt;
        switch (orient) {
        case PORTRAIT:
            ix = layout.getLeftMargin();
            iy = layout.getTopMargin();
            iw = pWid - ix - layout.getRightMargin();
            ih = pHgt - iy - layout.getBottomMargin();
            break;
        case REVERSE_PORTRAIT:
            ix = layout.getRightMargin();
            iy = layout.getBottomMargin();
            iw = pWid - ix - layout.getLeftMargin();
            ih = pHgt - iy - layout.getTopMargin();
            break;
        case LANDSCAPE:
            ix = layout.getBottomMargin();
            iy = layout.getLeftMargin();
            iw = pWid - ix - layout.getTopMargin();
            ih = pHgt - iy - layout.getRightMargin();
            break;
        case REVERSE_LANDSCAPE:
            ix = layout.getTopMargin();
            iy = layout.getRightMargin();
            iw = pWid - ix - layout.getBottomMargin();
            ih = pHgt - iy - layout.getLeftMargin();
        }
        ix /= 72.0;
        iy /= 72.0;
        ih /= 72.0;
        iw /= 72.0;
        MediaPrintableArea mpa =
            new MediaPrintableArea((float)ix, (float)iy,
                                   (float)iw, (float)ih,
                                   MediaPrintableArea.INCH);
        printReqAttrSet.add(mpa);
    }

    private void syncPaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m != null &amp;&amp; m instanceof MediaTray) {
            printReqAttrSet.remove(Media.class);
        }
        PaperSource source = settings.getPaperSource();
        if (!source.equals(j2dPrinter.defaultPaperSource())) {
            MediaTray tray = j2dPrinter.getTrayForPaperSource(source);
            if (tray != null) {
                printReqAttrSet.add(tray);
            }
        }
    }

    private void syncColor() {
        if (settings.getPrintColor() == PrintColor.MONOCHROME) {
            printReqAttrSet.add(Chromaticity.MONOCHROME);
        } else {
            printReqAttrSet.add(Chromaticity.COLOR);
        }
    }

    private void syncPrintQuality() {
        javafx.print.PrintQuality
            quality = settings.getPrintQuality();
        PrintQuality j2DQuality;
        if (quality == javafx.print.PrintQuality.DRAFT) {
            j2DQuality = PrintQuality.DRAFT;
        } else if (quality == javafx.print.PrintQuality.HIGH) {
          j2DQuality = PrintQuality.HIGH;
        } else {
            j2DQuality = PrintQuality.NORMAL;
        }
        printReqAttrSet.add(j2DQuality);
    }

    private void syncPrintResolution() {
        /* An unsupported resolution results in incorrect scaling by J2D, so
         * remove any unsupported value, and only replace with a supported value.
         */
        PrintService ps = pJob2D.getPrintService();
        if (!ps.isAttributeCategorySupported(PrinterResolution.class)) {
            printReqAttrSet.remove(PrinterResolution.class);
            return;
        }
        PrinterResolution pres =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (pres != null &amp;&amp; !ps.isAttributeValueSupported(pres, null, null)) {
            printReqAttrSet.remove(PrinterResolution.class);
        };

        // Any resolution is now at least known to be supported for this device.
        PrintResolution res = settings.getPrintResolution();
        if (res == null) {
            return;
        }
        int cfRes = res.getCrossFeedResolution();
        int fRes = res.getFeedResolution();
        pres = new PrinterResolution(cfRes, fRes, ResolutionSyntax.DPI);
        if (!ps.isAttributeValueSupported(pres, null, null)) {
            return;
        }
        // We have validated its a supported value, so add it.
        printReqAttrSet.add(pres);
    }

    public PageLayout validatePageLayout(PageLayout pageLayout) {
        boolean needsNewLayout = false;
        PrinterAttributes caps = fxPrinter.getPrinterAttributes();
        Paper p = pageLayout.getPaper();
        if (!caps.getSupportedPapers().contains(p)) {
            needsNewLayout = true;
            p = caps.getDefaultPaper();
        }
        PageOrientation o = pageLayout.getPageOrientation();
        if (!caps.getSupportedPageOrientations().contains(o)) {
            needsNewLayout = true;
            o = caps.getDefaultPageOrientation();
        }
        if (needsNewLayout) {
            pageLayout = fxPrinter.createPageLayout(p, o, MarginType.DEFAULT);
        }
        return pageLayout;
    }

    private boolean jobRunning = false;
    private boolean jobError = false;
    private boolean jobDone = false;
    private J2DPageable j2dPageable = null;

    /*
     * Permissions were already checked when creating the job,
     * and when setting output file, but this is a final check
     * to be made before we start the underlying native job.
     */
    private void checkPermissions() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPrintJobAccess();
        }
    }

    /*
     * 2D uses a call back model. So the 2D PrinterJob needs to run
     * on a different thread than the one that the FX app uses.
     * This gets really interesting if the FX Node is attached to a
     * scene, as you are only supposed to update it on the FX thread
     * and the PG code can only access it during sync.
     */
    public boolean print(PageLayout pageLayout, Node node) {
        if (Toolkit.getToolkit().isFxUserThread()) {
            // If we are on the event thread, we need to check whether we are
            // allowed to call a nested event handler.
            if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                throw new IllegalStateException(&quot;Printing is not allowed during animation or layout processing&quot;);
            }
        }

        if (jobError || jobDone) {
            return false;
        }

        if (!jobRunning) {
            checkPermissions();
            syncSettingsToAttributes();
            PrintJobRunnable runnable = new PrintJobRunnable();
            Thread prtThread = new Thread(runnable, &quot;Print Job Thread&quot;);
            prtThread.start();
            jobRunning = true;
        }
        try {
            j2dPageable.implPrintPage(pageLayout, node);
        } catch (Throwable t) {
            if (com.sun.prism.impl.PrismSettings.debug) {
                System.err.println(&quot;printPage caught exception.&quot;);
                t.printStackTrace();
            }
            jobError = true;
            jobDone = true;
        }
        return !jobError;
    }

    private class PrintJobRunnable implements Runnable {

        public void run() {

            try {
                pJob2D.print(printReqAttrSet);
                jobDone = true;
            } catch (Throwable t) { /* subsumes declared PrinterException */
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;print caught exception.&quot;);
                    t.printStackTrace();
                }
                jobError = true;
                jobDone = true;
            }
            /*
             * If the job ends because its reached a page range limit
             * rather than calling getPage() we need to exit the nested loop.
             */
            if (elo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }
        }
    }

    static class LayoutRunnable implements Runnable {
        PageInfo pageInfo;

        LayoutRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            if (pageInfo.tempScene &amp;&amp; pageInfo.root.getScene() == null) {
                new Scene(pageInfo.root);
            }
            NodeHelper.layoutNodeForPrinting(pageInfo.root);
        }
    }

    static class ClearSceneRunnable implements Runnable {
        PageInfo pageInfo;

        ClearSceneRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            pageInfo.clearScene();
        }
    }

    private static class PageInfo {

        private PageLayout pageLayout;
        private Node node;
        private Parent root;
        private Node topNode;
        private Group group;
        private boolean tempGroup;
        private boolean tempScene;
        private boolean sceneInited;

        PageInfo(PageLayout pageLayout, Node node) {
            this.pageLayout = pageLayout;
            this.node = node;
        }

        Node getNode() {
            initScene();
            return node;
        }

        PageLayout getPageLayout() {
            return pageLayout;
        }

        /*
         * There are 4 scenarios here.
         * 1. We are passed the root node of a Scene.
         * 2. We are passed a child node of a Scene, but not the root
         * 3. We are passed a root node (no parent) but its not attached
         * to a Scene.
         * 4. We are passed a child node, but its not part of a Scene.
         * In addition we may be called on the FX thread, or not.
         * The code here is trying to make all of these work without
         * the application needing to do anything special, and hopefully
         * without affecting the application.
         * The application should not be surprised if we request layout for it,
         * since we can't display or print an unlaid out hiearchy.
         *
         * If this is the FX thread, then we can do everything directly.
         * If not, we must add the node to a scene (if needed) and
         * request layout on another thread.
         * I am assuming here that layout will be a quick no-op if
         * everything is already laid out.
         * Eventually all of this should be able to be performed on any
         * thread, and without attaching to a scene, so this is largely
         * workaround. One part I'm not so sure about is whether it
         * will ever be the case that being passed a node that is part
         * of a hierarchy, but not its root, will be able to be laid out
         * directly, or if you need to traverse to the root.
         */
        void initScene() {
            if (sceneInited) {
               return;
            }
            if (node.getScene() == null) {
                tempScene = true;
                Node topNode = node;
                while (topNode.getParent() != null) {
                    topNode = topNode.getParent();
                }
                if (topNode instanceof Group) {
                    group = (Group)topNode;
                } else {
                    tempGroup = true;
                    group = new Group();
                    group.getChildren().add(topNode);
                }
                root = group;
            } else {
                root = node.getScene().getRoot();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                if (tempScene &amp;&amp; root.getScene() == null) {
                    new Scene(root); // don't need to keep the scene variable
                }
                NodeHelper.layoutNodeForPrinting(root);
            } else {
                Application.invokeAndWait(new LayoutRunnable(this));
            }
            sceneInited = true;
        }

        private void clearScene() {
            if (tempGroup) {
                group.getChildren().removeAll(root);
            }
            tempGroup = false;
            tempScene = false;
            root = null;
            group = null;
            topNode = null;
            sceneInited = false;
        }
    }

    private Object monitor = new Object();

    static class ExitLoopRunnable implements Runnable {
        Object elo, rv;

        ExitLoopRunnable(Object elo, Object rv) {
            this.elo = elo;
            this.rv = rv;
        }

        public void run() {
            Toolkit.getToolkit().exitNestedEventLoop(elo, rv);
        }
    }

    private class J2DPageable implements Pageable, Printable {

        private volatile boolean pageDone;

        private int currPageIndex = -1;

        private volatile PageInfo newPageInfo = null;
        private PageInfo currPageInfo;
        private PageFormat currPageFormat;


        private boolean waitForNextPage(int pageIndex) {

            if (elo != null &amp;&amp; currPageInfo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }

            if (currPageInfo != null) {
                if (Toolkit.getToolkit().isFxUserThread()) {
                    currPageInfo.clearScene();
                } else {
                    Application.
                        invokeAndWait(new ClearSceneRunnable(currPageInfo));
                }
            }
            currPageInfo = null;
            pageDone = true;
            synchronized (monitor) {
                if (newPageInfo == null) {
                    monitor.notify(); // page is printed and no new page to print
                }
                while (newPageInfo == null &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    try {
                        monitor.wait(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }
            if (jobDone || jobError) {
                return false;
            }
            currPageInfo = newPageInfo;
            newPageInfo = null;
            currPageIndex = pageIndex;
            currPageFormat = getPageFormatFromLayout(currPageInfo.getPageLayout());
            return true;
        }

        private PageFormat getPageFormatFromLayout(PageLayout layout) {
            java.awt.print.Paper paper = new java.awt.print.Paper();
            double pWid = layout.getPaper().getWidth();
            double pHgt = layout.getPaper().getHeight();
            double ix=0, iy=0, iw=pWid, ih=pHgt;
            PageOrientation orient = layout.getPageOrientation();
            switch (orient) {
            case PORTRAIT:
                ix = layout.getLeftMargin();
                iy = layout.getTopMargin();
                iw = pWid - ix - layout.getRightMargin();
                ih = pHgt - iy - layout.getBottomMargin();
                break;
            case REVERSE_PORTRAIT:
                ix = layout.getRightMargin();
                iy = layout.getBottomMargin();
                iw = pWid - ix - layout.getLeftMargin();
                ih = pHgt - iy - layout.getTopMargin();
                break;
            case LANDSCAPE:
                ix = layout.getBottomMargin();
                iy = layout.getLeftMargin();
                iw = pWid - ix - layout.getTopMargin();
                ih = pHgt - iy - layout.getRightMargin();
                break;
            case REVERSE_LANDSCAPE:
                ix = layout.getTopMargin();
                iy = layout.getRightMargin();
                iw = pWid - ix - layout.getBottomMargin();
                ih = pHgt - iy - layout.getLeftMargin();
            }
            paper.setSize(pWid, pHgt);
            paper.setImageableArea(ix, iy, iw, ih);
            PageFormat format = new PageFormat();
            format.setOrientation(J2DPrinter.getOrientID(orient));
            format.setPaper(paper);
            return format;
        }

        private boolean getPage(int pageIndex) {
            if (pageIndex == currPageIndex) {
                return true;
            }
            boolean nextPage = false;
            if (pageIndex &gt; currPageIndex) {
                nextPage = waitForNextPage(pageIndex);
            }
            return nextPage;
        }

        public int print(Graphics g, PageFormat pf, int pageIndex) {
            if (jobError || jobDone || !getPage(pageIndex)) {
                return Printable.NO_SUCH_PAGE;
            }
            int x = (int)pf.getImageableX();
            int y = (int)pf.getImageableY();
            int w = (int)pf.getImageableWidth();
            int h = (int)pf.getImageableHeight();
            Node appNode = currPageInfo.getNode();
            g.translate(x, y);
            printNode(appNode, g, w, h);
            return Printable.PAGE_EXISTS;
        }

        private void printNode(Node node, Graphics g, int w, int h) {
            PrismPrintGraphics ppg =
                    new PrismPrintGraphics((Graphics2D) g, w, h);
            NGNode pgNode = NodeHelper.getPeer(node);
            boolean errored = false;
            try {
                pgNode.render(ppg);
            } catch (Throwable t) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;printNode caught exception.&quot;);
                    t.printStackTrace();
                }
                errored = true;
            }
            ppg.getResourceFactory()
                    .getTextureResourcePool()
                    .freeDisposalRequestedAndCheckResources(errored);
        }

        public Printable getPrintable(int pageIndex) {
            getPage(pageIndex);
            return this;
        }

        public PageFormat getPageFormat(int pageIndex) {
            getPage(pageIndex);
            return currPageFormat;
        }

        /*
         * Since we return unknown number of pages, then
         * the behaviour must be that we can only signal
         * end of the job by returning NO_SUCH_PAGE from
         * the print(..) method.
         */
        public int getNumberOfPages() {
            return Pageable.UNKNOWN_NUMBER_OF_PAGES;
        }

        /*
         * Executed on the application's thread.
         * Messages over to the printing thread.
         */
        private void implPrintPage(PageLayout pageLayout, Node node) {

            /* The public API printPage() is synchronized, so we know
             * that the app can't call it from 2 threads at the same
             * time, not that this is encouraged either.
             * Therefore when we are in this code, we know that any
             * previous page rendering has completed.
             * We also know that this means the app can't have 'queued up'
             * pages.
             * So, when we are in here, we know that the app is providing
             * the info for the next page.
             */
            pageDone = false;
            synchronized (monitor) {
                newPageInfo = new PageInfo(pageLayout, node);
                monitor.notify();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                elo = new Object();
                Toolkit.getToolkit().enterNestedEventLoop(elo);
                elo = null;
            } else {
                while (!pageDone &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    synchronized (monitor) {
                        try {
                            if (!pageDone) {
                                monitor.wait(1000);
                            }
                        } catch (InterruptedException e) {
                        }
                    }
                }
            }
        }

    } /* END J2DPageable class */


    public boolean endJob() {
        if (jobRunning &amp;&amp; !jobDone &amp;&amp; !jobError) {
            jobDone = true;
            try {
                synchronized (monitor) {
                    monitor.notify();
                    return jobDone;
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        } else {
            return jobDone &amp;&amp; !jobError;
        }
        return jobDone;
    }

    public void cancelJob() {
        if (!pJob2D.isCancelled()) {
            pJob2D.cancel();
        }
        jobDone = true;
        if (jobRunning) {
            jobRunning = false;
            try {
                synchronized (monitor) {
                    monitor.notify();
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/canvas/GraphicsContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.canvas;

import com.sun.javafx.geom.Arc2D;
import com.sun.javafx.geom.IllegalPathStateException;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.image.*;
import com.sun.javafx.image.impl.ByteBgraPre;
import com.sun.javafx.sg.prism.GrowableDataBuffer;
import com.sun.javafx.sg.prism.NGCanvas;
import com.sun.javafx.scene.text.FontHelper;
import com.sun.javafx.tk.Toolkit;
import com.sun.scenario.effect.EffectHelper;
import javafx.geometry.NodeOrientation;
import javafx.geometry.VPos;
import javafx.scene.effect.Blend;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.Effect;
import javafx.scene.image.Image;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.PixelReader;
import javafx.scene.image.PixelWriter;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.FillRule;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;
import javafx.scene.transform.Affine;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.LinkedList;
import javafx.scene.text.FontSmoothingType;

/**
 * This class is used to issue draw calls to a {@link Canvas} using a buffer.
 * &lt;p&gt;
 * Each call pushes the necessary parameters onto the buffer
 * where they will be later rendered onto the image of the {@code Canvas} node
 * by the rendering thread at the end of a pulse.
 * &lt;p&gt;
 * A {@code Canvas} only contains one {@code GraphicsContext}, and only one buffer.
 * If it is not attached to any scene, then it can be modified by any thread,
 * as long as it is only used from one thread at a time. Once a {@code Canvas}
 * node is attached to a scene, it must be modified on the JavaFX Application
 * Thread.
 * &lt;p&gt;
 * Calling any method on the {@code GraphicsContext} is considered modifying
 * its corresponding {@code Canvas} and is subject to the same threading
 * rules.
 * &lt;p&gt;
 * A {@code GraphicsContext} also manages a stack of state objects that can
 * be saved or restored at anytime.
 * &lt;p&gt;
 * The {@code GraphicsContext} maintains the following rendering attributes
 * which affect various subsets of the rendering methods:
 * &lt;table class=&quot;overviewSummary&quot; style=&quot;width:80%; margin-left:auto; margin-right:auto&quot;&gt;
 * &lt;caption&gt;List of Rendering Attributes&lt;/caption&gt;
 * &lt;tr&gt;
 * &lt;th class=&quot;colLast&quot; style=&quot;width:15%&quot; scope=&quot;col&quot;&gt;Attribute&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot; scope=&quot;col&quot;&gt;Save/Restore?&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot; scope=&quot;col&quot;&gt;Default value&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;comm-attr&quot;&gt;Common Rendering Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #clip() Clip}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;No clipping&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * An anti-aliased intersection of various clip paths to which rendering
 * is restricted.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setGlobalAlpha(double) Global Alpha}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 1.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * An opacity value that controls the visibility or fading of each rendering
 * operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setGlobalBlendMode(javafx.scene.effect.BlendMode) Global Blend Mode}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link BlendMode#SRC_OVER SRC_OVER}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * A {@link BlendMode} enum value that controls how pixels from each rendering
 * operation are composited into the existing image.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setTransform(javafx.scene.transform.Affine) Transform}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code Identity}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * A 3x2 2D affine transformation matrix that controls how coordinates are
 * mapped onto the logical pixels of the canvas image.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setEffect(javafx.scene.effect.Effect) Effect}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code null}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * An {@link Effect} applied individually to each rendering operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;fill-attr&quot;&gt;Fill Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFill(javafx.scene.paint.Paint) Fill Paint}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link Color#BLACK BLACK}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The {@link Paint} to be applied to the interior of shapes in a
 * fill operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;strk-attr&quot;&gt;Stroke Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setStroke(javafx.scene.paint.Paint) Stroke Paint}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link Color#BLACK BLACK}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The {@link Paint} to be applied to the boundary of shapes in a
 * stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineWidth(double) Line Width}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 1.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The width of the stroke applied to the boundary of shapes in a
 * stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineCap(javafx.scene.shape.StrokeLineCap) Line Cap}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link StrokeLineCap#SQUARE SQUARE}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The style of the end caps applied to the beginnings and ends of each
 * dash and/or subpath in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineJoin(javafx.scene.shape.StrokeLineJoin) Line Join}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link StrokeLineJoin#MITER MITER}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The style of the joins applied between individual segments in the boundary
 * paths of shapes in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setMiterLimit(double) Miter Limit}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 10.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The ratio limit of how far a {@link StrokeLineJoin#MITER MITER} line join
 * may extend in the direction of a sharp corner between segments in the
 * boundary path of a shape, relative to the line width, before it is truncated
 * to a {@link StrokeLineJoin#BEVEL BEVEL} join in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineDashes(double...) Dashes}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code null}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The array of dash lengths to be applied to the segments in the boundary
 * of shapes in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineDashOffset(double) Dash Offset}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 0.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The distance offset into the array of dash lengths at which to start the
 * dashing of the segments in the boundary of shapes in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;text-attr&quot;&gt;Text Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFont(javafx.scene.text.Font) Font}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link Font#getDefault() Default Font}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The font used for all fill and stroke text operations.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setTextAlign(javafx.scene.text.TextAlignment) Text Align}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link TextAlignment#LEFT LEFT}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The horizontal alignment of text with respect to the {@code X} coordinate
 * specified in the text operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setTextBaseline(javafx.geometry.VPos) Text Baseline}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link VPos#BASELINE BASELINE}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The vertical position of the text relative to the {@code Y} coordinate
 * specified in the text operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFontSmoothingType(javafx.scene.text.FontSmoothingType) Font Smoothing}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link FontSmoothingType#GRAY GRAY}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The type of smoothing (antialiasing) applied to the glyphs in the font
 * for all fill text operations.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;path-attr&quot;&gt;Path Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #beginPath() Current Path}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;Empty path&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The path constructed using various path construction methods to be used
 * in various path filling, stroking, or clipping operations.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFillRule(javafx.scene.shape.FillRule) Fill Rule}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link FillRule#NON_ZERO NON_ZERO}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The method used to determine the interior of paths for a path fill or
 * clip operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * &lt;a id=&quot;attr-ops-table&quot;&gt;
 * The various rendering methods on the {@code GraphicsContext} use the
 * following sets of rendering attributes:
 * &lt;/a&gt;
 * &lt;table class=&quot;overviewSummary&quot; style=&quot;width:80%; margin-left:auto; margin-right:auto&quot;&gt;
 * &lt;caption&gt;Rendering Attributes Table&lt;/caption&gt;
 * &lt;tr&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;Method&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#comm-attr&quot;&gt;Common Rendering Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#fill-attr&quot;&gt;Fill Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#strk-attr&quot;&gt;Stroke Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#text-attr&quot;&gt;Text Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#path-attr&quot;&gt;Path Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;1&quot; scope=&quot;row&quot;&gt;Basic Shape Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fillRect(double, double, double, double) fillRect()},
 * {@link #fillRoundRect(double, double, double, double, double, double) fillRoundRect()},
 * {@link #fillOval(double, double, double, double) fillOval()},
 * {@link #fillArc(double, double, double, double, double, double, javafx.scene.shape.ArcType) fillArc()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #strokeLine(double, double, double, double) strokeLine()},
 * {@link #strokeRect(double, double, double, double) strokeRect()},
 * {@link #strokeRoundRect(double, double, double, double, double, double) strokeRoundRect()},
 * {@link #strokeOval(double, double, double, double) strokeOval()},
 * {@link #strokeArc(double, double, double, double, double, double, javafx.scene.shape.ArcType) strokeArc()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #clearRect(double, double, double, double) clearRect()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#base-fn-1&quot;&gt;[1]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fillPolygon(double[], double[], int) fillPolygon()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#base-fn-2&quot;&gt;[2]&lt;/a&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #strokePolygon(double[], double[], int) strokePolygon()},
 * {@link #strokePolyline(double[], double[], int) strokePolyline()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;6&quot;&gt;
 * &lt;a id=&quot;base-fn-1&quot;&gt;[1]&lt;/a&gt; Only the Transform, Clip, and Effect apply to clearRect()&lt;br&gt;
 * &lt;a id=&quot;base-fn-2&quot;&gt;[2]&lt;/a&gt; Only the Fill Rule applies to fillPolygon(), the current path is left unchanged
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;1&quot; scope=&quot;row&quot;&gt;Text Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fillText(java.lang.String, double, double) fillText()},
 * {@link #fillText(java.lang.String, double, double, double) fillText(with maxWidth)}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#text-fn-3&quot;&gt;[3]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #strokeText(java.lang.String, double, double) strokeText()},
 * {@link #strokeText(java.lang.String, double, double, double) strokeText(with maxWidth)}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#text-fn-3&quot;&gt;[3]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;6&quot;&gt;
 * &lt;a id=&quot;text-fn-3&quot;&gt;[3]&lt;/a&gt; The Font Smoothing attribute only applies to filled text
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;1&quot; scope=&quot;row&quot;&gt;Path Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #beginPath() beginPath()},
 * {@link #moveTo(double, double) moveTo()},
 * {@link #lineTo(double, double) lineTo()},
 * {@link #quadraticCurveTo(double, double, double, double) quadraticCurveTo()},
 * {@link #bezierCurveTo(double, double, double, double, double, double) bezierCurveTo()},
 * {@link #arc(double, double, double, double, double, double) arc()},
 * {@link #arcTo(double, double, double, double, double) arcTo()},
 * {@link #appendSVGPath(java.lang.String) appendSVGPath()},
 * {@link #closePath() closePath()},
 * {@link #rect(double, double, double, double) rect()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-4&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fill() fill()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-4&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #stroke() stroke()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-4&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-5&quot;&gt;[5]&lt;/a&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #clip() clip()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;6&quot;&gt;
 * &lt;a id=&quot;path-fn-4&quot;&gt;[4]&lt;/a&gt; Transform applied only during path construction&lt;br&gt;
 * &lt;a id=&quot;path-fn-5&quot;&gt;[5]&lt;/a&gt; Fill Rule only used for fill() and clip()
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;1&quot;&gt;Image Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #drawImage(javafx.scene.image.Image, double, double) drawImage(all forms)}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;1&quot;&gt;Miscellaneous&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #applyEffect(javafx.scene.effect.Effect) applyEffect()},
 * {@link #getPixelWriter() PixelWriter methods}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * import javafx.scene.*;
 * import javafx.scene.paint.*;
 * import javafx.scene.canvas.*;
 *
 * Group root = new Group();
 * Scene s = new Scene(root, 300, 300, Color.BLACK);
 *
 * final Canvas canvas = new Canvas(250,250);
 * GraphicsContext gc = canvas.getGraphicsContext2D();
 *
 * gc.setFill(Color.BLUE);
 * gc.fillRect(75,75,100,100);
 *
 * root.getChildren().add(canvas);
 * &lt;/pre&gt;
 *
 * @see Canvas
 * @since JavaFX 2.2
 */
public final class GraphicsContext {
    Canvas theCanvas;
    Path2D path;
    boolean pathDirty;

    State curState;
    LinkedList&lt;State&gt; stateStack;
    LinkedList&lt;Path2D&gt; clipStack;

    GraphicsContext(Canvas theCanvas) {
        this.theCanvas = theCanvas;
        this.path = new Path2D();
        pathDirty = true;

        this.curState = new State();
        this.stateStack = new LinkedList&lt;State&gt;();
        this.clipStack = new LinkedList&lt;Path2D&gt;();
    }

    static class State {
        double globalAlpha;
        BlendMode blendop;
        Affine2D transform;
        Paint fill;
        Paint stroke;
        double linewidth;
        StrokeLineCap linecap;
        StrokeLineJoin linejoin;
        double miterlimit;
        double dashes[];
        double dashOffset;
        int numClipPaths;
        Font font;
        FontSmoothingType fontsmoothing;
        TextAlignment textalign;
        VPos textbaseline;
        Effect effect;
        FillRule fillRule;

        State() {
            init();
        }

        final void init() {
            set(1.0, BlendMode.SRC_OVER,
                new Affine2D(),
                Color.BLACK, Color.BLACK,
                1.0, StrokeLineCap.SQUARE, StrokeLineJoin.MITER, 10.0,
                null, 0.0,
                0,
                Font.getDefault(), FontSmoothingType.GRAY,
                TextAlignment.LEFT, VPos.BASELINE,
                null, FillRule.NON_ZERO);
        }

        State(State copy) {
            set(copy.globalAlpha, copy.blendop,
                new Affine2D(copy.transform),
                copy.fill, copy.stroke,
                copy.linewidth, copy.linecap, copy.linejoin, copy.miterlimit,
                copy.dashes, copy.dashOffset,
                copy.numClipPaths,
                copy.font, copy.fontsmoothing, copy.textalign, copy.textbaseline,
                copy.effect, copy.fillRule);
        }

        final void set(double globalAlpha, BlendMode blendop,
                       Affine2D transform, Paint fill, Paint stroke,
                       double linewidth, StrokeLineCap linecap,
                       StrokeLineJoin linejoin, double miterlimit,
                       double dashes[], double dashOffset,
                       int numClipPaths,
                       Font font, FontSmoothingType smoothing,
                       TextAlignment align, VPos baseline,
                       Effect effect, FillRule fillRule)
        {
            this.globalAlpha = globalAlpha;
            this.blendop = blendop;
            this.transform = transform;
            this.fill = fill;
            this.stroke = stroke;
            this.linewidth = linewidth;
            this.linecap = linecap;
            this.linejoin = linejoin;
            this.miterlimit = miterlimit;
            this.dashes = dashes;
            this.dashOffset = dashOffset;
            this.numClipPaths = numClipPaths;
            this.font = font;
            this.fontsmoothing = smoothing;
            this.textalign = align;
            this.textbaseline = baseline;
            this.effect = effect;
            this.fillRule = fillRule;
        }

        State copy() {
            return new State(this);
        }

        void restore(GraphicsContext ctx) {
            ctx.setGlobalAlpha(globalAlpha);
            ctx.setGlobalBlendMode(blendop);
            ctx.setTransform(transform.getMxx(), transform.getMyx(),
                             transform.getMxy(), transform.getMyy(),
                             transform.getMxt(), transform.getMyt());
            ctx.setFill(fill);
            ctx.setStroke(stroke);
            ctx.setLineWidth(linewidth);
            ctx.setLineCap(linecap);
            ctx.setLineJoin(linejoin);
            ctx.setMiterLimit(miterlimit);
            ctx.setLineDashes(dashes);
            ctx.setLineDashOffset(dashOffset);
            GrowableDataBuffer buf = ctx.getBuffer();
            while (ctx.curState.numClipPaths &gt; numClipPaths) {
                ctx.curState.numClipPaths--;
                ctx.clipStack.removeLast();
                buf.putByte(NGCanvas.POP_CLIP);
            }
            ctx.setFillRule(fillRule);
            ctx.setFont(font);
            ctx.setFontSmoothingType(fontsmoothing);
            ctx.setTextAlign(textalign);
            ctx.setTextBaseline(textbaseline);
            ctx.setEffect(effect);
        }
    }

    private GrowableDataBuffer getBuffer() {
        return theCanvas.getBuffer();
    }

    private float coords[] = new float[6];
    private static final byte pgtype[] = {
        NGCanvas.MOVETO,
        NGCanvas.LINETO,
        NGCanvas.QUADTO,
        NGCanvas.CUBICTO,
        NGCanvas.CLOSEPATH,
    };
    private static final int numsegs[] = { 2, 2, 4, 6, 0, };

    private void markPathDirty() {
        pathDirty = true;
    }

    private void writePath(byte command) {
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        if (pathDirty) {
            buf.putByte(NGCanvas.PATHSTART);
            PathIterator pi = path.getPathIterator(null);
            while (!pi.isDone()) {
                int pitype = pi.currentSegment(coords);
                buf.putByte(pgtype[pitype]);
                for (int i = 0; i &lt; numsegs[pitype]; i++) {
                    buf.putFloat(coords[i]);
                }
                pi.next();
            }
            buf.putByte(NGCanvas.PATHEND);
            pathDirty = false;
        }
        buf.putByte(command);
    }

    private void writePaint(Paint p, byte command) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putObject(Toolkit.getPaintAccessor().getPlatformPaint(p));
    }

    private void writeArcType(ArcType closure) {
        byte type;
        switch (closure) {
            case OPEN:  type = NGCanvas.ARC_OPEN;  break;
            case CHORD: type = NGCanvas.ARC_CHORD; break;
            case ROUND: type = NGCanvas.ARC_PIE;   break;
            default: return;  // ignored for consistency with other attributes
        }
        writeParam(type, NGCanvas.ARC_TYPE);
    }

    private void writeRectParams(GrowableDataBuffer buf,
                                 double x, double y, double w, double h,
                                 byte command)
    {
        buf.putByte(command);
        buf.putFloat((float) x);
        buf.putFloat((float) y);
        buf.putFloat((float) w);
        buf.putFloat((float) h);
    }

    private void writeOp4(double x, double y, double w, double h, byte command) {
        updateTransform();
        writeRectParams(getBuffer(), x, y, w, h, command);
    }

    private void writeOp6(double x, double y, double w, double h,
                          double v1, double v2, byte command)
    {
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putFloat((float) x);
        buf.putFloat((float) y);
        buf.putFloat((float) w);
        buf.putFloat((float) h);
        buf.putFloat((float) v1);
        buf.putFloat((float) v2);
    }

    private float polybuf[] = new float[512];
    private void flushPolyBuf(GrowableDataBuffer buf,
                              float polybuf[], int n, byte command)
    {
        curState.transform.transform(polybuf, 0, polybuf, 0, n/2);
        for (int i = 0; i &lt; n; i += 2) {
            buf.putByte(command);
            buf.putFloat(polybuf[i]);
            buf.putFloat(polybuf[i+1]);
            command = NGCanvas.LINETO;
        }
    }
    private void writePoly(double xPoints[], double yPoints[], int nPoints,
                           boolean close, byte command)
    {
        if (xPoints == null || yPoints == null) return;
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.PATHSTART);
        int pos = 0;
        byte polycmd = NGCanvas.MOVETO;
        for (int i = 0; i &lt; nPoints; i++) {
            if (pos &gt;= polybuf.length) {
                flushPolyBuf(buf, polybuf, pos, polycmd);
                pos = 0;
                polycmd = NGCanvas.LINETO;
            }
            polybuf[pos++] = (float) xPoints[i];
            polybuf[pos++] = (float) yPoints[i];
        }
        flushPolyBuf(buf, polybuf, pos, polycmd);
        if (close) {
            buf.putByte(NGCanvas.CLOSEPATH);
        }
        buf.putByte(NGCanvas.PATHEND);
        // Transform needs to be updated for rendering attributes even though
        // we have already transformed the points as we sent them.
        updateTransform();
        buf.putByte(command);
        // Now that we have changed the PG layer path, we need to mark our path dirty.
        markPathDirty();
    }

    private void writeImage(Image img,
                            double dx, double dy, double dw, double dh)
    {
        if (img == null || img.getProgress() &lt; 1.0) return;
        Object platformImg = Toolkit.getImageAccessor().getPlatformImage(img);
        if (platformImg == null) return;
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        writeRectParams(buf, dx, dy, dw, dh, NGCanvas.DRAW_IMAGE);
        buf.putObject(platformImg);
    }

    private void writeImage(Image img,
                            double dx, double dy, double dw, double dh,
                            double sx, double sy, double sw, double sh)
    {
        if (img == null || img.getProgress() &lt; 1.0) return;
        Object platformImg = Toolkit.getImageAccessor().getPlatformImage(img);
        if (platformImg == null) return;
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        writeRectParams(buf, dx, dy, dw, dh, NGCanvas.DRAW_SUBIMAGE);
        buf.putFloat((float) sx);
        buf.putFloat((float) sy);
        buf.putFloat((float) sw);
        buf.putFloat((float) sh);
        buf.putObject(platformImg);
    }

    private void writeText(String text, double x, double y, double maxWidth,
                           byte command)
    {
        if (text == null) return;
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putFloat((float) x);
        buf.putFloat((float) y);
        buf.putFloat((float) maxWidth);
        buf.putBoolean(theCanvas.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
        buf.putObject(text);
    }

    void writeParam(double v, byte command) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putFloat((float) v);
    }

    private void writeParam(byte v, byte command) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putByte(v);
    }

    private boolean txdirty;
    private void updateTransform() {
        if (txdirty) {
            txdirty = false;
            GrowableDataBuffer buf = getBuffer();
            buf.putByte(NGCanvas.TRANSFORM);
            buf.putDouble(curState.transform.getMxx());
            buf.putDouble(curState.transform.getMxy());
            buf.putDouble(curState.transform.getMxt());
            buf.putDouble(curState.transform.getMyx());
            buf.putDouble(curState.transform.getMyy());
            buf.putDouble(curState.transform.getMyt());
        }
    }

    void updateDimensions() {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.SET_DIMS);
        buf.putFloat((float) theCanvas.getWidth());
        buf.putFloat((float) theCanvas.getHeight());
    }

    private void reset() {
        GrowableDataBuffer buf = getBuffer();
        // Only reset if we have a significant amount of data to omit,
        // this prevents a common occurrence of &quot;setFill(bg); fillRect();&quot;
        // at the start of a session from invoking a reset.
        // But, do a reset anyway if the rendering layer has been falling
        // behind because that lets the synchronization step throw out the
        // older buffers that have been backing up.
        if (buf.writeValuePosition() &gt; Canvas.DEFAULT_VAL_BUF_SIZE ||
            theCanvas.isRendererFallingBehind())
        {
            buf.reset();
            buf.putByte(NGCanvas.RESET);
            updateDimensions();
            txdirty = true;
            pathDirty = true;
            State s = this.curState;
            int numClipPaths = this.curState.numClipPaths;
            this.curState = new State();
            for (int i = 0; i &lt; numClipPaths; i++) {
                Path2D clip = clipStack.get(i);
                buf.putByte(NGCanvas.PUSH_CLIP);
                buf.putObject(clip);
            }
            this.curState.numClipPaths = numClipPaths;
            s.restore(this);
        }
    }

    private void resetIfCovers(Paint p, double x, double y, double w, double h) {
        Affine2D tx = this.curState.transform;
        if (tx.isTranslateOrIdentity()) {
            x += tx.getMxt();
            y += tx.getMyt();
            if (x &gt; 0 || y &gt; 0 ||
                (x+w) &lt; theCanvas.getWidth() ||
                (y+h) &lt; theCanvas.getHeight())
            {
                return;
            }
        } else {
//          quad test for coverage...?
            return;
        }
        if (p != null) {
            if (this.curState.blendop != BlendMode.SRC_OVER) return;
            if (!p.isOpaque() || this.curState.globalAlpha &lt; 1.0) return;
        }
        if (this.curState.numClipPaths &gt; 0) return;
        if (this.curState.effect != null) return;
        reset();
    }

    /**
    * Gets the {@code Canvas} that the {@code GraphicsContext} is issuing draw
    * commands to. There is only ever one {@code Canvas} for a
    * {@code GraphicsContext}.
    *
    * @return Canvas the canvas that this {@code GraphicsContext} is issuing draw
    * commands to.
    */
    public Canvas getCanvas() {
        return theCanvas;
    }

    /**
     * Saves the following attributes onto a stack.
     * &lt;ul&gt;
     *     &lt;li&gt;Global Alpha&lt;/li&gt;
     *     &lt;li&gt;Global Blend Operation&lt;/li&gt;
     *     &lt;li&gt;Transform&lt;/li&gt;
     *     &lt;li&gt;Fill Paint&lt;/li&gt;
     *     &lt;li&gt;Stroke Paint&lt;/li&gt;
     *     &lt;li&gt;Line Width&lt;/li&gt;
     *     &lt;li&gt;Line Cap&lt;/li&gt;
     *     &lt;li&gt;Line Join&lt;/li&gt;
     *     &lt;li&gt;Miter Limit&lt;/li&gt;
     *     &lt;li&gt;Clip&lt;/li&gt;
     *     &lt;li&gt;Font&lt;/li&gt;
     *     &lt;li&gt;Text Align&lt;/li&gt;
     *     &lt;li&gt;Text Baseline&lt;/li&gt;
     *     &lt;li&gt;Effect&lt;/li&gt;
     *     &lt;li&gt;Fill Rule&lt;/li&gt;
     * &lt;/ul&gt;
     * This method does NOT alter the current state in any way. Also, note that
     * the current path is not saved.
     */
    public void save() {
        stateStack.push(curState.copy());
    }

    /**
     * Pops the state off of the stack, setting the following attributes to their
     * value at the time when that state was pushed onto the stack. If the stack
     * is empty then nothing is changed.
     *
     * &lt;ul&gt;
     *     &lt;li&gt;Global Alpha&lt;/li&gt;
     *     &lt;li&gt;Global Blend Operation&lt;/li&gt;
     *     &lt;li&gt;Transform&lt;/li&gt;
     *     &lt;li&gt;Fill Paint&lt;/li&gt;
     *     &lt;li&gt;Stroke Paint&lt;/li&gt;
     *     &lt;li&gt;Line Width&lt;/li&gt;
     *     &lt;li&gt;Line Cap&lt;/li&gt;
     *     &lt;li&gt;Line Join&lt;/li&gt;
     *     &lt;li&gt;Miter Limit&lt;/li&gt;
     *     &lt;li&gt;Clip&lt;/li&gt;
     *     &lt;li&gt;Font&lt;/li&gt;
     *     &lt;li&gt;Text Align&lt;/li&gt;
     *     &lt;li&gt;Text Baseline&lt;/li&gt;
     *     &lt;li&gt;Effect&lt;/li&gt;
     *     &lt;li&gt;Fill Rule&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that the current path is not restored.
     */
    public void restore() {
        if (!stateStack.isEmpty()) {
            State savedState = stateStack.pop();
            savedState.restore(this);
            txdirty = true;
        }
    }

    /**
     * Translates the current transform by x, y.
     * @param x value to translate along the x axis.
     * @param y value to translate along the y axis.
     */
    public void translate(double x, double y) {
        curState.transform.translate(x, y);
        txdirty = true;
    }

    /**
     * Scales the current transform by x, y.
     * @param x value to scale in the x axis.
     * @param y value to scale in the y axis.
     */
    public void scale(double x, double y) {
        curState.transform.scale(x, y);
        txdirty = true;
    }

    /**
     * Rotates the current transform in degrees.
     * @param degrees value in degrees to rotate the current transform.
     */
    public void rotate(double degrees) {
        curState.transform.rotate(Math.toRadians(degrees));
        txdirty = true;
    }

    /**
     * Concatenates the input with the current transform.
     *
     * @param mxx - the X coordinate scaling element of the 3x4 matrix
     * @param myx - the Y coordinate shearing element of the 3x4 matrix
     * @param mxy - the X coordinate shearing element of the 3x4 matrix
     * @param myy - the Y coordinate scaling element of the 3x4 matrix
     * @param mxt - the X coordinate translation element of the 3x4 matrix
     * @param myt - the Y coordinate translation element of the 3x4 matrix
     */
    public void transform(double mxx, double myx,
                          double mxy, double myy,
                          double mxt, double myt)
    {
        curState.transform.concatenate(mxx, mxy, mxt,
                                       myx, myy, myt);
        txdirty = true;
    }

    /**
     * Concatenates the input with the current transform. Only 2D transforms are
     * supported. The only values used are the X and Y scaling, translation, and
     * shearing components of a transform. A {@code null} value is treated as identity.
     *
     * @param xform The affine to be concatenated with the current transform or null.
     */
    public void transform(Affine xform) {
        if (xform == null) return;
        curState.transform.concatenate(xform.getMxx(), xform.getMxy(), xform.getTx(),
                                       xform.getMyx(), xform.getMyy(), xform.getTy());
        txdirty = true;
    }

    /**
     * Sets the current transform.
     * @param mxx - the X coordinate scaling element of the 3x4 matrix
     * @param myx - the Y coordinate shearing element of the 3x4 matrix
     * @param mxy - the X coordinate shearing element of the 3x4 matrix
     * @param myy - the Y coordinate scaling element of the 3x4 matrix
     * @param mxt - the X coordinate translation element of the 3x4 matrix
     * @param myt - the Y coordinate translation element of the 3x4 matrix
     */
    public void setTransform(double mxx, double myx,
                             double mxy, double myy,
                             double mxt, double myt)
    {
        curState.transform.setTransform(mxx, myx,
                                        mxy, myy,
                                        mxt, myt);
        txdirty = true;
    }

    /**
     * Sets the current transform. Only 2D transforms are supported. The only
     * values used are the X and Y scaling, translation, and shearing components
     * of a transform.
     *
     * @param xform The affine to be copied and used as the current transform.
     */
    public void setTransform(Affine xform) {
        curState.transform.setTransform(xform.getMxx(), xform.getMyx(),
                                        xform.getMxy(), xform.getMyy(),
                                        xform.getTx(), xform.getTy());
        txdirty = true;
    }

    /**
     * Copies the current transform into the supplied object, creating
     * a new {@link Affine} object if it is null, and returns the object
     * containing the copy.
     *
     * @param xform A transform object that will be used to hold the result.
     * If xform is non null, then this method will copy the current transform
     * into that object. If xform is null a new transform object will be
     * constructed. In either case, the return value is a copy of the current
     * transform.
     *
     * @return A copy of the current transform.
     */
    public Affine getTransform(Affine xform) {
        if (xform == null) {
            xform = new Affine();
        }
<A NAME="7"></A>
        xform.setMxx(curState.transform.getMxx());
        xform.setMxy(curState.transform.getMxy());
        <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#7',2,'match58-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>xform.setMxz(0);
        xform.setTx(curState.transform.getMxt());
        xform.setMyx(curState.transform.getMyx());
        xform.setMyy(curState.transform.getMyy());
        xform.setMyz(0);
        xform.setTy(curState.transform.getMyt());
        xform.setMzx(0);
        xform.setMzy(0);
        xform.setMzz(1);
        xform.setTz(0);

        return xform;
    }

    /**
     * Returns a copy of the current transform.
     *
     * @return a copy of the transform of the current state.
     */
    public Affine getTransform() {</B></FONT>
        return getTransform(null);
    }

    /**
     * Sets the global alpha of the current state.
     * The default value is {@code 1.0}.
     * Any valid double can be set, but only values in the range
     * {@code [0.0, 1.0]} are valid and the nearest value in that
     * range will be used for rendering.
     * The global alpha is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param alpha the new alpha value, clamped to {@code [0.0, 1.0]}
     *              during actual use.
     */
    public void setGlobalAlpha(double alpha) {
        if (curState.globalAlpha != alpha) {
            curState.globalAlpha = alpha;
            alpha = (alpha &gt; 1.0) ? 1.0 : (alpha &lt; 0.0) ? 0.0 : alpha;
            writeParam(alpha, NGCanvas.GLOBAL_ALPHA);
        }
    }

    /**
     * Gets the current global alpha.
     * The default value is {@code 1.0}.
     * The global alpha is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the current global alpha.
     */
    public double getGlobalAlpha() {
        return curState.globalAlpha;
    }

    /**
     * Sets the global blend mode.
     * The default value is {@link BlendMode#SRC_OVER SRC_OVER}.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     * The blend mode is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param op the {@code BlendMode} that will be set or null.
     */
    public void setGlobalBlendMode(BlendMode op) {
        if (op != null &amp;&amp; op != curState.blendop) {
            GrowableDataBuffer buf = getBuffer();
            curState.blendop = op;
            buf.putByte(NGCanvas.COMP_MODE);
            buf.putObject(EffectHelper.getToolkitBlendMode(op));
        }
    }

    /**
     * Gets the global blend mode.
     * The default value is {@link BlendMode#SRC_OVER SRC_OVER}.
     * The blend mode is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the global {@code BlendMode} of the current state.
     */
    public BlendMode getGlobalBlendMode() {
        return curState.blendop;
    }

    /**
     * Sets the current fill paint attribute.
     * The default value is {@link Color#BLACK BLACK}.
     * The fill paint is a &lt;a href=&quot;#fill-attr&quot;&gt;fill attribute&lt;/a&gt;
     * used for any of the fill methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param p The {@code Paint} to be used as the fill {@code Paint} or null.
     */
    public void setFill(Paint p) {
        if (p != null &amp;&amp; curState.fill != p) {
            curState.fill = p;
            writePaint(p, NGCanvas.FILL_PAINT);
        }
    }

    /**
     * Gets the current fill paint attribute.
     * The default value is {@link Color#BLACK BLACK}.
     * The fill paint is a &lt;a href=&quot;#fill-attr&quot;&gt;fill attribute&lt;/a&gt;
     * used for any of the fill methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return p The {@code Paint} to be used as the fill {@code Paint}.
     */
    public Paint getFill() {
        return curState.fill;
    }

    /**
     * Sets the current stroke paint attribute.
     * The default value is {@link Color#BLACK BLACK}.
     * The stroke paint is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param p The Paint to be used as the stroke Paint or null.
     */
    public void setStroke(Paint p) {
        if (p != null &amp;&amp; curState.stroke != p) {
            curState.stroke = p;
            writePaint(p, NGCanvas.STROKE_PAINT);
        }
    }

    /**
     * Gets the current stroke.
     * The default value is {@link Color#BLACK BLACK}.
     * The stroke paint is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the {@code Paint} to be used as the stroke {@code Paint}.
     */
    public Paint getStroke() {
        return curState.stroke;
    }

    /**
     * Sets the current line width.
     * The default value is {@code 1.0}.
     * The line width is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * An infinite or non-positive value outside of the range {@code (0, +inf)}
     * will be ignored and the current value will remain unchanged.
     *
     * @param lw value in the range {0-positive infinity}, with any other value
     * being ignored and leaving the value unchanged.
     */
    public void setLineWidth(double lw) {
        // Per W3C spec: On setting, zero, negative, infinite, and NaN
        // values must be ignored, leaving the value unchanged
        if (lw &gt; 0 &amp;&amp; lw &lt; Double.POSITIVE_INFINITY) {
            if (curState.linewidth != lw) {
                curState.linewidth = lw;
                writeParam(lw, NGCanvas.LINE_WIDTH);
            }
        }
    }

    /**
     * Gets the current line width.
     * The default value is {@code 1.0}.
     * The line width is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return value between 0 and infinity.
     */
    public double getLineWidth() {
        return curState.linewidth;
    }

    /**
     * Sets the current stroke line cap.
     * The default value is {@link StrokeLineCap#SQUARE SQUARE}.
     * The line cap is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param cap {@code StrokeLineCap} with a value of Butt, Round, or Square or null.
     */
    public void setLineCap(StrokeLineCap cap) {
        if (cap != null &amp;&amp; curState.linecap != cap) {
            byte v;
            switch (cap) {
                case BUTT: v = NGCanvas.CAP_BUTT; break;
                case ROUND: v = NGCanvas.CAP_ROUND; break;
                case SQUARE: v = NGCanvas.CAP_SQUARE; break;
                default: return;
            }
            curState.linecap = cap;
            writeParam(v, NGCanvas.LINE_CAP);
        }
    }

    /**
     * Gets the current stroke line cap.
     * The default value is {@link StrokeLineCap#SQUARE SQUARE}.
     * The line cap is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code StrokeLineCap} with a value of Butt, Round, or Square.
     */
    public StrokeLineCap getLineCap() {
        return curState.linecap;
    }

    /**
     * Sets the current stroke line join.
     * The default value is {@link StrokeLineJoin#MITER}.
     * The line join is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param join {@code StrokeLineJoin} with a value of Miter, Bevel, or Round or null.
     */
    public void setLineJoin(StrokeLineJoin join) {
        if (join != null &amp;&amp; curState.linejoin != join) {
            byte v;
            switch (join) {
                case MITER: v = NGCanvas.JOIN_MITER; break;
                case BEVEL: v = NGCanvas.JOIN_BEVEL; break;
                case ROUND: v = NGCanvas.JOIN_ROUND; break;
                default: return;
            }
            curState.linejoin = join;
            writeParam(v, NGCanvas.LINE_JOIN);
        }
    }

    /**
     * Gets the current stroke line join.
     * The default value is {@link StrokeLineJoin#MITER}.
     * The line join is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code StrokeLineJoin} with a value of Miter, Bevel, or Round.
     */
    public StrokeLineJoin getLineJoin() {
        return curState.linejoin;
    }

    /**
     * Sets the current miter limit.
     * The default value is {@code 10.0}.
     * The miter limit is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * An infinite or non-positive value outside of the range {@code (0, +inf)}
     * will be ignored and the current value will remain unchanged.
     *
     * @param ml miter limit value between 0 and positive infinity with
     * any other value being ignored and leaving the value unchanged.
     */
    public void setMiterLimit(double ml) {
        // Per W3C spec: On setting, zero, negative, infinite, and NaN
        // values must be ignored, leaving the value unchanged
        if (ml &gt; 0.0 &amp;&amp; ml &lt; Double.POSITIVE_INFINITY) {
            if (curState.miterlimit != ml) {
                curState.miterlimit = ml;
                writeParam(ml, NGCanvas.MITER_LIMIT);
            }
        }
    }

    /**
     * Gets the current miter limit.
     * The default value is {@code 10.0}.
     * The miter limit is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the miter limit value in the range {@code 0.0-positive infinity}
     */
    public double getMiterLimit() {
        return curState.miterlimit;
    }

    /**
     * Sets the current stroke line dash pattern to a normalized copy of
     * the argument.
     * The default value is {@code null}.
     * The line dash array is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * If the array is {@code null} or empty or contains all {@code 0} elements
     * then dashing will be disabled and the current dash array will be set
     * to {@code null}.
     * If any of the elements of the array are a negative, infinite, or NaN
     * value outside the range {@code [0, +inf)} then the entire array will
     * be ignored and the current dash array will remain unchanged.
     * If the array is an odd length then it will be treated as if it
     * were two copies of the array appended to each other.
     *
     * @param dashes the array of finite non-negative dash lengths
     * @since JavaFX 8u40
     */
    public void setLineDashes(double... dashes) {
        if (dashes == null || dashes.length == 0) {
            if (curState.dashes == null) {
                return;
            }
            curState.dashes = null;
        } else {
            boolean allZeros = true;
            for (int i = 0; i &lt; dashes.length; i++) {
                double d = dashes[i];
                if (d &gt;= 0.0 &amp;&amp; d &lt; Double.POSITIVE_INFINITY) {
                    // Non-NaN, finite, non-negative
                    // Test cannot be inverted or it will not implicitly test for NaN
                    if (d &gt; 0) {
                        allZeros = false;
                    }
                } else {
                    return;
                }
            }
            if (allZeros) {
                if (curState.dashes == null) {
                    return;
                }
                curState.dashes = null;
            } else {
                int dashlen = dashes.length;
                if ((dashlen &amp; 1) == 0) {
                    curState.dashes = Arrays.copyOf(dashes, dashlen);
                } else {
                    curState.dashes = Arrays.copyOf(dashes, dashlen * 2);
                    System.arraycopy(dashes, 0, curState.dashes, dashlen, dashlen);
                }
            }
        }
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.DASH_ARRAY);
        buf.putObject(curState.dashes);
    }

    /**
     * Gets a copy of the current line dash array.
     * The default value is {@code null}.
     * The array may be normalized by the validation tests in the
     * {@link #setLineDashes(double...)} method.
     * The line dash array is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return a copy of the current line dash array.
     * @since JavaFX 8u40
     */
    public double[] getLineDashes() {
        if (curState.dashes == null) {
            return null;
        }
        return Arrays.copyOf(curState.dashes, curState.dashes.length);
    }

    /**
     * Sets the line dash offset.
     * The default value is {@code 0.0}.
     * The line dash offset is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * An infinite or NaN value outside of the range {@code (-inf, +inf)}
     * will be ignored and the current value will remain unchanged.
     *
     * @param dashOffset the line dash offset in the range {@code (-inf, +inf)}
     * @since JavaFX 8u40
     */
    public void setLineDashOffset(double dashOffset) {
        // Per W3C spec: On setting, infinite, and NaN
        // values must be ignored, leaving the value unchanged
        if (dashOffset &gt; Double.NEGATIVE_INFINITY &amp;&amp; dashOffset &lt; Double.POSITIVE_INFINITY) {
            curState.dashOffset = dashOffset;
            writeParam(dashOffset, NGCanvas.DASH_OFFSET);
        }
    }

    /**
     * Gets the current line dash offset.
     * The default value is {@code 0.0}.
     * The line dash offset is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the line dash offset in the range {@code (-inf, +inf)}
     * @since JavaFX 8u40
     */
    public double getLineDashOffset() {
        return curState.dashOffset;
    }

    /**
     * Sets the current Font.
     * The default value is specified by {@link Font#getDefault()}.
     * The font is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param f the Font or null.
     */
    public void setFont(Font f) {
        if (f != null &amp;&amp; curState.font != f) {
            curState.font = f;
            GrowableDataBuffer buf = getBuffer();
            buf.putByte(NGCanvas.FONT);
            buf.putObject(FontHelper.getNativeFont(f));
        }
    }

    /**
     * Gets the current Font.
     * The default value is specified by {@link Font#getDefault()}.
     * The font is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the Font
     */
    public Font getFont() {
        return curState.font;
    }

    /**
     * Sets the current Font Smoothing Type.
     * The default value is {@link FontSmoothingType#GRAY GRAY}.
     * The font smoothing type is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt; that the {@code FontSmoothingType} value of
     * {@link FontSmoothingType#LCD LCD} is only supported over an opaque
     * background.  {@code LCD} text will generally appear as {@code GRAY}
     * text over transparent or partially transparent pixels, and in some
     * implementations it may not be supported at all on a {@link Canvas}
     * because the required support does not exist for surfaces which contain
     * an alpha channel as all {@code Canvas} objects do.
     *
     * @param fontsmoothing the {@link FontSmoothingType} or null
     * @since JavaFX 8u40
     */
    public void setFontSmoothingType(FontSmoothingType fontsmoothing) {
        if (fontsmoothing != null &amp;&amp; fontsmoothing != curState.fontsmoothing) {
            curState.fontsmoothing = fontsmoothing;
            writeParam((byte) fontsmoothing.ordinal(), NGCanvas.FONT_SMOOTH);
        }
    }

    /**
     * Gets the current Font Smoothing Type.
     * The default value is {@link FontSmoothingType#GRAY GRAY}.
     * The font smoothing type is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the {@link FontSmoothingType}
     * @since JavaFX 8u40
     */
    public FontSmoothingType getFontSmoothingType() {
        return curState.fontsmoothing;
    }

    /**
     * Defines horizontal text alignment, relative to the text {@code x} origin.
     * The default value is {@link TextAlignment#LEFT LEFT}.
     * The text alignment is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;p&gt;
     * Let horizontal bounds represent the logical width of a single line of
     * text. Where each line of text has a separate horizontal bounds.
     * &lt;p&gt;
     * Then TextAlignment is specified as:
     * &lt;ul&gt;
     * &lt;li&gt;Left: the left edge of the horizontal bounds will be at {@code x}.
     * &lt;li&gt;Center: the center, halfway between left and right edge, of the
     * horizontal bounds will be at {@code x}.
     * &lt;li&gt;Right: the right edge of the horizontal bounds will be at {@code x}.
     * &lt;/ul&gt;
     * &lt;p&gt;
     *
     * Note: Canvas does not support line wrapping, therefore the text
     * alignment Justify is identical to left aligned text.
     * &lt;p&gt;
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param align {@code TextAlignment} with values of Left, Center, Right or null.
     */
    public void setTextAlign(TextAlignment align) {
        if (align != null &amp;&amp; curState.textalign != align) {
            byte a;
            switch (align) {
                case LEFT: a = NGCanvas.ALIGN_LEFT; break;
                case CENTER: a = NGCanvas.ALIGN_CENTER; break;
                case RIGHT: a = NGCanvas.ALIGN_RIGHT; break;
                case JUSTIFY: a = NGCanvas.ALIGN_JUSTIFY; break;
                default: return;
            }
            curState.textalign = align;
            writeParam(a, NGCanvas.TEXT_ALIGN);
        }
    }

    /**
     * Gets the current {@code TextAlignment}.
     * The default value is {@link TextAlignment#LEFT LEFT}.
     * The text alignment is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code TextAlignment} with values of Left, Center, Right, or
     * Justify.
     */
    public TextAlignment getTextAlign() {
        return curState.textalign;
    }

    /**
     * Sets the current Text Baseline.
     * The default value is {@link VPos#BASELINE BASELINE}.
     * The text baseline is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param baseline {@code VPos} with values of Top, Center, Baseline, or Bottom or null.
     */
    public void setTextBaseline(VPos baseline) {
        if (baseline != null &amp;&amp; curState.textbaseline != baseline) {
            byte b;
            switch (baseline) {
                case TOP: b = NGCanvas.BASE_TOP; break;
                case CENTER: b = NGCanvas.BASE_MIDDLE; break;
                case BASELINE: b = NGCanvas.BASE_ALPHABETIC; break;
                case BOTTOM: b = NGCanvas.BASE_BOTTOM; break;
                default: return;
            }
            curState.textbaseline = baseline;
            writeParam(b, NGCanvas.TEXT_BASELINE);
        }
    }

    /**
     * Gets the current Text Baseline.
     * The default value is {@link VPos#BASELINE BASELINE}.
     * The text baseline is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code VPos} with values of Top, Center, Baseline, or Bottom
     */
    public VPos getTextBaseline() {
        return curState.textbaseline;
    }

    /**
     * Fills the given string of text at position x, y
     * with the current fill paint attribute.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     */
    public void fillText(String text, double x, double y) {
        writeText(text, x, y, 0, NGCanvas.FILL_TEXT);
    }

    /**
     * Draws the given string of text at position x, y
     * with the current stroke paint attribute.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     */
    public void strokeText(String text, double x, double y) {
        writeText(text, x, y, 0, NGCanvas.STROKE_TEXT);
    }

    /**
     * Fills text and includes a maximum width of the string.
     * If the width of the text extends past max width, then it will be sized
     * to fit.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     * @param maxWidth  maximum width the text string can have.
     */
    public void fillText(String text, double x, double y, double maxWidth) {
        if (maxWidth &lt;= 0) return;
        writeText(text, x, y, maxWidth, NGCanvas.FILL_TEXT);
    }

    /**
     * Draws text with stroke paint and includes a maximum width of the string.
     * If the width of the text extends past max width, then it will be sized
     * to fit.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     * @param maxWidth  maximum width the text string can have.
     */
    public void strokeText(String text, double x, double y, double maxWidth) {
        if (maxWidth &lt;= 0) return;
        writeText(text, x, y, maxWidth, NGCanvas.STROKE_TEXT);
    }


    /**
     * Set the filling rule attribute for determining the interior of paths
     * in fill or clip operations.
     * The default value is {@code FillRule.NON_ZERO}.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     * The fill rule is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the fill or clip path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param fillRule {@code FillRule} with a value of  Even_odd or Non_zero or null.
     */
     public void setFillRule(FillRule fillRule) {
         if (fillRule != null &amp;&amp; curState.fillRule != fillRule) {
            byte b;
            if (fillRule == FillRule.EVEN_ODD) {
                b = NGCanvas.FILL_RULE_EVEN_ODD;
            } else {
                b = NGCanvas.FILL_RULE_NON_ZERO;
            }
            curState.fillRule = fillRule;
            writeParam(b, NGCanvas.FILL_RULE);
        }
     }

    /**
     * Get the filling rule attribute for determining the interior of paths
     * in fill and clip operations.
     * The default value is {@code FillRule.NON_ZERO}.
     * The fill rule is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the fill or clip path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return current fill rule.
     */
     public FillRule getFillRule() {
         return curState.fillRule;
     }

    /**
     * Resets the current path to empty.
     * The default path is empty.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     */
    public void beginPath() {
        path.reset();
        markPathDirty();
    }

    /**
     * Issues a move command for the current path to the given x,y coordinate.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param x0 the X position for the move to command.
     * @param y0 the Y position for the move to command.
     */
    public void moveTo(double x0, double y0) {
        coords[0] = (float) x0;
        coords[1] = (float) y0;
        curState.transform.transform(coords, 0, coords, 0, 1);
        path.moveTo(coords[0], coords[1]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make a line to the given x,y
     * coordinate.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param x1 the X coordinate of the ending point of the line.
     * @param y1 the Y coordinate of the ending point of the line.
     */
    public void lineTo(double x1, double y1) {
        coords[0] = (float) x1;
        coords[1] = (float) y1;
        curState.transform.transform(coords, 0, coords, 0, 1);
        if (path.getNumCommands() == 0) {
            path.moveTo(coords[0], coords[1]);
        }
        path.lineTo(coords[0], coords[1]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make a quadratic Bezier curve.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param xc the X coordinate of the control point
     * @param yc the Y coordinate of the control point
     * @param x1 the X coordinate of the end point
     * @param y1 the Y coordinate of the end point
     */
    public void quadraticCurveTo(double xc, double yc, double x1, double y1) {
        coords[0] = (float) xc;
        coords[1] = (float) yc;
        coords[2] = (float) x1;
        coords[3] = (float) y1;
        curState.transform.transform(coords, 0, coords, 0, 2);
        if (path.getNumCommands() == 0) {
            path.moveTo(coords[0], coords[1]);
        }
        path.quadTo(coords[0], coords[1], coords[2], coords[3]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make a cubic Bezier curve.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param xc1 the X coordinate of first Bezier control point.
     * @param yc1 the Y coordinate of the first Bezier control point.
     * @param xc2 the X coordinate of the second Bezier control point.
     * @param yc2 the Y coordinate of the second Bezier control point.
     * @param x1  the X coordinate of the end point.
     * @param y1  the Y coordinate of the end point.
     */
    public void bezierCurveTo(double xc1, double yc1, double xc2, double yc2, double x1, double y1) {
        coords[0] = (float) xc1;
        coords[1] = (float) yc1;
        coords[2] = (float) xc2;
        coords[3] = (float) yc2;
        coords[4] = (float) x1;
        coords[5] = (float) y1;
        curState.transform.transform(coords, 0, coords, 0, 3);
        if (path.getNumCommands() == 0) {
            path.moveTo(coords[0], coords[1]);
        }
        path.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make an arc.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     * &lt;p&gt;
     * If {@code p0} is the current point in the path and {@code p1} is the
     * point specified by {@code (x1, y1)} and {@code p2} is the point
     * specified by {@code (x2, y2)}, then the arc segments appended will
     * be segments along the circumference of a circle of the specified
     * radius touching and inscribed into the convex (interior) side of
     * {@code p0-&gt;p1-&gt;p2}.  The path will contain a line segment (if
     * needed) to the tangent point between that circle and {@code p0-&gt;p1}
     * followed by circular arc segments to reach the tangent point between
     * the circle and {@code p1-&gt;p2} and will end with the current point at
     * that tangent point (not at {@code p2}).
     * Note that the radius and circularity of the arc segments will be
     * measured or considered relative to the current transform, but the
     * resulting segments that are computed from those untransformed
     * points will then be transformed when they are added to the path.
     * Since all computation is done in untransformed space, but the
     * pre-existing path segments are all transformed, the ability to
     * correctly perform the computation may implicitly depend on being
     * able to inverse transform the current end of the current path back
     * into untransformed coordinates.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If there is no way to compute and inscribe the indicated circle
     * for any reason then the entire operation will simply append segments
     * to force a line to point {@code p1}.  Possible reasons that the
     * computation may fail include:
     * &lt;ul&gt;
     * &lt;li&gt;The current path is empty.&lt;/li&gt;
     * &lt;li&gt;The segments {@code p0-&gt;p1-&gt;p2} are colinear.&lt;/li&gt;
     * &lt;li&gt;the current transform is non-invertible so that the current end
     * point of the current path cannot be untransformed for computation.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param x1 the X coordinate of the first point of the arc.
     * @param y1 the Y coordinate of the first point of the arc.
     * @param x2 the X coordinate of the second point of the arc.
     * @param y2 the Y coordinate of the second point of the arc.
     * @param radius the radius of the arc in the range {0.0-positive infinity}.
     */
    public void arcTo(double x1, double y1, double x2, double y2, double radius) {
        if (path.getNumCommands() == 0) {
            moveTo(x1, y1);
            lineTo(x1, y1);
        } else if (!tryArcTo((float) x1, (float) y1, (float) x2, (float) y2,
                             (float) radius))
        {
            lineTo(x1, y1);
        }
    }

    private static double lenSq(double x0, double y0, double x1, double y1) {
        x1 -= x0;
        y1 -= y0;
        return x1 * x1 + y1 * y1;
    }

    private boolean tryArcTo(float x1, float y1, float x2, float y2, float radius) {
        float x0, y0;
        if (curState.transform.isTranslateOrIdentity()) {
            x0 = (float) (path.getCurrentX() - curState.transform.getMxt());
            y0 = (float) (path.getCurrentY() - curState.transform.getMyt());
        } else {
            coords[0] = path.getCurrentX();
            coords[1] = path.getCurrentY();
            try {
                curState.transform.inverseTransform(coords, 0, coords, 0, 1);
            } catch (NoninvertibleTransformException e) {
                return false;
            }
            x0 = coords[0];
            y0 = coords[1];
        }
        // call x1,y1 the corner point
        // If 2*theta is the angle described by p0-&gt;p1-&gt;p2
        // then theta is the angle described by p0-&gt;p1-&gt;centerpt and
        // centerpt-&gt;p1-&gt;p2
        // We know that the distance from the arc center to the tangent points
        // is r, and if A is the distance from the corner to the tangent point
        // then we know:
        // tan(theta) = r/A
        // A = r / sin(theta)
        // B = A * cos(theta) = r * (sin/cos) = r * tan
        // We use the cosine rule on the triangle to get the 2*theta angle:
        // cosB = (a^2 + c^2 - b^2) / (2ac)
        // where a and c are the adjacent sides and b is the opposite side
        // i.e. a = p0-&gt;p1, c=p1-&gt;p2, b=p0-&gt;p2
        // Then we can use the tan^2 identity to compute B:
        // tan^2 = (1 - cos(2theta)) / (1 + cos(2theta))
        double lsq01 = lenSq(x0, y0, x1, y1);
        double lsq12 = lenSq(x1, y1, x2, y2);
        double lsq02 = lenSq(x0, y0, x2, y2);
        double len01 = Math.sqrt(lsq01);
        double len12 = Math.sqrt(lsq12);
        double cosnum = lsq01 + lsq12 - lsq02;
        double cosden = 2.0 * len01 * len12;
        if (cosden == 0.0 || radius &lt;= 0f) {
            return false;
        }
        double cos_2theta = cosnum / cosden;
        double tansq_den = (1.0 + cos_2theta);
        if (tansq_den == 0.0) {
            return false;
        }
        double tansq_theta = (1.0 - cos_2theta) / tansq_den;
        double A = radius / Math.sqrt(tansq_theta);
        double tx0 = x1 + (A / len01) * (x0 - x1);
        double ty0 = y1 + (A / len01) * (y0 - y1);
        double tx1 = x1 + (A / len12) * (x2 - x1);
        double ty1 = y1 + (A / len12) * (y2 - y1);
        // The midpoint between the two tangent points
        double mx = (tx0 + tx1) / 2.0;
        double my = (ty0 + ty1) / 2.0;
        // similar triangles tell us that:
        // len(m,center)/len(m,tangent) = len(m,tangent)/len(corner,m)
        // len(m,center) = lensq(m,tangent)/len(corner,m)
        // center = m + (m - p1) * len(m,center) / len(corner,m)
        //   = m + (m - p1) * (lensq(m,tangent) / lensq(corner,m))
        double lenratioden = lenSq(mx, my, x1, y1);
        if (lenratioden == 0.0) {
            return false;
        }
        double lenratio = lenSq(mx, my, tx0, ty0) / lenratioden;
        double cx = mx + (mx - x1) * lenratio;
        double cy = my + (my - y1) * lenratio;
        if (!(cx == cx &amp;&amp; cy == cy)) {
            return false;
        }
        // Looks like we are good to draw, first we have to get to the
        // initial tangent point with a line segment.
        if (tx0 != x0 || ty0 != y0) {
            lineTo(tx0, ty0);
        }
        // We need sin(arc/2), cos(arc/2)
        // and possibly sin(arc/4), cos(arc/4) if we need 2 cubic beziers
        // We have tan(theta) = tan(tri/2)
        // arc = 180-tri
        // arc/2 = (180-tri)/2 = 90-(tri/2)
        // sin(arc/2) = sin(90-(tri/2)) = cos(tri/2)
        // cos(arc/2) = cos(90-(tri/2)) = sin(tri/2)
        // 2theta = tri, therefore theta = tri/2
        // cos(tri/2)^2 = (1+cos(tri)) / 2.0 = (1+cos_2theta)/2.0
        // sin(tri/2)^2 = (1-cos(tri)) / 2.0 = (1-cos_2theta)/2.0
        // sin(arc/2) = cos(tri/2) = sqrt((1+cos_2theta)/2.0)
        // cos(arc/2) = sin(tri/2) = sqrt((1-cos_2theta)/2.0)
        // We compute cos(arc/2) here as we need it in either case below
        double coshalfarc = Math.sqrt((1.0 - cos_2theta) / 2.0);
        boolean ccw = (ty0 - cy) * (tx1 - cx) &gt; (ty1 - cy) * (tx0 - cx);
        // If the arc covers more than 90 degrees then we must use 2
        // cubic beziers to get a decent approximation.
        // arc = 180-tri
        // arc = 180-2*theta
        // arc &gt; 90 implies 2*theta &lt; 90
        // 2*theta &lt; 90 implies cos_2theta &gt; 0
        // So, we need 2 cubics if cos_2theta &gt; 0
        if (cos_2theta &lt;= 0.0) {
            // 1 cubic bezier
            double sinhalfarc = Math.sqrt((1.0 + cos_2theta) / 2.0);
            double cv = 4.0 / 3.0 * sinhalfarc / (1.0 + coshalfarc);
            if (ccw) cv = -cv;
            double cpx0 = tx0 - cv * (ty0 - cy);
            double cpy0 = ty0 + cv * (tx0 - cx);
            double cpx1 = tx1 + cv * (ty1 - cy);
            double cpy1 = ty1 - cv * (tx1 - cx);
            bezierCurveTo(cpx0, cpy0, cpx1, cpy1, tx1, ty1);
        } else {
            // 2 cubic beziers
            // We need sin(arc/4) and cos(arc/4)
            // We computed cos(arc/2), so we can compute them as follows:
            // sin(arc/4) = sqrt((1 - cos(arc/2)) / 2)
            // cos(arc/4) = sart((1 + cos(arc/2)) / 2)
            double sinqtrarc = Math.sqrt((1.0 - coshalfarc) / 2.0);
            double cosqtrarc = Math.sqrt((1.0 + coshalfarc) / 2.0);
            double cv = 4.0 / 3.0 * sinqtrarc / (1.0 + cosqtrarc);
            if (ccw) cv = -cv;
            double midratio = radius / Math.sqrt(lenratioden);
            double midarcx = cx + (x1 - mx) * midratio;
            double midarcy = cy + (y1 - my) * midratio;
            double cpx0 = tx0 - cv * (ty0 - cy);
            double cpy0 = ty0 + cv * (tx0 - cx);
            double cpx1 = midarcx + cv * (midarcy - cy);
            double cpy1 = midarcy - cv * (midarcx - cx);
            bezierCurveTo(cpx0, cpy0, cpx1, cpy1, midarcx, midarcy);
            cpx0 = midarcx - cv * (midarcy - cy);
            cpy0 = midarcy + cv * (midarcx - cx);
            cpx1 = tx1 + cv * (ty1 - cy);
            cpy1 = ty1 - cv * (tx1 - cx);
            bezierCurveTo(cpx0, cpy0, cpx1, cpy1, tx1, ty1);
        }
        return true;
    }

    /**
     * Adds path elements to the current path to make an arc that uses Euclidean
     * degrees. This Euclidean orientation sweeps from East to North, then West,
     * then South, then back to East.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param centerX the center x position of the arc.
     * @param centerY the center y position of the arc.
     * @param radiusX the x radius of the arc.
     * @param radiusY the y radius of the arc.
     * @param startAngle the starting angle of the arc in the range {@code 0-360.0}
     * @param length  the length of the baseline of the arc.
     */
    public void arc(double centerX, double centerY,
                    double radiusX, double radiusY,
                    double startAngle, double length)
    {
        Arc2D arc = new Arc2D((float) (centerX - radiusX), // x
                              (float) (centerY - radiusY), // y
                              (float) (radiusX * 2.0), // w
                              (float) (radiusY * 2.0), // h
                              (float) startAngle,
                              (float) length,
                              Arc2D.OPEN);
        path.append(arc.getPathIterator(curState.transform), true);
        markPathDirty();
    }

    /**
     * Adds path elements to the current path to make a rectangle.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param x x position of the upper left corner of the rectangle.
     * @param y y position of the upper left corner of the rectangle.
     * @param w width of the rectangle.
     * @param h height of the rectangle.
     */
    public void rect(double x, double y, double w, double h) {
        coords[0] = (float) x;
        coords[1] = (float) y;
        coords[2] = (float) w;
        coords[3] = (float) 0;
        coords[4] = (float) 0;
        coords[5] = (float) h;
        curState.transform.deltaTransform(coords, 0, coords, 0, 3);
        float x0 = coords[0] + (float) curState.transform.getMxt();
        float y0 = coords[1] + (float) curState.transform.getMyt();
        float dx1 = coords[2];
        float dy1 = coords[3];
        float dx2 = coords[4];
        float dy2 = coords[5];
        path.moveTo(x0, y0);
        path.lineTo(x0+dx1, y0+dy1);
        path.lineTo(x0+dx1+dx2, y0+dy1+dy2);
        path.lineTo(x0+dx2, y0+dy2);
        path.closePath();
        markPathDirty();
//        path.moveTo(x0, y0); // not needed, closepath leaves pen at moveto
    }

    /**
     * Appends an SVG Path string to the current path. If there is no current
     * path the string must then start with either type of move command.
     * A {@code null} value or incorrect SVG path will be ignored.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param svgpath the SVG Path string.
     */
    public void appendSVGPath(String svgpath) {
        if (svgpath == null) return;
        boolean prependMoveto = true;
        boolean skipMoveto = true;
        for (int i = 0; i &lt; svgpath.length(); i++) {
            switch (svgpath.charAt(i)) {
                case ' ':
                case '\t':
                case '\r':
                case '\n':
                    continue;
                case 'M':
                    prependMoveto = skipMoveto = false;
                    break;
                case 'm':
                    if (path.getNumCommands() == 0) {
                        // An initial relative moveTo becomes absolute
                        prependMoveto = false;
                    }
                    // Even if we prepend an initial moveTo in the temp
                    // path, we do not want to delete the resulting initial
                    // moveTo because the relative moveto will be folded
                    // into it by an optimization in the Path2D object.
                    skipMoveto = false;
                    break;
            }
            break;
        }
        Path2D p2d = new Path2D();
        if (prependMoveto &amp;&amp; path.getNumCommands() &gt; 0) {
            float x0, y0;
            if (curState.transform.isTranslateOrIdentity()) {
                x0 = (float) (path.getCurrentX() - curState.transform.getMxt());
                y0 = (float) (path.getCurrentY() - curState.transform.getMyt());
            } else {
                coords[0] = path.getCurrentX();
                coords[1] = path.getCurrentY();
                try {
                    curState.transform.inverseTransform(coords, 0, coords, 0, 1);
                } catch (NoninvertibleTransformException e) {
                }
                x0 = coords[0];
                y0 = coords[1];
            }
            p2d.moveTo(x0, y0);
        } else {
            skipMoveto = false;
        }
        try {
            p2d.appendSVGPath(svgpath);
            PathIterator pi = p2d.getPathIterator(curState.transform);
            if (skipMoveto) {
                // We need to delete the initial moveto and let the path
                // extend from the actual existing geometry.
                pi.next();
            }
            path.append(pi, false);
        } catch (IllegalArgumentException | IllegalPathStateException ex) {
            //Ignore incorrect path
        }
    }

    /**
     * Closes the path.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     */
    public void closePath() {
        if (path.getNumCommands() &gt; 0) {
            path.closePath();
            markPathDirty();
        }
    }

    /**
     * Fills the path with the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#path-attr&quot;&gt;path&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * Note that the path segments were transformed as they were originally
     * added to the current path so the current transform will not affect
     * those path segments again, but it may affect other attributes in
     * affect at the time of the {@code fill()} operation.
     * &lt;/p&gt;
     */
    public void fill() {
        writePath(NGCanvas.FILL_PATH);
    }

    /**
     * Strokes the path with the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;,
     * or &lt;a href=&quot;#path-attr&quot;&gt;path&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * Note that the path segments were transformed as they were originally
     * added to the current path so the current transform will not affect
     * those path segments again, but it may affect other attributes in
     * affect at the time of the {@code stroke()} operation.
     * &lt;/p&gt;
     */
    public void stroke() {
        writePath(NGCanvas.STROKE_PATH);
    }

    /**
     * Intersects the current clip with the current path and applies it to
     * subsequent rendering operation as an anti-aliased mask.
     * The current clip is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering operations as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;p&gt;
     * This method will itself be affected only by the
     * &lt;a href=&quot;#path-attr&quot;&gt;path&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * Note that the path segments were transformed as they were originally
     * added to the current path so the current transform will not affect
     * those path segments again, but it may affect other attributes in
     * affect at the time of the {@code stroke()} operation.
     * &lt;/p&gt;
     */
    public void clip() {
        Path2D clip = new Path2D(path);
        clipStack.addLast(clip);
        curState.numClipPaths++;
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.PUSH_CLIP);
        buf.putObject(clip);
    }

    /**
     * Returns true if the the given x,y point is inside the path.
     *
     * @param x the X coordinate to use for the check.
     * @param y the Y coordinate to use for the check.
     * @return true if the point given is inside the path, false
     * otherwise.
     */
    public boolean isPointInPath(double x, double y) {
        // TODO: HTML5 considers points on the path to be inside, but we
        // implement a halfin-halfout approach...
        return path.contains((float) x, (float) y);
    }

    /**
     * Clears a portion of the canvas with a transparent color value.
     * &lt;p&gt;
     * This method will be affected only by the current transform, clip,
     * and effect.
     * &lt;/p&gt;
     *
     * @param x X position of the upper left corner of the rectangle.
     * @param y Y position of the upper left corner of the rectangle.
     * @param w width of the rectangle.
     * @param h height of the rectangle.
     */
    public void clearRect(double x, double y, double w, double h) {
        if (w != 0 &amp;&amp; h != 0) {
            resetIfCovers(null, x, y, w, h);
            writeOp4(x, y, w, h, NGCanvas.CLEAR_RECT);
        }
    }

    /**
     * Fills a rectangle using the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X position of the upper left corner of the rectangle.
     * @param y the Y position of the upper left corner of the rectangle.
     * @param w the width of the rectangle.
     * @param h the height of the rectangle.
     */
    public void fillRect(double x, double y, double w, double h) {
        if (w != 0 &amp;&amp; h != 0) {
            resetIfCovers(this.curState.fill, x, y, w, h);
            writeOp4(x, y, w, h, NGCanvas.FILL_RECT);
        }
    }

    /**
     * Strokes a rectangle using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X position of the upper left corner of the rectangle.
     * @param y the Y position of the upper left corner of the rectangle.
     * @param w the width of the rectangle.
     * @param h the height of the rectangle.
     */
    public void strokeRect(double x, double y, double w, double h) {
        if (w != 0 || h != 0) {
            writeOp4(x, y, w, h, NGCanvas.STROKE_RECT);
        }
    }

    /**
     * Fills an oval using the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     */
    public void fillOval(double x, double y, double w, double h) {
        if (w != 0 &amp;&amp; h != 0) {
            writeOp4(x, y, w, h, NGCanvas.FILL_OVAL);
        }
    }

    /**
     * Strokes an oval using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     */
    public void strokeOval(double x, double y, double w, double h) {
        if (w != 0 || h != 0) {
            writeOp4(x, y, w, h, NGCanvas.STROKE_OVAL);
        }
    }

    /**
     * Fills an arc using the current fill paint. A {@code null} ArcType or
     * non positive width or height will cause the render command to be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the arc.
     * @param y the Y coordinate of the arc.
     * @param w the width of the arc.
     * @param h the height of the arc.
     * @param startAngle the starting angle of the arc in degrees.
     * @param arcExtent the angular extent of the arc in degrees.
     * @param closure closure type (Round, Chord, Open) or null.
     */
    public void fillArc(double x, double y, double w, double h,
                        double startAngle, double arcExtent, ArcType closure)
    {
        if (w != 0 &amp;&amp; h != 0 &amp;&amp; closure != null) {
            writeArcType(closure);
            writeOp6(x, y, w, h, startAngle, arcExtent, NGCanvas.FILL_ARC);
        }
    }

    /**
     * Strokes an Arc using the current stroke paint. A {@code null} ArcType or
     * non positive width or height will cause the render command to be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the arc.
     * @param y the Y coordinate of the arc.
     * @param w the width of the arc.
     * @param h the height of the arc.
     * @param startAngle the starting angle of the arc in degrees.
     * @param arcExtent arcExtent the angular extent of the arc in degrees.
     * @param closure closure type (Round, Chord, Open) or null
     */
    public void strokeArc(double x, double y, double w, double h,
                        double startAngle, double arcExtent, ArcType closure)
    {
        if (w != 0 &amp;&amp; h != 0 &amp;&amp; closure != null) {
            writeArcType(closure);
            writeOp6(x, y, w, h, startAngle, arcExtent, NGCanvas.STROKE_ARC);
        }
    }

    /**
     * Fills a rounded rectangle using the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     * @param arcWidth the arc width of the rectangle corners.
     * @param arcHeight the arc height of the rectangle corners.
     */
    public void fillRoundRect(double x, double y, double w, double h,
                              double arcWidth, double arcHeight)
    {
        if (w != 0 &amp;&amp; h != 0) {
            writeOp6(x, y, w, h, arcWidth, arcHeight, NGCanvas.FILL_ROUND_RECT);
        }
    }

    /**
     * Strokes a rounded rectangle using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     * @param arcWidth the arc width of the rectangle corners.
     * @param arcHeight the arc height of the rectangle corners.
     */
    public void strokeRoundRect(double x, double y, double w, double h,
                              double arcWidth, double arcHeight)
    {
        if (w != 0 &amp;&amp; h != 0) {
            writeOp6(x, y, w, h, arcWidth, arcHeight, NGCanvas.STROKE_ROUND_RECT);
        }
    }

    /**
     * Strokes a line using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x1 the X coordinate of the starting point of the line.
     * @param y1 the Y coordinate of the starting point of the line.
     * @param x2 the X coordinate of the ending point of the line.
     * @param y2 the Y coordinate of the ending point of the line.
     */
    public void strokeLine(double x1, double y1, double x2, double y2) {
        writeOp4(x1, y1, x2, y2, NGCanvas.STROKE_LINE);
    }

    /**
     * Fills a polygon with the given points using the currently set fill paint.
     * A {@code null} value for any of the arrays will be ignored and nothing will be drawn.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#path-attr&quot;&gt;Fill Rule&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param xPoints array containing the x coordinates of the polygon's points or null.
     * @param yPoints array containing the y coordinates of the polygon's points or null.
     * @param nPoints the number of points that make the polygon.
     */
    public void fillPolygon(double xPoints[], double yPoints[], int nPoints) {
        if (nPoints &gt;= 3) {
            writePoly(xPoints, yPoints, nPoints, true, NGCanvas.FILL_PATH);
        }
    }

    /**
     * Strokes a polygon with the given points using the currently set stroke paint.
     * A {@code null} value for any of the arrays will be ignored and nothing will be drawn.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param xPoints array containing the x coordinates of the polygon's points or null.
     * @param yPoints array containing the y coordinates of the polygon's points or null.
     * @param nPoints the number of points that make the polygon.
     */
    public void strokePolygon(double xPoints[], double yPoints[], int nPoints) {
        if (nPoints &gt;= 2) {
            writePoly(xPoints, yPoints, nPoints, true, NGCanvas.STROKE_PATH);
        }
    }

    /**
     * Strokes a polyline with the given points using the currently set stroke
     * paint attribute.
     * A {@code null} value for any of the arrays will be ignored and nothing will be drawn.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param xPoints array containing the x coordinates of the polyline's points or null.
     * @param yPoints array containing the y coordinates of the polyline's points or null.
     * @param nPoints the number of points that make the polyline.
     */
    public void strokePolyline(double xPoints[], double yPoints[], int nPoints) {
        if (nPoints &gt;= 2) {
            writePoly(xPoints, yPoints, nPoints, false, NGCanvas.STROKE_PATH);
        }
    }

    /**
     * Draws an image at the given x, y position using the width
     * and height of the given image.
     * A {@code null} image value or an image still in progress will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param img the image to be drawn or null.
     * @param x the X coordinate on the destination for the upper left of the image.
     * @param y the Y coordinate on the destination for the upper left of the image.
     */
    public void drawImage(Image img, double x, double y) {
        if (img == null) return;
        double sw = img.getWidth();
        double sh = img.getHeight();
        writeImage(img, x, y, sw, sh);
    }

    /**
     * Draws an image into the given destination rectangle of the canvas. The
     * Image is scaled to fit into the destination rectangle.
     * A {@code null} image value or an image still in progress will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param img the image to be drawn or null.
     * @param x the X coordinate on the destination for the upper left of the image.
     * @param y the Y coordinate on the destination for the upper left of the image.
     * @param w the width of the destination rectangle.
     * @param h the height of the destination rectangle.
     */
    public void drawImage(Image img, double x, double y, double w, double h) {
        writeImage(img, x, y, w, h);
    }

    /**
     * Draws the specified source rectangle of the given image to the given
     * destination rectangle of the Canvas.
     * A {@code null} image value or an image still in progress will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param img the image to be drawn or null.
     * @param sx the source rectangle's X coordinate position.
     * @param sy the source rectangle's Y coordinate position.
     * @param sw the source rectangle's width.
     * @param sh the source rectangle's height.
     * @param dx the destination rectangle's X coordinate position.
     * @param dy the destination rectangle's Y coordinate position.
     * @param dw the destination rectangle's width.
     * @param dh the destination rectangle's height.
     */
    public void drawImage(Image img,
                          double sx, double sy, double sw, double sh,
                          double dx, double dy, double dw, double dh)
    {
        writeImage(img, dx, dy, dw, dh, sx, sy, sw, sh);
    }

    private PixelWriter writer;
    /**
     * Returns a {@link PixelWriter} object that can be used to modify
     * the pixels of the {@link Canvas} associated with this
     * {@code GraphicsContext}.
     * All coordinates in the {@code PixelWriter} methods on the returned
     * object will be in device space since they refer directly to pixels
     * and no other rendering attributes will be applied when modifying
     * pixels using this object.
     *
     * @return the {@code PixelWriter} for modifying the pixels of this
     *         {@code Canvas}
     */
    public PixelWriter getPixelWriter() {
        if (writer == null) {
            writer = new PixelWriter() {
                @Override
                public PixelFormat&lt;ByteBuffer&gt; getPixelFormat() {
                    return PixelFormat.getByteBgraPreInstance();
                }

                private BytePixelSetter getSetter() {
                    return ByteBgraPre.setter;
                }

                @Override
                public void setArgb(int x, int y, int argb) {
                    GrowableDataBuffer buf = getBuffer();
                    buf.putByte(NGCanvas.PUT_ARGB);
                    buf.putInt(x);
                    buf.putInt(y);
                    buf.putInt(argb);
                }

                @Override
                public void setColor(int x, int y, Color c) {
                    if (c == null) throw new NullPointerException(&quot;Color cannot be null&quot;);
                    int a = (int) Math.round(c.getOpacity() * 255.0);
                    int r = (int) Math.round(c.getRed() * 255.0);
                    int g = (int) Math.round(c.getGreen() * 255.0);
                    int b = (int) Math.round(c.getBlue() * 255.0);
                    setArgb(x, y, (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b);
                }

                private void writePixelBuffer(int x, int y, int w, int h,
                                              byte[] pixels)
                {
                    GrowableDataBuffer buf = getBuffer();
                    buf.putByte(NGCanvas.PUT_ARGBPRE_BUF);
                    buf.putInt(x);
                    buf.putInt(y);
                    buf.putInt(w);
                    buf.putInt(h);
                    buf.putObject(pixels);
                }

                private int[] checkBounds(int x, int y, int w, int h,
                                          PixelFormat&lt;? extends Buffer&gt; pf,
                                          int scan)
                {
                    // assert (w &gt;= 0 &amp;&amp; h &gt;= 0) - checked by caller
                    int cw = (int) Math.ceil(theCanvas.getWidth());
                    int ch = (int) Math.ceil(theCanvas.getHeight());
                    if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x+w &lt;= cw &amp;&amp; y+h &lt;= ch) {
                        return null;
                    }
                    int offset = 0;
                    if (x &lt; 0) {
                        w += x;
                        if (w &lt; 0) return null;
                        if (pf != null) {
                            switch (pf.getType()) {
                                case BYTE_BGRA:
                                case BYTE_BGRA_PRE:
                                    offset -= x * 4;
                                    break;
                                case BYTE_RGB:
                                    offset -= x * 3;
                                    break;
                                case BYTE_INDEXED:
                                case INT_ARGB:
                                case INT_ARGB_PRE:
                                    offset -= x;
                                    break;
                                default:
                                    throw new InternalError(&quot;unknown Pixel Format&quot;);
                            }
                        }
                        x = 0;
                    }
                    if (y &lt; 0) {
                        h += y;
                        if (h &lt; 0) return null;
                        offset -= y * scan;
                        y = 0;
                    }
                    if (x + w &gt; cw) {
                        w = cw - x;
                        if (w &lt; 0) return null;
                    }
                    if (y + h &gt; ch) {
                        h = ch - y;
                        if (h &lt; 0) return null;
                    }
                    return new int[] {
                        x, y, w, h, offset
                    };
                }

                @Override
                public &lt;T extends Buffer&gt; void
                    setPixels(int x, int y, int w, int h,
                              PixelFormat&lt;T&gt; pixelformat,
                              T buffer, int scan)
                {
                    if (pixelformat == null) throw new NullPointerException(&quot;PixelFormat cannot be null&quot;);
                    if (buffer == null) throw new NullPointerException(&quot;Buffer cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int offset = buffer.position();
                    int adjustments[] = checkBounds(x, y, w, h,
                                                    pixelformat, scan);
                    if (adjustments != null) {
                        x = adjustments[0];
                        y = adjustments[1];
                        w = adjustments[2];
                        h = adjustments[3];
                        offset += adjustments[4];
                    }

                    byte pixels[] = new byte[w * h * 4];
                    ByteBuffer dst = ByteBuffer.wrap(pixels);

                    PixelGetter&lt;T&gt; getter = PixelUtils.getGetter(pixelformat);
                    PixelConverter&lt;T, ByteBuffer&gt; converter =
                        PixelUtils.getConverter(getter, getSetter());
                    converter.convert(buffer, offset, scan,
                                      dst, 0, w * 4,
                                      w, h);
                    writePixelBuffer(x, y, w, h, pixels);
                }

                @Override
                public void setPixels(int x, int y, int w, int h,
                                      PixelFormat&lt;ByteBuffer&gt; pixelformat,
                                      byte[] buffer, int offset, int scanlineStride)
                {
                    if (pixelformat == null) throw new NullPointerException(&quot;PixelFormat cannot be null&quot;);
                    if (buffer == null) throw new NullPointerException(&quot;Buffer cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int adjustments[] = checkBounds(x, y, w, h,
                                                    pixelformat, scanlineStride);
                    if (adjustments != null) {
                        x = adjustments[0];
                        y = adjustments[1];
                        w = adjustments[2];
                        h = adjustments[3];
                        offset += adjustments[4];
                    }

                    byte pixels[] = new byte[w * h * 4];

                    BytePixelGetter getter = PixelUtils.getByteGetter(pixelformat);
                    ByteToBytePixelConverter converter =
                        PixelUtils.getB2BConverter(getter, getSetter());
                    converter.convert(buffer, offset, scanlineStride,
                                      pixels, 0, w * 4,
                                      w, h);
                    writePixelBuffer(x, y, w, h, pixels);
                }

                @Override
                public void setPixels(int x, int y, int w, int h,
                                      PixelFormat&lt;IntBuffer&gt; pixelformat,
                                      int[] buffer, int offset, int scanlineStride)
                {
                    if (pixelformat == null) throw new NullPointerException(&quot;PixelFormat cannot be null&quot;);
                    if (buffer == null) throw new NullPointerException(&quot;Buffer cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int adjustments[] = checkBounds(x, y, w, h,
                                                    pixelformat, scanlineStride);
                    if (adjustments != null) {
                        x = adjustments[0];
                        y = adjustments[1];
                        w = adjustments[2];
                        h = adjustments[3];
                        offset += adjustments[4];
                    }

                    byte pixels[] = new byte[w * h * 4];

                    IntPixelGetter getter = PixelUtils.getIntGetter(pixelformat);
                    IntToBytePixelConverter converter =
                        PixelUtils.getI2BConverter(getter, getSetter());
                    converter.convert(buffer, offset, scanlineStride,
                                      pixels, 0, w * 4,
                                      w, h);
                    writePixelBuffer(x, y, w, h, pixels);
                }

                @Override
                public void setPixels(int dstx, int dsty, int w, int h,
                                      PixelReader reader, int srcx, int srcy)
                {
                    if (reader == null) throw new NullPointerException(&quot;Reader cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int adjustments[] = checkBounds(dstx, dsty, w, h, null, 0);
                    if (adjustments != null) {
                        int newx = adjustments[0];
                        int newy = adjustments[1];
                        srcx += newx - dstx;
                        srcy += newy - dsty;
                        dstx = newx;
                        dsty = newy;
                        w = adjustments[2];
                        h = adjustments[3];
                    }

                    byte pixels[] = new byte[w * h * 4];
                    reader.getPixels(srcx, srcy, w, h,
                                     PixelFormat.getByteBgraPreInstance(),
                                     pixels, 0, w * 4);
                    writePixelBuffer(dstx, dsty, w, h, pixels);
                }
            };
        }
        return writer;
    }

    /**
     * Sets the effect to be applied after the next draw call, or null to
     * disable effects.
     * The current effect is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering operations as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param e the effect to use, or null to disable effects
     */
    public void setEffect(Effect e) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.EFFECT);
        if (e == null) {
            curState.effect = null;
            buf.putObject(null);
        } else {
            curState.effect = EffectHelper.copy(e);
            EffectHelper.sync(curState.effect);
            buf.putObject(EffectHelper.getPeer(curState.effect));
        }
    }

    /**
     * Gets a copy of the effect to be applied after the next draw call.
     * A null return value means that no effect will be applied after subsequent
     * rendering calls.
     * The current effect is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering operations as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param e an {@code Effect} object that may be used to store the
     *        copy of the current effect, if it is of a compatible type
     * @return the current effect used for all rendering calls,
     *         or null if there is no current effect
     */
    public Effect getEffect(Effect e) {
        return curState.effect == null ? null : EffectHelper.copy(curState.effect);
    }

    /**
     * Applies the given effect to the entire bounds of the canvas and stores
     * the result back into the same canvas.
     * A {@code null} value will be ignored.
     * The effect will be applied without any other rendering attributes and
     * under an Identity coordinate transform.
     * Since the effect is applied to the entire bounds of the canvas, some
     * effects may have a confusing result, such as a Reflection effect
     * that will apply its reflection off of the bottom of the canvas even if
     * only a portion of the canvas has been rendered to and will not be
     * visible unless a negative offset is used to bring the reflection back
     * into view.
     *
     * @param e the effect to apply onto the entire destination or null.
     */
    public void applyEffect(Effect e) {
        if (e == null) return;
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.FX_APPLY_EFFECT);
        Effect effect = EffectHelper.copy(e);
        EffectHelper.sync(effect);
        buf.putObject(EffectHelper.getPeer(effect));
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/layout/BackgroundConverter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.layout;

import com.sun.javafx.css.StyleManager;
import com.sun.javafx.scene.layout.region.RepeatStruct;
import java.util.Map;
<A NAME="18"></A>import javafx.css.CssMetaData;
import javafx.css.ParsedValue;
import javafx.css.StyleConverter;
<FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#18',2,'match58-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.css.Styleable;
import javafx.css.StyleConverter;
import javafx.geometry.Insets;
import javafx.scene.image.Image;
import javafx.scene.paint.Paint;

/**
 * Converts the CSS for -fx-background items into a Background.
 */
class BackgroundConverter extends StyleConverter&lt;ParsedValue[], Background&gt; {

    static final StyleConverter&lt;ParsedValue[], Background&gt; INSTANCE = new BackgroundConverter();

    @Override public Background convert(Map&lt;CssMetaData&lt;? extends Styleable, ?&gt;,Object&gt; convertedValues) {</B></FONT>
        final Paint[] fills = (Paint[]) convertedValues.get(Background.BACKGROUND_COLOR);
        final String[] imageUrls = (String[]) convertedValues.get(Background.BACKGROUND_IMAGE);
        final boolean hasFills = fills != null &amp;&amp; fills.length &gt; 0;
        final boolean hasImages = imageUrls != null &amp;&amp; imageUrls.length &gt; 0;

        // If there are neither background fills nor images, then there is nothing for us to construct.
        if (!hasFills &amp;&amp; !hasImages) return null;

        // Iterate over all of the fills, and create BackgroundFill objects for each.
        BackgroundFill[] backgroundFills = null;
        if (hasFills) {
            backgroundFills = new BackgroundFill[fills.length];

            Object tmp = convertedValues.get(Background.BACKGROUND_INSETS);
            final Insets[] insets = tmp == null ? new Insets[0] : (Insets[]) tmp;

            tmp = convertedValues.get(Background.BACKGROUND_RADIUS);
            final CornerRadii[] radii = tmp == null ? new CornerRadii[0] : (CornerRadii[]) tmp;

            final int lastInsetsIndex = insets.length - 1;
            final int lastRadiiIndex = radii.length - 1;
            for (int i=0; i&lt;fills.length; i++) {
                Insets in = insets.length &gt; 0 ? insets[i &lt;= lastInsetsIndex ? i : lastInsetsIndex] : Insets.EMPTY;
                CornerRadii ra = radii.length &gt; 0 ? radii[i &lt;= lastRadiiIndex ? i : lastRadiiIndex] : CornerRadii.EMPTY;
                backgroundFills[i] = new BackgroundFill(fills[i], ra, in);
            }
        }

        // Iterate over all of the image, and create BackgroundImage objects for each.
        BackgroundImage[] backgroundImages = null;
        if (hasImages) {
            // TODO convert image urls into image objects!
            backgroundImages = new BackgroundImage[imageUrls.length];

            Object tmp = convertedValues.get(Background.BACKGROUND_REPEAT);
            final RepeatStruct[] repeats = tmp == null ? new RepeatStruct[0] : (RepeatStruct[]) tmp;

            tmp = convertedValues.get(Background.BACKGROUND_POSITION);
            final BackgroundPosition[] positions = tmp == null ? new BackgroundPosition[0] : (BackgroundPosition[]) tmp;

            tmp = convertedValues.get(Background.BACKGROUND_SIZE);
            final BackgroundSize[] sizes = tmp == null ? new BackgroundSize[0] : (BackgroundSize[]) tmp;

            final int lastRepeatIndex = repeats.length - 1;
            final int lastPositionIndex = positions.length - 1;
            final int lastSizeIndex = sizes.length - 1;
            for (int i = 0; i &lt; imageUrls.length; i++) {
                // RT-21335: skip background and border images whose image url is null
                if (imageUrls[i] == null) continue;

                final Image image = StyleManager.getInstance().getCachedImage(imageUrls[i]);
                if (image == null) continue;

                final RepeatStruct repeat = (repeats.length &gt; 0) ?
                        repeats[i &lt;= lastRepeatIndex ? i : lastRepeatIndex] : null; // min
                final BackgroundPosition position = (positions.length &gt; 0) ?
                        positions[i &lt;= lastPositionIndex ? i : lastPositionIndex] : null; // min
                final BackgroundSize size = (sizes.length &gt; 0) ?
                        sizes[i &lt;= lastSizeIndex ? i : lastSizeIndex] : null; // min
                backgroundImages[i] = new BackgroundImage(image,
                        repeat == null ? null : repeat.repeatX,
                        repeat == null ? null : repeat.repeatY,
                        position, size);
            }
        }

        // Give the background fills and background images to a newly constructed BackgroundConverter,
        // and return it.
        return new Background(backgroundFills, backgroundImages);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/Line.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.Line2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.shape.LineHelper;
import com.sun.javafx.sg.prism.NGLine;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGShape;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.css.StyleableProperty;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;


/**
 * This Line represents a line segment in {@code (x,y)}
 * coordinate space. Example:
 *
&lt;PRE&gt;
import javafx.scene.shape.*;

Line line = new Line();
line.setStartX(0.0f);
line.setStartY(0.0f);
line.setEndX(100.0f);
line.setEndY(100.0f);
}
&lt;/PRE&gt;
 * @since JavaFX 2.0
 */
public class Line extends Shape {
    static {
        LineHelper.setLineAccessor(new LineHelper.LineAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Line) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Line) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Line) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public Paint doCssGetFillInitialValue(Shape shape) {
                return ((Line) shape).doCssGetFillInitialValue();
            }

            @Override
            public Paint doCssGetStrokeInitialValue(Shape shape) {
                return ((Line) shape).doCssGetStrokeInitialValue();
            }

            @Override
            public com.sun.javafx.geom.Shape doConfigShape(Shape shape) {
                return ((Line) shape).doConfigShape();
            }
        });
    }

    private final Line2D shape = new Line2D();

    {
        // To initialize the class helper at the begining each constructor of this class
        LineHelper.initHelper(this);

        // overriding default values for fill and stroke
        // Set through CSS property so that it appears to be a UA style rather
        // that a USER style so that fill and stroke can still be set from CSS.
        ((StyleableProperty)fillProperty()).applyStyle(null, null);
        ((StyleableProperty)strokeProperty()).applyStyle(null, Color.BLACK);
    }

    /**
     * Creates an empty instance of Line.
     */
    public Line() {
    }

    /**
     * Creates a new instance of Line.
     * @param startX the horizontal coordinate of the start point of the line segment
     * @param startY the vertical coordinate of the start point of the line segment
     * @param endX the horizontal coordinate of the end point of the line segment
     * @param endY the vertical coordinate of the end point of the line segment
     */
    public Line(double startX, double startY, double endX, double endY) {
        setStartX(startX);
        setStartY(startY);
        setEndX(endX);
        setEndY(endY);
    }

    /**
     * The X coordinate of the start point of the line segment.
     *
     * @defaultValue 0.0
     */
    private final DoubleProperty startX = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    NodeHelper.markDirty(Line.this, DirtyBits.NODE_GEOMETRY);
                    NodeHelper.geomChanged(Line.this);
                }

                @Override
                public Object getBean() {
                    return Line.this;
                }

                @Override
                public String getName() {
                    return &quot;startX&quot;;
                }
            };


    public final void setStartX(double value) {
        startX.set(value);
    }

    public final double getStartX() {
        return startX.get();
    }

    public final DoubleProperty startXProperty() {
        return startX;
    }

    /**
     * The Y coordinate of the start point of the line segment.
     *
     * @defaultValue 0.0
     */
    private final DoubleProperty startY = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    NodeHelper.markDirty(Line.this, DirtyBits.NODE_GEOMETRY);
                    NodeHelper.geomChanged(Line.this);
                }

                @Override
                public Object getBean() {
                    return Line.this;
                }

                @Override
                public String getName() {
                    return &quot;startY&quot;;
                }
            };


    public final void setStartY(double value) {
        startY.set(value);
    }

    public final double getStartY() {
        return startY.get();
    }

    public final DoubleProperty startYProperty() {
        return startY;
    }

    /**
     * The X coordinate of the end point of the line segment.
     *
     * @defaultValue 0.0
     */
    private final DoubleProperty endX = new DoublePropertyBase() {

        @Override
        public void invalidated() {
            NodeHelper.markDirty(Line.this, DirtyBits.NODE_GEOMETRY);
            NodeHelper.geomChanged(Line.this);
        }

        @Override
        public Object getBean() {
            return Line.this;
        }

        @Override
        public String getName() {
            return &quot;endX&quot;;
        }
    };



    public final void setEndX(double value) {
        endX.set(value);
    }

    public final double getEndX() {
        return endX.get();
    }

    public final DoubleProperty endXProperty() {
        return endX;
    }

    /**
     * The Y coordinate of the end point of the line segment.
     *
     * @defaultValue 0.0
     */
    private final DoubleProperty endY = new DoublePropertyBase() {

        @Override
        public void invalidated() {
            NodeHelper.markDirty(Line.this, DirtyBits.NODE_GEOMETRY);
            NodeHelper.geomChanged(Line.this);
        }

        @Override
        public Object getBean() {
            return Line.this;
        }

        @Override
        public String getName() {
            return &quot;endY&quot;;
        }
    };

    public final void setEndY(double value) {
        endY.set(value);
    }

    public final double getEndY() {
        return endY.get();
    }

    public final DoubleProperty endYProperty() {
        return endY;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGLine();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {

        // Since line's only draw with strokes, if the mode is FILL or EMPTY
        // then we simply return empty bounds
        if (getMode() == NGShape.Mode.FILL || getMode() == NGShape.Mode.EMPTY ||
            getStrokeType() == StrokeType.INSIDE)
        {
            return bounds.makeEmpty();
        }

        double x1 = getStartX();
        double x2 = getEndX();
        double y1 = getStartY();
        double y2 = getEndY();
        // Get the draw stroke, and figure out the bounds based on the stroke.
        double wpad = getStrokeWidth();
        if (getStrokeType() == StrokeType.CENTERED) {
            wpad /= 2.0f;
        }
        // fast path the case of AffineTransform being TRANSLATE or identity
        if (tx.isTranslateOrIdentity()) {
            final double xpad;
            final double ypad;
            wpad = Math.max(wpad, 0.5f);
            if (tx.getType() == BaseTransform.TYPE_TRANSLATION) {
                final double ddx = tx.getMxt();
                final double ddy = tx.getMyt();
                x1 += ddx;
                y1 += ddy;
                x2 += ddx;
                y2 += ddy;
            }
            if (y1 == y2 &amp;&amp; x1 != x2) {
                ypad = wpad;
                xpad = (getStrokeLineCap() == StrokeLineCap.BUTT) ? 0.0f : wpad;
            } else if (x1 == x2 &amp;&amp; y1 != y2) {
                xpad = wpad;
                ypad = (getStrokeLineCap() == StrokeLineCap.BUTT) ? 0.0f : wpad;
            } else {
                if (getStrokeLineCap() == StrokeLineCap.SQUARE) {
                    wpad *= Math.sqrt(2);
                }
                xpad = ypad = wpad;
            }
            if (x1 &gt; x2) { final double t = x1; x1 = x2; x2 = t; }
            if (y1 &gt; y2) { final double t = y1; y1 = y2; y2 = t; }

            x1 -= xpad;
            y1 -= ypad;
            x2 += xpad;
            y2 += ypad;
            bounds = bounds.deriveWithNewBounds((float)x1, (float)y1, 0.0f,
                    (float)x2, (float)y2, 0.0f);
            return bounds;
        }

        double dx = x2 - x1;
        double dy = y2 - y1;
        final double len = Math.sqrt(dx * dx + dy * dy);
        if (len == 0.0f) {
            dx = wpad;
            dy = 0.0f;
        } else {
            dx = wpad * dx / len;
            dy = wpad * dy / len;
        }
        final double ecx;
        final double ecy;
        if (getStrokeLineCap() != StrokeLineCap.BUTT) {
            ecx = dx;
            ecy = dy;
        } else {
            ecx = ecy = 0.0f;
        }
        final double corners[] = new double[] {
            x1-dy-ecx, y1+dx-ecy,
            x1+dy-ecx, y1-dx-ecy,
            x2+dy+ecx, y2-dx+ecy,
            x2-dy+ecx, y2+dx+ecy };
        tx.transform(corners, 0, corners, 0, 4);
        x1 = Math.min(Math.min(corners[0], corners[2]),
                             Math.min(corners[4], corners[6]));
        y1 = Math.min(Math.min(corners[1], corners[3]),
                             Math.min(corners[5], corners[7]));
        x2 = Math.max(Math.max(corners[0], corners[2]),
                             Math.max(corners[4], corners[6]));
        y2 = Math.max(Math.max(corners[1], corners[3]),
                             Math.max(corners[5], corners[7]));
        x1 -= 0.5f;
        y1 -= 0.5f;
        x2 += 0.5f;
        y2 += 0.5f;
<A NAME="16"></A>        bounds = bounds.deriveWithNewBounds((float)x1, (float)y1, 0.0f,
                (float)x2, (float)y2, 0.0f);
        return bounds;
    <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#16',2,'match58-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private Line2D doConfigShape() {
        shape.setLine((float)getStartX(), (float)getStartY(), (float)getEndX(), (float)getEndY());
        return shape;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {</B></FONT>
        if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
            NGLine peer = NodeHelper.getPeer(this);
            peer.updateLine((float)getStartX(),
                (float)getStartY(),
                (float)getEndX(),
                (float)getEndY());
        }
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    /*
     * Some sub-class of Shape, such as {@link Line}, override the
     * default value for the {@link Shape#fill} property. This allows
     * CSS to get the correct initial value.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private Paint doCssGetFillInitialValue() {
        return null;
    }

    /**
     * Some sub-class of Shape, such as {@link Line}, override the
     * default value for the {@link Shape#stroke} property. This allows
     * CSS to get the correct initial value.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private Paint doCssGetStrokeInitialValue() {
        return Color.BLACK;
    }

    /**
     * Returns a string representation of this {@code Line} object.
     * @return a string representation of this {@code Line} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Line[&quot;);

        String id = getId();
        if (id != null) {
            sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
        }

        sb.append(&quot;startX=&quot;).append(getStartX());
        sb.append(&quot;, startY=&quot;).append(getStartY());
        sb.append(&quot;, endX=&quot;).append(getEndX());
        sb.append(&quot;, endY=&quot;).append(getEndY());

        Paint stroke = getStroke();
        if (stroke != null) {
            sb.append(&quot;, stroke=&quot;).append(stroke);
            sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
        }

        return sb.append(&quot;]&quot;).toString();
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/perf/WCFontPerfLogger.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.perf;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.webkit.graphics.WCFont;
import com.sun.webkit.graphics.WCGlyphBuffer;

public final class WCFontPerfLogger extends WCFont {
    private static final PlatformLogger log =
            PlatformLogger.getLogger(WCFontPerfLogger.class.getName());

    private static final PerfLogger logger = PerfLogger.getLogger(log);

    private final WCFont fnt;

    public WCFontPerfLogger(WCFont fnt) {
        this.fnt = fnt;
    }

    public synchronized static boolean isEnabled() {
        return logger.isEnabled();
    }

    public static void log() {
        logger.log();
    }

    public static void reset() {
        logger.reset();
    }

    public Object getPlatformFont() {
        return fnt.getPlatformFont();
    }

    public WCFont deriveFont(float size) {
        logger.resumeCount(&quot;DERIVEFONT&quot;);
        WCFont res = fnt.deriveFont(size);
        logger.suspendCount(&quot;DERIVEFONT&quot;);
        return res;
    }

    public int getOffsetForPosition(String str, float x) {
        logger.resumeCount(&quot;GETOFFSETFORPOSITION&quot;);
        int res = fnt.getOffsetForPosition(str, x);
        logger.suspendCount(&quot;GETOFFSETFORPOSITION&quot;);
        return res;
    }

    public WCGlyphBuffer getGlyphsAndAdvances(String str, int from, int to,
                                              boolean rtl) {
        logger.resumeCount(&quot;GETGLYPHSANDADVANCESFORCOMPLEXTEXT&quot;);
        WCGlyphBuffer adv = fnt.getGlyphsAndAdvances(str, from, to, rtl);
        logger.suspendCount(&quot;GETGLYPHSANDADVANCESFORCOMPLEXTEXT&quot;);
        return adv;
    }
<A NAME="13"></A>
    public int[] getGlyphCodes(char[] chars) {
        logger.resumeCount(&quot;GETGLYPHCODES&quot;);
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#13',2,'match58-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int[] res = fnt.getGlyphCodes(chars);
        logger.suspendCount(&quot;GETGLYPHCODES&quot;);
        return res;
    }

    public float getXHeight() {
        logger.resumeCount(&quot;GETXHEIGHT&quot;);
        float res = fnt.getXHeight()</B></FONT>;
        logger.suspendCount(&quot;GETXHEIGHT&quot;);
        return res;
    }

    public double getGlyphWidth(int glyph) {
        logger.resumeCount(&quot;GETGLYPHWIDTH&quot;);
        double res = fnt.getGlyphWidth(glyph);
        logger.suspendCount(&quot;GETGLYPHWIDTH&quot;);
        return res;
    }

    public float[] getGlyphBoundingBox(int glyph) {
        logger.resumeCount(&quot;GETGLYPHBOUNDINGBOX&quot;);
        float[] res = fnt.getGlyphBoundingBox(glyph);
        logger.suspendCount(&quot;GETGLYPHBOUNDINGBOX&quot;);
        return res;
    }

    public double getStringWidth(String str) {
        logger.resumeCount(&quot;GETSTRINGLENGTH&quot;);
        double res = fnt.getStringWidth(str);
        logger.suspendCount(&quot;GETSTRINGLENGTH&quot;);
        return res;
    }

    public double[] getStringBounds(String str, int from, int to, boolean rtl) {
        logger.resumeCount(&quot;GETSTRINGBOUNDS&quot;);
        double[] res = fnt.getStringBounds(str, from, to, rtl);
        logger.suspendCount(&quot;GETSTRINGBOUNDS&quot;);
        return res;
    }

    public int hashCode() {
        logger.resumeCount(&quot;HASH&quot;);
        int res = fnt.hashCode();
        logger.suspendCount(&quot;HASH&quot;);
        return res;
    }

    public boolean equals(Object object) {
        logger.resumeCount(&quot;COMPARE&quot;);
        boolean res = fnt.equals(object);
        logger.suspendCount(&quot;COMPARE&quot;);
        return res;
    }

    public float getAscent() {
        logger.resumeCount(&quot;GETASCENT&quot;);
        float res = fnt.getAscent();
        logger.suspendCount(&quot;GETASCENT&quot;);
        return res;
    }

    public float getDescent() {
        logger.resumeCount(&quot;GETDESCENT&quot;);
        float res = fnt.getDescent();
        logger.suspendCount(&quot;GETDESCENT&quot;);
        return res;
    }

    public float getLineSpacing() {
        logger.resumeCount(&quot;GETLINESPACING&quot;);
        float res = fnt.getLineSpacing();
        logger.suspendCount(&quot;GETLINESPACING&quot;);
        return res;
    }

    public float getLineGap() {
        logger.resumeCount(&quot;GETLINEGAP&quot;);
        float res = fnt.getLineGap();
        logger.suspendCount(&quot;GETLINEGAP&quot;);
        return res;
    }

    public boolean hasUniformLineMetrics() {
        logger.resumeCount(&quot;HASUNIFORMLINEMETRICS&quot;);
        boolean res = fnt.hasUniformLineMetrics();
        logger.suspendCount(&quot;HASUNIFORMLINEMETRICS&quot;);
        return res;
    }

    public float getCapHeight() {
        logger.resumeCount(&quot;GETCAPHEIGHT&quot;);
        float res = fnt.getCapHeight();
        logger.suspendCount(&quot;GETCAPHEIGHT&quot;);
        return res;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/plugin/PluginManager.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.plugin;

import com.sun.javafx.logging.PlatformLogger;
import java.net.URL;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ServiceLoader;
import java.util.TreeMap;
import java.util.Vector;

public final class PluginManager {
    private final static PlatformLogger log =
            PlatformLogger.getLogger(&quot;com.sun.browser.plugin.PluginManager&quot;);

<A NAME="2"></A>    private static final ServiceLoader&lt;PluginHandler&gt; pHandlers =
        ServiceLoader.load(PluginHandler.class);

    <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match58-0.html#2',2,'match58-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static final TreeMap&lt;String,PluginHandler&gt; hndMap =
        new TreeMap&lt;String,PluginHandler&gt;();

    private static PluginHandler[] hndArray;

    private static final HashSet&lt;String&gt; disabledPluginHandlers =
        new HashSet&lt;String&gt;();


    private static void updatePluginHandlers() {
        log.fine(&quot;Update plugin handlers&quot;);

        hndMap.clear</B></FONT>();

        Iterator&lt;PluginHandler&gt; iter = pHandlers.iterator();
        while(iter.hasNext()) {
            PluginHandler hnd = iter.next();
            if (hnd.isSupportedPlatform() &amp;&amp; !isDisabledPlugin(hnd))
            {
                String [] types = hnd.supportedMIMETypes();
                for (String type : types) {
                    hndMap.put(type, hnd);
                    log.fine(type);
                }
            }
        }
        Collection&lt;PluginHandler&gt; vals = hndMap.values();
        hndArray = vals.toArray(new PluginHandler[vals.size()]);
    }

    static {
        if (&quot;false&quot;.equalsIgnoreCase(
                System.getProperty(&quot;com.sun.browser.plugin&quot;)))
        {
            for(PluginHandler hnd : getAvailablePlugins()) {
                disabledPluginHandlers.add(hnd.getClass().getCanonicalName());
            }
        }

        updatePluginHandlers();
    }

    public static Plugin createPlugin(URL url, String type, String[] pNames,
                                        String[] pValues)
    {
        try {
            PluginHandler hnd =  hndMap.get(type);
            if (hnd == null) {
                return new DefaultPlugin(url, type, pNames, pValues);
            } else {
                Plugin p = hnd.createPlugin(url, type, pNames, pValues);
                if (p == null) {
                    return new DefaultPlugin(url, type, pNames, pValues);
                } else {
                    return p;
                }
            }
        } catch (Throwable ex) {
            log.fine(&quot;Cannot create plugin&quot; , ex);
            return new DefaultPlugin(url, type, pNames, pValues);
        }
    }


    private static List&lt;PluginHandler&gt; getAvailablePlugins() {
        Vector&lt;PluginHandler&gt; res = new Vector&lt;PluginHandler&gt;();
        Iterator&lt;PluginHandler&gt; iter = pHandlers.iterator();
        while(iter.hasNext()) {
            PluginHandler hnd = iter.next();
            if (hnd.isSupportedPlatform()) {
                res.add(hnd);
            }
        }
        return res;
    }

    private static PluginHandler getEnabledPlugin(int i) {
        if (i &lt; 0 || i &gt;= hndArray.length) return null;
        return hndArray[i];
    }

    private static int getEnabledPluginCount() {
        return hndArray.length;
    }

    private static void disablePlugin(PluginHandler hnd) {
        disabledPluginHandlers.add(hnd.getClass().getCanonicalName());
        updatePluginHandlers();
    }

    private static void enablePlugin(PluginHandler hnd) {
        disabledPluginHandlers.remove(hnd.getClass().getCanonicalName());
        updatePluginHandlers();
    }

    private static boolean isDisabledPlugin(PluginHandler hnd) {
        return disabledPluginHandlers.contains(
            hnd.getClass().getCanonicalName());
    }

    private static boolean supportsMIMEType(String mimeType) {
        return hndMap.containsKey(mimeType);
    }

    private static String getPluginNameForMIMEType(String mimeType) {
        PluginHandler hnd = hndMap.get(mimeType);
        if (hnd != null) return hnd.getName();
        return &quot;&quot;;
    }
}
</PRE>

</BODY>
</HTML>
