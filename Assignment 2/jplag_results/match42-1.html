<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/binding/When.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.beans.binding;

import java.lang.ref.WeakReference;

import javafx.beans.InvalidationListener;
import javafx.beans.NamedArg;
import javafx.beans.Observable;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableDoubleValue;
import javafx.beans.value.ObservableFloatValue;
import javafx.beans.value.ObservableLongValue;
import javafx.beans.value.ObservableNumberValue;
import javafx.beans.value.ObservableObjectValue;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import com.sun.javafx.binding.DoubleConstant;
import com.sun.javafx.binding.FloatConstant;
import com.sun.javafx.binding.IntegerConstant;
import com.sun.javafx.binding.Logging;
import com.sun.javafx.binding.LongConstant;

/**
 * Starting point for a binding that calculates a ternary expression.
 * &lt;p&gt;
 * A ternary expression has the basic form
 * {@code new When(cond).then(value1).otherwise(value2);}. The expression
 * {@code cond} needs to be a {@link javafx.beans.value.ObservableBooleanValue}.
 * Based on the value of {@code cond}, the binding contains the value of
 * {@code value1} (if {@code cond.getValue() == true}) or {@code value2} (if
 * {@code cond.getValue() == false}). The values {@code value1} and
 * {@code value2} have to be of the same type. They can be constant values or
 * implementations of {@link javafx.beans.value.ObservableValue}.
 * @since JavaFX 2.0
 */
public class When {
    private final ObservableBooleanValue condition;

    /**
     * The constructor of {@code When}.
     *
     * @param condition
     *            the condition of the ternary expression
     */
    public When(final @NamedArg(&quot;condition&quot;) ObservableBooleanValue condition) {
        if (condition == null) {
            throw new NullPointerException(&quot;Condition must be specified.&quot;);
        }
        this.condition = condition;
    }

    private static class WhenListener implements InvalidationListener {

        private final ObservableBooleanValue condition;
        private final ObservableValue&lt;?&gt; thenValue;
        private final ObservableValue&lt;?&gt; otherwiseValue;
        private final WeakReference&lt;Binding&lt;?&gt;&gt; ref;

        private WhenListener(Binding&lt;?&gt; binding, ObservableBooleanValue condition, ObservableValue&lt;?&gt; thenValue, ObservableValue&lt;?&gt; otherwiseValue) {
            this.ref = new WeakReference&lt;Binding&lt;?&gt;&gt;(binding);
            this.condition = condition;
            this.thenValue = thenValue;
            this.otherwiseValue = otherwiseValue;
        }

        @Override
        public void invalidated(Observable observable) {
            final Binding&lt;?&gt; binding = ref.get();
            if (binding == null) {
                condition.removeListener(this);
                if (thenValue != null) {
                    thenValue.removeListener(this);
                }
                if (otherwiseValue != null) {
                    otherwiseValue.removeListener(this);
                }
            } else {
                // short-circuit invalidation. This Binding becomes
                // only invalid if the condition changes or the
                // active branch.
                if (condition.equals(observable) || (binding.isValid() &amp;&amp; (condition.get() == observable.equals(thenValue)))) {
                    binding.invalidate();
                }
            }
        }

    }

    private static NumberBinding createNumberCondition(
            final ObservableBooleanValue condition,
            final ObservableNumberValue thenValue,
            final ObservableNumberValue otherwiseValue) {
        if ((thenValue instanceof ObservableDoubleValue) || (otherwiseValue instanceof ObservableDoubleValue)) {
            return new DoubleBinding() {
                final InvalidationListener observer = new WhenListener(this, condition, thenValue, otherwiseValue);
                {
                    condition.addListener(observer);
                    thenValue.addListener(observer);
                    otherwiseValue.addListener(observer);
                }

                @Override
                public void dispose() {
                    condition.removeListener(observer);
                    thenValue.removeListener(observer);
                    otherwiseValue.removeListener(observer);
                }

                @Override
                protected double computeValue() {
                    final boolean conditionValue = condition.get();
                    Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
                    return conditionValue ? thenValue.doubleValue() : otherwiseValue.doubleValue();
                }

                @Override
                public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                    return FXCollections.unmodifiableObservableList(
                            FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition, thenValue, otherwiseValue));
                }
            };
        } else if ((thenValue instanceof ObservableFloatValue) || (otherwiseValue instanceof ObservableFloatValue)) {
            return new FloatBinding() {
                final InvalidationListener observer = new WhenListener(this, condition, thenValue, otherwiseValue);
                {
                    condition.addListener(observer);
                    thenValue.addListener(observer);
                    otherwiseValue.addListener(observer);
                }

                @Override
                public void dispose() {
                    condition.removeListener(observer);
                    thenValue.removeListener(observer);
                    otherwiseValue.removeListener(observer);
                }

                @Override
                protected float computeValue() {
                    final boolean conditionValue = condition.get();
                    Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
                    return conditionValue ? thenValue.floatValue() : otherwiseValue.floatValue();
                }

                @Override
                public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                    return FXCollections.unmodifiableObservableList(
                            FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition, thenValue, otherwiseValue));
                }
            };
        } else if ((thenValue instanceof ObservableLongValue) || (otherwiseValue instanceof ObservableLongValue)) {
            return new LongBinding() {
                final InvalidationListener observer = new WhenListener(this, condition, thenValue, otherwiseValue);
                {
                    condition.addListener(observer);
                    thenValue.addListener(observer);
                    otherwiseValue.addListener(observer);
                }

                @Override
                public void dispose() {
                    condition.removeListener(observer);
                    thenValue.removeListener(observer);
                    otherwiseValue.removeListener(observer);
                }

                @Override
                protected long computeValue() {
                    final boolean conditionValue = condition.get();
                    Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
                    return conditionValue ? thenValue.longValue() : otherwiseValue.longValue();
                }

                @Override
                public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                    return FXCollections.unmodifiableObservableList(
                            FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition, thenValue, otherwiseValue));
                }
            };
        } else {
            return new IntegerBinding() {
                final InvalidationListener observer = new WhenListener(this, condition, thenValue, otherwiseValue);
                {
                    condition.addListener(observer);
                    thenValue.addListener(observer);
                    otherwiseValue.addListener(observer);
                }

                @Override
                public void dispose() {
                    condition.removeListener(observer);
                    thenValue.removeListener(observer);
                    otherwiseValue.removeListener(observer);
                }

                @Override
                protected int computeValue() {
                    final boolean conditionValue = condition.get();
                    Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
                    return conditionValue ? thenValue.intValue(): otherwiseValue.intValue();
                }

                @Override
                public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
                    return FXCollections.unmodifiableObservableList(
                            FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition, thenValue, otherwiseValue));
                }
            };
        }
    }

    /**
     * If-then-else expression returning a number.
     * @since JavaFX 2.0
     */
    public class NumberConditionBuilder {

        private ObservableNumberValue thenValue;

        private NumberConditionBuilder(final ObservableNumberValue thenValue) {
            this.thenValue = thenValue;
        }

        /**
         * Defines the {@link javafx.beans.value.ObservableNumberValue} which
         * value is returned by the ternary expression if the condition is
         * {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link DoubleBinding}
         */
        public NumberBinding otherwise(ObservableNumberValue otherwiseValue) {
            if (otherwiseValue == null) {
                throw new NullPointerException(&quot;Value needs to be specified&quot;);
            }
            return When.createNumberCondition(condition, thenValue, otherwiseValue);
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link DoubleBinding}
         */
        public DoubleBinding otherwise(double otherwiseValue) {
            return (DoubleBinding) otherwise(DoubleConstant.valueOf(otherwiseValue));
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link NumberBinding}
         */
        public NumberBinding otherwise(float otherwiseValue) {
            return otherwise(FloatConstant.valueOf(otherwiseValue));
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link NumberBinding}
         */
        public NumberBinding otherwise(long otherwiseValue) {
            return otherwise(LongConstant.valueOf(otherwiseValue));
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link NumberBinding}
         */
        public NumberBinding otherwise(int otherwiseValue) {
            return otherwise(IntegerConstant.valueOf(otherwiseValue));
        }
    }

    /**
     * Defines the {@link javafx.beans.value.ObservableNumberValue} which value
     * is returned by the ternary expression if the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public NumberConditionBuilder then(final ObservableNumberValue thenValue) {
        if (thenValue == null) {
            throw new NullPointerException(&quot;Value needs to be specified&quot;);
        }
        return new NumberConditionBuilder(thenValue);
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public NumberConditionBuilder then(double thenValue) {
        return new NumberConditionBuilder(DoubleConstant.valueOf(thenValue));
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public NumberConditionBuilder then(float thenValue) {
        return new NumberConditionBuilder(FloatConstant.valueOf(thenValue));
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public NumberConditionBuilder then(long thenValue) {
        return new NumberConditionBuilder(LongConstant.valueOf(thenValue));
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public NumberConditionBuilder then(int thenValue) {
        return new NumberConditionBuilder(IntegerConstant.valueOf(thenValue));
    }

    /**
     * If-then-else expression returning Boolean.
     */
    private class BooleanCondition extends BooleanBinding {
        private final ObservableBooleanValue trueResult;
        private final boolean trueResultValue;

        private final ObservableBooleanValue falseResult;
        private final boolean falseResultValue;

        private final InvalidationListener observer;

        private BooleanCondition(final ObservableBooleanValue then, final ObservableBooleanValue otherwise) {
            this.trueResult = then;
<A NAME="28"></A>            this.trueResultValue = false;
            this.falseResult = otherwise;
            this.falseResultValue = false;
            <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#28',2,'match42-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.observer = new WhenListener(this, condition, then, otherwise);
            condition.addListener(observer);
            then.addListener(observer);
            otherwise.addListener(observer);
        }

        private BooleanCondition(final boolean then</B></FONT>, final ObservableBooleanValue otherwise) {
            this.trueResult = null;
            this.trueResultValue = then;
            this.falseResult = otherwise;
            this.falseResultValue = false;
            this.observer = new WhenListener(this, condition, null, otherwise);
            condition.addListener(observer);
            otherwise.addListener(observer);
        }

        private BooleanCondition(final ObservableBooleanValue then, final boolean otherwise) {
            this.trueResult = then;
            this.trueResultValue = false;
            this.falseResult = null;
            this.falseResultValue = otherwise;
            this.observer = new WhenListener(this, condition, then, null);
            condition.addListener(observer);
            then.addListener(observer);
        }

        private BooleanCondition(final boolean then, final boolean otherwise) {
            this.trueResult = null;
            this.trueResultValue = then;
            this.falseResult = null;
            this.falseResultValue = otherwise;
            this.observer = null;
            super.bind(condition);
        }

        @Override
        protected boolean computeValue() {
            final boolean conditionValue = condition.get();
            Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
            return conditionValue ? (trueResult != null ? trueResult.get() : trueResultValue)
                    : (falseResult != null ? falseResult.get() : falseResultValue);
        }

        @Override
        public void dispose() {
            if (observer == null) {
                super.unbind(condition);
            } else {
                condition.removeListener(observer);
                if (trueResult != null) {
                    trueResult.removeListener(observer);
                }
                if (falseResult != null) {
                    falseResult.removeListener(observer);
                }
            }
        }

        @Override
        public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
            assert condition != null;
            final ObservableList&lt;ObservableValue&lt;?&gt;&gt; seq = FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition);
            if (trueResult != null) {
                seq.add(trueResult);
            }
            if (falseResult != null) {
                seq.add(falseResult);
            }
            return FXCollections.unmodifiableObservableList(seq);
        }
    }

    /**
     * An intermediate class needed while assembling the ternary expression. It
     * should not be used in another context.
     * @since JavaFX 2.0
     */
    public class BooleanConditionBuilder {

        private ObservableBooleanValue trueResult;
        private boolean trueResultValue;

        private BooleanConditionBuilder(final ObservableBooleanValue thenValue) {
            this.trueResult = thenValue;
        }

        private BooleanConditionBuilder(final boolean thenValue) {
            this.trueResultValue = thenValue;
        }

        /**
         * Defines the {@link javafx.beans.value.ObservableBooleanValue} which
         * value is returned by the ternary expression if the condition is
         * {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link BooleanBinding}
         */
        public BooleanBinding otherwise(final ObservableBooleanValue otherwiseValue) {
            if (otherwiseValue == null) {
                throw new NullPointerException(&quot;Value needs to be specified&quot;);
            }
            if (trueResult != null)
                return new BooleanCondition(trueResult, otherwiseValue);
            else
                return new BooleanCondition(trueResultValue, otherwiseValue);
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link BooleanBinding}
         */
        public BooleanBinding otherwise(final boolean otherwiseValue) {
            if (trueResult != null)
                return new BooleanCondition(trueResult, otherwiseValue);
            else
                return new BooleanCondition(trueResultValue, otherwiseValue);
        }
    }

    /**
     * Defines the {@link javafx.beans.value.ObservableBooleanValue} which value
     * is returned by the ternary expression if the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public BooleanConditionBuilder then(final ObservableBooleanValue thenValue) {
        if (thenValue == null) {
            throw new NullPointerException(&quot;Value needs to be specified&quot;);
        }
        return new BooleanConditionBuilder(thenValue);
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public BooleanConditionBuilder then(final boolean thenValue) {
        return new BooleanConditionBuilder(thenValue);
    }

    /**
     * If-then-else expression returning String.
     */
    private class StringCondition extends StringBinding {

        private final ObservableStringValue trueResult;
        private final String trueResultValue;

        private final ObservableStringValue falseResult;
        private final String falseResultValue;

        private final InvalidationListener observer;

        private StringCondition(final ObservableStringValue then, final ObservableStringValue otherwise) {
            this.trueResult = then;
            this.trueResultValue = &quot;&quot;;
            this.falseResult = otherwise;
            this.falseResultValue = &quot;&quot;;
            this.observer = new WhenListener(this, condition, then, otherwise);
            condition.addListener(observer);
            then.addListener(observer);
            otherwise.addListener(observer);
        }

        private StringCondition(final String then, final ObservableStringValue otherwise) {
            this.trueResult = null;
            this.trueResultValue = then;
            this.falseResult = otherwise;
            this.falseResultValue = &quot;&quot;;
            this.observer = new WhenListener(this, condition, null, otherwise);
            condition.addListener(observer);
            otherwise.addListener(observer);
        }

        private StringCondition(final ObservableStringValue then, final String otherwise) {
            this.trueResult = then;
            this.trueResultValue = &quot;&quot;;
            this.falseResult = null;
            this.falseResultValue = otherwise;
            this.observer = new WhenListener(this, condition, then, null);
            condition.addListener(observer);
            then.addListener(observer);
        }

        private StringCondition(final String then, final String otherwise) {
            this.trueResult = null;
            this.trueResultValue = then;
            this.falseResult = null;
            this.falseResultValue = otherwise;
            this.observer = null;
            super.bind(condition);
        }

        @Override
        protected String computeValue() {
            final boolean conditionValue = condition.get();
            Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
            return conditionValue ? (trueResult != null ? trueResult.get() : trueResultValue)
                    : (falseResult != null ? falseResult.get() : falseResultValue);
        }

        @Override
        public void dispose() {
            if (observer == null) {
                super.unbind(condition);
            } else {
                condition.removeListener(observer);
                if (trueResult != null) {
                    trueResult.removeListener(observer);
                }
                if (falseResult != null) {
                    falseResult.removeListener(observer);
                }
            }
        }


        @Override
        public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
            assert condition != null;
            final ObservableList&lt;ObservableValue&lt;?&gt;&gt; seq = FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition);
            if (trueResult != null) {
                seq.add(trueResult);
            }
            if (falseResult != null) {
                seq.add(falseResult);
            }
            return FXCollections.unmodifiableObservableList(seq);
        }
    }

    /**
     * An intermediate class needed while assembling the ternary expression. It
     * should not be used in another context.
     * @since JavaFX 2.0
     */
    public class StringConditionBuilder {

        private ObservableStringValue trueResult;
        private String trueResultValue;

        private StringConditionBuilder(final ObservableStringValue thenValue) {
            this.trueResult = thenValue;
        }

        private StringConditionBuilder(final String thenValue) {
            this.trueResultValue = thenValue;
        }

        /**
         * Defines the {@link javafx.beans.value.ObservableStringValue} which
         * value is returned by the ternary expression if the condition is
         * {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link StringBinding}
         */
        public StringBinding otherwise(final ObservableStringValue otherwiseValue) {
            if (trueResult != null)
                return new StringCondition(trueResult, otherwiseValue);
            else
                return new StringCondition(trueResultValue, otherwiseValue);
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link StringBinding}
         */
        public StringBinding otherwise(final String otherwiseValue) {
            if (trueResult != null)
                return new StringCondition(trueResult, otherwiseValue);
            else
                return new StringCondition(trueResultValue, otherwiseValue);
        }
    }

    /**
     * Defines the {@link javafx.beans.value.ObservableStringValue} which value
     * is returned by the ternary expression if the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public StringConditionBuilder then(final ObservableStringValue thenValue) {
        if (thenValue == null) {
            throw new NullPointerException(&quot;Value needs to be specified&quot;);
        }
        return new StringConditionBuilder(thenValue);
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public StringConditionBuilder then(final String thenValue) {
        return new StringConditionBuilder(thenValue);
    }

    /**
     * If-then-else expression returning general objects.
     */
    private class ObjectCondition&lt;T&gt; extends ObjectBinding&lt;T&gt; {

        private final ObservableObjectValue&lt;T&gt; trueResult;
        private final T trueResultValue;

        private final ObservableObjectValue&lt;T&gt; falseResult;
        private final T falseResultValue;

        private final InvalidationListener observer;

        private ObjectCondition(final ObservableObjectValue&lt;T&gt; then, final ObservableObjectValue&lt;T&gt; otherwise) {
            this.trueResult = then;
            this.trueResultValue = null;
            this.falseResult = otherwise;
            this.falseResultValue = null;
            this.observer = new WhenListener(this, condition, then, otherwise);
            condition.addListener(observer);
            then.addListener(observer);
            otherwise.addListener(observer);
        }

        private ObjectCondition(final T then, final ObservableObjectValue&lt;T&gt; otherwise) {
            this.trueResult = null;
            this.trueResultValue = then;
            this.falseResult = otherwise;
            this.falseResultValue = null;
            this.observer = new WhenListener(this, condition, null, otherwise);
            condition.addListener(observer);
            otherwise.addListener(observer);
        }

        private ObjectCondition(final ObservableObjectValue&lt;T&gt; then, final T otherwise) {
            this.trueResult = then;
            this.trueResultValue = null;
            this.falseResult = null;
            this.falseResultValue = otherwise;
            this.observer = new WhenListener(this, condition, then, null);
            condition.addListener(observer);
            then.addListener(observer);
        }

        private ObjectCondition(final T then, final T otherwise) {
            this.trueResult = null;
            this.trueResultValue = then;
            this.falseResult = null;
            this.falseResultValue = otherwise;
            this.observer = null;
            super.bind(condition);
        }

        @Override
        protected T computeValue() {
            final boolean conditionValue = condition.get();
            Logging.getLogger().finest(&quot;Condition of ternary binding expression was evaluated: {0}&quot;, conditionValue);
            return conditionValue ? (trueResult != null ? trueResult.get() : trueResultValue)
                    : (falseResult != null ? falseResult.get() : falseResultValue);
        }

        @Override
        public void dispose() {
            if (observer == null) {
                super.unbind(condition);
            } else {
                condition.removeListener(observer);
                if (trueResult != null) {
                    trueResult.removeListener(observer);
                }
                if (falseResult != null) {
                    falseResult.removeListener(observer);
                }
            }
        }


        @Override
        public ObservableList&lt;ObservableValue&lt;?&gt;&gt; getDependencies() {
            assert condition != null;
            final ObservableList&lt;ObservableValue&lt;?&gt;&gt; seq = FXCollections.&lt;ObservableValue&lt;?&gt;&gt; observableArrayList(condition);
            if (trueResult != null) {
                seq.add(trueResult);
            }
            if (falseResult != null) {
                seq.add(falseResult);
            }
            return FXCollections.unmodifiableObservableList(seq);
        }
    }

    /**
     * An intermediate class needed while assembling the ternary expression. It
     * should not be used in another context.
     * @since JavaFX 2.0
     */
    public class ObjectConditionBuilder&lt;T&gt; {

        private ObservableObjectValue&lt;T&gt; trueResult;
        private T trueResultValue;

        private ObjectConditionBuilder(final ObservableObjectValue&lt;T&gt; thenValue) {
            this.trueResult = thenValue;
        }

        private ObjectConditionBuilder(final T thenValue) {
            this.trueResultValue = thenValue;
        }

        /**
         * Defines the {@link javafx.beans.value.ObservableObjectValue} which
         * value is returned by the ternary expression if the condition is
         * {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link ObjectBinding}
         */
        public ObjectBinding&lt;T&gt; otherwise(final ObservableObjectValue&lt;T&gt; otherwiseValue) {
            if (otherwiseValue == null) {
                throw new NullPointerException(&quot;Value needs to be specified&quot;);
            }
            if (trueResult != null)
                return new ObjectCondition&lt;T&gt;(trueResult, otherwiseValue);
            else
                return new ObjectCondition&lt;T&gt;(trueResultValue, otherwiseValue);
        }

        /**
         * Defines a constant value of the ternary expression, that is returned
         * if the condition is {@code false}.
         *
         * @param otherwiseValue
         *            the value
         * @return the complete {@link ObjectBinding}
         */
        public ObjectBinding&lt;T&gt; otherwise(final T otherwiseValue) {
            if (trueResult != null)
                return new ObjectCondition&lt;T&gt;(trueResult, otherwiseValue);
            else
                return new ObjectCondition&lt;T&gt;(trueResultValue, otherwiseValue);
        }
    }

    /**
     * Defines the {@link javafx.beans.value.ObservableObjectValue} which value
     * is returned by the ternary expression if the condition is {@code true}.
     *
     * @param &lt;T&gt; the type of the intermediate result
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public &lt;T&gt; ObjectConditionBuilder&lt;T&gt; then(final ObservableObjectValue&lt;T&gt; thenValue) {
        if (thenValue == null) {
            throw new NullPointerException(&quot;Value needs to be specified&quot;);
        }
        return new ObjectConditionBuilder&lt;T&gt;(thenValue);
    }

    /**
     * Defines a constant value of the ternary expression, that is returned if
     * the condition is {@code true}.
     *
     * @param &lt;T&gt; the type of the intermediate result
     * @param thenValue
     *            the value
     * @return the intermediate result which still requires the otherwise-branch
     */
    public &lt;T&gt; ObjectConditionBuilder&lt;T&gt; then(final T thenValue) {
        return new ObjectConditionBuilder&lt;T&gt;(thenValue);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/collections/ListChangeBuilder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.collections;

import com.sun.javafx.collections.ChangeHelper;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;
import javafx.collections.ListChangeListener.Change;

final class ListChangeBuilder&lt;E&gt; {

    private static final int[] EMPTY_PERM = new int[0];
    private final ObservableListBase&lt;E&gt; list;
    private int changeLock;
    private List&lt;SubChange&lt;E&gt;&gt; addRemoveChanges;
    private List&lt;SubChange&lt;E&gt;&gt; updateChanges;
    private SubChange&lt;E&gt; permutationChange;

    private void checkAddRemoveList() {
        if (addRemoveChanges == null) {
            addRemoveChanges = new ArrayList&lt;SubChange&lt;E&gt;&gt;();
        }
    }

    private void checkState() {
        if (changeLock == 0) {
            throw new IllegalStateException(&quot;beginChange was not called on this builder&quot;);
        }
    }

    private int findSubChange(int idx, final List&lt;SubChange&lt;E&gt;&gt; list) {
        int from = 0;
        int to = list.size() - 1;

        while (from &lt;= to) {
            int changeIdx  = (from + to) / 2;
            SubChange&lt;E&gt; change = list.get(changeIdx);

            if (idx &gt;= change.to) {
                from = changeIdx + 1;
            } else if (idx &lt; change.from) {
                to = changeIdx - 1;
            } else {
                return changeIdx;
            }
        }
        return ~from;
    }

    private void insertUpdate(int pos) {
        int idx = findSubChange(pos, updateChanges);
        if (idx &lt; 0) { //If not found
            idx = ~idx;
            SubChange&lt;E&gt; change;
            if (idx &gt; 0 &amp;&amp; (change = updateChanges.get(idx - 1)).to == pos) {
                change.to = pos + 1;
            } else if (idx &lt; updateChanges.size() &amp;&amp; (change = updateChanges.get(idx)).from == pos + 1) {
                change.from = pos;
            } else {
                updateChanges.add(idx, new SubChange&lt;E&gt;(pos, pos + 1, null, EMPTY_PERM, true));
            }
        } // If found, no need to do another update
    }

    private void insertRemoved(int pos, final E removed) {
        int idx = findSubChange(pos, addRemoveChanges);
        if (idx &lt; 0) { // Not found
            idx = ~idx;
            SubChange&lt;E&gt; change;

            if (idx &gt; 0 &amp;&amp; (change = addRemoveChanges.get(idx - 1)).to == pos) {
                change.removed.add(removed);
                --idx; // Idx index will be used as a starting point for update
            } else if (idx &lt; addRemoveChanges.size() &amp;&amp; (change = addRemoveChanges.get(idx)).from == pos + 1) {
                change.from--;
                change.to--;
                change.removed.add(0, removed);
            } else {
                ArrayList&lt;E&gt; removedList = new ArrayList&lt;E&gt;();
                removedList.add(removed);
                addRemoveChanges.add(idx, new SubChange&lt;E&gt;(pos, pos, removedList, EMPTY_PERM, false));
            }
        } else {
            SubChange&lt;E&gt; change = addRemoveChanges.get(idx);
            change.to--; // Removed one element from the previously added list
            if (change.from == change.to &amp;&amp; (change.removed == null || change.removed.isEmpty())) {
                    addRemoveChanges.remove(idx);
            }
        }
        for (int i = idx + 1; i &lt; addRemoveChanges.size(); ++i) {
            SubChange&lt;E&gt; change = addRemoveChanges.get(i);
            change.from--;
            change.to--;
        }
    }

    private void insertAdd(int from, int to) {
        int idx = findSubChange(from, addRemoveChanges);
        final int numberOfAdded = to - from;

        if (idx &lt; 0) { // Not found
            idx = ~idx;

            SubChange&lt;E&gt; change;
            if (idx &gt; 0 &amp;&amp; (change = addRemoveChanges.get(idx - 1)).to == from) {
                change.to = to;
                --idx;
            } else {
                addRemoveChanges.add(idx, new SubChange&lt;E&gt;(from, to, new ArrayList&lt;E&gt;(), EMPTY_PERM, false));
            }
        } else {
            SubChange&lt;E&gt; change = addRemoveChanges.get(idx);
            change.to += numberOfAdded;
        }

        for (int i = idx + 1; i &lt; addRemoveChanges.size(); ++i) {
            SubChange&lt;E&gt; change = addRemoveChanges.get(i);
            change.from += numberOfAdded;
            change.to += numberOfAdded;
        }
    }

    private int compress(List&lt;SubChange&lt;E&gt;&gt; list) {
        int removed = 0;

        SubChange&lt;E&gt; prev = list.get(0);
        for (int i = 1, sz = list.size(); i &lt; sz; ++i) {
            SubChange&lt;E&gt; cur = list.get(i);
            if (prev.to == cur.from) {
                prev.to = cur.to;
                if (prev.removed != null || cur.removed != null) {
                    if (prev.removed == null) {
                        prev.removed = new ArrayList&lt;E&gt;();
                    }
                    prev.removed.addAll(cur.removed);
                }
                list.set(i, null);
                ++removed;
            } else {
                prev = cur;
            }
        }
        return removed;

    }

    private static class SubChange&lt;E&gt; {

        int from, to;
        List&lt;E&gt; removed;
        int[] perm;
        boolean updated;

        public SubChange(int from, int to, List&lt;E&gt; removed, int[] perm, boolean updated) {
            this.from = from;
            this.to = to;
            this.removed = removed;
            this.perm = perm;
            this.updated = updated;
        }
    }

    ListChangeBuilder(ObservableListBase&lt;E&gt; list) {
        this.list = list;
    }

    public void nextRemove(int idx, E removed) {
        checkState();
        checkAddRemoveList();

        final SubChange&lt;E&gt; last = addRemoveChanges.isEmpty() ? null
                : addRemoveChanges.get(addRemoveChanges.size() - 1);

        if (last != null &amp;&amp; last.to == idx) {
            last.removed.add(removed);
        } else if (last != null &amp;&amp; last.from == idx + 1) {
            last.from--;
            last.to--;
            last.removed.add(0, removed);
        } else {
            insertRemoved(idx, removed);
        }

        if (updateChanges != null &amp;&amp; !updateChanges.isEmpty()) {
            int uPos = findSubChange(idx, updateChanges);
            if (uPos &lt; 0) {
                uPos = ~uPos;
            } else {
                final SubChange&lt;E&gt; change = updateChanges.get(uPos);
                if (change.from == change.to - 1) {
                    updateChanges.remove(uPos);
                } else {
                    change.to--;
                    ++uPos; // Do the update from the next position
                }
            }
            for (int i = uPos; i &lt; updateChanges.size(); ++i) {
                updateChanges.get(i).from--;
                updateChanges.get(i).to--;
            }
        }

    }

<A NAME="79"></A>    public void nextRemove(int idx, List&lt;? extends E&gt; removed) {
        checkState();

        <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#79',2,'match42-top.html#79',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int i = 0; i &lt; removed.size(); ++i) {
            nextRemove(idx, removed.get(i));
        }
    }

    public void nextAdd(int from, int to) {
        checkState();
        checkAddRemoveList</B></FONT>();
        final SubChange&lt;E&gt; last = addRemoveChanges.isEmpty() ? null :
                addRemoveChanges.get(addRemoveChanges.size() - 1);
        final int numberOfAdded = to - from;

        if (last != null &amp;&amp; last.to == from) {
            last.to = to;
        } else if (last != null &amp;&amp; from &gt;= last.from &amp;&amp; from &lt; last.to) { // Adding to the middle
            last.to += numberOfAdded;
        } else {
            insertAdd(from, to);
        }

        if (updateChanges != null &amp;&amp; !updateChanges.isEmpty()) {
            int uPos = findSubChange(from, updateChanges);
            if (uPos &lt; 0) {
                uPos = ~uPos;
            } else {
                // We have to split the change into 2
                SubChange&lt;E&gt; change = updateChanges.get(uPos);
                updateChanges.add(uPos + 1, new SubChange&lt;E&gt;(to, change.to + to - from, null, EMPTY_PERM, true));
                change.to = from;
                uPos += 2; // skip those 2 for the update
            }
            for (int i = uPos; i &lt; updateChanges.size(); ++i) {
                updateChanges.get(i).from += numberOfAdded;
                updateChanges.get(i).to += numberOfAdded;
            }
        }

    }

    public void nextPermutation(int from, int to, int[] perm) {
        checkState();

        int prePermFrom = from;
        int prePermTo = to;
        int[] prePerm = perm;

        if ((addRemoveChanges != null &amp;&amp; !addRemoveChanges.isEmpty())) {
            //Because there were already some changes to the list, we need
            // to &quot;reconstruct&quot; the original list and create a permutation
            // as-if there were no changes to the list. We can then
            // merge this with the permutation we already did

            // This maps elements from current list to the original list.
            // -1 means the map was not in the original list.
            // Note that for performance reasons, the map is permutated when created
            // by the permutation. So it basically contains the order in which the original
            // items were permutated by our new permutation.
            int[] mapToOriginal = new int[list.size()];
            // Marks the original-list indexes that were removed
            Set&lt;Integer&gt; removed = new TreeSet&lt;Integer&gt;();
            int last = 0;
            int offset = 0;
            for (int i = 0, sz = addRemoveChanges.size(); i &lt; sz; ++i) {
                SubChange&lt;E&gt; change = addRemoveChanges.get(i);
                for (int j = last; j &lt; change.from; ++j) {
                    mapToOriginal[j &lt; from || j &gt;= to ? j : perm[j - from]] = j + offset;
                }
                for (int j = change.from; j &lt; change.to; ++j) {
                    mapToOriginal[j &lt; from || j &gt;= to ? j : perm[j - from]] = -1;
                }
                last = change.to;
                int removedSize = (change.removed != null ? change.removed.size() : 0);
                for (int j = change.from + offset, upTo = change.from + offset + removedSize;
                        j &lt; upTo; ++j) {
                    removed.add(j);
                }
                offset += removedSize - (change.to - change.from);

            }
            // from the last add/remove change to the end of the list
            for (int i = last; i &lt; mapToOriginal.length; ++i) {
                mapToOriginal[i &lt; from || i &gt;= to ? i : perm[i - from]] = i + offset;
            }

            int[] newPerm = new int[list.size() + offset];
            int mapPtr = 0;
            for (int i = 0; i &lt; newPerm.length; ++i) {
                if (removed.contains(i)) {
                    newPerm[i] = i;
                } else {
                    while(mapToOriginal[mapPtr] == -1) {
                        mapPtr++;
                    }
                    newPerm[mapToOriginal[mapPtr++]] = i;
                }
            }

            // We could theoretically find the first and last items such that
            // newPerm[i] != i and trim the permutation, but it is not necessary
            prePermFrom = 0;
            prePermTo = newPerm.length;
            prePerm = newPerm;
        }



        if (permutationChange != null) {
            if (prePermFrom == permutationChange.from &amp;&amp; prePermTo == permutationChange.to) {
                for (int i = 0; i &lt; prePerm.length; ++i) {
                    permutationChange.perm[i] = prePerm[permutationChange.perm[i] - prePermFrom];
                }
            } else {
                final int newTo = Math.max(permutationChange.to, prePermTo);
                final int newFrom = Math.min(permutationChange.from, prePermFrom);
                int[] newPerm = new int[newTo - newFrom];

                for (int i = newFrom; i &lt; newTo; ++i) {
                    if (i &lt; permutationChange.from || i &gt;= permutationChange.to) {
                        newPerm[i - newFrom] = prePerm[i - prePermFrom];
                    } else {
                        int p = permutationChange.perm[i - permutationChange.from];
                        if (p &lt; prePermFrom || p &gt;= prePermTo) {
                            newPerm[i - newFrom] = p;
                        } else {
                            newPerm[i - newFrom] = prePerm[p - prePermFrom];
                        }
                    }
                }

                permutationChange.from = newFrom;
                permutationChange.to = newTo;
                permutationChange.perm = newPerm;
            }
        } else {
            permutationChange = new SubChange&lt;E&gt;(prePermFrom, prePermTo, null, prePerm, false);
        }

        if ((addRemoveChanges != null &amp;&amp; !addRemoveChanges.isEmpty())) {
            Set&lt;Integer&gt; newAdded = new TreeSet&lt;Integer&gt;();
            Map&lt;Integer, List&lt;E&gt;&gt; newRemoved = new HashMap&lt;Integer, List&lt;E&gt;&gt;();
            for (int i = 0, sz = addRemoveChanges.size(); i &lt; sz; ++i) {
                SubChange&lt;E&gt; change = addRemoveChanges.get(i);
                for (int cIndex = change.from; cIndex &lt; change.to; ++cIndex) {
                    if (cIndex &lt; from || cIndex &gt;= to) {
                        newAdded.add(cIndex);
                    } else {
                        newAdded.add(perm[cIndex - from]);
                    }
                }
                if (change.removed != null) {
                    if (change.from &lt; from || change.from &gt;= to) {
                        newRemoved.put(change.from, change.removed);
                    } else {
                        newRemoved.put(perm[change.from - from], change.removed);
                    }
                }
            }
            addRemoveChanges.clear();
            SubChange&lt;E&gt; lastChange = null;
            for (Integer i : newAdded) {
                if (lastChange == null || lastChange.to != i) {
                    lastChange = new SubChange&lt;E&gt;(i, i + 1, null, EMPTY_PERM, false);
                    addRemoveChanges.add(lastChange);
                } else {
                    lastChange.to = i + 1;
                }
                List&lt;E&gt; removed = newRemoved.remove(i);
                if (removed != null) {
                    if (lastChange.removed != null) {
                        lastChange.removed.addAll(removed);
                    } else {
                        lastChange.removed = removed;
                    }
                }
            }

            for(Entry&lt;Integer, List&lt;E&gt;&gt; e : newRemoved.entrySet()) {
                final Integer at = e.getKey();
                int idx = findSubChange(at, addRemoveChanges);
                assert(idx &lt; 0);
                addRemoveChanges.add(~idx, new SubChange&lt;E&gt;(at, at, e.getValue(), new int[0], false));
            }
        }

        if (updateChanges != null &amp;&amp; !updateChanges.isEmpty()) {
            Set&lt;Integer&gt; newUpdated = new TreeSet&lt;Integer&gt;();
            for (int i = 0, sz = updateChanges.size(); i &lt; sz; ++i) {
                SubChange&lt;E&gt; change = updateChanges.get(i);
                for (int cIndex = change.from; cIndex &lt; change.to; ++cIndex) {
                    if (cIndex &lt; from || cIndex &gt;= to) {
                        newUpdated.add(cIndex);
                    } else {
                        newUpdated.add(perm[cIndex - from]);
                    }
                }
            }
            updateChanges.clear();
            SubChange&lt;E&gt; lastUpdateChange = null;
            for (Integer i : newUpdated) {
                if (lastUpdateChange == null || lastUpdateChange.to != i) {
                    lastUpdateChange = new SubChange&lt;E&gt;(i, i + 1, null, EMPTY_PERM, true);
                    updateChanges.add(lastUpdateChange);
                } else {
                    lastUpdateChange.to = i + 1;
                }
            }
        }
    }


    public void nextReplace(int from, int to, List&lt;? extends E&gt; removed) {
        nextRemove(from, removed);
        nextAdd(from, to);
    }

    public void nextSet(int idx, E old) {
        nextRemove(idx, old);
        nextAdd(idx, idx + 1);

    }

    public void nextUpdate(int idx) {
        checkState();
        if (updateChanges == null) {
            updateChanges = new ArrayList&lt;SubChange&lt;E&gt;&gt;();
        }
        final SubChange&lt;E&gt; last = updateChanges.isEmpty() ? null : updateChanges.get(updateChanges.size() - 1);
        if (last != null &amp;&amp; last.to == idx) {
            last.to = idx + 1;
        } else {
            insertUpdate(idx);
        }
    }

    private void commit() {
        final boolean addRemoveNotEmpty = addRemoveChanges != null &amp;&amp; !addRemoveChanges.isEmpty();
        final boolean updateNotEmpty = updateChanges != null &amp;&amp; !updateChanges.isEmpty();
        if (changeLock == 0
                &amp;&amp; (addRemoveNotEmpty
                || updateNotEmpty
                || permutationChange != null)) {
            int totalSize = (updateChanges != null ? updateChanges.size() : 0) +
                    (addRemoveChanges != null ? addRemoveChanges.size() : 0) + (permutationChange != null ? 1 : 0);
            if (totalSize == 1) {
                if (addRemoveNotEmpty) {
                    list.fireChange(new SingleChange&lt;E&gt;(finalizeSubChange(addRemoveChanges.get(0)), list));
                    addRemoveChanges.clear();
                } else if (updateNotEmpty) {
                    list.fireChange(new SingleChange&lt;E&gt;(finalizeSubChange(updateChanges.get(0)), list));
                    updateChanges.clear();
                } else {
                    list.fireChange(new SingleChange&lt;E&gt;(finalizeSubChange(permutationChange), list));
                    permutationChange = null;
                }
            } else {
                if (updateNotEmpty) {
                    int removed = compress(updateChanges);
                    totalSize -= removed;
                }
                if (addRemoveNotEmpty) {
                    int removed = compress(addRemoveChanges);
                    totalSize -= removed;
                }

                SubChange&lt;E&gt;[] array = new SubChange[totalSize];
                int ptr = 0;
                if (permutationChange != null) {
                    array[ptr++] = permutationChange;
                }
                if (addRemoveNotEmpty) {
                    int sz = addRemoveChanges.size();
                    for (int i = 0; i &lt; sz; ++i) {
                        final SubChange&lt;E&gt; change = addRemoveChanges.get(i);
                        if (change != null) {
                            array[ptr++] = change;
                        }
                    }
                }
                if (updateNotEmpty) {
                    int sz = updateChanges.size();
                    for (int i = 0; i &lt; sz; ++i) {
                        final SubChange&lt;E&gt; change = updateChanges.get(i);
                        if (change != null) {
                            array[ptr++] = change;
                        }
                    }
                }
                list.fireChange(new IterableChange&lt;E&gt;(finalizeSubChangeArray(array), list));
                if (addRemoveChanges != null) addRemoveChanges.clear();
                if (updateChanges != null) updateChanges.clear();
                permutationChange = null;
            }
        }
    }

    public void beginChange() {
        changeLock++;
    }

    public void endChange() {
        if (changeLock &lt;= 0) {
            throw new IllegalStateException(&quot;Called endChange before beginChange&quot;);
        }
        changeLock--;
        commit();
    }

    private static &lt;E&gt; SubChange&lt;E&gt;[] finalizeSubChangeArray(final SubChange&lt;E&gt;[] changes) {
        for (SubChange&lt;E&gt; c : changes) {
            finalizeSubChange(c);
        }
        return changes;
    }

    private static &lt;E&gt; SubChange&lt;E&gt; finalizeSubChange(final SubChange&lt;E&gt; c) {
        if (c.perm == null) {
            c.perm = EMPTY_PERM;
        }
        if (c.removed == null) {
            c.removed = Collections.&lt;E&gt;emptyList();
        } else {
            c.removed = Collections.unmodifiableList(c.removed);
        }
        return c;
    }

    private static class SingleChange&lt;E&gt; extends Change&lt;E&gt; {
        private final SubChange&lt;E&gt; change;
        private boolean onChange;

        public SingleChange(SubChange&lt;E&gt; change, ObservableListBase&lt;E&gt; list) {
            super(list);
            this.change = change;
        }

        @Override
        public boolean next() {
            if (onChange) {
                return false;
            }
            onChange = true;
            return true;
        }

        @Override
        public void reset() {
            onChange = false;
        }

        @Override
        public int getFrom() {
            checkState();
            return change.from;
        }

        @Override
        public int getTo() {
            checkState();
            return change.to;
        }

        @Override
        public List&lt;E&gt; getRemoved() {
            checkState();
            return change.removed;
        }

        @Override
        protected int[] getPermutation() {
            checkState();
            return change.perm;
        }

        @Override
        public boolean wasUpdated() {
            checkState();
            return change.updated;
        }

        private void checkState() {
            if (!onChange) {
                throw new IllegalStateException(&quot;Invalid Change state: next() must be called before inspecting the Change.&quot;);
            }
        }

        @Override
        public String toString() {
            String ret;
            if (change.perm.length != 0) {
                ret = ChangeHelper.permChangeToString(change.perm);
            } else if (change.updated) {
                ret = ChangeHelper.updateChangeToString(change.from, change.to);
            } else {
                ret = ChangeHelper.addRemoveChangeToString(change.from, change.to, getList(), change.removed);
            }
            return &quot;{ &quot; + ret + &quot; }&quot;;
        }

    }


    private static class IterableChange&lt;E&gt; extends Change&lt;E&gt; {

        private SubChange[] changes;
        private int cursor = -1;

        private IterableChange(SubChange[] changes, ObservableList&lt;E&gt; list) {
            super(list);
            this.changes = changes;
        }

        @Override
        public boolean next() {
            if (cursor + 1 &lt; changes.length) {
                ++cursor;
                return true;
            }
            return false;
        }

        @Override
        public void reset() {
            cursor = -1;
        }

        @Override
        public int getFrom() {
            checkState();
            return changes[cursor].from;
        }

        @Override
        public int getTo() {
            checkState();
            return changes[cursor].to;
        }

        @Override
        public List&lt;E&gt; getRemoved() {
            checkState();
            return changes[cursor].removed;
        }

        @Override
        protected int[] getPermutation() {
            checkState();
            return changes[cursor].perm;
        }

        @Override
        public boolean wasUpdated() {
            checkState();
            return changes[cursor].updated;
        }

        private void checkState() {
            if (cursor == -1) {
                throw new IllegalStateException(&quot;Invalid Change state: next() must be called before inspecting the Change.&quot;);
            }
        }

        @Override
        public String toString() {
            int c = 0;
            StringBuilder b = new StringBuilder();
            b.append(&quot;{ &quot;);
            while (c &lt; changes.length) {
                if (changes[c].perm.length != 0) {
                    b.append(ChangeHelper.permChangeToString(changes[c].perm));
                } else if (changes[c].updated) {
                    b.append(ChangeHelper.updateChangeToString(changes[c].from, changes[c].to));
                } else {
                    b.append(ChangeHelper.addRemoveChangeToString(changes[c].from, changes[c].to, getList(), changes[c].removed));
                }
                if (c != changes.length - 1) {
                    b.append(&quot;, &quot;);
                }
                ++c;
            }
            b.append(&quot; }&quot;);
            return b.toString();
        }

    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/ContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Direction;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.*;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.stage.Window;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * This is a the SkinBase for ContextMenu based controls so that the CSS parts
 * work right, because otherwise we would have to copy the Keys from there to here.
 */
public class ContextMenuContent extends Region {

    private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;

    private ContextMenu contextMenu;

    /***************************************************************************
     * UI subcomponents
     **************************************************************************/

    private double maxGraphicWidth = 0; // we keep this margin to left for graphic
    private double maxRightWidth = 0;
    private double maxLabelWidth = 0;
    private double maxRowHeight = 0;
    private double maxLeftWidth = 0;
    private double oldWidth = 0;

    private Rectangle clipRect;
    MenuBox itemsContainer;
    private ArrowMenuItem upArrow;
    private ArrowMenuItem downArrow;

    /*
     * We maintain a current focused index which is used
     * in keyboard navigation of menu items.
     */
    private int currentFocusedIndex = -1;

    private boolean itemsDirty = true;
    private InvalidationListener popupShowingListener = arg0 -&gt; {
        updateItems();
    };
    private WeakInvalidationListener weakPopupShowingListener =
            new WeakInvalidationListener(popupShowingListener);


    /***************************************************************************
     * Constructors
     **************************************************************************/
    public ContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        clipRect = new Rectangle();
         clipRect.setSmooth(false);
        itemsContainer = new MenuBox();
//        itemsContainer = new VBox();
        itemsContainer.setClip(clipRect);

        upArrow = new ArrowMenuItem(this);
        upArrow.setUp(true);
        upArrow.setFocusTraversable(false);

        downArrow = new ArrowMenuItem(this);
        downArrow.setUp(false);
        downArrow.setFocusTraversable(false);
        getChildren().add(itemsContainer);
        getChildren().add(upArrow);
        getChildren().add(downArrow);
        initialize();
        setUpBinds();
        updateItems();
        // RT-20197 add menuitems only on first show.
        popupMenu.showingProperty().addListener(weakPopupShowingListener);

        /*
        ** only add this if we're on an embedded
        ** platform that supports 5-button navigation
        */
        if (Utils.isTwoLevelFocus()) {
            new TwoLevelFocusPopupBehavior(this);
        }
    }

    //For access from controls
    public VBox getItemsContainer() {
        return itemsContainer;
    }
    //For testing purpose only
    int getCurrentFocusIndex() {
        return currentFocusedIndex;
    }
    //For testing purpose only
    void setCurrentFocusedIndex(int index) {
        if (index &lt; itemsContainer.getChildren().size()) {
            currentFocusedIndex = index;
        }
    }

    private void updateItems() {
        if (itemsDirty) {
            updateVisualItems();
            itemsDirty = false;
        }
    }

    private void computeVisualMetrics() {
        maxRightWidth = 0;
        maxLabelWidth = 0;
        maxRowHeight = 0;
        maxGraphicWidth = 0;
        maxLeftWidth = 0;

        for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node child = itemsContainer.getChildren().get(i);
            if (child instanceof MenuItemContainer) {
                final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);

                if (! menuItemContainer.isVisible()) continue;

                double alt = -1;
                Node n = menuItemContainer.left;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.graphic;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.label;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) {
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.right;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }
            }
        }

        // Fix for RT-38838.
        // This fixes the issue where CSS is applied to a menu after it has been
        // showing, resulting in its bounds changing. In this case, we need to
        // shift the submenu such that it is properly aligned with its parent menu.
        //
        // To do this, we must firstly determine if the open submenu is shifted
        // horizontally to appear on the other side of this menu, as this is the
        // only situation where shifting has to happen. If so, we need to check
        // if we should shift the submenu due to changes in width.
        //
        // We need to get the parent menu of this contextMenu, so that we only
        // modify the X value in the following conditions:
        // 1) There exists a parent menu
        // 2) The parent menu is in the correct position (i.e. to the left of this
        //    menu in normal LTR systems).
        final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
        Window ownerWindow = contextMenu.getOwnerWindow();
        if (ownerWindow instanceof ContextMenu) {
            if (contextMenu.getX() &lt; ownerWindow.getX()) {
                if (oldWidth != newWidth) {
                    contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
                }
            }
        }

        oldWidth = newWidth;
    }

    private void updateVisualItems() {
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();

        disposeVisualItems();

        for (int row = 0; row &lt; getItems().size(); row++) {
            final MenuItem item = getItems().get(row);
            if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
                continue;
            }

            if (item instanceof SeparatorMenuItem) {
                // we don't want the hover highlight for separators, so for
                // now this is the simplest approach - just remove the
                // background entirely. This may cause issues if people
                // intend to style the background differently.
                Node node = ((CustomMenuItem) item).getContent();
                node.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(node);
                // Add the (separator) menu item to properties map of this node.
                // Special casing this for separator :
                // This allows associating this container with SeparatorMenuItem.
                node.getProperties().put(MenuItem.class, item);
            } else {
                MenuItemContainer menuItemContainer = new MenuItemContainer(item);
                menuItemContainer.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(menuItemContainer);
            }
        }

        // Add the Menu to properties map of this skin. Used by QA for testing
        // This enables associating a parent menu for this skin showing menu items.
        if (getItems().size() &gt; 0) {
            final MenuItem item = getItems().get(0);
            getProperties().put(Menu.class, item.getParentMenu());
        }

        // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
        NodeHelper.reapplyCSS(this);
    }

    private void disposeVisualItems() {
        // clean up itemsContainer
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
        for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
            Node n = itemsContainerChilder.get(i);

            if (n instanceof MenuItemContainer) {
                MenuItemContainer container = (MenuItemContainer) n;
                container.visibleProperty().unbind();
                container.dispose();
            }
        }
        itemsContainerChilder.clear();
    }

    /**
     * Can be called by Skins when they need to clean up the content of any
     * ContextMenu instances they might have created. This ensures that contents
     * of submenus if any, also get cleaned up.
     */
    public void dispose() {
        disposeBinds();
        disposeVisualItems();

        disposeContextMenu(submenu);
        submenu = null;
        openSubmenu = null;
        selectedBackground = null;
        if (contextMenu != null) {
            contextMenu.getItems().clear();
            contextMenu = null;
        }
    }

    public void disposeContextMenu(ContextMenu menu) {
        if (menu == null) return;

        Skin&lt;?&gt; skin = menu.getSkin();
        if (skin == null) return;

        ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
        if (cmContent == null) return;

        cmContent.dispose(); // recursive call to dispose submenus.
    }

    @Override protected void layoutChildren() {
        if (itemsContainer.getChildren().size() == 0) return;
        final double x = snappedLeftInset();
        final double y = snappedTopInset();
        final double w = getWidth() - x - snappedRightInset();
        final double h = getHeight() - y - snappedBottomInset();
        final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);

        itemsContainer.resize(w,contentHeight);
        itemsContainer.relocate(x, y);

        if (isFirstShow &amp;&amp; ty == 0) {
            upArrow.setVisible(false);
            isFirstShow = false;
        } else {
            upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
        }
        downArrow.setVisible(ty + contentHeight &gt; (y + h));

        clipRect.setX(0);
        clipRect.setY(0);
        clipRect.setWidth(w);
        clipRect.setHeight(h);
<A NAME="17"></A>
        if (upArrow.isVisible()) {
            final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(<FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#17',2,'match42-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>clipRect.getHeight() - prefHeight));
            clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
            upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
            positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }

        if (downArrow.isVisible()) {
            final double prefHeight = snapSizeY(downArrow.prefHeight(-1))</B></FONT>;
            clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
            downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
            positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }
    }

     @Override protected double computePrefWidth(double height) {
         computeVisualMetrics();
         double prefWidth = 0;
         if (itemsContainer.getChildren().size() == 0) return 0;
         for (Node n : itemsContainer.getChildren()) {
             if (! n.isVisible()) continue;
             prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
         }
         return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
    }

    @Override protected double computePrefHeight(double width) {
        if (itemsContainer.getChildren().size() == 0) return 0;
        final double screenHeight = getScreenHeight();
        final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
        double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
        // the pref height of this menu is the smaller value of the
        // actual pref height and the height of the screens _visual_ bounds.
        double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
        return prefHeight;
    }

    @Override protected double computeMinHeight(double width) {
        return 0.0;
    }

    @Override protected double computeMaxHeight(double height) {
        return getScreenHeight();
    }

    private double getScreenHeight() {
        if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
                contextMenu.getOwnerWindow().getScene() == null) {
            return -1;
        }
        return snapSizeY(com.sun.javafx.util.Utils.getScreen(
            contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());

    }

    private double getContentHeight() {
        double h = 0.0d;
        for (Node i : itemsContainer.getChildren()) {
            if (i.isVisible()) {
               h += snapSizeY(i.prefHeight(-1));
            }
        }
        return h;
    }

    // This handles shifting ty when doing keyboard navigation.
    private void ensureFocusedMenuItemIsVisible(Node node) {
        if (node == null) return;

        final Bounds nodeBounds = node.getBoundsInParent();
        final Bounds clipBounds = clipRect.getBoundsInParent();

        if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
            // this is for moving down the menu
            scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
        } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
            // this is for moving up the menu
            scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
        }
    }

    protected ObservableList&lt;MenuItem&gt; getItems() {
        return contextMenu.getItems();
    }

    /**
     * Finds the index of currently focused item.
     */
    private int findFocusedIndex() {
         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node n = itemsContainer.getChildren().get(i);
            if (n.isFocused()) {
                return i;
            }
        }
        return -1;
    }

    private boolean isFirstShow = true;
    private double ty;

    private void initialize() {
        // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
        contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
            currentFocusedIndex = -1;
            for (Node child : itemsContainer.getChildren()) {
                if (child instanceof MenuItemContainer) {
                    final MenuItem item = ((MenuItemContainer)child).item;
                    // When the choiceBox popup is shown, if this menu item is selected
                    // do a requestFocus so CSS kicks in and the item is highlighted.
                    if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
                        if (((RadioMenuItem)item).isSelected()) {
                            child.requestFocus();
                            break;
                        }
                    }
                }

            }
        });

//        // FIXME For some reason getSkinnable()Behavior traversal functions don't
//        // get called as expected, so I've just put the important code below.
        // We use setOnKeyPressed here as we are not adding a listener to a public
        // event type (ContextMenuContent is not public API), and without this
        // we get the issue shown in RT-34429
        setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent ke) {
                switch (ke.getCode()) {
                    case LEFT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processRightKey(ke);
                        } else {
                            processLeftKey(ke);
                        }
                        break;
                    case RIGHT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processLeftKey(ke);
                        } else {
                            processRightKey(ke);
                        }
                        break;
                    case CANCEL:
                        ke.consume();
                        break;
                    case ESCAPE:
                        // if the owner is not a menubar button, just close the
                        // menu - this will move focus up to the parent menu
                        // as required. In the case of the parent being a
                        // menubar button we special case in the conditional code
                        // beneath this switch statement. See RT-34429 for more context.
                        final Node ownerNode = contextMenu.getOwnerNode();
                        if (! (ownerNode instanceof MenuBarButton)) {
                            contextMenu.hide();
                            ke.consume();
                        }
                        break;
                    case DOWN:
                        // move to the next sibling
                        move(Direction.NEXT);
                        ke.consume();
                        break;
                    case UP:
                        // move to previous sibling
                        move(Direction.PREVIOUS);
                        ke.consume();
                        break;
                    case SPACE:
                    case ENTER:
                        // select the menuitem
                        selectMenuItem();
                        ke.consume();
                        break;
                    default:
                        break;
                }

                if (!ke.isConsumed()) {
                    final Node ownerNode = contextMenu.getOwnerNode();
                    if (ownerNode instanceof MenuItemContainer) {
                        // Forward to parent menu
                        Parent parent = ownerNode.getParent();
                        while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
                            parent = parent.getParent();
                        }
                        if (parent instanceof ContextMenuContent) {
                            parent.getOnKeyPressed().handle(ke);
                        }
                    } else if (ownerNode instanceof MenuBarButton) {
                        // the following code no longer appears necessary, but
                        // leaving in intact for now...
//                        // This is a top-level MenuBar Menu, so forward event to MenuBar
//                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
//                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
//                            mbs.getKeyEventHandler().handle(ke);
//                        }
                    }
                }
            }
        });

        addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            /*
             * we'll only scroll if the arrows are visible in the direction
             * that we're going, otherwise we go into empty space.
             */
            final double textDeltaY = event.getTextDeltaY();
            final double deltaY = event.getDeltaY();
            if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
                (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {

                switch(event.getTextDeltaYUnits()) {
                  case LINES:
                      /*
                      ** scroll lines, use the row height of selected row,
                      ** or row 0 if none selected
                      */
                      int focusedIndex = findFocusedIndex();
                      if (focusedIndex == -1) {
                          focusedIndex = 0;
                      }
                      double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
                      scroll(textDeltaY * rowHeight);
                      break;
                  case PAGES:
                      /*
                      ** page scroll, scroll the menu height
                      */
                      scroll(textDeltaY * itemsContainer.getHeight());
                      break;
                  case NONE:
                      /*
                      ** pixel scroll
                      */
                      scroll(deltaY);
                      break;
                }
                event.consume();
            }
        });
    }

    private Optional&lt;Node&gt; getFocusedNode() {
        final List&lt;Node&gt; children = itemsContainer.getChildren();
        final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
        return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
    }

    private void processLeftKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;

                    // if the submenu for this menu is showing, hide it
                    if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        hideSubmenu();
                        ke.consume();
                    }
                }
            }
        });
    }

    private void processRightKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);

                    // RT-15103
                    // if submenu for this menu is already showing then do nothing
                    // Menubar will process the right key and move to the next menu
                    if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        return;
                    }

                    showMenu(menu);
                    ke.consume();
                }
            }
        });
    }

    private void showMenu(Menu menu) {
        menu.show();
        // request focus on the first item of the submenu after it is shown
        ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
        if (cmContent != null) {
           if (cmContent.itemsContainer.getChildren().size() &gt; 0) {
               cmContent.itemsContainer.getChildren().get(0).requestFocus();
               cmContent.currentFocusedIndex = 0;
           } else {
               cmContent.requestFocus();
           }
        }
    }

    private void selectMenuItem() {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);
                    menu.show();
                } else {
                    ((MenuItemContainer)n).doSelect();
                }
            }
        });
    }

    private void move(Direction dir) {
        int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
        requestFocusOnIndex(findSibling(dir, startIndex));
    }

    private int findSibling(final Direction dir, final int startIndex) {
        final int childCount = itemsContainer.getChildren().size();
        int i = startIndex;
        do {
            if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
                // loop to zero
                i = 0;
            } else if (!dir.isForward() &amp;&amp; i == 0) {
                // loop to end
                i = childCount - 1;
            } else {
                i += (dir.isForward() ? 1 : -1);
            }

            Node n = itemsContainer.getChildren().get(i);
            if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
                return i;
            }
        } while (i != startIndex);
        return -1;
    }

    public void requestFocusOnIndex(int index) {
        currentFocusedIndex = index;
        Node n = itemsContainer.getChildren().get(index);
        selectedBackground = ((MenuItemContainer)n);
        n.requestFocus();
        ensureFocusedMenuItemIsVisible(n);
    }

    /*
     * Get the Y offset from the top of the popup to the menu item whose index
     * is given.
     */
    public double getMenuYOffset(int menuIndex) {
        double offset = 0;
        if (itemsContainer.getChildren().size() &gt; menuIndex) {
            offset = snappedTopInset();
            Node menuitem = itemsContainer.getChildren().get(menuIndex);
            offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
        }
        return offset;
    }

    private void setUpBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), true);
        contextMenu.getItems().addListener(contextMenuItemsListener);
    }

    private void disposeBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), false);
        contextMenu.getItems().removeListener(contextMenuItemsListener);
    }

    private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
        ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
        Menu menu = (Menu) isShowingProperty.getBean();

        if (wasShowing &amp;&amp; ! isShowing) {
            // hide the submenu popup
            hideSubmenu();
        } else if (! wasShowing &amp;&amp; isShowing) {
            // show the submenu popup
            showSubmenu(menu);
        }
    };

    private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
        // Add listeners to the showing property of all menus that have
        // been added, and remove listeners from menus that have been removed
        // FIXME this is temporary - we should be adding and removing
        // listeners such that they use the one listener defined above
        // - but that can't be done until we have the bean in the
        // ObservableValue
        while (c.next()) {
            updateMenuShowingListeners(c.getRemoved(), false);
            updateMenuShowingListeners(c.getAddedSubList(), true);
        }

        // Listener to items in PopupMenu to update items in PopupMenuContent
        itemsDirty = true;
        updateItems(); // RT-29761
    };

    private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
        // re layout as item's visibility changed
        requestLayout();
    };

    private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
        for (MenuItem item : items) {
            if (item instanceof Menu) {
                final Menu menu = (Menu) item;

                if (addListeners) {
                    menu.showingProperty().addListener(menuShowingListener);
                } else {
                    menu.showingProperty().removeListener(menuShowingListener);
                }
            }

             // listen to menu items's visible property.
            if (addListeners) {
                item.visibleProperty().addListener(menuItemVisibleListener);
            } else {
                item.visibleProperty().removeListener(menuItemVisibleListener);
            }
        }
    }

    // For test purpose only
    ContextMenu getSubMenu() {
        return submenu;
    }

    Menu getOpenSubMenu() {
        return openSubmenu;
    }

    private void createSubmenu() {
        if (submenu == null) {
            submenu = new ContextMenu();
            submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
                @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
                                              Boolean oldValue, Boolean newValue) {
                    if (!submenu.isShowing()) {
                        // Maybe user clicked outside or typed ESCAPE.
                        // Make sure menus are in sync.
                        for (Node node : itemsContainer.getChildren()) {
                            if (node instanceof MenuItemContainer
                                  &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
                                Menu menu = (Menu)((MenuItemContainer)node).item;
                                if (menu.isShowing()) {
                                    menu.hide();
                                }
                            }
                        }
                    }
                }
            });
        }
    }

    private void showSubmenu(Menu menu) {
        openSubmenu = menu;
        createSubmenu();
        submenu.getItems().setAll(menu.getItems());
        submenu.show(selectedBackground, Side.RIGHT, 0, 0);
    }

    private void hideSubmenu() {
        if (submenu == null) return;

        submenu.hide();
        openSubmenu = null;

        // Fix for RT-37022 - we dispose content so that we do not process CSS
        // on hidden submenus
        disposeContextMenu(submenu);
        submenu = null;

        // Fix for JDK-8158679 - we put the focus on the menu, and then back
        // on the menu item, so that screen readers can properly speak out
        // the menu item.
        getFocusedNode().ifPresent(n -&gt; {
            requestFocus();
            n.requestFocus();
        });
    }

    private void hideAllMenus(MenuItem item) {
        if (contextMenu != null) contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    private Menu openSubmenu;
    private ContextMenu submenu;

    // FIXME: HACKY. We use this so that a submenu knows where to open from
    // but this will only work for mouse hovers currently - and won't work
    // programmatically.
    // package protected for testing only!
    Region selectedBackground;

    void scroll(double delta) {
        double newTy = ty + delta;
        if (ty == newTy) return;

        // translation should never be positive (this would mean the top of the
        // menu content is detaching from the top of the menu!)
        if (newTy &gt; 0.0) {
            newTy = 0.0;
        }

        // translation should never be greater than the preferred height of the
        // menu content (otherwise the menu content will be detaching from the
        // bottom of the menu).
        // RT-37185: We check the direction of the scroll, to prevent it locking
        // up when scrolling upwards from the very bottom (using the on-screen
        // up arrow).
        if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
            newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
        }

        ty = newTy;
        itemsContainer.requestLayout();
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/
    @Override public Styleable getStyleableParent() {
        return contextMenu;
    }

    private static class StyleableProperties {

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());

            //
            // SkinBase only has Region's unique StlyleableProperty's, none of Nodes
            // So, we need to add effect back in. The effect property is in a
            // private inner class, so get the property from Node the hard way.
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
            for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
                CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
                if (&quot;effect&quot;.equals(styleable.getProperty())) {
                    styleables.add(styleable);
                    break;
                }
            }
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    public Label getLabelAt(int index) {
        return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
    }

    /**
     * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
     * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
     * timeline when mouse is over up/down arrow.
     */
    class MenuBox extends VBox {
        MenuBox() {
            setAccessibleRole(AccessibleRole.CONTEXT_MENU);
        }

        @Override protected void layoutChildren() {
            double yOffset = ty;
            for (Node n : getChildren()) {
                if (n.isVisible()) {
                    final double prefHeight = snapSizeY(n.prefHeight(-1));
                    n.resize(snapSizeX(getWidth()), prefHeight);
                    n.relocate(snappedLeftInset(), yOffset);
                    yOffset += prefHeight;
                }
            }
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case VISIBLE: return contextMenu.isShowing();
                case PARENT_MENU: return contextMenu.getOwnerNode();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }
    }

    class ArrowMenuItem extends StackPane {
         private StackPane upDownArrow;
         private ContextMenuContent popupMenuContent;
         private boolean up = false;
         public final boolean isUp() { return up; }
         public void setUp(boolean value) {
            up = value;
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
        }

        // used to automatically scroll through menu items when the user performs
        // certain interactions, e.g. pressing and holding the arrow buttons
        private Timeline scrollTimeline;

        public ArrowMenuItem(ContextMenuContent pmc) {
            getStyleClass().setAll(&quot;scroll-arrow&quot;);
            upDownArrow = new StackPane();
            this.popupMenuContent = pmc;
            upDownArrow.setMouseTransparent(true);
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
    //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
            addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
                if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
                    return;
                }
                startTimeline();
            });
            addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
                stopTimeline();
            });
            setVisible(false);
            setManaged(false);
            getChildren().add(upDownArrow);
        }

        @Override protected double computePrefWidth(double height) {
//            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
            return itemsContainer.getWidth();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double w = snapSizeX(upDownArrow.prefWidth(-1));
            double h = snapSizeY(upDownArrow.prefHeight(-1));

            upDownArrow.resize(w, h);
            positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }

        private void adjust() {
            if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
        }

        private void startTimeline() {
            scrollTimeline = new Timeline();
            scrollTimeline.setCycleCount(Timeline.INDEFINITE);
            KeyFrame kf = new KeyFrame(
                Duration.millis(60),
                    event -&gt; {
                        adjust();
                    }
            );
            scrollTimeline.getKeyFrames().clear();
            scrollTimeline.getKeyFrames().add(kf);
            scrollTimeline.play();
        }

        private void stopTimeline() {
            scrollTimeline.stop();
            scrollTimeline = null;
        }
    }

    /*
     * Container responsible for laying out a single row in the menu - in other
     * words, this contains and lays out a single MenuItem, regardless of it's
     * specific subtype.
     */
    public class MenuItemContainer extends Region {

        private final MenuItem item;

        private Node left;
        private Node graphic;
        private Node label;
        private Node right;

        private final LambdaMultiplePropertyChangeListenerHandler listener =
            new LambdaMultiplePropertyChangeListenerHandler();

        private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
        private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;

        private EventHandler&lt;ActionEvent&gt; actionEventHandler;

        protected Label getLabel(){
            return (Label) label;
        }

        public MenuItem getItem() {
            return item;
        }

        public MenuItemContainer(MenuItem item){
            if (item == null) {
                throw new NullPointerException(&quot;MenuItem can not be null&quot;);
            }

            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            setFocusTraversable(!(item instanceof CustomMenuItem));
            this.item = item;

            createChildren();

            // listen to changes in the state of certain MenuItem types
            ReadOnlyBooleanProperty pseudoProperty;
            if (item instanceof Menu) {
                pseudoProperty = ((Menu)item).showingProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.MENU);
            } else if (item instanceof RadioMenuItem) {
                pseudoProperty = ((RadioMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
            } else if (item instanceof CheckMenuItem) {
                pseudoProperty = ((CheckMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
            } else {
                setAccessibleRole(AccessibleRole.MENU_ITEM);
            }

            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
            listener.registerChangeListener(item.disableProperty(),
                    e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));

            // Add the menu item to properties map of this node. Used by QA for testing
            // This allows associating this container with corresponding MenuItem.
            getProperties().put(MenuItem.class, item);

            listener.registerChangeListener(item.graphicProperty(), e -&gt; {
                createChildren();
                computeVisualMetrics();
            });

            actionEventHandler = e -&gt; {
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }

                    selectedBackground = MenuItemContainer.this;
                    showMenu(menu);
                } else {
                    doSelect();
                }
            };
            addEventHandler(ActionEvent.ACTION, actionEventHandler);
        }

        public void dispose() {
            if (item instanceof CustomMenuItem) {
                Node node = ((CustomMenuItem)item).getContent();
                if (node != null) {
                    node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
                }
            }

            listener.dispose();
            removeEventHandler(ActionEvent.ACTION, actionEventHandler);

            if (label != null) {
                ((Label)label).textProperty().unbind();
                label.styleProperty().unbind();
                label.idProperty().unbind();

                ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
                if (itemStyleClassListener != null) {
                    item.getStyleClass().removeListener(itemStyleClassListener);
                }
            }

            left = null;
            graphic = null;
            label = null;
            right = null;
        }

        private void createChildren() {
            getChildren().clear();

            // draw background region for hover effects. All content (other
            // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
            // this background also acts as the receiver of user input
            if (item instanceof CustomMenuItem) {
                createNodeMenuItemChildren((CustomMenuItem)item);

                if (mouseEnteredEventHandler == null) {
                    mouseEnteredEventHandler = event -&gt; {
                        requestFocus(); // request Focus on hover
                    };
                } else {
                    removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                }
                addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
            } else {
                // --- add check / radio to left column
                Node leftNode = getLeftGraphic(item);
                if (leftNode != null) {
                    StackPane leftPane = new StackPane();
                    leftPane.getStyleClass().add(&quot;left-container&quot;);
                    leftPane.getChildren().add(leftNode);
                    left = leftPane;
                    getChildren().add(left);
                    left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
                }
                // -- add graphic to graphic pane
                if (item.getGraphic() != null) {
                    Node graphicNode = item.getGraphic();
                    StackPane graphicPane = new StackPane();
                    graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
                    graphicPane.getChildren().add(graphicNode);
                    graphic = graphicPane;
                    getChildren().add(graphic);
                }

                // --- add text to center column
                label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()

                // set up bindings from the MenuItem into the Label
                ((Label)label).textProperty().bind(item.textProperty());
                label.styleProperty().bind(item.styleProperty());
                label.idProperty().bind(item.styleProperty());

                // we want to ensure that any styleclasses set on the menuitem are applied to the
                // label (so we can style appropriately), but we can't just do a binding such as this:
                // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
                // Because that means we overwrite the 'label' style class on the Label.
                // What we really want is to ensure all style classes in the MenuItem are _copied_
                // into the label, which is what we do below
                ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
                    while (c.next()) {
                        label.getStyleClass().removeAll(c.getRemoved());
                        label.getStyleClass().addAll(c.getAddedSubList());
                    }
                };
                item.getStyleClass().addListener(itemStyleClassListener);
                item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);


                label.setMouseTransparent(true);
                getChildren().add(label);

                listener.unregisterChangeListeners(focusedProperty());
                // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
                // e.g this happens when you press the Right key to open a submenu; the first
                // menuitem is focused.
                listener.registerChangeListener(focusedProperty(), e -&gt; {
                    if (isFocused()) {
                        currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
                    }
                });

                // --- draw in right column - this depends on whether we are
                // a Menu or not. A Menu gets an arrow, whereas other MenuItems
                // get the ability to draw an accelerator
                if (item instanceof Menu) {
                    // --- add arrow / accelerator / mnemonic to right column
                    Region rightNode = new Region();
                    rightNode.setMouseTransparent(true);
                    rightNode.getStyleClass().add(&quot;arrow&quot;);

                    StackPane rightPane = new StackPane();
                    rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
                    rightPane.setMouseTransparent(true);
                    rightPane.getStyleClass().add(&quot;right-container&quot;);
                    rightPane.getChildren().add(rightNode);
                    right = rightPane;
                    getChildren().add(rightPane);

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null &amp;&amp; item != openSubmenu) {
                                // if a submenu of a different menu is already
                                // open then close it (RT-15049)
                                hideSubmenu();
                            }

                            selectedBackground = MenuItemContainer.this;
                            requestFocus();  // request Focus on hover
                            final Menu menu = (Menu) item;
                            if (menu.isDisable()) return;
                            menu.show();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            item.fire();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    // show submenu when the menu is hovered over
                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                } else { // normal MenuItem
                    // remove old listeners
                    listener.unregisterChangeListeners(item.acceleratorProperty());

                    // accelerator support
                    updateAccelerator();

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null) {
                                openSubmenu.hide();
                            }
                            requestFocus();  // request Focus on hover
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            doSelect();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);

                    listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
                }
            }
        }

        private void updateAccelerator() {
            if (item.getAccelerator() != null) {
                if (right != null) {
                    getChildren().remove(right);
                }

                String text = item.getAccelerator().getDisplayText();
                right = new Label(text);
                right.setStyle(item.getStyle());
                right.getStyleClass().add(&quot;accelerator-text&quot;);
                getChildren().add(right);
            } else {
                getChildren().remove(right);
            }
        }

        void doSelect() {
            // don't do anything on disabled menu items
            if (item.isDisable()) return;
            // toggle state of check or radio items
            if (item instanceof CheckMenuItem) {
                CheckMenuItem checkItem = (CheckMenuItem)item;
                checkItem.setSelected(!checkItem.isSelected());
            } else if (item instanceof RadioMenuItem) {
                // this is a radio button. If there is a toggleGroup specified, we
                // simply set selected to true. If no toggleGroup is specified, we
                // toggle the selected state, as there is no assumption of mutual
                // exclusivity when no toggleGroup is set.
                final RadioMenuItem radioItem = (RadioMenuItem) item;
                radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
            }

            // fire the action before hiding the menu
            item.fire();

            if (item instanceof CustomMenuItem) {
                CustomMenuItem customMenuItem = (CustomMenuItem) item;
                if (customMenuItem.isHideOnClick()) {
                    hideAllMenus(item);
                }
            } else {
                hideAllMenus(item);
            }
        }

        private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;

        private void createNodeMenuItemChildren(final CustomMenuItem item) {
            Node node = item.getContent();
            getChildren().add(node);

            // handle hideOnClick
            customMenuItemMouseClickedHandler = event -&gt; {
                if (item == null || item.isDisable()) return;

                item.fire();
                if (item.isHideOnClick()) {
                    hideAllMenus(item);
                }
            };
            node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
        }

        @Override protected void layoutChildren() {
            double xOffset;

            final double prefHeight = prefHeight(-1);
            if (left != null) {
                xOffset = snappedLeftInset();
                left.resize(left.prefWidth(-1), left.prefHeight(-1));
                positionInArea(left, xOffset, 0,
                        maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }
            if (graphic != null) {
                xOffset = snappedLeftInset() + maxLeftWidth;
                graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
                positionInArea(graphic, xOffset, 0,
                        maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (label != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
                label.resize(label.prefWidth(-1), label.prefHeight(-1));
                positionInArea(label, xOffset, 0,
                        maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (right != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
                right.resize(right.prefWidth(-1), right.prefHeight(-1));
                positionInArea(right, xOffset, 0,
                    maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
            }

            if ( item instanceof CustomMenuItem) {
                Node n = ((CustomMenuItem) item).getContent();
                if (item instanceof SeparatorMenuItem) {
                    double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
                    n.resize(width, n.prefHeight(-1));
                    positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                } else {
                    n.resize(n.prefWidth(-1), n.prefHeight(-1));
                    //the node should be left aligned
                    positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                }
            }
        }

        @Override protected double computePrefHeight(double width) {
            double prefHeight = 0;
            if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
                prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
            } else {
                prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
            }
             return snappedTopInset() + prefHeight + snappedBottomInset();
        }

        @Override protected double computePrefWidth(double height) {
            double nodeMenuItemWidth = 0;
            if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
                nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
                        snappedRightInset();
            }
            return Math.max(nodeMenuItemWidth,
                    snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
                    maxLabelWidth + maxRightWidth + snappedRightInset());
        }

        // Responsible for returning a graphic (if necessary) to position in the
        // left column of the menu. This may be a Node from the MenuItem.graphic
        // property, or it may be a check/radio item if necessary.
        private Node getLeftGraphic(MenuItem item) {
            if (item instanceof RadioMenuItem) {
                 final Region _graphic = new Region();
                _graphic.getStyleClass().add(&quot;radio&quot;);
                return _graphic;
            } else if (item instanceof CheckMenuItem) {
                final StackPane _graphic = new StackPane();
                _graphic.getStyleClass().add(&quot;check&quot;);
                return _graphic;
            }

            return null;
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case SELECTED:
                    if (item instanceof CheckMenuItem) {
                        return ((CheckMenuItem)item).isSelected();
                    }
                    if (item instanceof RadioMenuItem) {
                        return ((RadioMenuItem) item).isSelected();
                    }
                    return false;
                case ACCELERATOR: return item.getAccelerator();
                case TEXT: {
                    String title = &quot;&quot;;
                    if (graphic != null) {
                        String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    final Label label = getLabel();
                    if (label != null) {
                        String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    if (item instanceof CustomMenuItem) {
                        Node content = ((CustomMenuItem) item).getContent();
                        if (content != null) {
                            String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                            if (t != null) title += t;
                        }
                    }
                    return title;
                }
                case MNEMONIC: {
                    final Label label = getLabel();
                    if (label != null) {
                        String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
                        if (mnemonic != null) return mnemonic;
                    }
                    return null;
                }
                case DISABLED: return item.isDisable();
                case SUBMENU:
                    createSubmenu();
                    // Accessibility might need to see the menu node before the window
                    // is visible (i.e. before the skin is applied).
                    if (submenu.getSkin() == null) {
                        submenu.getStyleableNode().applyCss();
                    }
                    ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
                    return cmContent.itemsContainer;
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case SHOW_MENU:{
                    if (item instanceof Menu) {
                        final Menu menuItem = (Menu) item;
                        if (menuItem.isShowing()) {
                            menuItem.hide();
                        } else {
                            menuItem.show();
                        }
                    }
                    break;
                }
                case FIRE:
                    doSelect();
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }


    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;checked&quot;);

    private class MenuLabel extends Label {

        public MenuLabel(MenuItem item, MenuItemContainer mic) {
            super(item.getText());
            setMnemonicParsing(item.isMnemonicParsing());
            setLabelFor(mic);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.temporal.ChronoUnit;
import java.time.temporal.ValueRange;
import java.time.temporal.WeekFields;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;
import static java.time.temporal.ChronoUnit.*;

import com.sun.javafx.scene.control.skin.*;
import javafx.application.Platform;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WeakChangeListener;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.layout.StackPane;

import com.sun.javafx.scene.control.skin.resources.ControlResources;
import com.sun.javafx.scene.traversal.Direction;

import static com.sun.javafx.PlatformUtil.*;
import com.sun.javafx.scene.NodeHelper;

/**
 * The full content for the DatePicker popup. This class could
 * probably be used more or less as-is with an embeddable type of date
 * picker that doesn't use a popup.
 */
public class DatePickerContent extends VBox {
    protected DatePicker datePicker;
    private Button backMonthButton;
    private Button forwardMonthButton;
    private Button backYearButton;
    private Button forwardYearButton;
    private Label monthLabel;
    private Label yearLabel;
    protected GridPane gridPane;

    private int daysPerWeek;
    private List&lt;DateCell&gt; dayNameCells = new ArrayList&lt;DateCell&gt;();
    private List&lt;DateCell&gt; weekNumberCells = new ArrayList&lt;DateCell&gt;();
    protected List&lt;DateCell&gt; dayCells = new ArrayList&lt;DateCell&gt;();
    private LocalDate[] dayCellDates;
    private DateCell lastFocusedDayCell = null;

    final DateTimeFormatter monthFormatter =
        DateTimeFormatter.ofPattern(&quot;MMMM&quot;);

    final DateTimeFormatter monthFormatterSO =
            DateTimeFormatter.ofPattern(&quot;LLLL&quot;); // Standalone month name

    final DateTimeFormatter yearFormatter =
        DateTimeFormatter.ofPattern(&quot;y&quot;);

    final DateTimeFormatter yearWithEraFormatter =
        DateTimeFormatter.ofPattern(&quot;GGGGy&quot;); // For Japanese. What to use for others??

    final DateTimeFormatter weekNumberFormatter =
        DateTimeFormatter.ofPattern(&quot;w&quot;);

    final DateTimeFormatter weekDayNameFormatter =
            DateTimeFormatter.ofPattern(&quot;ccc&quot;); // Standalone day name

    final DateTimeFormatter dayCellFormatter =
        DateTimeFormatter.ofPattern(&quot;d&quot;);

    static String getString(String key) {
        return ControlResources.getString(&quot;DatePicker.&quot;+key);
    }

    public DatePickerContent(final DatePicker datePicker) {
        this.datePicker = datePicker;

        getStyleClass().add(&quot;date-picker-popup&quot;);

        daysPerWeek = getDaysPerWeek();

        {
            LocalDate date = datePicker.getValue();
            displayedYearMonth.set((date != null) ? YearMonth.from(date) : YearMonth.now());
        }

        displayedYearMonth.addListener((observable, oldValue, newValue) -&gt; {
            updateValues();
        });


        getChildren().add(createMonthYearPane());

        gridPane = new GridPane() {
            @Override protected double computePrefWidth(double height) {
                final double width = super.computePrefWidth(height);

                // RT-30903: Make sure width snaps to pixel when divided by
                // number of columns. GridPane doesn't do this with percentage
                // width constraints. See GridPane.adjustColumnWidths().
                final int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);
                final double snaphgap = snapSpaceX(getHgap());
                final double left = snapSpaceX(getInsets().getLeft());
                final double right = snapSpaceX(getInsets().getRight());
                final double hgaps = snaphgap * (nCols - 1);
                final double contentWidth = width - left - right - hgaps;
                return ((snapSizeX(contentWidth / nCols)) * nCols) + left + right + hgaps;
            }

            @Override protected void layoutChildren() {
                // Prevent AssertionError in GridPane
                if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
                    super.layoutChildren();
                }
            }
        };
        gridPane.setFocusTraversable(true);
        gridPane.getStyleClass().add(&quot;calendar-grid&quot;);
        gridPane.setVgap(-1);
        gridPane.setHgap(-1);

        // Add a focus owner listener to Scene when it becomes available.
        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
            new WeakChangeListener&lt;Node&gt;((ov2, oldFocusOwner, newFocusOwner) -&gt; {
                if (newFocusOwner == gridPane) {
                    if (oldFocusOwner instanceof DateCell) {
                        // Backwards traversal, skip gridPane.
                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);
                    } else {
                        // Forwards traversal, pass focus to day cell.
                        if (lastFocusedDayCell != null) {
                            Platform.runLater(() -&gt; {
                                lastFocusedDayCell.requestFocus();
                            });
                        } else {
                            clearFocus();
                        }
                    }
                }
            });
        gridPane.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;((ov, oldScene, newScene) -&gt; {
            if (oldScene != null) {
                oldScene.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newScene != null) {
                Platform.runLater(() -&gt; {
                    newScene.focusOwnerProperty().addListener(weakFocusOwnerListener);
                });
            }
        }));
        if (gridPane.getScene() != null) {
            gridPane.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // get the weekday labels starting with the weekday that is the
        // first-day-of-the-week according to the locale in the
        // displayed LocalDate
        for (int i = 0; i &lt; daysPerWeek; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;day-name-cell&quot;);
            dayNameCells.add(cell);
        }

        // Week number column
        for (int i = 0; i &lt; 6; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;week-number-cell&quot;);
            weekNumberCells.add(cell);
        }

        createDayCells();
        updateGrid();
        getChildren().add(gridPane);

        refresh();

        // RT-30511: This prevents key events from reaching the popup's owner.
        addEventHandler(KeyEvent.ANY, e -&gt; {
            Node node = getScene().getFocusOwner();
            if (node instanceof DateCell) {
                lastFocusedDayCell = (DateCell)node;
            }

            if (e.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (e.getCode()) {
                  case HOME:
                      goToDate(LocalDate.now(), true);
                      e.consume();
                      break;


                  case PAGE_UP:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!backYearButton.isDisabled()) {
                              forward(-1, YEARS, true);
                          }
                      } else {
                          if (!backMonthButton.isDisabled()) {
                              forward(-1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;

                  case PAGE_DOWN:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!forwardYearButton.isDisabled()) {
                              forward(1, YEARS, true);
                          }
                      } else {
                          if (!forwardMonthButton.isDisabled()) {
                              forward(1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;
                }

                node = getScene().getFocusOwner();
                if (node instanceof DateCell) {
                    lastFocusedDayCell = (DateCell)node;
                }
            }

            // Consume all key events except those that control
            // showing the popup and traversal.
            switch (e.getCode()) {
              case F4:
              case F10:
              case UP:
              case DOWN:
              case LEFT:
              case RIGHT:
              case TAB:
                    break;

              case ESCAPE:
                datePicker.hide();
                e.consume();
                break;

              default:
                e.consume();
            }
        });
    }

    private ObjectProperty&lt;YearMonth&gt; displayedYearMonth =
        new SimpleObjectProperty&lt;YearMonth&gt;(this, &quot;displayedYearMonth&quot;);

    public ObjectProperty&lt;YearMonth&gt; displayedYearMonthProperty() {
        return displayedYearMonth;
    }


    protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = new BorderPane();
        monthYearPane.getStyleClass().add(&quot;month-year-pane&quot;);

        // Month spinner

        HBox monthSpinner = new HBox();
        monthSpinner.getStyleClass().add(&quot;spinner&quot;);

        backMonthButton = new Button();
        backMonthButton.getStyleClass().add(&quot;left-button&quot;);

        forwardMonthButton = new Button();
        forwardMonthButton.getStyleClass().add(&quot;right-button&quot;);

<A NAME="65"></A>        StackPane leftMonthArrow = new StackPane();
        leftMonthArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#65',2,'match42-top.html#65',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>backMonthButton.setGraphic(leftMonthArrow);

        StackPane rightMonthArrow = new StackPane();
        rightMonthArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardMonthButton.setGraphic(rightMonthArrow);


        backMonthButton.setOnAction(t -&gt; {
            forward</B></FONT>(-1, MONTHS, false);
        });

        monthLabel = new Label();
        monthLabel.getStyleClass().add(&quot;spinner-label&quot;);
        monthLabel.fontProperty().addListener((o, ov, nv) -&gt; {
            updateMonthLabelWidth();
        });

        forwardMonthButton.setOnAction(t -&gt; {
            forward(1, MONTHS, false);
        });

        monthSpinner.getChildren().addAll(backMonthButton, monthLabel, forwardMonthButton);
        monthYearPane.setLeft(monthSpinner);

        // Year spinner

        HBox yearSpinner = new HBox();
        yearSpinner.getStyleClass().add(&quot;spinner&quot;);

        backYearButton = new Button();
        backYearButton.getStyleClass().add(&quot;left-button&quot;);

        forwardYearButton = new Button();
        forwardYearButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftYearArrow = new StackPane();
        leftYearArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backYearButton.setGraphic(leftYearArrow);

        StackPane rightYearArrow = new StackPane();
        rightYearArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardYearButton.setGraphic(rightYearArrow);


        backYearButton.setOnAction(t -&gt; {
            forward(-1, YEARS, false);
        });

        yearLabel = new Label();
        yearLabel.getStyleClass().add(&quot;spinner-label&quot;);

        forwardYearButton.setOnAction(t -&gt; {
            forward(1, YEARS, false);
        });

        yearSpinner.getChildren().addAll(backYearButton, yearLabel, forwardYearButton);
        yearSpinner.setFillHeight(false);
        monthYearPane.setRight(yearSpinner);

        return monthYearPane;
    }

    private void refresh() {
        updateMonthLabelWidth();
        updateDayNameCells();
        updateValues();
    }

    public void updateValues() {
        // Note: Preserve this order, as DatePickerHijrahContent needs
        // updateDayCells before updateMonthYearPane().
        updateWeeknumberDateCells();
        updateDayCells();
        updateMonthYearPane();
    }

    public void updateGrid() {
        gridPane.getColumnConstraints().clear();
        gridPane.getChildren().clear();

        int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);

        ColumnConstraints columnConstraints = new ColumnConstraints();
        columnConstraints.setPercentWidth(100); // Treated as weight
        for (int i = 0; i &lt; nCols; i++) {
            gridPane.getColumnConstraints().add(columnConstraints);
        }

        for (int i = 0; i &lt; daysPerWeek; i++) {
            gridPane.add(dayNameCells.get(i), i + nCols - daysPerWeek, 1);  // col, row
        }

        // Week number column
        if (datePicker.isShowWeekNumbers()) {
            for (int i = 0; i &lt; 6; i++) {
                gridPane.add(weekNumberCells.get(i), 0, i + 2);  // col, row
            }
        }

        // setup: 6 rows of daysPerWeek (which is the maximum number of cells required in the worst case layout)
        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                gridPane.add(dayCells.get(row*daysPerWeek+col), col + nCols - daysPerWeek, row + 2);
            }
        }
    }

    public void updateDayNameCells() {
        // first day of week, 1 = monday, 7 = sunday
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();

        // july 13th 2009 is a Monday, so a firstDayOfWeek=1 must come out of the 13th
        LocalDate date = LocalDate.of(2009, 7, 12 + firstDayOfWeek);
        for (int i = 0; i &lt; daysPerWeek; i++) {
            String name = weekDayNameFormatter.withLocale(getLocale()).format(date.plus(i, DAYS));
            dayNameCells.get(i).setText(titleCaseWord(name));
        }
    }

    public void updateWeeknumberDateCells() {
        if (datePicker.isShowWeekNumbers()) {
            final Locale locale = getLocale();
            final int maxWeeksPerMonth = 6; // TODO: Get this from chronology?

            LocalDate firstOfMonth = displayedYearMonth.get().atDay(1);
            for (int i = 0; i &lt; maxWeeksPerMonth; i++) {
                LocalDate date = firstOfMonth.plus(i, WEEKS);
                // Use a formatter to ensure correct localization,
                // such as when Thai numerals are required.
                String cellText =
                    weekNumberFormatter.withLocale(locale)
                                       .withDecimalStyle(DecimalStyle.of(locale))
                                       .format(date);
                weekNumberCells.get(i).setText(cellText);
            }
        }
    }

    public void updateDayCells() {
        Locale locale = getLocale();
        Chronology chrono = getPrimaryChronology();
        int firstOfMonthIdx = determineFirstOfMonthDayOfWeek();
        YearMonth curMonth = displayedYearMonth.get();

        // RT-31075: The following are now set in the try-catch block.
        YearMonth prevMonth = null;
        YearMonth nextMonth = null;
        int daysInCurMonth = -1;
        int daysInPrevMonth = -1;
        int daysInNextMonth = -1;

        for (int i = 0; i &lt; 6 * daysPerWeek; i++) {
            DateCell dayCell = dayCells.get(i);
            dayCell.getStyleClass().setAll(&quot;cell&quot;, &quot;date-cell&quot;, &quot;day-cell&quot;);
            dayCell.setDisable(false);
            dayCell.setStyle(null);
            dayCell.setGraphic(null);
            dayCell.setTooltip(null);

            try {
                if (daysInCurMonth == -1) {
                    daysInCurMonth = curMonth.lengthOfMonth();
                }
                YearMonth month = curMonth;
                int day = i - firstOfMonthIdx + 1;
                //int index = firstOfMonthIdx + i - 1;
                if (i &lt; firstOfMonthIdx) {
                    if (prevMonth == null) {
                        prevMonth = curMonth.minusMonths(1);
                        daysInPrevMonth = prevMonth.lengthOfMonth();
                    }
                    month = prevMonth;
                    day = i + daysInPrevMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;previous-month&quot;);
                } else if (i &gt;= firstOfMonthIdx + daysInCurMonth) {
                    if (nextMonth == null) {
                        nextMonth = curMonth.plusMonths(1);
                        daysInNextMonth = nextMonth.lengthOfMonth();
                    }
                    month = nextMonth;
                    day = i - daysInCurMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;next-month&quot;);
                }
                LocalDate date = month.atDay(day);
                dayCellDates[i] = date;
                ChronoLocalDate cDate = chrono.date(date);

                dayCell.setDisable(false);

                if (isToday(date)) {
                    dayCell.getStyleClass().add(&quot;today&quot;);
                }

                if (date.equals(datePicker.getValue())) {
                    dayCell.getStyleClass().add(&quot;selected&quot;);
                }

                String cellText =
                    dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);
                dayCell.setText(cellText);

                dayCell.updateItem(date, false);
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                dayCell.setText(&quot; &quot;);
                dayCell.setDisable(true);
            }
        }
    }

    private int getDaysPerWeek() {
        ValueRange range = getPrimaryChronology().range(DAY_OF_WEEK);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private int getMonthsPerYear() {
        ValueRange range = getPrimaryChronology().range(MONTH_OF_YEAR);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private void updateMonthLabelWidth() {
        if (monthLabel != null) {
            int monthsPerYear = getMonthsPerYear();
            double width = 0;
            for (int i = 0; i &lt; monthsPerYear; i++) {
                YearMonth yearMonth = displayedYearMonth.get().withMonth(i + 1);
                String name = monthFormatterSO.withLocale(getLocale()).format(yearMonth);
                if (Character.isDigit(name.charAt(0))) {
                    // Fallback. The standalone format returned a number, so use standard format instead.
                    name = monthFormatter.withLocale(getLocale()).format(yearMonth);
                }
                width = Math.max(width, Utils.computeTextWidth(monthLabel.getFont(), name, 0));
            }
            monthLabel.setMinWidth(width);
        }
    }

    protected void updateMonthYearPane() {
        YearMonth yearMonth = displayedYearMonth.get();
        String str = formatMonth(yearMonth);
        monthLabel.setText(str);

        str = formatYear(yearMonth);
        yearLabel.setText(str);
        double width = Utils.computeTextWidth(yearLabel.getFont(), str, 0);
        if (width &gt; yearLabel.getMinWidth()) {
            yearLabel.setMinWidth(width);
        }

        Chronology chrono = datePicker.getChronology();
        LocalDate firstDayOfMonth = yearMonth.atDay(1);
        backMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, DAYS));
        forwardMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, MONTHS));
        backYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, YEARS));
        forwardYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, YEARS));
    }

    private String formatMonth(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));

            String str = monthFormatterSO.withLocale(getLocale())
                                         .withChronology(chrono)
                                         .format(cDate);
            if (Character.isDigit(str.charAt(0))) {
                // Fallback. The standalone format returned a number, so use standard format instead.
                str = monthFormatter.withLocale(getLocale())
                                    .withChronology(chrono)
                                    .format(cDate);
            }
            return titleCaseWord(str);
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    private String formatYear(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            DateTimeFormatter formatter = yearFormatter;
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));
            int era = cDate.getEra().getValue();
            int nEras = chrono.eras().size();

            /*if (cDate.get(YEAR) &lt; 0) {
                formatter = yearForNegYearFormatter;
            } else */
            if ((nEras == 2 &amp;&amp; era == 0) || nEras &gt; 2) {
                formatter = yearWithEraFormatter;
            }

            // Fixme: Format Japanese era names with Japanese text.
            String str = formatter.withLocale(getLocale())
                                  .withChronology(chrono)
                                  .withDecimalStyle(DecimalStyle.of(getLocale()))
                                  .format(cDate);

            return str;
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    // Ensures that month and day names are titlecased (capitalized).
    private String titleCaseWord(String str) {
        if (str.length() &gt; 0) {
            int firstChar = str.codePointAt(0);
            if (!Character.isTitleCase(firstChar)) {
                str = new String(new int[] { Character.toTitleCase(firstChar) }, 0, 1) +
                      str.substring(Character.offsetByCodePoints(str, 0, 1));
            }
        }
        return str;
    }



    /**
     * determine on which day of week idx the first of the months is
     */
    private int determineFirstOfMonthDayOfWeek() {
        // determine with which cell to start
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();
        int firstOfMonthIdx = displayedYearMonth.get().atDay(1).getDayOfWeek().getValue() - firstDayOfWeek;
        if (firstOfMonthIdx &lt; 0) {
            firstOfMonthIdx += daysPerWeek;
        }
        return firstOfMonthIdx;
    }

    private boolean isToday(LocalDate localDate) {
        return (localDate.equals(LocalDate.now()));
    }

    protected LocalDate dayCellDate(DateCell dateCell) {
        assert (dayCellDates != null);
        return dayCellDates[dayCells.indexOf(dateCell)];
    }

    // public for behavior class
    public void goToDayCell(DateCell dateCell, int offset, ChronoUnit unit, boolean focusDayCell) {
        goToDate(dayCellDate(dateCell).plus(offset, unit), focusDayCell);
    }

    protected void forward(int offset, ChronoUnit unit, boolean focusDayCell) {
        YearMonth yearMonth = displayedYearMonth.get();
        DateCell dateCell = lastFocusedDayCell;
        if (dateCell == null || !dayCellDate(dateCell).getMonth().equals(yearMonth.getMonth())) {
            dateCell = findDayCellForDate(yearMonth.atDay(1));
        }
        goToDayCell(dateCell, offset, unit, focusDayCell);
    }

    // public for behavior class
    public void goToDate(LocalDate date, boolean focusDayCell) {
        if (isValidDate(datePicker.getChronology(), date)) {
            displayedYearMonth.set(YearMonth.from(date));
            if (focusDayCell) {
                findDayCellForDate(date).requestFocus();
            }
        }
    }

    // public for behavior class
    public void selectDayCell(DateCell dateCell) {
        datePicker.setValue(dayCellDate(dateCell));
        datePicker.hide();
    }

    private DateCell findDayCellForDate(LocalDate date) {
        for (int i = 0; i &lt; dayCellDates.length; i++) {
            if (date.equals(dayCellDates[i])) {
                return dayCells.get(i);
            }
        }
        return dayCells.get(dayCells.size()/2+1);
    }

    public void clearFocus() {
        LocalDate focusDate = datePicker.getValue();
        if (focusDate == null) {
            focusDate = LocalDate.now();
        }
        if (YearMonth.from(focusDate).equals(displayedYearMonth.get())) {
            // focus date
            goToDate(focusDate, true);
        } else {
            // focus month spinner (should not happen)
            backMonthButton.requestFocus();
        }

        // RT-31857
        if (backMonthButton.getWidth() == 0) {
            backMonthButton.requestLayout();
            forwardMonthButton.requestLayout();
            backYearButton.requestLayout();
            forwardYearButton.requestLayout();
        }
    }

    protected void createDayCells() {
        final EventHandler&lt;MouseEvent&gt; dayCellActionHandler = ev -&gt; {
            if (ev.getButton() != MouseButton.PRIMARY) {
                return;
            }

            DateCell dayCell = (DateCell)ev.getSource();
            selectDayCell(dayCell);
            lastFocusedDayCell = dayCell;
        };

        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                DateCell dayCell = createDayCell();
                dayCell.addEventHandler(MouseEvent.MOUSE_CLICKED, dayCellActionHandler);
                dayCells.add(dayCell);
            }
        }

        dayCellDates = new LocalDate[6 * daysPerWeek];
    }

    private DateCell createDayCell() {
        DateCell cell = null;
        if (datePicker.getDayCellFactory() != null) {
            cell = datePicker.getDayCellFactory().call(datePicker);
        }
        if (cell == null) {
            cell = new DateCell();
        }

        return cell;
    }

    protected Locale getLocale() {
        return Locale.getDefault(Locale.Category.FORMAT);
    }

    /**
     * The primary chronology for display. This may be overridden to
     * be different than the DatePicker chronology. For example
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    protected Chronology getPrimaryChronology() {
        return datePicker.getChronology();
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date, int offset, ChronoUnit unit) {
        if (date != null) {
            try {
                return isValidDate(chrono, date.plus(offset, unit));
            } catch (DateTimeException ex) {
            }
        }
        return false;
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date) {
        try {
            if (date != null) {
                chrono.date(date);
            }
            return true;
        } catch (DateTimeException ex) {
            return false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/EmbeddedTextContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.util.Map;

import com.sun.javafx.scene.control.skin.*;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.ListChangeListener;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.geometry.HPos;
import javafx.geometry.VPos;
import javafx.scene.control.*;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.control.skin.TextFieldSkin;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;

/**
 * The embedded context menu for a text input control.
 * The menu will be displayed horizontally underneath the cursor
 * with the available text editing options i.e. cut, copy, paste, select all.
 *
 */
public class EmbeddedTextContextMenuContent extends StackPane {

    private ContextMenu contextMenu;
    private StackPane pointer;
    private HBox menuBox;

    public EmbeddedTextContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        this.menuBox = new HBox();
        this.pointer = new StackPane();
        pointer.getStyleClass().add(&quot;pointer&quot;);

        updateMenuItemContainer();
        getChildren().addAll(pointer, menuBox);

        contextMenu.ownerNodeProperty().addListener(arg0 -&gt; {
            if (contextMenu.getOwnerNode() instanceof TextArea) {
                TextAreaSkin tas = (TextAreaSkin)((TextArea)contextMenu.getOwnerNode()).getSkin();
                tas.getSkinnable().getProperties().addListener(new InvalidationListener() {
                    @Override public void invalidated(Observable arg0) {
                        requestLayout();
                    }
                });
            } else if (contextMenu.getOwnerNode() instanceof TextField) {
                TextFieldSkin tfs = (TextFieldSkin)((TextField)contextMenu.getOwnerNode()).getSkin();
                tfs.getSkinnable().getProperties().addListener(new InvalidationListener() {
                    @Override public void invalidated(Observable arg0) {
                        requestLayout();
                    }
                });
            }
        });

        contextMenu.getItems().addListener((ListChangeListener&lt;MenuItem&gt;) c -&gt; {
            // Listener to items in PopupMenu to update items in PopupMenuContent
            updateMenuItemContainer();
        });
    }
<A NAME="80"></A>
    private void updateMenuItemContainer() {
        menuBox.getChildren().clear();
        <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#80',2,'match42-top.html#80',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (MenuItem item: contextMenu.getItems()) {
            MenuItemContainer menuItemContainer = new MenuItemContainer(item);
            menuItemContainer.visibleProperty().bind(item.visibleProperty());
            menuBox.getChildren().add(menuItemContainer);
        }</B></FONT>
    }

    private void hideAllMenus(MenuItem item) {
        contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (parentMenu == null &amp;&amp; item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    @Override protected double computePrefHeight(double width) {
        final double pointerHeight = snapSizeY(pointer.prefHeight(width));
        final double menuBoxHeight = snapSizeY(menuBox.prefHeight(width));
        return snappedTopInset() + pointerHeight + menuBoxHeight + snappedBottomInset();
    }

    @Override protected double computePrefWidth(double height) {
        final double menuBoxWidth = snapSizeX(menuBox.prefWidth(height));
        return snappedLeftInset() + menuBoxWidth + snappedRightInset();
    }

<A NAME="18"></A>    @Override protected void layoutChildren() {
        final double left = snappedLeftInset();
        final double right = snappedRightInset();
        final double top = <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#18',2,'match42-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>snappedTopInset();
        final double width = getWidth() - (left + right);
        final double pointerWidth = snapSizeX(Utils.boundedSize(pointer.prefWidth(-1), pointer.minWidth(-1), pointer.maxWidth</B></FONT>(-1)));
        final double pointerHeight = snapSizeY(Utils.boundedSize(pointer.prefWidth(-1), pointer.minWidth(-1), pointer.maxWidth(-1)));
        final double menuBoxWidth = snapSizeX(Utils.boundedSize(menuBox.prefWidth(-1), menuBox.minWidth(-1), menuBox.maxWidth(-1)));
        final double menuBoxHeight = snapSizeY(Utils.boundedSize(menuBox.prefWidth(-1), menuBox.minWidth(-1), menuBox.maxWidth(-1)));
        double sceneX = 0;
        double screenX = 0;
        double pointerX = 0;

        // Get the positions of the cursor from the TextArea/TextField and draw the arrow underneath it.
        Map&lt;Object,Object&gt; properties = null;
        if (contextMenu.getOwnerNode() instanceof TextArea) {
            properties = ((TextArea)contextMenu.getOwnerNode()).getProperties();
        } else if (contextMenu.getOwnerNode() instanceof TextField) {
            properties = ((TextField)contextMenu.getOwnerNode()).getProperties();
        }

        if (properties != null) {
            if (properties.containsKey(&quot;CONTEXT_MENU_SCENE_X&quot;)) {
                sceneX = Double.valueOf(properties.get(&quot;CONTEXT_MENU_SCENE_X&quot;).toString());
                properties.remove(&quot;CONTEXT_MENU_SCENE_X&quot;);
            }

            if (properties.containsKey(&quot;CONTEXT_MENU_SCREEN_X&quot;)) {
                screenX = Double.valueOf(properties.get(&quot;CONTEXT_MENU_SCREEN_X&quot;).toString());
                properties.remove(&quot;CONTEXT_MENU_SCREEN_X&quot;);
            }
        }

        if (sceneX == 0) {
            pointerX = width/2;
        } else {
            pointerX = (screenX - sceneX - contextMenu.getX()) + sceneX;
        }

        pointer.resize(pointerWidth, pointerHeight);
        positionInArea(pointer, pointerX, top, pointerWidth, pointerHeight, 0, HPos.CENTER, VPos.CENTER);
        menuBox.resize(menuBoxWidth, menuBoxHeight);
        positionInArea(menuBox, left, top + pointerHeight, menuBoxWidth, menuBoxHeight, 0, HPos.CENTER, VPos.CENTER);
    }

    class MenuItemContainer extends Button {
        private MenuItem item;

        public MenuItemContainer(MenuItem item){
            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            this.item = item;
            setText(item.getText());
            setStyle(item.getStyle());

            // bind to text property in menu item
            textProperty().bind(item.textProperty());
        }

        public MenuItem getItem() {
            return item;
        }

        @Override public void fire() {
            Event.fireEvent(item, new ActionEvent());
            if (!Boolean.TRUE.equals((Boolean)item.getProperties().get(&quot;refreshMenu&quot;))) {
                hideAllMenus(item);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/GlobalMenuAdapter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.ListChangeListener;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SeparatorMenuItem;

import java.util.List;

import com.sun.javafx.menu.CheckMenuItemBase;
import com.sun.javafx.menu.CustomMenuItemBase;
import com.sun.javafx.menu.MenuBase;
import com.sun.javafx.menu.MenuItemBase;
import com.sun.javafx.menu.RadioMenuItemBase;
import com.sun.javafx.menu.SeparatorMenuItemBase;

import com.sun.javafx.collections.TrackableObservableList;

public class GlobalMenuAdapter extends Menu implements MenuBase {
    private Menu menu;

    public static MenuBase adapt(Menu menu) {
        return new GlobalMenuAdapter(menu);
    }

    private final ObservableList&lt;MenuItemBase&gt; items = new TrackableObservableList&lt;MenuItemBase&gt;() {
        @Override protected void onChanged(Change&lt;MenuItemBase&gt; c) {
        }
    };

    private GlobalMenuAdapter(final Menu menu) {
        super(menu.getText());

        this.menu = menu;

<A NAME="19"></A>        bindMenuItemProperties(this, menu);

        menu.showingProperty().addListener(property -&gt; {
            <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#19',2,'match42-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (menu.isShowing() &amp;&amp; !isShowing()) {
                show();
            } else if (!menu.isShowing() &amp;&amp; isShowing()) {
                hide();
            }
        }</B></FONT>);
        showingProperty().addListener(property -&gt; {
            if (isShowing() &amp;&amp; !menu.isShowing()) {
                menu.show();
            } else if (!isShowing() &amp;&amp; menu.isShowing()) {
                menu.hide();
            }
        });

//        EventHandler&lt;Event&gt; showHideHandler = new EventHandler&lt;Event&gt;() {
//            public void handle(Event ev) {
//                Event.fireEvent(menu, new Event(ev.getEventType()));
//            }
//        };

        menu.getItems().addListener(new ListChangeListener&lt;MenuItem&gt;() {
            @Override public void onChanged(Change&lt;? extends MenuItem&gt; change) {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends MenuItem&gt; removed = change.getRemoved();
                    for (int i = from + removed.size() - 1; i &gt;= from ; i--) {
                        items.remove(i);
                        getItems().remove(i);
                    }
                    for (int i = from; i &lt; to; i++) {
                        MenuItem item = change.getList().get(i);
                        insertItem(item, i);
                    }
                }
            }
        });

        for (MenuItem menuItem : menu.getItems()) {
            insertItem(menuItem, items.size());
        }
    }

    private void insertItem(MenuItem menuItem, int pos) {
        MenuItemBase mib;

        if (menuItem instanceof Menu) {
            mib = new GlobalMenuAdapter((Menu)menuItem);
        } else if (menuItem instanceof CheckMenuItem) {
            mib = new CheckMenuItemAdapter((CheckMenuItem)menuItem);
        } else if (menuItem instanceof RadioMenuItem) {
            mib = new RadioMenuItemAdapter((RadioMenuItem)menuItem);
        } else if (menuItem instanceof SeparatorMenuItem) {
            mib = new SeparatorMenuItemAdapter((SeparatorMenuItem)menuItem);
        } else if (menuItem instanceof CustomMenuItem) {
            mib = new CustomMenuItemAdapter((CustomMenuItem)menuItem);
        } else {
            mib = new MenuItemAdapter(menuItem);
        }

        items.add(pos, mib);
        getItems().add(pos, (MenuItem)mib);
    }

    public final ObservableList&lt;MenuItemBase&gt; getItemsBase() {
        return items;
    }


    private static void bindMenuItemProperties(MenuItem adapter, final MenuItem menuItem) {
        adapter.idProperty().bind(menuItem.idProperty());
        adapter.textProperty().bind(menuItem.textProperty());
        adapter.graphicProperty().bind(menuItem.graphicProperty());
        adapter.disableProperty().bind(menuItem.disableProperty());
        adapter.visibleProperty().bind(menuItem.visibleProperty());
        adapter.acceleratorProperty().bind(menuItem.acceleratorProperty());
        adapter.mnemonicParsingProperty().bind(menuItem.mnemonicParsingProperty());

        adapter.setOnAction(ev -&gt; {
            menuItem.fire();
        });
    }

    @Override
    public void fireValidation() {
        if (menu.getOnMenuValidation() != null) {
            Event.fireEvent(menu, new Event(GlobalMenuAdapter.MENU_VALIDATION_EVENT));
        }
        Menu target = (Menu)menu.getParentMenu();
        if(target != null &amp;&amp; target.getOnMenuValidation() != null) {
            Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
        }
    }


    private static class MenuItemAdapter extends MenuItem implements MenuItemBase {
        private MenuItem menuItem;

        private MenuItemAdapter(final MenuItem menuItem) {
            super(menuItem.getText());

            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (menuItem.getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class CheckMenuItemAdapter extends CheckMenuItem implements CheckMenuItemBase {
        private CheckMenuItem menuItem;

        private CheckMenuItemAdapter(final CheckMenuItem menuItem) {
            super(menuItem.getText());
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);

            selectedProperty().bindBidirectional(menuItem.selectedProperty());
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(CheckMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class RadioMenuItemAdapter extends RadioMenuItem implements RadioMenuItemBase {
        private RadioMenuItem menuItem;

        private RadioMenuItemAdapter(final RadioMenuItem menuItem) {
            super(menuItem.getText());

            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);

            selectedProperty().bindBidirectional(menuItem.selectedProperty());
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(RadioMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class SeparatorMenuItemAdapter extends SeparatorMenuItem implements SeparatorMenuItemBase {
        private SeparatorMenuItem menuItem;

        private SeparatorMenuItemAdapter(final SeparatorMenuItem menuItem) {
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(SeparatorMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class CustomMenuItemAdapter extends CustomMenuItem implements CustomMenuItemBase {
        private CustomMenuItem menuItem;

        private CustomMenuItemAdapter(final CustomMenuItem menuItem) {
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(CustomMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/AccordionBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="50"></A> * questions.
 */

<FONT color="#ff0000"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#50',2,'match42-top.html#50',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.scene.control.behavior;

import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.control.Accordion;
import javafx.scene.control.FocusModel;
import javafx.scene.control.TitledPane;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import static javafx.scene.input.KeyCode.*;

public class AccordionBehavior extends BehaviorBase&lt;Accordion&gt; {

    private final InputMap&lt;Accordion&gt; inputMap</B></FONT>;
    private AccordionFocusModel focusModel;

    public AccordionBehavior(Accordion accordion) {
        super(accordion);
        focusModel = new AccordionFocusModel(accordion);

        // create a map for accordion-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // accordion-specific mappings for key and mouse input
        addDefaultMapping(inputMap,
                new InputMap.KeyMapping(UP, e -&gt; pageUp(false)),
                new InputMap.KeyMapping(DOWN, e -&gt; pageDown(false)),
                new InputMap.KeyMapping(LEFT, e -&gt; {
                    if (isRTL(accordion)) pageDown(false);
                    else pageUp(false);
                }),
                new InputMap.KeyMapping(RIGHT, e -&gt; {
                    if (isRTL(accordion)) pageUp(false);
                    else pageDown(false);
                }),
                new InputMap.KeyMapping(HOME, this::home),
                new InputMap.KeyMapping(END, this::end),
                new InputMap.KeyMapping(PAGE_UP, e -&gt; pageUp(true)),
                new InputMap.KeyMapping(PAGE_DOWN, e -&gt; pageDown(true)),
                new InputMap.KeyMapping(new KeyBinding(PAGE_UP).ctrl(), this::moveBackward),
                new InputMap.KeyMapping(new KeyBinding(PAGE_DOWN).ctrl(), this::moveForward),
                new InputMap.KeyMapping(new KeyBinding(TAB).ctrl(), this::moveForward),
                new InputMap.KeyMapping(new KeyBinding(TAB).ctrl().shift(), this::moveBackward),
                new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
        );
    }

    @Override public void dispose() {
        focusModel.dispose();
        super.dispose();
    }

    @Override public InputMap&lt;Accordion&gt; getInputMap() {
        return inputMap;
    }

    /***************************************************************************
     *                                                                         *
     * Key event handling                                                      *
     *                                                                         *
     **************************************************************************/

//    private static final String HOME = &quot;Home&quot;;
//    private static final String END = &quot;End&quot;;
//    private static final String PAGE_UP = &quot;Page_Up&quot;;
//    private static final String PAGE_DOWN = &quot;Page_Down&quot;;
//    private static final String CTRL_PAGE_UP = &quot;Ctrl_Page_Up&quot;;
//    private static final String CTRL_PAGE_DOWN = &quot;Ctrl_Page_Down&quot;;
//    private static final String CTRL_TAB = &quot;Ctrl_Tab&quot;;
//    private static final String CTRL_SHIFT_TAB = &quot;Ctrl_Shift_Tab&quot;;
//
//    protected static final List&lt;KeyBinding&gt; ACCORDION_BINDINGS = new ArrayList&lt;KeyBinding&gt;();
//    static {
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.UP, &quot;TraverseUp&quot;));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.DOWN, &quot;TraverseDown&quot;));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.LEFT, &quot;TraverseLeft&quot;));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.RIGHT, &quot;TraverseRight&quot;));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.HOME, HOME));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.END, END));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.PAGE_UP, PAGE_UP));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.PAGE_DOWN, PAGE_DOWN));
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.PAGE_UP, CTRL_PAGE_UP).ctrl());
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.PAGE_DOWN, CTRL_PAGE_DOWN).ctrl());
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.TAB, CTRL_TAB).ctrl());
//        ACCORDION_BINDINGS.add(new KeyBinding(KeyCode.TAB, CTRL_SHIFT_TAB).shift().ctrl());
//    }

//    @Override protected void callAction(String name) {
//        Accordion accordion = getNode();
//        boolean rtl = (accordion.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
//
//        if ((&quot;TraverseLeft&quot;.equals(name) &amp;&amp; !rtl) ||
//            (&quot;TraverseRight&quot;.equals(name) &amp;&amp; rtl) ||
//            &quot;TraverseUp&quot;.equals(name) ||
//                PAGE_UP.equals(name)) {
//
//            if (focusModel.getFocusedIndex() != -1 &amp;&amp; accordion.getPanes().get(focusModel.getFocusedIndex()).isFocused()) {
//                focusModel.focusPrevious();
//                int next = focusModel.getFocusedIndex();
//                accordion.getPanes().get(next).requestFocus();
//                if (PAGE_UP.equals(name)) {
//                    accordion.getPanes().get(next).setExpanded(true);
//                }
//            }
//        } else if ((&quot;TraverseRight&quot;.equals(name) &amp;&amp; !rtl) ||
//                   (&quot;TraverseLeft&quot;.equals(name) &amp;&amp; rtl) ||
//                   &quot;TraverseDown&quot;.equals(name) ||
//                PAGE_DOWN.equals(name)) {
//
//            if (focusModel.getFocusedIndex() != -1 &amp;&amp; accordion.getPanes().get(focusModel.getFocusedIndex()).isFocused()) {
//                focusModel.focusNext();
//                int next = focusModel.getFocusedIndex();
//                accordion.getPanes().get(next).requestFocus();
//                if (PAGE_DOWN.equals(name)) {
//                    accordion.getPanes().get(next).setExpanded(true);
//                }
//            }
//        } else if (CTRL_TAB.equals(name) || CTRL_PAGE_DOWN.equals(name)) {
////            moveForward();
//        } else if (CTRL_SHIFT_TAB.equals(name) || CTRL_PAGE_UP.equals(name)) {
////            moveBackward();
//        } else if (HOME.equals(name)) {
////            home();
//        } else if (END.equals(name)) {
////            end();
//        } else {
//            super.callAction(name);
//        }
//    }

    private void pageUp(boolean doExpand) {
        Accordion accordion = getNode();
        if (focusModel.getFocusedIndex() != -1 &amp;&amp; accordion.getPanes().get(focusModel.getFocusedIndex()).isFocused()) {
            focusModel.focusPrevious();
            int next = focusModel.getFocusedIndex();
            accordion.getPanes().get(next).requestFocus();
            if (doExpand) {
                accordion.getPanes().get(next).setExpanded(true);
            }
        }
    }

    private void pageDown(boolean doExpand) {
        Accordion accordion = getNode();
        if (focusModel.getFocusedIndex() != -1 &amp;&amp; accordion.getPanes().get(focusModel.getFocusedIndex()).isFocused()) {
            focusModel.focusNext();
            int next = focusModel.getFocusedIndex();
            accordion.getPanes().get(next).requestFocus();
            if (doExpand) {
                accordion.getPanes().get(next).setExpanded(true);
            }
        }
    }

    private void moveBackward(KeyEvent e) {
        Accordion accordion = getNode();
        focusModel.focusPrevious();
        if (focusModel.getFocusedIndex() != -1) {
            int next = focusModel.getFocusedIndex();
            accordion.getPanes().get(next).requestFocus();
            accordion.getPanes().get(next).setExpanded(true);
        }
    }

    private void moveForward(KeyEvent e) {
        Accordion accordion = getNode();
        focusModel.focusNext();
        if (focusModel.getFocusedIndex() != -1) {
            int next = focusModel.getFocusedIndex();
            accordion.getPanes().get(next).requestFocus();
            accordion.getPanes().get(next).setExpanded(true);
        }
    }

    private void home(KeyEvent e) {
        Accordion accordion = getNode();
        if (focusModel.getFocusedIndex() != -1 &amp;&amp; accordion.getPanes().get(focusModel.getFocusedIndex()).isFocused()) {
            TitledPane tp = accordion.getPanes().get(0);
            tp.requestFocus();
            tp.setExpanded(!tp.isExpanded());
        }
    }

    private void end(KeyEvent e) {
        Accordion accordion = getNode();
        if (focusModel.getFocusedIndex() != -1 &amp;&amp; accordion.getPanes().get(focusModel.getFocusedIndex()).isFocused()) {
            TitledPane tp = accordion.getPanes().get(accordion.getPanes().size() - 1);
            tp.requestFocus();
            tp.setExpanded(!tp.isExpanded());
        }
    }


    /**
     * Mouse press over the background of the accordion
     * i.e. it missed all of the titled panes
     * select the last titled pane, or the accordion if
     * none present
     */
    public void mousePressed(MouseEvent e) {
        Accordion accordion = getNode();
        if (accordion.getPanes().size() &gt; 0) {
            TitledPane lastTitledPane = accordion.getPanes().get(accordion.getPanes().size() - 1);
            lastTitledPane.requestFocus();
        }
        else {
            accordion.requestFocus();
        }
    }


    static class AccordionFocusModel extends FocusModel&lt;TitledPane&gt; {

        private final Accordion accordion;
        private final ChangeListener&lt;Boolean&gt; focusListener = new ChangeListener&lt;Boolean&gt;() {
            @Override
            public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, Boolean newValue) {
                if (newValue) {
                    if (accordion.getExpandedPane() != null) {
                        accordion.getExpandedPane().requestFocus();
                    } else {
                        // TODO need to detect the focus direction
                        // to selected the first panel when TAB is pressed
                        // or select the last panel when SHIFT TAB is pressed.
                        if (! accordion.getPanes().isEmpty()) {
                            accordion.getPanes().get(0).requestFocus();
                        }
                    }
                }
            }
        };
        private final ChangeListener&lt;Boolean&gt; paneFocusListener = new ChangeListener&lt;Boolean&gt;() {
            @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, Boolean newValue) {
                if (newValue) {
                    final ReadOnlyBooleanProperty focusedProperty = (ReadOnlyBooleanProperty) observable;
                    final TitledPane tp = (TitledPane) focusedProperty.getBean();
                    focus(accordion.getPanes().indexOf(tp));
                }
            }
        };
        private final ListChangeListener&lt;TitledPane&gt; panesListener = c -&gt; {
            while (c.next()) {
                if (c.wasAdded()) {
                    for (final TitledPane tp: c.getAddedSubList()) {
                        tp.focusedProperty().addListener(paneFocusListener);
                    }
                } else if (c.wasRemoved()) {
                    for (final TitledPane tp: c.getAddedSubList()) {
                        tp.focusedProperty().removeListener(paneFocusListener);
                    }
                }
            }
        };

        public AccordionFocusModel(final Accordion accordion) {
            if (accordion == null) {
                throw new IllegalArgumentException(&quot;Accordion can not be null&quot;);
            }
            this.accordion = accordion;
            this.accordion.focusedProperty().addListener(focusListener);
            this.accordion.getPanes().addListener(panesListener);
            for (final TitledPane tp: this.accordion.getPanes()) {
                tp.focusedProperty().addListener(paneFocusListener);
            }
        }

        void dispose() {
            accordion.focusedProperty().removeListener(focusListener);
            accordion.getPanes().removeListener(panesListener);
            for (final TitledPane tp: this.accordion.getPanes()) {
                tp.focusedProperty().removeListener(paneFocusListener);
            }
        }

        @Override
        protected int getItemCount() {
            final ObservableList&lt;TitledPane&gt; panes = accordion.getPanes();
            return panes == null ? 0 : panes.size();
        }

        @Override
        protected TitledPane getModelItem(int row) {
            final ObservableList&lt;TitledPane&gt; panes = accordion.getPanes();
            if (panes == null) return null;
            if (row &lt; 0) return null;
            return panes.get(row%panes.size());
        }

        @Override public void focusPrevious() {
            if (getFocusedIndex() &lt;= 0) {
                focus(accordion.getPanes().size() - 1);
            } else {
                focus((getFocusedIndex() - 1)%accordion.getPanes().size());
            }
        }

        @Override public void focusNext() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else {
                focus((getFocusedIndex() + 1)%accordion.getPanes().size());
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ListViewBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.event.EventHandler;
import javafx.geometry.Orientation;
import javafx.scene.control.FocusModel;
import javafx.scene.control.ListView;
import javafx.scene.control.MultipleSelectionModel;
import javafx.scene.control.SelectionMode;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.util.Callback;

import java.util.ArrayList;
import java.util.List;

import static com.sun.javafx.scene.control.inputmap.InputMap.*;
import static javafx.scene.input.KeyCode.*;

public class ListViewBehavior&lt;T&gt; extends BehaviorBase&lt;ListView&lt;T&gt;&gt; {
    private final InputMap&lt;ListView&lt;T&gt;&gt; listViewInputMap;

    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        if (!e.isConsumed()) {
            // RT-12751: we want to keep an eye on the user holding down the shift key,
            // so that we know when they enter/leave multiple selection mode. This
            // changes what happens when certain key combinations are pressed.
            isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
            isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public ListViewBehavior(ListView&lt;T&gt; control) {
        super(control);

        // create a map for listView-specific mappings
        listViewInputMap = createInputMap();

        // add focus traversal mappings
        addDefaultMapping(listViewInputMap, FocusTraversalInputMap.getFocusTraversalMappings());
        addDefaultMapping(listViewInputMap,
            new KeyMapping(HOME, e -&gt; selectFirstRow()),
            new KeyMapping(END, e -&gt; selectLastRow()),
            new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
            new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
            new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
            new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),

            new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
            new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),

            new KeyMapping(PAGE_UP, e -&gt; scrollPageUp()),
            new KeyMapping(PAGE_DOWN, e -&gt; scrollPageDown()),

            new KeyMapping(ENTER, e -&gt; activate()),
            new KeyMapping(SPACE, e -&gt; activate()),
            new KeyMapping(F2, e -&gt; activate()),
            new KeyMapping(ESCAPE, e -&gt; cancelEdit()),

            new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll()),
            new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
            new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
            new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
            new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),

            new KeyMapping(new KeyBinding(BACK_SLASH).shortcut(), e -&gt; clearSelection()),

            new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
        );

        // create OS-specific child mappings
        // --- mac OS
        InputMap&lt;ListView&lt;T&gt;&gt; macInputMap = new InputMap&lt;&gt;(control);
        macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
        addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(listViewInputMap, macInputMap);

        // --- all other platforms
        InputMap&lt;ListView&lt;T&gt;&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
        otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
        addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(listViewInputMap, otherOsInputMap);

        // create two more child maps, one for vertical listview and one for horizontal listview
        // --- vertical listview
        InputMap&lt;ListView&lt;T&gt;&gt; verticalListInputMap = new InputMap&lt;&gt;(control);
        verticalListInputMap.setInterceptor(event -&gt; control.getOrientation() != Orientation.VERTICAL);

        addDefaultMapping(verticalListInputMap,
            new KeyMapping(UP, e -&gt; selectPreviousRow()),
            new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
            new KeyMapping(DOWN, e -&gt; selectNextRow()),
            new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),

            new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNextRow()),
            new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNextRow()),

            new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
            new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),

            new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
            new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
            new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
            new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown()),
            new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
            new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow())
        );

        addDefaultChildMap(listViewInputMap, verticalListInputMap);

        // --- horizontal listview
        InputMap&lt;ListView&lt;T&gt;&gt; horizontalListInputMap = new InputMap&lt;&gt;(control);
        horizontalListInputMap.setInterceptor(event -&gt; control.getOrientation() != Orientation.HORIZONTAL);

        addDefaultMapping(horizontalListInputMap,
            new KeyMapping(LEFT, e -&gt; selectPreviousRow()),
            new KeyMapping(KP_LEFT, e -&gt; selectPreviousRow()),
            new KeyMapping(RIGHT, e -&gt; selectNextRow()),
            new KeyMapping(KP_RIGHT, e -&gt; selectNextRow()),

            new KeyMapping(new KeyBinding(LEFT).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(KP_LEFT).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(RIGHT).shift(), e -&gt; alsoSelectNextRow()),
            new KeyMapping(new KeyBinding(KP_RIGHT).shift(), e -&gt; alsoSelectNextRow()),

            new KeyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; focusPreviousRow()),
            new KeyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; focusNextRow()),

            new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
            new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; discontinuousSelectNextRow())
        );

        addDefaultChildMap(listViewInputMap, horizontalListInputMap);

        // set up other listeners
        // We make this an event _filter_ so that we can determine the state
        // of the shift key before the event handlers get a shot at the event.
        control.addEventFilter(KeyEvent.ANY, keyEventListener);

        control.itemsProperty().addListener(weakItemsListener);
        if (control.getItems() != null) {
            control.getItems().addListener(weakItemsListListener);
        }

        // Fix for RT-16565
        control.selectionModelProperty().addListener(weakSelectionModelListener);
        if (control.getSelectionModel() != null) {
            control.getSelectionModel().getSelectedIndices().addListener(weakSelectedIndicesListener);
        }

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusListBehavior(control); // needs to be last.
        }
    }



    /***************************************************************************
     *                                                                         *
     * Implementation of BehaviorBase API                                      *
     *                                                                         *
     **************************************************************************/

    @Override public InputMap&lt;ListView&lt;T&gt;&gt; getInputMap() {
        return listViewInputMap;
    }

    @Override public void dispose() {
        ListView&lt;T&gt; control = getNode();

        ListCellBehavior.removeAnchor(control);
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();

        control.removeEventHandler(KeyEvent.ANY, keyEventListener);
    }





    /**************************************************************************
     *                         State and Functions                            *
     *************************************************************************/

    private boolean isShiftDown = false;
    private boolean isShortcutDown = false;

    private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
    private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
    private Runnable onFocusPreviousRow;
    private Runnable onFocusNextRow;
    private Runnable onSelectPreviousRow;
    private Runnable onSelectNextRow;
    private Runnable onMoveToFirstCell;
    private Runnable onMoveToLastCell;

    public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }
    public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }
    public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }
    public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }
    public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }
    public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }
    public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }
    public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }

    private boolean selectionChanging = false;

    private final ListChangeListener&lt;Integer&gt; selectedIndicesListener = c -&gt; {
        int newAnchor = getAnchor();

        while (c.next()) {
            if (c.wasReplaced()) {
                if (ListCellBehavior.hasDefaultAnchor(getNode())) {
                    ListCellBehavior.removeAnchor(getNode());
                    continue;
                }
            }

            final int shift = c.wasPermutated() ? c.getTo() - c.getFrom() : 0;

            MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();

            // there are no selected items, so lets clear out the anchor
            if (! selectionChanging) {
                if (sm.isEmpty()) {
                    newAnchor = -1;
                } else if (hasAnchor() &amp;&amp; ! sm.isSelected(getAnchor() + shift)) {
                    newAnchor = -1;
                }
            }

            // we care about the situation where the selection changes, and there is no anchor. In this
            // case, we set a new anchor to be the selected index
            if (newAnchor == -1) {
                int addedSize = c.getAddedSize();
                newAnchor = addedSize &gt; 0 ? c.getAddedSubList().get(addedSize - 1) : newAnchor;
            }
        }

        if (newAnchor &gt; -1) {
            setAnchor(newAnchor);
        }
    };

    private final ListChangeListener&lt;T&gt; itemsListListener = c -&gt; {
<A NAME="35"></A>        while (c.next()) {
            if (!hasAnchor()) continue;

            int newAnchor = (<FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#35',2,'match42-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>hasAnchor() ? getAnchor() : 0);

            if (c.wasAdded() &amp;&amp; c.getFrom() &lt;= newAnchor) {
                newAnchor += c.getAddedSize();
            } else if (c.wasRemoved() &amp;&amp; c.getFrom() &lt;= newAnchor) {
                newAnchor -= c.getRemovedSize();
            }</B></FONT>

            setAnchor(newAnchor &lt; 0 ? 0 : newAnchor);
        }
    };

    private final ChangeListener&lt;ObservableList&lt;T&gt;&gt; itemsListener = new ChangeListener&lt;ObservableList&lt;T&gt;&gt;() {
        @Override
        public void changed(
                ObservableValue&lt;? extends ObservableList&lt;T&gt;&gt; observable,
                ObservableList&lt;T&gt; oldValue, ObservableList&lt;T&gt; newValue) {
            if (oldValue != null) {
                oldValue.removeListener(weakItemsListListener);
            } if (newValue != null) {
                newValue.addListener(weakItemsListListener);
            }
        }
    };

    private final ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelListener = new ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;() {
        @Override public void changed(
                ObservableValue&lt;? extends MultipleSelectionModel&lt;T&gt;&gt; observable,
                MultipleSelectionModel&lt;T&gt; oldValue,
                MultipleSelectionModel&lt;T&gt; newValue) {
            if (oldValue != null) {
                oldValue.getSelectedIndices().removeListener(weakSelectedIndicesListener);
            }
            if (newValue != null) {
                newValue.getSelectedIndices().addListener(weakSelectedIndicesListener);
            }
        }
    };

    private final WeakChangeListener&lt;ObservableList&lt;T&gt;&gt; weakItemsListener =
            new WeakChangeListener&lt;ObservableList&lt;T&gt;&gt;(itemsListener);
    private final WeakListChangeListener&lt;Integer&gt; weakSelectedIndicesListener =
            new WeakListChangeListener&lt;Integer&gt;(selectedIndicesListener);
    private final WeakListChangeListener&lt;T&gt; weakItemsListListener =
            new WeakListChangeListener&lt;&gt;(itemsListListener);
    private final WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; weakSelectionModelListener =
            new WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;(selectionModelListener);

    private TwoLevelFocusListBehavior tlFocus;

    private void setAnchor(int anchor) {
        ListCellBehavior.setAnchor(getNode(), anchor &lt; 0 ? null : anchor, false);
    }

    private int getAnchor() {
        return ListCellBehavior.getAnchor(getNode(), getNode().getFocusModel().getFocusedIndex());
    }

    private boolean hasAnchor() {
        return ListCellBehavior.hasNonDefaultAnchor(getNode());
    }

<A NAME="72"></A>    private void mousePressed(MouseEvent e) {
        if (! e.isShiftDown() &amp;&amp; ! e.isSynthesized()) {
            int index = getNode().getSelectionModel().getSelectedIndex();
            <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#72',2,'match42-top.html#72',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setAnchor(index);
        }

        if (! getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {</B></FONT>
            getNode().requestFocus();
        }
    }

    private int getRowCount() {
        return getNode().getItems() == null ? 0 : getNode().getItems().size();
    }

    private void clearSelection() {
        getNode().getSelectionModel().clearSelection();
    }

    private void scrollPageUp() {
        int newSelectedIndex = -1;
        if (onScrollPageUp != null) {
            newSelectedIndex = onScrollPageUp.call(false);
        }
        if (newSelectedIndex == -1) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;
        sm.clearAndSelect(newSelectedIndex);
    }

    private void scrollPageDown() {
        int newSelectedIndex = -1;
        if (onScrollPageDown != null) {
            newSelectedIndex = onScrollPageDown.call(false);
        }
        if (newSelectedIndex == -1) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;
        sm.clearAndSelect(newSelectedIndex);
    }

    private void focusFirstRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(0);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    private void focusLastRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(getRowCount() - 1);

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    private void focusPreviousRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        fm.focusPrevious();

        if (! isShortcutDown || getAnchor() == -1) {
            setAnchor(fm.getFocusedIndex());
        }

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    private void focusNextRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        fm.focusNext();

        if (! isShortcutDown || getAnchor() == -1) {
            setAnchor(fm.getFocusedIndex());
        }

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    private void focusPageUp() {
        int newFocusIndex = onScrollPageUp.call(true);

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(newFocusIndex);
    }

    private void focusPageDown() {
        int newFocusIndex = onScrollPageDown.call(true);

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(newFocusIndex);
    }

    private void alsoSelectPreviousRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (isShiftDown &amp;&amp; getAnchor() != -1) {
            int newRow = fm.getFocusedIndex() - 1;
            if (newRow &lt; 0) return;

            int anchor = getAnchor();

            if (! hasAnchor()) {
                setAnchor(fm.getFocusedIndex());
            }

            if (sm.getSelectedIndices().size() &gt; 1) {
                clearSelectionOutsideRange(anchor, newRow);
            }

            if (anchor &gt; newRow) {
                sm.selectRange(anchor, newRow - 1);
            } else {
                sm.selectRange(anchor, newRow + 1);
            }
        } else {
            sm.selectPrevious();
        }

        onSelectPreviousRow.run();
    }

    private void alsoSelectNextRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (isShiftDown &amp;&amp; getAnchor() != -1) {
            int newRow = fm.getFocusedIndex() + 1;
            int anchor = getAnchor();

            if (! hasAnchor()) {
                setAnchor(fm.getFocusedIndex());
            }

            if (sm.getSelectedIndices().size() &gt; 1) {
                clearSelectionOutsideRange(anchor, newRow);
            }

            if (anchor &gt; newRow) {
                sm.selectRange(anchor, newRow - 1);
            } else {
                sm.selectRange(anchor, newRow + 1);
            }
        } else {
            sm.selectNext();
        }

        onSelectNextRow.run();
    }

    private void clearSelectionOutsideRange(int start, int end) {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        int min = Math.min(start, end);
        int max = Math.max(start, end);

        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;(sm.getSelectedIndices());

        selectionChanging = true;
        for (int i = 0; i &lt; indices.size(); i++) {
            int index = indices.get(i);
            if (index &lt; min || index &gt; max) {
                sm.clearSelection(index);
            }
        }
        selectionChanging = false;
    }

    private void selectPreviousRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        if (focusIndex &lt;= 0) {
            return;
        }

        setAnchor(focusIndex - 1);
        getNode().getSelectionModel().clearAndSelect(focusIndex - 1);
        onSelectPreviousRow.run();
    }

    private void selectNextRow() {
        ListView&lt;T&gt; listView = getNode();
        FocusModel&lt;T&gt; fm = listView.getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        if (focusIndex == getRowCount() - 1) {
            return;
        }

        MultipleSelectionModel&lt;T&gt; sm = listView.getSelectionModel();
        if (sm == null) return;

        setAnchor(focusIndex + 1);
        sm.clearAndSelect(focusIndex + 1);
        if (onSelectNextRow != null) onSelectNextRow.run();
    }

    private void selectFirstRow() {
        if (getRowCount() &gt; 0) {
            getNode().getSelectionModel().clearAndSelect(0);
            if (onMoveToFirstCell != null) onMoveToFirstCell.run();
        }
    }

    private void selectLastRow() {
        getNode().getSelectionModel().clearAndSelect(getRowCount() - 1);
        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    private void selectAllPageUp() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        if (isShiftDown) {
            leadIndex = getAnchor() == -1 ? leadIndex : getAnchor();
            setAnchor(leadIndex);
        }

        int leadSelectedIndex = onScrollPageUp.call(false);

        // fix for RT-34407
        int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        selectionChanging = true;
        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            sm.select(leadSelectedIndex);
        } else {
            sm.clearSelection();
            sm.selectRange(leadIndex, leadSelectedIndex + adjust);
        }
        selectionChanging = false;
    }

    private void selectAllPageDown() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        if (isShiftDown) {
            leadIndex = getAnchor() == -1 ? leadIndex : getAnchor();
            setAnchor(leadIndex);
        }

        int leadSelectedIndex = onScrollPageDown.call(false);

        // fix for RT-34407
        int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        selectionChanging = true;
        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            sm.select(leadSelectedIndex);
        } else {
            sm.clearSelection();
            sm.selectRange(leadIndex, leadSelectedIndex + adjust);
        }
        selectionChanging = false;
    }

    private void selectAllToFirstRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();

        if (isShiftDown) {
            leadIndex = hasAnchor() ? getAnchor() : leadIndex;
        }

        sm.clearSelection();
        sm.selectRange(leadIndex, -1);

        // RT-18413: Focus must go to first row
        fm.focus(0);

        if (isShiftDown) {
            setAnchor(leadIndex);
        }

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    private void selectAllToLastRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();

        if (isShiftDown) {
            leadIndex = hasAnchor() ? getAnchor() : leadIndex;
        }

        sm.clearSelection();
        sm.selectRange(leadIndex, getRowCount());

        if (isShiftDown) {
            setAnchor(leadIndex);
        }

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    private void selectAll() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;
        sm.selectAll();
    }

    private void selectAllToFocus(boolean setAnchorToFocusIndex) {
        // Fix for RT-31241
        final ListView&lt;T&gt; listView = getNode();
        if (listView.getEditingIndex() &gt;= 0) return;

        MultipleSelectionModel&lt;T&gt; sm = listView.getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = listView.getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        int anchor = getAnchor();

        sm.clearSelection();
        int startPos = anchor;
        int endPos = anchor &gt; focusIndex ? focusIndex - 1 : focusIndex + 1;
        sm.selectRange(startPos, endPos);
        setAnchor(setAnchorToFocusIndex ? focusIndex : anchor);
    }

    private void cancelEdit() {
        getNode().edit(-1);
    }

    private void activate() {
        int focusedIndex = getNode().getFocusModel().getFocusedIndex();
        getNode().getSelectionModel().select(focusedIndex);
        setAnchor(focusedIndex);

        // edit this row also
        if (focusedIndex &gt;= 0) {
            getNode().edit(focusedIndex);
        }
    }

    private void toggleFocusOwnerSelection() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusedIndex = fm.getFocusedIndex();

        if (sm.isSelected(focusedIndex)) {
            sm.clearSelection(focusedIndex);
            fm.focus(focusedIndex);
        } else {
            sm.select(focusedIndex);
        }

        setAnchor(focusedIndex);
    }

    /**************************************************************************
     * Discontinuous Selection                                                *
     *************************************************************************/

    private void discontinuousSelectPreviousRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectPreviousRow();
            return;
        }

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex - 1;
        if (newFocusIndex &lt; 0) return;

        int startIndex = focusIndex;
        if (isShiftDown) {
            startIndex = getAnchor() == -1 ? focusIndex : getAnchor();
        }

        sm.selectRange(newFocusIndex, startIndex + 1);
        fm.focus(newFocusIndex);

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    private void discontinuousSelectNextRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectNextRow();
            return;
        }

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex + 1;
        if (newFocusIndex &gt;= getRowCount()) return;

        int startIndex = focusIndex;
        if (isShiftDown) {
            startIndex = getAnchor() == -1 ? focusIndex : getAnchor();
        }

        sm.selectRange(startIndex, newFocusIndex + 1);
        fm.focus(newFocusIndex);

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    private void discontinuousSelectPageUp() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int anchor = getAnchor();
        int leadSelectedIndex = onScrollPageUp.call(false);
        sm.selectRange(anchor, leadSelectedIndex - 1);
    }

    private void discontinuousSelectPageDown() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int anchor = getAnchor();
        int leadSelectedIndex = onScrollPageDown.call(false);
        sm.selectRange(anchor, leadSelectedIndex + 1);
    }

    private void discontinuousSelectAllToFirstRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex();
        sm.selectRange(0, index);
        fm.focus(0);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    private void discontinuousSelectAllToLastRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex() + 1;
        sm.selectRange(index, getRowCount());

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/SliderBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import javafx.geometry.Orientation;
import javafx.scene.control.Skin;
import javafx.scene.control.Slider;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import com.sun.javafx.util.Utils;
import static javafx.scene.input.KeyCode.*;

public class SliderBehavior extends BehaviorBase&lt;Slider&gt; {

    private final InputMap&lt;Slider&gt; sliderInputMap;

    private TwoLevelFocusBehavior tlFocus;

    public SliderBehavior(Slider slider) {
        super(slider);

        // create a map for slider-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        sliderInputMap = createInputMap();

        // then slider-specific mappings for key input
        addDefaultMapping(sliderInputMap,
            new InputMap.KeyMapping(HOME, KeyEvent.KEY_RELEASED, e -&gt; home()),
            new InputMap.KeyMapping(END, KeyEvent.KEY_RELEASED, e -&gt; end())
        );

        // we split the rest of the mappings into vertical and horizontal slider
        // child input maps
        // -- horizontal
        InputMap&lt;Slider&gt; horizontalMappings = new InputMap&lt;&gt;(slider);
        horizontalMappings.setInterceptor(e -&gt; slider.getOrientation() != Orientation.HORIZONTAL);
        horizontalMappings.getMappings().addAll(
            // we use the rtl method to translate depending on the RTL state of the UI
<A NAME="23"></A>            new InputMap.KeyMapping(LEFT, e -&gt; rtl(slider, this::incrementValue, this::decrementValue)),
            new InputMap.KeyMapping(KP_LEFT, e -&gt; rtl(slider, this::incrementValue, this::decrementValue)),
            new InputMap.KeyMapping(RIGHT, e -&gt; rtl(slider, this::decrementValue, this::incrementValue)),
            new InputMap.KeyMapping(KP_RIGHT, <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#23',2,'match42-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>e -&gt; rtl(slider, this::decrementValue, this::incrementValue))
        );
        addDefaultChildMap(sliderInputMap, horizontalMappings);

        // -- vertical
        InputMap&lt;Slider&gt; verticalMappings = new InputMap&lt;&gt;(slider);
        verticalMappings.setInterceptor(e -&gt; slider.getOrientation() != Orientation.VERTICAL);
        verticalMappings.getMappings</B></FONT>().addAll(
                new InputMap.KeyMapping(DOWN, e -&gt; decrementValue()),
                new InputMap.KeyMapping(KP_DOWN, e -&gt; decrementValue()),
                new InputMap.KeyMapping(UP, e -&gt; incrementValue()),
                new InputMap.KeyMapping(KP_UP, e -&gt; incrementValue())
        );
        addDefaultChildMap(sliderInputMap, verticalMappings);

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (com.sun.javafx.scene.control.skin.Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(slider); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();
    }

    @Override public InputMap&lt;Slider&gt; getInputMap() {
        return sliderInputMap;
    }

    /**************************************************************************
     *                         State and Functions                            *
     *************************************************************************/

    /**
     * Invoked by the Slider {@link Skin} implementation whenever a mouse press
     * occurs on the &quot;track&quot; of the slider. This will cause the thumb to be
     * moved by some amount.
     *
     * @param position The mouse position on track with 0.0 being beginning of
     *        track and 1.0 being the end
     */
    public void trackPress(MouseEvent e, double position) {
        // determine the percentage of the way between min and max
        // represented by this mouse event
        final Slider slider = getNode();
        // If not already focused, request focus
        if (!slider.isFocused()) slider.requestFocus();
        if (slider.getOrientation().equals(Orientation.HORIZONTAL)) {
            slider.adjustValue(position * (slider.getMax() - slider.getMin()) + slider.getMin());
        } else {
            slider.adjustValue((1-position) * (slider.getMax() - slider.getMin()) + slider.getMin());
        }
    }

     /**
     * @param position The mouse position on track with 0.0 being beginning of
      *       track and 1.0 being the end
     */
    public void thumbPressed(MouseEvent e, double position) {
        // If not already focused, request focus
        final Slider slider = getNode();
        if (!slider.isFocused())  slider.requestFocus();
        slider.setValueChanging(true);
    }

    /**
     * @param position The mouse position on track with 0.0 being beginning of
     *        track and 1.0 being the end
     */
    public void thumbDragged(MouseEvent e, double position) {
        final Slider slider = getNode();
        slider.setValue(Utils.clamp(slider.getMin(), (position * (slider.getMax() - slider.getMin())) + slider.getMin(), slider.getMax()));
    }

    /**
     * When thumb is released valueChanging should be set to false.
     */
    public void thumbReleased(MouseEvent e) {
        final Slider slider = getNode();
        slider.setValueChanging(false);
        // RT-15207 When snapToTicks is true, slider value calculated in drag
        // is then snapped to the nearest tick on mouse release.
        slider.adjustValue(slider.getValue());
    }

    void home() {
        final Slider slider = getNode();
        slider.adjustValue(slider.getMin());
    }

    void decrementValue() {
        final Slider slider = getNode();
        // RT-8634 If snapToTicks is true and block increment is less than
        // tick spacing, tick spacing is used as the decrement value.
        if (slider.isSnapToTicks()) {
            slider.adjustValue(slider.getValue() - computeIncrement());
        } else {
            slider.decrement();
        }

    }

    void end() {
        final Slider slider = getNode();
        slider.adjustValue(slider.getMax());
    }

    void incrementValue() {
        final Slider slider = getNode();
        // RT-8634 If snapToTicks is true and block increment is less than
        // tick spacing, tick spacing is used as the increment value.
        if (slider.isSnapToTicks()) {
            slider.adjustValue(slider.getValue()+ computeIncrement());
        } else {
            slider.increment();
        }
    }

    // Used only if snapToTicks is true.
    double computeIncrement() {
        final Slider slider = getNode();
        double tickSpacing = 0;
        if (slider.getMinorTickCount() != 0) {
            tickSpacing = slider.getMajorTickUnit() / (Math.max(slider.getMinorTickCount(),0)+1);
        } else {
            tickSpacing = slider.getMajorTickUnit();
        }

        if (slider.getBlockIncrement() &gt; 0 &amp;&amp; slider.getBlockIncrement() &lt; tickSpacing) {
                return tickSpacing;
        }

        return slider.getBlockIncrement();
    }

//    public static class SliderKeyBinding extends OrientedKeyBinding {
//        public SliderKeyBinding(KeyCode code, String action) {
//            super(code, action);
//        }
//
//        public SliderKeyBinding(KeyCode code, EventType&lt;KeyEvent&gt; type, String action) {
//            super(code, type, action);
//        }
//
//        public @Override boolean getVertical(Control control) {
//            return ((Slider)control).getOrientation() == Orientation.VERTICAL;
//        }
//    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TableViewBehaviorBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.SizeLimitedList;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.*;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.util.Callback;
import java.util.ArrayList;
import java.util.List;
import com.sun.javafx.PlatformUtil;
import static javafx.scene.input.KeyCode.*;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;

public abstract class TableViewBehaviorBase&lt;C extends Control, T, TC extends TableColumnBase&lt;T,?&gt;&gt; extends BehaviorBase&lt;C&gt; {

    /**************************************************************************
     *                                                                        *
     * Internal fields                                                        *
     *                                                                        *
     *************************************************************************/

    private final InputMap&lt;C&gt; tableViewInputMap;

    protected boolean isShortcutDown = false;
    protected boolean isShiftDown = false;
    private boolean selectionPathDeviated = false;
    protected boolean selectionChanging = false;

    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        if (!e.isConsumed()) {
            // RT-12751: we want to keep an eye on the user holding down the shift key,
            // so that we know when they enter/leave multiple selection mode. This
            // changes what happens when certain key combinations are pressed.
            isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
            isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
        }
    };

    private final SizeLimitedList&lt;TablePositionBase&gt; selectionHistory = new SizeLimitedList&lt;&gt;(10);

    protected final ListChangeListener&lt;TablePositionBase&gt; selectedCellsListener = c -&gt; {
        while (c.next()) {
            if (c.wasReplaced()) {
                if (TreeTableCellBehavior.hasDefaultAnchor(getNode())) {
                    TreeTableCellBehavior.removeAnchor(getNode());
                }
            }

            if (! c.wasAdded()) {
                continue;
            }

            TableSelectionModel sm = getSelectionModel();
            if (sm == null) return;

            TablePositionBase anchor = getAnchor();
            boolean cellSelectionEnabled = sm.isCellSelectionEnabled();

            int addedSize = c.getAddedSize();
            List&lt;TablePositionBase&gt; addedSubList = (List&lt;TablePositionBase&gt;) c.getAddedSubList();

            for (TablePositionBase tpb : addedSubList) {
                if (! selectionHistory.contains(tpb)) {
                    selectionHistory.add(tpb);
                }
            }

            // newest selection
            if (addedSize &gt; 0 &amp;&amp; ! hasAnchor()) {
                TablePositionBase tp = addedSubList.get(addedSize - 1);
                setAnchor(tp);
            }

            if (anchor != null &amp;&amp; cellSelectionEnabled &amp;&amp; ! selectionPathDeviated) {
                // check if the selection is on the same row or column,
                // otherwise set selectionPathDeviated to true
                for (int i = 0; i &lt; addedSize; i++) {
                    TablePositionBase tp = addedSubList.get(i);
                    if (anchor.getRow() != -1 &amp;&amp; tp.getRow() != anchor.getRow() &amp;&amp; tp.getColumn() != anchor.getColumn()) {
                        setSelectionPathDeviated(true);
                        break;
                    }
                }
            }
        }
    };

    protected final WeakListChangeListener&lt;TablePositionBase&gt; weakSelectedCellsListener =
            new WeakListChangeListener&lt;TablePositionBase&gt;(selectedCellsListener);



    /**************************************************************************
     *                                                                        *
     * Constructors                                                           *
     *                                                                        *
     *************************************************************************/

    public TableViewBehaviorBase(C control) {
        super(control);


        // create a map for TableView(Base)-specific mappings
        tableViewInputMap = createInputMap();

        KeyMapping enterKeyActivateMapping, escapeKeyCancelEditMapping;
        addDefaultMapping(tableViewInputMap,
                new KeyMapping(TAB, FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),

                new KeyMapping(HOME, e -&gt; selectFirstRow()),
                new KeyMapping(END, e -&gt; selectLastRow()),

                new KeyMapping(PAGE_UP, e -&gt; scrollUp()),
                new KeyMapping(PAGE_DOWN, e -&gt; scrollDown()),

                new KeyMapping(LEFT, e -&gt; selectLeftCell()),
                new KeyMapping(KP_LEFT, e -&gt; selectLeftCell()),
                new KeyMapping(RIGHT, e -&gt; selectRightCell()),
                new KeyMapping(KP_RIGHT, e -&gt; selectRightCell()),

                new KeyMapping(UP, e -&gt; selectPreviousRow()),
                new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
                new KeyMapping(DOWN, e -&gt; selectNextRow()),
                new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),

                new KeyMapping(LEFT, FocusTraversalInputMap::traverseLeft),
                new KeyMapping(KP_LEFT, FocusTraversalInputMap::traverseLeft),
                new KeyMapping(RIGHT, FocusTraversalInputMap::traverseRight),
                new KeyMapping(KP_RIGHT, FocusTraversalInputMap::traverseRight),
                new KeyMapping(UP, FocusTraversalInputMap::traverseUp),
                new KeyMapping(KP_UP, FocusTraversalInputMap::traverseUp),
                new KeyMapping(DOWN, FocusTraversalInputMap::traverseDown),
                new KeyMapping(KP_DOWN, FocusTraversalInputMap::traverseDown),

                new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
                new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
                new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
                new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),

                new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPrevious()),
                new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPrevious()),
                new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNext()),
                new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNext()),

                new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
                new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),

                new KeyMapping(new KeyBinding(LEFT).shift(), e -&gt; alsoSelectLeftCell()),
                new KeyMapping(new KeyBinding(KP_LEFT).shift(), e -&gt; alsoSelectLeftCell()),
                new KeyMapping(new KeyBinding(RIGHT).shift(), e -&gt; alsoSelectRightCell()),
                new KeyMapping(new KeyBinding(KP_RIGHT).shift(), e -&gt; alsoSelectRightCell()),

                new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
                new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),
                new KeyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; focusRightCell()),
                new KeyMapping(new KeyBinding(KP_RIGHT).shortcut(), e -&gt; focusRightCell()),
                new KeyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; focusLeftCell()),
                new KeyMapping(new KeyBinding(KP_LEFT).shortcut(), e -&gt; focusLeftCell()),

                new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll()),
                new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
                new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
                new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
                new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),

                new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
                new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
                new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; discontinuousSelectPreviousColumn()),
                new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; discontinuousSelectNextColumn()),
                new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
                new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown()),
                new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
                new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow()),

                enterKeyActivateMapping = new KeyMapping(ENTER, this::activate),
                new KeyMapping(SPACE, this::activate),
                new KeyMapping(F2, this::activate),
                escapeKeyCancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
        );

        enterKeyActivateMapping.setAutoConsume(false);
        escapeKeyCancelEditMapping.setAutoConsume(false);

        // create OS-specific child mappings
        // --- mac OS
        InputMap&lt;C&gt; macInputMap = new InputMap&lt;&gt;(control);
        macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
        addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(tableViewInputMap, macInputMap);

        // --- all other platforms
        InputMap&lt;C&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
        otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
        addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(tableViewInputMap, otherOsInputMap);

        // set up other listeners
        // We make this an event _filter_ so that we can determine the state
        // of the shift key before the event handlers get a shot at the event.
        control.addEventFilter(KeyEvent.ANY, keyEventListener);
    }



    /**************************************************************************
     *                                                                        *
     * Abstract API                                                           *
     *                                                                        *
     *************************************************************************/

    /** {@inheritDoc} */
    @Override public InputMap&lt;C&gt; getInputMap() {
        return tableViewInputMap;
    }

    /**
     * Call to record the current anchor position
     */
    protected void setAnchor(TablePositionBase tp) {
        TableCellBehaviorBase.setAnchor(getNode(), tp, false);
        setSelectionPathDeviated(false);
    }

    /**
     * Will return the current anchor position.
     */
    protected TablePositionBase getAnchor() {
        return TableCellBehaviorBase.getAnchor(getNode(), getFocusedCell());
    }

    /**
     * Returns true if there is an anchor set, and false if not anchor is set.
     */
    protected boolean hasAnchor() {
        return TableCellBehaviorBase.hasNonDefaultAnchor(getNode());
    }

    /**
     * Returns the number of items in the underlying data model.
     */
    protected abstract int getItemCount();

    /**
     * Returns the focus model for the underlying UI control (which must extend
     * from TableFocusModel).
     */
    protected abstract TableFocusModel getFocusModel();

    /**
     * Returns the selection model for the underlying UI control (which must extend
     * from TableSelectionModel).
     */
    protected abstract TableSelectionModel&lt;T&gt; getSelectionModel();

    /**
     * Returns an observable list of all cells that are currently selected in
     * the selection model of the underlying control.
     */
    protected abstract ObservableList&lt;? extends TablePositionBase/*&lt;C,TC&gt;*/&gt; getSelectedCells();

    /**
     * Returns the focused cell from the focus model of the underlying control.
     */
    protected abstract TablePositionBase getFocusedCell();

    /**
     * Returns the position of the given table column in the visible leaf columns
     * list of the underlying control.
     */
    protected abstract int getVisibleLeafIndex(TableColumnBase tc);

    /**
     * Returns the column at the given index in the visible leaf columns list of
     * the underlying control.
     */
    protected abstract TableColumnBase getVisibleLeafColumn(int index);

    /**
     * Returns true if the control (i.e. TableView / TreeTableView) is editable
     */
    protected abstract boolean isControlEditable();

    /**
     * Begins the edit process in the underlying control for the given row/column
     * position.
     */
    protected abstract void editCell(int row, TableColumnBase tc);

    /**
     * Returns an observable list of all visible leaf columns in the underlying
     * control.
     */
    protected abstract ObservableList&lt;? extends TableColumnBase&gt; getVisibleLeafColumns();

    /**
     * Creates a TablePositionBase instance using the underlying controls
     * concrete implementation for the given row/column intersection.
     */
    protected abstract TablePositionBase&lt;TC&gt; getTablePosition(int row, TableColumnBase&lt;T,?&gt; tc);



    /**************************************************************************
     *                                                                        *
     * Public API                                                             *
     *                                                                        *
     *************************************************************************/

    /*
     * Anchor is created upon
     * - initial selection of an item (by mouse or keyboard)
     *
     * Anchor is changed when you
     * - move the selection to an item by UP/DOWN/LEFT/RIGHT arrow keys
     * - select an item by mouse click
     * - add/remove an item to/from an existing selection by CTRL+SPACE shortcut
     * - add/remove an items to/from an existing selection by CTRL+mouse click
     *
     * Note that if an item is removed from an existing selection by
     * CTRL+SPACE/CTRL+mouse click, anchor still remains on this item even
     * though it is not selected.
     *
     * Anchor is NOT changed when you
     * - create linear multi-selection by SHIFT+UP/DOWN/LEFT/RIGHT arrow keys
     * - create linear multi-selection by SHIFT+SPACE arrow keys
     * - create linear multi-selection by SHIFT+mouse click
     *
     * In case there is a discontinuous selection in the list, creating linear
     * multi-selection between anchor and focused item will cancel the
     * discontinuous selection. It means that only items that are located between
     * anchor and focused item will be selected.
     */
    protected void setAnchor(int row, TableColumnBase col) {
        setAnchor(row == -1 &amp;&amp; col == null ? null : getTablePosition(row, col));
    }

    private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
    public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }

    private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
    public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }

    private Runnable onFocusPreviousRow;
    public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }

    private Runnable onFocusNextRow;
    public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }

    private Runnable onSelectPreviousRow;
    public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }

    private Runnable onSelectNextRow;
    public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }

    private Runnable onMoveToFirstCell;
    public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }

    private Runnable onMoveToLastCell;
    public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }

    private Runnable onSelectRightCell;
    public void setOnSelectRightCell(Runnable r) { onSelectRightCell = r; }

    private Runnable onSelectLeftCell;
    public void setOnSelectLeftCell(Runnable r) { onSelectLeftCell = r; }

    public void mousePressed(MouseEvent e) {
//        // FIXME can't assume (yet) cells.get(0) is necessarily the lead cell
//        ObservableList&lt;? extends TablePositionBase&gt; cells = getSelectedCells();
//        setAnchor(cells.isEmpty() ? null : cells.get(0));

        if (!getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
            getNode().requestFocus();
        }
    }

    protected boolean isRTL() {
        return (getNode().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
    }


    /**************************************************************************
     *                                                                        *
     * Private implementation                                                 *
     *                                                                        *
     *************************************************************************/

    private void setSelectionPathDeviated(boolean selectionPathDeviated) {
        this.selectionPathDeviated = selectionPathDeviated;
    }

    protected void scrollUp() {
        TableSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm == null || getSelectedCells().isEmpty()) return;

        TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);

        int newSelectedIndex = -1;
        if (onScrollPageUp != null) {
            newSelectedIndex = onScrollPageUp.call(false);
        }
        if (newSelectedIndex == -1) return;

        sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
    }

    protected void scrollDown() {
        TableSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm == null || getSelectedCells().isEmpty()) return;

        TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);

        int newSelectedIndex = -1;
        if (onScrollPageDown != null) {
            newSelectedIndex = onScrollPageDown.call(false);
        }
        if (newSelectedIndex == -1) return;

        sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
    }

    protected void focusFirstRow() {
        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(0, tc);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void focusLastRow() {
        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(getItemCount() - 1, tc);

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    protected void focusPreviousRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            fm.focusAboveCell();
        } else {
            fm.focusPrevious();
        }

        if (! isShortcutDown || getAnchor() == null) {
            setAnchor(fm.getFocusedIndex(), null);
        }

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    protected void focusNextRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            fm.focusBelowCell();
        } else {
            fm.focusNext();
        }

        if (! isShortcutDown || getAnchor() == null) {
            setAnchor(fm.getFocusedIndex(), null);
        }

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    protected void focusLeftCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        fm.focusLeftCell();
        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    protected void focusRightCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        fm.focusRightCell();
        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    protected void focusPageUp() {
        int newFocusIndex = onScrollPageUp.call(true);

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;
        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(newFocusIndex, tc);
    }

    protected void focusPageDown() {
        int newFocusIndex = onScrollPageDown.call(true);

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;
        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(newFocusIndex, tc);
    }

    protected void clearSelection() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        sm.clearSelection();
    }

    protected void clearSelectionOutsideRange(int start, int end, TableColumnBase&lt;T,?&gt; column) {
        TableSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm == null) return;

        int min = Math.min(start, end);
        int max = Math.max(start, end);

        List&lt;Integer&gt; indices = new ArrayList&lt;Integer&gt;(sm.getSelectedIndices());

        selectionChanging = true;
        for (int i = 0; i &lt; indices.size(); i++) {
            int index = indices.get(i);
            if (index &lt; min || index &gt; max) {
                sm.clearSelection(index, column);
            }
        }
        selectionChanging = false;
    }

    protected void alsoSelectPrevious() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            selectPreviousRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            updateCellVerticalSelection(-1, () -&gt; {
                getSelectionModel().selectAboveCell();
            });
        } else {
            if (isShiftDown &amp;&amp; hasAnchor()) {
                updateRowSelection(-1);
            } else {
                sm.selectPrevious();
            }
        }
        onSelectPreviousRow.run();
    }

    protected void alsoSelectNext() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            selectNextRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            updateCellVerticalSelection(1, () -&gt; {
                getSelectionModel().selectBelowCell();
            });
        } else {
            if (isShiftDown &amp;&amp; hasAnchor()) {
                updateRowSelection(1);
            } else {
                sm.selectNext();
            }
        }
        onSelectNextRow.run();
    }

    protected void alsoSelectLeftCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || !sm.isCellSelectionEnabled()) return;

        updateCellHorizontalSelection(-1, () -&gt; getSelectionModel().selectLeftCell());
        onSelectLeftCell.run();
    }

    protected void alsoSelectRightCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || !sm.isCellSelectionEnabled()) return;

        updateCellHorizontalSelection(1, () -&gt; getSelectionModel().selectRightCell());
        onSelectRightCell.run();
    }

    protected void updateRowSelection(int delta) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int newRow = fm.getFocusedIndex() + delta;
        TablePositionBase anchor = getAnchor();

        if (! hasAnchor()) {
            setAnchor(getFocusedCell());
        }

        if (sm.getSelectedIndices().size() &gt; 1) {
            clearSelectionOutsideRange(anchor.getRow(), newRow, null);
        }

        if (anchor.getRow() &gt; newRow) {
            sm.selectRange(anchor.getRow(), newRow - 1);
        } else {
            sm.selectRange(anchor.getRow(), newRow + 1);
        }
    }

    protected void updateCellVerticalSelection(int delta, Runnable defaultAction) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final TablePositionBase focusedCell = getFocusedCell();
        final int focusedCellRow = focusedCell.getRow();

        if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow + delta, focusedCell.getTableColumn())) {
            int newFocusOwner = focusedCellRow + delta;

            // work out if we're backtracking
            boolean backtracking = false;
            if (selectionHistory.size() &gt;= 2) {
                TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectionHistory.get(1);
                backtracking = secondToLastSelectedCell.getRow() == newFocusOwner &amp;&amp;
                        secondToLastSelectedCell.getColumn() == focusedCell.getColumn();
            }

            // if the selection path has deviated from the anchor row / column, then we need to see if we're moving
            // backwards to the previous selection or not (as it determines what cell row we clear out)
            int cellRowToClear = selectionPathDeviated ?
                    (backtracking ? focusedCellRow : newFocusOwner) :
                    focusedCellRow;

            sm.clearSelection(cellRowToClear, focusedCell.getTableColumn());
            fm.focus(newFocusOwner, focusedCell.getTableColumn());
        } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
<A NAME="47"></A>            int newRow = fm.getFocusedIndex() + delta;

            // we don't let the newRow go outside the bounds of the data
            newRow = <FONT color="#d16587"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#47',2,'match42-top.html#47',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Math.max(Math.min(getItemCount() - 1, newRow), 0);

            int start = Math.min(getAnchor().getRow(), newRow);
            int end = Math.max</B></FONT>(getAnchor().getRow(), newRow);

            if (sm.getSelectedIndices().size() &gt; 1) {
                clearSelectionOutsideRange(start, end, focusedCell.getTableColumn());
            }

            for (int _row = start; _row &lt;= end; _row++) {
                if (sm.isSelected(_row, focusedCell.getTableColumn())) {
                    continue;
                }
                sm.select(_row, focusedCell.getTableColumn());
            }
            fm.focus(newRow, focusedCell.getTableColumn());
        } else {
            final int focusIndex = fm.getFocusedIndex();
            if (! sm.isSelected(focusIndex, focusedCell.getTableColumn())) {
                sm.select(focusIndex, focusedCell.getTableColumn());
            }
            defaultAction.run();
        }
    }

    protected void updateCellHorizontalSelection(int delta, Runnable defaultAction) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final TablePositionBase focusedCell = getFocusedCell();
        if (focusedCell == null || focusedCell.getTableColumn() == null) return;

        boolean atEnd = false;
        TableColumnBase adjacentColumn = getColumn(focusedCell.getTableColumn(), delta);
        if (adjacentColumn == null) {
            // if adjacentColumn is null, we use the focusedCell column, as we are
            // most probably at the very beginning or end of the row
            adjacentColumn = focusedCell.getTableColumn();
            atEnd = true;
        }

        final int focusedCellRow = focusedCell.getRow();

        if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow, adjacentColumn)) {
            if (atEnd) {
                return;
            }

            // work out if we're backtracking
            boolean backtracking = false;
            ObservableList&lt;? extends TablePositionBase&gt; selectedCells = getSelectedCells();
            if (selectedCells.size() &gt;= 2) {
                TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectedCells.get(selectedCells.size() - 2);
                backtracking = secondToLastSelectedCell.getRow() == focusedCellRow &amp;&amp;
                        secondToLastSelectedCell.getTableColumn().equals(adjacentColumn);
            }

            // if the selection path has deviated from the anchor row / column, then we need to see if we're moving
            // backwards to the previous selection or not (as it determines what cell column we clear out)
            TableColumnBase&lt;?,?&gt; cellColumnToClear = selectionPathDeviated ?
                    (backtracking ? focusedCell.getTableColumn() : adjacentColumn) :
                    focusedCell.getTableColumn();

            sm.clearSelection(focusedCellRow, cellColumnToClear);
            fm.focus(focusedCellRow, adjacentColumn);
        } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
            final int anchorColumn = getAnchor().getColumn();

            // we don't let the newColumn go outside the bounds of the data
            int newColumn = getVisibleLeafIndex(focusedCell.getTableColumn()) + delta;
            newColumn = Math.max(Math.min(getVisibleLeafColumns().size() - 1, newColumn), 0);

            int start = Math.min(anchorColumn, newColumn);
            int end = Math.max(anchorColumn, newColumn);

            for (int _col = start; _col &lt;= end; _col++) {
                sm.select(focusedCell.getRow(), getColumn(_col));
            }
            fm.focus(focusedCell.getRow(), getColumn(newColumn));
        } else {
            defaultAction.run();
        }
    }

    protected TableColumnBase getColumn(int index) {
        return getVisibleLeafColumn(index);
    }

    protected TableColumnBase getColumn(TableColumnBase tc, int delta) {
        return getVisibleLeafColumn(getVisibleLeafIndex(tc) + delta);
    }

    protected void selectFirstRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
        TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
        sm.clearAndSelect(0, selectedColumn);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void selectLastRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
        TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
        sm.clearAndSelect(getItemCount() - 1, selectedColumn);

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    protected void selectPreviousRow() {
        selectCell(-1, 0);
        if (onSelectPreviousRow != null) onSelectPreviousRow.run();
    }

    protected void selectNextRow() {
        selectCell(1, 0);
        if (onSelectNextRow != null) onSelectNextRow.run();
    }

    protected void selectLeftCell() {
        selectCell(0, -1);
        if (onSelectLeftCell != null) onSelectLeftCell.run();
    }

    protected void selectRightCell() {
        selectCell(0, 1);
        if (onSelectRightCell != null) onSelectRightCell.run();
    }

    protected void selectCell(int rowDiff, int columnDiff) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
        int currentRow = focusedCell.getRow();
        int currentColumn = getVisibleLeafIndex(focusedCell.getTableColumn());

        if (rowDiff &lt; 0 &amp;&amp; currentRow &lt;= 0) return;
        else if (rowDiff &gt; 0 &amp;&amp; currentRow &gt;= getItemCount() - 1) return;
        else if (columnDiff &lt; 0 &amp;&amp; currentColumn &lt;= 0) return;
        else if (columnDiff &gt; 0 &amp;&amp; currentColumn &gt;= getVisibleLeafColumns().size() - 1) return;
        else if (columnDiff &gt; 0 &amp;&amp; currentColumn == -1) return;

        TableColumnBase tc = focusedCell.getTableColumn();
        tc = getColumn(tc, columnDiff);

        int row = focusedCell.getRow() + rowDiff;
        sm.clearAndSelect(row, tc);
        setAnchor(row, tc);
    }

    protected void cancelEdit(KeyEvent e) {
        if (isControlEditable()) {
            editCell(-1, null);
            e.consume();
        }
    }

    protected void activate(KeyEvent e) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase&lt;TC&gt; cell = getFocusedCell();
        sm.select(cell.getRow(), cell.getTableColumn());
        setAnchor(cell);

        // check if we are editable
        boolean isEditable = isControlEditable() &amp;&amp; cell.getTableColumn().isEditable();

        // edit this row also
        if (isEditable &amp;&amp; cell.getRow() &gt;= 0) {
            editCell(cell.getRow(), cell.getTableColumn());
            e.consume();
        }
    }

    protected void selectAllToFocus(boolean setAnchorToFocusIndex) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
        int focusRow = focusedCell.getRow();

        TablePositionBase&lt;TC&gt; anchor = getAnchor();
        int anchorRow = anchor.getRow();

        sm.clearSelection();
        if (! sm.isCellSelectionEnabled()) {
            int startPos = anchorRow;
            int endPos = anchorRow &gt; focusRow ? focusRow - 1 : focusRow + 1;
            sm.selectRange(startPos, endPos);
        } else {
            // we add all cells/rows between the current selection focus and
            // the anchor (inclusive) to the current selection.
            // We want focus to end up on the current focus position.
            sm.selectRange(anchor.getRow(), anchor.getTableColumn(),
                           focusedCell.getRow(), focusedCell.getTableColumn());
        }

        setAnchor(setAnchorToFocusIndex ? focusedCell : anchor);
    }

    protected void selectAll() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;
        sm.selectAll();
    }

    protected void selectAllToFirstRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final boolean isSingleSelection = sm.getSelectionMode() == SelectionMode.SINGLE;
        final TablePositionBase focusedCell = getFocusedCell();
        final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
        int leadIndex = focusedCell.getRow();

        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
        }

        sm.clearSelection();
        if (! sm.isCellSelectionEnabled()) {
            // we are going from 0 to one before the focused cell as that is
            // the requirement of selectRange, so we call focus on the 0th row
            if (isSingleSelection) {
                sm.select(0);
            } else {
                sm.selectRange(leadIndex, -1);
            }
            fm.focus(0);
        } else {
            if (isSingleSelection) {
                sm.select(0, column);
            } else {
                sm.selectRange(leadIndex, column, -1, column);
            }
            fm.focus(0, column);
        }

        if (isShiftDown) {
            setAnchor(leadIndex, column);
        }

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void selectAllToLastRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final int itemCount = getItemCount();
        final TablePositionBase focusedCell = getFocusedCell();
        final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
        int leadIndex = focusedCell.getRow();

        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
        }

        sm.clearSelection();
        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(leadIndex, itemCount);
        } else {
            sm.selectRange(leadIndex, column, itemCount - 1, column);
        }

        if (isShiftDown) {
            setAnchor(leadIndex, column);
        }

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    protected void selectAllPageUp() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
            setAnchor(leadIndex, col);
        }

        int leadSelectedIndex = onScrollPageUp.call(false);

        selectionChanging = true;
        if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
            if (sm.isCellSelectionEnabled()) {
                sm.select(leadSelectedIndex, col);
            } else {
                sm.select(leadSelectedIndex);
            }
        } else {
            sm.clearSelection();
            if (sm.isCellSelectionEnabled()) {
                sm.selectRange(leadIndex, col, leadSelectedIndex, col);
            } else {
                // fix for RT-34407
                int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
                sm.selectRange(leadIndex, leadSelectedIndex + adjust);
            }
        }
        selectionChanging = false;
    }

    protected void selectAllPageDown() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
            setAnchor(leadIndex, col);
        }

        int leadSelectedIndex = onScrollPageDown.call(false);

        selectionChanging = true;
        if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
            if (sm.isCellSelectionEnabled()) {
                sm.select(leadSelectedIndex, col);
            } else {
                sm.select(leadSelectedIndex);
            }
        } else {
            sm.clearSelection();

            if (sm.isCellSelectionEnabled()) {
                sm.selectRange(leadIndex, col, leadSelectedIndex, col);
            } else {
                // fix for RT-34407
                int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
                sm.selectRange(leadIndex, leadSelectedIndex + adjust);
            }
        }
        selectionChanging = false;
    }

    protected void toggleFocusOwnerSelection() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase focusedCell = getFocusedCell();

        if (sm.isSelected(focusedCell.getRow(), focusedCell.getTableColumn())) {
            sm.clearSelection(focusedCell.getRow(), focusedCell.getTableColumn());
            fm.focus(focusedCell.getRow(), focusedCell.getTableColumn());
        } else {
            sm.select(focusedCell.getRow(), focusedCell.getTableColumn());
        }

        setAnchor(focusedCell.getRow(), focusedCell.getTableColumn());
    }

    // This functionality was added, but then removed when it was realised by
    // UX that TableView should not include 'spreadsheet-like' functionality.
    // When / if we ever introduce this kind of control, this functionality can
    // be re-enabled then.
    /*
    protected void moveToLeftMostColumn() {
        // Functionality as described in RT-12752
        if (onMoveToLeftMostColumn != null) onMoveToLeftMostColumn.run();

        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePosition focusedCell = fm.getFocusedCell();

        TableColumn endColumn = getNode().getVisibleLeafColumn(0);
        sm.clearAndSelect(focusedCell.getRow(), endColumn);
    }

    protected void moveToRightMostColumn() {
        // Functionality as described in RT-12752
        if (onMoveToRightMostColumn != null) onMoveToRightMostColumn.run();

        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePosition focusedCell = fm.getFocusedCell();

        TableColumn endColumn = getNode().getVisibleLeafColumn(getNode().getVisibleLeafColumns().size() - 1);
        sm.clearAndSelect(focusedCell.getRow(), endColumn);
    }
     */


    /**************************************************************************
     * Discontinuous Selection                                                *
     *************************************************************************/

    protected void discontinuousSelectPreviousRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectPreviousRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex - 1;
        if (newFocusIndex &lt; 0) return;

        int startIndex = focusIndex;
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
        }

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(newFocusIndex, startIndex + 1);
            fm.focus(newFocusIndex);
        } else {
            for (int i = newFocusIndex; i &lt; startIndex + 1; i++) {
                sm.select(i, col);
            }
            fm.focus(newFocusIndex, col);
        }

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    protected void discontinuousSelectNextRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectNextRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex + 1;
        if (newFocusIndex &gt;= getItemCount()) return;

        int startIndex = focusIndex;
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
        }

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(startIndex, newFocusIndex + 1);
            fm.focus(newFocusIndex);
        } else {
            for (int i = startIndex; i &lt; newFocusIndex + 1; i++) {
                sm.select(i, col);
            }
            fm.focus(newFocusIndex, col);
        }

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    protected void discontinuousSelectPreviousColumn() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), -1);
        sm.select(fm.getFocusedIndex(), tc);
    }

    protected void discontinuousSelectNextColumn() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), 1);
        sm.select(fm.getFocusedIndex(), tc);
    }

    protected void discontinuousSelectPageUp() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
        int leadSelectedIndex = onScrollPageUp.call(false);

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(anchor, leadSelectedIndex - 1);
        }
    }

    protected void discontinuousSelectPageDown() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
        int leadSelectedIndex = onScrollPageDown.call(false);

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(anchor, leadSelectedIndex + 1);
        }
    }

    protected void discontinuousSelectAllToFirstRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex();

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(0, index);
            fm.focus(0);
        } else {
            for (int i = 0; i &lt; index; i++) {
                sm.select(i, getFocusedCell().getTableColumn());
            }
            fm.focus(0, getFocusedCell().getTableColumn());
        }

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void discontinuousSelectAllToLastRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex() + 1;

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(index, getItemCount());
        } else {
            for (int i = index; i &lt; getItemCount(); i++) {
                sm.select(i, getFocusedCell().getTableColumn());
            }
        }

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextFieldBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.Properties;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.TextField;
import javafx.scene.control.skin.TextFieldSkin;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.HitInfo;
import javafx.stage.Screen;
import javafx.stage.Window;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.geom.transform.Affine3D;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;

/**
 * Text field behavior.
 */
public class TextFieldBehavior extends TextInputControlBehavior&lt;TextField&gt; {
    private TextFieldSkin skin;
    private TwoLevelFocusBehavior tlFocus;
    private ChangeListener&lt;Scene&gt; sceneListener;
    private ChangeListener&lt;Node&gt; focusOwnerListener;

    public TextFieldBehavior(final TextField textField) {
        super(textField);

        if (Properties.IS_TOUCH_SUPPORTED) {
            contextMenu.getStyleClass().add(&quot;text-input-context-menu&quot;);
        }

        handleFocusChange();

        // Register for change events
        textField.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            handleFocusChange();
        });

        focusOwnerListener = (observable, oldValue, newValue) -&gt; {
            // RT-23699: The selection is now only affected when the TextField
            // gains or loses focus within the Scene, and not when the whole
            // stage becomes active or inactive.
            if (newValue == textField) {
                if (!focusGainedByMouseClick) {
                    textField.selectRange(textField.getLength(), 0);
                }
            } else {
                textField.selectRange(0, 0);
            }
        };

        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
                                new WeakChangeListener&lt;Node&gt;(focusOwnerListener);
        sceneListener = (observable, oldValue, newValue) -&gt; {
            if (oldValue != null) {
                oldValue.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newValue != null) {
                newValue.focusOwnerProperty().addListener(weakFocusOwnerListener);
            }
        };
        textField.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;(sceneListener));

        if (textField.getScene() != null) {
            textField.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(textField); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();
    }

    private void handleFocusChange() {
        TextField textField = getNode();

        if (textField.isFocused()) {
            if (PlatformUtil.isIOS()) {
                // special handling of focus on iOS is required to allow to
                // control native keyboard, because nat. keyboard is poped-up only when native
                // text component gets focus. When we have JFX keyboard we can remove this code
                TextInputTypes type = TextInputTypes.TEXT_FIELD;
                if (textField.getClass().equals(javafx.scene.control.PasswordField.class)) {
                    type = TextInputTypes.PASSWORD_FIELD;
                } else if (textField.getParent().getClass().equals(javafx.scene.control.ComboBox.class)) {
                    type = TextInputTypes.EDITABLE_COMBO;
                }
                final Bounds bounds = textField.getBoundsInParent();
                double w = bounds.getWidth();
                double h = bounds.getHeight();
                Affine3D trans = calculateNodeToSceneTransform(textField);
//                Insets insets = skin.getInsets();
//                w -= insets.getLeft() + insets.getRight();
//                h -= insets.getTop() + insets.getBottom();
                String text = textField.getText();

                // we need to display native text input component on the place where JFX component is drawn
                // all parameters needed to do that are passed to native impl. here
                WindowHelper.getPeer(textField.getScene().getWindow()).requestInput(
                        text, type.ordinal(), w, h,
                        trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),// + insets.getLeft(),
                        trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),// + insets.getTop(),
                        trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
            }
            if (!focusGainedByMouseClick) {
                setCaretAnimating(true);
            }
        } else {
            if (PlatformUtil.isIOS() &amp;&amp; textField.getScene() != null) {
                // releasing the focus =&gt; we need to hide the native component and also native keyboard
                WindowHelper.getPeer(textField.getScene().getWindow()).releaseInput();
            }
            focusGainedByMouseClick = false;
            setCaretAnimating(false);
        }
    }

    static Affine3D calculateNodeToSceneTransform(Node node) {
        final Affine3D transform = new Affine3D();
        do {
            transform.preConcatenate(NodeHelper.getLeafTransform(node));
            node = node.getParent();
        } while (node != null);

        return transform;
    }

    // An unholy back-reference!
    public void setTextFieldSkin(TextFieldSkin skin) {
        this.skin = skin;
    }

    @Override protected void fire(KeyEvent event) {
        TextField textField = getNode();
        EventHandler&lt;ActionEvent&gt; onAction = textField.getOnAction();
        ActionEvent actionEvent = new ActionEvent(textField, null);

        textField.commitValue();
        textField.fireEvent(actionEvent);

        if (onAction == null &amp;&amp; !actionEvent.isConsumed()) {
            forwardToParent(event);
        }
    }

    @Override
    protected void cancelEdit(KeyEvent event) {
        TextField textField = getNode();
        if (textField.getTextFormatter() != null) {
            textField.cancelEdit();
            event.consume();
        } else {
            super.cancelEdit(event);
        }
    }

    @Override protected void deleteChar(boolean previous) {
        skin.deleteChar(previous);
    }

    @Override protected void replaceText(int start, int end, String txt) {
        skin.setForwardBias(true);
        skin.replaceText(start, end, txt);
    }

    @Override protected void deleteFromLineStart() {
        TextField textField = getNode();
        int end = textField.getCaretPosition();

        if (end &gt; 0) {
            replaceText(0, end, &quot;&quot;);
        }
    }

    @Override protected void setCaretAnimating(boolean play) {
        if (skin != null) {
            skin.setCaretAnimating(play);
        }
    }

    /**
     * Function which beeps. This requires a hook into the toolkit, and should
     * also be guarded by something that indicates whether we should beep
     * (as it is pretty annoying and many native controls don't do it).
     */
    private void beep() {
        // TODO
    }

    /**
     * If the focus is gained via response to a mouse click, then we don't
     * want to select all the text even if selectOnFocus is true.
     */
    private boolean focusGainedByMouseClick = false;
    private boolean shiftDown = false;
    private boolean deferClick = false;

    @Override public void mousePressed(MouseEvent e) {
        TextField textField = getNode();
        // We never respond to events if disabled
        if (!textField.isDisabled()) {
            // If the text field doesn't have focus, then we'll attempt to set
            // the focus and we'll indicate that we gained focus by a mouse
            // click, which will then NOT honor the selectOnFocus variable
            // of the textInputControl
            if (!textField.isFocused()) {
                focusGainedByMouseClick = true;
                textField.requestFocus();
            }

            // stop the caret animation
            setCaretAnimating(false);
            // only if there is no selection should we see the caret
<A NAME="74"></A>//            setCaretOpacity(if (textInputControl.dot == textInputControl.mark) then 1.0 else 0.0);

            // if the primary button was pressed
            if (e.isPrimaryButtonDown() &amp;&amp; !(<FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#74',2,'match42-top.html#74',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                HitInfo hit = skin.getIndex(e.getX(), e.getY());
                int i = hit.getInsertionIndex</B></FONT>();
                final int anchor = textField.getAnchor();
                final int caretPosition = textField.getCaretPosition();
                if (e.getClickCount() &lt; 2 &amp;&amp;
                    (Properties.IS_TOUCH_SUPPORTED ||
                     (anchor != caretPosition &amp;&amp;
                      ((i &gt; anchor &amp;&amp; i &lt; caretPosition) || (i &lt; anchor &amp;&amp; i &gt; caretPosition))))) {
                    // if there is a selection, then we will NOT handle the
                    // press now, but will defer until the release. If you
                    // select some text and then press down, we change the
                    // caret and wait to allow you to drag the text (TODO).
                    // When the drag concludes, then we handle the click

                    deferClick = true;
                    // TODO start a timer such that after some millis we
                    // switch into text dragging mode, change the cursor
                    // to indicate the text can be dragged, etc.
                } else if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    switch (e.getClickCount()) {
                        case 1: mouseSingleClick(hit); break;
                        case 2: mouseDoubleClick(hit); break;
                        case 3: mouseTripleClick(hit); break;
                        default: // no-op
                    }
                } else if (e.isShiftDown() &amp;&amp; !(e.isControlDown() || e.isAltDown() || e.isMetaDown()) &amp;&amp; e.getClickCount() == 1) {
                    // didn't click inside the selection, so select
                    shiftDown = true;
                    // if we are on mac os, then we will accumulate the
                    // selection instead of just moving the dot. This happens
                    // by figuring out past which (dot/mark) are extending the
                    // selection, and set the mark to be the other side and
                    // the dot to be the new position.
                    // everywhere else we just move the dot.
                    if (isMac()) {
                        textField.extendSelection(i);
                    } else {
                        skin.positionCaret(hit, true);
                    }
                }
                skin.setForwardBias(hit.isLeading());
//                if (textInputControl.editable)
//                    displaySoftwareKeyboard(true);
            }
        }
        if (contextMenu.isShowing()) {
            contextMenu.hide();
        }
    }

    @Override public void mouseDragged(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled() &amp;&amp; !deferClick) {
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), true);
                }
            }
        }
    }

    @Override public void mouseReleased(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled()) {
            setCaretAnimating(false);
            if (deferClick) {
                deferClick = false;
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), shiftDown);
                shiftDown = false;
            }
            setCaretAnimating(true);
        }
    }

    @Override public void contextMenuRequested(ContextMenuEvent e) {
        final TextField textField = getNode();

        if (contextMenu.isShowing()) {
            contextMenu.hide();
        } else if (textField.getContextMenu() == null &amp;&amp;
                   textField.getOnContextMenuRequested() == null) {
            double screenX = e.getScreenX();
            double screenY = e.getScreenY();
            double sceneX = e.getSceneX();

            if (Properties.IS_TOUCH_SUPPORTED) {
                Point2D menuPos;
                if (textField.getSelection().getLength() == 0) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                    menuPos = skin.getMenuPosition();
                } else {
                    menuPos = skin.getMenuPosition();
                    if (menuPos != null &amp;&amp; (menuPos.getX() &lt;= 0 || menuPos.getY() &lt;= 0)) {
                        skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                        menuPos = skin.getMenuPosition();
                    }
                }

                if (menuPos != null) {
                    Point2D p = getNode().localToScene(menuPos);
                    Scene scene = getNode().getScene();
                    Window window = scene.getWindow();
                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),
                                                   window.getY() + scene.getY() + p.getY());
                    screenX = location.getX();
                    sceneX = p.getX();
                    screenY = location.getY();
                }
            }

            populateContextMenu();
            double menuWidth = contextMenu.prefWidth(-1);
            double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0);
            Screen currentScreen = com.sun.javafx.util.Utils.getScreenForPoint(screenX, 0);
            Rectangle2D bounds = currentScreen.getBounds();

            if (menuX &lt; bounds.getMinX()) {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), bounds.getMinX(), screenY);
            } else if (screenX + menuWidth &gt; bounds.getMaxX()) {
                double leftOver = menuWidth - ( bounds.getMaxX() - screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), screenX - leftOver, screenY);
            } else {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, 0);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, 0);
                contextMenu.show(getNode(), menuX, screenY);
            }
        }

        e.consume();
    }

    protected void mouseSingleClick(HitInfo hit) {
        skin.positionCaret(hit, false);
    }

    protected void mouseDoubleClick(HitInfo hit) {
        final TextField textField = getNode();
        textField.previousWord();
        if (isWindows()) {
            textField.selectNextWord();
        } else {
            textField.selectEndOfNextWord();
        }
    }

    protected void mouseTripleClick(HitInfo hit) {
        getNode().selectAll();
    }

    // Enumeration of all types of text input that can be simulated on
    // touch device, such as iPad. Type is passed to native code and
    // native text component is shown. It's used as workaround for iOS
    // devices since keyboard control is not possible without native
    // text component being displayed
    enum TextInputTypes {
        TEXT_FIELD,
        PASSWORD_FIELD,
        EDITABLE_COMBO,
        TEXT_AREA;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextInputControlBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.FXVK;

import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.skin.TextInputControlSkin;
import javafx.application.ConditionalFeature;
import javafx.beans.InvalidationListener;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.IndexRange;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PasswordField;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextInputControl;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.Clipboard;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import java.text.Bidi;
import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isLinux;
import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;
import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;
import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public abstract class TextInputControlBehavior&lt;T extends TextInputControl&gt; extends BehaviorBase&lt;T&gt; {

    /**
     * Specifies whether we ought to show handles. We should do it on touch platforms, but not
     * iOS (and maybe not Android either?)
     */
    static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED &amp;&amp; !PlatformUtil.isIOS();

    public static final String DISABLE_FORWARD_TO_PARENT = &quot;TextInputControlBehavior.disableForwardToParent&quot;;

    /**************************************************************************
     * Fields                                                                 *
     *************************************************************************/

    final T textInputControl;

    protected ContextMenu contextMenu;

    private InvalidationListener textListener = observable -&gt; invalidateBidi();

    private final InputMap&lt;T&gt; inputMap;




    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TextInputControlBehavior(T c) {
        super(c);

        this.textInputControl = c;

        textInputControl.textProperty().addListener(textListener);

        // create a map for text input-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();
        final Predicate&lt;KeyEvent&gt; validOnWindows = e -&gt; !PlatformUtil.isWindows();
        final Predicate&lt;KeyEvent&gt; validOnLinux = e -&gt; !PlatformUtil.isLinux();

        KeyMapping cancelEditMapping;
        KeyMapping consumeMostPressedEventsMapping;

        // create a child input map for mappings which are applicable on all
        // platforms, and regardless of editing state
        addDefaultMapping(inputMap,
                // caret movement
                keyMapping(RIGHT, e -&gt; nextCharacterVisually(true)),
                keyMapping(LEFT, e -&gt; nextCharacterVisually(false)),
                keyMapping(UP, e -&gt; c.home()),
                keyMapping(HOME, e -&gt; c.home()),
                keyMapping(DOWN, e -&gt; c.end()),
                keyMapping(END, e -&gt; c.end()),
                keyMapping(ENTER, this::fire),

                keyMapping(new KeyBinding(HOME).shortcut(), e -&gt; c.home()),
                keyMapping(new KeyBinding(END).shortcut(), e -&gt; c.end()),

                // deletion (only applies when control is editable)
                keyMapping(new KeyBinding(BACK_SPACE), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(DELETE), e -&gt; deleteNextChar(), validWhenEditable),

                // cut (only applies when control is editable)
                keyMapping(new KeyBinding(X).shortcut(), e -&gt; cut(), validWhenEditable),
                keyMapping(new KeyBinding(CUT), e -&gt; cut(), validWhenEditable),

                // copy
                keyMapping(new KeyBinding(C).shortcut(), e -&gt; c.copy()),
                keyMapping(new KeyBinding(INSERT).shortcut(), e -&gt; c.copy()),
                keyMapping(COPY, e -&gt; c.copy()),

                // paste (only applies when control is editable)
                keyMapping(new KeyBinding(V).shortcut(), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(PASTE), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(INSERT).shift(), e -&gt; paste(), validWhenEditable),

                // selection
                keyMapping(new KeyBinding(RIGHT).shift(), e -&gt; selectRight()),
                keyMapping(new KeyBinding(LEFT).shift(), e -&gt; selectLeft()),
                keyMapping(new KeyBinding(UP).shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(DOWN).shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(A).shortcut(), e -&gt; c.selectAll()),

                // Traversal Bindings
                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),

                // The following keys are forwarded to the parent container
                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                keyMapping(new KeyBinding(Z).shortcut(), e -&gt; undo()),

                // character input.
                // Any other key press first goes to normal text input
                // Note this is KEY_TYPED because otherwise the character is not available in the event.
                keyMapping(new KeyBinding(null, KEY_TYPED)
                                    .alt(OptionalBoolean.ANY)
                                    .shift(OptionalBoolean.ANY)
                                    .ctrl(OptionalBoolean.ANY)
                                    .meta(OptionalBoolean.ANY),
                           this::defaultKeyTyped),

                // However, we want to consume other key press / release events too, for
                // things that would have been handled by the InputCharacter normally
                consumeMostPressedEventsMapping =
                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),
                               e -&gt; { if (!e.getCode().isFunctionKey()) e.consume(); }),

                // VK
                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -&gt; {
                    FXVK.toggleUseVK(textInputControl);
                }, p -&gt; !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),

                // mouse and context menu mappings
                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),
                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
                new InputMap.Mapping&lt;ContextMenuEvent&gt;(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {
                    @Override public int getSpecificity(Event event) {
                        return 1;
                    }
                }
        );

        cancelEditMapping.setAutoConsume(false);
        consumeMostPressedEventsMapping.setAutoConsume(false);

        // mac os specific mappings
        InputMap&lt;T&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEndExtend()),
            keyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; c.home()),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; c.end()),
            keyMapping(new KeyBinding(LEFT).alt(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).alt(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(DELETE).alt(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -&gt; deleteFromLineStart()),
            keyMapping(new KeyBinding(Z).shortcut().shift(), e -&gt; redo()),
            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; selectEndExtend()),

            // Mac OS specific selection mappings
            keyMapping(new KeyBinding(LEFT).shift().alt(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;T&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHome()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEnd()),
            keyMapping(new KeyBinding(LEFT).ctrl(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(H).ctrl(), e -&gt; deletePreviousChar()),
            keyMapping(new KeyBinding(DELETE).ctrl(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -&gt; c.deselect()),
            keyMapping(new KeyBinding(Y).ctrl(), e -&gt; redo(), validOnWindows),
            keyMapping(new KeyBinding(Z).ctrl().shift(), e -&gt; redo(), validOnLinux),
            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, nonMacOsInputMap);

        addKeyPadMappings(inputMap);

        textInputControl.textProperty().addListener(textListener);

        contextMenu = new ContextMenu();
}

    @Override public InputMap&lt;T&gt; getInputMap() {
        return inputMap;
    }

    /**
     * Bind keypad arrow keys to the same as the regular arrow keys.
     */
    protected void addKeyPadMappings(InputMap&lt;T&gt; map) {
        // First create a temporary map for the keypad mappings
        InputMap&lt;T&gt; tmpMap = new InputMap&lt;&gt;(getNode());
        for (Object o : map.getMappings()) {
            if (o instanceof KeyMapping) {
                KeyMapping mapping = (KeyMapping)o;
                KeyBinding kb = (KeyBinding)mapping.getMappingKey();
                if (kb.getCode() != null) {
                    KeyCode newCode = null;
                    switch (kb.getCode()) {
                        case LEFT:  newCode = KP_LEFT;  break;
                        case RIGHT: newCode = KP_RIGHT; break;
                        case UP:    newCode = KP_UP;    break;
                        case DOWN:  newCode = KP_DOWN;  break;
                        default:
                    }
                    if (newCode != null) {
                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())
                                                                  .ctrl(kb.getCtrl())
                                                                  .alt(kb.getAlt())
                                                                  .meta(kb.getMeta());
                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));
                    }
                }
            }
        }
        // Install mappings
        for (Object o : tmpMap.getMappings()) {
            map.getMappings().add((KeyMapping)o);
        }

        // Recursive call for child maps
        for (Object o : map.getChildInputMaps()) {
            addKeyPadMappings((InputMap&lt;T&gt;)o);
        }
    }


    /**
     * Wraps the event handler to pause caret blinking when
     * processing the key event.
     */
    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(new KeyBinding(keyCode), eventHandler);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(keyBinding, eventHandler, null);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler,
                                    Predicate&lt;KeyEvent&gt; interceptor) {
        return new KeyMapping(keyBinding,
                              e -&gt; {
                                  setCaretAnimating(false);
                                  eventHandler.handle(e);
                                  setCaretAnimating(true);
                              },
                              interceptor);
    }





    /**************************************************************************
     * Disposal methods                                                       *
     *************************************************************************/

    @Override public void dispose() {
        textInputControl.textProperty().removeListener(textListener);
        super.dispose();
    }

    /**************************************************************************
     * Abstract methods                                                       *
     *************************************************************************/

    protected abstract void deleteChar(boolean previous);
    protected abstract void replaceText(int start, int end, String txt);
    protected abstract void setCaretAnimating(boolean play);
    protected abstract void deleteFromLineStart();

    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void contextMenuRequested(ContextMenuEvent e);

    /**************************************************************************
     * Key handling implementation                                            *
     *************************************************************************/

    /**
     * The default handler for a key typed event, which is called when none of
     * the other key bindings match. This is the method which handles basic
     * text entry.
     * @param event not null
     */
    private void defaultKeyTyped(KeyEvent event) {
        final TextInputControl textInput = getNode();
        // I'm not sure this case can actually ever happen, maybe this
        // should be an assert instead?
        if (!textInput.isEditable() || textInput.isDisabled()) return;

        // Sometimes we get events with no key character, in which case
        // we need to bail.
        String character = event.getCharacter();
        if (character.length() == 0) return;

        // Filter out control keys except control+Alt on PC or Alt on Mac
        if (event.isControlDown() || event.isAltDown() || (isMac() &amp;&amp; event.isMetaDown())) {
            if (!((event.isControlDown() || isMac()) &amp;&amp; event.isAltDown())) return;
        }

        setEditing(true);

        // Ignore characters in the control range and the ASCII delete
        // character as well as meta key presses
        if (character.charAt(0) &gt; 0x1F
                &amp;&amp; character.charAt(0) != 0x7F
                &amp;&amp; !event.isMetaDown()) { // Not sure about this one
            final IndexRange selection = textInput.getSelection();
            final int start = selection.getStart();
            final int end = selection.getEnd();

            replaceText(start, end, character);
        }

        setEditing(false);
    }

    private Bidi bidi = null;
    private Boolean mixed = null;
    private Boolean rtlText = null;

    private void invalidateBidi() {
        bidi = null;
        mixed = null;
        rtlText = null;
    }

    private Bidi getBidi() {
        if (bidi == null) {
            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),
                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)
                            ? Bidi.DIRECTION_RIGHT_TO_LEFT
                            : Bidi.DIRECTION_LEFT_TO_RIGHT);
        }
        return bidi;
    }

    protected boolean isMixed() {
        if (mixed == null) {
            mixed = getBidi().isMixed();
        }
        return mixed;
    }

    protected boolean isRTLText() {
        if (rtlText == null) {
            Bidi bidi = getBidi();
            rtlText =
                    (bidi.isRightToLeft() ||
                            (isMixed() &amp;&amp;
                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));
        }
        return rtlText;
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isMixed()) {
            TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;)textInputControl.getSkin();
            skin.moveCaret(TextUnit.CHARACTER, moveRight ? Direction.RIGHT : Direction.LEFT, false);
        } else if (moveRight != isRTLText()) {
            textInputControl.forward();
        } else {
            textInputControl.backward();
        }
    }

    private void selectLeft() {
        if (isRTLText()) {
            textInputControl.selectForward();
        } else {
            textInputControl.selectBackward();
        }
    }

    private void selectRight() {
        if (isRTLText()) {
            textInputControl.selectBackward();
        } else {
            textInputControl.selectForward();
        }
    }

    private void deletePreviousChar() {
        setEditing(true);
        deleteChar(true);
        setEditing(false);
    }

    private void deleteNextChar() {
        setEditing(true);
        deleteChar(false);
        setEditing(false);
    }

    protected void deletePreviousWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
<A NAME="44"></A>        int end = textInputControl.getCaretPosition();

        if (end &gt; 0) {
            <FONT color="#e57ded"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#44',2,'match42-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>textInputControl.previousWord();
            int start = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    protected void</B></FONT> deleteNextWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int start = textInputControl.getCaretPosition();

        if (start &lt; textInputControl.getLength()) {
            nextWord();
            int end = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    public void deleteSelection() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        IndexRange selection = textInputControl.getSelection();

        if (selection.getLength() &gt; 0) {
            deleteChar(false);
        }
        setEditing(false);
    }

    public void cut() {
        setEditing(true);
        getNode().cut();
        setEditing(false);
    }

    public void paste() {
        setEditing(true);
        getNode().paste();
        setEditing(false);
    }

    public void undo() {
        setEditing(true);
        getNode().undo();
        setEditing(false);
    }

    public void redo() {
        setEditing(true);
        getNode().redo();
        setEditing(false);
    }

    protected void selectPreviousWord() {
        getNode().selectPreviousWord();
    }

    public void selectNextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.selectEndOfNextWord();
        } else {
            textInputControl.selectNextWord();
        }
    }

    private void selectLeftWord() {
        if (isRTLText()) {
            selectNextWord();
        } else {
            selectPreviousWord();
        }
    }

    private void selectRightWord() {
        if (isRTLText()) {
            selectPreviousWord();
        } else {
            selectNextWord();
        }
    }

    protected void selectWord() {
        final TextInputControl textInputControl = getNode();
        textInputControl.previousWord();
        if (isWindows()) {
            textInputControl.selectNextWord();
        } else {
            textInputControl.selectEndOfNextWord();
        }
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void selectAll() {
        getNode().selectAll();
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void previousWord() {
        getNode().previousWord();
    }

    protected void nextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.endOfNextWord();
        } else {
            textInputControl.nextWord();
        }
    }

    private void leftWord() {
        if (isRTLText()) {
            nextWord();
        } else {
            previousWord();
        }
    }

    private void rightWord() {
        if (isRTLText()) {
            previousWord();
        } else {
            nextWord();
        }
    }

    protected void fire(KeyEvent event) { } // TODO move to TextFieldBehavior
    protected void cancelEdit(KeyEvent event) { forwardToParent(event);} // not autoconsumed

    protected void forwardToParent(KeyEvent event) {
        // fix for JDK-8145515
        if (getNode().getProperties().containsKey(DISABLE_FORWARD_TO_PARENT)) {
            return;
        }

        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }

    protected void selectHome() {
        getNode().selectHome();
    }

    protected void selectEnd() {
        getNode().selectEnd();
    }

    protected void selectHomeExtend() {
        getNode().extendSelection(0);
    }

    protected void selectEndExtend() {
        TextInputControl textInputControl = getNode();
        textInputControl.extendSelection(textInputControl.getLength());
    }

    private boolean editing = false;
    protected void setEditing(boolean b) {
        editing = b;
    }
    public boolean isEditing() {
        return editing;
    }

    protected void populateContextMenu() {
        TextInputControl textInputControl = getNode();
        boolean editable = textInputControl.isEditable();
        boolean hasText = (textInputControl.getLength() &gt; 0);
        boolean hasSelection = (textInputControl.getSelection().getLength() &gt; 0);
        boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength());
        boolean maskText = (textInputControl instanceof PasswordField); // (maskText(&quot;A&quot;) != &quot;A&quot;);
        ObservableList&lt;MenuItem&gt; items = contextMenu.getItems();

        if (SHOW_HANDLES) {
            items.clear();
            if (!maskText &amp;&amp; hasSelection) {
                if (editable) {
                    items.add(cutMI);
                }
                items.add(copyMI);
            }
            if (editable &amp;&amp; Clipboard.getSystemClipboard().hasString()) {
                items.add(pasteMI);
            }
            if (hasText &amp;&amp; !allSelected) {
                if (!hasSelection &amp;&amp; !(textInputControl instanceof PasswordField)) {
                    items.add(selectWordMI);
                }
                items.add(selectAllMI);
            }
            selectWordMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
            selectAllMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
        } else {
            if (editable) {
                items.setAll(undoMI, redoMI, cutMI, copyMI, pasteMI, deleteMI,
                        separatorMI, selectAllMI);
            } else {
                items.setAll(copyMI, separatorMI, selectAllMI);
            }
            undoMI.setDisable(!getNode().isUndoable());
            redoMI.setDisable(!getNode().isRedoable());
            cutMI.setDisable(maskText || !hasSelection);
            copyMI.setDisable(maskText || !hasSelection);
            pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString());
            deleteMI.setDisable(!hasSelection);
        }
    }

    private static class ContextMenuItem extends MenuItem {
        ContextMenuItem(final String action, EventHandler&lt;ActionEvent&gt; onAction) {
            super(getString(&quot;TextInputControl.menu.&quot; + action));
            setOnAction(onAction);
        }
    }

    private final MenuItem undoMI   = new ContextMenuItem(&quot;Undo&quot;, e -&gt; undo());
    private final MenuItem redoMI   = new ContextMenuItem(&quot;Redo&quot;, e -&gt; redo());
    private final MenuItem cutMI    = new ContextMenuItem(&quot;Cut&quot;, e -&gt; cut());
    private final MenuItem copyMI   = new ContextMenuItem(&quot;Copy&quot;, e -&gt; getNode().copy());
    private final MenuItem pasteMI  = new ContextMenuItem(&quot;Paste&quot;, e -&gt; paste());
    private final MenuItem deleteMI = new ContextMenuItem(&quot;DeleteSelection&quot;, e -&gt; deleteSelection());
    private final MenuItem selectWordMI = new ContextMenuItem(&quot;SelectWord&quot;, e -&gt; selectWord());
    private final MenuItem selectAllMI = new ContextMenuItem(&quot;SelectAll&quot;, e -&gt; selectAll());
    private final MenuItem separatorMI = new SeparatorMenuItem();

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TreeTableViewBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import static javafx.scene.input.KeyCode.*;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.control.TableColumnBase;
import javafx.scene.control.TableFocusModel;
import javafx.scene.control.TablePositionBase;
import javafx.scene.control.TableSelectionModel;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeTableColumn;
import javafx.scene.control.TreeTablePosition;
import javafx.scene.control.TreeTableView;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.util.Callback;

public class TreeTableViewBehavior&lt;T&gt; extends TableViewBehaviorBase&lt;TreeTableView&lt;T&gt;, TreeItem&lt;T&gt;, TreeTableColumn&lt;T, ?&gt;&gt; {

    /**************************************************************************
     *                                                                        *
     * Listeners                                                              *
     *                                                                        *
     *************************************************************************/

    private final ChangeListener&lt;TreeTableView.TreeTableViewSelectionModel&lt;T&gt;&gt; selectionModelListener =
            (observable, oldValue, newValue) -&gt; {
                if (oldValue != null) {
                    oldValue.getSelectedCells().removeListener(weakSelectedCellsListener);
                }
                if (newValue != null) {
                    newValue.getSelectedCells().addListener(weakSelectedCellsListener);
                }
            };

    private final WeakChangeListener&lt;TreeTableView.TreeTableViewSelectionModel&lt;T&gt;&gt; weakSelectionModelListener =
            new WeakChangeListener&lt;&gt;(selectionModelListener);



    /**************************************************************************
     *                                                                        *
     * Constructors                                                           *
     *                                                                        *
     *************************************************************************/

    public TreeTableViewBehavior(TreeTableView&lt;T&gt;  control) {
        super(control);

        // Add these bindings as a child input map, so they take precedence
        InputMap&lt;TreeTableView&lt;T&gt;&gt; expandCollapseInputMap = new InputMap&lt;&gt;(control);
        expandCollapseInputMap.getMappings().addAll(
            // these should be read as 'if RTL, use the first method, otherwise use the second'
            new InputMap.KeyMapping(LEFT, e -&gt; rtl(control, this::expandRow, this::collapseRow)),
            new InputMap.KeyMapping(KP_LEFT, e -&gt; rtl(control, this::expandRow, this::collapseRow)),
            new InputMap.KeyMapping(RIGHT, e -&gt; rtl(control, this::collapseRow, this::expandRow)),
            new InputMap.KeyMapping(KP_RIGHT, e -&gt; rtl(control, this::collapseRow, this::expandRow)),

            new InputMap.KeyMapping(MULTIPLY, e -&gt; expandAll()),
            new InputMap.KeyMapping(ADD, e -&gt; expandRow()),
            new InputMap.KeyMapping(SUBTRACT, e -&gt; collapseRow())
        );
        addDefaultChildMap(getInputMap(), expandCollapseInputMap);


        // Fix for RT-16565
        control.selectionModelProperty().addListener(weakSelectionModelListener);
        if (getSelectionModel() != null) {
            control.getSelectionModel().getSelectedCells().addListener(selectedCellsListener);
        }
    }



    /**************************************************************************
     *                                                                        *
     * Implement TableViewBehaviorBase abstract methods                       *
     *                                                                        *
     *************************************************************************/

    /** {@inheritDoc}  */
    @Override protected int getItemCount() {
        return getNode().getExpandedItemCount();
    }

    /** {@inheritDoc}  */
    @Override protected TableFocusModel getFocusModel() {
        return getNode().getFocusModel();
    }

    /** {@inheritDoc}  */
    @Override protected TableSelectionModel&lt;TreeItem&lt;T&gt;&gt; getSelectionModel() {
        return getNode().getSelectionModel();
    }

    /** {@inheritDoc}  */
    @Override protected ObservableList&lt;TreeTablePosition&lt;T,?&gt;&gt; getSelectedCells() {
        return getNode().getSelectionModel().getSelectedCells();
    }

    /** {@inheritDoc}  */
    @Override protected TablePositionBase getFocusedCell() {
        return getNode().getFocusModel().getFocusedCell();
    }

    /** {@inheritDoc}  */
    @Override protected int getVisibleLeafIndex(TableColumnBase tc) {
        return getNode().getVisibleLeafIndex((TreeTableColumn)tc);
    }

    /** {@inheritDoc}  */
    @Override protected TreeTableColumn getVisibleLeafColumn(int index) {
        return getNode().getVisibleLeafColumn(index);
    }

    /** {@inheritDoc} */
    @Override protected boolean isControlEditable() {
        return getNode().isEditable();
    }

    /** {@inheritDoc}  */
    @Override protected void editCell(int row, TableColumnBase tc) {
        getNode().edit(row, (TreeTableColumn)tc);
    }

    /** {@inheritDoc}  */
    @Override protected ObservableList&lt;TreeTableColumn&lt;T,?&gt;&gt; getVisibleLeafColumns() {
        return getNode().getVisibleLeafColumns();
    }

    /** {@inheritDoc}  */
    @Override protected TablePositionBase&lt;TreeTableColumn&lt;T, ?&gt;&gt;
            getTablePosition(int row, TableColumnBase&lt;TreeItem&lt;T&gt;, ?&gt; tc) {
        return new TreeTablePosition(getNode(), row, (TreeTableColumn)tc);
    }



    /**************************************************************************
     *                                                                        *
     * Modify TableViewBehaviorBase behavior                                  *
     *                                                                        *
     *************************************************************************/

    /** {@inheritDoc} */
    @Override protected void selectAllToFocus(boolean setAnchorToFocusIndex) {
        // Fix for RT-31241
        if (getNode().getEditingCell() != null) return;

        super.selectAllToFocus(setAnchorToFocusIndex);
    }

    /**************************************************************************
     *                                                                        *
     * Tree-related implementation                                            *
     *                                                                        *
     *************************************************************************/

    /**
     * The next methods handle the left/right arrow input differently depending
     * on whether we are in row or cell selection.
     */
    private void rightArrowPressed() {
        if (getNode().getSelectionModel().isCellSelectionEnabled()) {
            if (isRTL()) {
                selectLeftCell();
            } else {
                selectRightCell();
            }
        } else {
            expandRow();
        }
    }

    private void leftArrowPressed() {
        if (getNode().getSelectionModel().isCellSelectionEnabled()) {
            if (isRTL()) {
                selectRightCell();
            } else {
                selectLeftCell();
            }
        } else {
            collapseRow();
        }
    }

    private void expandRow() {
        Callback&lt;TreeItem&lt;T&gt;, Integer&gt; getIndex = p -&gt; getNode().getRow(p);
        TreeViewBehavior.expandRow(getNode().getSelectionModel(), getIndex);
    }

    private void expandAll() {
        TreeViewBehavior.expandAll(getNode().getRoot());
<A NAME="86"></A>    }

    private void collapseRow() {
        <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#86',2,'match42-top.html#86',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TreeTableView&lt;T&gt; control = getNode();
        TreeViewBehavior.collapseRow(control.getSelectionModel(), control.getRoot(), control.isShowRoot());
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/inputmap/KeyBinding.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.inputmap;

import com.sun.javafx.util.Utils;
import com.sun.javafx.tk.Toolkit;
import javafx.event.EventType;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

import java.util.Objects;

import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean.*;

/**
 * KeyBindings are used to describe which action should occur based on some
 * KeyEvent state and Control state. These bindings are used to populate the
 * keyBindings variable on BehaviorBase. The KeyBinding can be subclassed to
 * add additional matching criteria. A match in a subclass should always have
 * a specificity that is 1 greater than its superclass in the case of a match,
 * or 0 in the case where there is no match.
 *
 * Note that this API is, at present, quite odd in that you use a constructor
 * and then use shift(), ctrl(), alt(), or meta() separately. It gave me an
 * object-literal like approach but isn't ideal. We will want some builder
 * approach here (similar as in other places).
 *
 * @since 9
 */
public class KeyBinding {
    private final KeyCode code;
    private final EventType&lt;KeyEvent&gt; eventType;
    private OptionalBoolean shift = FALSE;
    private OptionalBoolean ctrl = FALSE;
    private OptionalBoolean alt = FALSE;
    private OptionalBoolean meta = FALSE;

    public KeyBinding(KeyCode code) {
        this(code, null);
    }

    /**
     * Designed for 'catch-all' situations, e.g. all KeyTyped events.
     * @param type
     */
    public KeyBinding(EventType&lt;KeyEvent&gt; type) {
        this(null, type);
    }

    public KeyBinding(KeyCode code, EventType&lt;KeyEvent&gt; type) {
        this.code = code;
        this.eventType = type != null ? type : KeyEvent.KEY_PRESSED;
    }

    public final KeyBinding shift() {
        return shift(TRUE);
    }

    public final KeyBinding shift(OptionalBoolean value) {
        shift = value;
        return this;
    }

    public final KeyBinding ctrl() {
        return ctrl(TRUE);
    }

    public final KeyBinding ctrl(OptionalBoolean value) {
        ctrl = value;
        return this;
    }

    public final KeyBinding alt() {
        return alt(TRUE);
    }

    public final KeyBinding alt(OptionalBoolean value) {
        alt = value;
        return this;
    }

    public final KeyBinding meta() {
        return meta(TRUE);
    }

    public final KeyBinding meta(OptionalBoolean value) {
        meta = value;
        return this;
    }

    public final KeyBinding shortcut() {
        if (Toolkit.getToolkit().getClass().getName().endsWith(&quot;StubToolkit&quot;)) {
            // FIXME: We've hit the terrible StubToolkit (which only appears
            // during testing). We will dumb down what we do here
            if (Utils.isMac()) {
                return meta();
            } else {
                return ctrl();
            }
        } else {
            switch (Toolkit.getToolkit().getPlatformShortcutKey()) {
                case SHIFT:
                    return shift();

                case CONTROL:
                    return ctrl();

                case ALT:
                    return alt();

                case META:
                    return meta();

                default:
                    return this;
            }
        }
    }



    public final KeyCode getCode() { return code; }
    public final EventType&lt;KeyEvent&gt; getType() { return eventType; }
    public final OptionalBoolean getShift() { return shift; }
    public final OptionalBoolean getCtrl() { return ctrl; }
    public final OptionalBoolean getAlt() { return alt; }
    public final OptionalBoolean getMeta() { return meta; }

    public int getSpecificity(KeyEvent event) {
        int s = 0;
        if (code != null &amp;&amp; code != event.getCode()) return 0; else s = 1;
        if (!shift.equals(event.isShiftDown())) return 0; else if (shift != ANY) s++;
        if (!ctrl.equals(event.isControlDown())) return 0; else if (ctrl != ANY) s++;
        if (!alt.equals(event.isAltDown())) return 0; else if (alt != ANY) s++;
        if (!meta.equals(event.isMetaDown())) return 0; else if (meta != ANY) s++;
        if (eventType != null &amp;&amp; eventType != event.getEventType()) return 0; else s++;
        // We can now trivially accept it
        return s;
    }

    /** {@inheritDoc} */
    @Override public String toString() {
        return &quot;KeyBinding [code=&quot; + code + &quot;, shift=&quot; + shift +
                &quot;, ctrl=&quot; + ctrl + &quot;, alt=&quot; + alt +
                &quot;, meta=&quot; + meta + &quot;, type=&quot; + eventType + &quot;]&quot;;
    }

    /** {@inheritDoc} */
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof KeyBinding)) return false;
        KeyBinding that = (KeyBinding) o;
        return Objects.equals(getCode(), that.getCode()) &amp;&amp;
                Objects.equals(eventType, that.eventType) &amp;&amp;
                Objects.equals(getShift(), that.getShift()) &amp;&amp;
                Objects.equals(getCtrl(), that.getCtrl()) &amp;&amp;
                Objects.equals(getAlt(), that.getAlt()) &amp;&amp;
                Objects.equals(getMeta(), that.getMeta());
    }
<A NAME="38"></A>
    /** {@inheritDoc} */
    @Override public int hashCode() {
        return Objects.hash(getCode(), eventType, <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#38',2,'match42-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getShift(), getCtrl(), getAlt(), getMeta());
    }

    public static KeyBinding toKeyBinding(KeyEvent keyEvent) {
        KeyBinding newKeyBinding = new</B></FONT> KeyBinding(keyEvent.getCode(), keyEvent.getEventType());
        if (keyEvent.isShiftDown()) newKeyBinding.shift();
        if (keyEvent.isControlDown()) newKeyBinding.ctrl();
        if (keyEvent.isAltDown()) newKeyBinding.alt();
        if (keyEvent.isShortcutDown()) newKeyBinding.shortcut();
        return newKeyBinding;
    }

    /**
     * A tri-state boolean used with KeyBinding.
     */
    public enum OptionalBoolean {
        TRUE,
        FALSE,
        ANY;

        public boolean equals(boolean b) {
            if (this == ANY) return true;
            if (b &amp;&amp; this == TRUE) return true;
            if (!b &amp;&amp; this == FALSE) return true;
            return false;
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/Chart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.scene.control.skin.Utils;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.ObservableList;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;

import com.sun.javafx.charts.ChartLayoutAnimator;
import com.sun.javafx.charts.Legend;
import com.sun.javafx.scene.NodeHelper;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Base class for all charts. It has 3 parts the title, legend and chartContent. The chart content is populated by the
 * specific subclass of Chart.
 *
 * @since JavaFX 2.0
 */
public abstract class Chart extends Region {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------

    private static final int MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT = 200;
    private static final int MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT = 150;

    /** Title Label */
    private final Label titleLabel = new Label();
    /**
     * This is the Pane that Chart subclasses use to contain the chart content,
     * It is sized to be inside the chart area leaving space for the title and legend.
     */
    private final Pane chartContent = new Pane() {
        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double left = snappedLeftInset();
            final double bottom = snappedBottomInset();
            final double right = snappedRightInset();
            final double width = getWidth();
            final double height = getHeight();
            final double contentWidth = snapSizeX(width - (left + right));
            final double contentHeight = snapSizeY(height - (top + bottom));
            layoutChartChildren(snapPositionY(top), snapPositionX(left), contentWidth, contentHeight);
        }
        @Override public boolean usesMirroring() {
            return useChartContentMirroring;
        }
    };
    // Determines if chart content should be mirrored if node orientation is right-to-left.
    boolean useChartContentMirroring = true;

    /** Animator for animating stuff on the chart */
    private final ChartLayoutAnimator animator = new ChartLayoutAnimator(chartContent);

    // -------------- PUBLIC PROPERTIES --------------------------------------------------------------------------------

    /** The chart title */
    private StringProperty title = new StringPropertyBase() {
        @Override protected void invalidated() {
            titleLabel.setText(get());
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;title&quot;;
        }
    };
    public final String getTitle() { return title.get(); }
    public final void setTitle(String value) { title.set(value); }
    public final StringProperty titleProperty() { return title; }

    /**
     * The side of the chart where the title is displayed
     * @defaultValue Side.TOP
     */
    private ObjectProperty&lt;Side&gt; titleSide = new StyleableObjectProperty&lt;Side&gt;(Side.TOP) {
        @Override protected void invalidated() {
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Side&gt; getCssMetaData() {
            return StyleableProperties.TITLE_SIDE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;titleSide&quot;;
        }
    };
    public final Side getTitleSide() { return titleSide.get(); }
    public final void setTitleSide(Side value) { titleSide.set(value); }
    public final ObjectProperty&lt;Side&gt; titleSideProperty() { return titleSide; }

    /**
     * The node to display as the Legend. Subclasses can set a node here to be displayed on a side as the legend. If
     * no legend is wanted then this can be set to null
     */
    private final ObjectProperty&lt;Node&gt; legend = new ObjectPropertyBase&lt;Node&gt;() {
        private Node old = null;
        @Override protected void invalidated() {
            Node newLegend = get();
            if (old != null) getChildren().remove(old);
            if (newLegend != null) {
                getChildren().add(newLegend);
                newLegend.setVisible(isLegendVisible());
            }
            old = newLegend;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legend&quot;;
        }
    };
    protected final Node getLegend() { return legend.getValue(); }
    protected final void setLegend(Node value) { legend.setValue(value); }
    protected final ObjectProperty&lt;Node&gt; legendProperty() { return legend; }

    /**
     * When true the chart will display a legend if the chart implementation supports a legend.
     */
    private final BooleanProperty legendVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LEGEND_VISIBLE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legendVisible&quot;;
        }
    };
    public final boolean isLegendVisible() { return legendVisible.getValue(); }
    public final void setLegendVisible(boolean value) { legendVisible.setValue(value); }
    public final BooleanProperty legendVisibleProperty() { return legendVisible; }

    /**
     * The side of the chart where the legend should be displayed
     *
     * @defaultValue Side.BOTTOM
     */
    private ObjectProperty&lt;Side&gt; legendSide = new StyleableObjectProperty&lt;Side&gt;(Side.BOTTOM) {
        @Override protected void invalidated() {
            final Side legendSide = get();
            final Node legend = getLegend();
            if(legend instanceof Legend) ((Legend)legend).setVertical(Side.LEFT.equals(legendSide) || Side.RIGHT.equals(legendSide));
            requestLayout();
        }

        @Override
        public CssMetaData&lt;Chart,Side&gt; getCssMetaData() {
            return StyleableProperties.LEGEND_SIDE;
        }

        @Override
        public Object getBean() {
            return Chart.this;
        }

        @Override
        public String getName() {
            return &quot;legendSide&quot;;
        }
    };
    public final Side getLegendSide() { return legendSide.get(); }
    public final void setLegendSide(Side value) { legendSide.set(value); }
    public final ObjectProperty&lt;Side&gt; legendSideProperty() { return legendSide; }

    /** When true any data changes will be animated. */
    private BooleanProperty animated = new SimpleBooleanProperty(this, &quot;animated&quot;, true);

    /**
     * Indicates whether data changes will be animated or not.
     *
     * @return true if data changes will be animated and false otherwise.
     */
    public final boolean getAnimated() { return animated.get(); }
    public final void setAnimated(boolean value) { animated.set(value); }
    public final BooleanProperty animatedProperty() { return animated; }

    // -------------- PROTECTED PROPERTIES -----------------------------------------------------------------------------

    /**
     * Modifiable and observable list of all content in the chart. This is where implementations of Chart should add
     * any nodes they use to draw their chart. This excludes the legend and title which are looked after by this class.
     *
     * @return Observable list of plot children
     */
    protected ObservableList&lt;Node&gt; getChartChildren() {
        return chartContent.getChildren();
    }

    // -------------- CONSTRUCTOR --------------------------------------------------------------------------------------

    /**
     * Creates a new default Chart instance.
     */
    public Chart() {
        titleLabel.setAlignment(Pos.CENTER);
        titleLabel.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
        getChildren().addAll(titleLabel, chartContent);
        getStyleClass().add(&quot;chart&quot;);
        titleLabel.getStyleClass().add(&quot;chart-title&quot;);
        chartContent.getStyleClass().add(&quot;chart-content&quot;);
        // mark chartContent as unmanaged because any changes to its preferred size shouldn't cause a relayout
        chartContent.setManaged(false);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * Play a animation involving the given keyframes. On every frame of the animation the chart will be relayed out
     *
     * @param keyFrames Array of KeyFrames to play
     */
    void animate(KeyFrame...keyFrames) { animator.animate(keyFrames); }

    /**
     * Play the given animation on every frame of the animation the chart will be relayed out until the animation
     * finishes. So to add a animation to a chart, create a animation on data model, during layoutChartContent() map
     * data model to nodes then call this method with the animation.
     *
     * @param animation The animation to play
     */
    protected void animate(Animation animation) { animator.animate(animation); }

    /** Call this when you know something has changed that needs the chart to be relayed out. */
    protected void requestChartLayout() {
        chartContent.requestLayout();
    }

    /**
     * This is used to check if any given animation should run. It returns true if animation is enabled and the node
     * is visible and in a scene.
     * @return true if animation is enabled and the node is visible and in a scene
     */
    protected final boolean shouldAnimate(){
        return getAnimated() &amp;&amp; NodeHelper.isTreeShowing(this);
    }

    /**
     * Called to update and layout the chart children available from getChartChildren()
     *
     * @param top The top offset from the origin to account for any padding on the chart content
     * @param left The left offset from the origin to account for any padding on the chart content
     * @param width The width of the area to layout the chart within
     * @param height The height of the area to layout the chart within
     */
    protected abstract void layoutChartChildren(double top, double left, double width, double height);

    /**
     * Invoked during the layout pass to layout this chart and all its content.
     */
    @Override protected void layoutChildren() {
        double top = snappedTopInset();
        double left = snappedLeftInset();
        double bottom = snappedBottomInset();
        double right = snappedRightInset();
        final double width = getWidth();
        final double height = getHeight();
        // layout title
<A NAME="75"></A>        if (getTitle() != null) {
            titleLabel.setVisible(true);
            if (getTitleSide().equals(Side.TOP)) {
                final double titleHeight = <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#75',2,'match42-top.html#75',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>snapSizeY(titleLabel.prefHeight(width-left-right));
                titleLabel.resizeRelocate(left,top,width-left-right,titleHeight);
                top += titleHeight;
            } else if (getTitleSide().equals(Side.BOTTOM)) {
                final double titleHeight = snapSizeY(titleLabel.prefHeight(width-left-right));
                titleLabel.resizeRelocate</B></FONT>(left,height-bottom-titleHeight,width-left-right,titleHeight);
                bottom += titleHeight;
            } else if (getTitleSide().equals(Side.LEFT)) {
                final double titleWidth = snapSizeX(titleLabel.prefWidth(height-top-bottom));
                titleLabel.resizeRelocate(left,top,titleWidth,height-top-bottom);
                left += titleWidth;
            } else if (getTitleSide().equals(Side.RIGHT)) {
                final double titleWidth = snapSizeX(titleLabel.prefWidth(height-top-bottom));
                titleLabel.resizeRelocate(width-right-titleWidth,top,titleWidth,height-top-bottom);
                right += titleWidth;
            }
        } else {
            titleLabel.setVisible(false);
        }
        // layout legend
        final Node legend = getLegend();
        if (legend != null) {
            boolean shouldShowLegend = isLegendVisible();
            if (shouldShowLegend) {
                if (getLegendSide() == Side.TOP) {
                    final double legendHeight = snapSizeY(legend.prefHeight(width-left-right));
                    final double legendWidth = Utils.boundedSize(snapSizeX(legend.prefWidth(legendHeight)), 0, width - left - right);
                    legend.resizeRelocate(left + (((width - left - right)-legendWidth)/2), top, legendWidth, legendHeight);
                    if ((height - bottom - top - legendHeight) &lt; MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        top += legendHeight;
                    }
                } else if (getLegendSide() == Side.BOTTOM) {
                    final double legendHeight = snapSizeY(legend.prefHeight(width-left-right));
                    final double legendWidth = Utils.boundedSize(snapSizeX(legend.prefWidth(legendHeight)), 0, width - left - right);
                    legend.resizeRelocate(left + (((width - left - right)-legendWidth)/2), height-bottom-legendHeight, legendWidth, legendHeight);
                    if ((height - bottom - top - legendHeight) &lt; MIN_HEIGHT_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        bottom += legendHeight;
                    }
                } else if (getLegendSide() == Side.LEFT) {
                    final double legendWidth = snapSizeX(legend.prefWidth(height-top-bottom));
                    final double legendHeight = Utils.boundedSize(snapSizeY(legend.prefHeight(legendWidth)), 0, height - top - bottom);
                    legend.resizeRelocate(left,top +(((height-top-bottom)-legendHeight)/2),legendWidth,legendHeight);
                    if ((width - left - right - legendWidth) &lt; MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        left += legendWidth;
                    }
                } else if (getLegendSide() == Side.RIGHT) {
                    final double legendWidth = snapSizeX(legend.prefWidth(height-top-bottom));
                    final double legendHeight = Utils.boundedSize(snapSizeY(legend.prefHeight(legendWidth)), 0, height - top - bottom);
                    legend.resizeRelocate(width-right-legendWidth,top +(((height-top-bottom)-legendHeight)/2),legendWidth,legendHeight);
                    if ((width - left - right - legendWidth) &lt; MIN_WIDTH_TO_LEAVE_FOR_CHART_CONTENT) {
                        shouldShowLegend = false;
                    } else {
                        right += legendWidth;
                    }
                }
            }
            legend.setVisible(shouldShowLegend);
        }
        // whats left is for the chart content
        chartContent.resizeRelocate(left,top,width-left-right,height-top-bottom);
    }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So minimum
     * height is a constant 150.
     */
    @Override protected double computeMinHeight(double width) { return 150; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So minimum
     * width is a constant 200.
     */
    @Override protected double computeMinWidth(double height) { return 200; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So preferred
     * width is a constant 500.
     */
    @Override protected double computePrefWidth(double height) { return 500.0; }

    /**
     * Charts are sized outside in, user tells chart how much space it has and chart draws inside that. So preferred
     * height is a constant 400.
     */
    @Override protected double computePrefHeight(double width) { return 400.0; }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;Chart,Side&gt; TITLE_SIDE =
            new CssMetaData&lt;Chart,Side&gt;(&quot;-fx-title-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class),
                Side.TOP) {

            @Override
            public boolean isSettable(Chart node) {
                return node.titleSide == null || !node.titleSide.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)node.titleSideProperty();
            }
        };

        private static final CssMetaData&lt;Chart,Side&gt; LEGEND_SIDE =
            new CssMetaData&lt;Chart,Side&gt;(&quot;-fx-legend-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class),
                Side.BOTTOM) {

            @Override
            public boolean isSettable(Chart node) {
                return node.legendSide == null || !node.legendSide.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)node.legendSideProperty();
            }
        };

        private static final CssMetaData&lt;Chart,Boolean&gt; LEGEND_VISIBLE =
            new CssMetaData&lt;Chart,Boolean&gt;(&quot;-fx-legend-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Chart node) {
                return node.legendVisible == null || !node.legendVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Chart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.legendVisibleProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(TITLE_SIDE);
            styleables.add(LEGEND_VISIBLE);
            styleables.add(LEGEND_SIDE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/LineChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Animation;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.StrokeLineJoin;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;

import javafx.css.StyleableBooleanProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;

import java.util.*;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Line Chart plots a line connecting the data points in a series. The data points
 * themselves can be represented by symbols optionally. Line charts are usually used
 * to view data trends over time or category.
 * @since JavaFX 2.0
 */
public class LineChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- PRIVATE FIELDS ------------------------------------------

    /** A multiplier for the Y values that we store for each series, it is used to animate in a new series */
    private Map&lt;Series&lt;X,Y&gt;, DoubleProperty&gt; seriesYMultiplierMap = new HashMap&lt;&gt;();
    private Timeline dataRemoveTimeline;
    private Series&lt;X,Y&gt; seriesOfDataRemoved = null;
    private Data&lt;X,Y&gt; dataItemBeingRemoved = null;
    private FadeTransition fadeSymbolTransition = null;
    private Map&lt;Data&lt;X,Y&gt;, Double&gt; XYValueMap =
                                new HashMap&lt;Data&lt;X,Y&gt;, Double&gt;();
    private Timeline seriesRemoveTimeline = null;
    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** When true, CSS styleable symbols are created for any data items that don't have a symbol node specified. */
    private BooleanProperty createSymbols = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            for (int seriesIndex=0; seriesIndex &lt; getData().size(); seriesIndex ++) {
                Series&lt;X,Y&gt; series = getData().get(seriesIndex);
                for (int itemIndex=0; itemIndex &lt; series.getData().size(); itemIndex ++) {
                    Data&lt;X,Y&gt; item = series.getData().get(itemIndex);
                    Node symbol = item.getNode();
                    if(get() &amp;&amp; symbol == null) { // create any symbols
                        symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
                        getPlotChildren().add(symbol);
                    } else if (!get() &amp;&amp; symbol != null) { // remove symbols
                        getPlotChildren().remove(symbol);
                        symbol = null;
                        item.setNode(null);
                    }
                }
            }
            requestChartLayout();
        }

        public Object getBean() {
            return LineChart.this;
        }

        public String getName() {
            return &quot;createSymbols&quot;;
        }

        public CssMetaData&lt;LineChart&lt;?,?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CREATE_SYMBOLS;
        }
    };

    /**
     * Indicates whether symbols for data points will be created or not.
     *
     * @return true if symbols for data points will be created and false otherwise.
     */
    public final boolean getCreateSymbols() { return createSymbols.getValue(); }
    public final void setCreateSymbols(boolean value) { createSymbols.setValue(value); }
    public final BooleanProperty createSymbolsProperty() { return createSymbols; }


    /**
     * Indicates whether the data passed to LineChart should be sorted by natural order of one of the axes.
     * If this is set to {@link SortingPolicy#NONE}, the order in {@link #dataProperty()} will be used.
     *
     * @since JavaFX 8u40
     * @see SortingPolicy
     * @defaultValue SortingPolicy#X_AXIS
     */
    private ObjectProperty&lt;SortingPolicy&gt; axisSortingPolicy = new ObjectPropertyBase&lt;SortingPolicy&gt;(SortingPolicy.X_AXIS) {
        @Override protected void invalidated() {
            requestChartLayout();
        }

        public Object getBean() {
            return LineChart.this;
        }

        public String getName() {
            return &quot;axisSortingPolicy&quot;;
        }

    };

    public final SortingPolicy getAxisSortingPolicy() { return axisSortingPolicy.getValue(); }
    public final void setAxisSortingPolicy(SortingPolicy value) { axisSortingPolicy.setValue(value); }
    public final ObjectProperty&lt;SortingPolicy&gt; axisSortingPolicyProperty() { return axisSortingPolicy; }

    // -------------- CONSTRUCTORS ----------------------------------------------

    /**
     * Construct a new LineChart with the given axis.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public LineChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis, yAxis, FXCollections.&lt;Series&lt;X, Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new LineChart with the given axis and data.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public LineChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis,yAxis);
        setData(data);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        final Axis&lt;X&gt; xa = getXAxis();
        final Axis&lt;Y&gt; ya = getYAxis();
        List&lt;X&gt; xData = null;
        List&lt;Y&gt; yData = null;
        if(xa.isAutoRanging()) xData = new ArrayList&lt;X&gt;();
        if(ya.isAutoRanging()) yData = new ArrayList&lt;Y&gt;();
        if(xData != null || yData != null) {
            for(Series&lt;X,Y&gt; series : getData()) {
                for(Data&lt;X,Y&gt; data: series.getData()) {
                    if(xData != null) xData.add(data.getXValue());
                    if(yData != null) yData.add(data.getYValue());
                }
            }
            // RT-32838 No need to invalidate range if there is one data item - whose value is zero.
            if(xData != null &amp;&amp; !(xData.size() == 1 &amp;&amp; getXAxis().toNumericValue(xData.get(0)) == 0)) {
                xa.invalidateRange(xData);
            }
            if(yData != null &amp;&amp; !(yData.size() == 1 &amp;&amp; getYAxis().toNumericValue(yData.get(0)) == 0)) {
                ya.invalidateRange(yData);
            }

        }
    }

    @Override protected void dataItemAdded(final Series&lt;X,Y&gt; series, int itemIndex, final Data&lt;X,Y&gt; item) {
        final Node symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            if (dataRemoveTimeline != null &amp;&amp; dataRemoveTimeline.getStatus().equals(Animation.Status.RUNNING)) {
                if (seriesOfDataRemoved == series) {
                    dataRemoveTimeline.stop();
                    dataRemoveTimeline = null;
                    getPlotChildren().remove(dataItemBeingRemoved.getNode());
                    removeDataItemFromDisplay(seriesOfDataRemoved, dataItemBeingRemoved);
                    seriesOfDataRemoved = null;
                    dataItemBeingRemoved = null;
                }
            }
            boolean animate = false;
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; (series.getData().size()-1)) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getData().get(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getData().get(itemIndex + 1);
                if (p1 != null &amp;&amp; p2 != null) {
                    double x1 = getXAxis().toNumericValue(p1.getXValue());
                    double y1 = getYAxis().toNumericValue(p1.getYValue());
                    double x3 = getXAxis().toNumericValue(p2.getXValue());
                    double y3 = getYAxis().toNumericValue(p2.getYValue());

                    double x2 = getXAxis().toNumericValue(item.getXValue());
                    //double y2 = getYAxis().toNumericValue(item.getYValue());
                    if (x2 &gt; x1 &amp;&amp; x2 &lt; x3) {
                         //1. y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                        double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                        item.setCurrentY(getYAxis().toRealValue(y));
                        item.setCurrentX(getXAxis().toRealValue(x2));
                    } else {
                        //2. we can simply use the midpoint on the line as well..
                        double x = (x3 + x1)/2;
                        double y = (y3 + y1)/2;
                        item.setCurrentX(getXAxis().toRealValue(x));
                        item.setCurrentY(getYAxis().toRealValue(y));
                    }
                }
            } else if (itemIndex == 0 &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                item.setCurrentX(series.getData().get(1).getXValue());
                item.setCurrentY(series.getData().get(1).getYValue());
            } else if (itemIndex == (series.getData().size() - 1) &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                int last = series.getData().size() - 2;
                item.setCurrentX(series.getData().get(last).getXValue());
                item.setCurrentY(series.getData().get(last).getYValue());
            } else if(symbol != null) {
                // fade in new symbol
                symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(1);
                ft.play();
            }
            if (animate) {
                animate(
                    new KeyFrame(Duration.ZERO,
                            (e) -&gt; { if (symbol != null &amp;&amp; !getPlotChildren().contains(symbol)) getPlotChildren().add(symbol); },
                                   new KeyValue(item.currentYProperty(),
                                        item.getCurrentY()),
                                        new KeyValue(item.currentXProperty(),
                                        item.getCurrentX())),
                    new KeyFrame(Duration.millis(700), new KeyValue(item.currentYProperty(),
                                        item.getYValue(), Interpolator.EASE_BOTH),
                                        new KeyValue(item.currentXProperty(),
                                        item.getXValue(), Interpolator.EASE_BOTH))
                );
            }

        } else {
            if (symbol != null) getPlotChildren().add(symbol);
        }
    }

    @Override protected  void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node symbol = item.getNode();

        if (symbol != null) {
            symbol.focusTraversableProperty().unbind();
        }

        // remove item from sorted list
        int itemIndex = series.getItemIndex(item);
        if (shouldAnimate()) {
            XYValueMap.clear();
            boolean animate = false;
            // dataSize represents size of currently visible data. After this operation, the number will decrement by 1
            final int dataSize = series.getDataSize();
            // This is the size of current data list in Series. Note that it might be totaly different from dataSize as
            // some big operation might have happened on the list.
            final int dataListSize = series.getData().size();
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; dataSize - 1) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getItem(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getItem(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());
                if (x2 &gt; x1 &amp;&amp; x2 &lt; x3) {
//                //1.  y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                    double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                    item.setCurrentX(getXAxis().toRealValue(x2));
                    item.setCurrentY(getYAxis().toRealValue(y2));
                    item.setXValue(getXAxis().toRealValue(x2));
                    item.setYValue(getYAxis().toRealValue(y));
                } else {
                //2.  we can simply use the midpoint on the line as well..
                    double x = (x3 + x1)/2;
                    double y = (y3 + y1)/2;
                    item.setCurrentX(getXAxis().toRealValue(x));
                    item.setCurrentY(getYAxis().toRealValue(y));
                }
            } else if (itemIndex == 0 &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                item.setXValue(series.getData().get(0).getXValue());
                item.setYValue(series.getData().get(0).getYValue());
            } else if (itemIndex == (dataSize - 1) &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                int last = dataListSize - 1;
                item.setXValue(series.getData().get(last).getXValue());
                item.setYValue(series.getData().get(last).getYValue());
<A NAME="25"></A>            } else if (symbol != null) {
                // fade out symbol
                fadeSymbolTransition = new FadeTransition(Duration.millis(500),symbol);
                <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#25',2,'match42-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>fadeSymbolTransition.setToValue(0);
                fadeSymbolTransition.setOnFinished(actionEvent -&gt; {
                    item.setSeries(null);
                    getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                    symbol.setOpacity(1.0);
                });
                fadeSymbolTransition.play();
            }</B></FONT> else {
                item.setSeries(null);
                removeDataItemFromDisplay(series, item);
            }
            if (animate) {
                dataRemoveTimeline = createDataRemoveTimeline(item, symbol, series);
                seriesOfDataRemoved = series;
                dataItemBeingRemoved = item;
                dataRemoveTimeline.play();
            }
        } else {
            item.setSeries(null);
            if (symbol != null) getPlotChildren().remove(symbol);
            removeDataItemFromDisplay(series, item);
        }
        //Note: better animation here, point should move from old position to new position at center point between prev and next symbols
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        // Note: is there a more efficient way of doing this?
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; s = getData().get(i);
            Node seriesNode = s.getNode();
            if (seriesNode != null) seriesNode.getStyleClass().setAll(&quot;chart-series-line&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            for (int j=0; j &lt; s.getData().size(); j++) {
                final Node symbol = s.getData().get(j).getNode();
                if (symbol != null) symbol.getStyleClass().setAll(&quot;chart-line-symbol&quot;, &quot;series&quot; + i, &quot;data&quot; + j, s.defaultColorStyleClass);
            }
        }
    }

    @Override protected  void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // create new path for series
        Path seriesLine = new Path();
        seriesLine.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        series.setNode(seriesLine);
        // create series Y multiplier
        DoubleProperty seriesYAnimMultiplier = new SimpleDoubleProperty(this, &quot;seriesYMultiplier&quot;);
        seriesYMultiplierMap.put(series, seriesYAnimMultiplier);
        // handle any data already in series
        if (shouldAnimate()) {
            seriesLine.setOpacity(0);
            seriesYAnimMultiplier.setValue(0d);
        } else {
            seriesYAnimMultiplier.setValue(1d);
        }
        getPlotChildren().add(seriesLine);

        List&lt;KeyFrame&gt; keyFrames = new ArrayList&lt;KeyFrame&gt;();
        if (shouldAnimate()) {
            // animate in new series
            keyFrames.add(new KeyFrame(Duration.ZERO,
                new KeyValue(seriesLine.opacityProperty(), 0),
                new KeyValue(seriesYAnimMultiplier, 0)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(200),
                new KeyValue(seriesLine.opacityProperty(), 1)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(500),
                new KeyValue(seriesYAnimMultiplier, 1)
            ));
        }
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            final Node symbol = createSymbol(series, seriesIndex, item, j);
            if(symbol != null) {
                if (shouldAnimate()) symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                if (shouldAnimate()) {
                    // fade in new symbol
                    keyFrames.add(new KeyFrame(Duration.ZERO, new KeyValue(symbol.opacityProperty(), 0)));
                    keyFrames.add(new KeyFrame(Duration.millis(200), new KeyValue(symbol.opacityProperty(), 1)));
                }
            }
        }
        if (shouldAnimate()) animate(keyFrames.toArray(new KeyFrame[keyFrames.size()]));
    }

    @Override protected  void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove all symbol nodes
        seriesYMultiplierMap.remove(series);
        if (shouldAnimate()) {
            seriesRemoveTimeline = new Timeline(createSeriesRemoveTimeLine(series, 900));
            seriesRemoveTimeline.play();
        } else {
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        List&lt;LineTo&gt; constructedPath = new ArrayList&lt;&gt;(getDataSize());
        for (int seriesIndex=0; seriesIndex &lt; getDataSize(); seriesIndex++) {
            Series&lt;X,Y&gt; series = getData().get(seriesIndex);
            final DoubleProperty seriesYAnimMultiplier = seriesYMultiplierMap.get(series);
            final Node seriesNode = series.getNode();
            if (seriesNode instanceof Path) {
                AreaChart.makePaths(this, series,
                                    constructedPath, null, (Path) seriesNode,
                                    seriesYAnimMultiplier.get(), getAxisSortingPolicy());
            }
        }
    }

    /** {@inheritDoc} */
    @Override void dataBeingRemovedIsAdded(Data item, Series series) {
        if (fadeSymbolTransition != null) {
            fadeSymbolTransition.setOnFinished(null);
            fadeSymbolTransition.stop();
        }
        if (dataRemoveTimeline != null) {
            dataRemoveTimeline.setOnFinished(null);
            dataRemoveTimeline.stop();
        }
        final Node symbol = item.getNode();
        if (symbol != null) getPlotChildren().remove(symbol);

        item.setSeries(null);
        removeDataItemFromDisplay(series, item);

        // restore values to item
        Double value = XYValueMap.get(item);
        if (value != null) {
            item.setYValue(value);
            item.setCurrentY(value);
        }
        XYValueMap.clear();
    }
    /** {@inheritDoc} */
    @Override void seriesBeingRemovedIsAdded(Series&lt;X,Y&gt; series) {
        if (seriesRemoveTimeline != null) {
            seriesRemoveTimeline.setOnFinished(null);
            seriesRemoveTimeline.stop();
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    private Timeline createDataRemoveTimeline(final Data&lt;X,Y&gt; item, final Node symbol, final Series&lt;X,Y&gt; series) {
        Timeline t = new Timeline();
        // save data values in case the same data item gets added immediately.
        XYValueMap.put(item, ((Number)item.getYValue()).doubleValue());

        t.getKeyFrames().addAll(new KeyFrame(Duration.ZERO, new KeyValue(item.currentYProperty(),
                item.getCurrentY()), new KeyValue(item.currentXProperty(),
                item.getCurrentX())),
                new KeyFrame(Duration.millis(500), actionEvent -&gt; {
                    if (symbol != null) getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                    XYValueMap.clear();
                },
                new KeyValue(item.currentYProperty(),
                item.getYValue(), Interpolator.EASE_BOTH),
                new KeyValue(item.currentXProperty(),
                item.getXValue(), Interpolator.EASE_BOTH))
        );
        return t;
    }

    private Node createSymbol(Series&lt;X, Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node symbol = item.getNode();
        // check if symbol has already been created
        if (symbol == null &amp;&amp; getCreateSymbols()) {
            symbol = new StackPane();
            symbol.setAccessibleRole(AccessibleRole.TEXT);
            symbol.setAccessibleRoleDescription(&quot;Point&quot;);
            symbol.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(symbol);
        }
        // set symbol styles
        if (symbol != null) symbol.getStyleClass().addAll(&quot;chart-line-symbol&quot;, &quot;series&quot; + seriesIndex,
                &quot;data&quot; + itemIndex, series.defaultColorStyleClass);
        return symbol;
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-line-symbol&quot;, &quot;series&quot; + seriesIndex,
                series.defaultColorStyleClass);
        return legendItem;
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;LineChart&lt;?,?&gt;,Boolean&gt; CREATE_SYMBOLS =
            new CssMetaData&lt;LineChart&lt;?,?&gt;,Boolean&gt;(&quot;-fx-create-symbols&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(LineChart&lt;?,?&gt; node) {
                return node.createSymbols == null || !node.createSymbols.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(LineChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.createSymbolsProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CREATE_SYMBOLS);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /**
     * This enum defines a policy for {@link LineChart#axisSortingPolicyProperty()}.
     * @since JavaFX 8u40
     */
    public static enum SortingPolicy {
        /**
         * The data should be left in the order defined by the list in {@link javafx.scene.chart.LineChart#dataProperty()}.
         */
        NONE,
        /**
         * The data is ordered by x axis.
         */
        X_AXIS,
        /**
         * The data is ordered by y axis.
         */
        Y_AXIS
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/PieChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Side;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcTo;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.ClosePath;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.text.Text;
import javafx.scene.transform.Scale;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend;
import com.sun.javafx.charts.Legend.LegendItem;
import com.sun.javafx.collections.NonIterableChange;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.SizeConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Displays a PieChart. The chart content is populated by pie slices based on
 * data set on the PieChart.
 * &lt;p&gt; The clockwise property is set to true by default, which means slices are
 * placed in the clockwise order. The labelsVisible property is used to either display
 * pie slice labels or not.
 *
 * @since JavaFX 2.0
 */
public class PieChart extends Chart {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------
    private static final int MIN_PIE_RADIUS = 25;
    private static final double LABEL_TICK_GAP = 6;
    private static final double LABEL_BALL_RADIUS = 2;
    private BitSet colorBits = new BitSet(8);
    private double pieRadius;
    private Data begin = null;
    private final Path labelLinePath = new Path() {
        @Override public boolean usesMirroring() {
            return false;
        }
    };
    private List&lt;LabelLayoutInfo&gt; labelLayoutInfos = null;
    private Legend legend = new Legend();
    private Data dataItemBeingRemoved = null;
    private Timeline dataRemoveTimeline = null;
    private final ListChangeListener&lt;Data&gt; dataChangeListener = c -&gt; {
        while (c.next()) {
            // RT-28090 Probably a sort happened, just reorder the pointers.
            if (c.wasPermutated()) {
                Data ptr = begin;
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                    if (i == 0) {
                        begin = item;
                        ptr = begin;
                        begin.next = null;
                    } else {
                        ptr.next = item;
                        item.next = null;
                        ptr = item;
                    }
                }
                updateLegend();
                requestChartLayout();
                return;
            }
            // recreate linked list &amp; set chart on new data
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                item.setChart(PieChart.this);
                if (begin == null) {
                    begin = item;
                    begin.next = null;
                } else {
                    if (i == 0) {
                        item.next = begin;
                        begin = item;
                    } else {
                        Data ptr = begin;
                        for (int j = 0; j &lt; i -1 ; j++) {
                            ptr = ptr.next;
                        }
                        item.next = ptr.next;
                        ptr.next = item;
                    }
                }
            }
            // call data added/removed methods
            for (Data item : c.getRemoved()) {
                dataItemRemoved(item);
            }
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                // assign default color to the added slice
                // TODO: check nearby colors
                item.defaultColorIndex = colorBits.nextClearBit(0);
                colorBits.set(item.defaultColorIndex);
                dataItemAdded(item, i);
            }
            if (c.wasRemoved() || c.wasAdded()) {
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                }
                updateLegend();
            }
        }
        // re-layout everything
        requestChartLayout();
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** PieCharts data */
    private ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; data = new ObjectPropertyBase&lt;ObservableList&lt;Data&gt;&gt;() {
        private ObservableList&lt;Data&gt; old;
        @Override protected void invalidated() {
            final ObservableList&lt;Data&gt; current = getValue();
            // add remove listeners
            if(old != null) old.removeListener(dataChangeListener);
            if(current != null) current.addListener(dataChangeListener);
            // fire data change event if series are added or removed
            if(old != null || current != null) {
                final List&lt;Data&gt; removed = (old != null) ? old : Collections.&lt;Data&gt;emptyList();
                final int toIndex = (current != null) ? current.size() : 0;
                // let data listener know all old data have been removed and new data that has been added
                if (toIndex &gt; 0 || !removed.isEmpty()) {
                    dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, toIndex, current){
                        @Override public List&lt;Data&gt; getRemoved() { return removed; }
                        @Override public boolean wasPermutated() { return false; }
                        @Override protected int[] getPermutation() {
                            return new int[0];
                        }
                    });
                }
            } else if (old != null &amp;&amp; old.size() &gt; 0) {
                // let series listener know all old series have been removed
                dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, 0, current){
                    @Override public List&lt;Data&gt; getRemoved() { return old; }
                    @Override public boolean wasPermutated() { return false; }
                    @Override protected int[] getPermutation() {
                        return new int[0];
                    }
                });
            }
            old = current;
        }

        public Object getBean() {
            return PieChart.this;
        }

        public String getName() {
            return &quot;data&quot;;
        }
    };
    public final ObservableList&lt;Data&gt; getData() { return data.getValue(); }
    public final void setData(ObservableList&lt;Data&gt; value) { data.setValue(value); }
    public final ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; dataProperty() { return data; }

    /** The angle to start the first pie slice at */
    private DoubleProperty startAngle = new StyleableDoubleProperty(0) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;startAngle&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.START_ANGLE;
        }
    };
    public final double getStartAngle() { return startAngle.getValue(); }
    public final void setStartAngle(double value) { startAngle.setValue(value); }
    public final DoubleProperty startAngleProperty() { return startAngle; }

    /** When true we start placing slices clockwise from the startAngle */
    private BooleanProperty clockwise = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;clockwise&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CLOCKWISE;
        }
    };
    public final void setClockwise(boolean value) { clockwise.setValue(value);}
    public final boolean isClockwise() { return clockwise.getValue(); }
    public final BooleanProperty clockwiseProperty() { return clockwise; }


    /** The length of the line from the outside of the pie to the slice labels. */
    private DoubleProperty labelLineLength = new StyleableDoubleProperty(20d) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelLineLength&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.LABEL_LINE_LENGTH;
        }
    };
    public final double getLabelLineLength() { return labelLineLength.getValue(); }
    public final void setLabelLineLength(double value) { labelLineLength.setValue(value); }
    public final DoubleProperty labelLineLengthProperty() { return labelLineLength; }

    /** When true pie slice labels are drawn */
    private BooleanProperty labelsVisible = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelsVisible&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LABELS_VISIBLE;
        }
    };
    public final void setLabelsVisible(boolean value) { labelsVisible.setValue(value);}

    /**
     * Indicates whether pie slice labels are drawn or not
     * @return true if pie slice labels are visible and false otherwise.
     */
    public final boolean getLabelsVisible() { return labelsVisible.getValue(); }
    public final BooleanProperty labelsVisibleProperty() { return labelsVisible; }

    // -------------- CONSTRUCTOR ----------------------------------------------

    /**
     * Construct a new empty PieChart.
     */
    public PieChart() {
        this(FXCollections.&lt;Data&gt;observableArrayList());
    }

    /**
     * Construct a new PieChart with the given data
     *
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public PieChart(ObservableList&lt;PieChart.Data&gt; data) {
        getChartChildren().add(labelLinePath);
        labelLinePath.getStyleClass().add(&quot;chart-pie-label-line&quot;);
        setLegend(legend);
        setData(data);
        // set chart content mirroring to be always false i.e. chartContent mirrorring is not done
        // when  node orientation is right-to-left for PieChart.
        useChartContentMirroring = false;
    }

    // -------------- METHODS --------------------------------------------------

    private void dataNameChanged(Data item) {
        item.textNode.setText(item.getName());
        requestChartLayout();
        updateLegend();
    }

    private void dataPieValueChanged(Data item) {
        if (shouldAnimate()) {
            animate(
                new KeyFrame(Duration.ZERO, new KeyValue(item.currentPieValueProperty(),
                        item.getCurrentPieValue())),
                new KeyFrame(Duration.millis(500),new KeyValue(item.currentPieValueProperty(),
                        item.getPieValue(), Interpolator.EASE_BOTH))
            );
        } else {
            item.setCurrentPieValue(item.getPieValue());
            requestChartLayout(); // RT-23091
        }
    }

    private Node createArcRegion(Data item) {
        Node arcRegion = item.getNode();
        // check if symbol has already been created
        if (arcRegion == null) {
            arcRegion = new Region();
            arcRegion.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
            arcRegion.setPickOnBounds(false);
            item.setNode(arcRegion);
        }
        return arcRegion;
    }

    private Text createPieLabel(Data item) {
        Text text = item.textNode;
        text.setText(item.getName());
        return text;
    }

    private void updateDataItemStyleClass(final Data item, int index) {
        Node node = item.getNode();
        if (node != null) {
            // Note: not sure if we want to add or check, ie be more careful and efficient here
            node.getStyleClass().setAll(&quot;chart-pie&quot;, &quot;data&quot; + index,
                    &quot;default-color&quot; + item.defaultColorIndex % 8);
            if (item.getPieValue() &lt; 0) {
                node.getStyleClass().add(&quot;negative&quot;);
            }
        }
    }

    private void dataItemAdded(final Data item, int index) {
        // create shape
        Node shape = createArcRegion(item);
        final Text text = createPieLabel(item);
        item.getChart().getChartChildren().add(shape);
        if (shouldAnimate()) {
            // if the same data item is being removed, first stop the remove animation,
            // remove the item and then start the add animation.
            if (dataRemoveTimeline != null &amp;&amp; dataRemoveTimeline.getStatus().equals(Animation.Status.RUNNING)) {
                if (dataItemBeingRemoved == item) {
                    dataRemoveTimeline.stop();
                    dataRemoveTimeline = null;
                    getChartChildren().remove(item.textNode);
                    getChartChildren().remove(shape);
                    removeDataItemRef(item);
                }
            }
            animate(
                new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            text.setOpacity(0);
                            // RT-23597 : item's chart might have been set to null if
                            // this item is added and removed before its add animation finishes.
                            if (item.getChart() == null) item.setChart(PieChart.this);
                            item.getChart().getChartChildren().add(text);
                            FadeTransition ft = new FadeTransition(Duration.millis(150),text);
                            ft.setToValue(1);
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), item.getPieValue(), Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 1, Interpolator.EASE_BOTH))
            );
        } else {
            getChartChildren().add(text);
            item.setRadiusMultiplier(1);
            item.setCurrentPieValue(item.getPieValue());
        }

        // we sort the text nodes to always be at the end of the children list, so they have a higher z-order
        // (Fix for RT-34564)
        for (int i = 0; i &lt; getChartChildren().size(); i++) {
            Node n = getChartChildren().get(i);
            if (n instanceof Text) {
                n.toFront();
            }
        }
    }

    private void removeDataItemRef(Data item) {
        if (begin == item) {
            begin = item.next;
        } else {
            Data ptr = begin;
            while(ptr != null &amp;&amp; ptr.next != item) {
                ptr = ptr.next;
            }
            if(ptr != null) ptr.next = item.next;
        }
    }

    private Timeline createDataRemoveTimeline(final Data item) {
        final Node shape = item.getNode();
        Timeline t = new Timeline();
        t.getKeyFrames().addAll(new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            // removing item
                            colorBits.clear(item.defaultColorIndex);
                            getChartChildren().remove(shape);
                            // fade out label
                            FadeTransition ft = new FadeTransition(Duration.millis(150),item.textNode);
                            ft.setFromValue(1);
                            ft.setToValue(0);
                            ft.setOnFinished(new EventHandler&lt;ActionEvent&gt;() {
                                 @Override public void handle(ActionEvent actionEvent) {
                                     getChartChildren().remove(item.textNode);
                                     // remove chart references from old data - RT-22553
                                     item.setChart(null);
                                     removeDataItemRef(item);
                                     item.textNode.setOpacity(1.0);
                                 }
                            });
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), 0, Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 0))
                );
        return t;
    }

    private void dataItemRemoved(final Data item) {
        final Node shape = item.getNode();
        if (shouldAnimate()) {
            dataRemoveTimeline = createDataRemoveTimeline(item);
            dataItemBeingRemoved = item;
            animate(dataRemoveTimeline);
        } else {
            colorBits.clear(item.defaultColorIndex);
            getChartChildren().remove(item.textNode);
            getChartChildren().remove(shape);
            // remove chart references from old data
            item.setChart(null);
            removeDataItemRef(item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChartChildren(double top, double left, double contentWidth, double contentHeight) {
        double total = 0.0;
        for (Data item = begin; item != null; item = item.next) {
            total+= Math.abs(item.getCurrentPieValue());
        }
        double scale = (total != 0) ? 360 / total : 0;

         // calculate combined bounds of all labels &amp; pie radius
        double[] labelsX = null;
        double[] labelsY = null;
        double[] labelAngles = null;
        double labelScale = 1;
        List&lt;LabelLayoutInfo&gt; fullPie = null;
        boolean shouldShowLabels = getLabelsVisible();
        if (shouldShowLabels) {
            double xPad = 0d;
            double yPad = 0d;

            labelsX = new double[getDataSize()];
            labelsY = new double[getDataSize()];
            labelAngles = new double[getDataSize()];
            fullPie = new ArrayList&lt;&gt;();
            int index = 0;
            double start = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                // remove any scale on the text node
                item.textNode.getTransforms().clear();

                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                labelAngles[index] = normalizeAngle(start + (size / 2));
                final double sproutX = calcX(labelAngles[index], getLabelLineLength(), 0);
                final double sproutY = calcY(labelAngles[index], getLabelLineLength(), 0);
                labelsX[index] = sproutX;
                labelsY[index] = sproutY;
                xPad = Math.max(xPad, 2 * (item.textNode.getLayoutBounds().getWidth() + LABEL_TICK_GAP + Math.abs(sproutX)));
                if (sproutY &gt; 0) { // on bottom
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY+item.textNode.getLayoutBounds().getMaxY()));
                } else { // on top
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY + item.textNode.getLayoutBounds().getMinY()));
                }
                start+= size;
                index++;
            }
            pieRadius = Math.min(contentWidth - xPad, contentHeight - yPad) / 2;
            // check if this makes the pie too small
            if (pieRadius &lt; MIN_PIE_RADIUS ) {
                // calculate scale for text to fit labels in
                final double roomX = contentWidth-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                final double roomY = contentHeight-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                labelScale = Math.min(
                        roomX/xPad,
                        roomY/yPad
                );
                // hide labels if pie radius is less than minimum
                if ((begin == null &amp;&amp; labelScale &lt; 0.7) || ((begin.textNode.getFont().getSize()*labelScale) &lt; 9)) {
                    shouldShowLabels = false;
                    labelScale = 1;
                } else {
                    // set pieRadius to minimum
                    pieRadius = MIN_PIE_RADIUS;
                    // apply scale to all label positions
                    for(int i=0; i&lt; labelsX.length; i++) {
                        labelsX[i] =  labelsX[i] * labelScale;
                        labelsY[i] =  labelsY[i] * labelScale;
                    }
                }
            }
        }

        if (!shouldShowLabels) {
            pieRadius = Math.min(contentWidth,contentHeight) / 2;
            labelLinePath.getElements().clear();
        }

        if (getChartChildren().size() &gt; 0) {
            double centerX = contentWidth / 2 + left;
            double centerY = contentHeight / 2 + top;
            int index = 0;
            for (Data item = begin; item != null; item = item.next) {
                // layout labels for pie slice
                item.textNode.setVisible(shouldShowLabels);
                if (shouldShowLabels) {
                    double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                    final boolean isLeftSide = !(labelAngles[index] &gt; -90 &amp;&amp; labelAngles[index] &lt; 90);

                    double sliceCenterEdgeX = calcX(labelAngles[index], pieRadius, centerX);
                    double sliceCenterEdgeY = calcY(labelAngles[index], pieRadius, centerY);
                    double xval = isLeftSide ?
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMaxX() - LABEL_TICK_GAP) :
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMinX() + LABEL_TICK_GAP);
                    double yval = labelsY[index] + sliceCenterEdgeY - (item.textNode.getLayoutBounds().getMinY()/2) -2;

                    // do the line (Path)for labels
                    double lineEndX = sliceCenterEdgeX +labelsX[index];
                    double lineEndY = sliceCenterEdgeY +labelsY[index];
                    LabelLayoutInfo info = new LabelLayoutInfo(sliceCenterEdgeX,
                            sliceCenterEdgeY,lineEndX, lineEndY, xval, yval, item.textNode, Math.abs(size));
                    fullPie.add(info);

                    // set label scales
                    if (labelScale &lt; 1) {
                        item.textNode.getTransforms().add(
                            new Scale(
                                    labelScale, labelScale,
                                    isLeftSide ? item.textNode.getLayoutBounds().getWidth() : 0, 0
                            )
                        );
                    }
                }
                index++;
            }

            // update/draw pie slices
            double sAngle = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                Node node = item.getNode();
                Arc arc = null;
                if (node != null) {
                    if (node instanceof Region) {
                        Region arcRegion = (Region)node;
                        if (arcRegion.getShape() == null) {
                            arc = new Arc();
                            arcRegion.setShape(arc);
                        } else {
                            arc = (Arc)arcRegion.getShape();
                        }
                        arcRegion.setScaleShape(false);
                        arcRegion.setCenterShape(false);
                        arcRegion.setCacheShape(false);
                    }
                }
                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                // update slice arc size
                arc.setStartAngle(sAngle);
                arc.setLength(size);
                arc.setType(ArcType.ROUND);
                arc.setRadiusX(pieRadius * item.getRadiusMultiplier());
                arc.setRadiusY(pieRadius * item.getRadiusMultiplier());
                node.setLayoutX(centerX);
                node.setLayoutY(centerY);
                sAngle += size;
            }
            // finally draw the text and line
            if (fullPie != null) {
                // Check for collision and resolve by hiding the label of the smaller pie slice
                resolveCollision(fullPie);

                if (!fullPie.equals(labelLayoutInfos)) {
                    labelLinePath.getElements().clear();
                    for (LabelLayoutInfo info : fullPie) {
                        if (info.text.isVisible()) drawLabelLinePath(info);
                    }
                    labelLayoutInfos = fullPie;
                }
            }
        }
    }

    // We check for pie slice label collision and if collision is detected, we then
    // compare the size of the slices, and hide the label of the smaller slice.
    private void resolveCollision(List&lt;LabelLayoutInfo&gt; list) {
        int boxH = (begin != null) ? (int)begin.textNode.getLayoutBounds().getHeight() : 0;
        for (int i = 0; i &lt; list.size(); i++ ) {
            for (int j = i+1; j &lt; list.size(); j++ ) {
                LabelLayoutInfo box1 = list.get(i);
                LabelLayoutInfo box2 = list.get(j);
                if ((box1.text.isVisible() &amp;&amp; box2.text.isVisible()) &amp;&amp;
                        (fuzzyGT(box2.textY, box1.textY) ? fuzzyLT((box2.textY - boxH - box1.textY), 2) :
                                fuzzyLT((box1.textY - boxH - box2.textY), 2)) &amp;&amp;
                        (fuzzyGT(box1.textX, box2.textX) ? fuzzyLT((box1.textX - box2.textX), box2.text.prefWidth(-1)) :
                                fuzzyLT((box2.textX - box1.textX), box1.text.prefWidth(-1)))) {
                    if (fuzzyLT(box1.size, box2.size)) {
                        box1.text.setVisible(false);
                    } else {
                        box2.text.setVisible(false);
                    }
                }
            }
        }
    }

    private int fuzzyCompare(double o1, double o2) {
       double fuzz = 0.00001;
       return (((Math.abs(o1 - o2)) &lt; fuzz) ? 0 : ((o1 &lt; o2) ? -1 : 1));
    }

    private boolean fuzzyGT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == 1;
    }

    private boolean fuzzyLT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == -1;
    }

    private void drawLabelLinePath(LabelLayoutInfo info) {
        info.text.setLayoutX(info.textX);
        info.text.setLayoutY(info.textY);
        labelLinePath.getElements().add(new MoveTo(info.startX, info.startY));
        labelLinePath.getElements().add(new LineTo(info.endX, info.endY));

        labelLinePath.getElements().add(new MoveTo(info.endX-LABEL_BALL_RADIUS,info.endY));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY-LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX+LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY+LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX-LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ClosePath());
    }
    /**
     * This is called whenever a series is added or removed and the legend needs to be updated
     */
    private void updateLegend() {
        Node legendNode = getLegend();
<A NAME="82"></A>        if (legendNode != null &amp;&amp; legendNode != legend) return; // RT-23596 dont update when user has set legend.
        legend.setVertical(getLegendSide().equals(Side.LEFT) || getLegendSide().equals(Side.RIGHT));
        List&lt;Legend.LegendItem&gt; legendList = new ArrayList&lt;&gt;();
        if (<FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#82',2,'match42-top.html#82',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getData() != null) {
            for (Data item : getData()) {
                LegendItem legenditem = new LegendItem(item.getName());
                legenditem.getSymbol().getStyleClass().addAll(item.getNode().getStyleClass());
                legenditem.getSymbol().getStyleClass().add</B></FONT>(&quot;pie-legend-symbol&quot;);
                legendList.add(legenditem);
            }
        }
        legend.getItems().setAll(legendList);
        if (legendList.size() &gt; 0) {
            if (legendNode == null) {
                setLegend(legend);
            }
        } else {
            setLegend(null);
        }
    }

    private int getDataSize() {
        int count = 0;
        for (Data d = begin; d != null; d = d.next) {
            count++;
        }
        return count;
    }

    private static double calcX(double angle, double radius, double centerX) {
        return (double)(centerX + radius * Math.cos(Math.toRadians(-angle)));
    }

    private static double calcY(double angle, double radius, double centerY) {
        return (double)(centerY + radius * Math.sin(Math.toRadians(-angle)));
    }

     /** Normalize any angle into -180 to 180 deg range */
    private static double normalizeAngle(double angle) {
        double a = angle % 360;
        if (a &lt;= -180) a += 360;
        if (a &gt; 180) a -= 360;
        return a;
    }

    // -------------- INNER CLASSES --------------------------------------------

    // Class holding label line layout info for collision detection and removal
    private final static class LabelLayoutInfo {
        double startX;
        double startY;
        double endX;
        double endY;
        double textX;
        double textY;
        Text text;
        double size;

        LabelLayoutInfo(double startX, double startY, double endX, double endY,
                double textX, double textY, Text text, double size) {
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
            this.textX = textX;
            this.textY = textY;
            this.text = text;
            this.size = size;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            LabelLayoutInfo that = (LabelLayoutInfo) o;
            return Double.compare(that.startX, startX) == 0 &amp;&amp;
                    Double.compare(that.startY, startY) == 0 &amp;&amp;
                    Double.compare(that.endX, endX) == 0 &amp;&amp;
                    Double.compare(that.endY, endY) == 0 &amp;&amp;
                    Double.compare(that.textX, textX) == 0 &amp;&amp;
                    Double.compare(that.textY, textY) == 0 &amp;&amp;
                    Double.compare(that.size, size) == 0;
        }

        @Override
        public int hashCode() {
            return Objects.hash(startX, startY, endX, endY, textX, textY, size);
        }
    }

    /**
     * PieChart Data Item, represents one slice in the PieChart
     *
     * @since JavaFX 2.0
     */
    public final static class Data {

        private Text textNode = new Text();
        /**
         * Next pointer for the next data item : so we can do animation on data delete.
         */
        private Data next = null;

        /**
         * Default color index for this slice.
         */
        private int defaultColorIndex;

        // -------------- PUBLIC PROPERTIES ------------------------------------

        /**
         * The chart which this data belongs to.
         */
        private ReadOnlyObjectWrapper&lt;PieChart&gt; chart = new ReadOnlyObjectWrapper&lt;PieChart&gt;(this, &quot;chart&quot;);

        public final PieChart getChart() {
            return chart.getValue();
        }

        private void setChart(PieChart value) {
            chart.setValue(value);
        }

        public final ReadOnlyObjectProperty&lt;PieChart&gt; chartProperty() {
            return chart.getReadOnlyProperty();
        }

        /**
         * The name of the pie slice
         */
        private StringProperty name = new StringPropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataNameChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;name&quot;;
            }
        };

        public final void setName(java.lang.String value) {
            name.setValue(value);
        }

        public final java.lang.String getName() {
            return name.getValue();
        }

        public final StringProperty nameProperty() {
            return name;
        }

        /**
         * The value of the pie slice
         */
        private DoubleProperty pieValue = new DoublePropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataPieValueChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;pieValue&quot;;
            }
        };

        public final double getPieValue() {
            return pieValue.getValue();
        }

        public final void setPieValue(double value) {
            pieValue.setValue(value);
        }

        public final DoubleProperty pieValueProperty() {
            return pieValue;
        }

        /**
         * The current pie value, used during animation. This will be the last data value, new data value or
         * anywhere in between
         */
        private DoubleProperty currentPieValue = new SimpleDoubleProperty(this, &quot;currentPieValue&quot;);

        private double getCurrentPieValue() {
            return currentPieValue.getValue();
        }

        private void setCurrentPieValue(double value) {
            currentPieValue.setValue(value);
        }

        private DoubleProperty currentPieValueProperty() {
            return currentPieValue;
        }

        /**
         * Multiplier that is used to animate the radius of the pie slice
         */
        private DoubleProperty radiusMultiplier = new SimpleDoubleProperty(this, &quot;radiusMultiplier&quot;);

        private double getRadiusMultiplier() {
            return radiusMultiplier.getValue();
        }

        private void setRadiusMultiplier(double value) {
            radiusMultiplier.setValue(value);
        }

        private DoubleProperty radiusMultiplierProperty() {
            return radiusMultiplier;
        }

        /**
         * Readonly access to the node that represents the pie slice. You can use this to add mouse event listeners etc.
         */
        private ReadOnlyObjectWrapper&lt;Node&gt; node = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;node&quot;);

        /**
         * Returns the node that represents the pie slice. You can use this to
         * add mouse event listeners etc.
         * @return the node that represents the pie slice
         */
        public Node getNode() {
            return node.getValue();
        }

        private void setNode(Node value) {
            node.setValue(value);
        }

        public ReadOnlyObjectProperty&lt;Node&gt; nodeProperty() {
            return node.getReadOnlyProperty();
        }

        // -------------- CONSTRUCTOR -------------------------------------------------

        /**
         * Constructs a PieChart.Data object with the given name and value.
         *
         * @param name  name for Pie
         * @param value pie value
         */
        public Data(java.lang.String name, double value) {
            setName(name);
            setPieValue(value);
            textNode.getStyleClass().addAll(&quot;text&quot;, &quot;chart-pie-label&quot;);
            textNode.setAccessibleRole(AccessibleRole.TEXT);
            textNode.setAccessibleRoleDescription(&quot;slice&quot;);
            textNode.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            textNode.accessibleTextProperty().bind( new StringBinding() {
                {bind(nameProperty(), currentPieValueProperty());}
                @Override protected String computeValue() {
                    return getName() + &quot; represents &quot; + getCurrentPieValue() + &quot; percent&quot;;
                }
            });
        }

        // -------------- PUBLIC METHODS ----------------------------------------------

        /**
         * Returns a string representation of this {@code Data} object.
         *
         * @return a string representation of this {@code Data} object.
         */
        @Override
        public java.lang.String toString() {
            return &quot;Data[&quot; + getName() + &quot;,&quot; + getPieValue() + &quot;]&quot;;
        }
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;PieChart,Boolean&gt; CLOCKWISE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-clockwise&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.clockwise == null || !node.clockwise.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.clockwiseProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Boolean&gt; LABELS_VISIBLE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-pie-label-visible&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelsVisible == null || !node.labelsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.labelsVisibleProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; LABEL_LINE_LENGTH =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-label-line-length&quot;,
                 SizeConverter.getInstance(), 20d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelLineLength == null || !node.labelLineLength.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.labelLineLengthProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; START_ANGLE =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-start-angle&quot;,
                 SizeConverter.getInstance(), 0d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.startAngle == null || !node.startAngle.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.startAngleProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Chart.getClassCssMetaData());
            styleables.add(CLOCKWISE);
            styleables.add(LABELS_VISIBLE);
            styleables.add(LABEL_LINE_LENGTH);
            styleables.add(START_ANGLE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/StackedAreaChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;


import java.util.*;

import javafx.animation.*;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.AccessibleRole;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.*;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;
import javafx.css.converter.BooleanConverter;

import javafx.beans.property.BooleanProperty;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableProperty;

/**
 * StackedAreaChart is a variation of {@link AreaChart} that displays trends of the
 * contribution of each value. (over time e.g.) The areas are stacked so that each
 * series adjoins but does not overlap the preceding series. This contrasts with
 * the Area chart where each series overlays the preceding series.
 *
 * The cumulative nature of the StackedAreaChart gives an idea of the total Y data
 * value at any given point along the X axis.
 *
 * Since data points across multiple series may not be common, StackedAreaChart
 * interpolates values along the line joining the data points whenever necessary.
 *
 * @since JavaFX 2.1
 */
public class StackedAreaChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- PRIVATE FIELDS ------------------------------------------

    /** A multiplier for teh Y values that we store for each series, it is used to animate in a new series */
    private Map&lt;Series&lt;X,Y&gt;, DoubleProperty&gt; seriesYMultiplierMap = new HashMap&lt;&gt;();

    // -------------- PUBLIC PROPERTIES ----------------------------------------
    /**
     * When true, CSS styleable symbols are created for any data items that
     * don't have a symbol node specified.
     * @since JavaFX 8.0
     */
    private BooleanProperty createSymbols = new StyleableBooleanProperty(true) {
        @Override
        protected void invalidated() {
            for (int seriesIndex = 0; seriesIndex &lt; getData().size(); seriesIndex++) {
                Series&lt;X, Y&gt; series = getData().get(seriesIndex);
                for (int itemIndex = 0; itemIndex &lt; series.getData().size(); itemIndex++) {
                    Data&lt;X, Y&gt; item = series.getData().get(itemIndex);
                    Node symbol = item.getNode();
                    if (get() &amp;&amp; symbol == null) { // create any symbols
                        symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
                        if (null != symbol) {
                            getPlotChildren().add(symbol);
                        }
                    } else if (!get() &amp;&amp; symbol != null) { // remove symbols
                        getPlotChildren().remove(symbol);
                        symbol = null;
                        item.setNode(null);
                    }
                }
            }
            requestChartLayout();
        }

        public Object getBean() {
            return this;
        }

        public String getName() {
            return &quot;createSymbols&quot;;
        }

        public CssMetaData&lt;StackedAreaChart&lt;?, ?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CREATE_SYMBOLS;
        }
    };

    /**
     * Indicates whether symbols for data points will be created or not.
     *
     * @return true if symbols for data points will be created and false otherwise.
     * @since JavaFX 8.0
     */
    public final boolean getCreateSymbols() { return createSymbols.getValue(); }
    public final void setCreateSymbols(boolean value) { createSymbols.setValue(value); }
    public final BooleanProperty createSymbolsProperty() { return createSymbols; }

    // -------------- CONSTRUCTORS ----------------------------------------------

    /**
     * Construct a new Area Chart with the given axis
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public StackedAreaChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis,yAxis, FXCollections.&lt;Series&lt;X,Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new Area Chart with the given axis and data.
     * &lt;p&gt;
     * Note: yAxis must be a ValueAxis, otherwise {@code IllegalArgumentException} is thrown.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     *
     * @throws java.lang.IllegalArgumentException if yAxis is not a ValueAxis
     */
    public StackedAreaChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis,yAxis);
        if (!(yAxis instanceof ValueAxis)) {
            throw new IllegalArgumentException(&quot;Axis type incorrect, yAxis must be of ValueAxis type.&quot;);
        }
        setData(data);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    private static double doubleValue(Number number) { return doubleValue(number, 0); }
    private static double doubleValue(Number number, double nullDefault) {
        return (number == null) ? nullDefault : number.doubleValue();
    }

    @Override protected void dataItemAdded(Series&lt;X,Y&gt; series, int itemIndex, Data&lt;X,Y&gt; item) {
        final Node symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            boolean animate = false;
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; (series.getData().size()-1)) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getData().get(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getData().get(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());

//                //1. y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                item.setCurrentY(getYAxis().toRealValue(y));
                item.setCurrentX(getXAxis().toRealValue(x2));
                //2. we can simply use the midpoint on the line as well..
//                double x = (x3 + x1)/2;
//                double y = (y3 + y1)/2;
//                item.setCurrentX(x);
//                item.setCurrentY(y);
            } else if (itemIndex == 0 &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                item.setCurrentX(series.getData().get(1).getXValue());
                item.setCurrentY(series.getData().get(1).getYValue());
            } else if (itemIndex == (series.getData().size() - 1) &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                int last = series.getData().size() - 2;
                item.setCurrentX(series.getData().get(last).getXValue());
                item.setCurrentY(series.getData().get(last).getYValue());
            } else if (symbol != null) {
                // fade in new symbol
                symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(1);
                ft.play();
            }
            if (animate) {
                animate(
                    new KeyFrame(Duration.ZERO,
                            (e) -&gt; {
                                if (symbol != null &amp;&amp; !getPlotChildren().contains(symbol)) {
                                    getPlotChildren().add(symbol);
                                } },
                            new KeyValue(item.currentYProperty(),
                                    item.getCurrentY()),
                            new KeyValue(item.currentXProperty(),
                                    item.getCurrentX())
                    ),
                    new KeyFrame(Duration.millis(800), new KeyValue(item.currentYProperty(),
                                        item.getYValue(), Interpolator.EASE_BOTH),
                                        new KeyValue(item.currentXProperty(),
                                        item.getXValue(), Interpolator.EASE_BOTH))
                );
            }

        } else if (symbol != null) {
            getPlotChildren().add(symbol);
        }
    }

    @Override protected  void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node symbol = item.getNode();

        if (symbol != null) {
            symbol.focusTraversableProperty().unbind();
        }

        // remove item from sorted list
        int itemIndex = series.getItemIndex(item);
        if (shouldAnimate()) {
            boolean animate = false;
            // dataSize represents size of currently visible data. After this operation, the number will decrement by 1
            final int dataSize = series.getDataSize();
            // This is the size of current data list in Series. Note that it might be totaly different from dataSize as
            // some big operation might have happened on the list.
            final int dataListSize = series.getData().size();
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; dataSize - 1) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getItem(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getItem(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());

//                //1.  y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                item.setCurrentX(getXAxis().toRealValue(x2));
                item.setCurrentY(getYAxis().toRealValue(y2));
                item.setXValue(getXAxis().toRealValue(x2));
                item.setYValue(getYAxis().toRealValue(y));
                //2.  we can simply use the midpoint on the line as well..
//                double x = (x3 + x1)/2;
//                double y = (y3 + y1)/2;
//                item.setCurrentX(x);
//                item.setCurrentY(y);
            } else if (itemIndex == 0 &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                item.setXValue(series.getData().get(0).getXValue());
                item.setYValue(series.getData().get(0).getYValue());
            } else if (itemIndex == (dataSize - 1) &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                int last = dataListSize - 1;
                item.setXValue(series.getData().get(last).getXValue());
                item.setYValue(series.getData().get(last).getYValue());
            } else if (symbol != null) {
                // fade out symbol
                symbol.setOpacity(0);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(0);
                ft.setOnFinished(actionEvent -&gt; {
                    getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                    symbol.setOpacity(1.0);
                });
                ft.play();
            } else {
                item.setSeries(null);
                removeDataItemFromDisplay(series, item);
            }
            if (animate) {
                animate( new KeyFrame(Duration.ZERO, new KeyValue(item.currentYProperty(),
                            item.getCurrentY()), new KeyValue(item.currentXProperty(),
                            item.getCurrentX())),
                            new KeyFrame(Duration.millis(800), actionEvent -&gt; {
                                getPlotChildren().remove(symbol);
                                removeDataItemFromDisplay(series, item);
                            },
                            new KeyValue(item.currentYProperty(),
                            item.getYValue(), Interpolator.EASE_BOTH),
                            new KeyValue(item.currentXProperty(),
                            item.getXValue(), Interpolator.EASE_BOTH))
                );
            }
        } else {
            getPlotChildren().remove(symbol);
            removeDataItemFromDisplay(series, item);
        }
        //Note: better animation here, point should move from old position to new position at center point between prev and next symbols
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; s = getData().get(i);
            Path seriesLine = (Path)((Group)s.getNode()).getChildren().get(1);
            Path fillPath = (Path)((Group)s.getNode()).getChildren().get(0);
            seriesLine.getStyleClass().setAll(&quot;chart-series-area-line&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            fillPath.getStyleClass().setAll(&quot;chart-series-area-fill&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            for (int j=0; j &lt; s.getData().size(); j++) {
                final Data&lt;X,Y&gt; item = s.getData().get(j);
                final Node node = item.getNode();
                if(node!=null) node.getStyleClass().setAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + i, &quot;data&quot; + j, s.defaultColorStyleClass);
            }
        }
    }

    @Override protected  void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // create new paths for series
        Path seriesLine = new Path();
        Path fillPath = new Path();
        seriesLine.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        fillPath.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        Group areaGroup = new Group(fillPath,seriesLine);
        series.setNode(areaGroup);
        // create series Y multiplier
        DoubleProperty seriesYAnimMultiplier = new SimpleDoubleProperty(this, &quot;seriesYMultiplier&quot;);
        seriesYMultiplierMap.put(series, seriesYAnimMultiplier);
        // handle any data already in series
        if (shouldAnimate()) {
            seriesYAnimMultiplier.setValue(0d);
        } else {
            seriesYAnimMultiplier.setValue(1d);
        }
        getPlotChildren().add(areaGroup);
        List&lt;KeyFrame&gt; keyFrames = new ArrayList&lt;KeyFrame&gt;();
        if (shouldAnimate()) {
            // animate in new series
            keyFrames.add(new KeyFrame(Duration.ZERO,
                new KeyValue(areaGroup.opacityProperty(), 0),
                new KeyValue(seriesYAnimMultiplier, 0)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(200),
                new KeyValue(areaGroup.opacityProperty(), 1)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(500),
                new KeyValue(seriesYAnimMultiplier, 1)
            ));
        }
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            final Node symbol = createSymbol(series, seriesIndex, item, j);
            if (symbol != null) {
                if (shouldAnimate()) symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                if (shouldAnimate()) {
                    // fade in new symbol
                    keyFrames.add(new KeyFrame(Duration.ZERO, new KeyValue(symbol.opacityProperty(), 0)));
                    keyFrames.add(new KeyFrame(Duration.millis(200), new KeyValue(symbol.opacityProperty(), 1)));
                }
            }
        }
        if (shouldAnimate()) animate(keyFrames.toArray(new KeyFrame[keyFrames.size()]));
    }

    @Override protected  void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove series Y multiplier
        seriesYMultiplierMap.remove(series);
        // remove all symbol nodes
        if (shouldAnimate()) {
            Timeline tl = new Timeline(createSeriesRemoveTimeLine(series, 400));
            tl.play();
        } else {
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        // This override is necessary to update axis range based on cumulative Y value for the
        // Y axis instead of the normal way where max value in the data range is used.
        final Axis&lt;X&gt; xa = getXAxis();
        final Axis&lt;Y&gt; ya = getYAxis();
        if (xa.isAutoRanging()) {
            List xData = new ArrayList&lt;Number&gt;();
            for(Series&lt;X,Y&gt; series : getData()) {
                for(Data&lt;X,Y&gt; data: series.getData()) {
                    xData.add(data.getXValue());
                }
            }
            xa.invalidateRange(xData);
        }
        if (ya.isAutoRanging()) {
            double totalMinY = Double.MAX_VALUE;
            Iterator&lt;Series&lt;X, Y&gt;&gt; seriesIterator = getDisplayedSeriesIterator();
            boolean first = true;
            NavigableMap&lt;Double, Double&gt; accum = new TreeMap&lt;&gt;();
            NavigableMap&lt;Double, Double&gt; prevAccum = new TreeMap&lt;&gt;();
            NavigableMap&lt;Double, Double&gt; currentValues = new TreeMap&lt;&gt;();
            while (seriesIterator.hasNext()) {
                currentValues.clear();
                Series&lt;X, Y&gt; series = seriesIterator.next();
                for(Data&lt;X,Y&gt; item : series.getData()) {
                    if(item != null) {
                        final double xv = xa.toNumericValue(item.getXValue());
                        final double yv = ya.toNumericValue(item.getYValue());
                        currentValues.put(xv, yv);
                        if (first) {
                            // On the first pass, just fill the map
                            accum.put(xv, yv);
                            // minimum is applicable only in the first series
                            totalMinY = Math.min(totalMinY, yv);
                        } else {
                            if (prevAccum.containsKey(xv)) {
                                accum.put(xv, prevAccum.get(xv) + yv);
                            } else {
                                // If the point wasn't yet in the previous (accumulated) series
                                Map.Entry&lt;Double, Double&gt; he = prevAccum.higherEntry(xv);
                                Map.Entry&lt;Double, Double&gt; le = prevAccum.lowerEntry(xv);
                                if (he != null &amp;&amp; le != null) {
                                    // If there's both point above and below this point, interpolate
                                    accum.put(xv, ((xv - le.getKey()) / (he.getKey() - le.getKey())) *
                                            (le.getValue() + he.getValue()) + yv);
                                } else if (he != null) {
                                    // The point is before the first point in the previously accumulated series
                                    accum.put(xv, he.getValue() + yv);
                                } else if (le != null) {
                                    // The point is after the last point in the previously accumulated series
                                    accum.put(xv, le.getValue() + yv);
                                } else {
                                    // The previously accumulated series is empty
                                    accum.put(xv, yv);
                                }
                            }
                        }
                    }
                }
                // Now update all the keys that were in the previous series, but not in the new one
                for (Map.Entry&lt;Double, Double&gt; e : prevAccum.entrySet()) {
                    if (accum.keySet().contains(e.getKey())) {
                        continue;
                    }
                    Double k = e.getKey();
                    final Double v = e.getValue();
                    // Look at the values of the current series
                    Map.Entry&lt;Double, Double&gt; he = currentValues.higherEntry(k);
                    Map.Entry&lt;Double, Double&gt; le = currentValues.lowerEntry(k);
                    if (he != null &amp;&amp; le != null) {
                        // Interpolate the for the point from current series and add the accumulated value
                        accum.put(k, ((k - le.getKey()) / (he.getKey() - le.getKey())) *
                                (le.getValue() + he.getValue()) + v);
                    } else if (he != null) {
                        // There accumulated value is before the first value in the current series
                        accum.put(k, he.getValue() + v);
                    } else if (le != null) {
                        // There accumulated value is after the last value in the current series
                        accum.put(k, le.getValue() + v);
                    } else {
                        // The current series are empty
                        accum.put(k, v);
                    }

                }

                prevAccum.clear();
                prevAccum.putAll(accum);
                accum.clear();
                first = (totalMinY == Double.MAX_VALUE); // If there was already some value in the series, we can consider as
                                                         // being past the first series

            }
            if(totalMinY != Double.MAX_VALUE) ya.invalidateRange(Arrays.asList(ya.toRealValue(totalMinY),
<A NAME="16"></A>                    ya.toRealValue(Collections.max(prevAccum.values()))));

        }
    <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#16',2,'match42-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; currentSeriesData = new ArrayList&lt;&gt;();
        // AggregateData hold the data points of both the current and the previous series.
            // The goal is to collect all the data, sort it and iterate.
        ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; aggregateData = new</B></FONT> ArrayList&lt;&gt;();
        for (int seriesIndex=0; seriesIndex &lt; getDataSize(); seriesIndex++) { // for every series
            Series&lt;X, Y&gt; series = getData().get(seriesIndex);
            aggregateData.clear();
            // copy currentSeriesData accumulated in the previous iteration to aggregate.
            for(DataPointInfo&lt;X, Y&gt; data : currentSeriesData) {
                data.partOf = PartOf.PREVIOUS;
                aggregateData.add(data);
            }
            currentSeriesData.clear();
            // now copy actual data of the current series.
            for (Iterator&lt;Data&lt;X, Y&gt;&gt; it = getDisplayedDataIterator(series); it.hasNext(); ) {
                Data&lt;X, Y&gt; item = it.next();
                DataPointInfo&lt;X, Y&gt; itemInfo = new DataPointInfo&lt;&gt;(item, item.getXValue(),
                        item.getYValue(), PartOf.CURRENT);
                aggregateData.add(itemInfo);
            }
            DoubleProperty seriesYAnimMultiplier = seriesYMultiplierMap.get(series);
            Path seriesLine = (Path)((Group)series.getNode()).getChildren().get(1);
            Path fillPath = (Path)((Group)series.getNode()).getChildren().get(0);
            seriesLine.getElements().clear();
            fillPath.getElements().clear();
            int dataIndex = 0;
            // Sort data points from prev and current series
            sortAggregateList(aggregateData);

            Axis&lt;Y&gt; yAxis = getYAxis();
            Axis&lt;X&gt; xAxis = getXAxis();
            boolean firstCurrent = false;
            boolean lastCurrent = false;
            int firstCurrentIndex = findNextCurrent(aggregateData, -1);
            int lastCurrentIndex = findPreviousCurrent(aggregateData, aggregateData.size());
            double basePosition = yAxis.getZeroPosition();
            if (Double.isNaN(basePosition)) {
                ValueAxis&lt;Number&gt; valueYAxis = (ValueAxis&lt;Number&gt;) yAxis;
                if (valueYAxis.getLowerBound() &gt; 0) {
                    basePosition = valueYAxis.getDisplayPosition(valueYAxis.getLowerBound());
                } else {
                    basePosition = valueYAxis.getDisplayPosition(valueYAxis.getUpperBound());
                }
            }
            // Iterate over the aggregate data : this process accumulates data points
            // cumulatively from the bottom to top of stack

            for (DataPointInfo&lt;X, Y&gt; dataInfo : aggregateData) {
                if (dataIndex == lastCurrentIndex) lastCurrent = true;
                if (dataIndex == firstCurrentIndex) firstCurrent = true;
                final Data&lt;X,Y&gt; item = dataInfo.dataItem;
                if (dataInfo.partOf.equals(PartOf.CURRENT)) { // handle data from current series
                    int pIndex = findPreviousPrevious(aggregateData, dataIndex);
                    int nIndex = findNextPrevious(aggregateData, dataIndex);
                    DataPointInfo&lt;X, Y&gt; prevPoint;
                    DataPointInfo&lt;X, Y&gt; nextPoint;
                    if (pIndex == -1 || (nIndex == -1 &amp;&amp; !(aggregateData.get(pIndex).x.equals(dataInfo.x)))) {
                        if (firstCurrent) {
                            // Need to add the drop down point.
                            Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, 0);
                            addDropDown(currentSeriesData, ddItem, ddItem.getXValue(), ddItem.getYValue(),
                                    xAxis.getDisplayPosition(ddItem.getCurrentX()), basePosition);
                        }
                        double x = xAxis.getDisplayPosition(item.getCurrentX());
                        double y = yAxis.getDisplayPosition(
                                yAxis.toRealValue(yAxis.toNumericValue(item.getCurrentY()) * seriesYAnimMultiplier.getValue()));
                        addPoint(currentSeriesData, item, item.getXValue(), item.getYValue(), x, y,
                                PartOf.CURRENT, false, (firstCurrent) ? false : true);
                        if (dataIndex == lastCurrentIndex) {
                            // need to add drop down point
                            Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, 0);
                            addDropDown(currentSeriesData, ddItem, ddItem.getXValue(), ddItem.getYValue(),
                                    xAxis.getDisplayPosition(ddItem.getCurrentX()), basePosition);
                        }
                    } else {
                        prevPoint = aggregateData.get(pIndex);
                        if (prevPoint.x.equals(dataInfo.x)) { // Need to add Y values
                            // Check if prevPoint is a dropdown - as the stable sort preserves the order.
                            // If so, find the non dropdown previous point on previous series.
                            if (prevPoint.dropDown) {
                                pIndex = findPreviousPrevious(aggregateData, pIndex);
                                prevPoint = aggregateData.get(pIndex);
                                // If lastCurrent - add this drop down
                            }
                            if (prevPoint.x.equals(dataInfo.x)) { // simply add
                                double x = xAxis.getDisplayPosition(item.getCurrentX());
                                final double yv = yAxis.toNumericValue(item.getCurrentY()) + yAxis.toNumericValue(prevPoint.y);
                                double y = yAxis.getDisplayPosition(
                                        yAxis.toRealValue(yv * seriesYAnimMultiplier.getValue()));
                                addPoint(currentSeriesData, item, dataInfo.x, yAxis.toRealValue(yv), x, y, PartOf.CURRENT, false,
                                        (firstCurrent) ? false : true);
                            }
                            if (lastCurrent) {
                                addDropDown(currentSeriesData, item, prevPoint.x, prevPoint.y, prevPoint.displayX, prevPoint.displayY);
                            }
                        } else {
                            // interpolate
                            nextPoint = (nIndex == -1) ? null : aggregateData.get(nIndex);
                            prevPoint = (pIndex == -1) ? null : aggregateData.get(pIndex);
                            final double yValue = yAxis.toNumericValue(item.getCurrentY());
                            if (prevPoint != null &amp;&amp; nextPoint != null) {
                                double x = xAxis.getDisplayPosition(item.getCurrentX());
                                double displayY = interpolate(prevPoint.displayX,
                                        prevPoint.displayY, nextPoint.displayX, nextPoint.displayY, x);
                                double dataY = interpolate(xAxis.toNumericValue(prevPoint.x),
                                        yAxis.toNumericValue(prevPoint.y),
                                        xAxis.toNumericValue(nextPoint.x),
                                        yAxis.toNumericValue(nextPoint.y),
                                        xAxis.toNumericValue(dataInfo.x));
                                if (firstCurrent) {
                                    // now create the drop down point
                                    Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, dataY);
                                    addDropDown(currentSeriesData, ddItem, dataInfo.x, yAxis.toRealValue(dataY), x, displayY);
                                }
                                double y = yAxis.getDisplayPosition(yAxis.toRealValue((yValue + dataY) * seriesYAnimMultiplier.getValue()));
                                // Add the current point
                                addPoint(currentSeriesData, item, dataInfo.x, yAxis.toRealValue(yValue + dataY), x, y, PartOf.CURRENT, false,
                                        (firstCurrent) ? false : true);
                                if (dataIndex == lastCurrentIndex) {
                                    // add drop down point
                                    Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, dataY);
                                    addDropDown(currentSeriesData, ddItem, dataInfo.x, yAxis.toRealValue(dataY), x, displayY);
                                }
                                // Note: add drop down if last current
                            }
                            else {
                                // we do not need to take care of this as it is
                                // already handled above with check of if(pIndex == -1 or nIndex == -1)
                            }
                        }
                    }

                } else { // handle data from Previous series.
                    int pIndex = findPreviousCurrent(aggregateData, dataIndex);
                    int nIndex = findNextCurrent(aggregateData, dataIndex);
                    DataPointInfo&lt;X, Y&gt; prevPoint;
                    DataPointInfo&lt;X, Y&gt; nextPoint;
                    if (dataInfo.dropDown) {
                        if (xAxis.toNumericValue(dataInfo.x) &lt;=
                                xAxis.toNumericValue(aggregateData.get(firstCurrentIndex).x) ||
                                xAxis.toNumericValue(dataInfo.x) &gt; xAxis.toNumericValue(aggregateData.get(lastCurrentIndex).x)) {
                            addDropDown(currentSeriesData, item, dataInfo.x, dataInfo.y, dataInfo.displayX, dataInfo.displayY);
                        }
                    } else {
                        if (pIndex == -1 || nIndex == -1) {
                            addPoint(currentSeriesData, item, dataInfo.x, dataInfo.y, dataInfo.displayX, dataInfo.displayY,
                                    PartOf.CURRENT, true, false);
                        } else {
                            nextPoint = aggregateData.get(nIndex);
                            if (nextPoint.x.equals(dataInfo.x)) {
                                // do nothing as the current point is already there.
                            } else {
                                // interpolate on the current series.
                                prevPoint = aggregateData.get(pIndex);
                                double x = xAxis.getDisplayPosition(item.getCurrentX());
                                  double dataY = interpolate(xAxis.toNumericValue(prevPoint.x),
                                          yAxis.toNumericValue(prevPoint.y),
                                          xAxis.toNumericValue(nextPoint.x),
                                          yAxis.toNumericValue(nextPoint.y),
                                          xAxis.toNumericValue(dataInfo.x));
                                final double yv = yAxis.toNumericValue(dataInfo.y) + dataY;
                                double y = yAxis.getDisplayPosition(
                                        yAxis.toRealValue(yv * seriesYAnimMultiplier.getValue()));
                                addPoint(currentSeriesData, new Data(dataInfo.x, dataY), dataInfo.x, yAxis.toRealValue(yv), x, y, PartOf.CURRENT, true, true);
                            }
                        }
                    }
                }
                dataIndex++;
                if (firstCurrent) firstCurrent = false;
                if (lastCurrent) lastCurrent = false;
            } // end of inner for loop

            // Draw the SeriesLine and Series fill
            if (!currentSeriesData.isEmpty()) {
                seriesLine.getElements().add(new MoveTo(currentSeriesData.get(0).displayX, currentSeriesData.get(0).displayY));
                fillPath.getElements().add(new MoveTo(currentSeriesData.get(0).displayX, currentSeriesData.get(0).displayY));
            }
            for (DataPointInfo&lt;X, Y&gt; point : currentSeriesData) {
                if (point.lineTo) {
                    seriesLine.getElements().add(new LineTo(point.displayX, point.displayY));
                } else {
                    seriesLine.getElements().add(new MoveTo(point.displayX, point.displayY));
                }
                fillPath.getElements().add(new  LineTo(point.displayX, point.displayY));
                // draw symbols only for actual data points and skip for interpolated points.
                if (!point.skipSymbol) {
                    Node symbol = point.dataItem.getNode();
                    if (symbol != null) {
                        final double w = symbol.prefWidth(-1);
                        final double h = symbol.prefHeight(-1);
                        symbol.resizeRelocate(point.displayX-(w/2), point.displayY-(h/2),w,h);
                    }
                }
            }
            for(int i = aggregateData.size()-1; i &gt; 0; i--) {
                DataPointInfo&lt;X, Y&gt; point = aggregateData.get(i);
                if (PartOf.PREVIOUS.equals(point.partOf)) {
                    fillPath.getElements().add(new  LineTo(point.displayX, point.displayY));
                }
            }
            if (!fillPath.getElements().isEmpty()) {
                fillPath.getElements().add(new ClosePath());
            }

        }  // end of out for loop
     }

    private void addDropDown(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; currentSeriesData, Data&lt;X, Y&gt; item, X xValue, Y yValue, double x, double y) {
        DataPointInfo&lt;X, Y&gt; dropDownDataPoint = new DataPointInfo&lt;&gt;(true);
        dropDownDataPoint.setValues(item, xValue, yValue, x, y, PartOf.CURRENT, true, false);
        currentSeriesData.add(dropDownDataPoint);
    }

    private void addPoint(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; currentSeriesData, Data&lt;X, Y&gt; item, X xValue, Y yValue, double x, double y, PartOf partof,
                          boolean symbol, boolean lineTo) {
        DataPointInfo&lt;X, Y&gt; currentDataPoint = new DataPointInfo&lt;&gt;();
        currentDataPoint.setValues(item, xValue, yValue, x, y, partof, symbol, lineTo);
        currentSeriesData.add(currentDataPoint);
    }

    //-------------------- helper methods to retrieve data points from the previous
     // or current data series.
     private int findNextCurrent(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
        for(int i = index+1; i &lt; points.size(); i++) {
            if (points.get(i).partOf.equals(PartOf.CURRENT)) {
                return i;
            }
        }
        return -1;
     }

     private int findPreviousCurrent(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
        for(int i = index-1; i &gt;= 0; i--) {
            if (points.get(i).partOf.equals(PartOf.CURRENT)) {
                return i;
            }
        }
        return -1;
     }


    private int findPreviousPrevious(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
       for(int i = index-1; i &gt;= 0; i--) {
            if (points.get(i).partOf.equals(PartOf.PREVIOUS)) {
                return i;
            }
        }
        return -1;
    }
    private int findNextPrevious(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
        for(int i = index+1; i &lt; points.size(); i++) {
            if (points.get(i).partOf.equals(PartOf.PREVIOUS)) {
                return i;
            }
        }
        return -1;
    }


     private void sortAggregateList(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; aggregateList) {
        Collections.sort(aggregateList, (o1, o2) -&gt; {
            Data&lt;X,Y&gt; d1 = o1.dataItem;
            Data&lt;X,Y&gt; d2 = o2.dataItem;
            double val1 = getXAxis().toNumericValue(d1.getXValue());
            double val2 = getXAxis().toNumericValue(d2.getXValue());
            return (val1 &lt; val2 ? -1 : ( val1 == val2) ? 0 : 1);
        });
     }

    private double interpolate(double lowX, double lowY, double highX, double highY, double x) {
         // using y = mx+c find the y for the given x.
         return (((highY - lowY)/(highX - lowX))*(x - lowX))+lowY;
    }

    private Node createSymbol(Series&lt;X,Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node symbol = item.getNode();
        // check if symbol has already been created
        if (symbol == null &amp;&amp; getCreateSymbols()) {
            symbol = new StackPane();
            symbol.setAccessibleRole(AccessibleRole.TEXT);
            symbol.setAccessibleRoleDescription(&quot;Point&quot;);
            symbol.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(symbol);
        }
        // set symbol styles
        // Note not sure if we want to add or check, ie be more careful and efficient here
        if (symbol != null) symbol.getStyleClass().setAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex,
                series.defaultColorStyleClass);
        return symbol;
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + seriesIndex,
                &quot;area-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }

    // -------------- INNER CLASSES --------------------------------------------
    /*
     * Helper class to hold data and display and other information for each
     * data point
     */
    final static class DataPointInfo&lt;X, Y&gt; {
        X x;
        Y y;
        double displayX;
        double displayY;
        Data&lt;X,Y&gt; dataItem;
        PartOf partOf;
        boolean skipSymbol = false; // interpolated point - skip drawing symbol
        boolean lineTo = false; // should there be a lineTo to this point on SeriesLine.
        boolean dropDown = false; // Is this a drop down point ( non data point).

<A NAME="9"></A>        //----- Constructors --------------------
        DataPointInfo() {}

        DataPointInfo(Data&lt;X,Y&gt; item, X x, Y y, PartOf partOf) <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#9',2,'match42-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            this.dataItem = item;
            this.x = x;
            this.y = y;
            this.partOf = partOf;
        }

        DataPointInfo(boolean dropDown) {
            this.dropDown = dropDown;
        }

        void setV</B></FONT>alues(Data&lt;X,Y&gt; item, X x, Y y, double dx, double dy,
                        PartOf partOf, boolean skipSymbol, boolean lineTo) {
            this.dataItem = item;
            this.x = x;
            this.y = y;
            this.displayX = dx;
            this.displayY = dy;
            this.partOf = partOf;
            this.skipSymbol = skipSymbol;
            this.lineTo = lineTo;
        }

        public final X getX() {
            return x;
        }

        public final Y getY() {
            return y;
        }
    }

    // To indicate if the data point belongs to the current or the previous series.
    private static enum PartOf {
        CURRENT,
        PREVIOUS
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    private static class StyleableProperties {

        private static final CssMetaData&lt;StackedAreaChart&lt;?, ?&gt;, Boolean&gt; CREATE_SYMBOLS =
                new CssMetaData&lt;StackedAreaChart&lt;?, ?&gt;, Boolean&gt;(&quot;-fx-create-symbols&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {
            @Override
            public boolean isSettable(StackedAreaChart&lt;?,?&gt; node) {
                return node.createSymbols == null || !node.createSymbols.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(StackedAreaChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.createSymbolsProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CREATE_SYMBOLS);
            STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
         return StyleableProperties.STYLEABLES;
     }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/DialogEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control;

import javafx.beans.NamedArg;
import javafx.event.Event;
import javafx.event.EventTarget;
import javafx.event.EventType;

/**
 * Event related to dialog showing/hiding actions. In particular, this event is
 * used exclusively by the following methods:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link Dialog#onShowingProperty()}
 *   &lt;li&gt;{@link Dialog#onShownProperty()}
 *   &lt;li&gt;{@link Dialog#onHidingProperty()}
 *   &lt;li&gt;{@link Dialog#onCloseRequestProperty()}
 *   &lt;li&gt;{@link Dialog#onHiddenProperty()}
 * &lt;/ul&gt;
 *
 * @see Dialog
 * @since JavaFX 8u40
 */
public class DialogEvent extends Event {

    private static final long serialVersionUID = 20140716L;

    /**
     * Common supertype for all dialog event types.
     */
    public static final EventType&lt;DialogEvent&gt; ANY =
            new EventType&lt;DialogEvent&gt;(Event.ANY, &quot;DIALOG&quot;);

    /**
     * This event occurs on dialog just before it is shown.
     */
    public static final EventType&lt;DialogEvent&gt; DIALOG_SHOWING =
            new EventType&lt;DialogEvent&gt;(DialogEvent.ANY, &quot;DIALOG_SHOWING&quot;);

    /**
     * This event occurs on dialog just after it is shown.
     */
    public static final EventType&lt;DialogEvent&gt; DIALOG_SHOWN =
            new EventType&lt;DialogEvent&gt;(DialogEvent.ANY, &quot;DIALOG_SHOWN&quot;);

    /**
     * This event occurs on dialog just before it is hidden.
     */
    public static final EventType&lt;DialogEvent&gt; DIALOG_HIDING =
            new EventType&lt;DialogEvent&gt;(DialogEvent.ANY, &quot;DIALOG_HIDING&quot;);

    /**
     * This event occurs on dialog just after it is hidden.
     */
    public static final EventType&lt;DialogEvent&gt; DIALOG_HIDDEN =
            new EventType&lt;DialogEvent&gt;(DialogEvent.ANY, &quot;DIALOG_HIDDEN&quot;);

    /**
     * This event is delivered to a
     * dialog when there is an external request to close that dialog. If the
     * event is not consumed by any installed dialog event handler, the default
     * handler for this event closes the corresponding dialog.
     */
    public static final EventType&lt;DialogEvent&gt; DIALOG_CLOSE_REQUEST =
            new EventType&lt;DialogEvent&gt;(DialogEvent.ANY, &quot;DIALOG_CLOSE_REQUEST&quot;);

    /**
     * Construct a new {@code Event} with the specified event source, target
     * and type. If the source or target is set to {@code null}, it is replaced
     * by the {@code NULL_SOURCE_TARGET} value.
     *
     * @param source    the event source which sent the event
     * @param eventType the event type
<A NAME="59"></A>     */
    public DialogEvent(final @NamedArg(&quot;source&quot;) Dialog&lt;?&gt; source, final @NamedArg(&quot;eventType&quot;) EventType&lt;? extends Event&gt; eventType) {
        super(source, source, eventType);
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#59',2,'match42-top.html#59',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Returns a string representation of this {@code DialogEvent} object.
     * @return a string representation of this {@code DialogEvent} object.
     */
    @Override public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;DialogEvent [&quot;);

        sb.append(&quot;source = &quot;).append(getSource());
        sb.append</B></FONT>(&quot;, target = &quot;).append(getTarget());
        sb.append(&quot;, eventType = &quot;).append(getEventType());
        sb.append(&quot;, consumed = &quot;).append(isConsumed());

        return sb.append(&quot;]&quot;).toString();
    }

    @Override public DialogEvent copyFor(Object newSource, EventTarget newTarget) {
        return (DialogEvent) super.copyFor(newSource, newTarget);
    }

    /**
     * Creates a copy of the given event with the given fields substituted.
     * @param newSource the new source of the copied event
     * @param newTarget the new target of the copied event
     * @param type the new eventType
     * @return the event copy with the fields substituted
     */
    public DialogEvent copyFor(Object newSource, EventTarget newTarget, EventType&lt;DialogEvent&gt; type) {
        DialogEvent e = copyFor(newSource, newTarget);
        e.eventType = type;
        return e;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override public EventType&lt;DialogEvent&gt; getEventType() {
        return (EventType&lt;DialogEvent&gt;) super.getEventType();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/MultipleSelectionModelBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.collections.NonIterableChange;
import static javafx.scene.control.SelectionMode.SINGLE;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.sun.javafx.scene.control.MultipleAdditionAndRemovedChange;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableListBase;
import javafx.util.Callback;

import javafx.util.Pair;


/**
 * An abstract class that implements more of the abstract MultipleSelectionModel
 * abstract class. However, this class is package-protected and not intended
 * for public use.
 *
 * @param &lt;T&gt; The type of the underlying data model for the UI control.
 */
abstract class MultipleSelectionModelBase&lt;T&gt; extends MultipleSelectionModel&lt;T&gt; {

    /***********************************************************************
     *                                                                     *
     * Constructors                                                        *
     *                                                                     *
     **********************************************************************/

    public MultipleSelectionModelBase() {
        selectedIndexProperty().addListener(valueModel -&gt; {
            // we used to lazily retrieve the selected item, but now we just
            // do it when the selection changes. This is hardly likely to be
            // expensive, and we still lazily handle the multiple selection
            // cases over in MultipleSelectionModel.
            setSelectedItem(getModelItem(getSelectedIndex()));
        });

        selectedIndices = new SelectedIndicesList();

        selectedItems = new SelectedItemsReadOnlyObservableList&lt;T&gt;(selectedIndices, () -&gt; getItemCount()) {
            @Override protected T getModelItem(int index) {
                return MultipleSelectionModelBase.this.getModelItem(index);
            }
        };
    }



    /***********************************************************************
     *                                                                     *
     * Observable properties                                               *
     *                                                                     *
     **********************************************************************/

    /*
     * We only maintain the values of the selectedIndex and selectedIndices
     * properties. The value of the selectedItem and selectedItems properties
     * is determined on-demand. We fire the SELECTED_ITEM and SELECTED_ITEMS
     * property change events whenever the related SELECTED_INDEX or
     * SELECTED_INDICES properties change.
     *
     * This means that the cost of the ListViewSelectionModel is cheap in most
     * cases, assuming that the end-consumer isn't calling getSelectedItems
     * too aggressively. Of course, this is only an issue when the ListViewModel
     * is being populated by some remote, expensive to query data source.
     *
     * In addition, we do not provide ObservableLists for the selected indices or the
     * selected items properties, as this would allow the API consumer to add
     * observers to these ObservableLists. This would make life tougher as we would
     * then be forced to keep these ObservableLists in-sync at all times, which for
     * the selectedItems ObservableList, would require potentially a lot of work and
     * memory. Instead, we return a List, and allow for changes to these Lists
     * to be observed through the SELECTED_INDICES and SELECTED_ITEMS
     * properties.
     */


    final SelectedIndicesList selectedIndices;
    @Override public ObservableList&lt;Integer&gt; getSelectedIndices() {
        return selectedIndices;
    }

    private final ObservableListBase&lt;T&gt; selectedItems;
    @Override public ObservableList&lt;T&gt; getSelectedItems() {
        return selectedItems;
    }



    /***********************************************************************
     *                                                                     *
     * Internal field                                                      *
     *                                                                     *
     **********************************************************************/

    ListChangeListener.Change selectedItemChange;



    /***********************************************************************
     *                                                                     *
     * Public selection API                                                *
     *                                                                     *
     **********************************************************************/

    /**
     * Returns the number of items in the data model that underpins the control.
     * An example would be that a ListView selection model would likely return
     * &lt;code&gt;listView.getItems().size()&lt;/code&gt;. The valid range of selectable
     * indices is between 0 and whatever is returned by this method.
     * @return the number of items in the data model that underpins the control
     */
    protected abstract int getItemCount();

    /**
     * Returns the item at the given index. An example using ListView would be
     * &lt;code&gt;listView.getItems().get(index)&lt;/code&gt;.
     *
     * @param index The index of the item that is requested from the underlying
     *      data model.
     * @return Returns null if the index is out of bounds, or an element of type
     *      T that is related to the given index.
     */
    protected abstract T getModelItem(int index);
    protected abstract void focus(int index);
    protected abstract int getFocusedIndex();

    static class ShiftParams {
        private final int clearIndex;
        private final int setIndex;
        private final boolean selected;

        ShiftParams(int clearIndex, int setIndex, boolean selected) {
            this.clearIndex = clearIndex;
            this.setIndex = setIndex;
            this.selected = selected;
        }

        public final int getClearIndex() {
            return clearIndex;
        }

        public final int getSetIndex() {
            return setIndex;
        }

        public final boolean isSelected() {
            return selected;
        }
    }

    // package only
    void shiftSelection(int position, int shift, final Callback&lt;ShiftParams, Void&gt; callback) {
        shiftSelection(Arrays.asList(new Pair&lt;&gt;(position, shift)), callback);
    }

    void shiftSelection(List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts, final Callback&lt;ShiftParams, Void&gt; callback) {
        int selectedIndicesCardinality = selectedIndices.size(); // number of true bits
        if (selectedIndicesCardinality == 0) return;

        int selectedIndicesSize = selectedIndices.bitsetSize();   // number of bits reserved

        int[] perm = new int[selectedIndicesSize];
        Arrays.fill(perm, -1);

        // sort the list so that we iterate from highest position to lowest position
        Collections.sort(shifts, (s1, s2) -&gt; Integer.compare(s2.getKey(), s1.getKey()));
        final int lowestShiftPosition = shifts.get(shifts.size() - 1).getKey();

        // make a copy of the selectedIndices before so we can compare to it afterwards
        BitSet selectedIndicesCopy = (BitSet) selectedIndices.bitset.clone();

        startAtomic();
        for (Pair&lt;Integer, Integer&gt; shift : shifts) {
            doShift(shift, callback, perm);
        }
        stopAtomic();

        // strip out all useless -1 default values from the perm array
        final int[] prunedPerm = Arrays.stream(perm).filter(value -&gt; value &gt; -1).toArray();
        final boolean hasSelectionChanged = prunedPerm.length &gt; 0;

        // This ensure that the selection remains accurate when a shift occurs.
        final int selectedIndex = getSelectedIndex();
        if (selectedIndex &gt;= lowestShiftPosition &amp;&amp; selectedIndex &gt; -1) {
            // sum up the total shift, where the position is less than or equal
            // to the previously selected index
            int totalShift = shifts.stream()
                    .filter(shift -&gt; shift.getKey() &lt;= selectedIndex)
                    .mapToInt(shift -&gt; shift.getValue())
                    .sum();

            // Fix for RT-38787: we used to not enter this block if
            // selectedIndex + shift resulted in a value less than zero, whereas
            // now we just set the newSelectionLead to zero in that instance.
            // There exists unit tests that cover this.
            final int newSelectionLead = Math.max(0, selectedIndex + totalShift);

            setSelectedIndex(newSelectionLead);

            // added the selectedIndices call for RT-30356.
            // changed to check if hasPermutated, and to call select(..) for RT-40010.
            // This forces the selection event to go through the system and fire
            // the necessary events.
            if (hasSelectionChanged) {
                selectedIndices.set(newSelectionLead, true);
            } else {
                select(newSelectionLead);
            }

            // removed due to RT-27185
//            focus(newSelectionLead);
        }

        if (hasSelectionChanged) {
            // work out what indices were removed and added
            BitSet removed = (BitSet) selectedIndicesCopy.clone();
            removed.andNot(selectedIndices.bitset);

            BitSet added = (BitSet) selectedIndices.bitset.clone();
            added.andNot(selectedIndicesCopy);

            selectedIndices.reset();
            selectedIndices.callObservers(new MultipleAdditionAndRemovedChange&lt;&gt;(
                    added.stream().boxed().collect(Collectors.toList()),
                    removed.stream().boxed().collect(Collectors.toList()),
                    selectedIndices
            ));
        }
    }

    private void doShift(Pair&lt;Integer, Integer&gt; shiftPair, final Callback&lt;ShiftParams, Void&gt; callback, int[] perm) {
        final int position = shiftPair.getKey();
        final int shift = shiftPair.getValue();

        // with no check here, we get RT-15024
        if (position &lt; 0) return;
        if (shift == 0) return;

        int idx = (int) Arrays.stream(perm).filter(value -&gt; value &gt; -1).count();

        int selectedIndicesSize = selectedIndices.bitsetSize() - idx;   // number of bits reserved

        if (shift &gt; 0) {
            for (int i = selectedIndicesSize - 1; i &gt;= position &amp;&amp; i &gt;= 0; i--) {
                boolean selected = selectedIndices.isSelected(i);

                if (callback == null) {
                    selectedIndices.clear(i);
                    selectedIndices.set(i + shift, selected);
                } else {
                    callback.call(new ShiftParams(i, i + shift, selected));
                }

                if (selected) {
                    perm[idx++] = i + 1;
                }
            }
            selectedIndices.clear(position);
        } else if (shift &lt; 0) {
            for (int i = position; i &lt; selectedIndicesSize; i++) {
                if ((i + shift) &lt; 0) continue;
                if ((i + 1 + shift) &lt; position) continue;
                boolean selected = selectedIndices.isSelected(i + 1);

                if (callback == null) {
                    selectedIndices.clear(i + 1);
                    selectedIndices.set(i + 1 + shift, selected);
                } else {
                    callback.call(new ShiftParams(i + 1, i + 1 + shift, selected));
                }

                if (selected) {
                    perm[idx++] = i;
                }
            }
        }
    }

    void startAtomic() {
        selectedIndices.startAtomic();
    }

    void stopAtomic() {
        selectedIndices.stopAtomic();
    }

    boolean isAtomic() {
        return selectedIndices.isAtomic();
    }

    @Override public void clearAndSelect(int row) {
        if (row &lt; 0 || row &gt;= getItemCount()) {
            clearSelection();
            return;
        }

        final boolean wasSelected = isSelected(row);

        // RT-33558 if this method has been called with a given row, and that
        // row is the only selected row currently, then this method becomes a no-op.
        if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
            // before we return, we double-check that the selected item
            // is equal to the item in the given index
            if (getSelectedItem() == getModelItem(row)) {
                return;
            }
        }

        // firstly we make a copy of the selection, so that we can send out
        // the correct details in the selection change event.
        // We remove the new selection from the list seeing as it is not removed.
        BitSet selectedIndicesCopy = new BitSet();
        selectedIndicesCopy.or(selectedIndices.bitset);
        selectedIndicesCopy.clear(row);
        List&lt;Integer&gt; previousSelectedIndices = new SelectedIndicesList(selectedIndicesCopy);

        // RT-32411 We used to call quietClearSelection() here, but this
        // resulted in the selectedItems and selectedIndices lists never
        // reporting that they were empty.
        // makeAtomic toggle added to resolve RT-32618
        startAtomic();

        // then clear the current selection
        clearSelection();

        // and select the new row
        select(row);
        stopAtomic();

        // fire off a single add/remove/replace notification (rather than
        // individual remove and add notifications) - see RT-33324
        ListChangeListener.Change&lt;Integer&gt; change;

        /*
         * getFrom() documentation:
         *   If wasAdded is true, the interval contains all the values that were added.
         *   If wasPermutated is true, the interval marks the values that were permutated.
         *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
         *   return the same number - the place where the removed elements were positioned in the list.
         */
        if (wasSelected) {
            change = ControlUtils.buildClearAndSelectChange(selectedIndices, previousSelectedIndices, row);
        } else {
            int changeIndex = Math.max(0, selectedIndices.indexOf(row));
            change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                    changeIndex, changeIndex+1, previousSelectedIndices, selectedIndices);
        }

        selectedIndices.callObservers(change);
    }

    @Override public void select(int row) {
        if (row == -1) {
            clearSelection();
            return;
        }
        if (row &lt; 0 || row &gt;= getItemCount()) {
            return;
        }

        boolean isSameRow = row == getSelectedIndex();
        T currentItem = getSelectedItem();
        T newItem = getModelItem(row);
        boolean isSameItem = newItem != null &amp;&amp; newItem.equals(currentItem);
        boolean fireUpdatedItemEvent = isSameRow &amp;&amp; ! isSameItem;

        // focus must come first so that we have the anchors set appropriately
        focus(row);

        if (! selectedIndices.isSelected(row)) {
            if (getSelectionMode() == SINGLE) {
                startAtomic();
                quietClearSelection();
                stopAtomic();
            }
            selectedIndices.set(row);
        }

        setSelectedIndex(row);

        if (fireUpdatedItemEvent) {
            setSelectedItem(newItem);
        }
    }

    @Override public void select(T obj) {
//        if (getItemCount() &lt;= 0) return;

        if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
            clearSelection();
            return;
        }

        // We have no option but to iterate through the model and select the
        // first occurrence of the given object. Once we find the first one, we
        // don't proceed to select any others.
        Object rowObj = null;
        for (int i = 0, max = getItemCount(); i &lt; max; i++) {
            rowObj = getModelItem(i);
            if (rowObj == null) continue;

            if (rowObj.equals(obj)) {
                if (isSelected(i)) {
                    return;
                }

                if (getSelectionMode() == SINGLE) {
                    quietClearSelection();
                }

                select(i);
                return;
            }
        }

        // if we are here, we did not find the item in the entire data model.
        // Even still, we allow for this item to be set to the give object.
        // We expect that in concrete subclasses of this class we observe the
        // data model such that we check to see if the given item exists in it,
        // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
        setSelectedIndex(-1);
        setSelectedItem(obj);
    }

    @Override public void selectIndices(int row, int... rows) {
        if (rows == null || rows.length == 0) {
            select(row);
            return;
        }

        /*
         * Performance optimisation - if multiple selection is disabled, only
         * process the end-most row index.
         */

        int rowCount = getItemCount();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();

            for (int i = rows.length - 1; i &gt;= 0; i--) {
                int index = rows[i];
                if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                    selectedIndices.set(index);
                    select(index);
                    break;
                }
            }

            if (selectedIndices.isEmpty()) {
                if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                    selectedIndices.set(row);
                    select(row);
                }
            }
        } else {
            selectedIndices.set(row, rows);

            IntStream.concat(IntStream.of(row), IntStream.of(rows))
                     .filter(index -&gt; index &gt;= 0 &amp;&amp; index &lt; rowCount)
                     .reduce((first, second) -&gt; second)
                     .ifPresent(lastIndex -&gt; {
                         setSelectedIndex(lastIndex);
                         focus(lastIndex);
                         setSelectedItem(getModelItem(lastIndex));
                     });
        }
    }

    @Override public void selectAll() {
        if (getSelectionMode() == SINGLE) return;

        if (getItemCount() &lt;= 0) return;

        final int rowCount = getItemCount();
        final int focusedIndex = getFocusedIndex();

        // set all selected indices to true
        clearSelection();
        selectedIndices.set(0, rowCount, true);

        if (focusedIndex == -1) {
            setSelectedIndex(rowCount - 1);
            focus(rowCount - 1);
        } else {
            setSelectedIndex(focusedIndex);
            focus(focusedIndex);
        }
    }

    @Override public void selectFirst() {
        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (getItemCount() &gt; 0) {
            select(0);
        }
    }

    @Override public void selectLast() {
        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        int numItems = getItemCount();
        if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
            select(numItems - 1);
        }
    }

    @Override public void clearSelection(int index) {
        if (index &lt; 0) return;

        // TODO shouldn't directly access like this
        // TODO might need to update focus and / or selected index/item
        boolean wasEmpty = selectedIndices.isEmpty();
        selectedIndices.clear(index);

        if (! wasEmpty &amp;&amp; selectedIndices.isEmpty()) {
            clearSelection();
        }
    }

    @Override public void clearSelection() {
        quietClearSelection();

        if (! isAtomic()) {
            setSelectedIndex(-1);
            focus(-1);
        }
    }

    private void quietClearSelection() {
        selectedIndices.clear();
    }

    @Override public boolean isSelected(int index) {
        // Note the change in semantics here - we used to check to ensure that
        // the index is less than the item count, but now simply ensure that
        // it is less than the length of the selectedIndices bitset. This helps
        // to resolve issues such as RT-26721, where isSelected(int) was being
        // called for indices that exceeded the item count, as a TreeItem (e.g.
        // the root) was being collapsed.
//        if (index &gt;= 0 &amp;&amp; index &lt; getItemCount()) {
        if (index &gt;= 0 &amp;&amp; index &lt; selectedIndices.bitsetSize()) {
            return selectedIndices.isSelected(index);
        }

        return false;
    }

    @Override public boolean isEmpty() {
        return selectedIndices.isEmpty();
    }

    @Override public void selectPrevious() {
        int focusIndex = getFocusedIndex();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (focusIndex == -1) {
            select(getItemCount() - 1);
        } else if (focusIndex &gt; 0) {
            select(focusIndex - 1);
        }
    }

    @Override public void selectNext() {
        int focusIndex = getFocusedIndex();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (focusIndex == -1) {
            select(0);
        } else if (focusIndex != getItemCount() -1) {
            select(focusIndex + 1);
        }
    }



    /***********************************************************************
     *                                                                     *
     * Private implementation                                              *
     *                                                                     *
     **********************************************************************/

    class SelectedIndicesList extends ReadOnlyUnbackedObservableList&lt;Integer&gt; {
        private final BitSet bitset;

        private int lastGetIndex = -1;
        private int lastGetValue = -1;

        // Fix for RT-20945 (and numerous other issues!)
        private int atomicityCount = 0;

//        @Override
//        public void callObservers(Change&lt;Integer&gt; c) {
//            throw new RuntimeException(&quot;callObservers unavailable&quot;);
//        }

        public SelectedIndicesList() {
            this(new BitSet());
        }

        public SelectedIndicesList(BitSet bitset) {
            this.bitset = bitset;
        }

        boolean isAtomic() {
            return atomicityCount &gt; 0;
        }
        void startAtomic() {
            atomicityCount++;
        }
        void stopAtomic() {
            atomicityCount = Math.max(0, atomicityCount - 1);
        }

        // Returns the selected index at the given index.
        // e.g. if our selectedIndices are [1,3,5], then an index of 2 will return 5 here.
        @Override public Integer get(int index) {
            final int itemCount = size();
            if (index &lt; 0 || index &gt;= itemCount)  {
                throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot; + itemCount);
            }

            if (index == (lastGetIndex + 1) &amp;&amp; lastGetValue &lt; itemCount) {
                // we're iterating forward in order, short circuit for
                // performance reasons (RT-39776)
                lastGetIndex++;
                lastGetValue = bitset.nextSetBit(lastGetValue + 1);
                return lastGetValue;
            } else if (index == (lastGetIndex - 1) &amp;&amp; lastGetValue &gt; 0) {
                // we're iterating backward in order, short circuit for
                // performance reasons (RT-39776)
                lastGetIndex--;
                lastGetValue = bitset.previousSetBit(lastGetValue - 1);
                return lastGetValue;
            } else {
                for (lastGetIndex = 0, lastGetValue = bitset.nextSetBit(0);
                     lastGetValue &gt;= 0 || lastGetIndex == index;
                     lastGetIndex++, lastGetValue = bitset.nextSetBit(lastGetValue + 1)) {
                    if (lastGetIndex == index) {
                        return lastGetValue;
                    }
                }
            }

            return -1;
        }

        public void set(int index) {
            if (!isValidIndex(index) || isSelected(index)) {
                return;
            }

            _beginChange();
            bitset.set(index);
            int indicesIndex = indexOf(index);
            _nextAdd(indicesIndex, indicesIndex + 1);
            _endChange();
        }

        private boolean isValidIndex(int index) {
            return index &gt;= 0 &amp;&amp; index &lt; getItemCount();
        }

        public void set(int index, boolean isSet) {
            if (isSet) {
                set(index);
            } else {
                clear(index);
            }
        }

        public void set(int index, int end, boolean isSet) {
            _beginChange();
            if (isSet) {
                bitset.set(index, end, isSet);
                int indicesIndex = indexOf(index);
                int span = end - index;
                _nextAdd(indicesIndex, indicesIndex + span);
            } else {
                // TODO handle remove
                bitset.set(index, end, isSet);
            }
            _endChange();
        }

        public void set(int index, int... indices) {
            if (indices == null || indices.length == 0) {
                set(index);
            } else {
                // we reduce down to the minimal number of changes possible
                // by finding all contiguous indices, of all indices that are
<A NAME="73"></A>                // not already selected, and which are in the valid range
                startAtomic();
                List&lt;Integer&gt; sortedNewIndices =
                        <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#73',2,'match42-top.html#73',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>IntStream.concat(IntStream.of(index), IntStream.of(indices))
                        .distinct()
                        .filter(this::isValidIndex)
                        .filter(this::isNotSelected)
                        .sorted()
                        .boxed()
                        .peek(this::set) // we also set here, but it's atomic!
                        .collect(Collectors.toList());
                stopAtomic();

                final int size = sortedNewIndices.size();
                if</B></FONT> (size == 0) {
                    // no-op
                } else if (size == 1) {
                    _beginChange();
                    int _index = sortedNewIndices.get(0);
                    int indicesIndex = indexOf(_index);
                    _nextAdd(indicesIndex, indicesIndex + 1);
                    _endChange();
                } else {
                    _beginChange();
                    int pos = 0;
                    int start = 0;
                    int end = 0;

                    // starting from pos, we keep going until the value is
                    // not the next value
                    int startValue = sortedNewIndices.get(pos++);
                    start = indexOf(startValue);
                    end = start + 1;
                    int endValue = startValue;
                    while (pos &lt; size) {
                        int previousEndValue = endValue;
                        endValue = sortedNewIndices.get(pos++);
                        ++end;
                        if (previousEndValue != (endValue - 1)) {
                            _nextAdd(start, end);
                            start = end;
                            continue;
                        }

                        // special case for when we get to the point where the loop is about to end
                        // and we have uncommitted changes to fire.
                        if (pos == size) {
                            _nextAdd(start, start + pos);
                        }
                    }

                    _endChange();
                }
            }
        }

        public void clear() {
            _beginChange();
            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
            bitset.clear();
            _nextRemove(0, removed);
            _endChange();
        }

        public void clear(int index) {
            if (!bitset.get(index)) return;

            _beginChange();
            bitset.clear(index);
            _nextRemove(index, index);
            _endChange();
        }

//        public void clearAndSelect(int index) {
//            if (index &lt; 0 || index &gt;= getItemCount()) {
//                clearSelection();
//                return;
//            }
//
//            final boolean wasSelected = isSelected(index);
//
//            // RT-33558 if this method has been called with a given row, and that
//            // row is the only selected row currently, then this method becomes a no-op.
//            if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
//                // before we return, we double-check that the selected item
//                // is equal to the item in the given index
//                if (getSelectedItem() == getModelItem(index)) {
//                    return;
//                }
//            }
//
//            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
//            boolean isSelected = removed.contains(index);
//            if (isSelected) {
//                removed.remove((Object)index);
//            }
//
//            if (removed.isEmpty()) {
//                set(index);
//            }
//
//            bitset.clear();
//            bitset.set(index);
//            _beginChange();
//            if (isSelected) {
//                _nextRemove(0, removed);
//            } else {
//                _nextAdd(0, 1);
//                _nextRemove(0, removed);
//            }
//            _endChange();
//        }

        public boolean isSelected(int index) {
            return bitset.get(index);
        }

        public boolean isNotSelected(int index) {
            return !isSelected(index);
        }

        /** Returns number of true bits in BitSet */
        @Override public int size() {
            return bitset.cardinality();
        }

        /** Returns the number of bits reserved in the BitSet */
        public int bitsetSize() {
            return bitset.size();
        }

        @Override public int indexOf(Object obj) {
            reset();
            return super.indexOf(obj);
        }

        @Override public boolean contains(Object o) {
            if (o instanceof Number) {
                Number n = (Number) o;
                int index = n.intValue();

                return index &gt;= 0 &amp;&amp; index &lt; bitset.length() &amp;&amp;
                        bitset.get(index);
            }

            return false;
        }

        public void reset() {
            this.lastGetIndex = -1;
            this.lastGetValue = -1;
        }

        @Override public void _beginChange() {
            if (!isAtomic()) {
                super._beginChange();
            }
        }

        @Override public void _endChange() {
            if (!isAtomic()) {
                super._endChange();
            }
        }

        @Override public final void _nextUpdate(int pos) {
            if (!isAtomic()) {
                nextUpdate(pos);
            }
        }

        @Override public final void _nextSet(int idx, Integer old) {
            if (!isAtomic()) {
                nextSet(idx, old);
            }
        }

        @Override public final void _nextReplace(int from, int to, List&lt;? extends Integer&gt; removed) {
            if (!isAtomic()) {
                nextReplace(from, to, removed);
            }
        }

        @Override public final void _nextRemove(int idx, List&lt;? extends Integer&gt; removed) {
            if (!isAtomic()) {
                nextRemove(idx, removed);
            }
        }

        @Override public final void _nextRemove(int idx, Integer removed) {
            if (!isAtomic()) {
                nextRemove(idx, removed);
            }
        }

        @Override public final void _nextPermutation(int from, int to, int[] perm) {
            if (!isAtomic()) {
                nextPermutation(from, to, perm);
            }
        }

        @Override public final void _nextAdd(int from, int to) {
            if (!isAtomic()) {
                nextAdd(from, to);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextFormatter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.NamedArg;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.util.StringConverter;

import java.util.function.Consumer;
import java.util.function.UnaryOperator;

/**
 * A Formatter describes a format of a {@code TextInputControl} text by using two distinct mechanisms:
 * &lt;ul&gt;
 *     &lt;li&gt;A filter ({@link #getFilter()}) that can intercept and modify user input. This helps to keep the text
 *     in the desired format. A default text supplier can be used to provide the intial text.&lt;/li&gt;
 *     &lt;li&gt;A value converter ({@link #getValueConverter()}) and value ({@link #valueProperty()})
 *     can be used to provide special format that represents a value of type {@code V}.
 *     If the control is editable and the text is changed by the user, the value is then updated to correspond to the text.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * It's possible to have a formatter with just filter or value converter. If value converter is not provided however, setting a value will
 * result in an {@code IllegalStateException} and the value is always null.
 * &lt;p&gt;
 * Since {@code Formatter} contains a value which represents the state of the {@code TextInputControl} to which it is currently assigned, a single
 * {@code Formatter} instance can be used only in one {@code TextInputControl} at a time.
 *
 * @param &lt;V&gt; The type of the value
 * @since JavaFX 8u40
 */
public class TextFormatter&lt;V&gt; {
    private final StringConverter&lt;V&gt; valueConverter;
    private final UnaryOperator&lt;Change&gt; filter;

    private Consumer&lt;TextFormatter&lt;?&gt;&gt; textUpdater;

    /**
     * This string converter converts the text to the same String value. This might be useful for cases where you
     * want to manipulate with the text through the value or you need to provide a default text value.
     */
    public static final StringConverter&lt;String&gt; IDENTITY_STRING_CONVERTER = new StringConverter&lt;String&gt;() {
        @Override
        public String toString(String object) {
            return object == null ? &quot;&quot; : object;
        }
        @Override
        public String fromString(String string) {
            return string;
        }
    };


    /**
     * Creates a new Formatter with the provided filter.
     * @param filter The filter to use in this formatter or null
     */
    public TextFormatter(@NamedArg(&quot;filter&quot;) UnaryOperator&lt;Change&gt; filter) {
        this(null, null, filter);
    }

    /**
     * Creates a new Formatter with the provided filter, value converter and default value.
     * @param valueConverter The value converter to use in this formatter or null.
     * @param defaultValue the default value.
     * @param filter The filter to use in this formatter or null
     */
    public TextFormatter(@NamedArg(&quot;valueConverter&quot;) StringConverter&lt;V&gt; valueConverter,
                         @NamedArg(&quot;defaultValue&quot;) V defaultValue, @NamedArg(&quot;filter&quot;) UnaryOperator&lt;Change&gt; filter) {
        this.filter = filter;
        this.valueConverter = valueConverter;
        setValue(defaultValue);
    }

    /**
     * Creates a new Formatter with the provided value converter and default value.
     * @param valueConverter The value converter to use in this formatter. This must not be null.
     * @param defaultValue the default value
     */
    public TextFormatter(@NamedArg(&quot;valueConverter&quot;) StringConverter&lt;V&gt; valueConverter, @NamedArg(&quot;defaultValue&quot;) V defaultValue) {
        this(valueConverter, defaultValue, null);
    }

    /**
     * Creates a new Formatter with the provided value converter. The default value will be null.
     * @param valueConverter The value converter to use in this formatter. This must not be null.
     */
    public TextFormatter(@NamedArg(&quot;valueConverter&quot;) StringConverter&lt;V&gt; valueConverter) {
        this(valueConverter, null, null);
    }


    /**
     * The converter between the values and text.
     * It maintains a &quot;binding&quot; between the {@link javafx.scene.control.TextInputControl#textProperty()} }
     * and {@link #valueProperty()} }. The value is updated when the control loses it's focus or it is commited (TextField only).
     * Setting the value will update the text of the control, usin the provided converter.
     *
     * If it's impossible to convert text to value, an exception should be thrown.
     * @return StringConverter for values or null if none provided
     * @see javafx.scene.control.TextField#commitValue()
     * @see javafx.scene.control.TextField#cancelEdit()
     */
    public final StringConverter&lt;V&gt; getValueConverter() {
        return valueConverter;
    }

    /**
     * Filter allows user to intercept and modify any change done to the text content.
     * &lt;p&gt;
     * The filter itself is an {@code UnaryOperator} that accepts {@link javafx.scene.control.TextFormatter.Change} object.
     * It should return a {@link javafx.scene.control.TextFormatter.Change} object that contains the actual (filtered)
     * change. Returning null rejects the change.
     * @return the filter for this formatter or null if there is none
     */
    public final UnaryOperator&lt;Change&gt; getFilter() {
        return filter;
    }

    /**
     * The current value for this formatter. When the formatter is set on a {@code TextInputControl} and has a
     * {@code valueConverter}, the value is set by the control, when the text is commited.
     */
    private final ObjectProperty&lt;V&gt; value = new ObjectPropertyBase&lt;V&gt;() {

        @Override
        public Object getBean() {
            return TextFormatter.this;
        }

        @Override
        public String getName() {
            return &quot;value&quot;;
        }

        @Override
        protected void invalidated() {
            if (valueConverter == null &amp;&amp; get() != null) {
                if (isBound()) {
                    unbind();
                }
                throw new IllegalStateException(&quot;Value changes are not supported when valueConverter is not set&quot;);
            }
            updateText();
        }
    };

    public final ObjectProperty&lt;V&gt; valueProperty() {
        return value;
    }
    public final void setValue(V value) {
        if (valueConverter == null &amp;&amp; value != null) {
            throw new IllegalStateException(&quot;Value changes are not supported when valueConverter is not set&quot;);
        }
        this.value.set(value);
    }
    public final V getValue() {
        return value.get();
    }

    private void updateText() {
        if (textUpdater != null) {
            textUpdater.accept(this);
        }
    }

    void bindToControl(Consumer&lt;TextFormatter&lt;?&gt;&gt; updater) {
        if (textUpdater != null) {
            throw new IllegalStateException(&quot;Formatter is already used in other control&quot;);
        }
        this.textUpdater = updater;
    }

    void unbindFromControl() {
        this.textUpdater = null;
    }

    void updateValue(String text) {
        if (!value.isBound()) {
            try {
                V v = valueConverter.fromString(text);
                setValue(v);
            } catch (Exception e) {
                updateText(); // Set the text with the latest value
            }
        }
    }

    /**
     * Contains the state representing a change in the content or selection for a
     * TextInputControl. This object is passed to any registered
     * {@code formatter} on the TextInputControl whenever the text
     * for the TextInputControl is modified.
     * &lt;p&gt;
     *     This class contains state and convenience methods for determining what
     *     change occurred on the control. It also has a reference to the
     *     TextInputControl itself so that the developer may query any other
     *     state on the control. Note that you should never modify the state
     *     of the control directly from within the formatter handler.
     * &lt;/p&gt;
     * &lt;p&gt;
     *     The Change of the text is described by &lt;b&gt;range&lt;/b&gt; ({@link #getRangeStart()}, {@link #getRangeEnd()}) and
     *     text ({@link #getText()}. There are 3 cases that can occur:
     *     &lt;ul&gt;
     *         &lt;li&gt;&lt;b&gt;Some text was deleted:&lt;/b&gt; In this case, {@code text} is empty and {@code range} denotes the {@code range} of deleted text.
     *         E.g. In text &quot;Lorem ipsum dolor sit amet&quot;, removal of the second word would result in {@code range} being (6,11) and
     *         an empty {@code text}. Similarly, if you want to delete some different or additional text, just set the {@code range}.
     *         If you want to remove first word instead of the second, just call {@code setRange(0,5)}&lt;/li&gt;
     *         &lt;li&gt;&lt;b&gt;Some text was added:&lt;/b&gt; Now the {@code range} is empty (means nothing was deleted), but it's value is still important.
     *         Both the start and end of the {@code range} point to the index wheret the new text was added. E.g. adding &quot;ipsum &quot; to &quot;Lorem dolor sit amet&quot;
     *         would result in a change with {@code range} of (6,6) and {@code text} containing the String &quot;ipsum &quot;.&lt;/li&gt;
     *         &lt;li&gt;&lt;b&gt;Some text was replaced:&lt;/b&gt; The combination of the 2 cases above. Both {@code text} and {@code range} are not empty. The text in {@code range} is deleted
     *         and replaced by {@code text} in the Change. The new text is added instead of the old text, which is at the beginning of the {@code range}.
     *         E.g. when some text is being deleted, you can simply replace it by some placeholder text just by setting a new text
     *         ({@code setText(&quot;new text&quot;)})&lt;/li&gt;
     *     &lt;/ul&gt;
     * &lt;p&gt;
     *     The Change is mutable, but not observable. It should be used
     *     only for the life of a single change. It is intended that the
     *     Change will be modified from within the formatter.
     * &lt;/p&gt;
     * @since JavaFX 8u40
     */
    public static final class Change implements Cloneable {
        private final FormatterAccessor accessor;
        private Control control;
        int start;
        int end;
        String text;

        int anchor;
        int caret;

        Change(Control control, FormatterAccessor accessor,  int anchor, int caret) {
            this(control, accessor, caret, caret, &quot;&quot;, anchor, caret);
        }

        Change(Control control, FormatterAccessor accessor, int start, int end, String text) {
            this(control, accessor, start, end, text, start + text.length(), start + text.length());
        }

        // Restrict construction to TextInputControl only. Because we are the
        // only ones who can create this, we don't bother doing a check here
        // to make sure the arguments are within reason (they will be).
        Change(Control control, FormatterAccessor accessor, int start, int end, String text, int anchor, int caret) {
            this.control = control;
            this.accessor = accessor;
            this.start = start;
            this.end = end;
            this.text = text;
            this.anchor = anchor;
            this.caret = caret;
        }

        /**
         * Gets the control associated with this change.
         * @return The control associated with this change. This will never be null.
         */
        public final Control getControl() { return control; }

        /**
         * Gets the start index into the {@link TextInputControl#getText()}
         * for the modification. This will always be a value &amp;gt; 0 and
         * &amp;lt;= {@link TextInputControl#getLength()}.
         *
         * @return The start index
         */
        public final int getRangeStart() { return start; }

        /**
         * Gets the end index into the {@link TextInputControl#getText()}
         * for the modification. This will always be a value &amp;gt; {@link #getRangeStart()} and
         * &amp;lt;= {@link TextInputControl#getLength()}.
         *
         * @return The end index
         */
        public final int getRangeEnd() { return end; }

        /**
         * A method assigning both the start and end values
         * together, in such a way as to ensure they are valid with respect to
         * each other. The start must be less than or equal to the end.
         *
         * @param start The new start value. Must be a valid start value
         * @param end The new end value. Must be a valid end value
         */
        public final void setRange(int start, int end) {
            int length = accessor.getTextLength();
            if (start &lt; 0 || start &gt; length || end &lt; 0 || end &gt; length) {
                throw new IndexOutOfBoundsException();
            }
            this.start = start;
            this.end = end;
        }


        /**
         * Gets the new caret position. This value will always be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}
         *
         * @return The new caret position
         */
        public final int getCaretPosition() { return caret; }

        /**
         * Gets the new anchor. This value will always be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}
         *
         * @return The new anchor position
         */
        public final int getAnchor() { return anchor; }

        /**
         * Gets the current caret position of the control.
         * @return The previous caret position
         */
        public final int getControlCaretPosition() { return accessor.getCaret();}

        /**
         * Gets the current anchor position of the control.
         * @return The previous anchor
         */
        public final int getControlAnchor() { return accessor.getAnchor(); }

        /**
         * Sets the selection. The anchor and caret position values must be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}. Note that there
         * is an order dependence here, in that the positions should be
         * specified after the new text has been specified.
         *
         * @param newAnchor The new anchor position
         * @param newCaretPosition The new caret position
         */
        public final void selectRange(int newAnchor, int newCaretPosition) {
            if (newAnchor &lt; 0 || newAnchor &gt; accessor.getTextLength() - (end - start) + text.length()
                    || newCaretPosition &lt; 0 || newCaretPosition &gt; accessor.getTextLength() - (end - start) + text.length()) {
                throw new IndexOutOfBoundsException();
            }
            anchor = newAnchor;
            caret = newCaretPosition;
        }

        /**
         * Gets the selection of this change. Note that the selection range refers to {@link #getControlNewText()}, not
         * the current control text.
         * @return The selected range of this change.
         */
        public final IndexRange getSelection() {
            return IndexRange.normalize(anchor, caret);
        }


        /**
         * Sets the anchor. The anchor value must be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}. Note that there
         * is an order dependence here, in that the position should be
         * specified after the new text has been specified.
         *
         * @param newAnchor The new anchor position
         */
        public final void setAnchor(int newAnchor) {
            if (newAnchor &lt; 0 || newAnchor &gt; accessor.getTextLength() - (end - start) + text.length()) {
                throw new IndexOutOfBoundsException();
            }
            anchor = newAnchor;
        }

        /**
         * Sets the caret position. The caret position value must be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}. Note that there
         * is an order dependence here, in that the position should be
         * specified after the new text has been specified.
         *
         * @param newCaretPosition The new caret position
         */
        public final void setCaretPosition(int newCaretPosition) {
            if (newCaretPosition &lt; 0 || newCaretPosition &gt; accessor.getTextLength() - (end - start) + text.length()) {
                throw new IndexOutOfBoundsException();
            }
            caret = newCaretPosition;
        }

        /**
         * Gets the text used in this change. For example, this may be new
         * text being added, or text which is replacing all the control's text
         * within the range of start and end. Typically it is an empty string
         * only for cases where the range is being deleted.
         *
         * @return The text involved in this change. This will never be null.
         */
        public final String getText() { return text; }

        /**
         * Sets the text to use in this change. This is used to replace the
         * range from start to end, if such a range exists, or to insert text
         * at the position represented by start == end.
         *
         * @param value The text. This cannot be null.
         */
        public final void setText(String value) {
            if (value == null) throw new NullPointerException();
            text = value;
        }

        /**
         * This is the full text that control has before the change. To get the text
         * after this change, use {@link #getControlNewText()}.
         * @return the previous text of control
         */
        public final String getControlText() {
            return accessor.getText(0, accessor.getTextLength());
        }

        /**
         * Gets the complete new text which will be used on the control after
         * this change. Note that some controls (such as TextField) may do further
         * filtering after the change is made (such as stripping out newlines)
         * such that you cannot assume that the newText will be exactly the same
         * as what is finally set as the content on the control, however it is
         * correct to assume that this is the case for the purpose of computing
         * the new caret position and new anchor position (as those values supplied
         * will be modified as necessary after the control has stripped any
         * additional characters that the control might strip).
         *
         * @return The controls proposed new text at the time of this call, according
         *         to the state set for start, end, and text properties on this Change object.
         */
        public final String getControlNewText() {
            return accessor.getText(0, start) + text + accessor.getText(end, accessor.getTextLength());
        }

        /**
         * Gets whether this change was in response to text being added. Note that
         * after the Change object is modified by the formatter (by one
         * of the setters) the return value of this method is not altered. It answers
         * as to whether this change was fired as a result of text being added,
         * not whether text will end up being added in the end.
         *
         * @return true if text was being added
         */
        public final boolean isAdded() { return !text.isEmpty(); }

        /**
         * Gets whether this change was in response to text being deleted. Note that
         * after the Change object is modified by the formatter (by one
         * of the setters) the return value of this method is not altered. It answers
         * as to whether this change was fired as a result of text being deleted,
         * not whether text will end up being deleted in the end.
         *
         * @return true if text was being deleted
         */
        public final boolean isDeleted() { return start != end; }

        /**
         * Gets whether this change was in response to text being replaced. Note that
         * after the Change object is modified by the formatter (by one
         * of the setters) the return value of this method is not altered. It answers
         * as to whether this change was fired as a result of text being replaced,
         * not whether text will end up being replaced in the end.
         *
         * @return true if text was being replaced
         */
        public final boolean isReplaced() {
            return isAdded() &amp;&amp; isDeleted();
        }

        /**
         * The content change is any of add, delete or replace changes. Basically it's a shortcut for
         * {@code c.isAdded() || c.isDeleted() };
         * @return true if the content changed
<A NAME="43"></A>         */
        public final boolean isContentChange() {
            return isAdded() || isDeleted();
        <FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#43',2,'match42-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder(&quot;TextInputControl.Change [&quot;);
            if (isReplaced()) {</B></FONT>
                builder.append(&quot; replaced \&quot;&quot;).append(accessor.getText(start, end)).append(&quot;\&quot; with \&quot;&quot;).append(text).
                        append(&quot;\&quot; at (&quot;).append(start).append(&quot;, &quot;).append(end).append(&quot;)&quot;);
            } else if (isDeleted()) {
                builder.append(&quot; deleted \&quot;&quot;).append(accessor.getText(start, end)).
                        append(&quot;\&quot; at (&quot;).append(start).append(&quot;, &quot;).append(end).append(&quot;)&quot;);
            } else if (isAdded()) {
                builder.append(&quot; added \&quot;&quot;).append(text).append(&quot;\&quot; at &quot;).append(start);
            }
            if (isAdded() || isDeleted()) {
                builder.append(&quot;; &quot;);
            } else {
                builder.append(&quot; &quot;);
            }
            builder.append(&quot;new selection (anchor, caret): [&quot;).append(anchor).append(&quot;, &quot;).append(caret).append(&quot;]&quot;);
            builder.append(&quot; ]&quot;);
            return builder.toString();
        }

        @Override
        public Change clone() {
            try {
                return (Change) super.clone();
            } catch (CloneNotSupportedException e) {
                // Cannot happen
                throw new RuntimeException(e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextInputControl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.text.Font;

import java.text.BreakIterator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.util.Utils;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.scene.NodeHelper;
import javafx.util.StringConverter;

/**
 * Abstract base class for text input controls.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public abstract class TextInputControl extends Control {
    /**
     * Interface representing a text input's content. Since it is an ObservableStringValue,
     * you can also bind to, or observe the content.
     * @since JavaFX 2.0
     */
    protected interface Content extends ObservableStringValue {
        /**
         * Retrieves a subset of the content.
         *
         * @param start the start
         * @param end the end
         * @return a subset of the content
         */
        public String get(int start, int end);

        /**
         * Inserts a sequence of characters into the content.
         *
         * @param index the index
         * @param text the text string
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void insert(int index, String text, boolean notifyListeners);

        /**
         * Removes a sequence of characters from the content.
         *
         * @param start the start
         * @param end the end
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void delete(int start, int end, boolean notifyListeners);

        /**
         * Returns the number of characters represented by the content.
         * @return the number of characters
         */
        public int length();
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TextInputControl. The content is an immutable property and
     * must be specified (as non-null) at the time of construction.
     *
     * @param content a non-null implementation of Content.
     */
    protected TextInputControl(final Content content) {
        this.content = content;

        // Add a listener so that whenever the Content is changed, we notify
        // listeners of the text property that it is invalid.
        content.addListener(observable -&gt; {
            if (content.length() &gt; 0) {
                text.textIsNull = false;
            }
            text.controlContentHasChanged();
        });

        // Bind the length to be based on the length of the text property
        length.bind(new IntegerBinding() {
            { bind(text); }
            @Override protected int computeValue() {
                String txt = text.get();
                return txt == null ? 0 : txt.length();
            }
        });

        // Bind the selected text to be based on the selection and text properties
        selectedText.bind(new StringBinding() {
            { bind(selection, text); }
            @Override protected String computeValue() {
                String txt = text.get();
                IndexRange sel = selection.get();
                if (txt == null || sel == null) return &quot;&quot;;

                int start = sel.getStart();
                int end = sel.getEnd();
                int length = txt.length();
                if (end &gt; start + length) end = length;
                if (start &gt; length-1) start = end = 0;
                return txt.substring(start, end);
            }
        });

        focusedProperty().addListener((ob, o, n) -&gt; {
            if (n) {
                if (getTextFormatter() != null) {
                    updateText(getTextFormatter());
                }
            } else {
                commitValue();
            }
        });

        // Specify the default style class
        getStyleClass().add(&quot;text-input&quot;);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The default font to use for text in the TextInputControl. If the TextInputControl's text is
     * rich text then this font may or may not be used depending on the font
     * information embedded in the rich text, but in any case where a default
     * font is required, this font will be used.
     * @return the font property
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Font&gt; fontProperty() {
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {


                private boolean fontSetByCss = false;

                @Override
                public void applyStyle(StyleOrigin newOrigin, Font value) {

                    //
                    // RT-20727 - if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS
                    //
                    try {
                        // super.applyStyle calls set which might throw if value is bound.
                        // Have to make sure fontSetByCss is reset.
                        fontSetByCss = true;
                        super.applyStyle(newOrigin, value);
                    } catch(Exception e) {
                        throw e;
                    } finally {
                        fontSetByCss = false;
                    }

                }


                @Override
                public void set(Font value) {
                    final Font oldValue = get();
                    if (value == null ? oldValue == null : value.equals(oldValue)) {
                        return;
                    }
                    super.set(value);
                }

                @Override
                protected void invalidated() {
                    // RT-20727 - if font is changed by calling setFont, then
                    // css might need to be reapplied since font size affects
                    // calculated values for styles with relative values
                    if(fontSetByCss == false) {
                        NodeHelper.reapplyCSS(TextInputControl.this);
                    }
                }

                @Override
                public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }

                @Override
                public Object getBean() {
                    return TextInputControl.this;
                }

                @Override
                public String getName() {
                    return &quot;font&quot;;
                }
            };
        }
        return font;
    }

    private ObjectProperty&lt;Font&gt; font;
    public final void setFont(Font value) { fontProperty().setValue(value); }
    public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }

    /**
     * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
     * prompt text is displayed.
     *
     * @defaultValue An empty String
     * @since JavaFX 2.2
     */
    private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
        @Override protected void invalidated() {
            // Strip out newlines
            String txt = get();
            if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
                txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
                set(txt);
            }
        }
    };
    public final StringProperty promptTextProperty() { return promptText; }
    public final String getPromptText() { return promptText.get(); }
    public final void setPromptText(String value) { promptText.set(value); }


    /**
     * The property contains currently attached {@link TextFormatter}.
     * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
     *
     * @defaultValue null
     * @since JavaFX 8u40
     */
    private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {

        private TextFormatter&lt;?&gt; oldFormatter = null;

        @Override
        public Object getBean() {
            return TextInputControl.this;
        }

        @Override
        public String getName() {
            return &quot;textFormatter&quot;;
        }

        @Override
        protected void invalidated() {
            final TextFormatter&lt;?&gt; formatter = get();
            try {
                if (formatter != null) {
                    try {
                        formatter.bindToControl(f -&gt; updateText(f));
                    } catch (IllegalStateException e) {
                        if (isBound()) {
                            unbind();
                        }
                        set(null);
                        throw e;
                    }
                    if (!isFocused()) {
                        updateText(get());
                    }
                }

                if (oldFormatter != null) {
                    oldFormatter.unbindFromControl();
                }
            } finally {
                oldFormatter = formatter;
            }
        }
    };
    public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
    public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
    public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }

    private final Content content;
    /**
     * Returns the text input's content model.
     * @return the text input's content model
     */
    protected final Content getContent() {
        return content;
    }

    /**
     * The textual content of this TextInputControl.
     */
    private TextProperty text = new TextProperty();
    public final String getText() { return text.get(); }
    public final void setText(String value) { text.set(value); }
    public final StringProperty textProperty() { return text; }

    /**
     * The number of characters in the text input.
     */
    private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
    public final int getLength() { return length.get(); }
    public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }

    /**
     * Indicates whether this TextInputControl can be edited by the user.
     */
    private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
        }
    };
    public final boolean isEditable() { return editable.getValue(); }
    public final void setEditable(boolean value) { editable.setValue(value); }
    public final BooleanProperty editableProperty() { return editable; }

    /**
     * The current selection.
     */
    private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
    public final IndexRange getSelection() { return selection.getValue(); }
    public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }

    /**
     * Defines the characters in the TextInputControl which are selected
     */
    private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
    public final String getSelectedText() { return selectedText.get(); }
    public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }

    /**
     * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the anchor might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
    public final int getAnchor() { return anchor.get(); }
    public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }

    /**
     * The current position of the caret within the text.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the caretPosition might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
    public final int getCaretPosition() { return caretPosition.get(); }
    public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }

    private UndoRedoChange undoChangeHead = new UndoRedoChange();
    private UndoRedoChange undoChange = undoChangeHead;
    private boolean createNewUndoRecord = false;

    /**
     * The property describes if it's currently possible to undo the latest change of the content that was done.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
    public final boolean isUndoable() { return undoable.get(); }
    public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }


    /**
     * The property describes if it's currently possible to redo the latest change of the content that was undone.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
    public final boolean isRedoable() { return redoable.get(); }
    public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a subset of the text input's content.
     *
     * @param start must be a value between 0 and end - 1.
     * @param end must be less than or equal to the length
     * @return the subset of the text input's content
     */
    public String getText(int start, int end) {
        if (start &gt; end) {
            throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        return getContent().get(start, end);
    }

    /**
     * Appends a sequence of characters to the content.
     *
     * @param text a non null String
     */
    public void appendText(String text) {
        insertText(getLength(), text);
    }

    /**
     * Inserts a sequence of characters into the content.
     *
     * @param index The location to insert the text.
     * @param text The text to insert.
     */
    public void insertText(int index, String text) {
        replaceText(index, index, text);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param range The range of text to delete. The range object must not be null.
     *
     * @see #deleteText(int, int)
     */
    public void deleteText(IndexRange range) {
        replaceText(range, &quot;&quot;);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     */
    public void deleteText(int start, int end) {
        replaceText(start, end, &quot;&quot;);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param range The range of text to replace. The range object must not be null.
     * @param text The text that is to replace the range. This must not be null.
     *
     * @see #replaceText(int, int, String)
     */
    public void replaceText(IndexRange range, String text) {
        final int start = range.getStart();
        final int end = start + range.getLength();
        replaceText(start, end, text);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param text The text that is to replace the range. This must not be null.
     */
    public void replaceText(final int start, final int end, final String text) {
        if (start &gt; end) {
            throw new IllegalArgumentException();
        }

        if (text == null) {
            throw new NullPointerException();
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        if (!this.text.isBound()) {
            final int oldLength = getLength();
            TextFormatter&lt;?&gt; formatter = getTextFormatter();
            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
            if (formatter != null &amp;&amp; formatter.getFilter() != null) {
                change = formatter.getFilter().apply(change);
                if (change == null) {
                    return;
                }
            }

            // Update the content
            updateContent(change, oldLength == 0);

        }
    }

    private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
        final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
        String oldText = getText(change.start, change.end);
        int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
        if (newText.equals(oldText)) {
            // Undo record not required as there is no change in the text.
            return;
        }

        /*
         * A new undo record is created, if
         * 1. createNewUndoRecord is true, currently it is set to true for paste operation
         * 2. Text is selected and a character is typed
         * 3. This is the first operation to be added to undo record
         * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
         * 5. Space character is typed
         * 6. 2500 milliseconds are elapsed since the undo record was created
         * 7. Cursor position is changed and a character is typed
         * 8. A range of text is replaced programmatically using replaceText()
         * Otherwise, the last undo record is updated or discarded.
         */

        int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
        boolean isNewSpaceChar = false;
        if (newText.equals(&quot; &quot;)) {
            if (!UndoRedoChange.isSpaceCharSequence()) {
                isNewSpaceChar = true;
                UndoRedoChange.setSpaceCharSequence(true);
            }
        } else {
            UndoRedoChange.setSpaceCharSequence(false);
        }
        if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
                isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
                (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
            undoChange = undoChange.add(change.start, oldText, newText);
        } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
            // I know I am deleting, and am located at the end of the range of the current undo record
            if (undoChange.newText.length() &gt; 0) {
                undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
                if (undoChange.newText.isEmpty()) {
                    // throw away this undo change record
                    undoChange = undoChange.discard();
                }
            } else {
                if (change.start == endOfUndoChange) {
                    undoChange.oldText += oldText;
                } else { // end == endOfUndoChange
                    undoChange.oldText = oldText + undoChange.oldText;
                    undoChange.start--;
                }
            }
        } else {
            // I know I am adding, and am located at the end of the range of the current undo record
            undoChange.newText += newText;
        }
        updateUndoRedoState();
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * removing the current selection.
     */
    public void cut() {
        copy();
        IndexRange selection = getSelection();
        deleteText(selection.getStart(), selection.getEnd());
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * leaving the current selection.
     */
     public void copy() {
        final String selectedText = getSelectedText();
        if (selectedText.length() &gt; 0) {
            final ClipboardContent content = new ClipboardContent();
            content.putString(selectedText);
            Clipboard.getSystemClipboard().setContent(content);
        }
    }

    /**
     * Transfers the contents in the clipboard into this text,
     * replacing the current selection.  If there is no selection, the contents
     * in the clipboard is inserted at the current caret position.
     */
    public void paste() {
        final Clipboard clipboard = Clipboard.getSystemClipboard();
        if (clipboard.hasString()) {
            final String text = clipboard.getString();
            if (text != null) {
                createNewUndoRecord = true;
                try {
                    replaceSelection(text);
                } finally {
                    createNewUndoRecord = false;
                }
            }
        }
    }

    /**
     * Moves the selection backward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caretPosition.
     */
    public void selectBackward() {
        if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
            // because the anchor stays put, by moving the caret to the left
            // we ensure that a selection is registered and that it is correct
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
        }
    }

    /**
     * Moves the selection forward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caret forward.
     */
    public void selectForward() {
        final int textLength = getLength();
        if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.following(getCaretPosition()));
        }
    }

    /**
     * The break iterator instances for navigation over words and complex characters.
     */
    private BreakIterator charIterator;
    private BreakIterator wordIterator;

    /**
     * Moves the caret to the beginning of previous word. This function
     * also has the effect of clearing the selection.
     */
    public void previousWord() {
        previousWord(false);
    }

    /**
     * Moves the caret to the beginning of next word. This function
     * also has the effect of clearing the selection.
     */
    public void nextWord() {
        nextWord(false);
    }

    /**
     * Moves the caret to the end of the next word. This function
     * also has the effect of clearing the selection.
     */
    public void endOfNextWord() {
        endOfNextWord(false);
    }

    /**
     * Moves the caret to the beginning of previous word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of previous word.
     */
    public void selectPreviousWord() {
        previousWord(true);
    }

    /**
     * Moves the caret to the beginning of next word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of next word.
     */
    public void selectNextWord() {
        nextWord(true);
    }

    /**
     * Moves the caret to the end of the next word. This does not cause
     * the selection to be cleared.
     */
    public void selectEndOfNextWord() {
        endOfNextWord(true);
    }

    private void previousWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));

        // Skip the non-word region, then move/select to the beginning of the word.
        while (pos != BreakIterator.DONE &amp;&amp;
               !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
            pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
        }

        // move/select
        selectRange(select ? getAnchor() : pos, pos);
    }

    private void nextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
        int current = wordIterator.next();

        // Skip whitespace characters to the beginning of next word, but
        // stop at newline. Then move the caret or select a range.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                char ch = text.charAt(Utils.clamp(0, p, textLength-1));
                // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
                // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
                if (ch != ' ' &amp;&amp; ch != '\t') {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    private void endOfNextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
        int current = wordIterator.next();

        // skip the non-word region, then move/select to the end of the word.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    /**
     * Selects all text in the text input.
     */
    public void selectAll() {
        selectRange(0, getLength());
    }

    /**
     * Moves the caret to before the first char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void home() {
        // user wants to go to start
        selectRange(0, 0);
    }

    /**
     * Moves the caret to after the last char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void end() {
        // user wants to go to end
        final int textLength = getLength();
        if (textLength &gt; 0) {
            selectRange(textLength, textLength);
        }
    }

    /**
     * Moves the caret to before the first char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to before the first char.
     */
    public void selectHome() {
        selectRange(getAnchor(), 0);
    }

    /**
     * Moves the caret to after the last char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to after the last char.
     */
    public void selectEnd() {
        final int textLength = getLength();
        if (textLength &gt; 0) selectRange(getAnchor(), textLength);
    }

    /**
     * Deletes the character that precedes the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deletePreviousChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (dot &gt; 0) {
                // The caret is not at the beginning, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                // Note: Do not use charIterator here, because we do want to
                // break up clusters when deleting backwards.
                int p = Character.offsetByCodePoints(text, dot, -1);
                deleteText(p, dot);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Deletes the character that follows the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deleteNextChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final int textLength = getLength();
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
                // The caret is not at the end, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                if (charIterator == null) {
                    charIterator = BreakIterator.getCharacterInstance();
                }
                charIterator.setText(text);
                int p = charIterator.following(dot);
                deleteText(dot, p);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Moves the caret position forward. If there is no selection, then the
     * caret position is moved one character forward. If there is a selection,
     * then the caret position is moved to the end of the selection and
     * the selection cleared.
     */
    public void forward() {
        // user has moved caret to the right
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.max(dot, mark);
            selectRange(pos, pos);
        } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.following(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Moves the caret position backward. If there is no selection, then the
     * caret position is moved one character backward. If there is a selection,
     * then the caret position is moved to the beginning of the selection and
     * the selection cleared.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void backward() {
        // user has moved caret to the left
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.min(dot, mark);
            selectRange(pos, pos);
        } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.preceding(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Positions the caret to the position indicated by {@code pos}. This
     * function will also clear the selection.
     * @param pos the position
     */
    public void positionCaret(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        selectRange(p, p);
    }

    /**
     * Positions the caret to the position indicated by {@code pos} and extends
     * the selection, if there is one. If there is no selection, then a
     * selection is formed where the anchor is at the current caret position
     * and the caretPosition is moved to pos.
     * @param pos the position
     */
    public void selectPositionCaret(int pos) {
        selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
    }

    /**
     * Positions the anchor and caretPosition explicitly.
     * @param anchor the anchor
     * @param caretPosition the caretPosition
     */
    public void selectRange(int anchor, int caretPosition) {
        caretPosition = Utils.clamp(0, caretPosition, getLength());
        anchor = Utils.clamp(0, anchor, getLength());

        TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        if (formatter != null &amp;&amp; formatter.getFilter() != null) {
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return;
            }
        }

        updateContent(change, false);
    }

    private void doSelectRange(int anchor, int caretPosition) {
        this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
        this.anchor.set(Utils.clamp(0, anchor, getLength()));
        this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
        notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
    }

    /**
     * This function will extend the selection to include the specified pos.
     * This is different from selectPositionCaret in that it does not simply
     * move the caret. Rather, it will reposition the caret and anchor as necessary
     * to ensure that pos becomes the new caret and the far other end of the
     * selection becomes the anchor.
     * @param pos the position
     */
    public void extendSelection(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        int start = Math.min(dot, mark);
        int end = Math.max(dot, mark);
        if (p &lt; start) {
            selectRange(end, p);
        } else {
            selectRange(start, p);
        }
    }

    /**
     * Clears the text.
     */
    public void clear() {
        deselect();
        if (!text.isBound()) {
            setText(&quot;&quot;);
        }
    }

    /**
     * Clears the selection.
     */
    public void deselect() {
        // set the anchor equal to the caret position, which clears the selection
        // while also preserving the caret position
        selectRange(getCaretPosition(), getCaretPosition());
    }

    /**
     * Replaces the selection with the given replacement String. If there is
     * no selection, then the replacement text is simply inserted at the current
     * caret position. If there was a selection, then the selection is cleared
     * and the given replacement text inserted.
     * @param replacement the replacement string
     */
    public void replaceSelection(String replacement) {
        replaceText(getSelection(), replacement);
    }

    /**
     * If possible, undoes the last modification. If {@link #isUndoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void undo() {
        if (isUndoable()) {
            // Apply reverse change here
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (newText != null) {
                getContent().delete(start, start + newText.length(), oldText.isEmpty());
            }

            if (oldText != null) {
                getContent().insert(start, oldText, true);
                doSelectRange(start, start + oldText.length());
            } else {
                doSelectRange(start, start + newText.length());
            }

            undoChange = undoChange.prev;
        }
        updateUndoRedoState();
    }

    /**
     * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void redo() {
        if (isRedoable()) {
            // Apply change here
            undoChange = undoChange.next;
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (oldText != null) {
                getContent().delete(start, start + oldText.length(), newText.isEmpty());
            }

            if (newText != null) {
                getContent().insert(start, newText, true);
                doSelectRange(start + newText.length(), start + newText.length());
            } else {
                doSelectRange(start, start);
            }
        }
        updateUndoRedoState();
        // else beep ?
    }

    // Used by TextArea, although there are probably other better ways of
    // doing this.
    void textUpdated() { }

    private void resetUndoRedoState() {
        undoChange = undoChangeHead;
        undoChange.next = null;
        updateUndoRedoState();
    }

    private void updateUndoRedoState() {
        undoable.set(undoChange != undoChangeHead);
        redoable.set(undoChange.next != null);
    }

    private boolean filterAndSet(String value) {
<A NAME="10"></A>        // Send the new value through the textFormatter, if one exists.
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        int length = content.length();
        if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#10',2,'match42-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>text.isBound()) {
            TextFormatter.Change change = new TextFormatter.Change(
                    TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
            change = formatter.getFilter().apply(change);
            if (change == null) {</B></FONT>
                return false;
            }
            replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        } else {
            replaceText(0, length, value, 0, 0);
        }
        return true;
    }

    /**
     * This is what is ultimately called by every code path that will update
     * the content (except for undo / redo). The input into this method has
     * already run through the textFormatter where appropriate.
     *
     * @param start            The start index into the existing text which
     *                         will be replaced by the new value
     * @param end              The end index into the existing text which will
     *                         be replaced by the new value. As with
     *                         String.replace this is a lastIndex+1 value
     * @param value            The new text value
     * @param anchor           The new selection anchor after the change is made
     * @param caretPosition    The new selection caretPosition after the change
     *                         is made.
     * @return The amount of adjustment made to the end / anchor / caretPosition to
     *         accommodate for subsequent filtering (such as the filtering of
     *         new lines by the TextField)
     */
    private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
        // RT-16566: Need to take into account stripping of chars into the
        // final anchor &amp; caret position
        int length = getLength();
        int adjustmentAmount = 0;
        if (end != start) {
            getContent().delete(start, end, value.isEmpty());
            length -= (end - start);
        }
        if (value != null) {
            getContent().insert(start, value, true);
            adjustmentAmount = value.length() - (getLength() - length);
            anchor -= adjustmentAmount;
            caretPosition -= adjustmentAmount;
        }
        doSelectRange(anchor, caretPosition);
        return adjustmentAmount;
    }

    private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
        T value = formatter.getValue();
        StringConverter&lt;T&gt; converter = formatter.getValueConverter();
        if (converter != null) {
            String text = converter.toString(value);
            if (text == null) text = &quot;&quot;;
            replaceText(0, getLength(), text, text.length(), text.length());
        }
    }

    /**
     * Commit the current text and convert it to a value.
     * @since JavaFX 8u40
     */
    public final void commitValue() {
        if (getTextFormatter() != null) {
            getTextFormatter().updateValue(getText());
        }
    }

    /**
     * If the field is currently being edited, this call will set text to the last commited value.
     * @since JavaFX 8u40
     */
    public final void cancelEdit() {
        if (getTextFormatter() != null) {
            updateText(getTextFormatter());
        }
    }

    private FormatterAccessor accessor;

    private FormatterAccessor getFormatterAccessor() {
        if (accessor == null) {
            accessor = new TextInputControlFromatterAccessor();
        }
        return accessor;
    }


    /**
     * A little utility method for stripping out unwanted characters.
     *
     * @param txt
     * @param stripNewlines
     * @param stripTabs
     * @return The string after having the unwanted characters stripped out.
     */
    static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
        // Most of the time, when text is inserted, there are no illegal
        // characters. So we'll do a &quot;cheap&quot; check for illegal characters.
        // If we find one, we'll do a longer replace algorithm. In the
        // case of illegal characters, this may at worst be an O(2n) solution.
        // Strip out any characters that are outside the printed range
        if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
            StringBuilder s = new StringBuilder(txt.length());
            for (int i=0; i&lt;txt.length(); i++) {
                final char c = txt.charAt(i);
                if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
                    s.append(c);
                }
            }
            txt = s.toString();
        }
        return txt;
    }

    static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
        for (int i=0; i&lt;txt.length(); i++) {
            final char c = txt.charAt(i);
            if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
        }
        return false;
    }

    private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
        if (c == 0x7F) return true;
        if (c == 0xA) return newlineIllegal;
        if (c == 0x9) return tabIllegal;
        if (c &lt; 0x20) return true;
        return false;
    }

    // It can be bound, in which case we will force it to be an eager
    // binding so that we update the content eagerly
    // It can be bidirectionally bound, which basically will just work
    // If somebody changes the content directly, it will be notified and
    // send an invalidation event.
    private class TextProperty extends StringProperty {
        // This is used only when the property is bound
        private ObservableValue&lt;? extends String&gt; observable = null;
        // Added to the observable when bound
        private InvalidationListener listener = null;
        // Used for event handling
        private ExpressionHelper&lt;String&gt; helper = null;
        // The developer my set the Text property to null. Although
        // the Content must be given an empty String, we must still
        // treat the value as though it were null, so that a subsequent
        // getText() will return null.
        private boolean textIsNull = false;

        @Override public String get() {
            // Since we force eager binding and content is always up to date,
            // we just need to get it from content and not through the binding
            return textIsNull ? null : content.get();
        }

        @Override public void set(String value) {
            if (isBound()) {
                throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
            }
            doSet(value);
            markInvalid();
        }

        /**
         * Called whenever the content on the control has changed (as determined
         * by a listener on the content).
         */
        private void controlContentHasChanged() {
            markInvalid();
            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        }

        @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
            if (observable == null) {
                throw new NullPointerException(&quot;Cannot bind to null&quot;);
            }
            if (!observable.equals(this.observable)) {
                unbind();
                this.observable = observable;
                if (listener == null) {
                    listener = new Listener();
                }
                this.observable.addListener(listener);
                markInvalid();
                doSet(observable.getValue());
            }
        }

        @Override public void unbind() {
            if (observable != null) {
                doSet(observable.getValue());
                observable.removeListener(listener);
                observable = null;
            }
        }

        @Override public boolean isBound() {
            return observable != null;
        }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public Object getBean() {
            return TextInputControl.this;
        }

        @Override public String getName() {
            return &quot;text&quot;;
        }

        private void fireValueChangedEvent() {
            ExpressionHelper.fireValueChangedEvent(helper);
        }

        private void markInvalid() {
            fireValueChangedEvent();
        }

        /**
         * doSet is called whenever the setText() method was called directly
         * on the TextInputControl, or when the text property was bound,
         * unbound, or reacted to a binding invalidation. It is *not* called
         * when modifications to the content happened indirectly, such as
         * through the replaceText / replaceSelection methods.
         *
         * @param value The new value
         */
        private void doSet(String value) {
            // Guard against the null value.
            textIsNull = value == null;
            if (value == null) value = &quot;&quot;;

            if (!filterAndSet(value)) return;

            if (getTextFormatter() != null) {
                getTextFormatter().updateValue(getText());
            }

            textUpdated();

            // If the programmer has directly manipulated the text property
            // or has it bound up, then we will clear out any modifications
            // from the undo manager as we must suppose that the control is
            // being reused, for example, between forms.
            resetUndoRedoState();
        }

        private class Listener implements InvalidationListener {
            @Override
            public void invalidated(Observable valueModel) {
                // We now need to force it to be eagerly recomputed
                // because we need to push these changes to the
                // content model. Because changing the model ends
                // up calling invalidate and markInvalid, the
                // listeners will all be notified.
                doSet(observable.getValue());
            }
        }
    }

    /**
     * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
     * records the old and new text, and the start index. It also has
     * the links to the previous and next Changes in the chain. There
     * are two special UndoRedoChange objects in this chain representing the
     * head and the tail so we can have beforeFirst and afterLast
     * behavior as necessary.
     */
    static class UndoRedoChange {
        static long prevRecordTime;
        static final long CHANGE_DURATION = 2500; // milliseconds
        static boolean spaceCharSequence = false;
        int start;
        String oldText;
        String newText;
        UndoRedoChange prev;
        UndoRedoChange next;

        UndoRedoChange() { }

        public UndoRedoChange add(int start, String oldText, String newText) {
            UndoRedoChange c = new UndoRedoChange();
            c.start = start;
            c.oldText = oldText;
            c.newText = newText;
            c.prev = this;
            next = c;
            prevRecordTime = System.currentTimeMillis();
            return c;
        }

        static boolean hasChangeDurationElapsed() {
            return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
        }

        static void setSpaceCharSequence(boolean value) {
            spaceCharSequence = value;
        }
        static boolean isSpaceCharSequence() {
            return spaceCharSequence;
        }

        public UndoRedoChange discard() {
            prev.next = next;
            return prev;
        }

        // Handy to use when debugging, just put it in undo or redo
        // method or replaceText to see what is happening to the undo
        // history as it occurs.
        void debugPrint() {
            UndoRedoChange c = this;
            System.out.print(&quot;[&quot;);
            while (c != null) {
                System.out.print(c.toString());
                if (c.next != null) System.out.print(&quot;, &quot;);
                c = c.next;
            }
            System.out.println(&quot;]&quot;);
        }

        @Override public String toString() {
            if (oldText == null &amp;&amp; newText == null) {
                return &quot;head&quot;;
            }
            if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;added '&quot; + newText + &quot;' at index &quot; + start;
            } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;replaced '&quot; + oldText + &quot;' with '&quot; + newText + &quot;' at index &quot; + start;
            } else {
                return &quot;deleted '&quot; + oldText + &quot;' at index &quot; + start;
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/


    private static final PseudoClass PSEUDO_CLASS_READONLY
            = PseudoClass.getPseudoClass(&quot;readonly&quot;);

    private static class StyleableProperties {
        private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
            new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(TextInputControl n) {
                return n.font == null || !n.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
                return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FONT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                String text = getText();
                if (text == null || text.isEmpty()) {
                    text = getPromptText();
                }
                return text;
            }
            case EDITABLE: return isEditable();
            case SELECTION_START: return getSelection().getStart();
            case SELECTION_END: return getSelection().getEnd();
            case CARET_OFFSET: return getCaretPosition();
            case FONT: return getFont();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SET_TEXT: {
                String value = (String) parameters[0];
                if (value != null) setText(value);
                break;
            }
            case SET_TEXT_SELECTION: {
                Integer start = (Integer) parameters[0];
                Integer end = (Integer) parameters[1];
                if (start != null &amp;&amp; end != null) {
                    selectRange(start,  end);
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }

    private class TextInputControlFromatterAccessor implements FormatterAccessor {
        @Override
        public int getTextLength() {
            return TextInputControl.this.getLength();
        }

        @Override
        public String getText(int begin, int end) {
            return TextInputControl.this.getText(begin, end);
        }

        @Override
        public int getCaret() {
            return TextInputControl.this.getCaretPosition();
        }

        @Override
        public int getAnchor() {
            return TextInputControl.this.getAnchor();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/cell/ChoiceBoxTreeTableCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.cell;

import static javafx.scene.control.cell.CellUtils.createChoiceBox;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.Label;
import javafx.scene.control.TreeTableColumn;
import javafx.scene.control.TreeTableCell;
import javafx.util.Callback;
import javafx.util.StringConverter;

/**
 * A class containing a {@link TreeTableCell} implementation that draws a
 * {@link ChoiceBox} node inside the cell.
 *
 * &lt;p&gt;By default, the ChoiceBoxTreeTableCell is rendered as a {@link Label} when not
 * being edited, and as a ChoiceBox when in editing mode. The ChoiceBox will, by
 * default, stretch to fill the entire table cell.
 *
 * &lt;p&gt;To create a ChoiceBoxTreeTableCell, it is necessary to provide zero or more
 * items that will be shown to the user when the {@link ChoiceBox} menu is
 * showing. These items must be of the same type as the TreeTableColumn.
 *
 * @param &lt;S&gt; The type of the TreeTableView generic type
 * @param &lt;T&gt; The type of the elements contained within the TreeTableColumn.
 * @since JavaFX 8.0
 */
public class ChoiceBoxTreeTableCell&lt;S,T&gt; extends TreeTableCell&lt;S,T&gt; {

    /***************************************************************************
     *                                                                         *
     * Static cell factories                                                   *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a ChoiceBox cell factory for use in {@link TreeTableColumn} controls.
     * By default, the ChoiceBoxCell is rendered as a {@link Label} when not
     * being edited, and as a ChoiceBox when in editing mode. The ChoiceBox will,
     * by default, stretch to fill the entire list cell.
     *
     * @param &lt;S&gt; The type of the TreeTableView generic type
     * @param &lt;T&gt; The type of the elements contained within the TreeTableColumn.
     * @param items Zero or more items that will be shown to the user when the
     *      {@link ChoiceBox} menu is showing. These items must be of the same
     *      type as the TreeTableColumn. Note that it is up to the developer to set
     *      {@link EventHandler event handlers} to listen to edit events in the
     *      TreeTableColumn, and react accordingly. Methods of interest include
     *      {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) setOnEditStart},
     *      {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler) setOnEditCommit},
     *      and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) setOnEditCancel}.
     * @return A {@link Callback} that will return a TreeTableCell that is able to
     *      work on the type of element contained within the TreeTableColumn.
     */
    @SafeVarargs
    public static &lt;S,T&gt; Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt; forTreeTableColumn(final T... items) {
        return forTreeTableColumn(null, items);
    }

    /**
     * Creates a ChoiceBox cell factory for use in {@link TreeTableColumn} controls.
     * By default, the ChoiceBoxCell is rendered as a {@link Label} when not
     * being edited, and as a ChoiceBox when in editing mode. The ChoiceBox
     * will, by default, stretch to fill the entire list cell.
     *
     * @param &lt;S&gt; The type of the TreeTableView generic type
     * @param &lt;T&gt; The type of the elements contained within the TreeTableColumn.
     * @param converter A {@link StringConverter} to convert the given item (of type T)
     *      to a String for displaying to the user.
     * @param items Zero or more items that will be shown to the user when the
     *      {@link ChoiceBox} menu is showing. These items must be of the same
     *      type as the TreeTableColumn. Note that it is up to the developer to set
     *      {@link EventHandler event handlers} to listen to edit events in the
     *      TreeTableColumn, and react accordingly. Methods of interest include
     *      {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) setOnEditStart},
     *      {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler) setOnEditCommit},
     *      and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) setOnEditCancel}.
     * @return A {@link Callback} that will return a TreeTableCell that is able to
     *      work on the type of element contained within the TreeTableColumn.
     */
    @SafeVarargs
    public static &lt;S,T&gt; Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt; forTreeTableColumn(
            final StringConverter&lt;T&gt; converter,
            final T... items) {
        return forTreeTableColumn(converter, FXCollections.observableArrayList(items));
    }

    /**
     * Creates a ChoiceBox cell factory for use in {@link TreeTableColumn} controls.
     * By default, the ChoiceBoxCell is rendered as a {@link Label} when not
     * being edited, and as a ChoiceBox when in editing mode. The ChoiceBox will,
     * by default, stretch to fill the entire list cell.
     *
     * @param &lt;S&gt; The type of the TreeTableView generic type
     * @param &lt;T&gt; The type of the elements contained within the TreeTableColumn.
     * @param items Zero or more items that will be shown to the user when the
     *      {@link ChoiceBox} menu is showing. These items must be of the same
     *      type as the TreeTableColumn. Note that it is up to the developer to set
     *      {@link EventHandler event handlers} to listen to edit events in the
     *      TreeTableColumn, and react accordingly. Methods of interest include
     *      {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) setOnEditStart},
     *      {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler) setOnEditCommit},
     *      and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) setOnEditCancel}.
     * @return A {@link Callback} that will return a TreeTableCell that is able to
     *      work on the type of element contained within the TreeTableColumn.
     */
    public static &lt;S,T&gt; Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt; forTreeTableColumn(
            final ObservableList&lt;T&gt; items) {
        return forTreeTableColumn(null, items);
    }

    /**
     * Creates a ChoiceBox cell factory for use in {@link TreeTableColumn} controls.
     * By default, the ChoiceBoxCell is rendered as a {@link Label} when not
     * being edited, and as a ChoiceBox when in editing mode. The ChoiceBox will,
     * by default, stretch to fill the entire list cell.
     *
     * @param &lt;S&gt; The type of the TreeTableView generic type
     * @param &lt;T&gt; The type of the elements contained within the TreeTableColumn.
     * @param converter A {@link StringConverter} to convert the given item (of type T)
     * to a String for displaying to the user.
     * @param items Zero or more items that will be shown to the user when the
     *      {@link ChoiceBox} menu is showing. These items must be of the same
     *      type as the TreeTableColumn. Note that it is up to the developer to set
     *      {@link EventHandler event handlers} to listen to edit events in the
     *      TreeTableColumn, and react accordingly. Methods of interest include
     *      {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) setOnEditStart},
     *      {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler) setOnEditCommit},
     *      and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) setOnEditCancel}.
     * @return A {@link Callback} that will return a TreeTableCell that is able to
     *      work on the type of element contained within the TreeTableColumn.
     */
    public static &lt;S,T&gt; Callback&lt;TreeTableColumn&lt;S,T&gt;, TreeTableCell&lt;S,T&gt;&gt; forTreeTableColumn(
            final StringConverter&lt;T&gt; converter,
            final ObservableList&lt;T&gt; items) {
        return list -&gt; new ChoiceBoxTreeTableCell&lt;S,T&gt;(converter, items);
    }



    /***************************************************************************
     *                                                                         *
     * Fields                                                                  *
     *                                                                         *
     **************************************************************************/

    private final ObservableList&lt;T&gt; items;

    private ChoiceBox&lt;T&gt; choiceBox;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default ChoiceBoxTreeTableCell with an empty items list.
     */
    public ChoiceBoxTreeTableCell() {
        this(FXCollections.&lt;T&gt;observableArrayList());
    }

    /**
     * Creates a default {@link ChoiceBoxTreeTableCell} instance with the given items
     * being used to populate the {@link ChoiceBox} when it is shown.
     *
     * @param items The items to show in the ChoiceBox popup menu when selected
     *      by the user.
     */
    @SafeVarargs
    public ChoiceBoxTreeTableCell(T... items) {
        this(FXCollections.observableArrayList(items));
    }

    /**
     * Creates a {@link ChoiceBoxTreeTableCell} instance with the given items
     * being used to populate the {@link ChoiceBox} when it is shown, and the
     * {@link StringConverter} being used to convert the item in to a
     * user-readable form.
     *
     * @param converter A {@link StringConverter} that can convert an item of type T
     *      into a user-readable string so that it may then be shown in the
     *      ChoiceBox popup menu.
     * @param items The items to show in the ChoiceBox popup menu when selected
     *      by the user.
     */
    @SafeVarargs
    public ChoiceBoxTreeTableCell(StringConverter&lt;T&gt; converter, T... items) {
        this(converter, FXCollections.observableArrayList(items));
    }

    /**
     * Creates a default {@link ChoiceBoxTreeTableCell} instance with the given items
     * being used to populate the {@link ChoiceBox} when it is shown.
     *
     * @param items The items to show in the ChoiceBox popup menu when selected
     *      by the user.
     */
    public ChoiceBoxTreeTableCell(ObservableList&lt;T&gt; items) {
        this(null, items);
    }

    /**
     * Creates a {@link ChoiceBoxTreeTableCell} instance with the given items
     * being used to populate the {@link ChoiceBox} when it is shown, and the
     * {@link StringConverter} being used to convert the item in to a
     * user-readable form.
     *
     * @param converter A {@link StringConverter} that can convert an item of type T
     *      into a user-readable string so that it may then be shown in the
     *      ChoiceBox popup menu.
     * @param items The items to show in the ChoiceBox popup menu when selected
     *      by the user.
     */
    public ChoiceBoxTreeTableCell(StringConverter&lt;T&gt; converter, ObservableList&lt;T&gt; items) {
        this.getStyleClass().add(&quot;choice-box-tree-table-cell&quot;);
        this.items = items;
        setConverter(converter != null ? converter : CellUtils.&lt;T&gt;defaultStringConverter());
    }


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- converter
    private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter =
            new SimpleObjectProperty&lt;StringConverter&lt;T&gt;&gt;(this, &quot;converter&quot;);

    /**
     * The {@link StringConverter} property.
     * @return the {@link StringConverter} property
     */
    public final ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() {
        return converter;
    }

    /**
     * Sets the {@link StringConverter} to be used in this cell.
     * @param value the {@link StringConverter} to be used in this cell
     */
    public final void setConverter(StringConverter&lt;T&gt; value) {
        converterProperty().set(value);
    }

    /**
     * Returns the {@link StringConverter} used in this cell.
     * @return the {@link StringConverter} used in this cell
     */
    public final StringConverter&lt;T&gt; getConverter() {
        return converterProperty().get();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the items to be displayed in the ChoiceBox when it is showing.
     * @return the items to be displayed in the ChoiceBox when it is showing
     */
    public ObservableList&lt;T&gt; getItems() {
        return items;
    }

    /** {@inheritDoc} */
    @Override public void startEdit() {
        if (! isEditable() || ! getTreeTableView().isEditable() || ! getTableColumn().isEditable()) {
            return;
        }

        if (choiceBox == null) {
            choiceBox = createChoiceBox(this, items, converterProperty());
        }
<A NAME="27"></A>
        choiceBox.getSelectionModel().select(getItem());

        <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#27',2,'match42-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.startEdit();
        setText(null);
        setGraphic(choiceBox);
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        super.cancelEdit();

        setText(getConverter().toString(getItem()));
        setGraphic</B></FONT>(null);
    }

    /** {@inheritDoc} */
    @Override public void updateItem(T item, boolean empty) {
        super.updateItem(item, empty);
        CellUtils.updateItem(this, getConverter(), null, null, choiceBox);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/cell/ComboBoxListCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.cell;

import static javafx.scene.control.cell.CellUtils.createComboBox;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.*;
import javafx.util.Callback;
import javafx.util.StringConverter;

/**
 * A class containing a {@link ListCell} implementation that draws a
 * {@link ComboBox} node inside the cell.
 *
 * &lt;p&gt;By default, the ComboBoxListCell is rendered as a {@link Label} when not
 * being edited, and as a ComboBox when in editing mode. The ComboBox will, by
 * default, stretch to fill the entire list cell.
 *
 * &lt;p&gt;To create a ComboBoxListCell, it is necessary to provide zero or more
 * items that will be shown to the user when the {@link ComboBox} menu is
 * showing. These items must be of the same type as the ListView items sequence,
 * such that upon selection, they replace the existing value in the
 * {@link ListView#itemsProperty() items} list.
 *
 * @param &lt;T&gt; The type of the elements contained within the ListView.
 * @since JavaFX 2.2
 */
public class ComboBoxListCell&lt;T&gt; extends ListCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Static cell factories                                                   *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a ComboBox cell factory for use in {@link ListView} controls. By
     * default, the ComboBoxCell is rendered as a {@link Label} when not being
     * edited, and as a ComboBox when in editing mode. The ComboBox will, by
     * default, stretch to fill the entire list cell.
     *
     * @param &lt;T&gt; The type of the elements contained within the ListView.
     * @param items Zero or more items that will be shown to the user when the
     *      {@link ComboBox} menu is showing. These items must be of the same
     *      type as the ListView items list, such that upon selection, they
     *      replace the existing value in the
     *      {@link ListView#itemsProperty() items} list.
     * @return A {@link Callback} that will return a ListCell that is able to
     *      work on the type of element contained within the ListView.
     */
    @SafeVarargs
    public static &lt;T&gt; Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; forListView(final T... items) {
        return forListView(FXCollections.observableArrayList(items));
    }

    /**
     * Creates a ComboBox cell factory for use in {@link ListView} controls. By
     * default, the ComboBoxCell is rendered as a {@link Label} when not being
     * edited, and as a ComboBox when in editing mode. The ComboBox will, by
     * default, stretch to fill the entire list cell.
     *
     * @param &lt;T&gt; The type of the elements contained within the ListView.
     * @param converter A {@link StringConverter} to convert the given item (of
     *      type T) to a String for displaying to the user.
     * @param items Zero or more items that will be shown to the user when the
     *      {@link ComboBox} menu is showing. These items must be of the same
     *      type as the ListView items list, such that
     *      upon selection, they replace the existing value in the
     *      {@link ListView#itemsProperty() items} list.
     * @return A {@link Callback} that will return a ListCell that is able to
     *      work on the type of element contained within the ListView.
     */
    @SafeVarargs
    public static &lt;T&gt; Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; forListView(
                final StringConverter&lt;T&gt; converter,
                final T... items) {
        return forListView(converter, FXCollections.observableArrayList(items));
    }

    /**
     * Creates a ComboBox cell factory for use in {@link ListView} controls. By
     * default, the ComboBoxCell is rendered as a {@link Label} when not being
     * edited, and as a ComboBox when in editing mode. The ComboBox will, by
     * default, stretch to fill the entire list cell.
     *
     * @param &lt;T&gt; The type of the elements contained within the ListView.
     * @param items An {@link ObservableList} containing zero or more items that
     *      will be shown to the user when the {@link ComboBox} menu is showing.
     *      These items must be of the same type as the ListView items sequence,
     *      such that upon selection, they replace the existing value in the
     *      {@link ListView#itemsProperty() items} list.
     * @return A {@link Callback} that will return a ListCell that is able to
     *      work on the type of element contained within the ListView.
     */
    public static &lt;T&gt; Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; forListView(
            final ObservableList&lt;T&gt; items) {
        return forListView(null, items);
    }

    /**
     * Creates a ComboBox cell factory for use in {@link ListView} controls. By
     * default, the ComboBoxCell is rendered as a {@link Label} when not being
     * edited, and as a ComboBox when in editing mode. The ComboBox will, by
     * default, stretch to fill the entire list cell.
     *
     * @param &lt;T&gt; The type of the elements contained within the ListView.
     * @param converter A {@link StringConverter} to convert the given item (of
     *      type T) to a String for displaying to the user.
     * @param items An {@link ObservableList} containing zero or more items that
     *      will be shown to the user when the {@link ComboBox} menu is showing.
     *      These items must be of the same type as the ListView items sequence,
     *      such that upon selection, they replace the existing value in the
     *      {@link ListView#itemsProperty() items} list.
     * @return A {@link Callback} that will return a ListCell that is able to
     *      work on the type of element contained within the ListView.
     */
    public static &lt;T&gt; Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; forListView(
            final StringConverter&lt;T&gt; converter,
            final ObservableList&lt;T&gt; items) {
        return list -&gt; new ComboBoxListCell&lt;T&gt;(converter, items);
    }



    /***************************************************************************
     *                                                                         *
     * Fields                                                                  *
     *                                                                         *
     **************************************************************************/

    private final ObservableList&lt;T&gt; items;

    private ComboBox&lt;T&gt; comboBox;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default ComboBoxListCell with an empty items list.
     */
    public ComboBoxListCell() {
        this(FXCollections.&lt;T&gt;observableArrayList());
    }

    /**
     * Creates a default {@link ComboBoxListCell} instance with the given items
     * being used to populate the {@link ComboBox} when it is shown.
     *
     * @param items The items to show in the ComboBox popup menu when selected
     *      by the user.
     */
    @SafeVarargs
    public ComboBoxListCell(T... items) {
        this(FXCollections.observableArrayList(items));
    }

    /**
     * Creates a {@link ComboBoxListCell} instance with the given items
     * being used to populate the {@link ComboBox} when it is shown, and the
     * {@link StringConverter} being used to convert the item in to a
     * user-readable form.
     *
     * @param converter A {@link StringConverter} that can convert an item of
     *      type T into a user-readable string so that it may then be shown in
     *      the ComboBox popup menu.
     * @param items The items to show in the ComboBox popup menu when selected
     *      by the user.
     */
    @SafeVarargs
    public ComboBoxListCell(StringConverter&lt;T&gt; converter, T... items) {
        this(converter, FXCollections.observableArrayList(items));
    }

    /**
     * Creates a default {@link ComboBoxListCell} instance with the given items
     * being used to populate the {@link ComboBox} when it is shown.
     *
     * @param items The items to show in the ComboBox popup menu when selected
     *      by the user.
     */
    public ComboBoxListCell(ObservableList&lt;T&gt; items) {
        this(null, items);
    }

    /**
     * Creates a {@link ComboBoxListCell} instance with the given items
     * being used to populate the {@link ComboBox} when it is shown, and the
     * {@link StringConverter} being used to convert the item in to a
     * user-readable form.
     *
     * @param converter A {@link StringConverter} that can convert an item of
     *      type T into a user-readable string so that it may then be shown in
     *      the ComboBox popup menu.
     * @param items The items to show in the ComboBox popup menu when selected
     *      by the user.
     */
    public ComboBoxListCell(StringConverter&lt;T&gt; converter, ObservableList&lt;T&gt; items) {
        this.getStyleClass().add(&quot;combo-box-list-cell&quot;);
        this.items = items;
        setConverter(converter != null ? converter : CellUtils.&lt;T&gt;defaultStringConverter());
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- converter
    private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter =
            new SimpleObjectProperty&lt;StringConverter&lt;T&gt;&gt;(this, &quot;converter&quot;);

    /**
     * The {@link StringConverter} property.
     * @return the {@link StringConverter} property
     */
    public final ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() {
        return converter;
    }

    /**
     * Sets the {@link StringConverter} to be used in this cell.
     * @param value the {@link StringConverter} to be used in this cell
     */
    public final void setConverter(StringConverter&lt;T&gt; value) {
        converterProperty().set(value);
    }

    /**
     * Returns the {@link StringConverter} used in this cell.
     * @return the {@link StringConverter} used in this cell
     */
    public final StringConverter&lt;T&gt; getConverter() {
        return converterProperty().get();
    }


    // --- comboBox editable
    private BooleanProperty comboBoxEditable =
            new SimpleBooleanProperty(this, &quot;comboBoxEditable&quot;);

    /**
     * A property representing whether the ComboBox, when shown to the user,
     * is editable or not.
     * @return the property representing whether the ComboBox, when shown to
     * the user, is editable or not
     */
    public final BooleanProperty comboBoxEditableProperty() {
        return comboBoxEditable;
    }

    /**
     * Configures the ComboBox to be editable (to allow user input outside of the
     * options provide in the dropdown list).
     * @param value the editable value for this ComboBox
     */
    public final void setComboBoxEditable(boolean value) {
        comboBoxEditableProperty().set(value);
    }

    /**
     * Returns true if the ComboBox is editable.
     * @return true if the ComboBox is editable
     */
    public final boolean isComboBoxEditable() {
        return comboBoxEditableProperty().get();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the items to be displayed in the ChoiceBox when it is showing.
     * @return the items to be displayed in the ChoiceBox when it is showing
     */
    public ObservableList&lt;T&gt; getItems() {
        return items;
    }

    /** {@inheritDoc} */
    @Override public void startEdit() {
        if (! isEditable() || ! getListView().isEditable()) {
            return;
        }

        if (comboBox == null) {
            comboBox = createComboBox(this, items, converterProperty());
            comboBox.editableProperty().bind(comboBoxEditableProperty());
        }

        comboBox.getSelectionModel().select(getItem());

        super.startEdit();

        if (isEditing()) {
<A NAME="26"></A>            setText(null);
            setGraphic(comboBox);
        }
    <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#26',2,'match42-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        super.cancelEdit();

        setText(getConverter().toString(getItem()));
        setGraphic</B></FONT>(null);
    }

    /** {@inheritDoc} */
    @Override public void updateItem(T item, boolean empty) {
        super.updateItem(item, empty);
        CellUtils.updateItem(this, getConverter(), null, null, comboBox);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/cell/TextFieldTreeCell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.cell;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.TreeCell;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeView;
import javafx.scene.layout.HBox;
import javafx.util.Callback;
import javafx.util.StringConverter;
import javafx.util.converter.DefaultStringConverter;

/**
 * A class containing a {@link TreeCell} implementation that draws a
 * {@link TextField} node inside the cell.
 *
 * &lt;p&gt;By default, the TextFieldTreeCell is rendered as a {@link Label} when not
 * being edited, and as a TextField when in editing mode. The TextField will, by
 * default, stretch to fill the entire tree cell.
 *
 * @param &lt;T&gt; The type of the elements contained within the TreeView.
 * @since JavaFX 2.2
 */
public class TextFieldTreeCell&lt;T&gt; extends DefaultTreeCell&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Static cell factories                                                   *
     *                                                                         *
     **************************************************************************/

    /**
     * Provides a {@link TextField} that allows editing of the cell content when
     * the cell is double-clicked, or when
     * {@link TreeView#edit(javafx.scene.control.TreeItem)} is called.
     * This method will only work on {@link TreeView} instances which are of
     * type String.
     *
     * @return A {@link Callback} that can be inserted into the
     *      {@link TreeView#cellFactoryProperty() cell factory property} of a
     *      TreeView, that enables textual editing of the content.
     */
    public static Callback&lt;TreeView&lt;String&gt;, TreeCell&lt;String&gt;&gt; forTreeView() {
        return forTreeView(new DefaultStringConverter());
    }

    /**
     * Provides a {@link TextField} that allows editing of the cell content when
     * the cell is double-clicked, or when
     * {@link TreeView#edit(javafx.scene.control.TreeItem)} is called. This
     * method will work on any {@link TreeView} instance,
     * regardless of its generic type. However, to enable this, a
     * {@link StringConverter} must be provided that will convert the given String
     * (from what the user typed in) into an instance of type T. This item will
     * then be passed along to the {@link TreeView#onEditCommitProperty()}
     * callback.
     *
     * @param &lt;T&gt; The type of the elements contained within the TreeView
     * @param converter A {@link StringConverter} that can convert the given String
     *      (from what the user typed in) into an instance of type T.
     * @return A {@link Callback} that can be inserted into the
     *      {@link TreeView#cellFactoryProperty() cell factory property} of a
     *      TreeView, that enables textual editing of the content.
     */
    public static &lt;T&gt; Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; forTreeView(
            final StringConverter&lt;T&gt; converter) {
        return list -&gt; new TextFieldTreeCell&lt;T&gt;(converter);
    }



    /***************************************************************************
     *                                                                         *
     * Fields                                                                  *
     *                                                                         *
     **************************************************************************/

    private TextField textField;
    private HBox hbox;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TextFieldTreeCell with a null converter. Without a
     * {@link StringConverter} specified, this cell will not be able to accept
     * input from the TextField (as it will not know how to convert this back
     * to the domain object). It is therefore strongly encouraged to not use
     * this constructor unless you intend to set the converter separately.
     */
    public TextFieldTreeCell() {
        this(null);
    }

    /**
     * Creates a TextFieldTreeCell that provides a {@link TextField} when put
     * into editing mode that allows editing of the cell content. This method
     * will work on any TreeView instance, regardless of its generic type.
     * However, to enable this, a {@link StringConverter} must be provided that
     * will convert the given String (from what the user typed in) into an
     * instance of type T. This item will then be passed along to the
     * {@link TreeView#onEditCommitProperty()} callback.
     *
     * @param converter A {@link StringConverter converter} that can convert
     *      the given String (from what the user typed in) into an instance of
     *      type T.
     */
    public TextFieldTreeCell(StringConverter&lt;T&gt; converter) {
        this.getStyleClass().add(&quot;text-field-tree-cell&quot;);
        setConverter(converter);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- converter
    private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter =
            new SimpleObjectProperty&lt;StringConverter&lt;T&gt;&gt;(this, &quot;converter&quot;);

    /**
     * The {@link StringConverter} property.
     * @return the {@link StringConverter} property
     */
    public final ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() {
        return converter;
    }

    /**
     * Sets the {@link StringConverter} to be used in this cell.
     * @param value the {@link StringConverter} to be used in this cell
     */
    public final void setConverter(StringConverter&lt;T&gt; value) {
        converterProperty().set(value);
    }

    /**
     * Returns the {@link StringConverter} used in this cell.
     * @return the {@link StringConverter} used in this cell
     */
    public final StringConverter&lt;T&gt; getConverter() {
        return converterProperty().get();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void startEdit() {
        if (! isEditable() || ! getTreeView().isEditable()) {
            return;
        }
        super.startEdit();

        if (isEditing()) {
            StringConverter&lt;T&gt; converter = getConverter();
            if (textField == null) {
                textField = CellUtils.createTextField(this, converter);
            }
            if (hbox == null) {
<A NAME="53"></A>                hbox = new HBox(CellUtils.TREE_VIEW_HBOX_GRAPHIC_PADDING);
            }

            <FONT color="#f88158"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#53',2,'match42-top.html#53',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CellUtils.startEdit(this, converter, hbox, getTreeItemGraphic(), textField);
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        super.cancelEdit();
        CellUtils.cancelEdit(this, getConverter(), getTreeItemGraphic());
    }

    /** {@inheritDoc} */
    @</B></FONT>Override public void updateItem(T item, boolean empty) {
        super.updateItem(item, empty);
        CellUtils.updateItem(this, getConverter(), hbox, getTreeItemGraphic(), textField);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private Node getTreeItemGraphic() {
        TreeItem&lt;T&gt; treeItem = getTreeItem();
        return treeItem == null ? null : treeItem.getGraphic();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/CheckBoxSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import com.sun.javafx.scene.control.behavior.ButtonBehavior;
import javafx.scene.control.Control;
import javafx.scene.layout.StackPane;

import javafx.geometry.NodeOrientation;

/**
 * Default skin implementation for the tri-state {@link CheckBox} control.
 *
 * @see CheckBox
 * @since 9
 */
public class CheckBoxSkin extends LabeledSkinBase&lt;CheckBox&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final StackPane box = new StackPane();
    private StackPane innerbox;
    private final BehaviorBase&lt;CheckBox&gt; behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new CheckBoxSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public CheckBoxSkin(CheckBox control) {
        super(control);

        // install default input map for the CheckBox control
        behavior = new ButtonBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        box.getStyleClass().setAll(&quot;box&quot;);
        innerbox = new StackPane();
        innerbox.getStyleClass().setAll(&quot;mark&quot;);
        innerbox.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
        box.getChildren().add(innerbox);
        updateChildren();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateChildren() {
        super.updateChildren();
        if (box != null) {
            getChildren().add(box);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return super.computeMinWidth(height, topInset, rightInset, bottomInset, leftInset) + snapSizeX(box.minWidth(-1));
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Math.max(super.computeMinHeight(width - box.minWidth(-1), topInset, rightInset, bottomInset, leftInset),
                topInset + box.minHeight(-1) + bottomInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return super.computePrefWidth(height, topInset, rightInset, bottomInset, leftInset) + snapSizeX(box.prefWidth(-1));
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Math.max(super.computePrefHeight(width - box.prefWidth(-1), topInset, rightInset, bottomInset, leftInset),
                        topInset + box.prefHeight(-1) + bottomInset);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
            final double w, final double h) {
        final CheckBox checkBox = getSkinnable();
        final double boxWidth = snapSizeX(box.prefWidth(-1));
        final double boxHeight = snapSizeY(box.prefHeight(-1));
        final double computeWidth = Math.max(checkBox.prefWidth(-1), checkBox.minWidth(-1));
        final double labelWidth = Math.min( computeWidth - boxWidth, w - snapSizeX(boxWidth));
<A NAME="49"></A>        final double labelHeight = Math.min(checkBox.prefHeight(labelWidth), h);
        final double maxHeight = Math.max(boxHeight, labelHeight);
        final double xOffset = Utils.computeXOffset(w, labelWidth + boxWidth, checkBox.getAlignment().getHpos()) + x;
        <FONT color="#8e35ef"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#49',2,'match42-top.html#49',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final double yOffset = Utils.computeYOffset(h, maxHeight, checkBox.getAlignment().getVpos()) + y;

        layoutLabelInArea(xOffset + boxWidth, yOffset, labelWidth, maxHeight, checkBox.getAlignment());
        box.resize(boxWidth, boxHeight);
        positionInArea(box, xOffset, yOffset, boxWidth, maxHeight, 0, checkBox.getAlignment().getHpos(), checkBox.getAlignment().getVpos());
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ScrollBarSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="56"></A> * questions.
 */

<FONT color="#52d017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#56',2,'match42-top.html#56',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package javafx.scene.control.skin;

import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.behavior.BehaviorBase;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.SkinBase;
import javafx.scene.input.MouseButton;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.Node;
import com.sun.javafx.util.Utils;
import com.sun.javafx.scene.control.behavior.ScrollBarBehavior;

import java.util.function.Consumer;

/**
 * Default skin implementation for the {@link ScrollBar} control.
 *
 * @see ScrollBar
 * @since 9
 */
public class ScrollBarSkin extends SkinBase&lt;ScrollBar&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final ScrollBarBehavior behavior;

    private StackPane thumb;
    private StackPane trackBackground;
    private StackPane track;
    private EndButton incButton</B></FONT>;
    private EndButton decButton;

    private double trackLength;
    private double thumbLength;

    private double preDragThumbPos;
    private Point2D dragStart; // in the track's coord system

    private double trackPos;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ScrollBarSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ScrollBarSkin(ScrollBar control) {
        super(control);

        // install default input map for the ScrollBar control
        this.behavior = new ScrollBarBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        initialize();
        getSkinnable().requestLayout();

        // Register listeners
        final Consumer&lt;ObservableValue&lt;?&gt;&gt; consumer = e -&gt; {
            positionThumb();
            getSkinnable().requestLayout();
        };
        registerChangeListener(control.minProperty(), consumer);
        registerChangeListener(control.maxProperty(), consumer);
        registerChangeListener(control.visibleAmountProperty(), consumer);
        registerChangeListener(control.valueProperty(), e -&gt; positionThumb());
        registerChangeListener(control.orientationProperty(), e -&gt; getSkinnable().requestLayout());
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {

        final ScrollBar s = getSkinnable();

        /**
         * Compute the percentage length of thumb as (visibleAmount/range)
         * if max isn't greater than min then there is nothing to do here
         */
        double visiblePortion;
        if (s.getMax() &gt; s.getMin()) {
            visiblePortion = s.getVisibleAmount()/(s.getMax() - s.getMin());
        }
        else {
            visiblePortion = 1.0;
        }

        if (s.getOrientation() == Orientation.VERTICAL) {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                double decHeight = snapSizeY(decButton.prefHeight(-1));
                double incHeight = snapSizeY(incButton.prefHeight(-1));

                decButton.resize(w, decHeight);
                incButton.resize(w, incHeight);

                trackLength = snapSizeY(h - (decHeight + incHeight));
                thumbLength = snapSizeY(Utils.clamp(minThumbLength(), (trackLength * visiblePortion), trackLength));

                trackBackground.resizeRelocate(snapPositionX(x), snapPositionY(y), w, trackLength+decHeight+incHeight);
                decButton.relocate(snapPositionX(x), snapPositionY(y));
                incButton.relocate(snapPositionX(x), snapPositionY(y + h - incHeight));
                track.resizeRelocate(snapPositionX(x), snapPositionY(y + decHeight), w, trackLength);
                thumb.resize(snapSizeX(x &gt;= 0 ? w : w + x), thumbLength); // Account for negative padding (see also RT-10719)
                positionThumb();
            }
            else {
                trackLength = snapSizeY(h);
                thumbLength = snapSizeY(Utils.clamp(minThumbLength(), (trackLength * visiblePortion), trackLength));

                track.resizeRelocate(snapPositionX(x), snapPositionY(y), w, trackLength);
                thumb.resize(snapSizeX(x &gt;= 0 ? w : w + x), thumbLength); // Account for negative padding (see also RT-10719)
                positionThumb();
            }
        } else {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                double decWidth = snapSizeX(decButton.prefWidth(-1));
                double incWidth = snapSizeX(incButton.prefWidth(-1));

                decButton.resize(decWidth, h);
                incButton.resize(incWidth, h);

                trackLength = snapSizeX(w - (decWidth + incWidth));
                thumbLength = snapSizeX(Utils.clamp(minThumbLength(), (trackLength * visiblePortion), trackLength));

                trackBackground.resizeRelocate(snapPositionX(x), snapPositionY(y), trackLength+decWidth+incWidth, h);
                decButton.relocate(snapPositionX(x), snapPositionY(y));
                incButton.relocate(snapPositionX(x + w - incWidth), snapPositionY(y));
                track.resizeRelocate(snapPositionX(x + decWidth), snapPositionY(y), trackLength, h);
                thumb.resize(thumbLength, snapSizeY(y &gt;= 0 ? h : h + y)); // Account for negative padding (see also RT-10719)
                positionThumb();
            }
            else {
                trackLength = snapSizeX(w);
                thumbLength = snapSizeX(Utils.clamp(minThumbLength(), (trackLength * visiblePortion), trackLength));

                track.resizeRelocate(snapPositionX(x), snapPositionY(y), trackLength, h);
                thumb.resize(thumbLength, snapSizeY(y &gt;= 0 ? h : h + y)); // Account for negative padding (see also RT-10719)
                positionThumb();
            }

            s.resize(snapSizeX(s.getWidth()), snapSizeY(s.getHeight()));
        }

        // things should be invisible only when well below minimum length
        if (s.getOrientation() == Orientation.VERTICAL &amp;&amp; h &gt;= (computeMinHeight(-1, (int)y , snappedRightInset(), snappedBottomInset(), (int)x) - (y+snappedBottomInset())) ||
                s.getOrientation() == Orientation.HORIZONTAL &amp;&amp; w &gt;= (computeMinWidth(-1, (int)y , snappedRightInset(), snappedBottomInset(), (int)x) - (x+snappedRightInset()))) {
            trackBackground.setVisible(true);
            track.setVisible(true);
            thumb.setVisible(true);
            if (!Properties.IS_TOUCH_SUPPORTED) {
                incButton.setVisible(true);
                decButton.setVisible(true);
            }
        }
        else {
            trackBackground.setVisible(false);
            track.setVisible(false);
            thumb.setVisible(false);

            if (!Properties.IS_TOUCH_SUPPORTED) {
                /*
                ** once the space is big enough for one button we
                ** can look at drawing
                */
                if (h &gt;= decButton.computeMinWidth(-1)) {
                    decButton.setVisible(true);
                }
                else {
                    decButton.setVisible(false);
                }
                if (h &gt;= incButton.computeMinWidth(-1)) {
                    incButton.setVisible(true);
                }
                else {
                    incButton.setVisible(false);
                }
            }
        }
    }

    /*
     * Minimum length is the length of the end buttons plus twice the
     * minimum thumb length, which should be enough for a reasonably-sized
     * track. Minimum breadth is determined by the breadths of the
     * end buttons.
     */
    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
            return getBreadth();
        } else {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                return decButton.minWidth(-1) + incButton.minWidth(-1) + minTrackLength()+leftInset+rightInset;
            } else {
                return minTrackLength()+leftInset+rightInset;
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                return decButton.minHeight(-1) + incButton.minHeight(-1) + minTrackLength()+topInset+bottomInset;
            } else {
                return minTrackLength()+topInset+bottomInset;
            }
        } else {
            return getBreadth();
        }
    }

    /*
     * Preferred size. The breadth is determined by the breadth of
     * the end buttons. The length is a constant default length.
     * Usually applications or other components will either set a
     * specific length using LayoutInfo or will stretch the length
     * of the scrollbar to fit a container.
     */
    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollBar s = getSkinnable();
        return s.getOrientation() == Orientation.VERTICAL ? getBreadth() : Properties.DEFAULT_LENGTH+leftInset+rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollBar s = getSkinnable();
        return s.getOrientation() == Orientation.VERTICAL ? Properties.DEFAULT_LENGTH+topInset+bottomInset : getBreadth();
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollBar s = getSkinnable();
        return s.getOrientation() == Orientation.VERTICAL ? s.prefWidth(-1) : Double.MAX_VALUE;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollBar s = getSkinnable();
        return s.getOrientation() == Orientation.VERTICAL ? Double.MAX_VALUE : s.prefHeight(-1);
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    /**
     * Initializes the ScrollBarSkin. Creates the scene and sets up all the
     * bindings for the group.
     */
    private void initialize() {

        track = new StackPane();
        track.getStyleClass().setAll(&quot;track&quot;);

        trackBackground = new StackPane();
        trackBackground.getStyleClass().setAll(&quot;track-background&quot;);

        thumb = new StackPane() {
            @Override
            public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
                switch (attribute) {
                    case VALUE: return getSkinnable().getValue();
                    default: return super.queryAccessibleAttribute(attribute, parameters);
                }
            }
        };
        thumb.getStyleClass().setAll(&quot;thumb&quot;);
        thumb.setAccessibleRole(AccessibleRole.THUMB);


        if (!Properties.IS_TOUCH_SUPPORTED) {

            incButton = new EndButton(&quot;increment-button&quot;, &quot;increment-arrow&quot;) {
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE:
                            getSkinnable().increment();
                            break;
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            incButton.setAccessibleRole(AccessibleRole.INCREMENT_BUTTON);
            incButton.setOnMousePressed(me -&gt; {
                /*
                ** if the tracklenght isn't greater than do nothing....
                */
                if (!thumb.isVisible() || trackLength &gt; thumbLength) {
                    behavior.incButtonPressed();
                }
                me.consume();
            });
            incButton.setOnMouseReleased(me -&gt; {
                /*
                ** if the tracklenght isn't greater than do nothing....
                */
                if (!thumb.isVisible() || trackLength &gt; thumbLength) {
                    behavior.incButtonReleased();
                }
                me.consume();
            });

            decButton = new EndButton(&quot;decrement-button&quot;, &quot;decrement-arrow&quot;) {
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE:
                            getSkinnable().decrement();
                            break;
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            decButton.setAccessibleRole(AccessibleRole.DECREMENT_BUTTON);
            decButton.setOnMousePressed(me -&gt; {
                /*
                ** if the tracklenght isn't greater than do nothing....
                */
                if (!thumb.isVisible() || trackLength &gt; thumbLength) {
                    behavior.decButtonPressed();
                }
                me.consume();
            });
            decButton.setOnMouseReleased(me -&gt; {
                /*
                ** if the tracklenght isn't greater than do nothing....
                */
                if (!thumb.isVisible() || trackLength &gt; thumbLength) {
                    behavior.decButtonReleased();
                }
                me.consume();
            });
        }


        track.setOnMousePressed(me -&gt; {
            if (!thumb.isPressed() &amp;&amp; me.getButton() == MouseButton.PRIMARY) {
                if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                    if (trackLength != 0) {
                        behavior.trackPress(me.getY() / trackLength);
                        me.consume();
                    }
                } else {
                    if (trackLength != 0) {
                        behavior.trackPress(me.getX() / trackLength);
                        me.consume();
                    }
                }
            }
        });

        track.setOnMouseReleased(me -&gt; {
            behavior.trackRelease();
            me.consume();
        });

        thumb.setOnMousePressed(me -&gt; {
            if (me.isSynthesized()) {
                // touch-screen events handled by Scroll handler
                me.consume();
                return;
            }
            /*
            ** if max isn't greater than min then there is nothing to do here
            */
            if (getSkinnable().getMax() &gt; getSkinnable().getMin()) {
                dragStart = thumb.localToParent(me.getX(), me.getY());
                double clampedValue = Utils.clamp(getSkinnable().getMin(), getSkinnable().getValue(), getSkinnable().getMax());
                preDragThumbPos = (clampedValue - getSkinnable().getMin()) / (getSkinnable().getMax() - getSkinnable().getMin());
                me.consume();
            }
        });


        thumb.setOnMouseDragged(me -&gt; {
            if (me.isSynthesized()) {
                // touch-screen events handled by Scroll handler
                me.consume();
                return;
            }
            /*
            ** if max isn't greater than min then there is nothing to do here
            */
            if (getSkinnable().getMax() &gt; getSkinnable().getMin()) {
                /*
                ** if the tracklength isn't greater then do nothing....
                */
                if (trackLength &gt; thumbLength) {
                    Point2D cur = thumb.localToParent(me.getX(), me.getY());
                    if (dragStart == null) {
                        // we're getting dragged without getting a mouse press
                        dragStart = thumb.localToParent(me.getX(), me.getY());
                    }
                    double dragPos = getSkinnable().getOrientation() == Orientation.VERTICAL ? cur.getY() - dragStart.getY(): cur.getX() - dragStart.getX();
                    behavior.thumbDragged(preDragThumbPos + dragPos / (trackLength - thumbLength));
                }

                me.consume();
            }
        });

        thumb.setOnScrollStarted(se -&gt; {
            if (se.isDirect()) {
                /*
                ** if max isn't greater than min then there is nothing to do here
                */
                if (getSkinnable().getMax() &gt; getSkinnable().getMin()) {
                    dragStart = thumb.localToParent(se.getX(), se.getY());
                    double clampedValue = Utils.clamp(getSkinnable().getMin(), getSkinnable().getValue(), getSkinnable().getMax());
                    preDragThumbPos = (clampedValue - getSkinnable().getMin()) / (getSkinnable().getMax() - getSkinnable().getMin());
                    se.consume();
                }
            }
        });

        thumb.setOnScroll(event -&gt; {
            if (event.isDirect()) {
                /*
                ** if max isn't greater than min then there is nothing to do here
                */
                if (getSkinnable().getMax() &gt; getSkinnable().getMin()) {
                    /*
                    ** if the tracklength isn't greater then do nothing....
                    */
                    if (trackLength &gt; thumbLength) {
                        Point2D cur = thumb.localToParent(event.getX(), event.getY());
                        if (dragStart == null) {
                            // we're getting dragged without getting a mouse press
                            dragStart = thumb.localToParent(event.getX(), event.getY());
                        }
                        double dragPos = getSkinnable().getOrientation() == Orientation.VERTICAL ? cur.getY() - dragStart.getY(): cur.getX() - dragStart.getX();
                        behavior.thumbDragged(/*todo*/ preDragThumbPos + dragPos / (trackLength - thumbLength));
                    }

                    event.consume();
                    return;
                }
            }
        });


        getSkinnable().addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            /*
            ** if the tracklength isn't greater then do nothing....
            */
            if (trackLength &gt; thumbLength) {

                double dx = event.getDeltaX();
                double dy = event.getDeltaY();

                /*
                ** in 2.0 a horizontal scrollbar would scroll on a vertical
                ** drag on a tracker-pad. We need to keep this behavior.
                */
                dx = (Math.abs(dx) &lt; Math.abs(dy) ? dy : dx);

                /*
                ** we only consume an event that we've used.
                */
                ScrollBar sb = (ScrollBar) getSkinnable();

                double delta = (getSkinnable().getOrientation() == Orientation.VERTICAL ? dy : dx);

                /*
                ** RT-22941 - If this is either a touch or inertia scroll
                ** then we move to the position of the touch point.
                *
                * TODO: this fix causes RT-23406 ([ScrollBar, touch] Dragging scrollbar from the
                * track on touchscreen causes flickering)
                */
                if (event.isDirect()) {
                    if (trackLength &gt; thumbLength) {
                        behavior.thumbDragged((getSkinnable().getOrientation() == Orientation.VERTICAL ? event.getY() : event.getX()) / trackLength);
                        event.consume();
                    }
                }
                else {
                    if (delta &gt; 0.0 &amp;&amp; sb.getValue() &gt; sb.getMin()) {
                        sb.decrement();
                        event.consume();
                    } else if (delta &lt; 0.0 &amp;&amp; sb.getValue() &lt; sb.getMax()) {
                        sb.increment();
                        event.consume();
                    }
                }
            }
        });

        getChildren().clear();
        if (!Properties.IS_TOUCH_SUPPORTED) {
            getChildren().addAll(trackBackground, incButton, decButton, track, thumb);
        }
        else {
            getChildren().addAll(track, thumb);
        }
    }


    /*
     * Gets the breadth of the scrollbar. The &quot;breadth&quot; is the distance
     * across the scrollbar, i.e. if vertical the width, otherwise the height.
     * On desktop this is determined by the greater of the breadths of the end-buttons.
     * Embedded doesn't have end-buttons, so currently we use a default breadth.
     * We should change this when we get width/height css properties.
     */
    double getBreadth() {
        if (!Properties.IS_TOUCH_SUPPORTED) {
            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                return Math.max(decButton.prefWidth(-1), incButton.prefWidth(-1)) +snappedLeftInset()+snappedRightInset();
            } else {
                return Math.max(decButton.prefHeight(-1), incButton.prefHeight(-1)) +snappedTopInset()+snappedBottomInset();
            }
        }
        else {
            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                return Math.max(Properties.DEFAULT_EMBEDDED_SB_BREADTH, Properties.DEFAULT_EMBEDDED_SB_BREADTH)+snappedLeftInset()+snappedRightInset();
            } else {
                return Math.max(Properties.DEFAULT_EMBEDDED_SB_BREADTH, Properties.DEFAULT_EMBEDDED_SB_BREADTH)+snappedTopInset()+snappedBottomInset();
            }
        }
    }

    double minThumbLength() {
        return 1.5f * getBreadth();
    }

    double minTrackLength() {
        return 2.0f * getBreadth();
    }

    /**
     * Called when ever either min, max or value changes, so thumb's layoutX, Y is recomputed.
     */
    void positionThumb() {
        ScrollBar s = getSkinnable();
        double clampedValue = Utils.clamp(s.getMin(), s.getValue(), s.getMax());
        trackPos = (s.getMax() - s.getMin() &gt; 0) ? ((trackLength - thumbLength) * (clampedValue - s.getMin()) / (s.getMax() - s.getMin())) : (0.0F);

        if (!Properties.IS_TOUCH_SUPPORTED) {
            if (s.getOrientation() == Orientation.VERTICAL) {
                trackPos += decButton.prefHeight(-1);
            } else {
                trackPos += decButton.prefWidth(-1);
            }
        }

        thumb.setTranslateX( snapPositionX(s.getOrientation() == Orientation.VERTICAL ? snappedLeftInset() : trackPos + snappedLeftInset()));
        thumb.setTranslateY( snapPositionY(s.getOrientation() == Orientation.VERTICAL ? trackPos + snappedTopInset() : snappedTopInset()));
    }

    private Node getThumb() {
        return thumb;
    }

    private Node getTrack() {
        return track;
    }

    private Node getIncrementButton() {
        return incButton;
    }

    private Node getDecrementButton() {
        return decButton;
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    private static class EndButton extends Region {
        private Region arrow;

        private EndButton(String styleClass, String arrowStyleClass) {
            getStyleClass().setAll(styleClass);
            arrow = new Region();
            arrow.getStyleClass().setAll(arrowStyleClass);
            getChildren().setAll(arrow);
            requestLayout();
        }

        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double left = snappedLeftInset();
            final double bottom = snappedBottomInset();
            final double right = snappedRightInset();
            final double aw = snapSizeX(arrow.prefWidth(-1));
            final double ah = snapSizeY(arrow.prefHeight(-1));
            final double yPos = snapPositionY((getHeight() - (top + bottom + ah)) / 2.0);
            final double xPos = snapPositionX((getWidth() - (left + right + aw)) / 2.0);
            arrow.resizeRelocate(xPos + left, yPos + top, aw, ah);
        }

        @Override protected double computeMinHeight(double width) {
            return prefHeight(-1);
        }

        @Override protected double computeMinWidth(double height) {
            return prefWidth(-1);
        }

        @Override protected double computePrefWidth(double height) {
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double aw = snapSizeX(arrow.prefWidth(-1));
            return left + aw + right;
        }

        @Override protected double computePrefHeight(double width) {
            final double top = snappedTopInset();
            final double bottom = snappedBottomInset();
            final double ah = snapSizeY(arrow.prefHeight(-1));
            return top + ah + bottom;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ScrollPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.control.SkinBase;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import com.sun.javafx.util.Utils;
import com.sun.javafx.scene.control.behavior.ScrollPaneBehavior;
import static com.sun.javafx.scene.control.skin.Utils.*;
import javafx.geometry.Insets;

import java.util.function.Consumer;

/**
 * Default skin implementation for the {@link ScrollPane} control.
 *
 * @see ScrollPane
 * @since 9
 */
public class ScrollPaneSkin extends SkinBase&lt;ScrollPane&gt; {
    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final double DEFAULT_PREF_SIZE = 100.0;

    private static final double DEFAULT_MIN_SIZE = 36.0;

    private static final double DEFAULT_SB_BREADTH = 12.0;
    private static final double DEFAULT_EMBEDDED_SB_BREADTH = 8.0;

    private static final double PAN_THRESHOLD = 0.5;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    // state from the control

    private Node scrollNode;
    private final BehaviorBase&lt;ScrollPane&gt; behavior;

    private double nodeWidth;
    private double nodeHeight;
    private boolean nodeSizeInvalid = true;

    private double posX;
    private double posY;

    // working state

    private boolean hsbvis;
    private boolean vsbvis;
    private double hsbHeight;
    private double vsbWidth;

    // substructure

    private StackPane viewRect;
    private StackPane viewContent;
    private double contentWidth;
    private double contentHeight;
    private StackPane corner;
    ScrollBar hsb;
    ScrollBar vsb;

    double pressX;
    double pressY;
    double ohvalue;
    double ovvalue;
    private Cursor saveCursor =  null;
    private boolean dragDetected = false;
    private boolean touchDetected = false;
    private boolean mouseDown = false;

    Rectangle clipRect;

    Timeline sbTouchTimeline;
    KeyFrame sbTouchKF1;
    KeyFrame sbTouchKF2;
    Timeline contentsToViewTimeline;
    KeyFrame contentsToViewKF1;
    KeyFrame contentsToViewKF2;
    KeyFrame contentsToViewKF3;

    private boolean tempVisibility;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private final InvalidationListener nodeListener = new InvalidationListener() {
        @Override public void invalidated(Observable valueModel) {
            if (!nodeSizeInvalid) {
                final Bounds scrollNodeBounds = scrollNode.getLayoutBounds();
                final double scrollNodeWidth = scrollNodeBounds.getWidth();
                final double scrollNodeHeight = scrollNodeBounds.getHeight();

                /*
                ** if the new size causes scrollbar visibility to change, then need to relayout
                ** we also need to correct the thumb size when the scrollnode's size changes
                */
                if (vsbvis != determineVerticalSBVisible() || hsbvis != determineHorizontalSBVisible() ||
                        (scrollNodeWidth != 0.0  &amp;&amp; nodeWidth != scrollNodeWidth) ||
                        (scrollNodeHeight != 0.0 &amp;&amp; nodeHeight != scrollNodeHeight)) {
                    getSkinnable().requestLayout();
                } else {
                    /**
                     * we just need to update scrollbars based on new scrollNode size,
                     * but we don't do this while dragging, there's no need,
                     * and it jumps, as dragging updates the scrollbar too.
                     */
                    if (!dragDetected) {
                        updateVerticalSB();
                        updateHorizontalSB();
                    }
                }
            }
        }
    };


    /*
    ** The content of the ScrollPane has just changed bounds, check scrollBar positions.
    */
    private final ChangeListener&lt;Bounds&gt; boundsChangeListener = new ChangeListener&lt;Bounds&gt;() {
        @Override public void changed(ObservableValue&lt;? extends Bounds&gt; observable, Bounds oldBounds, Bounds newBounds) {

            /*
            ** For a height change then we want to reduce
            ** viewport vertical jumping as much as possible.
            ** We set a new vsb value to try to keep the same
            ** content position at the top of the viewport
            */
            double oldHeight = oldBounds.getHeight();
            double newHeight = newBounds.getHeight();
            if (oldHeight &gt; 0 &amp;&amp; oldHeight != newHeight) {
                double oldPositionY = (snapPositionY(snappedTopInset() - posY / (vsb.getMax() - vsb.getMin()) * (oldHeight - contentHeight)));
                double newPositionY = (snapPositionY(snappedTopInset() - posY / (vsb.getMax() - vsb.getMin()) * (newHeight - contentHeight)));

                double newValueY = (oldPositionY/newPositionY)*vsb.getValue();
                if (newValueY &lt; 0.0) {
                    vsb.setValue(0.0);
                }
                else if (newValueY &lt; 1.0) {
                    vsb.setValue(newValueY);
                }
                else if (newValueY &gt; 1.0) {
                    vsb.setValue(1.0);
                }
            }

            /*
            ** For a width change then we want to reduce
            ** viewport horizontal jumping as much as possible.
            ** We set a new hsb value to try to keep the same
            ** content position to the left of the viewport
            */
            double oldWidth = oldBounds.getWidth();
            double newWidth = newBounds.getWidth();
            if (oldWidth &gt; 0 &amp;&amp; oldWidth != newWidth) {
                double oldPositionX = (snapPositionX(snappedLeftInset() - posX / (hsb.getMax() - hsb.getMin()) * (oldWidth - contentWidth)));
                double newPositionX = (snapPositionX(snappedLeftInset() - posX / (hsb.getMax() - hsb.getMin()) * (newWidth - contentWidth)));

                double newValueX = (oldPositionX/newPositionX)*hsb.getValue();
                if (newValueX &lt; 0.0) {
                    hsb.setValue(0.0);
                }
                else if (newValueX &lt; 1.0) {
                    hsb.setValue(newValueX);
                }
                else if (newValueX &gt; 1.0) {
                    hsb.setValue(1.0);
                }
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ScrollPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ScrollPaneSkin(final ScrollPane control) {
        super(control);

        // install default input map for the ScrollPane control
        behavior = new ScrollPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        initialize();

        // Register listeners
        Consumer&lt;ObservableValue&lt;?&gt;&gt; viewportSizeHintConsumer = e -&gt; {
            // change affects pref size, so requestLayout on control
            getSkinnable().requestLayout();
        };
        registerChangeListener(control.contentProperty(), e -&gt; {
            if (scrollNode != getSkinnable().getContent()) {
                if (scrollNode != null) {
                    scrollNode.layoutBoundsProperty().removeListener(nodeListener);
                    scrollNode.layoutBoundsProperty().removeListener(boundsChangeListener);
                    viewContent.getChildren().remove(scrollNode);
                }
                scrollNode = getSkinnable().getContent();
                if (scrollNode != null) {
                    nodeWidth = snapSizeX(scrollNode.getLayoutBounds().getWidth());
                    nodeHeight = snapSizeY(scrollNode.getLayoutBounds().getHeight());
                    viewContent.getChildren().setAll(scrollNode);
                    scrollNode.layoutBoundsProperty().addListener(nodeListener);
                    scrollNode.layoutBoundsProperty().addListener(boundsChangeListener);
                }
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.fitToWidthProperty(), e -&gt; {
            getSkinnable().requestLayout();
            viewRect.requestLayout();
        });
        registerChangeListener(control.fitToHeightProperty(), e -&gt; {
            getSkinnable().requestLayout();
            viewRect.requestLayout();
        });
        registerChangeListener(control.hbarPolicyProperty(), e -&gt; {
            // change might affect pref size, so requestLayout on control
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.vbarPolicyProperty(), e -&gt; {
            // change might affect pref size, so requestLayout on control
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.hvalueProperty(), e -&gt; hsb.setValue(getSkinnable().getHvalue()));
        registerChangeListener(control.hmaxProperty(), e -&gt; hsb.setMax(getSkinnable().getHmax()));
        registerChangeListener(control.hminProperty(), e -&gt; hsb.setMin(getSkinnable().getHmin()));
        registerChangeListener(control.vvalueProperty(), e -&gt; vsb.setValue(getSkinnable().getVvalue()));
        registerChangeListener(control.vmaxProperty(), e -&gt; vsb.setMax(getSkinnable().getVmax()));
        registerChangeListener(control.vminProperty(), e -&gt; vsb.setMin(getSkinnable().getVmin()));
        registerChangeListener(control.prefViewportWidthProperty(), viewportSizeHintConsumer);
        registerChangeListener(control.prefViewportHeightProperty(), viewportSizeHintConsumer);
        registerChangeListener(control.minViewportWidthProperty(), viewportSizeHintConsumer);
        registerChangeListener(control.minViewportHeightProperty(), viewportSizeHintConsumer);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private DoubleProperty contentPosX;
    private final void setContentPosX(double value) { contentPosXProperty().set(value); }
    private final double getContentPosX() { return contentPosX == null ? 0.0 : contentPosX.get(); }
    private final DoubleProperty contentPosXProperty() {
        if (contentPosX == null) {
            contentPosX = new DoublePropertyBase() {
                @Override protected void invalidated() {
                    hsb.setValue(getContentPosX());
                    getSkinnable().requestLayout();
                }

                @Override
                public Object getBean() {
                    return ScrollPaneSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;contentPosX&quot;;
                }
            };
        }
        return contentPosX;
    }

    private DoubleProperty contentPosY;
    private final void setContentPosY(double value) { contentPosYProperty().set(value); }
    private final double getContentPosY() { return contentPosY == null ? 0.0 : contentPosY.get(); }
    private final DoubleProperty contentPosYProperty() {
        if (contentPosY == null) {
            contentPosY = new DoublePropertyBase() {
                @Override protected void invalidated() {
                    vsb.setValue(getContentPosY());
                    getSkinnable().requestLayout();
                }

                @Override
                public Object getBean() {
                    return ScrollPaneSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;contentPosY&quot;;
                }
            };
        }
        return contentPosY;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /**
     * Returns the horizontal {@link ScrollBar} used in this ScrollPaneSkin
     * instance.
     * @return the horizontal ScrollBar used in this ScrollPaneSkin instance
     */
    public final ScrollBar getHorizontalScrollBar() {
        return hsb;
    }

    /**
     * Returns the vertical {@link ScrollBar} used in this ScrollPaneSkin
     * instance.
     * @return the vertical ScrollBar used in this ScrollPaneSkin instance
     */
    public final ScrollBar getVerticalScrollBar() {
        return vsb;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double vsbWidth = computeVsbSizeHint(sp);
        double minWidth = vsbWidth + snappedLeftInset() + snappedRightInset();

        if (sp.getPrefViewportWidth() &gt; 0) {
            return (sp.getPrefViewportWidth() + minWidth);
        }
        else if (sp.getContent() != null) {
            return (sp.getContent().prefWidth(height) + minWidth);
        }
        else {
            return Math.max(minWidth, DEFAULT_PREF_SIZE);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double hsbHeight = computeHsbSizeHint(sp);
        double minHeight = hsbHeight + snappedTopInset() + snappedBottomInset();

        if (sp.getPrefViewportHeight() &gt; 0) {
            return (sp.getPrefViewportHeight() + minHeight);
        }
        else if (sp.getContent() != null) {
            return (sp.getContent().prefHeight(width) + minHeight);
        }
        else {
            return Math.max(minHeight, DEFAULT_PREF_SIZE);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double vsbWidth = computeVsbSizeHint(sp);
        double minWidth = vsbWidth + snappedLeftInset() + snappedRightInset();

        if (sp.getMinViewportWidth() &gt; 0) {
            return (sp.getMinViewportWidth() + minWidth);
        } else {
            double w = corner.minWidth(-1);
            return (w &gt; 0) ? (3 * w) : (DEFAULT_MIN_SIZE);
        }

    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ScrollPane sp = getSkinnable();

        double hsbHeight = computeHsbSizeHint(sp);
        double minHeight = hsbHeight + snappedTopInset() + snappedBottomInset();

        if (sp.getMinViewportHeight() &gt; 0) {
            return (sp.getMinViewportHeight() + minHeight);
        } else {
            double h = corner.minHeight(-1);
            return (h &gt; 0) ? (3 * h) : (DEFAULT_MIN_SIZE);
        }
    }

    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        final ScrollPane control = getSkinnable();
        final Insets padding = control.getPadding();
        final double rightPadding = snapSizeX(padding.getRight());
        final double leftPadding = snapSizeX(padding.getLeft());
        final double topPadding = snapSizeY(padding.getTop());
        final double bottomPadding = snapSizeY(padding.getBottom());

        vsb.setMin(control.getVmin());
        vsb.setMax(control.getVmax());

        //should only do this on css setup
        hsb.setMin(control.getHmin());
        hsb.setMax(control.getHmax());

        contentWidth = w;
        contentHeight = h;

        /*
        ** we want the scrollbars to go right to the border
        */
        double hsbWidth = 0;
        double vsbHeight = 0;

        computeScrollNodeSize(contentWidth, contentHeight);
        computeScrollBarSize();

        for (int i = 0; i &lt; 2; ++i) {
            vsbvis = determineVerticalSBVisible();
            hsbvis = determineHorizontalSBVisible();

            if (vsbvis &amp;&amp; !Properties.IS_TOUCH_SUPPORTED) {
                contentWidth = w - vsbWidth;
            }
            hsbWidth = w + leftPadding + rightPadding - (vsbvis ? vsbWidth : 0);
            if (hsbvis &amp;&amp; !Properties.IS_TOUCH_SUPPORTED) {
                contentHeight = h - hsbHeight;
            }
            vsbHeight = h + topPadding + bottomPadding - (hsbvis ? hsbHeight : 0);
        }


        if (scrollNode != null &amp;&amp; scrollNode.isResizable()) {
            // maybe adjust size now that scrollbars may take up space
            if (vsbvis &amp;&amp; hsbvis) {
                // adjust just once to accommodate
                computeScrollNodeSize(contentWidth, contentHeight);

            } else if (hsbvis &amp;&amp; !vsbvis) {
                computeScrollNodeSize(contentWidth, contentHeight);
                vsbvis = determineVerticalSBVisible();
                if (vsbvis) {
                    // now both are visible
                    contentWidth -= vsbWidth;
                    hsbWidth -= vsbWidth;
                    computeScrollNodeSize(contentWidth, contentHeight);
                }
            } else if (vsbvis &amp;&amp; !hsbvis) {
                computeScrollNodeSize(contentWidth, contentHeight);
                hsbvis = determineHorizontalSBVisible();
                if (hsbvis) {
                    // now both are visible
                    contentHeight -= hsbHeight;
                    vsbHeight -= hsbHeight;
                    computeScrollNodeSize(contentWidth, contentHeight);
                }
            }
        }

        // figure out the content area that is to be filled
        double cx = snappedLeftInset() - leftPadding;
        double cy = snappedTopInset() - topPadding;

        vsb.setVisible(vsbvis);
        if (vsbvis) {
            /*
            ** round up position of ScrollBar, round down it's size.
            **
            ** Positioning the ScrollBar
            **  The Padding should go between the content and the edge,
            **  otherwise changes in padding move the ScrollBar, and could
            **  in extreme cases size the ScrollBar to become unusable.
            **  The -1, +1 plus one bit :
            **   If padding in =&gt; 1 then we allow one pixel to appear as the
            **   outside border of the Scrollbar, and the rest on the inside.
            **   If padding is &lt; 1 then we just stick to the edge.
            */
            vsb.resizeRelocate(snappedLeftInset() + w - vsbWidth + (rightPadding &lt; 1 ? 0 : rightPadding - 1) ,
                    cy, vsbWidth, vsbHeight);
        }
        updateVerticalSB();

        hsb.setVisible(hsbvis);
        if (hsbvis) {
            /*
            ** round up position of ScrollBar, round down it's size.
            **
            ** Positioning the ScrollBar
            **  The Padding should go between the content and the edge,
            **  otherwise changes in padding move the ScrollBar, and could
            **  in extreme cases size the ScrollBar to become unusable.
            **  The -1, +1 plus one bit :
            **   If padding in =&gt; 1 then we allow one pixel to appear as the
            **   outside border of the Scrollbar, and the rest on the inside.
            **   If padding is &lt; 1 then we just stick to the edge.
            */
            hsb.resizeRelocate(cx, snappedTopInset() + h - hsbHeight + (bottomPadding &lt; 1 ? 0 : bottomPadding - 1),
                    hsbWidth, hsbHeight);
        }
        updateHorizontalSB();

        viewRect.resizeRelocate(snappedLeftInset(), snappedTopInset(), snapSizeX(contentWidth), snapSizeY(contentHeight));
        resetClip();

        if (vsbvis &amp;&amp; hsbvis) {
            corner.setVisible(true);
            double cornerWidth = vsbWidth;
            double cornerHeight = hsbHeight;
            corner.resizeRelocate(snapPositionX(vsb.getLayoutX()), snapPositionY(hsb.getLayoutY()), snapSizeX(cornerWidth), snapSizeY(cornerHeight));
        } else {
            corner.setVisible(false);
        }
        control.setViewportBounds(new BoundingBox(snapPositionX(viewContent.getLayoutX()), snapPositionY(viewContent.getLayoutY()), snapSizeX(contentWidth), snapSizeY(contentHeight)));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case VERTICAL_SCROLLBAR: return vsb;
            case HORIZONTAL_SCROLLBAR: return hsb;
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void initialize() {
        // requestLayout calls below should not trigger requestLayout above ScrollPane
//        setManaged(false);

        ScrollPane control = getSkinnable();
        scrollNode = control.getContent();

        ParentTraversalEngine traversalEngine = new ParentTraversalEngine(getSkinnable());
        traversalEngine.addTraverseListener((node, bounds) -&gt; {
            // auto-scroll so node is within (0,0),(contentWidth,contentHeight)
            scrollBoundsIntoView(bounds);
        });
        ParentHelper.setTraversalEngine(getSkinnable(), traversalEngine);

        if (scrollNode != null) {
            scrollNode.layoutBoundsProperty().addListener(nodeListener);
            scrollNode.layoutBoundsProperty().addListener(boundsChangeListener);
        }

        viewRect = new StackPane() {
            @Override protected void layoutChildren() {
                viewContent.resize(getWidth(), getHeight());
            }
        };
        // prevent requestLayout requests from within scrollNode from percolating up
        viewRect.setManaged(false);
        viewRect.setCache(true);
        viewRect.getStyleClass().add(&quot;viewport&quot;);

        clipRect = new Rectangle();
        viewRect.setClip(clipRect);

        hsb = new ScrollBar();

        vsb = new ScrollBar();
        vsb.setOrientation(Orientation.VERTICAL);

        EventHandler&lt;MouseEvent&gt; barHandler = ev -&gt; {
            if (getSkinnable().isFocusTraversable()) {
                getSkinnable().requestFocus();
            }
        };

        hsb.addEventFilter(MouseEvent.MOUSE_PRESSED, barHandler);
        vsb.addEventFilter(MouseEvent.MOUSE_PRESSED, barHandler);

        corner = new StackPane();
        corner.getStyleClass().setAll(&quot;corner&quot;);

        viewContent = new StackPane() {
            @Override public void requestLayout() {
                // if scrollNode requested layout, will want to recompute
                nodeSizeInvalid = true;

                super.requestLayout(); // add as layout root for next layout pass

                // Need to layout the ScrollPane as well in case scrollbars
                // appeared or disappeared.
                ScrollPaneSkin.this.getSkinnable().requestLayout();
            }
            @Override protected void layoutChildren() {
                if (nodeSizeInvalid) {
                    computeScrollNodeSize(getWidth(),getHeight());
                }
                if (scrollNode != null &amp;&amp; scrollNode.isResizable()) {
                    scrollNode.resize(snapSize(nodeWidth), snapSize(nodeHeight));
                    if (vsbvis != determineVerticalSBVisible() || hsbvis != determineHorizontalSBVisible()) {
                        getSkinnable().requestLayout();
                    }
                }
                if (scrollNode != null) {
                    scrollNode.relocate(0,0);
                }
            }
        };
        viewRect.getChildren().add(viewContent);

        if (scrollNode != null) {
            viewContent.getChildren().add(scrollNode);
            viewRect.nodeOrientationProperty().bind(scrollNode.nodeOrientationProperty());
        }

        getChildren().clear();
        getChildren().addAll(viewRect, vsb, hsb, corner);

        /*
        ** listeners, and assorted housekeeping
        */
        InvalidationListener vsbListener = valueModel -&gt; {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                posY = Utils.clamp(getSkinnable().getVmin(), vsb.getValue(), getSkinnable().getVmax());
            }
            else {
                posY = vsb.getValue();
            }
            updatePosY();
        };
        vsb.valueProperty().addListener(vsbListener);

        InvalidationListener hsbListener = valueModel -&gt; {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                posX = Utils.clamp(getSkinnable().getHmin(), hsb.getValue(), getSkinnable().getHmax());
            }
            else {
                posX = hsb.getValue();
            }
            updatePosX();
        };
        hsb.valueProperty().addListener(hsbListener);

        viewRect.setOnMousePressed(e -&gt; {
            mouseDown = true;
            if (Properties.IS_TOUCH_SUPPORTED) {
                startSBReleasedAnimation();
            }
            pressX = e.getX();
            pressY = e.getY();
            ohvalue = hsb.getValue();
            ovvalue = vsb.getValue();
        });


        viewRect.setOnDragDetected(e -&gt; {
             if (Properties.IS_TOUCH_SUPPORTED) {
                 startSBReleasedAnimation();
             }
            if (getSkinnable().isPannable()) {
              dragDetected = true;
              if (saveCursor == null) {
                  saveCursor = getSkinnable().getCursor();
                  if (saveCursor == null) {
                      saveCursor = Cursor.DEFAULT;
                  }
                  getSkinnable().setCursor(Cursor.MOVE);
                  getSkinnable().requestLayout();
              }
            }
        });

        viewRect.addEventFilter(MouseEvent.MOUSE_RELEASED, e -&gt; {
             mouseDown = false;
             if (dragDetected == true) {
                 if (saveCursor != null) {
                     getSkinnable().setCursor(saveCursor);
                     saveCursor = null;
                     getSkinnable().requestLayout();
                 }
                 dragDetected = false;
             }

             /*
             ** if the contents need repositioning, and there's is no
             ** touch event in progress, then start the repositioning.
             */
             if ((posY &gt; getSkinnable().getVmax() || posY &lt; getSkinnable().getVmin() ||
                 posX &gt; getSkinnable().getHmax() || posX &lt; getSkinnable().getHmin()) &amp;&amp; !touchDetected) {
                 startContentsToViewport();
             }
        });
        viewRect.setOnMouseDragged(e -&gt; {
             if (Properties.IS_TOUCH_SUPPORTED) {
                 startSBReleasedAnimation();
             }
            /*
            ** for mobile-touch we allow drag, even if not pannagle
            */
            if (getSkinnable().isPannable() || Properties.IS_TOUCH_SUPPORTED) {
                double deltaX = pressX - e.getX();
                double deltaY = pressY - e.getY();
                /*
                ** we only drag if not all of the content is visible.
                */
                if (hsb.getVisibleAmount() &gt; 0.0 &amp;&amp; hsb.getVisibleAmount() &lt; hsb.getMax()) {
                    if (Math.abs(deltaX) &gt; PAN_THRESHOLD) {
                        if (isReverseNodeOrientation()) {
                            deltaX = -deltaX;
                        }
                        double newHVal = (ohvalue + deltaX / (nodeWidth - viewRect.getWidth()) * (hsb.getMax() - hsb.getMin()));
                        if (!Properties.IS_TOUCH_SUPPORTED) {
                            if (newHVal &gt; hsb.getMax()) {
                                newHVal = hsb.getMax();
                            }
                            else if (newHVal &lt; hsb.getMin()) {
                                newHVal = hsb.getMin();
                            }
                            hsb.setValue(newHVal);
                        }
                        else {
                            hsb.setValue(newHVal);
                        }
                    }
                }
                /*
                ** we only drag if not all of the content is visible.
                */
                if (vsb.getVisibleAmount() &gt; 0.0 &amp;&amp; vsb.getVisibleAmount() &lt; vsb.getMax()) {
                    if (Math.abs(deltaY) &gt; PAN_THRESHOLD) {
                        double newVVal = (ovvalue + deltaY / (nodeHeight - viewRect.getHeight()) * (vsb.getMax() - vsb.getMin()));
                        if (!Properties.IS_TOUCH_SUPPORTED) {
                            if (newVVal &gt; vsb.getMax()) {
                                newVVal = vsb.getMax();
                            }
                            else if (newVVal &lt; vsb.getMin()) {
                                newVVal = vsb.getMin();
                            }
                            vsb.setValue(newVVal);
                        }
                        else {
                            vsb.setValue(newVVal);
                        }
                    }
                }
            }
            /*
            ** we need to consume drag events, as we don't want
            ** the scrollpane itself to be dragged on every mouse click
            */
            e.consume();
        });


        /*
        ** don't allow the ScrollBar to handle the ScrollEvent,
        ** In a ScrollPane a vertical scroll should scroll on the vertical only,
        ** whereas in a horizontal ScrollBar it can scroll horizontally.
        */
        // block the event from being passed down to children
        final EventDispatcher blockEventDispatcher = (event, tail) -&gt; event;
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldHsbEventDispatcher = hsb.getEventDispatcher();
        hsb.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldHsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldHsbEventDispatcher.dispatchEvent(event, tail);
        });
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldVsbEventDispatcher = vsb.getEventDispatcher();
        vsb.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldVsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldVsbEventDispatcher.dispatchEvent(event, tail);
        });

        /*
         * listen for ScrollEvents over the whole of the ScrollPane
         * area, the above dispatcher having removed the ScrollBars
         * scroll event handling.
         *
         * Note that we use viewRect here, rather than setting the eventHandler
         * on the ScrollPane itself. This is for RT-31582, and effectively
         * allows for us to prioritise handling (and consuming) the event
         * internally, before it is made available to users listening to events
         * on the control. This is consistent with the VirtualFlow-based controls.
         */
        viewRect.addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            if (Properties.IS_TOUCH_SUPPORTED) {
                startSBReleasedAnimation();
            }
            /*
            ** if we're completely visible then do nothing....
            ** we only consume an event that we've used.
            */
            if (vsb.getVisibleAmount() &lt; vsb.getMax()) {
                double vRange = getSkinnable().getVmax()-getSkinnable().getVmin();
                double vPixelValue;
                if (nodeHeight &gt; 0.0) {
                    vPixelValue = vRange / nodeHeight;
                }
                else {
                    vPixelValue = 0.0;
                }
                double newValue = vsb.getValue()+(-event.getDeltaY())*vPixelValue;
                if (!Properties.IS_TOUCH_SUPPORTED) {
                    if ((event.getDeltaY() &gt; 0.0 &amp;&amp; vsb.getValue() &gt; vsb.getMin()) ||
                        (event.getDeltaY() &lt; 0.0 &amp;&amp; vsb.getValue() &lt; vsb.getMax())) {
                        vsb.setValue(newValue);
                        event.consume();
                    }
                }
                else {
                    /*
                    ** if there is a repositioning in progress then we only
                    ** set the value for 'real' events
                    */
                    if (!(((ScrollEvent)event).isInertia()) || (((ScrollEvent)event).isInertia()) &amp;&amp; (contentsToViewTimeline == null || contentsToViewTimeline.getStatus() == Status.STOPPED)) {
                        vsb.setValue(newValue);
                        if ((newValue &gt; vsb.getMax() || newValue &lt; vsb.getMin()) &amp;&amp; (!mouseDown &amp;&amp; !touchDetected)) {
                            startContentsToViewport();
                        }
                        event.consume();
                    }
                }
            }

            if (hsb.getVisibleAmount() &lt; hsb.getMax()) {
                double hRange = getSkinnable().getHmax()-getSkinnable().getHmin();
                double hPixelValue;
                if (nodeWidth &gt; 0.0) {
                    hPixelValue = hRange / nodeWidth;
                }
                else {
                    hPixelValue = 0.0;
                }

                double newValue = hsb.getValue()+(-event.getDeltaX())*hPixelValue;
                if (!Properties.IS_TOUCH_SUPPORTED) {
                    if ((event.getDeltaX() &gt; 0.0 &amp;&amp; hsb.getValue() &gt; hsb.getMin()) ||
                        (event.getDeltaX() &lt; 0.0 &amp;&amp; hsb.getValue() &lt; hsb.getMax())) {
                        hsb.setValue(newValue);
                        event.consume();
                    }
                }
                else {
                    /*
                    ** if there is a repositioning in progress then we only
                    ** set the value for 'real' events
                    */
                    if (!(((ScrollEvent)event).isInertia()) || (((ScrollEvent)event).isInertia()) &amp;&amp; (contentsToViewTimeline == null || contentsToViewTimeline.getStatus() == Status.STOPPED)) {
                        hsb.setValue(newValue);

                        if ((newValue &gt; hsb.getMax() || newValue &lt; hsb.getMin()) &amp;&amp; (!mouseDown &amp;&amp; !touchDetected)) {
                            startContentsToViewport();
                        }
                        event.consume();
                    }
                }
            }
        });

        /*
        ** there are certain animations that need to know if the touch is
        ** happening.....
        */
        getSkinnable().addEventHandler(TouchEvent.TOUCH_PRESSED, e -&gt; {
            touchDetected = true;
            startSBReleasedAnimation();
            e.consume();
        });

        getSkinnable().addEventHandler(TouchEvent.TOUCH_RELEASED, e -&gt; {
            touchDetected = false;
            e.consume();
        });

        // ScrollPanes do not block all MouseEvents by default, unlike most other UI Controls.
        consumeMouseEvents(false);

        // update skin initial state to match control (see RT-35554)
        hsb.setValue(control.getHvalue());
        vsb.setValue(control.getVvalue());
    }

    void scrollBoundsIntoView(Bounds b) {
        double dx = 0.0;
        double dy = 0.0;
        if (b.getMaxX() &gt; contentWidth) {
            dx = b.getMinX() - snappedLeftInset();
        }
        if (b.getMinX() &lt; snappedLeftInset()) {
            dx = b.getMaxX() - contentWidth - snappedLeftInset();
        }
        if (b.getMaxY() &gt; snappedTopInset() + contentHeight) {
            dy = b.getMinY() - snappedTopInset();
        }
        if (b.getMinY() &lt; snappedTopInset()) {
            dy = b.getMaxY() - contentHeight - snappedTopInset();
        }
        // We want to move contentPanel's layoutX,Y by (dx,dy).
        // But to do this we have to set the scrollbars' values appropriately.

        if (dx != 0) {
            double sdx = dx * (hsb.getMax() - hsb.getMin()) / (nodeWidth - contentWidth);
            // Adjust back for some amount so that the Node border is not too close to view border
            sdx += -1 * Math.signum(sdx) * hsb.getUnitIncrement() / 5; // This accounts to 2% of view width
            hsb.setValue(hsb.getValue() + sdx);
            getSkinnable().requestLayout();
        }
        if (dy != 0) {
            double sdy = dy * (vsb.getMax() - vsb.getMin()) / (nodeHeight - contentHeight);
            // Adjust back for some amount so that the Node border is not too close to view border
            sdy += -1 * Math.signum(sdy) * vsb.getUnitIncrement() / 5; // This accounts to 2% of view height
            vsb.setValue(vsb.getValue() + sdy);
            getSkinnable().requestLayout();
        }

    }

    /**
     * Computes the size that should be reserved for horizontal scrollbar in size hints (min/pref height)
     */
    private double computeHsbSizeHint(ScrollPane sp) {
        return ((sp.getHbarPolicy() == ScrollBarPolicy.ALWAYS) ||
                (sp.getHbarPolicy() == ScrollBarPolicy.AS_NEEDED &amp;&amp; (sp.getPrefViewportHeight() &gt; 0 || sp.getMinViewportHeight() &gt; 0)))
                ? hsb.prefHeight(ScrollBar.USE_COMPUTED_SIZE)
                : 0;
    }

    /**
     * Computes the size that should be reserved for vertical scrollbar in size hints (min/pref width)
     */
    private double computeVsbSizeHint(ScrollPane sp) {
        return ((sp.getVbarPolicy() == ScrollBarPolicy.ALWAYS) ||
                (sp.getVbarPolicy() == ScrollBarPolicy.AS_NEEDED &amp;&amp; (sp.getPrefViewportWidth() &gt; 0
                        || sp.getMinViewportWidth() &gt; 0)))
                ? vsb.prefWidth(ScrollBar.USE_COMPUTED_SIZE)
                : 0;
    }

    private void computeScrollNodeSize(double contentWidth, double contentHeight) {
        if (scrollNode != null) {
            if (scrollNode.isResizable()) {
                ScrollPane control = getSkinnable();
                Orientation bias = scrollNode.getContentBias();
                if (bias == null) {
                    nodeWidth = snapSizeX(boundedSize(control.isFitToWidth()? contentWidth : scrollNode.prefWidth(-1),
                                                         scrollNode.minWidth(-1),scrollNode.maxWidth(-1)));
                    nodeHeight = snapSizeY(boundedSize(control.isFitToHeight()? contentHeight : scrollNode.prefHeight(-1),
                                                          scrollNode.minHeight(-1), scrollNode.maxHeight(-1)));

                } else if (bias == Orientation.HORIZONTAL) {
                    nodeWidth = snapSizeX(boundedSize(control.isFitToWidth()? contentWidth : scrollNode.prefWidth(-1),
                                                         scrollNode.minWidth(-1),scrollNode.maxWidth(-1)));
                    nodeHeight = snapSizeY(boundedSize(control.isFitToHeight()? contentHeight : scrollNode.prefHeight(nodeWidth),
                                                          scrollNode.minHeight(nodeWidth),scrollNode.maxHeight(nodeWidth)));

                } else { // bias == VERTICAL
                    nodeHeight = snapSizeY(boundedSize(control.isFitToHeight()? contentHeight : scrollNode.prefHeight(-1),
                                                          scrollNode.minHeight(-1), scrollNode.maxHeight(-1)));
                    nodeWidth = snapSizeX(boundedSize(control.isFitToWidth()? contentWidth : scrollNode.prefWidth(nodeHeight),
                                                         scrollNode.minWidth(nodeHeight),scrollNode.maxWidth(nodeHeight)));
                }

            } else {
                nodeWidth = snapSizeX(scrollNode.getLayoutBounds().getWidth());
                nodeHeight = snapSizeY(scrollNode.getLayoutBounds().getHeight());
            }
            nodeSizeInvalid = false;
        }
    }

    private boolean isReverseNodeOrientation() {
        return (scrollNode != null &amp;&amp;
                getSkinnable().getEffectiveNodeOrientation() !=
                            scrollNode.getEffectiveNodeOrientation());
    }

    private boolean determineHorizontalSBVisible() {
        final ScrollPane sp = getSkinnable();

        if (Properties.IS_TOUCH_SUPPORTED) {
            return (tempVisibility &amp;&amp; (nodeWidth &gt; contentWidth));
        }
        else {
            // RT-17395: ScrollBarPolicy might be null. If so, treat it as &quot;AS_NEEDED&quot;, which is the default
            ScrollBarPolicy hbarPolicy = sp.getHbarPolicy();
            return (ScrollBarPolicy.NEVER == hbarPolicy) ? false :
                   ((ScrollBarPolicy.ALWAYS == hbarPolicy) ? true :
                   ((sp.isFitToWidth() &amp;&amp; scrollNode != null ? scrollNode.isResizable() : false) ?
                   (nodeWidth &gt; contentWidth &amp;&amp; scrollNode.minWidth(-1) &gt; contentWidth) : (nodeWidth &gt; contentWidth)));
        }
    }

    private boolean determineVerticalSBVisible() {
        final ScrollPane sp = getSkinnable();

        if (Properties.IS_TOUCH_SUPPORTED) {
            return (tempVisibility &amp;&amp; (nodeHeight &gt; contentHeight));
        }
        else {
            // RT-17395: ScrollBarPolicy might be null. If so, treat it as &quot;AS_NEEDED&quot;, which is the default
            ScrollBarPolicy vbarPolicy = sp.getVbarPolicy();
            return (ScrollBarPolicy.NEVER == vbarPolicy) ? false :
                   ((ScrollBarPolicy.ALWAYS == vbarPolicy) ? true :
                   ((sp.isFitToHeight() &amp;&amp; scrollNode != null ? scrollNode.isResizable() : false) ?
                   (nodeHeight &gt; contentHeight &amp;&amp; scrollNode.minHeight(-1) &gt; contentHeight) : (nodeHeight &gt; contentHeight)));
        }
    }

    private void computeScrollBarSize() {
        vsbWidth = snapSizeX(vsb.prefWidth(-1));
        if (vsbWidth == 0) {
            //            println(&quot;*** WARNING ScrollPaneSkin: can't get scroll bar width, using {DEFAULT_SB_BREADTH}&quot;);
            if (Properties.IS_TOUCH_SUPPORTED) {
                vsbWidth = DEFAULT_EMBEDDED_SB_BREADTH;
            }
            else {
                vsbWidth = DEFAULT_SB_BREADTH;
            }
        }
        hsbHeight = snapSizeY(hsb.prefHeight(-1));
        if (hsbHeight == 0) {
            //            println(&quot;*** WARNING ScrollPaneSkin: can't get scroll bar height, using {DEFAULT_SB_BREADTH}&quot;);
            if (Properties.IS_TOUCH_SUPPORTED) {
                hsbHeight = DEFAULT_EMBEDDED_SB_BREADTH;
            }
            else {
                hsbHeight = DEFAULT_SB_BREADTH;
            }
        }
    }

    private void updateHorizontalSB() {
        double contentRatio = nodeWidth * (hsb.getMax() - hsb.getMin());
        if (contentRatio &gt; 0.0) {
            hsb.setVisibleAmount(contentWidth / contentRatio);
            hsb.setBlockIncrement(0.9 * hsb.getVisibleAmount());
            hsb.setUnitIncrement(0.1 * hsb.getVisibleAmount());
        }
        else {
            hsb.setVisibleAmount(0.0);
            hsb.setBlockIncrement(0.0);
            hsb.setUnitIncrement(0.0);
        }

        if (hsb.isVisible()) {
            updatePosX();
        } else {
            if (nodeWidth &gt; contentWidth) {
                updatePosX();
            } else {
                viewContent.setLayoutX(0);
            }
        }
    }

    private void updateVerticalSB() {
        double contentRatio = nodeHeight * (vsb.getMax() - vsb.getMin());
        if (contentRatio &gt; 0.0) {
            vsb.setVisibleAmount(contentHeight / contentRatio);
            vsb.setBlockIncrement(0.9 * vsb.getVisibleAmount());
            vsb.setUnitIncrement(0.1 * vsb.getVisibleAmount());
        }
        else {
            vsb.setVisibleAmount(0.0);
            vsb.setBlockIncrement(0.0);
            vsb.setUnitIncrement(0.0);
        }

        if (vsb.isVisible()) {
            updatePosY();
        } else {
            if (nodeHeight &gt; contentHeight) {
                updatePosY();
            } else {
                viewContent.setLayoutY(0);
            }
        }
    }

<A NAME="67"></A>    private double updatePosX() {
        final ScrollPane sp = getSkinnable();
        double x = isReverseNodeOrientation() ? (hsb.getMax() - (posX - hsb.getMin())) : posX;
        double minX = Math.min((- x / (hsb.getMax() - <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#67',2,'match42-top.html#67',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>hsb.getMin()) * (nodeWidth - contentWidth)), 0);
        viewContent.setLayoutX(snapPositionX(minX));
        if (!sp.hvalueProperty().isBound()) sp.setHvalue(Utils.clamp(sp.getHmin(), posX, sp.getHmax()));</B></FONT>
        return posX;
    }
<A NAME="68"></A>
    private double updatePosY() {
        final ScrollPane sp = getSkinnable();
        double minY = Math.min((- posY / (vsb.getMax() - <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#68',2,'match42-top.html#68',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>vsb.getMin()) * (nodeHeight - contentHeight)), 0);
        viewContent.setLayoutY(snapPositionY(minY));
        if (!sp.vvalueProperty().isBound()) sp.setVvalue(Utils.clamp(sp.getVmin(), posY, sp.getVmax()));</B></FONT>
        return posY;
    }

    private void resetClip() {
        clipRect.setWidth(snapSizeX(contentWidth));
        clipRect.setHeight(snapSizeY(contentHeight));
    }

    private void startSBReleasedAnimation() {
        if (sbTouchTimeline == null) {
            /*
            ** timeline to leave the scrollbars visible for a short
            ** while after a scroll/drag
            */
            sbTouchTimeline = new Timeline();
            sbTouchKF1 = new KeyFrame(Duration.millis(0), event -&gt; {
                tempVisibility = true;
                if (touchDetected == true || mouseDown == true) {
                    sbTouchTimeline.playFromStart();
                }
            });

            sbTouchKF2 = new KeyFrame(Duration.millis(1000), event -&gt; {
                tempVisibility = false;
                getSkinnable().requestLayout();
            });
            sbTouchTimeline.getKeyFrames().addAll(sbTouchKF1, sbTouchKF2);
        }
        sbTouchTimeline.playFromStart();
    }

    private void startContentsToViewport() {
        double newPosX = posX;
        double newPosY = posY;

        setContentPosX(posX);
        setContentPosY(posY);

        if (posY &gt; getSkinnable().getVmax()) {
            newPosY = getSkinnable().getVmax();
        }
        else if (posY &lt; getSkinnable().getVmin()) {
            newPosY = getSkinnable().getVmin();
        }


        if (posX &gt; getSkinnable().getHmax()) {
            newPosX = getSkinnable().getHmax();
        }
        else if (posX &lt; getSkinnable().getHmin()) {
            newPosX = getSkinnable().getHmin();
        }

        if (!Properties.IS_TOUCH_SUPPORTED) {
            startSBReleasedAnimation();
        }

        /*
        ** timeline to return the contents of the scrollpane to the viewport
        */
        if (contentsToViewTimeline != null) {
            contentsToViewTimeline.stop();
        }
        contentsToViewTimeline = new Timeline();
        /*
        ** short pause before animation starts
        */
        contentsToViewKF1 = new KeyFrame(Duration.millis(50));
        /*
        ** reposition
        */
        contentsToViewKF2 = new KeyFrame(Duration.millis(150), event -&gt; {
            getSkinnable().requestLayout();
        },
                new KeyValue(contentPosX, newPosX),
                new KeyValue(contentPosY, newPosY)
        );
        /*
        ** block out 'aftershocks', but real events will
        ** still reactivate
        */
        contentsToViewKF3 = new KeyFrame(Duration.millis(1500));
        contentsToViewTimeline.getKeyFrames().addAll(contentsToViewKF1, contentsToViewKF2, contentsToViewKF3);
        contentsToViewTimeline.playFromStart();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
<A NAME="24"></A>                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#24',2,'match42-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize</B></FONT>(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
<A NAME="63"></A>            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#63',2,'match42-top.html#63',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi</B></FONT>;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextAreaSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.geometry.VerticalDirection;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import javafx.util.Duration;

import java.util.List;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;

/**
 * Default skin implementation for the {@link TextArea} control.
 *
 * @see TextArea
 * @since 9
 */
public class TextAreaSkin extends TextInputControlSkin&lt;TextArea&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /** A shared helper object, used only by downLines(). */
    private static final Path tmpCaretPath = new Path();



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

<A NAME="57"></A>    final private TextArea textArea;

    // *** NOTE: Multiple node mode is not yet fully implemented *** //
    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#57',2,'match42-top.html#57',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static final boolean USE_MULTIPLE_NODES = false;

    private final TextAreaBehavior behavior;

    private double computedMinWidth = Double.NEGATIVE_INFINITY;
    private double computedMinHeight = Double.NEGATIVE_INFINITY;
    private double computedPrefWidth = Double.NEGATIVE_INFINITY;
    private double computedPrefHeight = Double.NEGATIVE_INFINITY;
    private double widthForComputedPrefHeight = Double.NEGATIVE_INFINITY;
    private double characterWidth;
    private double lineHeight;

    private ContentView contentView = new ContentView();
    private Group paragraphNodes = new Group();

    private Text promptNode;
    private ObservableBooleanValue usePromptText;

    private ObservableIntegerValue caretPosition;
    private Group selectionHighlightGroup = new Group()</B></FONT>;

    private ScrollPane scrollPane;
    private Bounds oldViewportBounds;

    private VerticalDirection scrollDirection = null;

    private Path characterBoundingPath = new Path();

    private Timeline scrollSelectionTimeline = new Timeline();
    private EventHandler&lt;ActionEvent&gt; scrollSelectionHandler = event -&gt; {
        switch (scrollDirection) {
            case UP: {
                // TODO Get previous offset
                break;
            }

            case DOWN: {
                // TODO Get next offset
                break;
            }
        }
    };

    private double pressX, pressY; // For dragging handles on embedded
    private boolean handlePressed;

    /**
     * Remembers horizontal position when traversing up / down.
     */
    double targetCaretX = -1;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextAreaSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextAreaSkin(final TextArea control) {
        super(control);

        // install default input map for the text area control
        this.behavior = new TextAreaBehavior(control);
        this.behavior.setTextAreaSkin(this);
//        control.setInputMap(behavior.getInputMap());

        this.textArea = control;

        caretPosition = new IntegerBinding() {
            { bind(control.caretPositionProperty()); }
            @Override protected int computeValue() {
                return control.getCaretPosition();
            }
        };
        caretPosition.addListener((observable, oldValue, newValue) -&gt; {
            targetCaretX = -1;
            if (control.getWidth() &gt; 0) {
                setForwardBias(true);
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
            }
        });

//        setManaged(false);

        // Initialize content
        scrollPane = new ScrollPane();
        scrollPane.setFitToWidth(control.isWrapText());
        scrollPane.setContent(contentView);
        getChildren().add(scrollPane);

        getSkinnable().addEventFilter(ScrollEvent.ANY, event -&gt; {
            if (event.isDirect() &amp;&amp; handlePressed) {
                event.consume();
            }
        });

        // Add selection
        selectionHighlightGroup.setManaged(false);
        selectionHighlightGroup.setVisible(false);
        contentView.getChildren().add(selectionHighlightGroup);

        // Add content view
        paragraphNodes.setManaged(false);
        contentView.getChildren().add(paragraphNodes);

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());
        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        contentView.getChildren().add(caretPath);

        if (SHOW_HANDLES) {
            contentView.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
        }

        scrollPane.hvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollLeft(newValue.doubleValue() * getScrollLeftMax());
        });

        scrollPane.vvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollTop(newValue.doubleValue() * getScrollTopMax());
        });

        // Initialize the scroll selection timeline
        scrollSelectionTimeline.setCycleCount(Timeline.INDEFINITE);
        List&lt;KeyFrame&gt; scrollSelectionFrames = scrollSelectionTimeline.getKeyFrames();
        scrollSelectionFrames.clear();
        scrollSelectionFrames.add(new KeyFrame(Duration.millis(350), scrollSelectionHandler));

        // Add initial text content
        for (int i = 0, n = USE_MULTIPLE_NODES ? control.getParagraphs().size() : 1; i &lt; n; i++) {
            CharSequence paragraph = (n == 1) ? control.textProperty().getValueSafe() : control.getParagraphs().get(i);
            addParagraphNode(i, paragraph.toString());
        }

        control.selectionProperty().addListener((observable, oldValue, newValue) -&gt; {
            // TODO Why do we need two calls here?
            control.requestLayout();
            contentView.requestLayout();
        });

        control.wrapTextProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            scrollPane.setFitToWidth(newValue);
        });

        control.prefColumnCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportWidth();
        });

        control.prefRowCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportHeight();
        });

        updateFontMetrics();
        fontMetrics.addListener(valueModel -&gt; {
            updateFontMetrics();
        });

        contentView.paddingProperty().addListener(valueModel -&gt; {
            updatePrefViewportWidth();
            updatePrefViewportHeight();
        });

        scrollPane.viewportBoundsProperty().addListener(valueModel -&gt; {
            if (scrollPane.getViewportBounds() != null) {
                // ScrollPane creates a new Bounds instance for each
                // layout pass, so we need to check if the width/height
                // have really changed to avoid infinite layout requests.
                Bounds newViewportBounds = scrollPane.getViewportBounds();
                if (oldViewportBounds == null ||
                    oldViewportBounds.getWidth() != newViewportBounds.getWidth() ||
                    oldViewportBounds.getHeight() != newViewportBounds.getHeight()) {

                    invalidateMetrics();
                    oldViewportBounds = newViewportBounds;
                    contentView.requestLayout();
                }
            }
        });

        control.scrollTopProperty().addListener((observable, oldValue, newValue) -&gt; {
            double vValue = (newValue.doubleValue() &lt; getScrollTopMax())
                               ? (newValue.doubleValue() / getScrollTopMax()) : 1.0;
            scrollPane.setVvalue(vValue);
        });

        control.scrollLeftProperty().addListener((observable, oldValue, newValue) -&gt; {
            double hValue = (newValue.doubleValue() &lt; getScrollLeftMax())
                               ? (newValue.doubleValue() / getScrollLeftMax()) : 1.0;
            scrollPane.setHvalue(hValue);
        });

        if (USE_MULTIPLE_NODES) {
            control.getParagraphs().addListener((ListChangeListener.Change&lt;? extends CharSequence&gt; change) -&gt; {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends CharSequence&gt; removed = change.getRemoved();
                    if (from &lt; to) {

                        if (removed.isEmpty()) {
                            // This is an add
                            for (int i = from, n = to; i &lt; n; i++) {
                                addParagraphNode(i, change.getList().get(i).toString());
                            }
                        } else {
                            // This is an update
                            for (int i = from, n = to; i &lt; n; i++) {
                                Node node = paragraphNodes.getChildren().get(i);
                                Text paragraphNode = (Text) node;
                                paragraphNode.setText(change.getList().get(i).toString());
                            }
                        }
                    } else {
                        // This is a remove
                        paragraphNodes.getChildren().subList(from, from + removed.size()).clear();
                    }
                }
            });
        } else {
            control.textProperty().addListener(observable -&gt; {
                invalidateMetrics();
                ((Text)paragraphNodes.getChildren().get(0)).setText(control.textProperty().getValueSafe());
                contentView.requestLayout();
            });
        }

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(), control.promptTextProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty());
            }
        };

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        updateHighlightFill();
        updatePrefViewportWidth();
        updatePrefViewportHeight();
        if (control.isFocused()) setCaretAnimating(true);

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                handlePressed = true;
                e.consume();
            };

            EventHandler&lt;MouseEvent&gt; handleReleaseHandler = event -&gt; {
                handlePressed = false;
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseReleased(handleReleaseHandler);
            selectionHandle1.setOnMouseReleased(handleReleaseHandler);
            selectionHandle2.setOnMouseReleased(handleReleaseHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + caretHandle.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle1.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY + selectionHandle1.getHeight() + 5);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &lt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &gt;= control1.getAnchor()) {
                        pos = control1.getAnchor();
                    }
                }
                positionCaret(hit, true);
                e.consume();
            });

            selectionHandle2.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle2.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &gt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &lt;= control1.getAnchor() + 1) {
                        pos = Math.min(control1.getAnchor() + 2, control1.getLength());
                    }
                    positionCaret(hit, true);
                }
                e.consume();
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void invalidateMetrics() {
        computedMinWidth = Double.NEGATIVE_INFINITY;
        computedMinHeight = Double.NEGATIVE_INFINITY;
        computedPrefWidth = Double.NEGATIVE_INFINITY;
        computedPrefHeight = Double.NEGATIVE_INFINITY;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        scrollPane.resizeRelocate(contentX, contentY, contentWidth, contentHeight);
    }

    /** {@inheritDoc} */
    @Override protected void updateHighlightFill() {
        for (Node node : selectionHighlightGroup.getChildren()) {
            Path selectionHighlightPath = (Path)node;
            selectionHighlightPath.setFill(highlightFillProperty().get());
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Text textNode = getTextNode();
        Point2D p = new Point2D(x - textNode.getLayoutX(), y - getTextTranslateY());
        HitInfo hit = textNode.hitTest(translateCaretPosition(p));
        return hit;
    };

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case LINE:
                switch (dir) {
                    case UP:
                        previousLine(select);
                        break;
                    case DOWN:
                        nextLine(select);
                        break;
                    case BEGINNING:
                        lineStart(select, select &amp;&amp; isMac());
                        break;
                    case END:
                        lineEnd(select, select &amp;&amp; isMac());
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PAGE:
                switch (dir) {
                    case UP:
                        previousPage(select);
                        break;
                    case DOWN:
                        nextPage(select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PARAGRAPH:
                switch (dir) {
                    case UP:
                        paragraphStart(true, select);
                        break;
                    case DOWN:
                        paragraphEnd(true, select);
                        break;
                    case BEGINNING:
                        paragraphStart(false, select);
                        break;
                    case END:
                        paragraphEnd(false, select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
            positionCaret(hit.getInsertionIndex(), leading, false, false);
        } else {
            // We're at beginning or end of line. Try moving up / down.
            int dot = textArea.getCaretPosition();
            targetCaretX = moveRight ? 0 : Double.MAX_VALUE;
            // TODO: Use Bidi sniffing instead of assuming right means forward here?
            downLines(moveRight ? 1 : -1, false, false);
            targetCaretX = -1;
            if (dot == textArea.getCaretPosition()) {
                if (moveRight) {
                    textArea.forward();
                } else {
                    textArea.backward();
                }
            }
        }
    }

    private void downLines(int nLines, boolean select, boolean extendSelection) {
        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();

        // The middle y coordinate of the the line we want to go to.
        double targetLineMidY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2 + nLines * lineHeight;
        if (targetLineMidY &lt; 0) {
            targetLineMidY = 0;
        }

        // The target x for the caret. This may have been set during a
        // previous call.
        double x = (targetCaretX &gt;= 0) ? targetCaretX : (caretBounds.getMaxX());

        // Find a text position for the target x,y.
        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));
        int pos = hit.getCharIndex();

        // Save the old pos temporarily while testing the new one.
        int oldPos = textNode.getCaretPosition();
        boolean oldBias = textNode.isCaretBias();
        textNode.setCaretBias(hit.isLeading());
        textNode.setCaretPosition(pos);
        tmpCaretPath.getElements().clear();
        tmpCaretPath.getElements().addAll(textNode.getCaretShape());
        tmpCaretPath.setLayoutX(textNode.getLayoutX());
        tmpCaretPath.setLayoutY(textNode.getLayoutY());
        Bounds tmpCaretBounds = tmpCaretPath.getLayoutBounds();
        // The y for the middle of the row we found.
        double foundLineMidY = (tmpCaretBounds.getMinY() + tmpCaretBounds.getMaxY()) / 2;
        textNode.setCaretBias(oldBias);
        textNode.setCaretPosition(oldPos);

        // Test if the found line is in the correct direction and move
        // the caret.
        if (nLines == 0 ||
                (nLines &gt; 0 &amp;&amp; foundLineMidY &gt; caretBounds.getMaxY()) ||
                (nLines &lt; 0 &amp;&amp; foundLineMidY &lt; caretBounds.getMinY())) {

            positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, extendSelection);
            targetCaretX = x;
        }
    }

    private void previousLine(boolean select) {
        downLines(-1, select, false);
    }

    private void nextLine(boolean select) {
        downLines(1, select, false);
    }

    private void previousPage(boolean select) {
        downLines(-(int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void nextPage(boolean select) {
        downLines((int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void lineStart(boolean select, boolean extendSelection) {
        targetCaretX = 0;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }

    private void lineEnd(boolean select, boolean extendSelection) {
        targetCaretX = Double.MAX_VALUE;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }


    private void paragraphStart(boolean previousIfAtStart, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();

        if (pos &gt; 0) {
            if (previousIfAtStart &amp;&amp; text.codePointAt(pos-1) == 0x0a) {
                // We are at the beginning of a paragraph.
                // Back up to the previous paragraph.
                pos--;
            }
            // Back up to the beginning of this paragraph
            while (pos &gt; 0 &amp;&amp; text.codePointAt(pos-1) != 0x0a) {
                pos--;
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
                setForwardBias(true);
            }
        }
    }

    private void paragraphEnd(boolean goPastInitialNewline, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();
        int len = text.length();
        boolean wentPastInitialNewline = false;
        boolean goPastTrailingNewline = isWindows();

        if (pos &lt; len) {
            if (goPastInitialNewline &amp;&amp; text.codePointAt(pos) == 0x0a) {
                // We are at the end of a paragraph, start by moving to the
                // next paragraph.
                pos++;
                wentPastInitialNewline = true;
            }
            if (!(goPastTrailingNewline &amp;&amp; wentPastInitialNewline)) {
                // Go to the end of this paragraph
                while (pos &lt; len &amp;&amp; text.codePointAt(pos) != 0x0a) {
                    pos++;
                }
                if (goPastTrailingNewline &amp;&amp; pos &lt; len) {
                    // We are at the end of a paragraph, finish by moving to
                    // the beginning of the next paragraph (Windows behavior).
                    pos++;
                }
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.underlineShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.rangeShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        int pStart = 0;
        Text paragraphNode = null;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                paragraphNode = p;
                break;
            }
            pStart = pEnd + 1;
        }

        if (paragraphNode != null) {
            for (Node node : nodes) {
                node.setLayoutX(paragraphNode.getLayoutX());
                node.setLayoutY(paragraphNode.getLayoutY());
            }
        }
        contentView.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        contentView.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        contentView.layoutChildren();
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - contentView.snappedLeftInset() - getSkinnable().getScrollLeft()),
                    Math.max(0, p.getY() - contentView.snappedTopInset() - getSkinnable().getScrollTop()));
        }
        return p;
    }

    // Public for FXVKSkin
    /**
     * Gets the {@code Bounds} of the caret of the skinned {@code TextArea}.
     * @return the {@code Bounds} of the caret shape, relative to the {@code TextArea}.
     */
    public Bounds getCaretBounds() {
        return getSkinnable().sceneToLocal(caretPath.localToScene(caretPath.getBoundsInLocal()));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case LINE_FOR_OFFSET:
            case LINE_START:
            case LINE_END:
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                Text text = getTextNode();
                return text.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }

        // TODO Unregister listeners on text editor, paragraph list
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Text firstParagraph = (Text) paragraphNodes.getChildren().get(0);
        return Utils.getAscent(getSkinnable().getFont(), firstParagraph.getBoundsType())
                + contentView.snappedTopInset() + textArea.snappedTopInset();
    }

    private char getCharacter(int index) {
        int n = paragraphNodes.getChildren().size();

        int paragraphIndex = 0;
        int offset = index;

        String paragraph = null;
        while (paragraphIndex &lt; n) {
            Text paragraphNode = (Text)paragraphNodes.getChildren().get(paragraphIndex);
            paragraph = paragraphNode.getText();
            int count = paragraph.length() + 1;

            if (offset &lt; count) {
                break;
            }

            offset -= count;
            paragraphIndex++;
        }

        return offset == paragraph.length() ? '\n' : paragraph.charAt(offset);
    }

    /** {@inheritDoc} */
    @Override protected int getInsertionPoint(double x, double y) {
        TextArea textArea = getSkinnable();

        int n = paragraphNodes.getChildren().size();
        int index = -1;

        if (n &gt; 0) {
            if (y &lt; contentView.snappedTopInset()) {
                // Select the character at x in the first row
                Text paragraphNode = (Text)paragraphNodes.getChildren().get(0);
                index = getNextInsertionPoint(paragraphNode, x, -1, VerticalDirection.DOWN);
            } else if (y &gt; contentView.snappedTopInset() + contentView.getHeight()) {
                // Select the character at x in the last row
                int lastParagraphIndex = n - 1;
                Text lastParagraphView = (Text)paragraphNodes.getChildren().get(lastParagraphIndex);

                index = getNextInsertionPoint(lastParagraphView, x, -1, VerticalDirection.UP)
                        + (textArea.getLength() - lastParagraphView.getText().length());
            } else {
                // Select the character at x in the row at y
                int paragraphOffset = 0;
                for (int i = 0; i &lt; n; i++) {
                    Text paragraphNode = (Text)paragraphNodes.getChildren().get(i);

                    Bounds bounds = paragraphNode.getBoundsInLocal();
                    double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();
                    if (y &gt;= paragraphViewY
                            &amp;&amp; y &lt; paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {
                        index = getInsertionPoint(paragraphNode,
                                x - paragraphNode.getLayoutX(),
                                y - paragraphNode.getLayoutY()) + paragraphOffset;
                        break;
                    }

                    paragraphOffset += paragraphNode.getText().length() + 1;
                }
            }
        }

        return index;
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, false);
    }

    private void positionCaret(int pos, boolean leading, boolean select, boolean extendSelection) {
        boolean isNewLine =
                (pos &gt; 0 &amp;&amp;
                        pos &lt;= getSkinnable().getLength() &amp;&amp;
                        getSkinnable().getText().codePointAt(pos-1) == 0x0a);

        // special handling for a new line
        if (!leading &amp;&amp; isNewLine) {
            leading = true;
            pos -= 1;
        }

        if (select) {
            if (extendSelection) {
                getSkinnable().extendSelection(pos);
            } else {
                getSkinnable().selectPositionCaret(pos);
            }
        } else {
            getSkinnable().positionCaret(pos);
        }

        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        TextArea textArea = getSkinnable();

        int paragraphIndex = paragraphNodes.getChildren().size();
        int paragraphOffset = textArea.getLength() + 1;

        Text paragraphNode = null;
        do {
            paragraphNode = (Text)paragraphNodes.getChildren().get(--paragraphIndex);
            paragraphOffset -= paragraphNode.getText().length() + 1;
        } while (index &lt; paragraphOffset);

        int characterIndex = index - paragraphOffset;
        boolean terminator = false;

        if (characterIndex == paragraphNode.getText().length()) {
            characterIndex--;
            terminator = true;
        }

        characterBoundingPath.getElements().clear();
        characterBoundingPath.getElements().addAll(paragraphNode.rangeShape(characterIndex, characterIndex + 1));
        characterBoundingPath.setLayoutX(paragraphNode.getLayoutX());
        characterBoundingPath.setLayoutY(paragraphNode.getLayoutY());

        Bounds bounds = characterBoundingPath.getBoundsInLocal();

        double x = bounds.getMinX() + paragraphNode.getLayoutX() - textArea.getScrollLeft();
        double y = bounds.getMinY() + paragraphNode.getLayoutY() - textArea.getScrollTop();

        // Sometimes the bounds is empty, in which case we must ignore the width/height
        double width = bounds.isEmpty() ? 0 : bounds.getWidth();
        double height = bounds.isEmpty() ? 0 : bounds.getHeight();

        if (terminator) {
            x += width;
            width = 0;
        }

        return new Rectangle2D(x, y, width, height);
    }

    /** {@inheritDoc} */
    @Override protected void scrollCharacterToVisible(final int index) {
        // TODO We queue a callback because when characters are added or
        // removed the bounds are not immediately updated; is this really
        // necessary?

        Platform.runLater(() -&gt; {
            if (getSkinnable().getLength() == 0) {
                return;
            }
            Rectangle2D characterBounds = getCharacterBounds(index);
            scrollBoundsToVisible(characterBounds);
        });
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextAreaBehavior getBehavior() {
        return behavior;
    }

    private void createPromptNode() {
        if (promptNode == null &amp;&amp; usePromptText.get()) {
            promptNode = new Text();
            contentView.getChildren().add(0, promptNode);
            promptNode.setManaged(false);
            promptNode.getStyleClass().add(&quot;text&quot;);
            promptNode.visibleProperty().bind(usePromptText);
            promptNode.fontProperty().bind(getSkinnable().fontProperty());
            promptNode.textProperty().bind(getSkinnable().promptTextProperty());
            promptNode.fillProperty().bind(promptTextFillProperty());
        }
    }

    private void addParagraphNode(int i, String string) {
        final TextArea textArea = getSkinnable();
        Text paragraphNode = new Text(string);
        paragraphNode.setTextOrigin(VPos.TOP);
        paragraphNode.setManaged(false);
        paragraphNode.getStyleClass().add(&quot;text&quot;);
        paragraphNode.boundsTypeProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updateFontMetrics();
        });
        paragraphNodes.getChildren().add(i, paragraphNode);

        paragraphNode.fontProperty().bind(textArea.fontProperty());
        paragraphNode.fillProperty().bind(textFillProperty());
        paragraphNode.selectionFillProperty().bind(highlightTextFillProperty());
    }

    private double getScrollTopMax() {
        return Math.max(0, contentView.getHeight() - scrollPane.getViewportBounds().getHeight());
    }

    private double getScrollLeftMax() {
        return Math.max(0, contentView.getWidth() - scrollPane.getViewportBounds().getWidth());
    }

    private int getInsertionPoint(Text paragraphNode, double x, double y) {
        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));
        return hitInfo.getInsertionIndex();
    }

    private int getNextInsertionPoint(Text paragraphNode, double x, int from,
        VerticalDirection scrollDirection) {
        // TODO
        return 0;
    }

    private void scrollCaretToVisible() {
        TextArea textArea = getSkinnable();
        Bounds bounds = caretPath.getLayoutBounds();
        double x = bounds.getMinX() - textArea.getScrollLeft();
        double y = bounds.getMinY() - textArea.getScrollTop();
        double w = bounds.getWidth();
        double h = bounds.getHeight();

        if (SHOW_HANDLES) {
            if (caretHandle.isVisible()) {
                h += caretHandle.getHeight();
            } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
                x -= selectionHandle1.getWidth() / 2;
                y -= selectionHandle1.getHeight();
                w += selectionHandle1.getWidth() / 2 + selectionHandle2.getWidth() / 2;
                h += selectionHandle1.getHeight() + selectionHandle2.getHeight();
            }
        }

        if (w &gt; 0 &amp;&amp; h &gt; 0) {
            scrollBoundsToVisible(new Rectangle2D(x, y, w, h));
        }
    }

    private void scrollBoundsToVisible(Rectangle2D bounds) {
        TextArea textArea = getSkinnable();
        Bounds viewportBounds = scrollPane.getViewportBounds();

        double viewportWidth = viewportBounds.getWidth();
        double viewportHeight = viewportBounds.getHeight();
        double scrollTop = textArea.getScrollTop();
        double scrollLeft = textArea.getScrollLeft();
        double slop = 6.0;

        if (bounds.getMinY() &lt; 0) {
            double y = scrollTop + bounds.getMinY();
            if (y &lt;= contentView.snappedTopInset()) {
                y = 0;
            }
            textArea.setScrollTop(y);
        } else if (contentView.snappedTopInset() + bounds.getMaxY() &gt; viewportHeight) {
            double y = scrollTop + contentView.snappedTopInset() + bounds.getMaxY() - viewportHeight;
            if (y &gt;= getScrollTopMax() - contentView.snappedBottomInset()) {
                y = getScrollTopMax();
            }
            textArea.setScrollTop(y);
        }


        if (bounds.getMinX() &lt; 0) {
            double x = scrollLeft + bounds.getMinX() - slop;
            if (x &lt;= contentView.snappedLeftInset() + slop) {
                x = 0;
            }
            textArea.setScrollLeft(x);
        } else if (contentView.snappedLeftInset() + bounds.getMaxX() &gt; viewportWidth) {
            double x = scrollLeft + contentView.snappedLeftInset() + bounds.getMaxX() - viewportWidth + slop;
            if (x &gt;= getScrollLeftMax() - contentView.snappedRightInset() - slop) {
                x = getScrollLeftMax();
            }
            textArea.setScrollLeft(x);
        }
    }

    private void updatePrefViewportWidth() {
        int columnCount = getSkinnable().getPrefColumnCount();
        scrollPane.setPrefViewportWidth(columnCount * characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
        scrollPane.setMinViewportWidth(characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
    }

    private void updatePrefViewportHeight() {
        int rowCount = getSkinnable().getPrefRowCount();
        scrollPane.setPrefViewportHeight(rowCount * lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
        scrollPane.setMinViewportHeight(lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
    }

    private void updateFontMetrics() {
        Text firstParagraph = (Text)paragraphNodes.getChildren().get(0);
        lineHeight = Utils.getLineHeight(getSkinnable().getFont(), firstParagraph.getBoundsType());
        characterWidth = fontMetrics.get().getCharWidth('W');
    }

    private double getTextTranslateX() {
        return contentView.snappedLeftInset();
    }

    private double getTextTranslateY() {
        return contentView.snappedTopInset();
    }

    private double getTextLeft() {
        return 0;
    }

    private Point2D translateCaretPosition(Point2D p) {
        return p;
    }

    private Text getTextNode() {
        if (USE_MULTIPLE_NODES) {
            throw new IllegalArgumentException(&quot;Multiple node traversal is not yet implemented.&quot;);
        }
        return (Text)paragraphNodes.getChildren().get(0);
    }

    private void updateTextNodeCaretPos(int pos) {
        Text textNode = getTextNode();
        if (isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }



    /**************************************************************************
     *
     * Support classes
     *
     **************************************************************************/

    private class ContentView extends Region {
        {
            getStyleClass().add(&quot;content&quot;);

            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                behavior.mousePressed(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                behavior.mouseReleased(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_DRAGGED, event -&gt; {
                behavior.mouseDragged(event);
                event.consume();
            });
        }

        @Override protected ObservableList&lt;Node&gt; getChildren() {
            return super.getChildren();
        }

        @Override public Orientation getContentBias() {
            return Orientation.HORIZONTAL;
        }

        @Override protected double computePrefWidth(double height) {
            if (computedPrefWidth &lt; 0) {
                double prefWidth = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefWidth = Math.max(prefWidth,
                            Utils.computeTextWidth(paragraphNode.getFont(),
                                    paragraphNode.getText(), 0));
                }

                prefWidth += snappedLeftInset() + snappedRightInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefWidth = Math.max(prefWidth, (viewPortBounds != null) ? viewPortBounds.getWidth() : 0);
            }
            return computedPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            if (width != widthForComputedPrefHeight) {
                invalidateMetrics();
                widthForComputedPrefHeight = width;
            }

            if (computedPrefHeight &lt; 0) {
                double wrappingWidth;
                if (width == -1) {
                    wrappingWidth = 0;
                } else {
                    wrappingWidth = Math.max(width - (snappedLeftInset() + snappedRightInset()), 0);
                }

                double prefHeight = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefHeight += Utils.computeTextHeight(
                            paragraphNode.getFont(),
                            paragraphNode.getText(),
                            wrappingWidth,
                            paragraphNode.getBoundsType());
                }

                prefHeight += snappedTopInset() + snappedBottomInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefHeight = Math.max(prefHeight, (viewPortBounds != null) ? viewPortBounds.getHeight() : 0);
            }
            return computedPrefHeight;
        }

        @Override protected double computeMinWidth(double height) {
            if (computedMinWidth &lt; 0) {
                double hInsets = snappedLeftInset() + snappedRightInset();
                computedMinWidth = Math.min(characterWidth + hInsets, computePrefWidth(height));
            }
            return computedMinWidth;
        }

        @Override protected double computeMinHeight(double width) {
            if (computedMinHeight &lt; 0) {
                double vInsets = snappedTopInset() + snappedBottomInset();
                computedMinHeight = Math.min(lineHeight + vInsets, computePrefHeight(width));
            }
            return computedMinHeight;
        }

        @Override public void layoutChildren() {
            TextArea textArea = getSkinnable();
            double width = getWidth();

            // Lay out paragraphs
            final double topPadding = snappedTopInset();
            final double leftPadding = snappedLeftInset();

            double wrappingWidth = Math.max(width - (leftPadding + snappedRightInset()), 0);

            double y = topPadding;

            final List&lt;Node&gt; paragraphNodesChildren = paragraphNodes.getChildren();

            for (int i = 0; i &lt; paragraphNodesChildren.size(); i++) {
                Node node = paragraphNodesChildren.get(i);
                Text paragraphNode = (Text)node;
                paragraphNode.setWrappingWidth(wrappingWidth);

                Bounds bounds = paragraphNode.getBoundsInLocal();
                paragraphNode.setLayoutX(leftPadding);
                paragraphNode.setLayoutY(y);

                y += bounds.getHeight();
            }

            if (promptNode != null) {
                promptNode.setLayoutX(leftPadding);
                promptNode.setLayoutY(topPadding + promptNode.getBaselineOffset());
                promptNode.setWrappingWidth(wrappingWidth);
            }

            // Update the selection
            IndexRange selection = textArea.getSelection();
            Bounds oldCaretBounds = caretPath.getBoundsInParent();

            selectionHighlightGroup.getChildren().clear();

            int caretPos = textArea.getCaretPosition();
            int anchorPos = textArea.getAnchor();

            if (SHOW_HANDLES) {
                // Install and resize the handles for caret and anchor.
                if (selection.getLength() &gt; 0) {
                    selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                            selectionHandle1.prefHeight(-1));
                    selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                            selectionHandle2.prefHeight(-1));
                } else {
                    caretHandle.resize(caretHandle.prefWidth(-1),
                            caretHandle.prefHeight(-1));
                }

                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the actual caret.
                if (selection.getLength() &gt; 0) {
                    int paragraphIndex = paragraphNodesChildren.size();
                    int paragraphOffset = textArea.getLength() + 1;
                    Text paragraphNode = null;
                    do {
                        paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                        paragraphOffset -= paragraphNode.getText().length() + 1;
                    } while (anchorPos &lt; paragraphOffset);

                    updateTextNodeCaretPos(anchorPos - paragraphOffset);
                    caretPath.getElements().clear();
                    caretPath.getElements().addAll(paragraphNode.getCaretShape());
                    caretPath.setLayoutX(paragraphNode.getLayoutX());
                    caretPath.setLayoutY(paragraphNode.getLayoutY());

                    Bounds b = caretPath.getBoundsInParent();
                    if (caretPos &lt; anchorPos) {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    } else {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    }
                }
            }

            {
                // Position caret
                int paragraphIndex = paragraphNodesChildren.size();
                int paragraphOffset = textArea.getLength() + 1;

                Text paragraphNode = null;
                do {
                    paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                    paragraphOffset -= paragraphNode.getText().length() + 1;
                } while (caretPos &lt; paragraphOffset);

                updateTextNodeCaretPos(caretPos - paragraphOffset);

                caretPath.getElements().clear();
                caretPath.getElements().addAll(paragraphNode.getCaretShape());

                caretPath.setLayoutX(paragraphNode.getLayoutX());

                // TODO: Remove this temporary workaround for RT-27533
                paragraphNode.setLayoutX(2 * paragraphNode.getLayoutX() - paragraphNode.getBoundsInParent().getMinX());

                caretPath.setLayoutY(paragraphNode.getLayoutY());
                if (oldCaretBounds == null || !oldCaretBounds.equals(caretPath.getBoundsInParent())) {
                    scrollCaretToVisible();
                }
            }

            // Update selection fg and bg
            int start = selection.getStart();
            int end = selection.getEnd();
            for (int i = 0, max = paragraphNodesChildren.size(); i &lt; max; i++) {
                Node paragraphNode = paragraphNodesChildren.get(i);
                Text textNode = (Text)paragraphNode;
                int paragraphLength = textNode.getText().length() + 1;
                if (end &gt; start &amp;&amp; start &lt; paragraphLength) {
                    textNode.setSelectionStart(start);
                    textNode.setSelectionEnd(Math.min(end, paragraphLength));

                    Path selectionHighlightPath = new Path();
                    selectionHighlightPath.setManaged(false);
                    selectionHighlightPath.setStroke(null);
                    PathElement[] selectionShape = textNode.getSelectionShape();
                    if (selectionShape != null) {
                        selectionHighlightPath.getElements().addAll(selectionShape);
                    }
                    selectionHighlightGroup.getChildren().add(selectionHighlightPath);
                    selectionHighlightGroup.setVisible(true);
                    selectionHighlightPath.setLayoutX(textNode.getLayoutX());
                    selectionHighlightPath.setLayoutY(textNode.getLayoutY());
                    updateHighlightFill();
                } else {
                    textNode.setSelectionStart(-1);
                    textNode.setSelectionEnd(-1);
                    selectionHighlightGroup.setVisible(false);
                }
                start = Math.max(0, start - paragraphLength);
                end   = Math.max(0, end   - paragraphLength);
            }

            if (SHOW_HANDLES) {
                // Position handle for the caret. This could be handle1 or handle2 when
                // a selection is active.
                Bounds b = caretPath.getBoundsInParent();
                if (selection.getLength() &gt; 0) {
                    if (caretPos &lt; anchorPos) {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    } else {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    }
                } else {
                    caretHandle.setLayoutX(b.getMinX() - caretHandle.getWidth() / 2 + 1);
                    caretHandle.setLayoutY(b.getMaxY());
                }
            }

            if (scrollPane.getPrefViewportWidth() == 0
                    || scrollPane.getPrefViewportHeight() == 0) {
                updatePrefViewportWidth();
                updatePrefViewportHeight();
                if (getParent() != null &amp;&amp; scrollPane.getPrefViewportWidth() &gt; 0
                        || scrollPane.getPrefViewportHeight() &gt; 0) {
                    // Force layout of viewRect in ScrollPaneSkin
                    getParent().requestLayout();
                }
            }

            // RT-36454: Fit to width/height only if smaller than viewport.
            // That is, grow to fit but don't shrink to fit.
            Bounds viewportBounds = scrollPane.getViewportBounds();
            boolean wasFitToWidth = scrollPane.isFitToWidth();
            boolean wasFitToHeight = scrollPane.isFitToHeight();
            boolean setFitToWidth = textArea.isWrapText() || computePrefWidth(-1) &lt;= viewportBounds.getWidth();
            boolean setFitToHeight = computePrefHeight(width) &lt;= viewportBounds.getHeight();
            if (wasFitToWidth != setFitToWidth || wasFitToHeight != setFitToHeight) {
                Platform.runLater(() -&gt; {
                    scrollPane.setFitToWidth(setFitToWidth);
                    scrollPane.setFitToHeight(setFitToHeight);
                });
                getParent().requestLayout();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextFieldSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableDoubleValue;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import java.util.List;
import com.sun.javafx.scene.control.behavior.TextFieldBehavior;
import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;

/**
 * Default skin implementation for the {@link TextField} control.
 *
 * @see TextField
 * @since 9
 */
public class TextFieldSkin extends TextInputControlSkin&lt;TextField&gt; {

    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    private final TextFieldBehavior behavior;

    /**
     * This group contains the text, caret, and selection rectangle.
     * It is clipped. The textNode, selectionHighlightPath, and
     * caret are each translated individually when horizontal
     * translation is needed to keep the caretPosition visible.
     */
    private Pane textGroup = new Pane();
    private Group handleGroup;

    /**
<A NAME="15"></A>     * The clip, applied to the textGroup. This makes sure that any
     * text / selection wandering off the text box is clipped
     */
    private Rectangle clip = <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#15',2,'match42-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Rectangle();
    /**
     * The node actually displaying the text. Note that it has the
     * ability to render both the normal fill as well as the highlight
     * fill, to perform hit testing, fetching of the selection
     * highlight, and other such duties.
     */
    private Text textNode = new Text();
    /**
     *
     * The node used for showing the prompt text.
     */
    private Text promptNode;
    /**
     * A path, provided by the textNode, which represents the area
     * which is selected. The path elements which make up the
     * selection must be updated whenever the selection changes. We
     * don't need to keep track of text changes because those will
     * force the selection to be updated.
     */
    private Path selectionHighlightPath = new Path();

    private Path characterBoundingPath = new Path();
    private ObservableBooleanValue usePromptText;
    private DoubleProperty textTranslateX = new SimpleDoubleProperty(this, &quot;textTranslateX&quot;)</B></FONT>;
    private double caretWidth;

    /**
     * Right edge of the text region sans padding
     */
    private ObservableDoubleValue textRight;

    private double pressX, pressY; // For dragging handles on embedded

    // For use with PasswordField
    static final char BULLET = '\u25cf';



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextFieldSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextFieldSkin(final TextField control) {
        super(control);

        // install default input map for the text field control
        this.behavior = (control instanceof PasswordField)
                ? new PasswordFieldBehavior((PasswordField)control)
                : new TextFieldBehavior(control);
        this.behavior.setTextFieldSkin(this);
//        control.setInputMap(behavior.getInputMap());

        control.caretPositionProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
                if (!isForwardBias()) {
                    setForwardBias(true);
                }
                updateCaretOff();
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
                updateCaretOff();
            }
        });

        textRight = new DoubleBinding() {
            { bind(textGroup.widthProperty()); }
            @Override protected double computeValue() {
                return textGroup.getWidth();
            }
        };

        // Once this was crucial for performance, not sure now.
        clip.setSmooth(false);
        clip.setX(0);
        clip.widthProperty().bind(textGroup.widthProperty());
        clip.heightProperty().bind(textGroup.heightProperty());

        // Add content
        textGroup.setClip(clip);
        // Hack to defeat the fact that otherwise when the caret blinks the parent group
        // bounds are completely invalidated and therefore the dirty region is much
        // larger than necessary.
        textGroup.getChildren().addAll(selectionHighlightPath, textNode, new Group(caretPath));
        getChildren().add(textGroup);
        if (SHOW_HANDLES) {
            handleGroup = new Group();
            handleGroup.setManaged(false);
            handleGroup.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
            getChildren().add(handleGroup);
        }

        // Add text
        textNode.setManaged(false);
        textNode.getStyleClass().add(&quot;text&quot;);
        textNode.fontProperty().bind(control.fontProperty());

        textNode.layoutXProperty().bind(textTranslateX);
        textNode.textProperty().bind(new StringBinding() {
            { bind(control.textProperty()); }
            @Override protected String computeValue() {
                return maskText(control.textProperty().getValueSafe());
            }
        });
        textNode.fillProperty().bind(textFillProperty());
        textNode.selectionFillProperty().bind(new ObjectBinding&lt;Paint&gt;() {
            { bind(highlightTextFillProperty(), textFillProperty(), control.focusedProperty()); }
            @Override protected Paint computeValue() {
                return control.isFocused() ? highlightTextFillProperty().get() : textFillProperty().get();
            }
        });
        // updated by listener on caretPosition to ensure order
        updateTextNodeCaretPos(control.getCaretPosition());
        control.selectionProperty().addListener(observable -&gt; {
            updateSelection();
        });

        // Add selection
        selectionHighlightPath.setManaged(false);
        selectionHighlightPath.setStroke(null);
        selectionHighlightPath.layoutXProperty().bind(textTranslateX);
        selectionHighlightPath.visibleProperty().bind(control.anchorProperty().isNotEqualTo(control.caretPositionProperty()).and(control.focusedProperty()));
        selectionHighlightPath.fillProperty().bind(highlightFillProperty());
        textNode.selectionShapeProperty().addListener(observable -&gt; {
            updateSelection();
        });

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());

        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
<A NAME="71"></A>            }
        });
        caretPath.layoutXProperty().bind(textTranslateX);
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#71',2,'match42-top.html#71',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>textNode.caretShapeProperty().addListener(observable -&gt; {
            caretPath.getElements().setAll(textNode.caretShapeProperty().get());
            if (caretPath.getElements().size() == 0) {
                // The caret pos is invalid.
                updateTextNodeCaretPos(control.getCaretPosition</B></FONT>());
            } else if (caretPath.getElements().size() == 4) {
                // The caret is split. Ignore and keep the previous width value.
            } else {
                caretWidth = Math.round(caretPath.getLayoutBounds().getWidth());
            }
        });

        // Be sure to get the control to request layout when the font changes,
        // since this will affect the pref height and pref width.
        control.fontProperty().addListener(observable -&gt; {
            // I do both so that any cached values for prefWidth/height are cleared.
            // The problem is that the skin is unmanaged and so calling request layout
            // doesn't walk up the tree all the way. I think....
            control.requestLayout();
            getSkinnable().requestLayout();
        });

        registerChangeListener(control.prefColumnCountProperty(), e -&gt; getSkinnable().requestLayout());
        if (control.isFocused()) setCaretAnimating(true);

        control.alignmentProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextPos();
                updateCaretOff();
                control.requestLayout();
            }
        });

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(),
                   control.promptTextProperty(),
                   promptTextFillProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty() &amp;&amp;
                        !getPromptTextFill().equals(Color.TRANSPARENT));
            }
        };

        promptTextFillProperty().addListener(observable -&gt; {
            updateTextPos();
        });

        control.textProperty().addListener(observable -&gt; {
            if (!behavior.isEditing()) {
                // Text changed, but not by user action
                updateTextPos();
            }
        });

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                e.consume();
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Point2D p = new Point2D(caretHandle.getLayoutX() + e.getX() + pressX - textNode.getLayoutX(),
                                        caretHandle.getLayoutY() + e.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(p);
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent e) {
                    TextField control = getSkinnable();
                    Point2D tp = textNode.localToScene(0, 0);
                    Point2D p = new Point2D(e.getSceneX() - tp.getX() + 10/*??*/ - pressX + selectionHandle1.getWidth() / 2,
                                            e.getSceneY() - tp.getY() - pressY - 6);
                    HitInfo hit = textNode.hitTest(p);
                    if (control.getAnchor() &lt; control.getCaretPosition()) {
                        // Swap caret and anchor
                        control.selectRange(control.getCaretPosition(), control.getAnchor());
                    }
                    int pos = hit.getInsertionIndex();
                    if (pos &gt;= 0) {
                        if (pos &gt;= control.getAnchor() - 1) {
                            pos = Math.max(0, control.getAnchor() - 1);
                        }
                        positionCaret(pos, hit.isLeading(), true);
                    }
                    e.consume();
                }
            });

            selectionHandle2.setOnMouseDragged(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent e) {
                    TextField control = getSkinnable();
                    Point2D tp = textNode.localToScene(0, 0);
                    Point2D p = new Point2D(e.getSceneX() - tp.getX() + 10/*??*/ - pressX + selectionHandle2.getWidth() / 2,
                                            e.getSceneY() - tp.getY() - pressY - 6);
                    HitInfo hit = textNode.hitTest(p);
                    if (control.getAnchor() &gt; control.getCaretPosition()) {
                        // Swap caret and anchor
                        control.selectRange(control.getCaretPosition(), control.getAnchor());
                    }
                    int pos = hit.getInsertionIndex();
                    if (pos &gt; 0) {
                        if (pos &lt;= control.getAnchor()) {
                            pos = Math.min(control.getAnchor() + 1, control.getLength());
                        }
                        positionCaret(pos, hit.isLeading(), true);
                    }
                    e.consume();
                }
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        TextField textField = getSkinnable();

        double characterWidth = fontMetrics.get().getCharWidth('W');

        int columnCount = textField.getPrefColumnCount();

        return columnCount * characterWidth + leftInset + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + textNode.getLayoutBounds().getHeight() + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().prefHeight(width);
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + textNode.getBaselineOffset();
    }

    // Public for behavior
    /**
     * Replaces a range of characters with the given text.
     *
     * Call this implementation from behavior classes instead of the
     * one provided on TextInputControl to ensure that the text
     * scrolls as needed.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param txt The text that is to replace the range. This must not be null.
     * @see TextField#replaceText(int, int, String)
     */
    public void replaceText(int start, int end, String txt) {
        final double textMaxXOld = textNode.getBoundsInParent().getMaxX();
        final double caretMaxXOld = caretPath.getLayoutBounds().getMaxX() + textTranslateX.get();
        getSkinnable().replaceText(start, end, txt);
        scrollAfterDelete(textMaxXOld, caretMaxXOld);
    }

    // Public for behavior
    /**
     * Deletes the character that follows or precedes the current
     * caret position from the text if there is no selection, or
     * deletes the selection if there is one.
     *
     * Call this implementation from behavior classes instead of the
     * one provided on TextInputControl to ensure that the text
     * scrolls as needed.
     *
     * @param previous whether to delete the preceding character.
     */
    public void deleteChar(boolean previous) {
        final double textMaxXOld = textNode.getBoundsInParent().getMaxX();
        final double caretMaxXOld = caretPath.getLayoutBounds().getMaxX() + textTranslateX.get();
        if (previous ? getSkinnable().deletePreviousChar() : getSkinnable().deleteNextChar()) {
            scrollAfterDelete(textMaxXOld, caretMaxXOld);
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Point2D p = new Point2D(x - textTranslateX.get() - snappedLeftInset(),
                                y - snappedTopInset());
        return textNode.hitTest(p);
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select);
    }

    private void positionCaret(int pos, boolean leading, boolean select) {
        TextField textField = getSkinnable();
        if (select) {
            textField.selectPositionCaret(pos);
        } else {
            textField.positionCaret(pos);
        }
        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        double x, y;
        double width, height;
        if (index == textNode.getText().length()) {
            Bounds textNodeBounds = textNode.getBoundsInLocal();
            x = textNodeBounds.getMaxX();
            y = 0;
            width = 0;
            height = textNodeBounds.getMaxY();
        } else {
            characterBoundingPath.getElements().clear();
            characterBoundingPath.getElements().addAll(textNode.rangeShape(index, index + 1));
            characterBoundingPath.setLayoutX(textNode.getLayoutX());
            characterBoundingPath.setLayoutY(textNode.getLayoutY());

            Bounds bounds = characterBoundingPath.getBoundsInLocal();

            x = bounds.getMinX();
            y = bounds.getMinY();
            // Sometimes the bounds is empty, in which case we must ignore the width/height
            width  = bounds.isEmpty() ? 0 : bounds.getWidth();
            height = bounds.isEmpty() ? 0 : bounds.getHeight();
        }

        Bounds textBounds = textGroup.getBoundsInParent();

        return new Rectangle2D(x + textBounds.getMinX() + textTranslateX.get(),
                y + textBounds.getMinY(), width, height);
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        return textNode.underlineShape(start, end);
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        return textNode.rangeShape(start, end);
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        textGroup.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        textGroup.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;
            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
        }
        positionCaret(hit.getInsertionIndex(), leading, false);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        super.layoutChildren(x, y, w, h);

        if (textNode != null) {
            double textY;
            final Bounds textNodeBounds = textNode.getLayoutBounds();
            final double ascent = textNode.getBaselineOffset();
            final double descent = textNodeBounds.getHeight() - ascent;

            switch (getSkinnable().getAlignment().getVpos()) {
                case TOP:
                    textY = ascent;
                    break;

                case CENTER:
                    textY = (ascent + textGroup.getHeight() - descent) / 2;
                    break;

                case BOTTOM:
                default:
                    textY = textGroup.getHeight() - descent;
            }
            textNode.setY(textY);
            if (promptNode != null) {
                promptNode.setY(textY);
            }

            if (getSkinnable().getWidth() &gt; 0) {
                updateTextPos();
                updateCaretOff();
            }
        }

        if (SHOW_HANDLES) {
            handleGroup.setLayoutX(x + caretWidth / 2);
            handleGroup.setLayoutY(y);

            // Resize handles for caret and anchor.
//            IndexRange selection = textField.getSelection();
            selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                    selectionHandle1.prefHeight(-1));
            selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                    selectionHandle2.prefHeight(-1));
            caretHandle.resize(caretHandle.prefWidth(-1),
                    caretHandle.prefHeight(-1));

            Bounds b = caretPath.getBoundsInParent();
            caretHandle.setLayoutY(b.getMaxY() - 1);
            //selectionHandle1.setLayoutY(b.getMaxY() - 1);
            selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
            selectionHandle2.setLayoutY(b.getMaxY() - 1);
        }
    }

    private HPos getHAlignment() {
        HPos hPos = getSkinnable().getAlignment().getHpos();
        return hPos;
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - textNode.getLayoutX() - snappedLeftInset() + textTranslateX.get()),
                    Math.max(0, p.getY() - textNode.getLayoutY() - snappedTopInset()));
        }
        return p;
    }

    /** {@inheritDoc} */
    @Override protected String maskText(String txt) {
        if (getSkinnable() instanceof PasswordField) {
            int n = txt.length();
            StringBuilder passwordBuilder = new StringBuilder(n);
            for (int i = 0; i &lt; n; i++) {
                passwordBuilder.append(BULLET);
            }

            return passwordBuilder.toString();
        } else {
            return txt;
        }
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                return textNode.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextInputControlBehavior getBehavior() {
        return behavior;
    }

    private void updateTextNodeCaretPos(int pos) {
        if (pos == 0 || isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }

    private void createPromptNode() {
        if (promptNode != null || !usePromptText.get()) return;

        promptNode = new Text();
        textGroup.getChildren().add(0, promptNode);
        promptNode.setManaged(false);
        promptNode.getStyleClass().add(&quot;text&quot;);
        promptNode.visibleProperty().bind(usePromptText);
        promptNode.fontProperty().bind(getSkinnable().fontProperty());

        promptNode.textProperty().bind(getSkinnable().promptTextProperty());
        promptNode.fillProperty().bind(promptTextFillProperty());
        updateSelection();
    }

    private void updateSelection() {
        TextField textField = getSkinnable();
        IndexRange newValue = textField.getSelection();

        if (newValue == null || newValue.getLength() == 0) {
            textNode.selectionStartProperty().set(-1);
            textNode.selectionEndProperty().set(-1);
        } else {
            textNode.selectionStartProperty().set(newValue.getStart());
            // This intermediate value is needed to force selection shape layout.
            textNode.selectionEndProperty().set(newValue.getStart());
            textNode.selectionEndProperty().set(newValue.getEnd());
        }

        PathElement[] elements = textNode.selectionShapeProperty().get();
        if (elements == null) {
            selectionHighlightPath.getElements().clear();
        } else {
            selectionHighlightPath.getElements().setAll(elements);
        }

        if (SHOW_HANDLES &amp;&amp; newValue != null &amp;&amp; newValue.getLength() &gt; 0) {
            int caretPos = textField.getCaretPosition();
            int anchorPos = textField.getAnchor();

            {
                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the handle for the caret.
                updateTextNodeCaretPos(anchorPos);
                Bounds b = caretPath.getBoundsInParent();
                if (caretPos &lt; anchorPos) {
                    selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                } else {
                    selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                }
            }

            {
                // Position handle for the caret. This could be handle1 or handle2.
                updateTextNodeCaretPos(caretPos);
                Bounds b = caretPath.getBoundsInParent();
                if (caretPos &lt; anchorPos) {
                    selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                } else {
                    selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                }
            }
        }
    }

    /**
     * Updates the textTranslateX value for the Text node position. This is
     * done for general layout, but care is taken to avoid resetting the
     * position when there's a need to scroll the text due to caret movement,
     * or when editing text that overflows on either side.
     */
    private void updateTextPos() {
        double oldX = textTranslateX.get();
        double newX;
        double textNodeWidth = textNode.getLayoutBounds().getWidth();

        switch (getHAlignment()) {
          case CENTER:
            double midPoint = textRight.get() / 2;
            if (usePromptText.get()) {
                // If a prompt is shown (which implies that the text is
                // empty), then we align the Text node so that the caret will
                // appear at the left of the centered prompt.
                newX = midPoint - promptNode.getLayoutBounds().getWidth() / 2;
                promptNode.setLayoutX(newX);
            } else {
                newX = midPoint - textNodeWidth / 2;
            }
            // Update if there is space on the right
            if (newX + textNodeWidth &lt;= textRight.get()) {
                textTranslateX.set(newX);
            }
            break;

          case RIGHT:
            newX = textRight.get() - textNodeWidth - caretWidth / 2;
            // Update if there is space on the right
            if (newX &gt; oldX || newX &gt; 0) {
                textTranslateX.set(newX);
            }
            if (usePromptText.get()) {
                promptNode.setLayoutX(textRight.get() - promptNode.getLayoutBounds().getWidth() -
                                      caretWidth / 2);
            }
            break;

          case LEFT:
          default:
            newX = caretWidth / 2;
            // Update if there is space on either side.
            if (newX &lt; oldX || newX + textNodeWidth &lt;= textRight.get()) {
                textTranslateX.set(newX);
            }
            if (usePromptText.get()) {
                promptNode.layoutXProperty().set(newX);
            }
        }
    }

    // should be called when the padding changes, or the text box width, or
    // the dot moves
    private void updateCaretOff() {
        double delta = 0.0;
        double caretX = caretPath.getLayoutBounds().getMinX() + textTranslateX.get();
        // If the caret position is less than or equal to the left edge of the
        // clip then the caret will be clipped. We want the caret to end up
        // being positioned one pixel right of the clip's left edge. The same
        // applies on the right edge (but going the other direction of course).
        if (caretX &lt; 0) {
            // I'll end up with a negative number
            delta = caretX;
        } else if (caretX &gt; (textRight.get() - caretWidth)) {
            // I'll end up with a positive number
            delta = caretX - (textRight.get() - caretWidth);
        }

        // If delta is negative, then translate in the negative direction
        // to cause the text to scroll to the right. Vice-versa for positive.
        switch (getHAlignment()) {
          case CENTER:
            textTranslateX.set(textTranslateX.get() - delta);
            break;

          case RIGHT:
            textTranslateX.set(Math.max(textTranslateX.get() - delta,
                                        textRight.get() - textNode.getLayoutBounds().getWidth() -
                                        caretWidth / 2));
            break;

          case LEFT:
          default:
            textTranslateX.set(Math.min(textTranslateX.get() - delta,
                                        caretWidth / 2));
        }
        if (SHOW_HANDLES) {
            caretHandle.setLayoutX(caretX - caretHandle.getWidth() / 2);
        }
    }

    private void scrollAfterDelete(double textMaxXOld, double caretMaxXOld) {
        final Bounds textLayoutBounds = textNode.getLayoutBounds();
        final Bounds textBounds = textNode.localToParent(textLayoutBounds);
        final Bounds clipBounds = clip.getBoundsInParent();
        final Bounds caretBounds = caretPath.getLayoutBounds();

        switch (getHAlignment()) {
          case RIGHT:
            if (textBounds.getMaxX() &gt; clipBounds.getMaxX()) {
                double delta = caretMaxXOld - caretBounds.getMaxX() - textTranslateX.get();
                if (textBounds.getMaxX() + delta &lt; clipBounds.getMaxX()) {
                    if (textMaxXOld &lt;= clipBounds.getMaxX()) {
                        delta = textMaxXOld - textBounds.getMaxX();
                    } else {
                        delta = clipBounds.getMaxX() - textBounds.getMaxX();
                    }
                }
                textTranslateX.set(textTranslateX.get() + delta);
            } else {
                updateTextPos();
            }
            break;

          case LEFT:
          case CENTER:
          default:
            if (textBounds.getMinX() &lt; clipBounds.getMinX() + caretWidth / 2 &amp;&amp;
                textBounds.getMaxX() &lt;= clipBounds.getMaxX()) {
                double delta = caretMaxXOld - caretBounds.getMaxX() - textTranslateX.get();
                if (textBounds.getMaxX() + delta &lt; clipBounds.getMaxX()) {
                    if (textMaxXOld &lt;= clipBounds.getMaxX()) {
                        delta = textMaxXOld - textBounds.getMaxX();
                    } else {
                        delta = clipBounds.getMaxX() - textBounds.getMaxX();
                    }
                }
                textTranslateX.set(textTranslateX.get() + delta);
            }
        }

        updateCaretOff();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TreeTableViewSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.collections.NonIterableChange;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;

import com.sun.javafx.scene.control.TreeTableViewBackingList;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.event.WeakEventHandler;
import javafx.scene.control.*;

import com.sun.javafx.scene.control.behavior.TreeTableViewBehavior;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.control.TreeItem.TreeModificationEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.util.Callback;

/**
 * Default skin implementation for the {@link TreeTableView} control.
 *
 * @see TreeTableView
 * @since 9
 */
public class TreeTableViewSkin&lt;T&gt; extends TableViewSkinBase&lt;T, TreeItem&lt;T&gt;, TreeTableView&lt;T&gt;, TreeTableRow&lt;T&gt;, TreeTableColumn&lt;T,?&gt;&gt; {

    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    TreeTableViewBackingList&lt;T&gt; tableBackingList;
    ObjectProperty&lt;ObservableList&lt;TreeItem&lt;T&gt;&gt;&gt; tableBackingListProperty;

    private WeakReference&lt;TreeItem&lt;T&gt;&gt; weakRootRef;
    private final TreeTableViewBehavior&lt;T&gt;  behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private EventHandler&lt;TreeItem.TreeModificationEvent&lt;T&gt;&gt; rootListener = e -&gt; {
        if (e.wasAdded() &amp;&amp; e.wasRemoved() &amp;&amp; e.getAddedSize() == e.getRemovedSize()) {
            // Fix for RT-14842, where the children of a TreeItem were changing,
            // but because the overall item count was staying the same, there was
            // no event being fired to the skin to be informed that the items
            // had changed. So, here we just watch for the case where the number
            // of items being added is equal to the number of items being removed.
            markItemCountDirty();
            getSkinnable().requestLayout();
        } else if (e.getEventType().equals(TreeItem.valueChangedEvent())) {
            // Fix for RT-14971 and RT-15338.
            requestRebuildCells();
        } else {
            // Fix for RT-20090. We are checking to see if the event coming
            // from the TreeItem root is an event where the count has changed.
            EventType&lt;?&gt; eventType = e.getEventType();
            while (eventType != null) {
                if (eventType.equals(TreeItem.&lt;T&gt;expandedItemCountChangeEvent())) {
                    markItemCountDirty();
                    getSkinnable().requestLayout();
                    break;
                }
                eventType = eventType.getSuperType();
            }
        }

        // fix for RT-37853
        getSkinnable().edit(-1, null);
    };

    private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakRootListener;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TreeTableViewSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TreeTableViewSkin(final TreeTableView&lt;T&gt; control) {
        super(control);

        // install default input map for the TreeTableView control
        behavior = new TreeTableViewBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        flow.setFixedCellSize(control.getFixedCellSize());
        flow.setCellFactory(flow -&gt; createCell());

        setRoot(getSkinnable().getRoot());

        EventHandler&lt;MouseEvent&gt; ml = event -&gt; {
            // RT-15127: cancel editing on scroll. This is a bit extreme
            // (we are cancelling editing on touching the scrollbars).
            // This can be improved at a later date.
            if (control.getEditingCell() != null) {
                control.edit(-1, null);
            }

            // This ensures that the table maintains the focus, even when the vbar
            // and hbar controls inside the flow are clicked. Without this, the
            // focus border will not be shown when the user interacts with the
            // scrollbars, and more importantly, keyboard navigation won't be
            // available to the user.
            if (control.isFocusTraversable()) {
                control.requestFocus();
            }
        };
        flow.getVbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
<A NAME="31"></A>        flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);

        // init the behavior 'closures'
        behavior.setOnFocusPreviousRow(() -&gt; <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#31',2,'match42-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>onFocusPreviousCell());
        behavior.setOnFocusNextRow(() -&gt; onFocusNextCell());
        behavior.setOnMoveToFirstCell(() -&gt; onMoveToFirstCell());
        behavior.setOnMoveToLastCell(() -&gt; onMoveToLastCell());
        behavior.setOnScrollPageDown(isFocusDriven -&gt; onScrollPageDown(isFocusDriven));
        behavior.setOnScrollPageUp(isFocusDriven -&gt; onScrollPageUp(isFocusDriven));
        behavior.setOnSelectPreviousRow(() -&gt; onSelectPreviousCell</B></FONT>());
        behavior.setOnSelectNextRow(() -&gt; onSelectNextCell());
<A NAME="32"></A>        behavior.setOnSelectLeftCell(() -&gt; onSelectLeftCell());
        behavior.setOnSelectRightCell(() -&gt; onSelectRightCell());

        <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#32',2,'match42-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>registerChangeListener(control.rootProperty(), e -&gt; {
            // fix for RT-37853
            getSkinnable().edit(-1, null);

            setRoot(getSkinnable().getRoot());
        });
        registerChangeListener</B></FONT>(control.showRootProperty(), e -&gt; {
            // if we turn off showing the root, then we must ensure the root
            // is expanded - otherwise we end up with no visible items in
            // the tree.
            if (! getSkinnable().isShowRoot() &amp;&amp; getRoot() != null) {
                getRoot().setExpanded(true);
            }
            // update the item count in the flow and behavior instances
            updateItemCount();
        });
        registerChangeListener(control.rowFactoryProperty(), e -&gt; flow.recreateCells());
        registerChangeListener(control.expandedItemCountProperty(), e -&gt; markItemCountDirty());
        registerChangeListener(control.fixedCellSizeProperty(), e -&gt; flow.setFixedCellSize(getSkinnable().getFixedCellSize()));
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROW_AT_INDEX: {
                final int rowIndex = (Integer)parameters[0];
                return rowIndex &lt; 0 ? null : flow.getPrivateCell(rowIndex);
            }
            case SELECTED_ITEMS: {
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                TreeTableView.TreeTableViewSelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
                for (TreeTablePosition&lt;T,?&gt; pos : sm.getSelectedCells()) {
                    TreeTableRow&lt;T&gt; row = flow.getPrivateCell(pos.getRow());
                    if (row != null) selection.add(row);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: // TableViewSkinBase
            case CELL_AT_ROW_COLUMN: // TableViewSkinBase
            case COLUMN_AT_INDEX: // TableViewSkinBase
            case HEADER: // TableViewSkinBase
            case VERTICAL_SCROLLBAR: // TableViewSkinBase
            case HORIZONTAL_SCROLLBAR: // TableViewSkinBase
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    @Override
    protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SHOW_ITEM: {
                Node item = (Node)parameters[0];
                if (item instanceof TreeTableCell) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    TreeTableCell&lt;T, ?&gt; cell = (TreeTableCell&lt;T, ?&gt;)item;
                    flow.scrollTo(cell.getIndex());
                }
                break;
            }
            case SET_SELECTED_ITEMS: {
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;Node&gt; items = (ObservableList&lt;Node&gt;)parameters[0];
                if (items != null) {
                    TreeTableView.TreeTableViewSelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
                    if (sm != null) {
                        sm.clearSelection();
                        for (Node item : items) {
                            if (item instanceof TreeTableCell) {
                                @SuppressWarnings(&quot;unchecked&quot;)
                                TreeTableCell&lt;T, ?&gt; cell = (TreeTableCell&lt;T, ?&gt;)item;
                                sm.select(cell.getIndex(), cell.getTableColumn());
                            }
                        }
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private methods                                                         *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    private TreeTableRow&lt;T&gt; createCell() {
        TreeTableRow&lt;T&gt; cell;

        TreeTableView&lt;T&gt; treeTableView = getSkinnable();
        if (treeTableView.getRowFactory() != null) {
            cell = treeTableView.getRowFactory().call(treeTableView);
        } else {
            cell = new TreeTableRow&lt;T&gt;();
        }

        // If there is no disclosure node, then add one of my own
        if (cell.getDisclosureNode() == null) {
            final StackPane disclosureNode = new StackPane();
            disclosureNode.getStyleClass().setAll(&quot;tree-disclosure-node&quot;);
            disclosureNode.setMouseTransparent(true);

            final StackPane disclosureNodeArrow = new StackPane();
            disclosureNodeArrow.getStyleClass().setAll(&quot;arrow&quot;);
            disclosureNode.getChildren().add(disclosureNodeArrow);

            cell.setDisclosureNode(disclosureNode);
        }

        cell.updateTreeTableView(treeTableView);
        return cell;
    }

    private TreeItem&lt;T&gt; getRoot() {
        return weakRootRef == null ? null : weakRootRef.get();
    }
    private void setRoot(TreeItem&lt;T&gt; newRoot) {
        if (getRoot() != null &amp;&amp; weakRootListener != null) {
            getRoot().removeEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }
        weakRootRef = new WeakReference&lt;&gt;(newRoot);
        if (getRoot() != null) {
            weakRootListener = new WeakEventHandler&lt;&gt;(rootListener);
            getRoot().addEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }

        updateItemCount();
    }

    /** {@inheritDoc} */
    @Override protected int getItemCount() {
        return getSkinnable().getExpandedItemCount();
    }

    /** {@inheritDoc} */
    @Override void horizontalScroll() {
        super.horizontalScroll();
        if (getSkinnable().getFixedCellSize() &gt; 0) {
            flow.requestCellLayout();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateItemCount() {
        updatePlaceholderRegionVisibility();

        tableBackingList.resetSize();

        int oldCount = flow.getCellCount();
        int newCount = getItemCount();

        // if this is not called even when the count is the same, we get a
        // memory leak in VirtualFlow.sheet.children. This can probably be
        // optimised in the future when time permits.
        flow.setCellCount(newCount);

        if (newCount != oldCount) {
            // The following line is (perhaps temporarily) disabled to
            // resolve two issues: JDK-8155798 and JDK-8147483.
            // A unit test exists in TreeTableViewTest to ensure that
            // the performance issue covered in JDK-8147483 doesn't regress.
            // requestRebuildCells();
        } else {
            needCellsReconfigured = true;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TreeViewSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.Properties;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.collections.FXCollections;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.event.WeakEventHandler;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.TreeItem.TreeModificationEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import com.sun.javafx.scene.control.behavior.TreeViewBehavior;

/**
 * Default skin implementation for the {@link TreeView} control.
 *
 * @see TreeView
 * @since 9
 */
public class TreeViewSkin&lt;T&gt; extends VirtualContainerBase&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    // RT-34744 : IS_PANNABLE will be false unless
    // javafx.scene.control.skin.TreeViewSkin.pannable
    // is set to true. This is done in order to make TreeView functional
    // on embedded systems with touch screens which do not generate scroll
    // events for touch drag gestures.
    private static final boolean IS_PANNABLE =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.control.skin.TreeViewSkin.pannable&quot;));



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final VirtualFlow&lt;TreeCell&lt;T&gt;&gt; flow;
    private WeakReference&lt;TreeItem&lt;T&gt;&gt; weakRoot;
    private final TreeViewBehavior&lt;T&gt; behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private MapChangeListener&lt;Object, Object&gt; propertiesMapListener = c -&gt; {
        if (! c.wasAdded()) return;
        if (Properties.RECREATE.equals(c.getKey())) {
            requestRebuildCells();
            getSkinnable().getProperties().remove(Properties.RECREATE);
        }
    };

    private EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; rootListener = e -&gt; {
        if (e.wasAdded() &amp;&amp; e.wasRemoved() &amp;&amp; e.getAddedSize() == e.getRemovedSize()) {
            // Fix for RT-14842, where the children of a TreeItem were changing,
            // but because the overall item count was staying the same, there was
            // no event being fired to the skin to be informed that the items
            // had changed. So, here we just watch for the case where the number
            // of items being added is equal to the number of items being removed.
            markItemCountDirty();
            getSkinnable().requestLayout();
        } else if (e.getEventType().equals(TreeItem.valueChangedEvent())) {
            // Fix for RT-14971 and RT-15338.
            requestRebuildCells();
        } else {
            // Fix for RT-20090. We are checking to see if the event coming
            // from the TreeItem root is an event where the count has changed.
            EventType&lt;?&gt; eventType = e.getEventType();
            while (eventType != null) {
                if (eventType.equals(TreeItem.&lt;T&gt;expandedItemCountChangeEvent())) {
                    markItemCountDirty();
                    getSkinnable().requestLayout();
                    break;
                }
                eventType = eventType.getSuperType();
            }
        }

        // fix for RT-37853
        getSkinnable().edit(null);
    };

    private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakRootListener;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TreeViewSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TreeViewSkin(final TreeView control) {
        super(control);

        // install default input map for the TreeView control
        behavior = new TreeViewBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        // init the VirtualFlow
        flow = getVirtualFlow();
        flow.setPannable(IS_PANNABLE);
        flow.setCellFactory(this::createCell);
        flow.setFixedCellSize(control.getFixedCellSize());
        getChildren().add(flow);

        setRoot(getSkinnable().getRoot());

        EventHandler&lt;MouseEvent&gt; ml = event -&gt; {
            // RT-15127: cancel editing on scroll. This is a bit extreme
            // (we are cancelling editing on touching the scrollbars).
            // This can be improved at a later date.
            if (control.getEditingItem() != null) {
                control.edit(null);
            }

            // This ensures that the tree maintains the focus, even when the vbar
            // and hbar controls inside the flow are clicked. Without this, the
            // focus border will not be shown when the user interacts with the
            // scrollbars, and more importantly, keyboard navigation won't be
            // available to the user.
            if (control.isFocusTraversable()) {
                control.requestFocus();
            }
        };
        flow.getVbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
        flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);

        final ObservableMap&lt;Object, Object&gt; properties = control.getProperties();
        properties.remove(Properties.RECREATE);
        properties.addListener(propertiesMapListener);

        // init the behavior 'closures'
        behavior.setOnFocusPreviousRow(() -&gt; { onFocusPreviousCell(); });
        behavior.setOnFocusNextRow(() -&gt; { onFocusNextCell(); });
        behavior.setOnMoveToFirstCell(() -&gt; { onMoveToFirstCell(); });
        behavior.setOnMoveToLastCell(() -&gt; { onMoveToLastCell(); });
        behavior.setOnScrollPageDown(this::onScrollPageDown);
        behavior.setOnScrollPageUp(this::onScrollPageUp);
        behavior.setOnSelectPreviousRow(() -&gt; { onSelectPreviousCell(); });
        behavior.setOnSelectNextRow(() -&gt; { onSelectNextCell(); });

        registerChangeListener(control.rootProperty(), e -&gt; setRoot(getSkinnable().getRoot()));
        registerChangeListener(control.showRootProperty(), e -&gt; {
            // if we turn off showing the root, then we must ensure the root
            // is expanded - otherwise we end up with no visible items in
            // the tree.
            if (! getSkinnable().isShowRoot() &amp;&amp; getRoot() != null) {
                getRoot().setExpanded(true);
            }
<A NAME="22"></A>            // update the item count in the flow and behavior instances
            updateItemCount();
        });
        <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#22',2,'match42-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>registerChangeListener(control.cellFactoryProperty(), e -&gt; flow.recreateCells());
        registerChangeListener(control.fixedCellSizeProperty(), e -&gt; flow.setFixedCellSize(getSkinnable().getFixedCellSize()));

        updateItemCount();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose</B></FONT>();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset) * 0.618033987;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return 400;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y, final double w, final double h) {
        super.layoutChildren(x, y, w, h);
        flow.resizeRelocate(x, y, w, h);
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: {
                FocusModel&lt;?&gt; fm = getSkinnable().getFocusModel();
                int focusedIndex = fm.getFocusedIndex();
                if (focusedIndex == -1) {
                    if (getItemCount() &gt; 0) {
                        focusedIndex = 0;
                    } else {
                        return null;
                    }
                }
                return flow.getPrivateCell(focusedIndex);
            }
            case ROW_AT_INDEX: {
                final int rowIndex = (Integer)parameters[0];
                return rowIndex &lt; 0 ? null : flow.getPrivateCell(rowIndex);
            }
            case SELECTED_ITEMS: {
                MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
                ObservableList&lt;Integer&gt; indices = sm.getSelectedIndices();
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;(indices.size());
                for (int i : indices) {
                    TreeCell&lt;T&gt; row = flow.getPrivateCell(i);
                    if (row != null) selection.add(row);
                }
                return FXCollections.observableArrayList(selection);
            }
            case VERTICAL_SCROLLBAR: return flow.getVbar();
            case HORIZONTAL_SCROLLBAR: return flow.getHbar();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SHOW_ITEM: {
                Node item = (Node)parameters[0];
                if (item instanceof TreeCell) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    TreeCell&lt;T&gt; cell = (TreeCell&lt;T&gt;)item;
                    flow.scrollTo(cell.getIndex());
                }
                break;
            }
            case SET_SELECTED_ITEMS: {
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;Node&gt; items = (ObservableList&lt;Node&gt;)parameters[0];
                if (items != null) {
                    MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
                    if (sm != null) {
                        sm.clearSelection();
                        for (Node item : items) {
                            if (item instanceof TreeCell) {
                                @SuppressWarnings(&quot;unchecked&quot;)
                                TreeCell&lt;T&gt; cell = (TreeCell&lt;T&gt;)item;
                                sm.select(cell.getIndex());
                            }
                        }
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private TreeCell&lt;T&gt; createCell(VirtualFlow&lt;TreeCell&lt;T&gt;&gt; flow) {
        final TreeCell&lt;T&gt; cell;
        if (getSkinnable().getCellFactory() != null) {
            cell = getSkinnable().getCellFactory().call(getSkinnable());
        } else {
            cell = createDefaultCellImpl();
        }

        // If there is no disclosure node, then add one of my own
        if (cell.getDisclosureNode() == null) {
            final StackPane disclosureNode = new StackPane();

            /* This code is intentionally commented.
             * Currently as it stands it does provided any functionality and interferes
             * with TreeView. The VO cursor move over the DISCLOSURE_NODE instead of the
             * tree item itself. This is possibly caused by the order of item's children
             * (the Labeled and the disclosure node).
             */
//            final StackPane disclosureNode = new StackPane() {
//                @Override protected Object accGetAttribute(Attribute attribute, Object... parameters) {
//                    switch (attribute) {
//                        case ROLE: return Role.DISCLOSURE_NODE;
//                        default: return super.accGetAttribute(attribute, parameters);
//                    }
//                }
//            };
            disclosureNode.getStyleClass().setAll(&quot;tree-disclosure-node&quot;);

            final StackPane disclosureNodeArrow = new StackPane();
            disclosureNodeArrow.getStyleClass().setAll(&quot;arrow&quot;);
            disclosureNode.getChildren().add(disclosureNodeArrow);

            cell.setDisclosureNode(disclosureNode);
        }

        cell.updateTreeView(getSkinnable());

        return cell;
    }

    private TreeItem&lt;T&gt; getRoot() {
        return weakRoot == null ? null : weakRoot.get();
    }
    private void setRoot(TreeItem&lt;T&gt; newRoot) {
        if (getRoot() != null &amp;&amp; weakRootListener != null) {
            getRoot().removeEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }
        weakRoot = new WeakReference&lt;&gt;(newRoot);
        if (getRoot() != null) {
            weakRootListener = new WeakEventHandler&lt;&gt;(rootListener);
            getRoot().addEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }

        updateItemCount();
    }

    /** {@inheritDoc} */
    @Override protected int getItemCount() {
        return getSkinnable().getExpandedItemCount();
    }

    /** {@inheritDoc} */
    @Override protected void updateItemCount() {
//        int oldCount = flow.getCellCount();
        int newCount = getItemCount();

        // if this is not called even when the count is the same, we get a
        // memory leak in VirtualFlow.sheet.children. This can probably be
        // optimised in the future when time permits.
        requestRebuildCells();
        flow.setCellCount(newCount);

        // Ideally we would be more nuanced above, toggling a cheaper needs*
        // field, but if we do we hit issues such as those identified in
        // RT-27852, where the expended item count of the new root equals the
        // EIC of the old root, which would lead to the visuals not updating
        // properly.
        getSkinnable().requestLayout();
    }

    // Note: This is a copy/paste of javafx.scene.control.cell.DefaultTreeCell,
    // which is package-protected
    private TreeCell&lt;T&gt; createDefaultCellImpl() {
        return new TreeCell&lt;T&gt;() {
            private HBox hbox;

            private WeakReference&lt;TreeItem&lt;T&gt;&gt; treeItemRef;

            private InvalidationListener treeItemGraphicListener = observable -&gt; {
                updateDisplay(getItem(), isEmpty());
            };

            private InvalidationListener treeItemListener = new InvalidationListener() {
                @Override public void invalidated(Observable observable) {
                    TreeItem&lt;T&gt; oldTreeItem = treeItemRef == null ? null : treeItemRef.get();
                    if (oldTreeItem != null) {
                        oldTreeItem.graphicProperty().removeListener(weakTreeItemGraphicListener);
                    }

                    TreeItem&lt;T&gt; newTreeItem = getTreeItem();
                    if (newTreeItem != null) {
                        newTreeItem.graphicProperty().addListener(weakTreeItemGraphicListener);
                        treeItemRef = new WeakReference&lt;TreeItem&lt;T&gt;&gt;(newTreeItem);
                    }
                }
            };

            private WeakInvalidationListener weakTreeItemGraphicListener =
                    new WeakInvalidationListener(treeItemGraphicListener);

            private WeakInvalidationListener weakTreeItemListener =
                    new WeakInvalidationListener(treeItemListener);

            {
                treeItemProperty().addListener(weakTreeItemListener);

                if (getTreeItem() != null) {
                    getTreeItem().graphicProperty().addListener(weakTreeItemGraphicListener);
                }
            }

            private void updateDisplay(T item, boolean empty) {
                if (item == null || empty) {
                    hbox = null;
                    setText(null);
                    setGraphic(null);
                } else {
                    // update the graphic if one is set in the TreeItem
                    TreeItem&lt;T&gt; treeItem = getTreeItem();
                    Node graphic = treeItem == null ? null : treeItem.getGraphic();
                    if (graphic != null) {
                        if (item instanceof Node) {
                            setText(null);

                            // the item is a Node, and the graphic exists, so
                            // we must insert both into an HBox and present that
                            // to the user (see RT-15910)
                            if (hbox == null) {
                                hbox = new HBox(3);
                            }
                            hbox.getChildren().setAll(graphic, (Node)item);
                            setGraphic(hbox);
                        } else {
                            hbox = null;
                            setText(item.toString());
                            setGraphic(graphic);
                        }
                    } else {
                        hbox = null;
                        if (item instanceof Node) {
                            setText(null);
                            setGraphic((Node)item);
                        } else {
                            setText(item.toString());
                            setGraphic(null);
                        }
                    }
                }
            }

            @Override public void updateItem(T item, boolean empty) {
                super.updateItem(item, empty);
                updateDisplay(item, empty);
            }
        };
    }

    private void onFocusPreviousCell() {
        FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (fm == null) return;
        flow.scrollTo(fm.getFocusedIndex());
    }

    private void onFocusNextCell() {
        FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (fm == null) return;
        flow.scrollTo(fm.getFocusedIndex());
    }

    private void onSelectPreviousCell() {
        int row = getSkinnable().getSelectionModel().getSelectedIndex();
        flow.scrollTo(row);
    }

    private void onSelectNextCell() {
        int row = getSkinnable().getSelectionModel().getSelectedIndex();
        flow.scrollTo(row);
    }

    private void onMoveToFirstCell() {
        flow.scrollTo(0);
        flow.setPosition(0);
    }

    private void onMoveToLastCell() {
        flow.scrollTo(getItemCount());
        flow.setPosition(1);
    }

    /**
     * Function used to scroll the container down by one 'page'.
     */
    private int onScrollPageDown(boolean isFocusDriven) {
        TreeCell&lt;T&gt; lastVisibleCell = flow.getLastVisibleCellWithinViewPort();
        if (lastVisibleCell == null) return -1;

        final SelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
        final FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (sm == null || fm == null) return -1;

        int lastVisibleCellIndex = lastVisibleCell.getIndex();

        // isSelected represents focus OR selection
        boolean isSelected = false;
        if (isFocusDriven) {
            isSelected = lastVisibleCell.isFocused() || fm.isFocused(lastVisibleCellIndex);
        } else {
            isSelected = lastVisibleCell.isSelected() || sm.isSelected(lastVisibleCellIndex);
        }

        if (isSelected) {
            boolean isLeadIndex = (isFocusDriven &amp;&amp; fm.getFocusedIndex() == lastVisibleCellIndex)
                    || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == lastVisibleCellIndex);

            if (isLeadIndex) {
                // if the last visible cell is selected, we want to shift that cell up
                // to be the top-most cell, or at least as far to the top as we can go.
                flow.scrollToTop(lastVisibleCell);

                TreeCell&lt;T&gt; newLastVisibleCell = flow.getLastVisibleCellWithinViewPort();
                lastVisibleCell = newLastVisibleCell == null ? lastVisibleCell : newLastVisibleCell;
            }
        } else {
            // if the selection is not on the 'bottom' most cell, we firstly move
            // the selection down to that, without scrolling the contents, so
            // this is a no-op
        }

        int newSelectionIndex = lastVisibleCell.getIndex();
        flow.scrollTo(lastVisibleCell);
        return newSelectionIndex;
    }

    /**
     * Function used to scroll the container up by one 'page'.
     */
    private int onScrollPageUp(boolean isFocusDriven) {
        TreeCell&lt;T&gt; firstVisibleCell = flow.getFirstVisibleCellWithinViewPort();
        if (firstVisibleCell == null) return -1;

        final SelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
        final FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (sm == null || fm == null) return -1;

        int firstVisibleCellIndex = firstVisibleCell.getIndex();

        // isSelected represents focus OR selection
        boolean isSelected = false;
        if (isFocusDriven) {
            isSelected = firstVisibleCell.isFocused() || fm.isFocused(firstVisibleCellIndex);
        } else {
            isSelected = firstVisibleCell.isSelected() || sm.isSelected(firstVisibleCellIndex);
        }

        if (isSelected) {
            boolean isLeadIndex = (isFocusDriven &amp;&amp; fm.getFocusedIndex() == firstVisibleCellIndex)
                    || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == firstVisibleCellIndex);

            if (isLeadIndex) {
                // if the first visible cell is selected, we want to shift that cell down
                // to be the bottom-most cell, or at least as far to the bottom as we can go.
                flow.scrollToBottom(firstVisibleCell);

                TreeCell&lt;T&gt; newFirstVisibleCell = flow.getFirstVisibleCellWithinViewPort();
                firstVisibleCell = newFirstVisibleCell == null ? firstVisibleCell : newFirstVisibleCell;
            }
        } else {
            // if the selection is not on the 'top' most cell, we firstly move
            // the selection up to that, without scrolling the contents, so
            // this is a no-op
        }

        int newSelectionIndex = firstVisibleCell.getIndex();
        flow.scrollTo(firstVisibleCell);
        return newSelectionIndex;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/VirtualFlow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.Logging;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.VirtualScrollBar;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.collections.ObservableList;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleRole;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Cell;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.ScrollBar;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Callback;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;

/**
 * Implementation of a virtualized container using a cell based mechanism. This
 * is used by the skin implementations for UI controls such as
 * {@link javafx.scene.control.ListView}, {@link javafx.scene.control.TreeView},
 * {@link javafx.scene.control.TableView}, and {@link javafx.scene.control.TreeTableView}.
 *
 * @since 9
 */
public class VirtualFlow&lt;T extends IndexedCell&gt; extends Region {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Scroll events may request to scroll about a number of &quot;lines&quot;. We first
     * decide how big one &quot;line&quot; is - for fixed cell size it's clear,
     * for variable cell size we settle on a single number so that the scrolling
     * speed is consistent. Now if the line is so big that
     * MIN_SCROLLING_LINES_PER_PAGE of them don't fit into one page, we make
     * them smaller to prevent the scrolling step to be too big (perhaps
     * even more than one page).
     */
    private static final int MIN_SCROLLING_LINES_PER_PAGE = 8;

    /**
     * Indicates that this is a newly created cell and we need call processCSS for it.
     *
     * See RT-23616 for more details.
     */
    private static final String NEW_CELL = &quot;newcell&quot;;

    private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private boolean touchDetected = false;
    private boolean mouseDown = false;

    /**
     * The width of the VirtualFlow the last time it was laid out. We
     * use this information for several fast paths during the layout pass.
     */
    double lastWidth = -1;

    /**
     * The height of the VirtualFlow the last time it was laid out. We
     * use this information for several fast paths during the layout pass.
     */
    double lastHeight = -1;

    /**
     * The number of &quot;virtual&quot; cells in the flow the last time it was laid out.
     * For example, there may have been 1000 virtual cells, but only 20 actual
     * cells created and in use. In that case, lastCellCount would be 1000.
     */
    int lastCellCount = 0;

    /**
     * We remember the last value for vertical the last time we laid out the
     * flow. If vertical has changed, we will want to change the max &amp; value
     * for the different scroll bars. Since we do all the scroll bar update
     * work in the layoutChildren function, we need to know what the old value for
     * vertical was.
     */
    boolean lastVertical;

    /**
     * The position last time we laid out. If none of the lastXXX vars have
     * changed respective to their values in layoutChildren, then we can just punt
     * out of the method (I hope...)
     */
    double lastPosition;

    /**
     * The breadth of the first visible cell last time we laid out.
     */
    double lastCellBreadth = -1;

    /**
     * The length of the first visible cell last time we laid out.
     */
    double lastCellLength = -1;

    /**
     * The list of cells representing those cells which actually make up the
     * current view. The cells are ordered such that the first cell in this
     * list is the first in the view, and the last cell is the last in the
     * view. When pixel scrolling, the list is simply shifted and items drop
     * off the beginning or the end, depending on the order of scrolling.
     * &lt;p&gt;
     * This is package private ONLY FOR TESTING
     */
    final ArrayLinkedList&lt;T&gt; cells = new ArrayLinkedList&lt;T&gt;();

    /**
     * A structure containing cells that can be reused later. These are cells
     * that at one time were needed to populate the view, but now are no longer
     * needed. We keep them here until they are needed again.
     * &lt;p&gt;
     * This is package private ONLY FOR TESTING
     */
    final ArrayLinkedList&lt;T&gt; pile = new ArrayLinkedList&lt;T&gt;();

    /**
     * A special cell used to accumulate bounds, such that we reduce object
     * churn. This cell must be recreated whenever the cell factory function
     * changes. This has package access ONLY for testing.
     */
    T accumCell;

    /**
     * This group is used for holding the 'accumCell'. 'accumCell' must
     * be added to the skin for it to be styled. Otherwise, it doesn't
     * report the correct width/height leading to issues when scrolling
     * the flow
     */
    Group accumCellParent;

    /**
     * The group which holds the cells.
     */
    final Group sheet;

    final ObservableList&lt;Node&gt; sheetChildren;

    /**
     * The scroll bar used for scrolling horizontally. This has package access
     * ONLY for testing.
     */
    private VirtualScrollBar hbar = new VirtualScrollBar(this);

    /**
     * The scroll bar used to scrolling vertically. This has package access
     * ONLY for testing.
     */
    private VirtualScrollBar vbar = new VirtualScrollBar(this);

    /**
     * Control in which the cell's sheet is placed and forms the viewport. The
     * viewportBreadth and viewportLength are simply the dimensions of the
     * clipView. This has package access ONLY for testing.
     */
    ClippedContainer clipView;

    /**
     * When both the horizontal and vertical scroll bars are visible,
     * we have to 'fill in' the bottom right corner where the two scroll bars
     * meet. This is handled by this corner region. This has package access
     * ONLY for testing.
     */
    StackPane corner;

    // used for panning the virtual flow
    private double lastX;
    private double lastY;
    private boolean isPanning = false;

    private boolean fixedCellSizeEnabled = false;

    private boolean needsReconfigureCells = false; // when cell contents are the same
    private boolean needsRecreateCells = false; // when cell factory changed
    private boolean needsRebuildCells = false; // when cell contents have changed
    private boolean needsCellsLayout = false;
    private boolean sizeChanged = false;
    private final BitSet dirtyCells = new BitSet();

    Timeline sbTouchTimeline;
    KeyFrame sbTouchKF1;
    KeyFrame sbTouchKF2;

    private boolean needBreadthBar;
    private boolean needLengthBar;
    private boolean tempVisibility = false;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new VirtualFlow instance.
     */
    public VirtualFlow() {
        getStyleClass().add(&quot;virtual-flow&quot;);
        setId(&quot;virtual-flow&quot;);

        // initContent
        // --- sheet
        sheet = new Group();
        sheet.getStyleClass().add(&quot;sheet&quot;);
        sheet.setAutoSizeChildren(false);

        sheetChildren = sheet.getChildren();

        // --- clipView
        clipView = new ClippedContainer(this);
        clipView.setNode(sheet);
        getChildren().add(clipView);

        // --- accumCellParent
        accumCellParent = new Group();
        accumCellParent.setVisible(false);
        getChildren().add(accumCellParent);


        /*
        ** don't allow the ScrollBar to handle the ScrollEvent,
        ** In a VirtualFlow a vertical scroll should scroll on the vertical only,
        ** whereas in a horizontal ScrollBar it can scroll horizontally.
        */
        // block the event from being passed down to children
        final EventDispatcher blockEventDispatcher = (event, tail) -&gt; event;
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldHsbEventDispatcher = hbar.getEventDispatcher();
        hbar.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldHsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldHsbEventDispatcher.dispatchEvent(event, tail);
        });
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldVsbEventDispatcher = vbar.getEventDispatcher();
        vbar.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldVsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldVsbEventDispatcher.dispatchEvent(event, tail);
        });
        /*
        ** listen for ScrollEvents over the whole of the VirtualFlow
        ** area, the above dispatcher having removed the ScrollBars
        ** scroll event handling.
        */
        setOnScroll(new EventHandler&lt;ScrollEvent&gt;() {
            @Override public void handle(ScrollEvent event) {
                if (Properties.IS_TOUCH_SUPPORTED) {
                    if (touchDetected == false &amp;&amp;  mouseDown == false ) {
                        startSBReleasedAnimation();
                    }
                }
                /*
                ** calculate the delta in the direction of the flow.
                */
                double virtualDelta = 0.0;
                if (isVertical()) {
                    switch(event.getTextDeltaYUnits()) {
                        case PAGES:
                            virtualDelta = event.getTextDeltaY() * lastHeight;
                            break;
                        case LINES:
                            double lineSize;
                            if (fixedCellSizeEnabled) {
                                lineSize = getFixedCellSize();
                            } else {
                                // For the scrolling to be reasonably consistent
                                // we set the lineSize to the average size
                                // of all currently loaded lines.
                                T lastCell = cells.getLast();
                                lineSize =
                                        (getCellPosition(lastCell)
                                            + getCellLength(lastCell)
                                            - getCellPosition(cells.getFirst()))
                                        / cells.size();
                            }

                            if (lastHeight / lineSize &lt; MIN_SCROLLING_LINES_PER_PAGE) {
                                lineSize = lastHeight / MIN_SCROLLING_LINES_PER_PAGE;
                            }

                            virtualDelta = event.getTextDeltaY() * lineSize;
                            break;
                        case NONE:
                            virtualDelta = event.getDeltaY();
                    }
                } else { // horizontal
                    switch(event.getTextDeltaXUnits()) {
                        case CHARACTERS:
                            // can we get character size here?
                            // for now, fall through to pixel values
                        case NONE:
                            double dx = event.getDeltaX();
                            double dy = event.getDeltaY();

                            virtualDelta = (Math.abs(dx) &gt; Math.abs(dy) ? dx : dy);
                    }
                }

                if (virtualDelta != 0.0) {
                    /*
                    ** only consume it if we use it
                    */
                    double result = scrollPixels(-virtualDelta);
                    if (result != 0.0) {
                        event.consume();
                    }
                }

                ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;
                if (needBreadthBar) {
                    double nonVirtualDelta = isVertical() ? event.getDeltaX() : event.getDeltaY();
                    if (nonVirtualDelta != 0.0) {
                        double newValue = nonVirtualBar.getValue() - nonVirtualDelta;
                        if (newValue &lt; nonVirtualBar.getMin()) {
                            nonVirtualBar.setValue(nonVirtualBar.getMin());
                        } else if (newValue &gt; nonVirtualBar.getMax()) {
                            nonVirtualBar.setValue(nonVirtualBar.getMax());
                        } else {
                            nonVirtualBar.setValue(newValue);
                        }
                        event.consume();
                    }
                }
            }
        });


        addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler&lt;MouseEvent&gt;() {
            @Override
            public void handle(MouseEvent e) {
                mouseDown = true;
                if (Properties.IS_TOUCH_SUPPORTED) {
                    scrollBarOn();
                }
                if (isFocusTraversable()) {
                    // We check here to see if the current focus owner is within
                    // this VirtualFlow, and if so we back-off from requesting
                    // focus back to the VirtualFlow itself. This is particularly
                    // relevant given the bug identified in RT-32869. In this
                    // particular case TextInputControl was clearing selection
                    // when the focus on the TextField changed, meaning that the
                    // right-click context menu was not showing the correct
                    // options as there was no selection in the TextField.
                    boolean doFocusRequest = true;
                    Node focusOwner = getScene().getFocusOwner();
                    if (focusOwner != null) {
                        Parent parent = focusOwner.getParent();
                        while (parent != null) {
                            if (parent.equals(VirtualFlow.this)) {
                                doFocusRequest = false;
                                break;
                            }
                            parent = parent.getParent();
                        }
                    }

                    if (doFocusRequest) {
                        requestFocus();
                    }
                }

                lastX = e.getX();
                lastY = e.getY();

                // determine whether the user has push down on the virtual flow,
                // or whether it is the scrollbar. This is done to prevent
                // mouse events being 'doubled up' when dragging the scrollbar
                // thumb - it has the side-effect of also starting the panning
                // code, leading to flicker
                isPanning = ! (vbar.getBoundsInParent().contains(e.getX(), e.getY())
                        || hbar.getBoundsInParent().contains(e.getX(), e.getY()));
            }
        });
        addEventFilter(MouseEvent.MOUSE_RELEASED, e -&gt; {
            mouseDown = false;
            if (Properties.IS_TOUCH_SUPPORTED) {
                startSBReleasedAnimation();
            }
        });
        addEventFilter(MouseEvent.MOUSE_DRAGGED, e -&gt; {
            if (Properties.IS_TOUCH_SUPPORTED) {
                scrollBarOn();
            }
            if (! isPanning || ! isPannable()) return;

            // With panning enabled, we support panning in both vertical
            // and horizontal directions, regardless of the fact that
            // VirtualFlow is virtual in only one direction.
            double xDelta = lastX - e.getX();
            double yDelta = lastY - e.getY();

            // figure out the distance that the mouse moved in the virtual
            // direction, and then perform the movement along that axis
            // virtualDelta will contain the amount we actually did move
            double virtualDelta = isVertical() ? yDelta : xDelta;
            double actual = scrollPixels(virtualDelta);
            if (actual != 0) {
                // update last* here, as we know we've just adjusted the
                // scrollbar. This means we don't get the situation where a
                // user presses-and-drags a long way past the min or max
                // values, only to change directions and see the scrollbar
                // start moving immediately.
                if (isVertical()) lastY = e.getY();
                else lastX = e.getX();
            }

            // similarly, we do the same in the non-virtual direction
            double nonVirtualDelta = isVertical() ? xDelta : yDelta;
            ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;
            if (nonVirtualBar.isVisible()) {
                double newValue = nonVirtualBar.getValue() + nonVirtualDelta;
                if (newValue &lt; nonVirtualBar.getMin()) {
                    nonVirtualBar.setValue(nonVirtualBar.getMin());
                } else if (newValue &gt; nonVirtualBar.getMax()) {
                    nonVirtualBar.setValue(nonVirtualBar.getMax());
                } else {
                    nonVirtualBar.setValue(newValue);

                    // same as the last* comment above
                    if (isVertical()) lastX = e.getX();
                    else lastY = e.getY();
                }
            }
        });

        /*
         * We place the scrollbars _above_ the rectangle, such that the drag
         * operations often used in conjunction with scrollbars aren't
         * misinterpreted as drag operations on the rectangle as well (which
         * would be the case if the scrollbars were underneath it as the
         * rectangle itself doesn't block the mouse.
         */
        // --- vbar
        vbar.setOrientation(Orientation.VERTICAL);
        vbar.addEventHandler(MouseEvent.ANY, event -&gt; {
            event.consume();
        });
        getChildren().add(vbar);

        // --- hbar
        hbar.setOrientation(Orientation.HORIZONTAL);
        hbar.addEventHandler(MouseEvent.ANY, event -&gt; {
            event.consume();
        });
        getChildren().add(hbar);

        // --- corner
        corner = new StackPane();
        corner.getStyleClass().setAll(&quot;corner&quot;);
        getChildren().add(corner);



        // initBinds
        // clipView binds
        InvalidationListener listenerX = valueModel -&gt; {
            updateHbar();
        };
        verticalProperty().addListener(listenerX);
        hbar.valueProperty().addListener(listenerX);
        hbar.visibleProperty().addListener(listenerX);

//        ChangeListener listenerY = new ChangeListener() {
//            @Override public void handle(Bean bean, PropertyReference property) {
//                clipView.setClipY(isVertical() ? 0 : vbar.getValue());
//            }
//        };
//        addChangedListener(VERTICAL, listenerY);
//        vbar.addChangedListener(ScrollBar.VALUE, listenerY);

        ChangeListener&lt;Number&gt; listenerY = (ov, t, t1) -&gt; {
            clipView.setClipY(isVertical() ? 0 : vbar.getValue());
        };
        vbar.valueProperty().addListener(listenerY);

        super.heightProperty().addListener((observable, oldHeight, newHeight) -&gt; {
            // Fix for RT-8480, where the VirtualFlow does not show its content
            // after changing size to 0 and back.
            if (oldHeight.doubleValue() == 0 &amp;&amp; newHeight.doubleValue() &gt; 0) {
                recreateCells();
            }
        });


        /*
        ** there are certain animations that need to know if the touch is
        ** happening.....
        */
        setOnTouchPressed(e -&gt; {
            touchDetected = true;
            scrollBarOn();
        });

        setOnTouchReleased(e -&gt; {
            touchDetected = false;
            startSBReleasedAnimation();
        });

        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {

            Node selectNextAfterIndex(int index, TraversalContext context) {
                T nextCell;
                while ((nextCell = getVisibleCell(++index)) != null) {
                    if (nextCell.isFocusTraversable()) {
                        return nextCell;
                    }
                    Node n = context.selectFirstInParent(nextCell);
                    if (n != null) {
                        return n;
                    }
                }
                return null;
            }

            Node selectPreviousBeforeIndex(int index, TraversalContext context) {
                T prevCell;
                while ((prevCell = getVisibleCell(--index)) != null) {
                    Node prev = context.selectLastInParent(prevCell);
                    if (prev != null) {
                        return prev;
                    }
                    if (prevCell.isFocusTraversable()) {
                        return prevCell;
                    }
                }
                return null;
            }

            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                T cell;
                if (cells.isEmpty()) return null;
                if (cells.contains(owner)) {
                    cell = (T) owner;
                } else {
                    cell = findOwnerCell(owner);
                    Node next = context.selectInSubtree(cell, owner, dir);
                    if (next != null) {
                        return next;
                    }
                    if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
                }
                int cellIndex = cell.getIndex();
                switch(dir) {
                    case PREVIOUS:
                        return selectPreviousBeforeIndex(cellIndex, context);
                    case NEXT:
                        Node n = context.selectFirstInParent(cell);
                        if (n != null) {
                            return n;
                        }
                        // Intentional fall-through
                    case NEXT_IN_LINE:
                        return selectNextAfterIndex(cellIndex, context);
                }
                return null;
            }

            private T findOwnerCell(Node owner) {
                Parent p = owner.getParent();
                while (!cells.contains(p)) {
                    p = p.getParent();
                }
                return (T)p;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                T firstCell = cells.getFirst();
                if (firstCell == null) return null;
                if (firstCell.isFocusTraversable()) return firstCell;
                Node n = context.selectFirstInParent(firstCell);
                if (n != null) {
                    return n;
                }
                return selectNextAfterIndex(firstCell.getIndex(), context);
            }

            @Override
            public Node selectLast(TraversalContext context) {
                T lastCell = cells.getLast();
                if (lastCell == null) return null;
                Node p = context.selectLastInParent(lastCell);
                if (p != null) {
                    return p;
                }
                if (lastCell.isFocusTraversable()) return lastCell;
                return selectPreviousBeforeIndex(lastCell.getIndex(), context);
            }
        }));
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * There are two main complicating factors in the implementation of the
     * VirtualFlow, which are made even more complicated due to the performance
     * sensitive nature of this code. The first factor is the actual
     * virtualization mechanism, wired together with the PositionMapper.
     * The second complicating factor is the desire to do minimal layout
     * and minimal updates to CSS.
     *
     * Since the layout mechanism runs at most once per pulse, we want to hook
     * into this mechanism for minimal recomputation. Whenever a layout pass
     * is run we record the width/height that the virtual flow was last laid
     * out to. In subsequent passes, if the width/height has not changed then
     * we know we only have to rebuild the cells. If the width or height has
     * changed, then we can make appropriate decisions based on whether the
     * width / height has been reduced or expanded.
     *
     * In various places, if requestLayout is called it is generally just
     * used to indicate that some form of layout needs to happen (either the
     * entire thing has to be reconstructed, or just the cells need to be
     * reconstructed, generally).
     *
     * The accumCell is a special cell which is used in some computations
     * when an actual cell for that item isn't currently available. However,
     * the accumCell must be cleared whenever the cellFactory function is
     * changed because we need to use the cells that come from the new factory.
     *
     * In addition to storing the lastWidth and lastHeight, we also store the
     * number of cells that existed last time we performed a layout. In this
     * way if the number of cells change, we can request a layout and when it
     * occurs we can tell that the number of cells has changed and react
     * accordingly.
     *
     * Because the VirtualFlow can be laid out horizontally or vertically a
     * naming problem is present when trying to conceptualize and implement
     * the flow. In particular, the words &quot;width&quot; and &quot;height&quot; are not
     * precise when describing the unit of measure along the &quot;virtualized&quot;
     * axis and the &quot;orthogonal&quot; axis. For example, the height of a cell when
     * the flow is vertical is the magnitude along the &quot;virtualized axis&quot;,
     * and the width is along the axis orthogonal to it.
     *
     * Since &quot;height&quot; and &quot;width&quot; are not reliable terms, we use the words
     * &quot;length&quot; and &quot;breadth&quot; to describe the magnitude of a cell along
     * the virtualized axis and orthogonal axis. For example, in a vertical
     * flow, the height=length and the width=breadth. In a horizontal axis,
     * the height=breadth and the width=length.
     *
     * These terms are somewhat arbitrary, but chosen so that when reading
     * most of the below code you can think in just one dimension, with
     * helper functions converting width/height in to length/breadth, while
     * also being different from width/height so as not to get confused with
     * the actual width/height of a cell.
     */

    // --- vertical
    /**
     * Indicates the primary direction of virtualization. If true, then the
     * primary direction of virtualization is vertical, meaning that cells will
     * stack vertically on top of each other. If false, then they will stack
     * horizontally next to each other.
     */
    private BooleanProperty vertical;
    public final void setVertical(boolean value) {
        verticalProperty().set(value);
    }

    public final boolean isVertical() {
        return vertical == null ? true : vertical.get();
    }

    public final BooleanProperty verticalProperty() {
        if (vertical == null) {
            vertical = new BooleanPropertyBase(true) {
                @Override protected void invalidated() {
                    pile.clear();
                    sheetChildren.clear();
                    cells.clear();
                    lastWidth = lastHeight = -1;
                    setMaxPrefBreadth(-1);
                    setViewportBreadth(0);
                    setViewportLength(0);
                    lastPosition = 0;
                    hbar.setValue(0);
                    vbar.setValue(0);
                    setPosition(0.0f);
                    setNeedsLayout(true);
                    requestLayout();
                }

                @Override
                public Object getBean() {
                    return VirtualFlow.this;
                }

                @Override
                public String getName() {
                    return &quot;vertical&quot;;
                }
            };
        }
        return vertical;
    }

    // --- pannable
    /**
     * Indicates whether the VirtualFlow viewport is capable of being panned
     * by the user (either via the mouse or touch events).
     */
    private BooleanProperty pannable = new SimpleBooleanProperty(this, &quot;pannable&quot;, true);
    public final boolean isPannable() { return pannable.get(); }
    public final void setPannable(boolean value) { pannable.set(value); }
    public final BooleanProperty pannableProperty() { return pannable; }

    // --- cell count
    /**
     * Indicates the number of cells that should be in the flow. The user of
     * the VirtualFlow must set this appropriately. When the cell count changes
     * the VirtualFlow responds by updating the visuals. If the items backing
     * the cells change, but the count has not changed, you must call the
     * reconfigureCells() function to update the visuals.
     */
    private IntegerProperty cellCount = new SimpleIntegerProperty(this, &quot;cellCount&quot;, 0) {
        private int oldCount = 0;

        @Override protected void invalidated() {
            int cellCount = get();

            boolean countChanged = oldCount != cellCount;
            oldCount = cellCount;

            // ensure that the virtual scrollbar adjusts in size based on the current
            // cell count.
            if (countChanged) {
                VirtualScrollBar lengthBar = isVertical() ? vbar : hbar;
                lengthBar.setMax(cellCount);
            }

            // I decided *not* to reset maxPrefBreadth here for the following
            // situation. Suppose I have 30 cells and then I add 10 more. Just
            // because I added 10 more doesn't mean the max pref should be
            // reset. Suppose the first 3 cells were extra long, and I was
            // scrolled down such that they weren't visible. If I were to reset
            // maxPrefBreadth when subsequent cells were added or removed, then the
            // scroll bars would erroneously reset as well. So I do not reset
            // the maxPrefBreadth here.

            // Fix for RT-12512, RT-14301 and RT-14864.
            // Without this, the VirtualFlow length-wise scrollbar would not change
            // as expected. This would leave items unable to be shown, as they
            // would exist outside of the visible area, even when the scrollbar
            // was at its maximum position.
            // FIXME this should be only executed on the pulse, so this will likely
            // lead to performance degradation until it is handled properly.
            if (countChanged) {
                layoutChildren();

                // Fix for RT-13965: Without this line of code, the number of items in
                // the sheet would constantly grow, leaking memory for the life of the
                // application. This was especially apparent when the total number of
                // cells changes - regardless of whether it became bigger or smaller.
                sheetChildren.clear();

                Parent parent = getParent();
                if (parent != null) parent.requestLayout();
            }
            // TODO suppose I had 100 cells and I added 100 more. Further
            // suppose I was scrolled to the bottom when that happened. I
            // actually want to update the position of the mapper such that
            // the view remains &quot;stable&quot;.
        }
    };
    public final int getCellCount() { return cellCount.get(); }
    public final void setCellCount(int value) { cellCount.set(value);  }
    public final IntegerProperty cellCountProperty() { return cellCount; }


    // --- position
    /**
     * The position of the VirtualFlow within its list of cells. This is a value
     * between 0 and 1.
     */
    private DoubleProperty position = new SimpleDoubleProperty(this, &quot;position&quot;) {
        @Override public void setValue(Number v) {
            super.setValue(com.sun.javafx.util.Utils.clamp(0, get(), 1));
        }

        @Override protected void invalidated() {
            super.invalidated();
            requestLayout();
        }
    };
    public final double getPosition() { return position.get(); }
    public final void setPosition(double value) { position.set(value); }
    public final DoubleProperty positionProperty() { return position; }

    // --- fixed cell size
    /**
     * For optimisation purposes, some use cases can trade dynamic cell length
     * for speed - if fixedCellSize is greater than zero we'll use that rather
     * than determine it by querying the cell itself.
     */
    private DoubleProperty fixedCellSize = new SimpleDoubleProperty(this, &quot;fixedCellSize&quot;) {
        @Override protected void invalidated() {
            fixedCellSizeEnabled = get() &gt; 0;
            needsCellsLayout = true;
            layoutChildren();
        }
    };
    public final void setFixedCellSize(final double value) { fixedCellSize.set(value); }
    public final double getFixedCellSize() { return fixedCellSize.get(); }
    public final DoubleProperty fixedCellSizeProperty() { return fixedCellSize; }


    // --- Cell Factory
    private ObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt; cellFactory;

    /**
     * Sets a new cell factory to use in the VirtualFlow. This forces all old
     * cells to be thrown away, and new cells to be created with
     * the new cell factory.
     * @param value the new cell factory
     */
    public final void setCellFactory(Callback&lt;VirtualFlow&lt;T&gt;, T&gt; value) {
        cellFactoryProperty().set(value);
    }

    /**
     * Returns the current cell factory.
     * @return the current cell factory
     */
    public final Callback&lt;VirtualFlow&lt;T&gt;, T&gt; getCellFactory() {
        return cellFactory == null ? null : cellFactory.get();
    }

    /**
     * &lt;p&gt;Setting a custom cell factory has the effect of deferring all cell
     * creation, allowing for total customization of the cell. Internally, the
     * VirtualFlow is responsible for reusing cells - all that is necessary
     * is for the custom cell factory to return from this function a cell
     * which might be usable for representing any item in the VirtualFlow.
     *
     * &lt;p&gt;Refer to the {@link Cell} class documentation for more detail.
     * @return  the cell factory property
     */
    public final ObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt; cellFactoryProperty() {
        if (cellFactory == null) {
            cellFactory = new SimpleObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt;(this, &quot;cellFactory&quot;) {
                @Override protected void invalidated() {
                    if (get() != null) {
                        accumCell = null;
                        setNeedsLayout(true);
                        recreateCells();
                        if (getParent() != null) getParent().requestLayout();
                    }
                }
            };
        }
        return cellFactory;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Overridden to implement somewhat more efficient support for layout. The
     * VirtualFlow can generally be considered as being unmanaged, in that
     * whenever the position changes, or other such things change, we need
     * to perform a layout but there is no reason to notify the parent. However
     * when things change which may impact the preferred size (such as
     * vertical, createCell, and configCell) then we need to notify the
     * parent.
     */
    @Override public void requestLayout() {
// Note: This block is commented as it was relaying on a bad assumption on how
//       layout request was handled in parent class that is now fixed.
//
//        // isNeedsLayout() is commented out due to RT-21417. This does not
//        // appear to impact performance (indeed, it may help), and resolves the
//        // issue identified in RT-21417.
//        setNeedsLayout(true);

        // The fix is to prograte this layout request to its parent class.
        // A better fix will be required if performance is negatively affected
        // by this fix.
        super.requestLayout();
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (needsRecreateCells) {
            lastWidth = -1;
            lastHeight = -1;
            releaseCell(accumCell);
//            accumCell = null;
//            accumCellParent.getChildren().clear();
            sheet.getChildren().clear();
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                cells.get(i).updateIndex(-1);
            }
            cells.clear();
            pile.clear();
            releaseAllPrivateCells();
        } else if (needsRebuildCells) {
            lastWidth = -1;
            lastHeight = -1;
            releaseCell(accumCell);
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                cells.get(i).updateIndex(-1);
            }
            addAllToPile();
            releaseAllPrivateCells();
        } else if (needsReconfigureCells) {
            setMaxPrefBreadth(-1);
            lastWidth = -1;
            lastHeight = -1;
        }

        if (! dirtyCells.isEmpty()) {
            int index;
            final int cellsSize = cells.size();
            while ((index = dirtyCells.nextSetBit(0)) != -1 &amp;&amp; index &lt; cellsSize) {
                T cell = cells.get(index);
                // updateIndex(-1) works for TableView, but breaks ListView.
                // For now, the TableView just does not use the dirtyCells API
//                cell.updateIndex(-1);
                if (cell != null) {
                    cell.requestLayout();
                }
                dirtyCells.clear(index);
            }

            setMaxPrefBreadth(-1);
            lastWidth = -1;
            lastHeight = -1;
        }

        final boolean hasSizeChange = sizeChanged;
        boolean recreatedOrRebuilt = needsRebuildCells || needsRecreateCells || sizeChanged;

        needsRecreateCells = false;
        needsReconfigureCells = false;
        needsRebuildCells = false;
        sizeChanged = false;

        if (needsCellsLayout) {
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                Cell&lt;?&gt; cell = cells.get(i);
                if (cell != null) {
                    cell.requestLayout();
                }
            }
            needsCellsLayout = false;

            // yes, we return here - if needsCellsLayout was set to true, we
            // only did it to do the above - not rerun the entire layout.
            return;
        }

        final double width = getWidth();
        final double height = getHeight();
        final boolean isVertical = isVertical();
        final double position = getPosition();

        // if the width and/or height is 0, then there is no point doing
        // any of this work. In particular, this can happen during startup
        if (width &lt;= 0 || height &lt;= 0) {
            addAllToPile();
            lastWidth = width;
            lastHeight = height;
            hbar.setVisible(false);
            vbar.setVisible(false);
            corner.setVisible(false);
            return;
        }

        // we check if any of the cells in the cells list need layout. This is a
        // sign that they are perhaps animating their sizes. Without this check,
        // we may not perform a layout here, meaning that the cell will likely
        // 'jump' (in height normally) when the user drags the virtual thumb as
        // that is the first time the layout would occur otherwise.
        boolean cellNeedsLayout = false;
        boolean thumbNeedsLayout = false;

        if (Properties.IS_TOUCH_SUPPORTED) {
            if ((tempVisibility == true &amp;&amp; (hbar.isVisible() == false || vbar.isVisible() == false)) ||
                (tempVisibility == false &amp;&amp; (hbar.isVisible() == true || vbar.isVisible() == true))) {
                thumbNeedsLayout = true;
            }
        }

        if (!cellNeedsLayout) {
            for (int i = 0; i &lt; cells.size(); i++) {
                Cell&lt;?&gt; cell = cells.get(i);
                cellNeedsLayout = cell.isNeedsLayout();
                if (cellNeedsLayout) break;
            }
        }

        final int cellCount = getCellCount();
        final T firstCell = getFirstVisibleCell();

        // If no cells need layout, we check other criteria to see if this
        // layout call is even necessary. If it is found that no layout is
        // needed, we just punt.
        if (! cellNeedsLayout &amp;&amp; !thumbNeedsLayout) {
            boolean cellSizeChanged = false;
            if (firstCell != null) {
                double breadth = getCellBreadth(firstCell);
                double length = getCellLength(firstCell);
                cellSizeChanged = (breadth != lastCellBreadth) || (length != lastCellLength);
                lastCellBreadth = breadth;
                lastCellLength = length;
            }

            if (width == lastWidth &amp;&amp;
                height == lastHeight &amp;&amp;
                cellCount == lastCellCount &amp;&amp;
                isVertical == lastVertical &amp;&amp;
                position == lastPosition &amp;&amp;
                ! cellSizeChanged)
            {
                // TODO this happens to work around the problem tested by
                // testCellLayout_LayoutWithoutChangingThingsUsesCellsInSameOrderAsBefore
                // but isn't a proper solution. Really what we need to do is, when
                // laying out cells, we need to make sure that if a cell is pressed
                // AND we are doing a full rebuild then we need to make sure we
                // use that cell in the same physical location as before so that
                // it gets the mouse release event.
                return;
            }
        }

        /*
         * This function may get called under a variety of circumstances.
         * It will determine what has changed from the last time it was laid
         * out, and will then take one of several execution paths based on
         * what has changed so as to perform minimal layout work and also to
         * give the expected behavior. One or more of the following may have
         * happened:
         *
         *  1) width/height has changed
         *      - If the width and/or height has been reduced (but neither of
         *        them has been expanded), then we simply have to reposition and
         *        resize the scroll bars
         *      - If the width (in the vertical case) has expanded, then we
         *        need to resize the existing cells and reposition and resize
         *        the scroll bars
         *      - If the height (in the vertical case) has expanded, then we
         *        need to resize and reposition the scroll bars and add
         *        any trailing cells
         *
         *  2) cell count has changed
         *      - If the number of cells is bigger, or it is smaller but not
         *        so small as to move the position then we can just update the
         *        cells in place without performing layout and update the
         *        scroll bars.
         *      - If the number of cells has been reduced and it affects the
         *        position, then move the position and rebuild all the cells
         *        and update the scroll bars
         *
         *  3) size of the cell has changed
         *      - If the size changed in the virtual direction (ie: height
         *        in the case of vertical) then layout the cells, adding
         *        trailing cells as necessary and updating the scroll bars
         *      - If the size changed in the non virtual direction (ie: width
         *        in the case of vertical) then simply adjust the widths of
         *        the cells as appropriate and adjust the scroll bars
         *
         *  4) vertical changed, cells is empty, maxPrefBreadth == -1, etc
         *      - Full rebuild.
         *
         * Each of the conditions really resolves to several of a handful of
         * possible outcomes:
         *  a) reposition &amp; rebuild scroll bars
         *  b) resize cells in non-virtual direction
         *  c) add trailing cells
         *  d) update cells
         *  e) resize cells in the virtual direction
         *  f) all of the above
         *
         * So this function first determines what outcomes need to occur, and
         * then will execute all the ones that really need to happen. Every code
         * path ends up touching the &quot;reposition &amp; rebuild scroll bars&quot; outcome,
         * so that one will be executed every time.
         */
        boolean needTrailingCells = false;
        boolean rebuild = cellNeedsLayout  ||
                isVertical != lastVertical ||
                cells.isEmpty()            ||
                getMaxPrefBreadth() == -1  ||
                position != lastPosition   ||
                cellCount != lastCellCount ||
                hasSizeChange ||
                (isVertical &amp;&amp; height &lt; lastHeight) || (! isVertical &amp;&amp; width &lt; lastWidth);

        if (!rebuild) {
            // Check if maxPrefBreadth didn't change
            double maxPrefBreadth = getMaxPrefBreadth();
            boolean foundMax = false;
            for (int i = 0; i &lt; cells.size(); ++i) {
                double breadth = getCellBreadth(cells.get(i));
                if (maxPrefBreadth == breadth) {
                    foundMax = true;
                } else if (breadth &gt; maxPrefBreadth) {
                    rebuild = true;
                    break;
                }
            }
            if (!foundMax) { // All values were lower
                rebuild = true;
            }
        }

        if (! rebuild) {
            if ((isVertical &amp;&amp; height &gt; lastHeight) || (! isVertical &amp;&amp; width &gt; lastWidth)) {
                // resized in the virtual direction
                needTrailingCells = true;
            }
        }

        initViewport();

        // Get the index of the &quot;current&quot; cell
        int currentIndex = computeCurrentIndex();
        if (lastCellCount != cellCount) {
            // The cell count has changed. We want to keep the viewport
            // stable if possible. If position was 0 or 1, we want to keep
            // the position in the same place. If the new cell count is &gt;=
            // the currentIndex, then we will adjust the position to be 1.
            // Otherwise, our goal is to leave the index of the cell at the
            // top consistent, with the same translation etc.
            if (position == 0 || position == 1) {
                // Update the item count
//                setItemCount(cellCount);
            } else if (currentIndex &gt;= cellCount) {
                setPosition(1.0f);
//                setItemCount(cellCount);
            } else if (firstCell != null) {
                double firstCellOffset = getCellPosition(firstCell);
                int firstCellIndex = getCellIndex(firstCell);
//                setItemCount(cellCount);
                adjustPositionToIndex(firstCellIndex);
                double viewportTopToCellTop = -computeOffsetForCell(firstCellIndex);
                adjustByPixelAmount(viewportTopToCellTop - firstCellOffset);
            }

            // Update the current index
            currentIndex = computeCurrentIndex();
        }

        if (rebuild) {
            setMaxPrefBreadth(-1);
            // Start by dumping all the cells into the pile
            addAllToPile();

            // The distance from the top of the viewport to the top of the
            // cell for the current index.
            double offset = -computeViewportOffset(getPosition());

            // Add all the leading and trailing cells (the call to add leading
            // cells will add the current cell as well -- that is, the one that
            // represents the current position on the mapper).
            addLeadingCells(currentIndex, offset);

            // Force filling of space with empty cells if necessary
            addTrailingCells(true);
        } else if (needTrailingCells) {
            addTrailingCells(true);
        }

        computeBarVisiblity();

        recreatedOrRebuilt = recreatedOrRebuilt || rebuild;
        updateScrollBarsAndCells(recreatedOrRebuilt);

        lastWidth = getWidth();
        lastHeight = getHeight();
        lastCellCount = getCellCount();
        lastVertical = isVertical();
        lastPosition = getPosition();

        cleanPile();
    }

    /** {@inheritDoc} */
    @Override protected void setWidth(double value) {
        if (value != lastWidth) {
            super.setWidth(value);
            sizeChanged = true;
            setNeedsLayout(true);
            requestLayout();
        }
    }

    /** {@inheritDoc} */
    @Override protected void setHeight(double value) {
        if (value != lastHeight) {
            super.setHeight(value);
            sizeChanged = true;
            setNeedsLayout(true);
            requestLayout();
        }
    }

    /**
     * Get a cell which can be used in the layout. This function will reuse
     * cells from the pile where possible, and will create new cells when
     * necessary.
     * @param prefIndex the preferred index
     * @return the available cell
     */
    protected T getAvailableCell(int prefIndex) {
        T cell = null;

        // Fix for RT-12822. We try to retrieve the cell from the pile rather
        // than just grab a random cell from the pile (or create another cell).
        for (int i = 0, max = pile.size(); i &lt; max; i++) {
            T _cell = pile.get(i);
            assert _cell != null;

            if (getCellIndex(_cell) == prefIndex) {
                cell = _cell;
                pile.remove(i);
                break;
            }
        }

        if (cell == null &amp;&amp; !pile.isEmpty()) {
            cell = pile.removeLast();
        }

        if (cell == null) {
            cell = getCellFactory().call(this);
            cell.getProperties().put(NEW_CELL, null);
        }

        if (cell.getParent() == null) {
            sheetChildren.add(cell);
        }

        return cell;
    }

    /**
     * This method will remove all cells from the VirtualFlow and remove them,
     * adding them to the 'pile' (that is, a place from where cells can be used
     * at a later date). This method is protected to allow subclasses to clean up
     * appropriately.
     */
    protected void addAllToPile() {
        for (int i = 0, max = cells.size(); i &lt; max; i++) {
            addToPile(cells.removeFirst());
        }
    }

    /**
     * Gets a cell for the given index if the cell has been created and laid out.
     * &quot;Visible&quot; is a bit of a misnomer, the cell might not be visible in the
     * viewport (it may be clipped), but does distinguish between cells that
     * have been created and are in use vs. those that are in the pile or
     * not created.
     * @param index the index
     * @return the visible cell
     */
    public T getVisibleCell(int index) {
        if (cells.isEmpty()) return null;

        // check the last index
        T lastCell = cells.getLast();
        int lastIndex = getCellIndex(lastCell);
        if (index == lastIndex) return lastCell;

        // check the first index
        T firstCell = cells.getFirst();
        int firstIndex = getCellIndex(firstCell);
        if (index == firstIndex) return firstCell;

        // if index is &gt; firstIndex and &lt; lastIndex then we can get the index
        if (index &gt; firstIndex &amp;&amp; index &lt; lastIndex) {
            T cell = cells.get(index - firstIndex);
            if (getCellIndex(cell) == index) return cell;
        }

        // there is no visible cell for the specified index
        return null;
    }

    /**
     * Locates and returns the last non-empty IndexedCell that is currently
     * partially or completely visible. This function may return null if there
     * are no cells, or if the viewport length is 0.
     * @return the last visible cell
     */
    public T getLastVisibleCell() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;

        T cell;
        for (int i = cells.size() - 1; i &gt;= 0; i--) {
            cell = cells.get(i);
            if (! cell.isEmpty()) {
                return cell;
            }
        }

        return null;
    }

    /**
     * Locates and returns the first non-empty IndexedCell that is partially or
     * completely visible. This really only ever returns null if there are no
     * cells or the viewport length is 0.
     * @return the first visible cell
     */
    public T getFirstVisibleCell() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;
        T cell = cells.getFirst();
        return cell.isEmpty() ? null : cell;
    }

    /**
     * Adjust the position of cells so that the specified cell
     * will be positioned at the start of the viewport. The given cell must
     * already be &quot;live&quot;.
     * @param firstCell the first cell
     */
    public void scrollToTop(T firstCell) {
        if (firstCell != null) {
            scrollPixels(getCellPosition(firstCell));
        }
    }

    /**
     * Adjust the position of cells so that the specified cell
     * will be positioned at the end of the viewport. The given cell must
     * already be &quot;live&quot;.
     * @param lastCell the last cell
     */
    public void scrollToBottom(T lastCell) {
        if (lastCell != null) {
            scrollPixels(getCellPosition(lastCell) + getCellLength(lastCell) - getViewportLength());
        }
    }

    /**
     * Adjusts the cells such that the selected cell will be fully visible in
     * the viewport (but only just).
     * @param cell the cell
     */
    public void scrollTo(T cell) {
        if (cell != null) {
            final double start = getCellPosition(cell);
            final double length = getCellLength(cell);
            final double end = start + length;
            final double viewportLength = getViewportLength();

            if (start &lt; 0) {
                scrollPixels(start);
            } else if (end &gt; viewportLength) {
                scrollPixels(end - viewportLength);
            }
        }
    }

    /**
     * Adjusts the cells such that the cell in the given index will be fully visible in
     * the viewport.
     * @param index the index
     */
    public void scrollTo(int index) {
        T cell = getVisibleCell(index);
        if (cell != null) {
            scrollTo(cell);
        } else {
            adjustPositionToIndex(index);
            addAllToPile();
            requestLayout();
        }
    }

    /**
     * Adjusts the cells such that the cell in the given index will be fully visible in
     * the viewport, and positioned at the very top of the viewport.
     * @param index the index
     */
    public void scrollToTop(int index) {
        boolean posSet = false;

        if (index &gt;= getCellCount() - 1) {
            setPosition(1);
            posSet = true;
        } else if (index &lt; 0) {
            setPosition(0);
            posSet = true;
        }

        if (! posSet) {
            adjustPositionToIndex(index);
            double offset = - computeOffsetForCell(index);
            adjustByPixelAmount(offset);
        }

        requestLayout();
    }

//    //TODO We assume all the cell have the same length.  We will need to support
//    // cells of different lengths.
//    public void scrollToOffset(int offset) {
//        scrollPixels(offset * getCellLength(0));
//    }

    /**
     * Given a delta value representing a number of pixels, this method attempts
     * to move the VirtualFlow in the given direction (positive is down/right,
     * negative is up/left) the given number of pixels. It returns the number of
     * pixels actually moved.
     * @param delta the delta value
     * @return the number of pixels actually moved
     */
    public double scrollPixels(final double delta) {
        // Short cut this method for cases where nothing should be done
        if (delta == 0) return 0;

        final boolean isVertical = isVertical();
        if (((isVertical &amp;&amp; (tempVisibility ? !needLengthBar : !vbar.isVisible())) ||
                (! isVertical &amp;&amp; (tempVisibility ? !needLengthBar : !hbar.isVisible())))) return 0;

        double pos = getPosition();
        if (pos == 0.0f &amp;&amp; delta &lt; 0) return 0;
        if (pos == 1.0f &amp;&amp; delta &gt; 0) return 0;

        adjustByPixelAmount(delta);
        if (pos == getPosition()) {
            // The pos hasn't changed, there's nothing to do. This is likely
            // to occur when we hit either extremity
            return 0;
        }

        // Now move stuff around. Translating by pixels fundamentally means
        // moving the cells by the delta. However, after having
        // done that, we need to go through the cells and see which cells,
        // after adding in the translation factor, now fall off the viewport.
        // Also, we need to add cells as appropriate to the end (or beginning,
        // depending on the direction of travel).
        //
        // One simplifying assumption (that had better be true!) is that we
        // will only make it this far in the function if the virtual scroll
        // bar is visible. Otherwise, we never will pixel scroll. So as we go,
        // if we find that the maxPrefBreadth exceeds the viewportBreadth,
        // then we will be sure to show the breadthBar and update it
        // accordingly.
        if (cells.size() &gt; 0) {
            for (int i = 0; i &lt; cells.size(); i++) {
                T cell = cells.get(i);
                assert cell != null;
                positionCell(cell, getCellPosition(cell) - delta);
            }

            // Fix for RT-32908
            T firstCell = cells.getFirst();
            double layoutY = firstCell == null ? 0 : getCellPosition(firstCell);
            for (int i = 0; i &lt; cells.size(); i++) {
                T cell = cells.get(i);
                assert cell != null;
                double actualLayoutY = getCellPosition(cell);
                if (Math.abs(actualLayoutY - layoutY) &gt; 0.001) {
                    // we need to shift the cell to layoutY
                    positionCell(cell, layoutY);
                }

                layoutY += getCellLength(cell);
            }
            // end of fix for RT-32908
            cull();
            firstCell = cells.getFirst();

            // Add any necessary leading cells
            if (firstCell != null) {
                int firstIndex = getCellIndex(firstCell);
                double prevIndexSize = getCellLength(firstIndex - 1);
                addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);
            } else {
                int currentIndex = computeCurrentIndex();

                // The distance from the top of the viewport to the top of the
                // cell for the current index.
                double offset = -computeViewportOffset(getPosition());

                // Add all the leading and trailing cells (the call to add leading
                // cells will add the current cell as well -- that is, the one that
                // represents the current position on the mapper).
                addLeadingCells(currentIndex, offset);
            }

            // Starting at the tail of the list, loop adding cells until
            // all the space on the table is filled up. We want to make
            // sure that we DO NOT add empty trailing cells (since we are
            // in the full virtual case and so there are no trailing empty
            // cells).
            if (! addTrailingCells(false)) {
                // Reached the end, but not enough cells to fill up to
                // the end. So, remove the trailing empty space, and translate
                // the cells down
                final T lastCell = getLastVisibleCell();
                final double lastCellSize = getCellLength(lastCell);
                final double cellEnd = getCellPosition(lastCell) + lastCellSize;
                final double viewportLength = getViewportLength();

                if (cellEnd &lt; viewportLength) {
                    // Reposition the nodes
                    double emptySize = viewportLength - cellEnd;
                    for (int i = 0; i &lt; cells.size(); i++) {
                        T cell = cells.get(i);
                        positionCell(cell, getCellPosition(cell) + emptySize);
                    }
                    setPosition(1.0f);
                    // fill the leading empty space
                    firstCell = cells.getFirst();
                    int firstIndex = getCellIndex(firstCell);
                    double prevIndexSize = getCellLength(firstIndex - 1);
                    addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);
                }
            }
        }

        // Now throw away any cells that don't fit
        cull();

        // Finally, update the scroll bars
        updateScrollBarsAndCells(false);
        lastPosition = getPosition();

        // notify
        return delta; // TODO fake
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        double w = isVertical() ? getPrefBreadth(height) : getPrefLength();
        return w + vbar.prefWidth(-1);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        double h = isVertical() ? getPrefLength() : getPrefBreadth(width);
        return h + hbar.prefHeight(-1);
    }

    /**
     * Return a cell for the given index. This may be called for any cell,
     * including beyond the range defined by cellCount, in which case an
     * empty cell will be returned. The returned value should not be stored for
     * any reason.
     * @param index the index
     * @return the cell
     */
    public T getCell(int index) {
        // If there are cells, then we will attempt to get an existing cell
        if (! cells.isEmpty()) {
            // First check the cells that have already been created and are
            // in use. If this call returns a value, then we can use it
            T cell = getVisibleCell(index);
            if (cell != null) return cell;
        }

        // check the pile
        for (int i = 0; i &lt; pile.size(); i++) {
            T cell = pile.get(i);
            if (getCellIndex(cell) == index) {
                // Note that we don't remove from the pile: if we do it leads
                // to a severe performance decrease. This seems to be OK, as
                // getCell() is only used for cell measurement purposes.
                // pile.remove(i);
                return cell;
            }
        }

        if (pile.size() &gt; 0) {
            return pile.get(0);
        }

        // We need to use the accumCell and return that
        if (accumCell == null) {
            Callback&lt;VirtualFlow&lt;T&gt;,T&gt; cellFactory = getCellFactory();
            if (cellFactory != null) {
                accumCell = cellFactory.call(this);
                accumCell.getProperties().put(NEW_CELL, null);
                accumCellParent.getChildren().setAll(accumCell);

                // Note the screen reader will attempt to find all
                // the items inside the view to calculate the item count.
                // Having items under different parents (sheet and accumCellParent)
                // leads the screen reader to compute wrong values.
                // The regular scheme to provide items to the screen reader
                // uses getPrivateCell(), which places the item in the sheet.
                // The accumCell, and its children, should be ignored by the
                // screen reader.
                accumCell.setAccessibleRole(AccessibleRole.NODE);
                accumCell.getChildrenUnmodifiable().addListener((Observable c) -&gt; {
                    for (Node n : accumCell.getChildrenUnmodifiable()) {
                        n.setAccessibleRole(AccessibleRole.NODE);
                    }
                });
            }
        }
        setCellIndex(accumCell, index);
        resizeCellSize(accumCell);
        return accumCell;
    }

    /**
     * The VirtualFlow uses this method to set a cells index (rather than calling
     * {@link IndexedCell#updateIndex(int)} directly), so it is a perfect place
     * for subclasses to override if this if of interest.
     *
     * @param cell The cell whose index will be updated.
     * @param index The new index for the cell.
     */
    protected void setCellIndex(T cell, int index) {
        assert cell != null;

        cell.updateIndex(index);

        // make sure the cell is sized correctly. This is important for both
        // general layout of cells in a VirtualFlow, but also in cases such as
        // RT-34333, where the sizes were being reported incorrectly to the
        // ComboBox popup.
        if ((cell.isNeedsLayout() &amp;&amp; cell.getScene() != null) || cell.getProperties().containsKey(NEW_CELL)) {
            cell.applyCss();
            cell.getProperties().remove(NEW_CELL);
        }
    }

    /**
     * Return the index for a given cell. This allows subclasses to customise
     * how cell indices are retrieved.
     * @param cell the cell
     * @return the index
     */
    protected int getCellIndex(T cell){
        return cell.getIndex();
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    final VirtualScrollBar getHbar() {
        return hbar;
    }
    final VirtualScrollBar getVbar() {
        return vbar;
    }

    /**
     * The maximum preferred size in the non-virtual direction. For example,
     * if vertical, then this is the max pref width of all cells encountered.
     * &lt;p&gt;
     * In general, this is the largest preferred size in the non-virtual
     * direction that we have ever encountered. We don't reduce this size
     * unless instructed to do so, so as to reduce the amount of scroll bar
     * jitter. The access on this variable is package ONLY FOR TESTING.
     */
    private double maxPrefBreadth;
    private final void setMaxPrefBreadth(double value) {
        this.maxPrefBreadth = value;
    }
    final double getMaxPrefBreadth() {
        return maxPrefBreadth;
    }

    /**
     * The breadth of the viewport portion of the VirtualFlow as computed during
     * the layout pass. In a vertical flow this would be the same as the clip
     * view width. In a horizontal flow this is the clip view height.
     * The access on this variable is package ONLY FOR TESTING.
     */
    private double viewportBreadth;
    private final void setViewportBreadth(double value) {
        this.viewportBreadth = value;
    }
    private final double getViewportBreadth() {
        return viewportBreadth;
    }

    /**
     * The length of the viewport portion of the VirtualFlow as computed
     * during the layout pass. In a vertical flow this would be the same as the
     * clip view height. In a horizontal flow this is the clip view width.
     * The access on this variable is package ONLY FOR TESTING.
     */
    private double viewportLength;
    void setViewportLength(double value) {
        this.viewportLength = value;
    }
    double getViewportLength() {
        return viewportLength;
    }

    /**
     * Compute and return the length of the cell for the given index. This is
     * called both internally when adjusting by pixels, and also at times
     * by PositionMapper (see the getItemSize callback). When called by
     * PositionMapper, it is possible that it will be called for some index
     * which is not associated with any cell, so we have to do a bit of work
     * to use a cell as a helper for computing cell size in some cases.
     */
    double getCellLength(int index) {
        if (fixedCellSizeEnabled) return getFixedCellSize();

        T cell = getCell(index);
        double length = getCellLength(cell);
        releaseCell(cell);
        return length;
    }

    /**
     */
    double getCellBreadth(int index) {
        T cell = getCell(index);
        double b = getCellBreadth(cell);
        releaseCell(cell);
        return b;
    }

    /**
     * Gets the length of a specific cell
     */
    double getCellLength(T cell) {
        if (cell == null) return 0;
        if (fixedCellSizeEnabled) return getFixedCellSize();

        return isVertical() ?
                cell.getLayoutBounds().getHeight()
                : cell.getLayoutBounds().getWidth();
    }

    /**
     * Gets the breadth of a specific cell
     */
    double getCellBreadth(Cell cell) {
        return isVertical() ?
                cell.prefWidth(-1)
                : cell.prefHeight(-1);
    }

    /**
     * Gets the layout position of the cell along the length axis
     */
    double getCellPosition(T cell) {
        if (cell == null) return 0;

        return isVertical() ?
                cell.getLayoutY()
                : cell.getLayoutX();
<A NAME="40"></A>    }

    private void positionCell(T cell, double position) {
        <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#40',2,'match42-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (isVertical()) {
            cell.setLayoutX(0);
            cell.setLayoutY(snapSizeY(position));
        } else {
            cell.setLayoutX(snapSizeX(position));
            cell.setLayoutY(0);
        }
    }</B></FONT>

    private void resizeCellSize(T cell) {
        if (cell == null) return;

        if (isVertical()) {
            double width = Math.max(getMaxPrefBreadth(), getViewportBreadth());
            cell.resize(width, fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefHeight(width), cell.minHeight(width), cell.maxHeight(width)));
        } else {
            double height = Math.max(getMaxPrefBreadth(), getViewportBreadth());
            cell.resize(fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefWidth(height), cell.minWidth(height), cell.maxWidth(height)), height);
        }
    }

    private List&lt;T&gt; getCells() {
        return cells;
    }

    // Returns last visible cell whose bounds are entirely within the viewport
    T getLastVisibleCellWithinViewPort() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;

        T cell;
        final double max = getViewportLength();
        for (int i = cells.size() - 1; i &gt;= 0; i--) {
            cell = cells.get(i);
            if (cell.isEmpty()) continue;

            final double cellStart = getCellPosition(cell);
            final double cellEnd = cellStart + getCellLength(cell);

            // we use the magic +2 to allow for a little bit of fuzziness,
            // this is to help in situations such as RT-34407
            if (cellEnd &lt;= (max + 2)) {
                return cell;
            }
        }

        return null;
    }

    // Returns first visible cell whose bounds are entirely within the viewport
    T getFirstVisibleCellWithinViewPort() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;

        T cell;
        for (int i = 0; i &lt; cells.size(); i++) {
            cell = cells.get(i);
            if (cell.isEmpty()) continue;

            final double cellStart = getCellPosition(cell);
            if (cellStart &gt;= 0) {
                return cell;
            }
        }

        return null;
    }

    /**
     * Adds all the cells prior to and including the given currentIndex, until
     * no more can be added without falling off the flow. The startOffset
     * indicates the distance from the leading edge (top) of the viewport to
     * the leading edge (top) of the currentIndex.
     */
    void addLeadingCells(int currentIndex, double startOffset) {
        // The offset will keep track of the distance from the top of the
        // viewport to the top of the current index. We will increment it
        // as we lay out leading cells.
        double offset = startOffset;
        // The index is the absolute index of the cell being laid out
        int index = currentIndex;

        // Offset should really be the bottom of the current index
        boolean first = true; // first time in, we just fudge the offset and let
        // it be the top of the current index then redefine
        // it as the bottom of the current index thereafter
        // while we have not yet laid out so many cells that they would fall
        // off the flow, we will continue to create and add cells. The
        // offset is our indication of whether we can lay out additional
        // cells. If the offset is ever &lt; 0, except in the case of the very
        // first cell, then we must quit.
        T cell = null;

        // special case for the position == 1.0, skip adding last invisible cell
        if (index == getCellCount() &amp;&amp; offset == getViewportLength()) {
            index--;
            first = false;
        }
        while (index &gt;= 0 &amp;&amp; (offset &gt; 0 || first)) {
            cell = getAvailableCell(index);
            setCellIndex(cell, index);
            resizeCellSize(cell); // resize must be after config
            cells.addFirst(cell);

            // A little gross but better than alternatives because it reduces
            // the number of times we have to update a cell or compute its
            // size. The first time into this loop &quot;offset&quot; is actually the
            // top of the current index. On all subsequent visits, it is the
            // bottom of the current index.
            if (first) {
                first = false;
            } else {
                offset -= getCellLength(cell);
            }

            // Position the cell, and update the maxPrefBreadth variable as we go.
            positionCell(cell, offset);
            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
            cell.setVisible(true);
            --index;
        }

        // There are times when after laying out the cells we discover that
        // the top of the first cell which represents index 0 is below the top
        // of the viewport. In these cases, we have to adjust the cells up
        // and reset the mapper position. This might happen when items got
        // removed at the top or when the viewport size increased.
        if (cells.size() &gt; 0) {
            cell = cells.getFirst();
            int firstIndex = getCellIndex(cell);
            double firstCellPos = getCellPosition(cell);
            if (firstIndex == 0 &amp;&amp; firstCellPos &gt; 0) {
                setPosition(0.0f);
                offset = 0;
                for (int i = 0; i &lt; cells.size(); i++) {
                    cell = cells.get(i);
                    positionCell(cell, offset);
                    offset += getCellLength(cell);
                }
            }
        } else {
            // reset scrollbar to top, so if the flow sees cells again it starts at the top
            vbar.setValue(0);
            hbar.setValue(0);
        }
    }

    /**
     * Adds all the trailing cells that come &lt;em&gt;after&lt;/em&gt; the last index in
     * the cells ObservableList.
     */
    boolean addTrailingCells(boolean fillEmptyCells) {
        // If cells is empty then addLeadingCells bailed for some reason and
        // we're hosed, so just punt
        if (cells.isEmpty()) return false;

        // While we have not yet laid out so many cells that they would fall
        // off the flow, so we will continue to create and add cells. When the
        // offset becomes greater than the width/height of the flow, then we
        // know we cannot add any more cells.
        T startCell = cells.getLast();
        double offset = getCellPosition(startCell) + getCellLength(startCell);
        int index = getCellIndex(startCell) + 1;
        final int cellCount = getCellCount();
        boolean filledWithNonEmpty = index &lt;= cellCount;

        final double viewportLength = getViewportLength();

        // Fix for RT-37421, which was a regression caused by RT-36556
        if (offset &lt; 0 &amp;&amp; !fillEmptyCells) {
            return false;
        }

        //
        // RT-36507: viewportLength gives the maximum number of
        // additional cells that should ever be able to fit in the viewport if
        // every cell had a height of 1. If index ever exceeds this count,
        // then offset is not incrementing fast enough, or at all, which means
        // there is something wrong with the cell size calculation.
        //
        final double maxCellCount = viewportLength;
        while (offset &lt; viewportLength) {
            if (index &gt;= cellCount) {
                if (offset &lt; viewportLength) filledWithNonEmpty = false;
                if (! fillEmptyCells) return filledWithNonEmpty;
                // RT-36507 - return if we've exceeded the maximum
                if (index &gt; maxCellCount) {
                    final PlatformLogger logger = Logging.getControlsLogger();
                    if (logger.isLoggable(PlatformLogger.Level.INFO)) {
                        logger.info(&quot;index exceeds maxCellCount. Check size calculations for &quot; + startCell.getClass());
                    }
                    return filledWithNonEmpty;
                }
            }
            T cell = getAvailableCell(index);
            setCellIndex(cell, index);
            resizeCellSize(cell); // resize happens after config!
            cells.addLast(cell);

            // Position the cell and update the max pref
            positionCell(cell, offset);
            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));

            offset += getCellLength(cell);
            cell.setVisible(true);
            ++index;
        }

        // Discover whether the first cell coincides with index #0. If after
        // adding all the trailing cells we find that a) the first cell was
        // not index #0 and b) there are trailing cells, then we have a
        // problem. We need to shift all the cells down and add leading cells,
        // one at a time, until either the very last non-empty cells is aligned
        // with the bottom OR we have laid out cell index #0 at the first
        // position.
        T firstCell = cells.getFirst();
        index = getCellIndex(firstCell);
        T lastNonEmptyCell = getLastVisibleCell();
        double start = getCellPosition(firstCell);
        double end = getCellPosition(lastNonEmptyCell) + getCellLength(lastNonEmptyCell);
        if ((index != 0 || (index == 0 &amp;&amp; start &lt; 0)) &amp;&amp; fillEmptyCells &amp;&amp;
                lastNonEmptyCell != null &amp;&amp; getCellIndex(lastNonEmptyCell) == cellCount - 1 &amp;&amp; end &lt; viewportLength) {

            double prospectiveEnd = end;
            double distance = viewportLength - end;
            while (prospectiveEnd &lt; viewportLength &amp;&amp; index != 0 &amp;&amp; (-start) &lt; distance) {
                index--;
                T cell = getAvailableCell(index);
                setCellIndex(cell, index);
                resizeCellSize(cell); // resize must be after config
                cells.addFirst(cell);
                double cellLength = getCellLength(cell);
                start -= cellLength;
                prospectiveEnd += cellLength;
                positionCell(cell, start);
                setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
                cell.setVisible(true);
            }

            // The amount by which to translate the cells down
            firstCell = cells.getFirst();
            start = getCellPosition(firstCell);
            double delta = viewportLength - end;
            if (getCellIndex(firstCell) == 0 &amp;&amp; delta &gt; (-start)) {
                delta = (-start);
            }
            // Move things
            for (int i = 0; i &lt; cells.size(); i++) {
                T cell = cells.get(i);
                positionCell(cell, getCellPosition(cell) + delta);
            }

            // Check whether the first cell, subsequent to our adjustments, is
            // now index #0 and aligned with the top. If so, change the position
            // to be at 0 instead of 1.
            start = getCellPosition(firstCell);
            if (getCellIndex(firstCell) == 0 &amp;&amp; start == 0) {
                setPosition(0);
            } else if (getPosition() != 1) {
                setPosition(1);
            }
        }

        return filledWithNonEmpty;
    }

    void reconfigureCells() {
        needsReconfigureCells = true;
        requestLayout();
    }

    void recreateCells() {
        needsRecreateCells = true;
        requestLayout();
    }

    void rebuildCells() {
        needsRebuildCells = true;
        requestLayout();
    }

    void requestCellLayout() {
        needsCellsLayout = true;
        requestLayout();
    }

    void setCellDirty(int index) {
        dirtyCells.set(index);
        requestLayout();
    }

    private void startSBReleasedAnimation() {
        if (sbTouchTimeline == null) {
            /*
            ** timeline to leave the scrollbars visible for a short
            ** while after a scroll/drag
            */
            sbTouchTimeline = new Timeline();
            sbTouchKF1 = new KeyFrame(Duration.millis(0), event -&gt; {
                tempVisibility = true;
                requestLayout();
            });

            sbTouchKF2 = new KeyFrame(Duration.millis(1000), event -&gt; {
                if (touchDetected == false &amp;&amp; mouseDown == false) {
                    tempVisibility = false;
                    requestLayout();
                }
            });
            sbTouchTimeline.getKeyFrames().addAll(sbTouchKF1, sbTouchKF2);
        }
        sbTouchTimeline.playFromStart();
    }

    private void scrollBarOn() {
        tempVisibility = true;
        requestLayout();
    }

    void updateHbar() {
        if (! isVisible() || getScene() == null) return;
        // Bring the clipView.clipX back to 0 if control is vertical or
        // the hbar isn't visible (fix for RT-11666)
        if (isVertical()) {
            if (hbar.isVisible()) {
                clipView.setClipX(hbar.getValue());
            } else {
                // all cells are now less than the width of the flow,
                // so we should shift the hbar/clip such that
                // everything is visible in the viewport.
                clipView.setClipX(0);
                hbar.setValue(0);
            }
        }
    }

    /**
     * @return true if bar visibility changed
     */
    private boolean computeBarVisiblity() {
        if (cells.isEmpty()) {
            // In case no cells are set yet, we assume no bars are needed
            needLengthBar = false;
            needBreadthBar = false;
            return true;
        }

        final boolean isVertical = isVertical();
        boolean barVisibilityChanged = false;

        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;

        final double viewportBreadth = getViewportBreadth();

        final int cellsSize = cells.size();
        final int cellCount = getCellCount();
        for (int i = 0; i &lt; 2; i++) {
            final boolean lengthBarVisible = getPosition() &gt; 0
                    || cellCount &gt; cellsSize
                    || (cellCount == cellsSize &amp;&amp; (getCellPosition(cells.getLast()) + getCellLength(cells.getLast())) &gt; getViewportLength())
                    || (cellCount == cellsSize - 1 &amp;&amp; barVisibilityChanged &amp;&amp; needBreadthBar);

            if (lengthBarVisible ^ needLengthBar) {
                needLengthBar = lengthBarVisible;
                barVisibilityChanged = true;
            }

            // second conditional removed for RT-36669.
            final boolean breadthBarVisible = (maxPrefBreadth &gt; viewportBreadth);// || (needLengthBar &amp;&amp; maxPrefBreadth &gt; (viewportBreadth - lengthBarBreadth));
            if (breadthBarVisible ^ needBreadthBar) {
                needBreadthBar = breadthBarVisible;
                barVisibilityChanged = true;
            }
        }

        // Start by optimistically deciding whether the length bar and
        // breadth bar are needed and adjust the viewport dimensions
        // accordingly. If during layout we find that one or the other of the
        // bars actually is needed, then we will perform a cleanup pass

        if (!Properties.IS_TOUCH_SUPPORTED) {
            updateViewportDimensions();
            breadthBar.setVisible(needBreadthBar);
            lengthBar.setVisible(needLengthBar);
        } else {
            breadthBar.setVisible(needBreadthBar &amp;&amp; tempVisibility);
            lengthBar.setVisible(needLengthBar &amp;&amp; tempVisibility);
        }

        return barVisibilityChanged;
    }

    private void updateViewportDimensions() {
        final boolean isVertical = isVertical();
        final double breadthBarLength = isVertical ? snapSizeY(hbar.prefHeight(-1)) : snapSizeX(vbar.prefWidth(-1));
        final double lengthBarBreadth = isVertical ? snapSizeX(vbar.prefWidth(-1)) : snapSizeY(hbar.prefHeight(-1));

        setViewportBreadth((isVertical ? getWidth() : getHeight()) - (needLengthBar ? lengthBarBreadth : 0));
        setViewportLength((isVertical ? getHeight() : getWidth()) - (needBreadthBar ? breadthBarLength : 0));
    }

    private void initViewport() {
        // Initialize the viewportLength and viewportBreadth to match the
        // width/height of the flow
        final boolean isVertical = isVertical();

        updateViewportDimensions();

        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;

        // If there has been a switch between the virtualized bar, then we
        // will want to do some stuff TODO.
        breadthBar.setVirtual(false);
        lengthBar.setVirtual(true);
    }

    private void updateScrollBarsAndCells(boolean recreate) {
        // Assign the hbar and vbar to the breadthBar and lengthBar so as
        // to make some subsequent calculations easier.
        final boolean isVertical = isVertical();
        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;

        // We may have adjusted the viewport length and breadth after the
        // layout due to scroll bars becoming visible. So we need to perform
        // a follow up pass and resize and shift all the cells to fit the
        // viewport. Note that the prospective viewport size is always &gt;= the
        // final viewport size, so we don't have to worry about adding
        // cells during this cleanup phase.
        fitCells();

        // Update cell positions.
        // When rebuilding the cells, we add the cells and along the way compute
        // the maxPrefBreadth. Based on the computed value, we may add
        // the breadth scrollbar which changes viewport length, so we need
        // to re-position the cells.
        if (!cells.isEmpty()) {
            final double currOffset = -computeViewportOffset(getPosition());
            final int currIndex = computeCurrentIndex() - cells.getFirst().getIndex();
            final int size = cells.size();

            // position leading cells
            double offset = currOffset;

            for (int i = currIndex - 1; i &gt;= 0 &amp;&amp; i &lt; size; i--) {
                final T cell = cells.get(i);

                offset -= getCellLength(cell);

                positionCell(cell, offset);
            }

            // position trailing cells
            offset = currOffset;
            for (int i = currIndex; i &gt;= 0 &amp;&amp; i &lt; size; i++) {
                final T cell = cells.get(i);
                positionCell(cell, offset);

                offset += getCellLength(cell);
            }
        }

        // Toggle visibility on the corner
        corner.setVisible(breadthBar.isVisible() &amp;&amp; lengthBar.isVisible());

        double sumCellLength = 0;
        double flowLength = (isVertical ? getHeight() : getWidth()) -
                (breadthBar.isVisible() ? breadthBar.prefHeight(-1) : 0);

        final double viewportBreadth = getViewportBreadth();
        final double viewportLength = getViewportLength();

        // Now position and update the scroll bars
        if (breadthBar.isVisible()) {
            /*
            ** Positioning the ScrollBar
            */
            if (!Properties.IS_TOUCH_SUPPORTED) {
                if (isVertical) {
                    hbar.resizeRelocate(0, viewportLength,
                            viewportBreadth, hbar.prefHeight(viewportBreadth));
                } else {
                    vbar.resizeRelocate(viewportLength, 0,
                            vbar.prefWidth(viewportBreadth), viewportBreadth);
                }
            }
            else {
                if (isVertical) {
                    hbar.resizeRelocate(0, (viewportLength-hbar.getHeight()),
                            viewportBreadth, hbar.prefHeight(viewportBreadth));
                } else {
                    vbar.resizeRelocate((viewportLength-vbar.getWidth()), 0,
                            vbar.prefWidth(viewportBreadth), viewportBreadth);
                }
            }

            if (getMaxPrefBreadth() != -1) {
                double newMax = Math.max(1, getMaxPrefBreadth() - viewportBreadth);
                if (newMax != breadthBar.getMax()) {
                    breadthBar.setMax(newMax);

                    double breadthBarValue = breadthBar.getValue();
                    boolean maxed = breadthBarValue != 0 &amp;&amp; newMax == breadthBarValue;
                    if (maxed || breadthBarValue &gt; newMax) {
                        breadthBar.setValue(newMax);
                    }

                    breadthBar.setVisibleAmount((viewportBreadth / getMaxPrefBreadth()) * newMax);
                }
            }
        }

        // determine how many cells there are on screen so that the scrollbar
        // thumb can be appropriately sized
        if (recreate &amp;&amp; (lengthBar.isVisible() || Properties.IS_TOUCH_SUPPORTED)) {
            final int cellCount = getCellCount();
            int numCellsVisibleOnScreen = 0;
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                T cell = cells.get(i);
                if (cell != null &amp;&amp; !cell.isEmpty()) {
                    sumCellLength += (isVertical ? cell.getHeight() : cell.getWidth());
                    if (sumCellLength &gt; flowLength) {
                        break;
                    }

                    numCellsVisibleOnScreen++;
                }
            }

            lengthBar.setMax(1);
            if (numCellsVisibleOnScreen == 0 &amp;&amp; cellCount == 1) {
                // special case to help resolve RT-17701 and the case where we have
                // only a single row and it is bigger than the viewport
                lengthBar.setVisibleAmount(flowLength / sumCellLength);
            } else {
                lengthBar.setVisibleAmount(numCellsVisibleOnScreen / (float) cellCount);
            }
        }

        if (lengthBar.isVisible()) {
            // Fix for RT-11873. If this isn't here, we can have a situation where
            // the scrollbar scrolls endlessly. This is possible when the cell
            // count grows as the user hits the maximal position on the scrollbar
            // (i.e. the list size dynamically grows as the user needs more).
            //
            // This code was commented out to resolve RT-14477 after testing
            // whether RT-11873 can be recreated. It could not, and therefore
            // for now this code will remained uncommented until it is deleted
            // following further testing.
//            if (lengthBar.getValue() == 1.0 &amp;&amp; lastCellCount != cellCount) {
//                lengthBar.setValue(0.99);
//            }

            /*
            ** Positioning the ScrollBar
            */
            if (!Properties.IS_TOUCH_SUPPORTED) {
                if (isVertical) {
                    vbar.resizeRelocate(viewportBreadth, 0, vbar.prefWidth(viewportLength), viewportLength);
                } else {
                    hbar.resizeRelocate(0, viewportBreadth, viewportLength, hbar.prefHeight(-1));
                }
            }
            else {
                if (isVertical) {
                    vbar.resizeRelocate((viewportBreadth-vbar.getWidth()), 0, vbar.prefWidth(viewportLength), viewportLength);
                } else {
                    hbar.resizeRelocate(0, (viewportBreadth-hbar.getHeight()), viewportLength, hbar.prefHeight(-1));
                }
            }
        }

        if (corner.isVisible()) {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                corner.resize(vbar.getWidth(), hbar.getHeight());
                corner.relocate(hbar.getLayoutX() + hbar.getWidth(), vbar.getLayoutY() + vbar.getHeight());
            }
            else {
                corner.resize(vbar.getWidth(), hbar.getHeight());
                corner.relocate(hbar.getLayoutX() + (hbar.getWidth()-vbar.getWidth()), vbar.getLayoutY() + (vbar.getHeight()-hbar.getHeight()));
                hbar.resize(hbar.getWidth()-vbar.getWidth(), hbar.getHeight());
                vbar.resize(vbar.getWidth(), vbar.getHeight()-hbar.getHeight());
            }
        }

        clipView.resize(snapSizeX(isVertical ? viewportBreadth : viewportLength),
                        snapSizeY(isVertical ? viewportLength : viewportBreadth));

        // If the viewportLength becomes large enough that all cells fit
        // within the viewport, then we want to update the value to match.
        if (getPosition() != lengthBar.getValue()) {
            lengthBar.setValue(getPosition());
        }
    }

    /**
     * Adjusts the cells location and size if necessary. The breadths of all
     * cells will be adjusted to fit the viewportWidth or maxPrefBreadth, and
     * the layout position will be updated if necessary based on index and
     * offset.
     */
    private void fitCells() {
        double size = Math.max(getMaxPrefBreadth(), getViewportBreadth());
        boolean isVertical = isVertical();

        // Note: Do not optimise this loop by pre-calculating the cells size and
        // storing that into a int value - this can lead to RT-32828
        for (int i = 0; i &lt; cells.size(); i++) {
            Cell&lt;?&gt; cell = cells.get(i);
            if (isVertical) {
                cell.resize(size, cell.prefHeight(size));
            } else {
                cell.resize(cell.prefWidth(size), size);
            }
        }
    }

    private void cull() {
        final double viewportLength = getViewportLength();
        for (int i = cells.size() - 1; i &gt;= 0; i--) {
            T cell = cells.get(i);
            double cellSize = getCellLength(cell);
            double cellStart = getCellPosition(cell);
            double cellEnd = cellStart + cellSize;
            if (cellStart &gt;= viewportLength || cellEnd &lt; 0) {
                addToPile(cells.remove(i));
            }
        }
    }

    /**
     * After using the accum cell, it needs to be released!
     */
    private void releaseCell(T cell) {
        if (accumCell != null &amp;&amp; cell == accumCell) {
            accumCell.updateIndex(-1);
        }
    }

    /**
     * This method is an experts-only method - if the requested index is not
     * already an existing visible cell, it will create a cell for the
     * given index and insert it into the sheet. From that point on it will be
     * unmanaged, and is up to the caller of this method to manage it.
     */
    T getPrivateCell(int index)  {
        T cell = null;

        // If there are cells, then we will attempt to get an existing cell
        if (! cells.isEmpty()) {
            // First check the cells that have already been created and are
            // in use. If this call returns a value, then we can use it
            cell = getVisibleCell(index);
            if (cell != null) {
                // Force the underlying text inside the cell to be updated
                // so that when the screen reader runs, it will match the
                // text in the cell (force updateDisplayedText())
                cell.layout();
                return cell;
            }
        }

        // check the existing sheet children
        if (cell == null) {
            for (int i = 0; i &lt; sheetChildren.size(); i++) {
                T _cell = (T) sheetChildren.get(i);
                if (getCellIndex(_cell) == index) {
                    return _cell;
                }
            }
        }

        Callback&lt;VirtualFlow&lt;T&gt;, T&gt; cellFactory = getCellFactory();
        if (cellFactory != null) {
            cell = cellFactory.call(this);
        }

        if (cell != null) {
            setCellIndex(cell, index);
            resizeCellSize(cell);
            cell.setVisible(false);
            sheetChildren.add(cell);
            privateCells.add(cell);
        }

        return cell;
    }

    private final List&lt;T&gt; privateCells = new ArrayList&lt;&gt;();

    private void releaseAllPrivateCells() {
        sheetChildren.removeAll(privateCells);
        privateCells.clear();
    }

    /**
     * Puts the given cell onto the pile. This is called whenever a cell has
     * fallen off the flow's start.
     */
    private void addToPile(T cell) {
        assert cell != null;
        pile.addLast(cell);
    }

    private void cleanPile() {
        boolean wasFocusOwner = false;

        for (int i = 0, max = pile.size(); i &lt; max; i++) {
            T cell = pile.get(i);
            wasFocusOwner = wasFocusOwner || doesCellContainFocus(cell);
            cell.setVisible(false);
        }

        // Fix for RT-35876: Rather than have the cells do weird things with
        // focus (in particular, have focus jump between cells), we return focus
        // to the VirtualFlow itself.
        if (wasFocusOwner) {
            requestFocus();
        }
    }

    private boolean doesCellContainFocus(Cell&lt;?&gt; c) {
        Scene scene = c.getScene();
        final Node focusOwner = scene == null ? null : scene.getFocusOwner();

        if (focusOwner != null) {
            if (c.equals(focusOwner)) {
                return true;
            }

            Parent p = focusOwner.getParent();
            while (p != null &amp;&amp; ! (p instanceof VirtualFlow)) {
                if (c.equals(p)) {
                    return true;
                }
                p = p.getParent();
            }
        }

        return false;
    }

    private double getPrefBreadth(double oppDimension) {
        double max = getMaxCellWidth(10);

        // This primarily exists for the case where we do not want the breadth
        // to grow to ensure a golden ratio between width and height (for example,
        // when a ListView is used in a ComboBox - the width should not grow
        // just because items are being added to the ListView)
        if (oppDimension &gt; -1) {
            double prefLength = getPrefLength();
            max = Math.max(max, prefLength * GOLDEN_RATIO_MULTIPLIER);
        }

        return max;
    }

    private double getPrefLength() {
        double sum = 0.0;
        int rows = Math.min(10, getCellCount());
        for (int i = 0; i &lt; rows; i++) {
            sum += getCellLength(i);
        }
        return sum;
    }

    double getMaxCellWidth(int rowsToCount) {
        double max = 0.0;

        // we always measure at least one row
        int rows = Math.max(1, rowsToCount == -1 ? getCellCount() : rowsToCount);
        for (int i = 0; i &lt; rows; i++) {
            max = Math.max(max, getCellBreadth(i));
        }
        return max;
    }

    // Old PositionMapper
    /**
     * Given a position value between 0 and 1, compute and return the viewport
     * offset from the &quot;current&quot; cell associated with that position value.
     * That is, if the return value of this function where used as a translation
     * factor for a sheet that contained all the items, then the current
     * item would end up positioned correctly.
     */
    private double computeViewportOffset(double position) {
        double p = com.sun.javafx.util.Utils.clamp(0, position, 1);
        double fractionalPosition = p * getCellCount();
        int cellIndex = (int) fractionalPosition;
        double fraction = fractionalPosition - cellIndex;
        double cellSize = getCellLength(cellIndex);
        double pixelOffset = cellSize * fraction;
        double viewportOffset = getViewportLength() * p;
        return pixelOffset - viewportOffset;
    }

    private void adjustPositionToIndex(int index) {
        int cellCount = getCellCount();
        if (cellCount &lt;= 0) {
            setPosition(0.0f);
        } else {
            setPosition(((double)index) / cellCount);
        }
    }

    /**
     * Adjust the position based on a delta of pixels. If negative, then the
     * position will be adjusted negatively. If positive, then the position will
     * be adjusted positively. If the pixel amount is too great for the range of
     * the position, then it will be clamped such that position is always
     * strictly between 0 and 1
     */
    private void adjustByPixelAmount(double numPixels) {
        if (numPixels == 0) return;
        // Starting from the current cell, we move in the direction indicated
        // by numPixels one cell at a team. For each cell, we discover how many
        // pixels the &quot;position&quot; line would move within that cell, and adjust
        // our count of numPixels accordingly. When we come to the &quot;final&quot; cell,
        // then we can take the remaining number of pixels and multiply it by
        // the &quot;travel rate&quot; of &quot;p&quot; within that cell to get the delta. Add
        // the delta to &quot;p&quot; to get position.

        // get some basic info about the list and the current cell
        boolean forward = numPixels &gt; 0;
        int cellCount = getCellCount();
        double fractionalPosition = getPosition() * cellCount;
        int cellIndex = (int) fractionalPosition;
        if (forward &amp;&amp; cellIndex == cellCount) return;
        double cellSize = getCellLength(cellIndex);
        double fraction = fractionalPosition - cellIndex;
        double pixelOffset = cellSize * fraction;

        // compute the percentage of &quot;position&quot; that represents each cell
        double cellPercent = 1.0 / cellCount;

        // To help simplify the algorithm, we pretend as though the current
        // position is at the beginning of the current cell. This reduces some
        // of the corner cases and provides a simpler algorithm without adding
        // any overhead to performance.
        double start = computeOffsetForCell(cellIndex);
        double end = cellSize + computeOffsetForCell(cellIndex + 1);

        // We need to discover the distance that the fictional &quot;position line&quot;
        // would travel within this cell, from its current position to the end.
        double remaining = end - start;

        // Keep track of the number of pixels left to travel
        double n = forward ?
              numPixels + pixelOffset - (getViewportLength() * getPosition()) - start
            : -numPixels + end - (pixelOffset - (getViewportLength() * getPosition()));

        // &quot;p&quot; represents the most recent value for position. This is always
        // based on the edge between two cells, except at the very end of the
        // algorithm where it is added to the computed &quot;p&quot; offset for the final
        // value of Position.
        double p = cellPercent * cellIndex;

        // Loop over the cells one at a time until either we reach the end of
        // the cells, or we find that the &quot;n&quot; will fall within the cell we're on
        while (n &gt; remaining &amp;&amp; ((forward &amp;&amp; cellIndex &lt; cellCount - 1) || (! forward &amp;&amp; cellIndex &gt; 0))) {
            if (forward) cellIndex++; else cellIndex--;
            n -= remaining;
            cellSize = getCellLength(cellIndex);
            start = computeOffsetForCell(cellIndex);
            end = cellSize + computeOffsetForCell(cellIndex + 1);
            remaining = end - start;
            p = cellPercent * cellIndex;
        }

        // if remaining is &lt; n, then we must have hit an end, so as a
        // fast path, we can just set position to 1.0 or 0.0 and return
        // because we know we hit the end
        if (n &gt; remaining) {
            setPosition(forward ? 1.0f : 0.0f);
        } else if (forward) {
            double rate = cellPercent / Math.abs(end - start);
            setPosition(p + (rate * n));
        } else {
            double rate = cellPercent / Math.abs(end - start);
            setPosition((p + cellPercent) - (rate * n));
        }
    }

    private int computeCurrentIndex() {
        return (int) (getPosition() * getCellCount());
    }

    /**
     * Given an item index, this function will compute and return the viewport
     * offset from the beginning of the specified item. Notice that because each
     * item has the same percentage of the position dedicated to it, and since
     * we are measuring from the start of each item, this is a very simple
     * calculation.
     */
    private double computeOffsetForCell(int itemIndex) {
        double cellCount = getCellCount();
        double p = com.sun.javafx.util.Utils.clamp(0, itemIndex, cellCount) / cellCount;
        return -(getViewportLength() * p);
    }

//    /**
//     * Adjust the position based on a chunk of pixels. The position is based
//     * on the start of the scrollbar position.
//     */
//    private void adjustByPixelChunk(double numPixels) {
//        setPosition(0);
//        adjustByPixelAmount(numPixels);
//    }
    // end of old PositionMapper code




    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**
     * A simple extension to Region that ensures that anything wanting to flow
     * outside of the bounds of the Region is clipped.
     */
    static class ClippedContainer extends Region {

        /**
         * The Node which is embedded within this {@code ClipView}.
         */
        private Node node;
        public Node getNode() { return this.node; }
        public void setNode(Node n) {
            this.node = n;

            getChildren().clear();
            getChildren().add(node);
        }

        public void setClipX(double clipX) {
            setLayoutX(-clipX);
            clipRect.setLayoutX(clipX);
        }

        public void setClipY(double clipY) {
            setLayoutY(-clipY);
            clipRect.setLayoutY(clipY);
        }

        private final Rectangle clipRect;

        public ClippedContainer(final VirtualFlow&lt;?&gt; flow) {
            if (flow == null) {
                throw new IllegalArgumentException(&quot;VirtualFlow can not be null&quot;);
            }

            getStyleClass().add(&quot;clipped-container&quot;);

            // clipping
            clipRect = new Rectangle();
            clipRect.setSmooth(false);
            setClip(clipRect);
            // --- clipping

            super.widthProperty().addListener(valueModel -&gt; {
                clipRect.setWidth(getWidth());
            });
            super.heightProperty().addListener(valueModel -&gt; {
                clipRect.setHeight(getHeight());
            });
        }
    }

    /**
     * A List-like implementation that is exceedingly efficient for the purposes
     * of the VirtualFlow. Typically there is not much variance in the number of
     * cells -- it is always some reasonably consistent number. Yet for efficiency
     * in code, we like to use a linked list implementation so as to append to
     * start or append to end. However, at times when we need to iterate, LinkedList
     * is expensive computationally as well as requiring the construction of
     * temporary iterators.
     * &lt;p&gt;
     * This linked list like implementation is done using an array. It begins by
     * putting the first item in the center of the allocated array, and then grows
     * outward (either towards the first or last of the array depending on whether
     * we are inserting at the head or tail). It maintains an index to the start
     * and end of the array, so that it can efficiently expose iteration.
     * &lt;p&gt;
     * This class is package private solely for the sake of testing.
     */
    static class ArrayLinkedList&lt;T&gt; extends AbstractList&lt;T&gt; {
        /**
         * The array list backing this class. We default the size of the array
         * list to be fairly large so as not to require resizing during normal
         * use, and since that many ArrayLinkedLists won't be created it isn't
         * very painful to do so.
         */
        private final ArrayList&lt;T&gt; array;

        private int firstIndex = -1;
        private int lastIndex = -1;

        public ArrayLinkedList() {
            array = new ArrayList&lt;T&gt;(50);

            for (int i = 0; i &lt; 50; i++) {
                array.add(null);
            }
        }

        public T getFirst() {
            return firstIndex == -1 ? null : array.get(firstIndex);
        }

        public T getLast() {
            return lastIndex == -1 ? null : array.get(lastIndex);
        }

        public void addFirst(T cell) {
            // if firstIndex == -1 then that means this is the first item in the
            // list and we need to initialize firstIndex and lastIndex
            if (firstIndex == -1) {
                firstIndex = lastIndex = array.size() / 2;
                array.set(firstIndex, cell);
            } else if (firstIndex == 0) {
                // we're already at the head of the array, so insert at position
                // 0 and then increment the lastIndex to compensate
                array.add(0, cell);
                lastIndex++;
            } else {
                // we're not yet at the head of the array, so insert at the
                // firstIndex - 1 position and decrement first position
                array.set(--firstIndex, cell);
            }
        }

        public void addLast(T cell) {
            // if lastIndex == -1 then that means this is the first item in the
            // list and we need to initialize the firstIndex and lastIndex
            if (firstIndex == -1) {
                firstIndex = lastIndex = array.size() / 2;
                array.set(lastIndex, cell);
            } else if (lastIndex == array.size() - 1) {
                // we're at the end of the array so need to &quot;add&quot; so as to force
                // the array to be expanded in size
                array.add(++lastIndex, cell);
            } else {
                array.set(++lastIndex, cell);
            }
        }

        public int size() {
            return firstIndex == -1 ? 0 : lastIndex - firstIndex + 1;
        }

        public boolean isEmpty() {
            return firstIndex == -1;
        }

        public T get(int index) {
            if (index &gt; (lastIndex - firstIndex) || index &lt; 0) {
                // Commented out exception due to RT-29111
                // throw new java.lang.ArrayIndexOutOfBoundsException();
                return null;
            }

            return array.get(firstIndex + index);
        }

        public void clear() {
            for (int i = 0; i &lt; array.size(); i++) {
                array.set(i, null);
            }

            firstIndex = lastIndex = -1;
        }

        public T removeFirst() {
            if (isEmpty()) return null;
            return remove(0);
        }

        public T removeLast() {
            if (isEmpty()) return null;
            return remove(lastIndex - firstIndex);
        }

        public T remove(int index) {
            if (index &gt; lastIndex - firstIndex || index &lt; 0) {
                throw new ArrayIndexOutOfBoundsException();
            }

            // if the index == 0, then we're removing the first
            // item and can simply set it to null in the array and increment
            // the firstIndex unless there is only one item, in which case
            // we have to also set first &amp; last index to -1.
            if (index == 0) {
                T cell = array.get(firstIndex);
                array.set(firstIndex, null);
                if (firstIndex == lastIndex) {
                    firstIndex = lastIndex = -1;
                } else {
                    firstIndex++;
                }
                return cell;
            } else if (index == lastIndex - firstIndex) {
                // if the index == lastIndex - firstIndex, then we're removing the
                // last item and can simply set it to null in the array and
                // decrement the lastIndex
                T cell = array.get(lastIndex);
                array.set(lastIndex--, null);
                return cell;
            } else {
                // if the index is somewhere in between, then we have to remove the
                // item and decrement the lastIndex
                T cell = array.get(firstIndex + index);
                array.set(firstIndex + index, null);
                for (int i = (firstIndex + index + 1); i &lt;= lastIndex; i++) {
                    array.set(i - 1, array.get(i));
                }
                array.set(lastIndex--, null);
                return cell;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/builder/JavaFXFontBuilder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.fxml.builder;

import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.AbstractMap;
import java.util.Set;
import java.util.StringTokenizer;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.util.Builder;

/**
 * JavaFX font builder.
 */
public final class JavaFXFontBuilder extends AbstractMap&lt;String, Object&gt; implements Builder&lt;Font&gt; {
    private String      name = null;
    private double      size = 12D;
    private FontWeight  weight = null;
    private FontPosture posture = null;
    private URL         url     = null;

    @Override
    public Font build() {
        Font f;
        if ( url != null) {
            //TODO Implement some font name caching so that the font
            // is not constructed from the stream every time
            InputStream in = null;
            try {
                in = url.openStream();
                f = Font.loadFont(in, size);
<A NAME="60"></A>            } catch( Exception e) {
                //TODO
                throw new RuntimeException( &quot;Load of font file failed from &quot; + url, e);
            } finally <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#60',2,'match42-top.html#60',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                try {
                    if ( in != null) {
                        in.close();
                    }
                } catch( Exception e) {
                    //TODO
                    e.printStackTrace();
                }</B></FONT>
            }
        } else {
            if (weight == null &amp;&amp; posture == null) {
                f = new Font(name, size);
            } else {
                if (weight == null) weight = FontWeight.NORMAL;
                if (posture == null) posture = FontPosture.REGULAR;
                f = Font.font(name, weight, posture, size);
            }
        }
        return f;
    }

    @Override
    public Object put(String key, Object value) {
        if ( &quot;name&quot;.equals( key)) {
            if ( value instanceof URL) {
                url = (URL) value;
            } else {
                name = (String) value;
            }
        } else if ( &quot;size&quot;.equals(key)) {
            size =  Double.parseDouble((String) value);
        } else if ( &quot;style&quot;.equals(key)) {
            String style = (String) value;
            if ( style != null &amp;&amp; style.length() &gt; 0) {
                boolean isWeightSet = false;
                for( StringTokenizer st = new StringTokenizer( style, &quot; &quot;); st.hasMoreTokens(); ) {
                    String stylePart = st.nextToken();
                    FontWeight fw;
                    if ( !isWeightSet &amp;&amp; (fw=FontWeight.findByName(stylePart)) != null) {
                        weight = fw;
                        isWeightSet = true;
                        continue;
                    }
                    FontPosture fp;
                    if ( (fp=FontPosture.findByName(stylePart)) != null) {
                        posture = fp;
                        continue;
                    }
                }
            }
        } else if ( &quot;url&quot;.equals(key)) {
            if ( value instanceof URL) {
                url = (URL) value;
            } else {
                try {
                    url = new URL( value.toString());
                } catch( MalformedURLException e) {
                    //TODO Better exception
                    throw new IllegalArgumentException(&quot;Invalid url &quot; + value.toString(), e);
                }
            }
        } else {
            throw new IllegalArgumentException(&quot;Unknown Font property: &quot; + key);
        }
        return null;
    }

    @Override
    public boolean containsKey(Object key) {
        return false; // False in this context means that the property is NOT read only
    }

    @Override
    public Object get(Object key) {
        return null; // In certain cases, get is also required to return null for read-write &quot;properties&quot;
    }

    @Override
    public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
        throw new UnsupportedOperationException();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Cursor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.lang.annotation.Native;

public abstract class Cursor {

    @Native public final static int CURSOR_NONE = -1;
    @Native public final static int CURSOR_CUSTOM = 0;
    @Native public final static int CURSOR_DEFAULT = 1;
    @Native public final static int CURSOR_TEXT = 2;
    @Native public final static int CURSOR_CROSSHAIR = 3;
    @Native public final static int CURSOR_CLOSED_HAND = 4;
    @Native public final static int CURSOR_OPEN_HAND = 5;
    @Native public final static int CURSOR_POINTING_HAND = 6;
    @Native public final static int CURSOR_RESIZE_LEFT = 7;
    @Native public final static int CURSOR_RESIZE_RIGHT = 8;
    @Native public final static int CURSOR_RESIZE_UP = 9;
    @Native public final static int CURSOR_RESIZE_DOWN = 10;
    @Native public final static int CURSOR_RESIZE_LEFTRIGHT = 11;
    @Native public final static int CURSOR_RESIZE_UPDOWN = 12;
<A NAME="42"></A>    @Native public final static int CURSOR_DISAPPEAR = 13;
    @Native public final static int CURSOR_WAIT = 14;
    @Native public final static int CURSOR_RESIZE_SOUTHWEST = 15;
    <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#42',2,'match42-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native public final static int CURSOR_RESIZE_SOUTHEAST = 16;
    @Native public final static int CURSOR_RESIZE_NORTHWEST = 17;
    @Native public final static int CURSOR_RESIZE_NORTHEAST = 18;
    @Native public final static int CURSOR_MOVE = 19;
    private final static int CURSOR_MAX = 19;

    private final int type;

    // Native cursor ptr, for custom cursors
    private long ptr</B></FONT>;

    protected Cursor(final int type) {
        Application.checkEventThread();
        this.type = type;
    }

    protected Cursor(final int x, final int y, final Pixels pixels) {
        this(CURSOR_CUSTOM);
        ptr = _createCursor(x, y, pixels);
    }

    public final int getType() {
        Application.checkEventThread();
        return type;
    }

    protected final long getNativeCursor() {
        Application.checkEventThread();
        return ptr;
    }

    /**
     * Shows or hides the cursor.
     * &lt;p&gt;
     * If the cursor is currently hidden with a previous call to {@code
     * setVisible(false)}, setting a new cursor shape (e.g. by means of calling
     * {@code Window.setCursor()}) does not automatically display the cursor on
     * the screen until the client code calls {@code setVisible(true)} to show
     * the cursor again.
     * &lt;p&gt;
     * If the mouse cursor is located over a non-Glass window at the time of
     * calling this method, the call may or may not affect the native cursor's
     * visibility. This behavior is platform-dependent.
     * &lt;p&gt;
     * When the mouse pointer is moved over a non-Glass window, depending on
     * the native platform behavior, the cursor may or may not become visible
     * on the screen, even if it was previously hidden by calling {@code
     * setVisible(false)}. After this occurs, on some platforms the cursor may
     * even remain visible permanently. For example, Mac OS X makes the cursor
     * visible unconditionally when the mouse is moved over the Dock or Menu
     * Bar areas. There's no way to detect that the native cursor became
     * visible, however, from Glass perspective it is still considered hidden,
     * and thus, when the mouse cursor is needed again, the app should call
     * {@code setVisible(true)} in order to continue to operate properly.
     * &lt;p&gt;
     * Calling this method multiple times with the same argument may not have
     * any effect. For example, if the cursor was hidden and the native OS
     * restored its visibility, calling {@code setVisible(false)} again may not
     * hide the cursor. If the app needs to ultimately hide the cursor, it
     * should first show the cursor again, and then proceed with hiding it.
     */
    public static void setVisible(boolean visible) {
        Application.checkEventThread();
        Application.GetApplication().staticCursor_setVisible(visible);
    }

    /**
     * Returns the 'best' cursor size based on the given preferred size.
     */
    public static Size getBestSize(int width, int height) {
        Application.checkEventThread();
        return Application.GetApplication().staticCursor_getBestSize(width, height);
    }

    protected abstract long _createCursor(int x, int y, Pixels pixels);
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/GlassRobot.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
<A NAME="33"></A> * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#33',2,'match42-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.glass.ui;

import java.lang.annotation.Native;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Objects;

import javafx.scene.image.Image;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.stage.Screen;

import com.sun.javafx.image.PixelUtils;

public abstract class GlassRobot {

    @Native public static final int MOUSE_LEFT_BTN    = 1 &lt;&lt; 0;
    @Native public static final int MOUSE_RIGHT_BTN   = 1 &lt;&lt; 1;
    @</B></FONT>Native public static final int MOUSE_MIDDLE_BTN  = 1 &lt;&lt; 2;

    /**
     * Initializes any state necessary for this {@code Robot}. Called by
     * the {@code Robot} constructor.
     */
    public abstract void create();

    /**
     * Frees any resources allocated by this {@code Robot}.
     */
    public abstract void destroy();

    /**
     * Presses the specified {@link KeyCode} key.
     *
     * @param keyCode the key to press
     */
    public abstract void keyPress(KeyCode keyCode);

    /**
     * Releases the specified {@link KeyCode} key.
     *
     * @param keyCode the key to release
     */
    public abstract void keyRelease(KeyCode keyCode);

    /**
     * Returns the current mouse x-position.
     *
     * @return the current mouse x-position
     */
    public abstract double getMouseX();

    /**
     * Returns the current mouse y-position.
     *
     * @return the current mouse y-position
     */
    public abstract double getMouseY();

    /**
     * Moves the mouse to the specified (x,y) screen coordinates relative to
     * the primary screen.
     *
     * @param x screen coordinate x to move the mouse to
     * @param y screen coordinate y to move the mouse to
     */
    public abstract void mouseMove(double x, double y);

    /**
     * Presses the specified {@link MouseButton}s.
     *
     * @param buttons the mouse buttons to press
     */
    public abstract void mousePress(MouseButton... buttons);

    /**
     * Releases the specified {@link MouseButton}s.
     *
     * @param buttons the mouse buttons to release
     */
    public abstract void mouseRelease(MouseButton... buttons);

    /**
     * Scrolls the mouse wheel by the specified amount of wheel clicks. A positive
     * {@code wheelAmt} scrolls the wheel towards the user (down) whereas negative
     * amounts scrolls the wheel away from the user (up).
     *
     * @param wheelAmt the (signed) amount of clicks to scroll the wheel
     */
    public abstract void mouseWheel(int wheelAmt);

    /**
     * Returns the {@link Color} of the pixel at the screen coordinates relative to the
     * primary screen specified by {@code location}. Regardless of the scale of the screen
     * ({@link Screen#getOutputScaleX()}, {@link Screen#getOutputScaleY()}), this method only
     * samples a single pixel. For example, on a HiDPI screen with output scale 2, the screen
     * unit at the point (x,y) may have 4 pixels. In this case the color returned is the color
     * of the top, left pixel. Color values are &lt;em&gt;not&lt;/em&gt; averaged when a screen unit is
     * made up of more than one pixel.
     *
     * @param x the x coordinate to get the pixel color from
     * @param y the y coordinate to get the pixel color from
     * @return the pixel color at the specified screen coordinates
     */
    public abstract Color getPixelColor(double x, double y);

    /**
     * Captures the specified rectangular area of the screen and uses it to fill the given
     * {@code data} array with the raw pixel data. The data is in RGBA format where each
     * pixel in the image is encoded as 4 bytes - one for each color component of each
     * pixel. If this method is not overridden by subclasses then
     * {@link #getScreenCapture(WritableImage, double, double, double, double, boolean)}
     * must be overridden to not call this method.
     *
     * @param x the starting x-position of the rectangular area to capture
     * @param y the starting y-position of the rectangular area to capture
     * @param width the width of the rectangular area to capture
     * @param height the height of the rectangular area to capture
     * @param data the array to fill with the raw pixel data corresponding to
     * the captured region
     * @param scaleToFit If {@literal true} the returned {@code Image} will be
     * scaled to fit the request dimensions, if necessary. Otherwise the size
     * of the returned image will depend on the output scale (DPI) of the primary
     * screen.
     */
    public void getScreenCapture(int x, int y, int width, int height, int[] data, boolean scaleToFit) {
        throw new InternalError(&quot;not implemented&quot;);
    }

    /**
     * Returns an {@code Image} containing the specified rectangular area of the screen.
     * &lt;p&gt;
     * If the {@code scaleToFit} argument is {@literal false}, the returned
     * {@code Image} object dimensions may differ from the requested {@code width}
     * and {@code height} depending on how many physical pixels the area occupies
     * on the screen. E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
     * are doubled, and thus a screen capture of an area of size (10x10) pixels
     * will result in an {@code Image} with dimensions (20x20). Calling code should
     * use the returned images's {@link Image#getWidth() and {@link Image#getHeight()
     * methods to determine the actual image size.
     * &lt;p&gt;
     * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
     * the requested size. Note that in this case the image will be scaled in
     * order to fit to the requested dimensions if necessary such as when running
     * on a HiDPI display.
     *
     * @param x the starting x-position of the rectangular area to capture
     * @param y the starting y-position of the rectangular area to capture
     * @param width the width of the rectangular area to capture
     * @param height the height of the rectangular area to capture
     * @param scaleToFit If {@literal true} the returned {@code Image} will be
     * scaled to fit the request dimensions, if necessary. Otherwise the size
     * of the returned image will depend on the output scale (DPI) of the primary
     * screen.
     */
    public WritableImage getScreenCapture(WritableImage image, double x, double y, double width,
                                          double height, boolean scaleToFit) {
        if (width &lt;= 0) {
            throw new IllegalArgumentException(&quot;width must be &gt; 0&quot;);
        }
        if (height &lt;= 0) {
            throw new IllegalArgumentException(&quot;height must be &gt; 0&quot;);
        }
        Screen primaryScreen = Screen.getPrimary();
        Objects.requireNonNull(primaryScreen);
        double outputScaleX = primaryScreen.getOutputScaleX();
        double outputScaleY = primaryScreen.getOutputScaleY();
        int data[];
        int dw, dh;
        if (outputScaleX == 1.0f &amp;&amp; outputScaleY == 1.0f) {
            // No scaling will be necessary regardless of if &quot;scaleToFit&quot; is set or not.
            data = new int[(int) (width * height)];
            getScreenCapture((int) x, (int) y, (int) width, (int) height, data, scaleToFit);
            dw = (int) width;
            dh = (int) height;
        } else {
            // Compute the absolute pixel bounds that the requested size will fill given
            // the display's scale.
            int pminx = (int) Math.floor(x * outputScaleX);
            int pminy = (int) Math.floor(y * outputScaleY);
            int pmaxx = (int) Math.ceil((x + width) * outputScaleX);
            int pmaxy = (int) Math.ceil((y + height) * outputScaleY);
            int pwidth = pmaxx - pminx;
            int pheight = pmaxy - pminy;
            int tmpdata[] = new int[pwidth * pheight];
            getScreenCapture(pminx, pminy, pwidth, pheight, tmpdata, scaleToFit);
            dw = pwidth;
            dh = pheight;
            if (!scaleToFit) {
                data = tmpdata;
            } else {
                // We must resize the image to fit the requested bounds. This means
                // resizing the pixel data array which we accomplish using bilinear (?)
                // interpolation.
                data = new int[(int) (width * height)];
                int index = 0;
                for (int iy = 0; iy &lt; height; iy++) {
                    double rely = ((y + iy + 0.5f) * outputScaleY) - (pminy + 0.5f);
                    int irely = (int) Math.floor(rely);
                    int fracty = (int) ((rely - irely) * 256);
                    for (int ix = 0; ix &lt; width; ix++) {
                        double relx = ((x + ix + 0.5f) * outputScaleX) - (pminx + 0.5f);
                        int irelx = (int) Math.floor(relx);
                        int fractx = (int) ((relx - irelx) * 256);
                        data[index++] = interp(tmpdata, irelx, irely, pwidth, pheight, fractx, fracty);
                    }
                }
                dw = (int) width;
                dh = (int) height;
            }
        }

        return convertFromPixels(image, Application.GetApplication().createPixels(dw, dh, IntBuffer.wrap(data)));
    }

    public static int convertToRobotMouseButton(MouseButton[] buttons) {
        int ret = 0;
        for (MouseButton button : buttons) {
            switch (button) {
                case PRIMARY: ret |= MOUSE_LEFT_BTN; break;
                case SECONDARY: ret |= MOUSE_RIGHT_BTN; break;
                case MIDDLE: ret |= MOUSE_MIDDLE_BTN; break;
                default: throw new IllegalArgumentException(&quot;MouseButton: &quot; + button + &quot; not supported by Robot&quot;);
            }
        }
        return ret;
    }

    public static Color convertFromIntArgb(int color) {
        int alpha = (color &gt;&gt; 24) &amp; 0xFF;
        int red   = (color &gt;&gt; 16) &amp; 0xFF;
        int green = (color &gt;&gt;  8) &amp; 0xFF;
        int blue  =  color        &amp; 0xFF;
        return new Color(red / 255d, green / 255d, blue / 255d, alpha / 255d);
    }

    protected static WritableImage convertFromPixels(WritableImage image, Pixels pixels) {
        Objects.requireNonNull(pixels);
        int width = pixels.getWidth();
        int height = pixels.getHeight();
        if (image == null || image.getWidth() != width || image.getHeight() != height) {
            image = new WritableImage(width, height);
        }

        int bytesPerComponent = pixels.getBytesPerComponent();
        if (bytesPerComponent == 4) {
            IntBuffer intBuffer = (IntBuffer) pixels.getPixels();
            writeIntBufferToImage(intBuffer, image);
        } else if (bytesPerComponent == 1) {
            ByteBuffer byteBuffer = (ByteBuffer) pixels.getPixels();
            writeByteBufferToImage(byteBuffer, image);
        } else {
            throw new IllegalArgumentException(&quot;bytesPerComponent must be either 4 or 1 but was: &quot; +
                    bytesPerComponent);
        }

        return image;
    }

    private static void writeIntBufferToImage(IntBuffer intBuffer, WritableImage image) {
        Objects.requireNonNull(image);
        PixelWriter pixelWriter = image.getPixelWriter();
        double width = image.getWidth();
        double height = image.getHeight();

        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                int argb = intBuffer.get();
                pixelWriter.setArgb(x, y, argb);
            }
        }
    }

    private static void writeByteBufferToImage(ByteBuffer byteBuffer, WritableImage image) {
        Objects.requireNonNull(image);
        PixelWriter pixelWriter = image.getPixelWriter();
        double width = image.getWidth();
        double height = image.getHeight();

        int format = Pixels.getNativeFormat();

        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                if (format == Pixels.Format.BYTE_BGRA_PRE) {
                    pixelWriter.setArgb(x, y, PixelUtils.PretoNonPre(bgraPreToRgbaPre(byteBuffer.getInt())));
                } else if (format == Pixels.Format.BYTE_ARGB) {
                    pixelWriter.setArgb(x, y, byteBuffer.getInt());
                } else {
                    throw new IllegalArgumentException(&quot;format must be either BYTE_BGRA_PRE or BYTE_ARGB&quot;);
                }
            }
        }
    }

    private static int bgraPreToRgbaPre(int bgraPre) {
        return Integer.reverseBytes(bgraPre);
    }

    private static int interp(int pixels[], int x, int y, int w, int h, int fractx1, int fracty1) {
        int fractx0 = 256 - fractx1;
        int fracty0 = 256 - fracty1;
        int i = y * w + x;
        int rgb00 = (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h) ? 0 : pixels[i];
        if (fracty1 == 0) {
            // No interpolation with pixels[y+1]
            if (fractx1 == 0) {
                // No interpolation with any neighbors
                return rgb00;
            }
            int rgb10 = (y &lt; 0 || x+1 &gt;= w || y &gt;= h) ? 0 : pixels[i+1];
            return interp(rgb00, rgb10, fractx0, fractx1);
        } else if (fractx1 == 0) {
            // No interpolation with pixels[x+1]
            int rgb01 = (x &lt; 0 || x &gt;= w || y+1 &gt;= h) ? 0 : pixels[i+w];
            return interp(rgb00, rgb01, fracty0, fracty1);
        } else {
            // All 4 neighbors must be interpolated
            int rgb10 = (y &lt; 0 || x+1 &gt;= w || y &gt;= h) ? 0 : pixels[i+1];
            int rgb01 = (x &lt; 0 || x &gt;= w || y+1 &gt;= h) ? 0 : pixels[i+w];
            int rgb11 = (x+1 &gt;= w || y+1 &gt;= h) ? 0 : pixels[i+w+1];
            return interp(interp(rgb00, rgb10, fractx0, fractx1),
                    interp(rgb01, rgb11, fractx0, fractx1),
                    fracty0, fracty1);
        }
    }

    private static int interp(int rgb0, int rgb1, int fract0, int fract1) {
        int a0 = (rgb0 &gt;&gt; 24) &amp; 0xff;
        int r0 = (rgb0 &gt;&gt; 16) &amp; 0xff;
        int g0 = (rgb0 &gt;&gt;  8) &amp; 0xff;
        int b0 = (rgb0      ) &amp; 0xff;
        int a1 = (rgb1 &gt;&gt; 24) &amp; 0xff;
        int r1 = (rgb1 &gt;&gt; 16) &amp; 0xff;
        int g1 = (rgb1 &gt;&gt;  8) &amp; 0xff;
        int b1 = (rgb1      ) &amp; 0xff;
        int a = (a0 * fract0 + a1 * fract1) &gt;&gt; 8;
        int r = (r0 * fract0 + r1 * fract1) &gt;&gt; 8;
        int g = (g0 * fract0 + g1 * fract1) &gt;&gt; 8;
        int b = (b0 * fract0 + b1 * fract1) &gt;&gt; 8;
        return (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Window.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.WindowEvent;
import com.sun.prism.impl.PrismSettings;

import java.lang.annotation.Native;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public abstract class Window {

    public static class EventHandler {
        public void handleWindowEvent(Window window, long time, int type) {
        }

        /**
         * Notifies a listener that the screen object for this Window instance
         * has been updated.
         *
         * Note that while the old and new screen objects may be different,
         * they can still represent the same physical screen. This can happen
         * if e.g. only a certain parameter of the screen has been updated such
         * as its scale factor.
         *
         * On some platforms when a window is moved to another physical screen
         * an app can receive this event twice. One representing the physical
         * screen change, and another - the display's parameters change. Note
         * that sending two events instead of just one is platform-specific.
         *
         * The event handler can use the {@link Screen#getNativeScreen} method
         * to determine if this is the same physical screen or not. If the
         * native system always creates new native screen instances, there's no
         * way for the app to distinguish between a real move to another screen
         * or jsut a parameters update event. Since this is a somewhat rare
         * event, an app is advised to always process it the same way.
         *
         * @see Window#getScreen
         */
        public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
        }

        /**
         * Notifies the listener that the window level has changed. The Level should be one of
         * {@link com.sun.glass.ui.Window.Level#NORMAL}, {@link com.sun.glass.ui.Window.Level#FLOATING},
         * {@link com.sun.glass.ui.Window.Level#TOPMOST}.
         * @param level Level from {@link com.sun.glass.ui.Window.Level} class
         */
        public void handleLevelEvent(int level) {
        }
    }

    // Native object handle (HWND, or NSWindow*, etc.)
    private long ptr;

    // 'Delegate window' ptr. Used in e.g. the Full Screen mode.
    private volatile long delegatePtr = 0L;

    // window list
    static private final LinkedList&lt;Window&gt; visibleWindows = new LinkedList&lt;Window&gt;();
     // Return a list of all visible windows.  Note that on platforms without a native window manager,
     // this list will be sorted in proper z-order
    static public synchronized List&lt;Window&gt; getWindows() {
        Application.checkEventThread();
        return Collections.unmodifiableList(Window.visibleWindows);
    }

    static public List&lt;Window&gt; getWindowsClone() {
        Application.checkEventThread();
        return (List&lt;Window&gt;)visibleWindows.clone();
    }

    // used by Lens Native
    static protected void add(Window window) {
        visibleWindows.add(window);
    }

    static protected void addFirst(Window window) {
        visibleWindows.addFirst(window);
    }

    // used by Lens Native
    static protected void remove(Window window) {
        visibleWindows.remove(window);
    }

    // window style mask

    // visual kind: mutually exclusive
    public static final int UNTITLED        = 0;
    public static final int TITLED          = 1 &lt;&lt; 0;
    public static final int TRANSPARENT     = 1 &lt;&lt; 1;

    // functional type: mutually exclusive
    /**
     * Normal window.
     *
     * Usual top-level window.
     */
    public static final int NORMAL          = 0;
    /**
     * An utility window.
     *
     * Often used for floating toolbars. It has smaller than usual decorations
     * and doesn't display a taskbar button.
     */
    @Native public static final int UTILITY         = 1 &lt;&lt; 2;
    /**
     * A popup window.
     *
     * Used to display popups (tooltips, popup menus, etc.) Note that by
     * default it may display a task-bar button. To hide it the window must be
     * owned.
     */
    @Native public static final int POPUP           = 1 &lt;&lt; 3;

    // These affect window decorations as well as system menu actions,
    // so applicable to both decorated and undecorated windows
    @Native public static final int CLOSABLE        = 1 &lt;&lt; 4;
    @Native public static final int MINIMIZABLE     = 1 &lt;&lt; 5;
    @Native public static final int MAXIMIZABLE     = 1 &lt;&lt; 6;

    /**
     * Indicates that the window trim will draw from right to left.
     */
    @Native public static final int RIGHT_TO_LEFT     = 1 &lt;&lt; 7;

    /**
     * Indicates that a window will have a client area textured the same way as the platform decorations
     * and will not have a border between decorations and the client area.
     * This is supported not on all platforms, the client should check if the feature is supported by using
     * {@link com.sun.glass.ui.Application#supportsUnifiedWindows()}
     */
    @Native public static final int UNIFIED = 1 &lt;&lt; 8;

    final static public class State {
        @Native public static final int NORMAL = 1;
        @Native public static final int MINIMIZED = 2;
        @Native public static final int MAXIMIZED = 3;
    }

    /**
     * Available window levels.
     *
     * Note that on some platforms both {@code FLOATING} and {@code TOPMOST}
     * may represent the same window level.
     *
     * @see #setLevel
     */
    public static final class Level {
        @Native private static final int _MIN = 1;

        /** Normal window level. */
        @Native public static final int NORMAL = 1;

        /** A window level that is above all other NORMAL windows. */
        @Native public static final int FLOATING = 2;

        /** A very topmost window level. May cover system UI elements such as dock, taskbar, etc. */
        @Native public static final int TOPMOST = 3;

        @Native private static final int _MAX = 3;
    }

    private final Window owner;
    private final long parent;
    private final int styleMask;
    private final boolean isDecorated;
    private boolean shouldStartUndecoratedMove = false;

    protected View view = null;
    protected Screen screen = null;
    private MenuBar menubar = null;
    private String title = &quot;&quot;;
    private UndecoratedMoveResizeHelper helper = null;

    private int state = State.NORMAL;
    private int level = Level.NORMAL;
    protected int x = 0;
    protected int y = 0;
    protected int width = 0;
    protected int height = 0;
    private float alpha = 1.0f;
    protected float platformScaleX = 1.0f;
    protected float platformScaleY = 1.0f;
    private float outputScaleX = 1.0f;
    private float outputScaleY = 1.0f;
    private float renderScaleX = 1.0f;
    private float renderScaleY = 1.0f;
    private boolean appletMode = false;

    // This is a workaround for RT-15970: as for embedded windows we don't
    // receive any MOVE notifications from the native platform, we poll
    // the window location on screen from timer and post synthetic events
    // if it has changed
    private Timer embeddedLocationTimer = null;
    private int lastKnownEmbeddedX = 0;
    private int lastKnownEmbeddedY = 0;

    private volatile boolean isResizable = false;
    private volatile boolean isVisible = false;
    private volatile boolean isFocused = false;
    private volatile boolean isFocusable = true;
    private volatile boolean isModal = false;

    // Indicates how many times setEnabled(false) has been called.
    // A value of 0 means the window is enabled.
    private volatile int disableCount = 0;

    private int minimumWidth = 0, minimumHeight = 0;
    private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;

    private EventHandler eventHandler;

    protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
    protected Window(Window owner, Screen screen, int styleMask) {
        Application.checkEventThread();
        switch (styleMask &amp; (TITLED | TRANSPARENT)) {
            case UNTITLED:
            case TITLED:
            case TRANSPARENT:
                break;
            default:
                throw new RuntimeException(&quot;The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these&quot;);
        }
        switch (styleMask &amp; (POPUP | UTILITY)) {
            case NORMAL:
            case POPUP:
            case UTILITY:
                break;
            default:
                throw new RuntimeException(&quot;The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these&quot;);
        }

        if (((styleMask &amp; UNIFIED) != 0)
                &amp;&amp; !Application.GetApplication().supportsUnifiedWindows()) {
           styleMask &amp;= ~UNIFIED;
        }

        if (((styleMask &amp; TRANSPARENT) != 0)
                &amp;&amp; !Application.GetApplication().supportsTransparentWindows()) {
            styleMask &amp;= ~TRANSPARENT;
        }


        this.owner = owner;
        this.parent = 0L;
        this.styleMask = styleMask;
        this.isDecorated = (this.styleMask &amp; Window.TITLED) != 0;

        this.screen = screen != null ? screen : Screen.getMainScreen();
        if (PrismSettings.allowHiDPIScaling) {
            this.platformScaleX = this.screen.getPlatformScaleX();
            this.platformScaleY = this.screen.getPlatformScaleY();
            this.outputScaleX = this.screen.getRecommendedOutputScaleX();
            this.outputScaleY = this.screen.getRecommendedOutputScaleY();
        }

        this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L,
                this.screen.getNativeScreen(), this.styleMask);
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform window&quot;);
        }
    }

    protected abstract long _createChildWindow(long parent);
    /**
     * Constructs a child window of the specified native parent window.
     */
    protected Window(long parent) {
        Application.checkEventThread();
        this.owner = null;
        this.parent = parent;
        this.styleMask = Window.UNTITLED;
        this.isDecorated = false;

        // Note: we can't always catch screen changes when parent is moved...
        this.screen = null; // should infer from the parent

        this.ptr = _createChildWindow(parent);
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform window&quot;);
        }

        if (screen == null) {
            screen = Screen.getMainScreen(); // start with a default

            if (PrismSettings.allowHiDPIScaling) {
                this.platformScaleX = this.screen.getPlatformScaleX();
                this.platformScaleY = this.screen.getPlatformScaleY();
                this.outputScaleX = this.screen.getRecommendedOutputScaleX();
                this.outputScaleY = this.screen.getRecommendedOutputScaleY();
            }
        }
    }

    public boolean isClosed() {
        Application.checkEventThread();
        return this.ptr == 0L;
    }

    private void checkNotClosed() {
        if (this.ptr == 0L) {
            throw new IllegalStateException(&quot;The window has already been closed&quot;);
        }
    }

    protected abstract boolean _close(long ptr);
    public void close() {
        Application.checkEventThread();
        if (this.view != null) {
            if (this.ptr != 0L) {
                _setView(this.ptr, null);
            }
            this.view.setWindow(null);
            this.view.close();
            this.view = null;
        }
        if (this.ptr != 0L) {
            _close(this.ptr);
        }
    }

    private boolean isChild() {
        Application.checkEventThread();
        return this.parent != 0L;
    }

    /** This method returns &quot;lowest-level&quot; native window handle
     * (HWND on Windows, NSWindow on Mac, X11 Window handle on linux-gtk etc.)
     */
    public long getNativeWindow() {
        Application.checkEventThread();
        checkNotClosed();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }

    /**
     * This method returns &quot;higher-level&quot; native window handle.
     * glass-mat-lib-gtk GtkWindow.java returns GtkWindow pointer for example.
     */
    public long getNativeHandle() {
        Application.checkEventThread();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }

    /**
     * return the &quot;raw' pointer needed by subclasses to pass to native routines
     * @return the native pointer.
     */
    public long getRawHandle() {
        return ptr;
    }

    public Window getOwner() {
        Application.checkEventThread();
        return this.owner;
    }

    public View getView() {
        Application.checkEventThread();
        return this.view;
    }

    protected abstract boolean _setView(long ptr, View view);
    public void setView(final View view) {
        Application.checkEventThread();
        checkNotClosed();
        View oldView = getView();
        if (oldView == view) {
            return;
        }

        if (oldView != null) {
            oldView.setWindow(null);
        }
        if (view != null) {
            Window host = view.getWindow();
            if (host != null) {
                host.setView(null);
            }
        }

        if (view != null &amp;&amp; _setView(this.ptr, view)) {
            this.view = view;
            this.view.setWindow(this);
            if (this.isDecorated == false) {
                this.helper = new UndecoratedMoveResizeHelper();
            }
        } else {
            _setView(this.ptr, null);
            this.view = null;
        }
    }

    public Screen getScreen() {
        Application.checkEventThread();
        return this.screen;
    }

    protected void setScreen(Screen screen) {
        Application.checkEventThread();

        final Screen old = this.screen;
        this.screen = screen;

        if (this.eventHandler != null) {
            if ((old == null &amp;&amp; this.screen != null) ||
                (old != null &amp;&amp; !old.equals(this.screen))) {
                this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
            }
        }
    }

    public int getStyleMask() {
        Application.checkEventThread();
        return this.styleMask;
    }

    public MenuBar getMenuBar() {
        Application.checkEventThread();
        return this.menubar;
    }

    protected abstract boolean _setMenubar(long ptr, long menubarPtr);
    public void setMenuBar(final MenuBar menubar) {
        Application.checkEventThread();
        checkNotClosed();
        if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
            this.menubar = menubar;
        }
    }

    public boolean isDecorated() {
        Application.checkEventThread();
        return this.isDecorated;
    }

    public boolean isMinimized() {
        Application.checkEventThread();
        return (this.state == State.MINIMIZED);
    }

    protected abstract boolean _minimize(long ptr, boolean minimize);
    public boolean minimize(final boolean minimize) {
        Application.checkEventThread();
        checkNotClosed();
        _minimize(this.ptr, minimize);
        //XXX: this is synchronous? On X11 this may not work
        return isMinimized();
    }

    public boolean isMaximized() {
        Application.checkEventThread();
        return (this.state == State.MAXIMIZED);
    }

    protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
    public boolean maximize(final boolean maximize) {
        Application.checkEventThread();
        checkNotClosed();
        _maximize(ptr, maximize, isMaximized());
        return isMaximized();
    }

    protected void notifyScaleChanged(float platformScaleX, float platformScaleY,
                                      float outputScaleX, float outputScaleY)
    {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.platformScaleX = platformScaleX;
        this.platformScaleY = platformScaleY;
        this.outputScaleX = outputScaleX;
        this.outputScaleY = outputScaleY;
        notifyRescale();
    }

    /**
     * Return the horizontal scale used to communicate window locations,
     * sizes, and event coordinates to/from the platform.
     * @return the horizontal platform scaling for screen locations
     */
    public final float getPlatformScaleX() {
        return platformScaleX;
    }

    /**
     * Return the vertical scale used to communicate window locations,
     * sizes, and event coordinates to/from the platform.
     * @return the vertical platform scaling for screen locations
     */
    public final float getPlatformScaleY() {
        return platformScaleY;
    }

    public void setRenderScaleX(float renderScaleX) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleX = renderScaleX;
    }

    public void setRenderScaleY(float renderScaleY) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleY = renderScaleY;
    }

    /**
     * Return the horizontal scale used for rendering the back buffer.
     * @return the horizontal scaling for rendering
     */
    public final float getRenderScaleX() {
        return renderScaleX;
    }

    /**
     * Return the vertical scale used for rendering to the back buffer.
     * @return the vertical scaling for rendering
     */
    public final float getRenderScaleY() {
        return renderScaleY;
    }

    public float getOutputScaleX() {
        return outputScaleX;
    }

    public float getOutputScaleY() {
        return outputScaleY;
    }

    protected abstract int _getEmbeddedX(long ptr);
    protected abstract int _getEmbeddedY(long ptr);

    private void checkScreenLocation() {
        this.x = _getEmbeddedX(ptr);
        this.y = _getEmbeddedY(ptr);
        if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {
            lastKnownEmbeddedX = this.x;
            lastKnownEmbeddedY = this.y;
            handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
        }
    }

    public int getX() {
        Application.checkEventThread();
        return this.x;
    }

    public int getY() {
        Application.checkEventThread();
        return this.y;
    }

    public int getWidth() {
        Application.checkEventThread();
        return this.width;
    }

    public int getHeight() {
        Application.checkEventThread();
        return this.height;
    }

    protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet,
                                       int w, int h, int cw, int ch,
                                       float xGravity, float yGravity);

    /**
     * Sets the window bounds to the specified values.
     *
     * Gravity values specify how to correct window location if only its size
     * changes (for example when stage decorations are added). User initiated
     * resizing should be ignored and must not influence window location through
     * this mechanism.
     *
     * The corresponding correction formulas are:
     *
     * {@code x -= xGravity * deltaW}
     * {@code y -= yGravity * deltaH}
     *
     * @param x the new window horizontal position, ignored if xSet is set to
     *          false
     * @param y the new window vertical position, ignored if ySet is set to
     *          false
     * @param xSet indicates whether the x parameter is valid
     * @param ySet indicates whether the y parameter is valid
     * @param w the new window width, ignored if set to -1
     * @param h the new window height, ignored if set to -1
     * @param cw the new window content width, ignored if set to -1
     * @param ch the new window content height, ignored if set to -1
     * @param xGravity the xGravity coefficient
     * @param yGravity the yGravity coefficient
     */
    public void setBounds(float x, float y, boolean xSet, boolean ySet,
                          float w, float h, float cw, float ch,
                          float xGravity, float yGravity)
    {
        Application.checkEventThread();
        checkNotClosed();
        float pScaleX = platformScaleX;
        float pScaleY = platformScaleY;
        int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
        int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
        int pw = (int) (w &gt; 0 ? Math.ceil(w * pScaleX) : w);
        int ph = (int) (h &gt; 0 ? Math.ceil(h * pScaleY) : h);
        int pcw = (int) (cw &gt; 0 ? Math.ceil(cw * pScaleX) : cw);
        int pch = (int) (ch &gt; 0 ? Math.ceil(ch * pScaleY) : ch);
        _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
    }

    public void setPosition(int x, int y) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
    }

    public void setSize(int w, int h) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
    }

    public void setContentSize(int cw, int ch) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
    }

    public boolean isVisible() {
        Application.checkEventThread();
        return this.isVisible;
    }

    /**
     * Generates a ViewEvent.MOVE aka insets (might have) changed.
     */
    private void synthesizeViewMoveEvent() {
        final View view = getView();
        if (view != null) {
            view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
        }
    }

    protected abstract boolean _setVisible(long ptr, boolean visible);
    public void setVisible(final boolean visible) {
        Application.checkEventThread();
        if (this.isVisible != visible) {
            if (!visible) {
                if (getView() != null) {
                    getView().setVisible(visible);
                }
                // Avoid native call if the window has been closed already
                if (this.ptr != 0L) {
                    this.isVisible = _setVisible(this.ptr, visible);
                } else {
                    this.isVisible = visible;
                }
                remove(this);
                if (parent != 0) {
                    embeddedLocationTimer.stop();
                }
            } else {
                checkNotClosed();
                this.isVisible = _setVisible(this.ptr, visible);

                if (getView() != null) {
                    getView().setVisible(this.isVisible);
                }
                add(this);
                if (parent != 0) {
                    final Runnable checkRunnable = () -&gt; checkScreenLocation();
                    final Runnable timerRunnable = () -&gt; Application.invokeLater(checkRunnable);
                    embeddedLocationTimer =
                           Application.GetApplication().createTimer(timerRunnable);
                    embeddedLocationTimer.start(16);
                }

                synthesizeViewMoveEvent();
            }
        }
    }

    protected abstract boolean _setResizable(long ptr, boolean resizable);
    public boolean setResizable(final boolean resizable) {
        Application.checkEventThread();
        checkNotClosed();
        if (this.isResizable != resizable) {
            if (_setResizable(this.ptr, resizable)) {
                this.isResizable = resizable;
                synthesizeViewMoveEvent();
            }
        }
        return isResizable;
    }

    public boolean isResizable() {
        Application.checkEventThread();
        return this.isResizable;
    }

    public boolean isUnifiedWindow() {
        //The UNIFIED flag is set only if it is supported
        return (this.styleMask &amp; Window.UNIFIED) != 0;
    }

    public boolean isTransparentWindow() {
        //The TRANSPARENT flag is set only if it is supported
        return (this.styleMask &amp; Window.TRANSPARENT) != 0;
    }

    private static volatile Window focusedWindow = null;
    public static Window getFocusedWindow() {
        Application.checkEventThread();
        return Window.focusedWindow;
    }

    private static void setFocusedWindow(final Window window) {
        Window.focusedWindow = window;
    }

    public boolean isFocused() {
        Application.checkEventThread();
        return this.isFocused;
    }

    protected abstract boolean _requestFocus(long ptr, int event);
    /**
     * Requests or resigns focus on this window.
     *
     * If this is a top-level window (owned or not), then the only possible
     * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.
     * Otherwise, if the window is a child window, the argument may be
     * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or
     * FOCUS_GAINED_BACKWARD.
     *
     * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD
     *
     * @throws IllegalArgumentException if the argument value is invalid for this window
     *
     * @return {@code true} if the operation succeeded
     */
    public boolean requestFocus(int event) {
        Application.checkEventThread();
        checkNotClosed();

        if (!isChild() &amp;&amp; event != WindowEvent.FOCUS_GAINED) {
            throw new IllegalArgumentException(&quot;Invalid focus event ID for top-level window&quot;);
        }

        if (isChild() &amp;&amp; (event &lt; WindowEvent._FOCUS_MIN || event &gt; WindowEvent._FOCUS_MAX)) {
            throw new IllegalArgumentException(&quot;Invalid focus event ID for child window&quot;);
        }

        if (event == WindowEvent.FOCUS_LOST &amp;&amp; !isFocused()) {
            // Already unfocused, nothing to do
            return true;
        }

        // At this point either A) the user requests focus for a focused or unfocused window,
        // or B) the window is focused and the user requests FOCUS_LOST
        if (!this.isFocusable) {
            // It's obviously A). Fail.
            return false;
        }

        return _requestFocus(this.ptr, event);
    }

    public boolean requestFocus() {
        Application.checkEventThread();
        return requestFocus(WindowEvent.FOCUS_GAINED);
    }

    protected abstract void _setFocusable(long ptr, boolean isFocusable);
    /**
     * Sets whether this window is focusable.
     *
     * Clicking an unfocusable window doesn't activate it.
     */
    public void setFocusable(final boolean isFocusable) {
        Application.checkEventThread();
        checkNotClosed();
        this.isFocusable = isFocusable;
        if (isEnabled()) {
            _setFocusable(this.ptr, isFocusable);
        }
    }

    protected abstract boolean _grabFocus(long ptr);
    protected abstract void _ungrabFocus(long ptr);
    /**
     * Grabs focus on this window.
     *
     * All mouse clicks that occur in this window's client area or client-areas
     * of any of its unfocusable owned windows are delivered as usual. Whenever
     * a click occurs on another app's window (not related via the ownership
     * relation with this one, or a focusable owned window), or on non-client
     * area of any window (titlebar, etc.), or any third-party app's window, or
     * native OS GUI (e.g. a taskbar), the grab is automatically reset, and the
     * window that held the grab receives the FOCUS_UNGRAB event.
     *
     * Note that for this functionality to work correctly, the window must have
     * a focus upon calling this method. All owned popup windows that should be
     * operable during the grabbed focus state (e.g. nested popup menus) must
     * be unfocusable (see {@link #setFocusable}). Clicking a focusable owned
     * window will reset the grab due to a focus transfer.
     *
     * The click that occurs in another window and causes resetting of the grab
     * may or may not be delivered to that other window depending on the native
     * OS behavior.
     *
     * If any of the application's windows already holds the grab, it is reset
     * prior to grabbing the focus for this window. The method may be called
     * multiple times for one window. Subsequent calls do not affect the grab
     * status unless it is reset between the calls, in which case the focus
     * is grabbed again.
     *
     * Note that grabbing the focus on an application window may prevent
     * delivering certain events to other applications until the grab is reset.
     * Therefore, if the application has finished showing popup windows based
     * on a user action (e.g. clicking a menu item), and doesn't require the
     * grab any more, it should call the {@link #ungrabFocus} method. The
     * FOCUS_UNGRAB event signals that the grab has been reset.
     *
     * A user event handler associated with a menu item must be invoked after
     * resetting the grab. Otherwise, if a developer debugs the application and
     * has installed a breakpoint in the event handler, the debugger may become
     * unoperable due to events blocking for other applications on some
     * platforms.
     *
     * @return {@code true} if the operation is successful
     * @throws IllegalStateException if the window isn't focused currently
     */
    public boolean grabFocus() {
        Application.checkEventThread();
        checkNotClosed();

        if (!isFocused()) {
            throw new IllegalStateException(&quot;The window must be focused when calling grabFocus()&quot;);
        }

        return _grabFocus(this.ptr);
    }

    /**
     * Manually ungrabs focus grabbed on this window previously.
     *
     * This method resets the grab, and forces sending of the FOCUS_UNGRAB
     * event. It should be used when popup windows (such as menus) should be
     * dismissed manually, e.g. when a user clicks a menu item which usually
     * causes the menus to hide.
     *
     * @see #grabFocus
     */
    public void ungrabFocus() {
        Application.checkEventThread();
        checkNotClosed();
        _ungrabFocus(this.ptr);
    }

    public String getTitle() {
        Application.checkEventThread();
        return this.title;
    }

    protected abstract boolean _setTitle(long ptr, String title);
    public void setTitle(String title) {
        Application.checkEventThread();
        checkNotClosed();
        if (title == null) {
            title = &quot;&quot;;
        }
        if (!title.equals(this.title)) {
            if (_setTitle(this.ptr, title)) {
                this.title = title;
            }
        }
    }

    protected abstract void _setLevel(long ptr, int level);
    /**
     * Set the level of this window in the z-order.
     *
     * @param level one of the constants from {@link Window.Level}
     * @see Window.Level
     */
    public void setLevel(final int level) {
        Application.checkEventThread();
        checkNotClosed();
        if (level &lt; Level._MIN || level &gt; Level._MAX) {
            throw new IllegalArgumentException(&quot;Level should be in the range [&quot; + Level._MIN + &quot;..&quot; + Level._MAX + &quot;]&quot;);
        }
        if (this.level != level) {
            _setLevel(this.ptr, level);
            this.level = level;
        }
    }

    public int getLevel() {
        Application.checkEventThread();
        return this.level;
    }

    private boolean isInFullscreen() {
        final View view = getView();
        return view == null ? false : view.isInFullscreen();
    }

    // Invoked from the View class before sending FULLSCREEN_ to the View.EventHandler
    void notifyFullscreen(boolean entered) {
        final float alpha = getAlpha();
        if (alpha &lt; 1f) {
            if (entered) {
                // Reset alpha at native level
                _setAlpha(this.ptr, 1f);
            } else {
                // restore the current opacity level
                setAlpha(alpha);
            }
        }
    }

    protected abstract void _setAlpha(long ptr, float alpha);
    /**
     * Sets the uniform translucency level for this window.
     *
     * In the full screen mode the native window is always fully opaque.
     * The requested opacity level is applied upon exiting the full screen
     * mode only.
     *
     * @param alpha a value in the range [0..1f] (transparent..fully-opaque)
     */
    public void setAlpha(final float alpha) {
        Application.checkEventThread();
        checkNotClosed();
        if (alpha &lt; 0f || alpha &gt; 1f) {
            throw new IllegalArgumentException(&quot;Alpha should be in the range [0f..1f]&quot;);
        }

        this.alpha = alpha;

        if (alpha &lt; 1f &amp;&amp; isInFullscreen()) {
            return;
        }

        _setAlpha(this.ptr, this.alpha);
    }

    public float getAlpha() {
        Application.checkEventThread();
        return this.alpha;
    }

    public boolean getAppletMode() {
        return appletMode;
    }

    public void setAppletMode(boolean appletMode) {
        this.appletMode = appletMode;
    }

    protected abstract boolean _setBackground(long ptr, float r, float g, float b);
    /**
     * Set the background of the window.
     *
     * In most cases the View covers the whole window, so the background color
     * of the window is never seen by the user. However, a window w/o a view
     * does display the background color in its content area.
     *
     * On some platforms setting the background color may produce flickering
     * when painting the content area of the View (even though the View covers
     * the whole window).  Therefore it is recommended to set the background
     * color to windows w/o views only.
     */
    public boolean setBackground(final float r, final float g, final float b) {
        Application.checkEventThread();
        checkNotClosed();
        return _setBackground(this.ptr, r, g, b);
    }

    public boolean isEnabled() {
        Application.checkEventThread();
        return this.disableCount == 0;
    }

    protected abstract void _setEnabled(long ptr, boolean enabled);
    /**
     * Enables or disables the window.
     *
     * A disabled window is unfocusable by definition.
     * Also, key or mouse events aren't generated for disabled windows.
     *
     * When a user tries to activate a disabled window, or the window gets
     * accidentally brought to the top of the stacking order, the window
     * generates the FOCUS_DISABLED window event. A Glass client should react
     * to this event and bring the currently active modal blocker of the
     * disabled window to top by calling blocker's minimize(false), toFront(),
     * and requestFocus() methods. It may also 'blink' the blocker window to
     * further attract user's attention.
     *
     * It's strongly recommended to process the FOCUS_DISABLED event
     * synchronously and as fast as possible to avoid any possible visual and
     * behavioral artifacts. Note that a disabled window may by no means gain
     * the input focus. The purpose of this event is to make sure that the
     * current modal blocker window is always visible to the user, and the user
     * understands why he can't interact with a disabled window.
     *
     * The method supports nested calls. If you disable the window twice
     * with two calls to setEnabled(false), you must call setEnabled(true)
     * twice as well in order to enable it afterwards. This is to support
     * 'nested' modal dialogs when one modal dialog opens another one.
     */
    public void setEnabled(boolean enabled) {
        Application.checkEventThread();
        checkNotClosed();
        if (!enabled) {
            if (++this.disableCount &gt; 1) {
                // already disabled
                return;
            }
        } else {
            if (this.disableCount == 0) {
                //should report a warning about an extra enable call ?
                return;
            }
            if (--this.disableCount &gt; 0) {
                // not yet enabled
                return;
            }
        }

        //TODO: on Windows _setFocusable(this.ptr, isEnabled() ? this.isFocusable : false);
        _setEnabled(this.ptr, isEnabled());
    }

    public int getMinimumWidth() {
        Application.checkEventThread();
        return this.minimumWidth;
    }

    public int getMinimumHeight() {
        Application.checkEventThread();
        return this.minimumHeight;
    }

    public int getMaximumWidth() {
        Application.checkEventThread();
        return this.maximumWidth;
    }

    public int getMaximumHeight() {
        Application.checkEventThread();
        return this.maximumHeight;
    }

    protected abstract boolean _setMinimumSize(long ptr, int width, int height);
    /**
     * Sets the minimum size for this window.
     * A value of zero indicates no restriction.
     * If the native platform is unable to apply the constraints,
     * the values returned by getMinimumWidth()/Height() won't change.
     *
     * @throws IllegalArgumentException if width or height &lt; 0
     */
    public void setMinimumSize(int width, int height) {
        Application.checkEventThread();
        if (width &lt; 0 || height &lt; 0) {
            throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
        }
        checkNotClosed();
        if (_setMinimumSize(this.ptr, width, height)) {
            this.minimumWidth = width;
            this.minimumHeight = height;
        }
    }

    protected abstract boolean _setMaximumSize(long ptr, int width, int height);
    /**
     * Sets the maximum size for this window.
     * A value of {@code Integer.MAX_VALUE} indicates no restriction.
     * If the native platform is unable to apply the constraints,
     * the values returned by getMaximumWidth()/Height() won't change.
     *
     * @throws IllegalArgumentException if width or height &lt; 0
     */
    public void setMaximumSize(int width, int height) {
        Application.checkEventThread();
        if (width &lt; 0 || height &lt; 0) {
            throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
        }
        checkNotClosed();
        if (_setMaximumSize(this.ptr,
                    // for easier handling in native:
                    width == Integer.MAX_VALUE ? -1 : width,
                    height == Integer.MAX_VALUE ? -1 : height))
        {
            this.maximumWidth = width;
            this.maximumHeight = height;
        }
    }


    protected abstract void _setIcon(long ptr, Pixels pixels);

    // In the future we may want to pass a collection of Pixels, so that
    // the native platform could pick up the icon with the best dimensions
    public void setIcon(final Pixels pixels) {
        Application.checkEventThread();
        checkNotClosed();
        _setIcon(this.ptr, pixels);
    }

    protected abstract void _setCursor(long ptr, Cursor cursor);

    /**
     * Sets given cursor as the cursor for this window.
     * If the cursor is NONE, it is automatically hidden,
     * otherwise it is automatically shown.
     * @see Cursor#setVisible(boolean)
     */
    public void setCursor(Cursor cursor) {
        Application.checkEventThread();
        _setCursor(this.ptr, cursor);
    }

    protected abstract void _toFront(long ptr);
    /**
     * Bring the window to front in the z-order.
     * This method DOES NOT activate the window. To make it active use
     * the requestFocus() method right after calling toFront().
     */
    public void toFront() {
        Application.checkEventThread();
        checkNotClosed();
        _toFront(ptr);
    }

    protected abstract void _toBack(long ptr);
    /**
     * Send the window to the bottom of the stacking order.
     * This method may or may not de-focus this window
     * depending on the native platform. To make sure some other
     * window is activated, call requestFocus() on that other window.
     */
    public void toBack() {
        Application.checkEventThread();
        checkNotClosed();
        _toBack(this.ptr);
    }

    // *****************************************************
    // modality (prototype using native platform feature)
    // *****************************************************
    protected abstract void _enterModal(long ptr);
    /**
     * Enter modal state blocking everything except our window.
     */
    public void enterModal() {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModal(this.ptr);
        }
    }

    protected abstract void _enterModalWithWindow(long dialog, long window);
    /**
     * Enter modal state only blocking the given window.
     * On Mac OS X this is done using a dialog sheet.
     */
    public void enterModal(final Window window) {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModalWithWindow(this.ptr, window.getNativeHandle());
        }
    }

    protected abstract void _exitModal(long ptr);
    public void exitModal() {
        checkNotClosed();
        if (this.isModal == true) {
            _exitModal(this.ptr);
            this.isModal = false;
        }
    }

    public boolean isModal() {
        return this.isModal;
    }

    /** Only used on Mac when run inside a plugin */
    public void dispatchNpapiEvent(Map eventInfo) {
        Application.checkEventThread();
        throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
    }

    public EventHandler getEventHandler() {
        Application.checkEventThread();
        return eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        Application.checkEventThread();
        this.eventHandler = eventHandler;
    }

    /**
     * Enables unconditional start of window move operation when
     * mouse is dragged in the client area.
     */
    public void setShouldStartUndecoratedMove(boolean v) {
        Application.checkEventThread();
        this.shouldStartUndecoratedMove = v;
    }

    // *****************************************************
    // notification callbacks
    // *****************************************************
    protected void notifyClose() {
        handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
    }

    protected void notifyDestroy() {
        // Mac is known to send multiple WillClose notifications for some reason
        if (this.ptr == 0) {
            return;
        }

        handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);

        this.ptr = 0;
<A NAME="62"></A>
        // Do this after setting ptr to 0 to avoid a call to _setVisible()
        setVisible(false);
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#62',2,'match42-top.html#62',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    protected void notifyMove(final int x, final int y) {
        this.x = x;
        this.y = y;
        handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
    }

    protected void notifyRescale() {
        handleWindowEvent(System.nanoTime</B></FONT>(), WindowEvent.RESCALE);
    }

    protected void notifyMoveToAnotherScreen(Screen newScreen) {
        setScreen(newScreen);
    }

    protected void setState(int state) {
        this.state = state;
    }

    /**
     * type values:
     *   - WindowEvent.RESIZE
     *   - WindowEvent.MINIMIZE
     *   - WindowEvent.MAXIMIZE
     *   - WindowEvent.RESTORE
     */
    protected void notifyResize(final int type, final int width, final int height) {
        if (type == WindowEvent.MINIMIZE) {
            this.state = State.MINIMIZED;
        } else {
            if (type == WindowEvent.MAXIMIZE) {
                this.state = State.MAXIMIZED;
            } else { // WindowEvent.RESIZE or WindowEvent.RESTORE
                this.state = State.NORMAL;
            }
            this.width = width;
            this.height = height;

            // update moveRect/resizeRect
            if (this.helper != null){
                this.helper.updateRectangles();
            }
        }
        handleWindowEvent(System.nanoTime(), type);

        /*
         * Send RESIZE notification as MAXIMIZE and RESTORE change the window size
         */
        if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
            handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
        }
    }

    protected void notifyFocus(int event) {
        final boolean focused = event != WindowEvent.FOCUS_LOST;

        if (this.isFocused != focused) {
            this.isFocused = focused;
            if (this.isFocused) {
                setFocusedWindow(this);
            } else {
                setFocusedWindow(null);
            }
            handleWindowEvent(System.nanoTime(), event);
        }
    }

    protected void notifyFocusDisabled() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
    }

    protected void notifyFocusUngrab() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
    }

    protected void notifyDelegatePtr(long ptr) {
        this.delegatePtr = ptr;
    }

    // *****************************************************
    // window event handlers
    // *****************************************************
    protected void handleWindowEvent(long time, int type) {
        if (this.eventHandler != null) {
            this.eventHandler.handleWindowEvent(this, time, type);
        }
    }

    // *****************************************************
    // programmatical move/resize
    // *****************************************************
    /** Sets &quot;programmatical move&quot; rectangle.
     * The rectangle is measured from top of the View:
     * width is View.width, height is size.
     *
     * throws RuntimeException for decorated window.
     */
    public void setUndecoratedMoveRectangle(int size) {
        Application.checkEventThread();
        if (this.isDecorated == true) {
            //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Window&quot;);
            System.err.println(&quot;Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.&quot;);
            Thread.dumpStack();
            return;
        }

        if (this.helper != null) {
            this.helper.setMoveRectangle(size);
        }
    }
    /** The method called only for undecorated windows
     * x, y: mouse coordinates (in View space).
     *
     * throws RuntimeException for decorated window.
     */
    public boolean shouldStartUndecoratedMove(final int x, final int y) {
        Application.checkEventThread();
        if (this.shouldStartUndecoratedMove == true) {
            return true;
        }
        if (this.isDecorated == true) {
            return false;
        }

        if (this.helper != null) {
            return this.helper.shouldStartMove(x, y);
        } else {
            return false;
        }
    }

    /** Sets &quot;programmatical resize&quot; rectangle.
     * The rectangle is measured from top of the View:
     * width is View.width, height is size.
     *
     * throws RuntimeException for decorated window.
     */
    public void setUndecoratedResizeRectangle(int size) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window&quot;);
            System.err.println(&quot;Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.&quot;);
            Thread.dumpStack();
            return;
        }

        if (this.helper != null) {
            this.helper.setResizeRectangle(size);
        }
    }

    /** The method called only for undecorated windows
     * x, y: mouse coordinates (in View space).
     *
     * throws RuntimeException for decorated window.
     */
    public boolean shouldStartUndecoratedResize(final int x, final int y) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            return false;
        }

        if (this.helper != null) {
            return this.helper.shouldStartResize(x, y);
        }  else {
            return false;
        }
    }

    /** Mouse event handler for processing programmatical resize/move
     * (for undecorated windows only).
     * Must be called by View.
     * x &amp; y are View coordinates.
     * NOTE: it's package private!
     * @return true if the event is processed by the window,
     *         false if it has to be delivered to the app
     */
    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
        if (this.isDecorated == false) {
            return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
        }
        return false;
    }

    @Override
    public String toString() {
        Application.checkEventThread();
        return  &quot;Window:&quot;+&quot;\n&quot;
                + &quot;    ptr: &quot; + getNativeWindow() + &quot;\n&quot;
                + &quot;    screen ptr: &quot; + (screen != null ? screen.getNativeScreen() : &quot;null&quot;) + &quot;\n&quot;
                + &quot;    isDecorated: &quot; + isDecorated() + &quot;\n&quot;
                + &quot;    title: &quot; + getTitle() + &quot;\n&quot;
                + &quot;    visible: &quot; + isVisible() + &quot;\n&quot;
                + &quot;    focused: &quot; + isFocused() + &quot;\n&quot;
                + &quot;    modal: &quot; + isModal() + &quot;\n&quot;
                + &quot;    state: &quot; + state + &quot;\n&quot;
                + &quot;    x: &quot; + getX() + &quot;, y: &quot; + getY() + &quot;, w: &quot; + getWidth() + &quot;, h: &quot; + getHeight() + &quot;\n&quot;
                + &quot;&quot;;
    }

    // &quot;programmical&quot; move/resize support for undecorated windows

    static private class TrackingRectangle {
        int size = 0;
        int x = 0, y = 0, width = 0, height = 0;
        boolean contains(final int x, final int y) {
            return ((size &gt; 0) &amp;&amp;
                    (x &gt;= this.x) &amp;&amp; (x &lt; (this.x + this.width)) &amp;&amp;
                        (y &gt;= this.y) &amp;&amp; (y &lt; (this.y + this.height)));
        }
    }

    protected void notifyLevelChanged(int level) {
        this.level = level;
        if (this.eventHandler != null) {
            this.eventHandler.handleLevelEvent(level);
        }
    }

    private class UndecoratedMoveResizeHelper {
        TrackingRectangle moveRect = null;
        TrackingRectangle resizeRect = null;

        boolean inMove = false;         // we are in &quot;move&quot; mode
        boolean inResize = false;       // we are in &quot;resize&quot; mode

        int startMouseX, startMouseY;   // start mouse coords
        int startX, startY;             // start window location (for move)
        int startWidth, startHeight;    // start window size (for resize)

        UndecoratedMoveResizeHelper() {
            this.moveRect = new TrackingRectangle();
            this.resizeRect = new TrackingRectangle();
        }

        void setMoveRectangle(final int size) {
            this.moveRect.size = size;

            this.moveRect.x = 0;
            this.moveRect.y = 0;
            this.moveRect.width = getWidth();
            this.moveRect.height = this.moveRect.size;
        }

        boolean shouldStartMove(final int x, final int y) {
            return this.moveRect.contains(x, y);
        }

        boolean inMove() {
            return this.inMove;
        }

        void startMove(final int x, final int y) {
            this.inMove = true;

            this.startMouseX = x;
            this.startMouseY = y;

            this.startX = getX();
            this.startY = getY();
        }

        void deltaMove(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;

            setPosition(this.startX + deltaX, this.startY + deltaY);
        }

        void stopMove() {
            this.inMove = false;
        }

        void setResizeRectangle(final int size) {
            this.resizeRect.size = size;

            // set the rect (bottom right corner of the Window)
            this.resizeRect.x = getWidth() - this.resizeRect.size;
            this.resizeRect.y = getHeight() - this.resizeRect.size;
            this.resizeRect.width = this.resizeRect.size;
            this.resizeRect.height = this.resizeRect.size;
        }

        boolean shouldStartResize(final int x, final int y) {
            return this.resizeRect.contains(x, y);
        }

        boolean inResize() {
            return this.inResize;
        }

        void startResize(final int x, final int y) {
            this.inResize = true;

            this.startMouseX = x;
            this.startMouseY = y;

            this.startWidth = getWidth();
            this.startHeight = getHeight();
        }

        void deltaResize(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;

            setSize(this.startWidth + deltaX, this.startHeight + deltaY);
        }

        protected void stopResize() {
            this.inResize = false;
        }

        void updateRectangles() {
            if (this.moveRect.size &gt; 0) {
                setMoveRectangle(this.moveRect.size);
            }
            if (this.resizeRect.size &gt; 0) {
                setResizeRectangle(this.resizeRect.size);
            }
        }

        boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
            switch (type) {
                case MouseEvent.DOWN:
                    if (button == MouseEvent.BUTTON_LEFT) {
                        if (shouldStartUndecoratedMove(x, y) == true) {
                            startMove(xAbs, yAbs);
                            return true;
                        } else if (shouldStartUndecoratedResize(x, y) == true) {
                            startResize(xAbs, yAbs);
                            return true;
                        }
                    }
                    break;

                case MouseEvent.MOVE:
                case MouseEvent.DRAG:
                    if (inMove() == true) {
                        deltaMove(xAbs, yAbs);
                        return true;
                    } else if (inResize() == true) {
                        deltaResize(xAbs, yAbs);
                        return true;
                    }
                    break;

                case MouseEvent.UP:
                    boolean wasProcessed = inMove() || inResize();
                    stopResize();
                    stopMove();
                    return wasProcessed;
            }
            return false;
        }
    }

    /**
     * Requests text input in form of native keyboard for text component
     * contained by this Window. Native text input component is drawn on the place
     * of JavaFX component to cover it completely and to provide native text editing
     * techniques. Any change of text is immediately reflected in JavaFX text component.
     *
     * @param text text to be shown in the native text input component
     * @param type type of text input component @see com.sun.javafx.scene.control.behavior.TextInputTypes
     * @param width width of JavaFX text input component
     * @param height height of JavaFX text input component
     * @param M standard transformation matrix for drawing the native text component derived from JavaFX component
     */
    public void requestInput(String text, int type, double width, double height,
                                double Mxx, double Mxy, double Mxz, double Mxt,
                                double Myx, double Myy, double Myz, double Myt,
                                double Mzx, double Mzy, double Mzz, double Mzt) {
        Application.checkEventThread();
        _requestInput(this.ptr, text, type, width, height,
                        Mxx, Mxy, Mxz, Mxt,
                        Myx, Myy, Myz, Myt,
                        Mzx, Mzy, Mzz, Mzt);
    }

    /**
     * Native keyboard for text input is no longer necessary.
     * Keyboard will be hidden and native text input component too.
     */
    public void releaseInput() {
        Application.checkEventThread();
        _releaseInput(this.ptr);
    }

    protected abstract void _requestInput(long ptr, String text, int type, double width, double height,
                                            double Mxx, double Mxy, double Mxz, double Mxt,
                                            double Myx, double Myy, double Myz, double Myt,
                                            double Mzx, double Mzy, double Mzz, double Mzt);

    protected abstract void _releaseInput(long ptr);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/mac/MacView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.mac;

import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.View;
import com.sun.glass.ui.Window;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Map;
import java.util.TreeSet;

/**
 * MacOSX platform implementation class for View.
 */
final class MacView extends View {

    private native static void _initIDs();
    static {
        _initIDs();
        multiClickTime = _getMultiClickTime_impl();
        multiClickMaxX = _getMultiClickMaxX_impl();
        multiClickMaxY = _getMultiClickMaxY_impl();
    }

    // Constants
    private static final long multiClickTime;
    private static final int multiClickMaxX, multiClickMaxY;

    private native static long _getMultiClickTime_impl();
    private native static int _getMultiClickMaxX_impl();
    private native static int _getMultiClickMaxY_impl();

    static long getMultiClickTime_impl() {
        return multiClickTime;
    }

    static int getMultiClickMaxX_impl() {
        return multiClickMaxX;
    }

    static int getMultiClickMaxY_impl() {
        return multiClickMaxY;
    }

    @Override native protected int _getNativeFrameBuffer(long ptr);
    @Override native protected long _create(Map caps);
    @Override native protected int _getX(long ptr);
    @Override native protected int _getY(long ptr);
    @Override native protected void _setParent(long ptr, long parentPtr);
    @Override native protected boolean _close(long ptr);
    @Override native protected void _scheduleRepaint(long ptr);
    @Override native protected void _begin(long ptr);
    @Override native protected void _end(long ptr);
    @Override native protected boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);
    @Override native protected void _exitFullscreen(long ptr, boolean animate);
    @Override native protected void _enableInputMethodEvents(long ptr, boolean enable);

    @Override protected void _uploadPixels(long ptr, Pixels pixels) {
        Buffer data = pixels.getPixels();
        if (data.isDirect() == true) {
            _uploadPixelsDirect(ptr, data, pixels.getWidth(), pixels.getHeight(), pixels.getScaleX(), pixels.getScaleY());
        } else if (data.hasArray() == true) {
            if (pixels.getBytesPerComponent() == 1) {
                ByteBuffer bytes = (ByteBuffer)data;
                _uploadPixelsByteArray(ptr, bytes.array(), bytes.arrayOffset(),
                                       pixels.getWidth(), pixels.getHeight(), pixels.getScaleX(), pixels.getScaleY());
            } else {
                IntBuffer ints = (IntBuffer)data;
                _uploadPixelsIntArray(ptr, ints.array(), ints.arrayOffset(),
                                      pixels.getWidth(), pixels.getHeight(), pixels.getScaleX(), pixels.getScaleY());
            }
        } else {
            // gznote: what are the circumstances under which this can happen?
            _uploadPixelsDirect(ptr, pixels.asByteBuffer(),
                                pixels.getWidth(), pixels.getHeight(), pixels.getScaleX(), pixels.getScaleY());
        }
    }
    native void _uploadPixelsDirect(long viewPtr, Buffer pixels, int width, int height, float scaleX, float scaleY);
    native void _uploadPixelsByteArray(long viewPtr, byte[] pixels, int offset, int width, int height, float scaleX, float scaleY);
    native void _uploadPixelsIntArray(long viewPtr, int[] pixels, int offset, int width, int height, float scaleX, float scaleY);

    @Override
    protected void notifyResize(int width, int height) {
        Window w = getWindow();
        float sx = (w == null) ? 1.0f : w.getPlatformScaleX();
        float sy = (w == null) ? 1.0f : w.getPlatformScaleY();
        width = Math.round(width * sx);
        height = Math.round(height * sy);
        super.notifyResize(width, height);
    }

    @Override
    protected void notifyMouse(int type, int button, int x, int y, int xAbs,
                               int yAbs, int modifiers, boolean isPopupTrigger,
                               boolean isSynthesized) {
        Window w = getWindow();
        float sx = (w == null) ? 1.0f : w.getPlatformScaleX();
        float sy = (w == null) ? 1.0f : w.getPlatformScaleY();
        x = Math.round(x * sx);
        y = Math.round(y * sy);
        xAbs = Math.round(xAbs * sx);
        yAbs = Math.round(yAbs * sy);
        super.notifyMouse(type, button, x, y, xAbs, yAbs, modifiers,
                          isPopupTrigger, isSynthesized);
    }

    @Override protected long _getNativeView(long ptr) {
        return ptr;
    }

    native protected long _getNativeLayer(long ptr);
    public long getNativeLayer() {
        return _getNativeLayer(getNativeView());
    }

    native protected int _getNativeRemoteLayerId(long ptr, String serverName);
    @Override public int getNativeRemoteLayerId(String serverName) {
        // used when run inside plugin
        return _getNativeRemoteLayerId(getNativeLayer(), serverName);
    }

    native protected void _hostRemoteLayerId(long ptr, int nativeLayerId);
    public void hostRemoteLayerId(int nativeLayerId) {
        // used when run inside plugin
        _hostRemoteLayerId(getNativeLayer(), nativeLayerId);
    }

    protected void notifyInputMethodMac(String str, int attrib, int length,
                                            int cursor, int selStart, int selLength) {
        byte atts[] = new byte[1];
        atts[0] = (byte) attrib;
        int attBounds[] = new int[2];
        attBounds[0] = 0;
        attBounds[1] = length;
        if(attrib == 4) {
            // attrib == 4 means we are going to commit changes, so commitLength should be non-zero
            notifyInputMethod(str, null, attBounds, atts, length, cursor, 0);
        } else {
            // all other cases = just an update, update preview text but do not commit it
<A NAME="81"></A>            if (selLength &gt; 0
                    &amp;&amp; str != null &amp;&amp; str.length() &gt; 0
                    &amp;&amp; selStart &gt;= 0
                    &amp;&amp; selLength + selStart &lt;= <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#81',2,'match42-top.html#81',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>str.length()) {

                TreeSet&lt;Integer&gt; b = new TreeSet&lt;&gt;();
                b.add(0);
                b.add(selStart);
                b.add(selStart + selLength);
                b.add(str.length</B></FONT>());

                int[] boundary = new int[b.size()];
                int i = 0;
                for (int e : b) {
                    boundary[i] = e;
                    i++;
                }

                byte[] values = new byte[boundary.length - 1];

                for (i = 0; i &lt; boundary.length - 1; i++) {
                    values[i] = (boundary[i] == selStart)
                                        ? IME_ATTR_TARGET_CONVERTED
                                        : IME_ATTR_CONVERTED;
                }

                notifyInputMethod(str, boundary, boundary, values, 0, cursor, 0);
            } else {
                notifyInputMethod(str, null, attBounds, atts, 0, cursor, 0);
            }
        }
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/AndroidInputProcessor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.monocle;

class AndroidInputProcessor {

    private final AndroidInputDevice device;
    final TouchPipeline touchPipeline;
    private final KeyInput keyInput = new KeyInput();
<A NAME="3"></A>
    AndroidInputProcessor(AndroidInputDevice device) {
        this.device = device;
        touchPipeline = <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#3',2,'match42-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new TouchPipeline();
        touchPipeline.add(TouchInput.getInstance().getBasePipeline());
    }

    void pushEvent(TouchState state) {
        touchPipeline.pushState(state);
    }</B></FONT>

    /**
     * Called when events are waiting on the input device to be processed.
     * Called on the runnable processor provided to the input device.
     *
     * @param device The device on which events are pending
     */
    void processEvents(AndroidInputDevice device) {
        touchPipeline.pushState(null);
    }

    synchronized void pushKeyEvent(KeyState keyState) {
        keyInput.setState(keyState);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/LinuxEventBuffer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * A buffer holding raw Linux input events waiting to be processed
 */
class LinuxEventBuffer {

    interface EventStruct {
        int getTypeIndex();
        int getCodeIndex();
        int getValueIndex();
        int getSize();
    }

    class EventStruct32Bit implements EventStruct {
        public int getTypeIndex() { return 8; }
        public int getCodeIndex() { return 10; }
        public int getValueIndex() { return 12; }
        public int getSize() { return 16; }
    }

    class EventStruct64Bit implements EventStruct {
        public int getTypeIndex() { return 16; }
        public int getCodeIndex() { return 18; }
        public int getValueIndex() { return 20; }
        public int getSize() { return 24; }
    }

    /**
     * EVENT_BUFFER_SIZE controls the maximum number of event lines that can be
     * processed per device in one pulse. This value must be greater than the
     * number of lines in the largest event including the terminating EV_SYN
     * SYN_REPORT. However it should not be too large or a flood of events will
     * prevent rendering from happening until the buffer is full.
     */
    private static final int EVENT_BUFFER_SIZE = 1000;

    private final ByteBuffer bb;
    private final EventStruct eventStruct;
    private int positionOfLastSync;
    private int currentPosition;
    private int mark;

    LinuxEventBuffer(int osArchBits) {
        eventStruct = osArchBits == 64 ? new EventStruct64Bit() : new EventStruct32Bit();
        bb = ByteBuffer.allocate(eventStruct.getSize() * EVENT_BUFFER_SIZE);
        bb.order(ByteOrder.nativeOrder());
    }

    int getEventSize() {
        return eventStruct.getSize();
    }

    /**
     * Adds a raw Linux event to the buffer. Blocks if the buffer is full.
     * Checks whether this is a SYN SYN_REPORT event terminator.
     *
     * @param event A ByteBuffer containing the event to be added.
     * @return true if the event was &quot;SYN SYN_REPORT&quot;, false otherwise
     * @throws InterruptedException if our thread was interrupted while waiting
     *                              for the buffer to empty.
     */
    synchronized boolean put(ByteBuffer event) throws
            InterruptedException {
        boolean isSync = event.getInt(eventStruct.getTypeIndex()) == 0
                &amp;&amp; event.getInt(eventStruct.getValueIndex()) == 0;
        while (bb.limit() - bb.position() &lt; event.limit()) {
            // Block if bb is full. This should be the
            // only time this thread waits for anything
            // except for more event lines.
            if (MonocleSettings.settings.traceEventsVerbose) {
                MonocleTrace.traceEvent(
                        &quot;Event buffer %s is full, waiting for some space to become available&quot;,
                        bb);
                // wait for half the space to be available, to avoid excessive context switching?
            }
            wait();
        }
        if (isSync) {
            positionOfLastSync = bb.position();
        }
        bb.put(event);
        if (MonocleSettings.settings.traceEventsVerbose) {
            int index = bb.position() - eventStruct.getSize();
            MonocleTrace.traceEvent(&quot;Read %s [index=%d]&quot;,
                                    getEventDescription(index), index);
        }
        return isSync;
    }

    synchronized void startIteration() {
        currentPosition = 0;
        mark = 0;
        if (MonocleSettings.settings.traceEventsVerbose) {
            MonocleTrace.traceEvent(&quot;Processing %s [index=%d]&quot;, getEventDescription(), currentPosition);
        }
    }
<A NAME="6"></A>
    synchronized void compact() {
        positionOfLastSync -= currentPosition;
        <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#6',2,'match42-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int newLimit = bb.position();
        bb.position(currentPosition);
        bb.limit(newLimit);
        bb.compact();
        if (MonocleSettings.settings.traceEventsVerbose) {
            MonocleTrace.traceEvent(&quot;Compacted event buffer %s&quot;, bb);
        }
        // If put() is waiting for space in the buffer, wake it up
        notifyAll();
    }</B></FONT>

    /**
     * Returns the type of the current event line. Call from the application
     * thread.
     *
     * @return the type of the current event line
     */
    synchronized short getEventType() {
        return bb.getShort(currentPosition + eventStruct.getTypeIndex());
    }

    /**
     * Returns the code of the current event line.  Call from the application
     * thread.
     *
     * @return the code of the event line
     */
    short getEventCode() {
        return bb.getShort(currentPosition + eventStruct.getCodeIndex());
    }

    /**
     * Returns the value of the current event line.  Call from the application
     * thread.
     *
     * @return the value of the current event line
     */
    synchronized int getEventValue() {
        return bb.getInt(currentPosition + eventStruct.getValueIndex());
    }

    /**
     * Returns a string describing the current event. Call from the application
     * thread.
     *
     * @return a string describing the event
     */
    synchronized String getEventDescription() {
        return getEventDescription(currentPosition);
    }

    private synchronized String getEventDescription(int position) {
        short type = bb.getShort(position + eventStruct.getTypeIndex());
        short code = bb.getShort(position + eventStruct.getCodeIndex());
        int value = bb.getInt(position + eventStruct.getValueIndex());
        String typeStr = LinuxInput.typeToString(type);
        return typeStr + &quot; &quot; + LinuxInput.codeToString(typeStr, code) + &quot; &quot; + value;
    }

    /**
     * Advances to the next event line.  Call from the application thread.
     */
    synchronized void nextEvent() {
        if (currentPosition &gt; positionOfLastSync) {
            throw new IllegalStateException(&quot;Cannot advance past the last&quot; +
                                                    &quot; EV_SYN EV_SYN_REPORT 0&quot;);
        }
        currentPosition += eventStruct.getSize();
        if (MonocleSettings.settings.traceEventsVerbose &amp;&amp; hasNextEvent()) {
            MonocleTrace.traceEvent(&quot;Processing %s [index=%d]&quot;,
                                    getEventDescription(), currentPosition);
        }
    }

    /**
     * Sets a mark on the buffer. A future call to reset() will return to this
     * point.
     */
    synchronized void mark() {
        mark = currentPosition;
    }

    /**
     * Returns iteration to the event set previously in a call to mark(), or to
     * the beginning of the buffer if no call to mark() was made.
     */
    synchronized void reset() {
        currentPosition = mark;
    }

    /**
     * Returns true iff another event line is available AND it is part of a
     * complete event. Call from the application thread.
     */
    synchronized boolean hasNextEvent() {
        return currentPosition &lt;= positionOfLastSync;
    }

    /**
     * Returns true iff another event line is available. Call on the
     * application thread.
     */
    synchronized boolean hasData() {
        return bb.position() != 0;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/RunnableProcessor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.ui.Application;

import java.util.LinkedList;
import java.util.concurrent.CountDownLatch;

/**
 * RunnableProcessor provides control over nested run loops in the JavaFX
 * event queue.
 */
class RunnableProcessor implements Runnable {

    private RunnableQueue queue = new RunnableQueue();

    private static class RunLoopControl {
        boolean active; // thread should continue to process events.
        Object release; // object to return with on leave nested
    }

    // our stack of nested run loops
    private LinkedList&lt;RunLoopControl&gt; activeRunLoops = new LinkedList&lt;RunLoopControl&gt;();

<A NAME="85"></A>    @Override
    public void run() {
        runLoop();
    <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#85',2,'match42-top.html#85',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Posts a Runnable to the JavaFX event queue using this RunnableProcessor
     *
     * @param r an action to be performed on the JavaFX application thread.
     */
    void invokeLater(Runnable r) {
        queue.postRunnable(r);
    }

    /**
     * Posts a Runnable to the JavaFX event queue and waits for the Runnable
     * to complete.
     *
     * @param r an action to be performed on the JavaFX application thread.
     */
    void invokeAndWait(final Runnable r) {
        final CountDownLatch latch = new</B></FONT> CountDownLatch(1);
        queue.postRunnable(() -&gt; {
            try {
                r.run();
            } finally {
                latch.countDown();
            }
        });
        try {
            latch.await();
        } catch (InterruptedException e) { }
    }

    private Object runLoop() {
        final RunLoopControl control = new RunLoopControl();

        //push this new instance on the stack
        activeRunLoops.push(control);

        control.active = true;
        while (control.active) {
            try {
                queue.getNextRunnable().run();
            } catch (Throwable e) {
                Application.reportException(e);
            }
        }

        return control.release;

    }

    Object enterNestedEventLoop() {
        // we are being called on the current active event thread
        // via dispatch, so it is stalled until we return.

        // start our nested loop, which will block until that exits
        Object ret = runLoop();

        // and return the value that was passed into leaveNested
        return ret;
    }

    void leaveNestedEventLoop(Object retValue) {
        // we are being called from dispatch of the current running
        // event thread. We want to cause this thread to exit, and
        // restart the nested on.

        RunLoopControl current = activeRunLoops.pop();
        assert current != null;

        // let the current run loop die when we return to dispatch.
        current.active = false;
        // and give it the ret object so it will return it to the
        // blocked nesting call.
        current.release = retValue;

        // when we return from this dispatched event, we will exit
        // because we are no longer active, and then the nested
        // call can return the release value we just provided.
    }

    void shutdown() {
        synchronized (queue) {
            queue.clear();
            while (!activeRunLoops.isEmpty()) {
                RunLoopControl control = activeRunLoops.pop();
                control.active = false;
            }
            queue.notifyAll();
        }
    }

    /** Posts a Runnable to the JavaFX event queue using the global
     * RunnableProcessor.
     *
     * @param r an action to be performed on the JavaFX application thread.
     */
    static void runLater(Runnable r) {
        NativePlatformFactory.getNativePlatform()
                .getRunnableProcessor()
                .invokeLater(r);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/VNCScreen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.MouseEvent;
import javafx.application.Platform;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.BitSet;
import java.util.HashSet;
import java.util.Set;

/** A headless screen that is available for remote connections using the
 * RFB 3.3 protocol on port 5901.
 */
class VNCScreen extends HeadlessScreen {

    private ServerSocketChannel server;
    private Set&lt;ClientConnection&gt; clients = new HashSet&lt;ClientConnection&gt;();

    VNCScreen() {
        super(1024, 600, 32);
        try {
            server = ServerSocketChannel.open();
            int vncPort = AccessController.doPrivileged(
                    (PrivilegedAction&lt;Integer&gt;)
                            () -&gt; Integer.getInteger(&quot;vnc.port&quot;, 5901));
            server.bind(new InetSocketAddress(vncPort));
            Thread t = new Thread(new ConnectionAccepter());
            t.setDaemon(true);
            t.setName(&quot;VNC Server on port &quot; + vncPort);
            t.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void shutdown() {
        super.shutdown();
        for (ClientConnection cc : clients) {
            try {
                cc.socket.close();
            } catch (IOException e) { }
        }
    }

    @Override
    public void swapBuffers() {
        ClientConnection[] ccs;
<A NAME="64"></A>        synchronized (clients) {
            ccs = clients.toArray(new ClientConnection[clients.size()]);
        }
        for (<FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#64',2,'match42-top.html#64',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ClientConnection cc : ccs) {
            try {
                sendBuffer(cc.socket);
            } catch (IOException e) {
                clients.remove(cc);
            }
        }</B></FONT>
        super.swapBuffers();
    }

    private void removeClient(ClientConnection cc, IOException e) {
        synchronized (clients) {
            if (clients.contains(cc)) {
                System.out.format(&quot;Disconnecting %s: %s\n&quot;,
                                  cc.descriptor, e.getMessage());
                clients.remove(cc);
            }
        }
    }

    private void sendBuffer(WritableByteChannel out) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(16);
        buffer.order(ByteOrder.BIG_ENDIAN);
        buffer.put((byte) 0);
        buffer.put((byte) 0);
        buffer.putShort((short) 1); // rectangle count
        buffer.putShort((short) 0); // x
        buffer.putShort((short) 0); // y
        buffer.putShort((short) width);
        buffer.putShort((short) height);
        buffer.putInt(0); // raw
        buffer.flip();
        out.write(buffer);
        fb.write(out);
    }

    private class ConnectionAccepter implements Runnable {
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(64);
            buffer.order(ByteOrder.BIG_ENDIAN);
            while (true) {
                try {
                    SocketChannel client = server.accept();
                    System.out.format(&quot;Connection received from %s\n&quot;,
                                      client.getRemoteAddress());
                    // Declare the server protocol version
                    buffer.clear();
                    buffer.put(&quot;RFB 003.003\n&quot;.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    // Read the client protocol version
                    buffer.clear();
                    buffer.limit(12);
                    client.read(buffer);
                    buffer.flip();
                    System.out.format(&quot;Client supports %s\n&quot;,
                                      Charset.forName(&quot;UTF-8&quot;)
                                              .decode(buffer).toString().trim());
                    buffer.clear();
                    buffer.putInt(1); // no authentication
                    buffer.flip();
                    client.write(buffer);
                    buffer.clear();
                    buffer.limit(1);
                    client.read(buffer);
                    System.out.format(&quot;Client share request: %d\n&quot;,
                                      buffer.get(0));
                    buffer.clear();
                    buffer.putShort((short) width);
                    buffer.putShort((short) height);
                    buffer.put((byte) depth);
                    buffer.put((byte) depth);
                    buffer.put((byte) (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN) ? 0 : 1));
                    buffer.put((byte) 1); // true color
                    if (depth == 32) {
                        buffer.putShort((short) 255); // red max
                        buffer.putShort((short) 255); // green max
                        buffer.putShort((short) 255); // blue max
                        buffer.put((byte) 16); // red offset
                        buffer.put((byte) 8); // blue offset
                        buffer.put((byte) 0); // green offset
                    } else {
                        buffer.putShort((byte) (short) 31);
                        buffer.putShort((byte) (short) 63);
                        buffer.putShort((byte) (short) 31);
                        buffer.put((byte) 11);
                        buffer.put((byte) 5);
                        buffer.put((byte) 0);
                    }
                    buffer.put((byte) 0); // padding
                    buffer.put((byte) 0);
                    buffer.put((byte) 0);
                    String name = &quot;JavaFX on &quot; + client.getLocalAddress();
                    buffer.putInt(name.length());
                    buffer.put(name.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    ClientConnection cc = new ClientConnection();
                    cc.socket = client;
                    Thread t = new Thread(cc);
                    t.setDaemon(true);
                    t.setName(&quot;VNC client connection from &quot;
                                      + client.getRemoteAddress());
                    t.start();
                    synchronized (clients) {
                        clients.add(cc);
                    }
                    sendBuffer(client);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private class ClientConnection implements Runnable {
        private SocketChannel socket;
        private String descriptor;
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(32);
            buffer.order(ByteOrder.BIG_ENDIAN);
            try {
                descriptor = socket.getRemoteAddress().toString();
                while (true) {
                    buffer.clear();
                    buffer.limit(4);
                    socket.read(buffer);
                    switch (buffer.get(0)) {
                        case 0: // SetPixelFormat
                            // discard the message in the next 16 bytes
                            buffer.clear();
                            buffer.limit(16);
                            socket.read(buffer);
                            break;
                        case 1: // FixColorMapEntries
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            // discard color map entries
                            int colorMapEntryCount = buffer.getShort(0);
                            for (int i = 0; i &lt; colorMapEntryCount; i++) {
                                buffer.clear();
                                buffer.limit(6);
                                socket.read(buffer);
                            }
                            break;
                        case 2: // SetEncodings
                            // discard encodings
                            int encodingCount = buffer.getShort(2);
                            for (int i = 0; i &lt; encodingCount; i++) {
                                buffer.clear();
                                buffer.limit(4);
                                socket.read(buffer);
                            }
                        case 3: // FramebufferUpdateRequest
                            buffer.clear();
                            buffer.limit(6);
                            socket.read(buffer);
                            Platform.runLater(() -&gt; {
                                try {
                                    if (fb.hasReceivedData()) {
                                        // an update is in progress and will
                                        // be sent on the next call to
                                        // swapBuffers. No need to
                                        // respond to this request.
                                    } else {
                                        sendBuffer(socket);
                                    }
                                } catch (IOException e) {
                                    removeClient(ClientConnection.this, e);
                                }
                            });
                            break;
                        case 4: // KeyEvent
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            break;
                        case 5: { // PointerEvent
                            int x = buffer.getShort(2);
                            buffer.position(1);
                            buffer.limit(2);
                            BitSet buttons = BitSet.valueOf(buffer);
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            int y = buffer.getShort(0);
                            final MouseState state = new MouseState();
                            state.setX(x);
                            state.setY(y);
                            if (buttons.get(0)) {
                                state.pressButton(MouseEvent.BUTTON_LEFT);
                            }
                            if (buttons.get(1)) {
                                state.pressButton(MouseEvent.BUTTON_OTHER);
                            }
                            if (buttons.get(2)) {
                                state.pressButton(MouseEvent.BUTTON_RIGHT);
                            }
                            Platform.runLater(() -&gt; MouseInput.getInstance().setState(state, false));
                            break;
                        }
                        case 6: // ClientCutText
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            int textLength = buffer.getInt(0);
                            for (int i = 0; i &lt; textLength; i++) {
                                buffer.clear();
                                buffer.limit(1);
                                socket.read(buffer);
                            }
                            break;
                        default:
                            System.err.format(
                                    &quot;Unknown message %d from client %s\n&quot;,
                                    buffer.get(0), socket.getRemoteAddress());
                    }
                }
            } catch (IOException e) {
                removeClient(this, e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/win/WinSystemClipboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.win;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.SystemClipboard;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

class WinSystemClipboard extends SystemClipboard {

    private static native void initIDs();
    static {
        initIDs();
    }

    private long ptr = 0L; //native pointer

    protected WinSystemClipboard(String name) {
        super(name);
        create();
    }

    protected final long getPtr() {
        return ptr;
    }

    protected native boolean isOwner();

    protected native void create();
    protected native void dispose();

    /*
     * public mime types to system clipboard
     */
    protected native void push(Object[] keys, int supportedActions);

    /*
     * extract clipboard snap-shot
     */
    protected native boolean pop();

    static final byte[] terminator = new byte[] { 0, 0 };
    static final String defaultCharset = &quot;UTF-16LE&quot;;
    static final String RTFCharset = &quot;US-ASCII&quot;;

    // Called from native code
    private byte[] fosSerialize(String mime, long index) {
        Object data = getLocalData(mime);
        if (data instanceof ByteBuffer) {
            byte[] b = ((ByteBuffer)data).array();
            if (HTML_TYPE.equals(mime)) {
                b = WinHTMLCodec.encode(b);
            }
            return b;
        } else if (data instanceof String) {
            String st = ((String) data).replaceAll(&quot;(\r\n|\r|\n)&quot;, &quot;\r\n&quot;);
            if (HTML_TYPE.equals(mime)) {
                try {
                    // NOTE: Transfer of HTML data on Windows uses UTF-8 encoding!
                    byte[] bytes = st.getBytes(WinHTMLCodec.defaultCharset);
                    ByteBuffer ba = ByteBuffer.allocate(bytes.length + 1);
                    ba.put(bytes);
                    ba.put((byte)0);

                    return WinHTMLCodec.encode(ba.array());
                } catch (UnsupportedEncodingException ex) {
                    // never happen
                    return null;
                }
            } else if (RTF_TYPE.equals(mime)) {
                try {
                    // NOTE: Transfer of RTF data on Windows uses US-ASCII encoding!
                    byte[] bytes = st.getBytes(RTFCharset);
                    ByteBuffer ba = ByteBuffer.allocate(bytes.length + 1);
                    ba.put(bytes);
                    ba.put((byte)0);
                    return ba.array();
                } catch (UnsupportedEncodingException ex) {
                    // could happen on user error
                    return null;
                }
            } else {
                ByteBuffer ba = ByteBuffer.allocate((st.length() + 1) * 2);
                try {
                    ba.put(st.getBytes(defaultCharset));
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
                ba.put(terminator);
                return ba.array();
            }
        } else if (FILE_LIST_TYPE.equals(mime)) {
            String[] ast = ((String[]) data);
            if (ast != null &amp;&amp; ast.length &gt; 0) {
                int size = 0;
                for (String st : ast) {
                    size += (st.length() + 1) * 2;
                }
                size += 2;
                try {
                    ByteBuffer ba = ByteBuffer.allocate(size);
                    for (String st : ast) {
                        ba.put(st.getBytes(defaultCharset));
                        ba.put(terminator);
                    }
                    ba.put(terminator);
                    return ba.array();
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            }
        } else if (RAW_IMAGE_TYPE.equals(mime)) {
            Pixels pxls = (Pixels)data;
            if (pxls != null) {
                ByteBuffer ba = ByteBuffer.allocate(
                        pxls.getWidth() * pxls.getHeight() * 4 + 8);
                ba.putInt(pxls.getWidth());
                ba.putInt(pxls.getHeight());
                ba.put(pxls.asByteBuffer());
                return ba.array();
            }
        }
        //TODO: customizes for OS specific cases
        return null;
    }

    private static final class MimeTypeParser {
        protected static final String externalBodyMime = &quot;message/external-body&quot;;
        protected String mime;
        protected boolean bInMemoryFile;
        protected int index;

        public MimeTypeParser() {
            parse(&quot;&quot;);
        }

        public MimeTypeParser(String mimeFull) {
            parse(mimeFull);
        }

        public void parse(String mimeFull) {
            mime = mimeFull;
            bInMemoryFile = false;
            index = -1;
            //we are limited here by [message/external-body] mime type with clipboard acess-type,
            //because NetBeans has a clipboard format that includes [;]
            if (mimeFull.startsWith(externalBodyMime)) {
                String mimeParts[] = mimeFull.split(&quot;;&quot;);
                String accessType = &quot;&quot;;
                int indexValue = -1;
                //RFC 1521 extension for [message/external-body] mime
                for (int i = 1; i &lt; mimeParts.length; ++i) {
                    String params[] = mimeParts[i].split(&quot;=&quot;);
                    if (params.length == 2) {
                        if( params[0].trim().equalsIgnoreCase(&quot;index&quot;) ) {
                            //that is OK to have the runtime-exception here
                            //we already have a chance to have an exception in WinHTMLCodec
                            indexValue = Integer.parseInt(params[1].trim());
                        } else if( params[0].trim().equalsIgnoreCase(&quot;access-type&quot;) ) {
                            accessType = params[1].trim();
                        }
                    }
                    if (indexValue != -1 &amp;&amp; !accessType.isEmpty()) {
                        //Better to stop here to avoid problem with &quot;index=100.url&quot; filename
                        //it is not a security problem - we can request any index without
                        //buffer overflow or null pointer exception
                        break;
                    }
                }
<A NAME="11"></A>                //we are responsible only for FX synthetic access type!
                if (accessType.equalsIgnoreCase(&quot;clipboard&quot;)) {
                    bInMemoryFile = true;
                    <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#11',2,'match42-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>mime = mimeParts[0];
                    index = indexValue;
                }
            }
        }

        public String getMime() {
            return mime;
        }

        public int getIndex() {
            return</B></FONT> index;
        }

        public boolean isInMemoryFile() {
            return bInMemoryFile;
        }
    }

    protected final void pushToSystem(HashMap&lt;String, Object&gt; cacheData, int supportedActions) {
        Set&lt;String&gt; mimes = cacheData.keySet();
        Set&lt;String&gt; mimesForSystem = new HashSet&lt;String&gt;();
        MimeTypeParser parser = new MimeTypeParser();
        for (String mime : mimes) {
            parser.parse(mime);
            if ( !parser.isInMemoryFile() ) {
                //[message/external-body] mime with [access-type=clipboard]
                //could not be exported to the system due to synthetic nature (Win-API subst),
                //but it could be used for applcation-wide communication
                mimesForSystem.add(mime);
            }
        }
        push(mimesForSystem.toArray(), supportedActions);
    }

    private native byte[] popBytes(String mime, long index);
    protected final Object popFromSystem(String mimeFull) {
        //we have to syncronize with system ones per
        //a popFromSystem function call, because
        //mime type data could be a collection of
        //sub-mimes likes &quot;ms-stuff/XXXX&quot;
        if ( !pop() ) {
            return null;
        }

        MimeTypeParser parser = new MimeTypeParser(mimeFull);
        String mime = parser.getMime();
        byte[] data = popBytes(mime, parser.getIndex());
        if (data != null) {
            if (TEXT_TYPE.equals(mime) || URI_TYPE.equals(mime)) {
                try {
                    // RT-16199 - internal Windows data null terminated
                    return new String(data, 0, data.length - 2, defaultCharset);
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            } else if (HTML_TYPE.equals(mime)) {
                try {
                    data = WinHTMLCodec.decode(data);
                    return new String(data, 0, data.length, WinHTMLCodec.defaultCharset);
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            } else if (RTF_TYPE.equals(mime)) {
                try {
                    return new String(data, 0, data.length, RTFCharset);
                } catch (UnsupportedEncodingException ex) {
                    //can happen for bad system data
                }
            } else if (FILE_LIST_TYPE.equals(mime)) {
                try {
                    String st = new String(data, 0, data.length, defaultCharset);
                    return st.split(&quot;\0&quot;);
                } catch (UnsupportedEncodingException ex) {
                    //never happen
                }
            } else if (RAW_IMAGE_TYPE.equals(mime)) {
                ByteBuffer size = ByteBuffer.wrap(data, 0, 8);
                return Application.GetApplication().createPixels(size.getInt(), size.getInt(),  ByteBuffer.wrap(data, 8, data.length - 8) );
            } else {
                return ByteBuffer.wrap(data);
            }
        } else {
            //alternative extraction if any
            if (URI_TYPE.equals(mime) || TEXT_TYPE.equals(mime)) {
                //try 8bit version
                data = popBytes(mime + &quot;;locale&quot;, parser.getIndex());
                if (data != null) {
                    try {
                        // RT-16199 - internal Windows data null terminated
                        // Here we can request the &quot;ms-stuff/locale&quot; mime data
                        // from GlassClipbord for codepage detection, but
                        // for the most of cases [UTF-8] is ok.
                        return new String(data, 0, data.length - 1, &quot;UTF-8&quot;);
                    } catch (UnsupportedEncodingException ex) {
                        //could happen, but not a problem
                    }
                }
            }
            if (URI_TYPE.equals(mime)) {
                //we are here if [text/uri-list;locale] mime is absent or
                //URL could not be decoded from the [data] as String
                String[] ret = (String[])popFromSystem(FILE_LIST_TYPE);
                if (ret != null) {
                    StringBuilder out = new StringBuilder();
                    //&quot;text/uri-list&quot; spec: http://www.ietf.org/rfc/rfc2483.txt
                    for (int i = 0; i &lt; ret.length; i++) {
                        String fileName = ret[i];
                        fileName = fileName.replace(&quot;\\&quot;, &quot;/&quot;);
                        //fileName = fileName.replace(&quot; &quot;, &quot;%20&quot;);
                        if (out.length() &gt; 0) {
                            out.append(&quot;\r\n&quot;);
                        }
                        out.append(&quot;file:/&quot;).append(fileName);
                    }
                    return out.toString();
                }
            }
        }
        return null;
    }

    private native String[] popMimesFromSystem();
    protected final String[] mimesFromSystem() {
        //we have to syncronize with system
        //if we heed to do it. DnD clipboard need not.
        if (!pop()) {
            return null;
        }
        return popMimesFromSystem();
    }

    @Override public String toString() {
        return &quot;Windows System Clipboard&quot;;
    }

    @Override protected final void close() {
        dispose();
        ptr = 0L;
    }

    @Override protected native void pushTargetActionToSystem(int actionDone);

    private native int popSupportedSourceActions();
    @Override protected int supportedSourceActionsFromSystem() {
        if (!pop()) {
            return ACTION_NONE;
        }
        return popSupportedSourceActions();
   }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/PrismFontFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.io.File;
import java.io.FilenameFilter;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;

import com.sun.glass.ui.Screen;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.text.GlyphLayout;
import static com.sun.javafx.FXPermissions.LOAD_FONT_PERMISSION;

public abstract class PrismFontFactory implements FontFactory {

    public static final boolean debugFonts;
    public static final boolean isWindows;
    public static final boolean isLinux;
    public static final boolean isMacOSX;
    public static final boolean isIOS;
    public static final boolean isAndroid;
    public static final boolean isEmbedded;
    public static final int cacheLayoutSize;
    private static int subPixelMode;
    public static final int SUB_PIXEL_ON = 1;
    public static final int SUB_PIXEL_Y = 2;
    public static final int SUB_PIXEL_NATIVE = 4;
    private static float fontSizeLimit = 80f;

    private static boolean lcdEnabled;
    private static float lcdContrast = -1;
    private static String jreFontDir;
    private static final String jreDefaultFont   = &quot;Lucida Sans Regular&quot;;
    private static final String jreDefaultFontLC = &quot;lucida sans regular&quot;;
    private static final String jreDefaultFontFile = &quot;LucidaSansRegular.ttf&quot;;
    private static final String CT_FACTORY = &quot;com.sun.javafx.font.coretext.CTFactory&quot;;
    private static final String DW_FACTORY = &quot;com.sun.javafx.font.directwrite.DWFactory&quot;;
    private static final String FT_FACTORY = &quot;com.sun.javafx.font.freetype.FTFactory&quot;;

    /* We need two maps. One to hold pointers to the raw fonts, another
     * to hold pointers to the composite resources. Top level look ups
     * to createFont() will look first in the compResourceMap, and
     * only go to the second map to create a wrapped resource.
     * Logical Fonts are handled separately.
     */
    HashMap&lt;String, FontResource&gt; fontResourceMap =
        new HashMap&lt;String, FontResource&gt;();

    HashMap&lt;String, CompositeFontResource&gt; compResourceMap =
        new HashMap&lt;String, CompositeFontResource&gt;();

    static {
        isWindows = PlatformUtil.isWindows();
        isMacOSX  = PlatformUtil.isMac();
        isLinux   = PlatformUtil.isLinux();
        isIOS     = PlatformUtil.isIOS();
        isAndroid = PlatformUtil.isAndroid();
        isEmbedded = PlatformUtil.isEmbedded();
        int[] tempCacheLayoutSize = {0x10000};

        debugFonts = AccessController.doPrivileged(
                (PrivilegedAction&lt;Boolean&gt;) () -&gt; {
                    NativeLibLoader.loadLibrary(&quot;javafx_font&quot;);
                    String dbg = System.getProperty(&quot;prism.debugfonts&quot;, &quot;&quot;);
                    boolean debug = &quot;true&quot;.equals(dbg);
                    jreFontDir = getJDKFontDir();
                    String s = System.getProperty(&quot;com.sun.javafx.fontSize&quot;);
                    systemFontSize = -1f;
                    if (s != null) {
                        try {
                            systemFontSize = Float.parseFloat(s);
                        } catch (NumberFormatException nfe) {
                            System.err.println(&quot;Cannot parse font size '&quot;
                                    + s + &quot;'&quot;);
                        }
                    }
                    s = System.getProperty(&quot;prism.subpixeltext&quot;, &quot;on&quot;);
                    if (s.indexOf(&quot;on&quot;) != -1 || s.indexOf(&quot;true&quot;) != -1) {
                        subPixelMode = SUB_PIXEL_ON;
                    }
                    if (s.indexOf(&quot;native&quot;) != -1) {
                        subPixelMode |= SUB_PIXEL_NATIVE | SUB_PIXEL_ON;
                    }
                    if (s.indexOf(&quot;vertical&quot;) != -1) {
                        subPixelMode |= SUB_PIXEL_Y | SUB_PIXEL_NATIVE | SUB_PIXEL_ON;
                    }

                    s = System.getProperty(&quot;prism.fontSizeLimit&quot;);
                    if (s != null) {
                        try {
                            fontSizeLimit = Float.parseFloat(s);
                            if (fontSizeLimit &lt;= 0) {
                                fontSizeLimit = Float.POSITIVE_INFINITY;
                            }
                        } catch (NumberFormatException nfe) {
                            System.err.println(&quot;Cannot parse fontSizeLimit '&quot; + s + &quot;'&quot;);
                        }
                    }

                    boolean lcdTextOff = isIOS || isAndroid || isEmbedded;
                    String defLCDProp = lcdTextOff ? &quot;false&quot; : &quot;true&quot;;
                    String lcdProp = System.getProperty(&quot;prism.lcdtext&quot;, defLCDProp);
                    lcdEnabled = lcdProp.equals(&quot;true&quot;);

                    s = System.getProperty(&quot;prism.cacheLayoutSize&quot;);
                    if (s != null) {
                        try {
                            tempCacheLayoutSize[0] = Integer.parseInt(s);
                            if (tempCacheLayoutSize[0] &lt; 0) {
                                tempCacheLayoutSize[0] = 0;
                            }
                        } catch (NumberFormatException nfe) {
                            System.err.println(&quot;Cannot parse cache layout size '&quot;
                                    + s + &quot;'&quot;);
                        }
                    }

                    return debug;
                }
        );
        cacheLayoutSize = tempCacheLayoutSize[0];
    }

    private static String getJDKFontDir() {
        return System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator +
                &quot;lib&quot; + File.separator + &quot;fonts&quot;;
    }

    private static String getNativeFactoryName() {
        if (isWindows) return DW_FACTORY;
        if (isMacOSX || isIOS) return CT_FACTORY;
        if (isLinux || isAndroid) return FT_FACTORY;
        return null;
    }

    public static float getFontSizeLimit() {
        return fontSizeLimit;
    }

    private static PrismFontFactory theFontFactory = null;
    public static synchronized PrismFontFactory getFontFactory() {
        if (theFontFactory != null) {
            return theFontFactory;
        }
        String factoryClass = getNativeFactoryName();
        if (factoryClass == null) {
            throw new InternalError(&quot;cannot find a native font factory&quot;);
        }
        if (debugFonts) {
            System.err.println(&quot;Loading FontFactory &quot; + factoryClass);
            if (subPixelMode != 0) {
                String s = &quot;Subpixel: enabled&quot;;
                if ((subPixelMode &amp; SUB_PIXEL_Y) != 0) {
                    s += &quot;, vertical&quot;;
                }
                if ((subPixelMode &amp; SUB_PIXEL_NATIVE) != 0) {
                    s += &quot;, native&quot;;
                }
                System.err.println(s);
            }
        }
        theFontFactory = getFontFactory(factoryClass);
        if (theFontFactory == null) {
            throw new InternalError(&quot;cannot load font factory: &quot;+ factoryClass);
        }
        return theFontFactory;
    }

    private static synchronized PrismFontFactory getFontFactory(String factoryClass) {
        try {
            Class&lt;?&gt; clazz = Class.forName(factoryClass);
            Method mid = clazz.getMethod(&quot;getFactory&quot;, (Class[])null);
            return (PrismFontFactory)mid.invoke(null);
        } catch (Throwable t) {
            if (debugFonts) {
                System.err.println(&quot;Loading font factory failed &quot;+ factoryClass);
            }
        }
        return null;
    }

    private HashMap&lt;String, PrismFontFile&gt;
        fileNameToFontResourceMap = new HashMap&lt;String, PrismFontFile&gt;();

    protected abstract PrismFontFile
          createFontFile(String name, String filename,
                         int fIndex, boolean register,
                         boolean embedded,
                         boolean copy, boolean tracked)
                         throws Exception;

    public abstract GlyphLayout createGlyphLayout();

    // For an caller who has recognised a TTC file and wants to create
    // the instances one at a time so as to have visibility into the
    // contents of the TTC. Onus is on caller to enumerate all the fonts.
    private PrismFontFile createFontResource(String filename, int index) {
        return createFontResource(null, filename, index,
                                  true, false, false, false);
    }

    private PrismFontFile createFontResource(String name,
                                             String filename, int index,
                                             boolean register, boolean embedded,
                                             boolean copy, boolean tracked) {
        String key = (filename+index).toLowerCase();
        PrismFontFile fr = fileNameToFontResourceMap.get(key);
        if (fr != null) {
            return fr;
        }

        try {
            fr = createFontFile(name, filename, index, register,
                                embedded, copy, tracked);
            if (register) {
                storeInMap(fr.getFullName(), fr);
                fileNameToFontResourceMap.put(key, fr);
            }
            return fr;
        } catch (Exception e) {
            if (PrismFontFactory.debugFonts) {
                e.printStackTrace();
            }
            return null;
        }
    }

    private PrismFontFile createFontResource(String name, String filename) {
        PrismFontFile[] pffArr =
            createFontResources(name, filename,
                                true, false, false, false, false);
        if (pffArr == null || pffArr.length == 0) {
           return null;
        } else {
           return pffArr[0];
        }
    }

    private PrismFontFile[] createFontResources(String name, String filename,
                                                boolean register,
                                                boolean embedded,
                                                boolean copy,
                                                boolean tracked,
                                                boolean loadAll) {

        PrismFontFile[] fArr = null;
        if (filename == null) {
            return null;
        }
        PrismFontFile fr = createFontResource(name, filename, 0, register,
                                              embedded, copy, tracked);
        if (fr == null) {
            return null;
        }
        int cnt = (!loadAll) ? 1 : fr.getFontCount();
        fArr = new PrismFontFile[cnt];
        fArr[0] = fr;
        if (cnt == 1) { // Not a TTC, or only requesting one font.
            return fArr;
        }
        PrismFontFile.FileRefCounter rc = null;
        if (copy) {
            rc = fr.createFileRefCounter();
        }
        int index = 1;
        do {
            String key = (filename+index).toLowerCase();
            try {
                fr = fileNameToFontResourceMap.get(key);
                if (fr != null) {
                    fArr[index] = fr;
                    continue;
                } else {
                    fr = createFontFile(null, filename, index,
                                        register, embedded,
                                        copy, tracked);
                    if (fr == null) {
                        return null;
                    }
                    if (rc != null) {
                        fr.setAndIncFileRefCounter(rc);
                    }
                    fArr[index] = fr;
                    String fontname = fr.getFullName();
                    if (register) {
                        storeInMap(fontname, fr);
                        fileNameToFontResourceMap.put(key, fr);
                    }
                }
            } catch (Exception e) {
                if (PrismFontFactory.debugFonts) {
                    e.printStackTrace();
                }
                return null;
            }

        } while (++index &lt; cnt);
        return fArr;
    }

    private String dotStyleStr(boolean bold, boolean italic) {
        if (!bold) {
            if (!italic) {
                return &quot;&quot;;
            }
            else {
                return &quot;.italic&quot;;
            }
        } else {
            if (!italic) {
                return &quot;.bold&quot;;
            }
            else {
                return &quot;.bolditalic&quot;;
            }
        }
    }

    private void storeInMap(String name, FontResource resource) {
        if (name == null || resource == null) {
            return;
        }
        if (resource instanceof PrismCompositeFontResource) {
            System.err.println(name + &quot; is a composite &quot; +
                                            resource);
            Thread.dumpStack();
            return;
        }
        fontResourceMap.put(name.toLowerCase(), resource);
    }

    private ArrayList&lt;WeakReference&lt;PrismFontFile&gt;&gt; tmpFonts;
    synchronized void addDecodedFont(PrismFontFile fr) {
        fr.setIsDecoded(true);
        addTmpFont(fr);
    }

    private synchronized void addTmpFont(PrismFontFile fr) {
        if (tmpFonts == null) {
            tmpFonts = new ArrayList&lt;WeakReference&lt;PrismFontFile&gt;&gt;();
        }
        WeakReference&lt;PrismFontFile&gt; ref;
        /* Registered fonts are enumerable by the application and are
         * expected to persist until VM shutdown.
         * Other fonts - notably ones temporarily loaded in a web page via
         * webview - should be eligible to be collected and have their
         * temp files deleted at any time.
         */
        if (fr.isRegistered()) {
            ref = new WeakReference&lt;PrismFontFile&gt;(fr);
        } else {
            ref = fr.createFileDisposer(this, fr.getFileRefCounter());
        }
        tmpFonts.add(ref);
        addFileCloserHook();
    }

    synchronized void removeTmpFont(WeakReference&lt;PrismFontFile&gt; ref) {
        if (tmpFonts != null) {
            tmpFonts.remove(ref);
        }
    }

    /* familyName is expected to be a physical font family name.
     */
    public synchronized FontResource getFontResource(String familyName,
                                                     boolean bold,
                                                     boolean italic,
                                                     boolean wantComp) {

        if (familyName == null || familyName.isEmpty()) {
            return null;
        }

        String lcFamilyName = familyName.toLowerCase();
        String styleStr = dotStyleStr(bold, italic);
        FontResource fr;

        fr = lookupResource(lcFamilyName+styleStr, wantComp);
        if (fr != null) {
            return fr;
        }


        /* We may have registered this as an embedded font.
         * In which case we should also try to locate it in
         * the non-composite map before looking elsewhere.
         * First look for a font with the exact styles specified.
         * If that fails, look for any font in the family.
         * Later on this should be a lot smarter about finding the best
         * match, but that can wait until we have better style matching
         * for all cases.
         */
        if (embeddedFonts != null &amp;&amp; wantComp) {
            fr = lookupResource(lcFamilyName+styleStr, false);
            if (fr != null) {
                return new PrismCompositeFontResource(fr, lcFamilyName+styleStr);
            }
            for (PrismFontFile embeddedFont : embeddedFonts.values()) {
                String lcEmFamily = embeddedFont.getFamilyName().toLowerCase();
                if (lcEmFamily.equals(lcFamilyName)) {
                    return new PrismCompositeFontResource(embeddedFont,
                                                        lcFamilyName+styleStr);
                }
            }
        }

        /* We have hard coded some of the most commonly used Windows fonts
         * so as to avoid the overhead of doing a lookup via GDI.
         */
        if (isWindows) {
            int style = ((bold ? 1 : 0)) + ((italic) ? 2 : 0);
            String fontFile = WindowsFontMap.findFontFile(lcFamilyName, style);
            if (fontFile != null) {
                fr = createFontResource(null, fontFile);
                if (fr != null) {
                    if (bold == fr.isBold() &amp;&amp; italic == fr.isItalic() &amp;&amp;
                        !styleStr.isEmpty())
                    {
                        storeInMap(lcFamilyName+styleStr, fr);
                    }
                    if (wantComp) {  // wrap with fallback support
                        fr = new PrismCompositeFontResource(fr,
                                                       lcFamilyName+styleStr);
                    }
                    return fr;
                }
            }
        }

        getFullNameToFileMap();
        ArrayList&lt;String&gt; family = familyToFontListMap.get(lcFamilyName);
        if (family == null) {
            return null;
        }

        FontResource plainFR = null, boldFR = null,
            italicFR = null, boldItalicFR = null;
        for (String fontName : family) {
            String lcFontName = fontName.toLowerCase();
            fr = fontResourceMap.get(lcFontName);
            if (fr == null) {
                String file = findFile(lcFontName);
                if (file != null) {
                    fr = getFontResource(fontName, file);
                }
                if (fr == null) {
                    continue;
                }
                storeInMap(lcFontName, fr);
            }
            if (bold == fr.isBold() &amp;&amp; italic == fr.isItalic()) {
                storeInMap(lcFamilyName+styleStr, fr);
                if (wantComp) {  // wrap with fallback support
                    fr = new PrismCompositeFontResource(fr,
                                                      lcFamilyName+styleStr);
                }
                return fr;
            }
            if (!fr.isBold()) {
                if (!fr.isItalic()) {
                    plainFR = fr;
                } else {
                    italicFR = fr;
                }
            } else {
                if (!fr.isItalic()) {
                    boldFR = fr;
                } else {
                    boldItalicFR = fr;
                }
            }
        }

        /* If get here, no perfect match in family. Substitute the
         * closest one we found.
         */
        if (!bold &amp;&amp; !italic) {
            if (boldFR != null) {
                fr = boldFR;
            } else if (italicFR != null) {
                fr = italicFR;
            } else {
                fr = boldItalicFR;
            }
        } else if (bold &amp;&amp; !italic) {
            if (plainFR != null) {
                fr = plainFR;
            } else if (boldItalicFR != null) {
                fr = boldItalicFR;
            } else {
                fr = italicFR;
            }
        } else if (!bold &amp;&amp; italic) {
            if (boldItalicFR != null) {
                fr =  boldItalicFR;
            } else if (plainFR != null) {
                fr = plainFR;
            } else {
                fr = boldFR;
            }
        } else /* (bold &amp;&amp; italic) */ {
            if (italicFR != null) {
                fr = italicFR;
            } else if (boldFR != null) {
                fr = boldFR;
            } else {
                fr = plainFR;
            }
        }
        if (fr != null) {
            storeInMap(lcFamilyName+styleStr, fr);
            if (wantComp) {  // wrap with fallback support
                fr = new PrismCompositeFontResource(fr, lcFamilyName+styleStr);
            }
        }
        return fr;
    }

    public synchronized PGFont createFont(String familyName, boolean bold,
                                          boolean italic, float size) {
        FontResource fr = null;
        if (familyName != null &amp;&amp; !familyName.isEmpty()) {
            PGFont logFont =
                LogicalFont.getLogicalFont(familyName, bold, italic, size);
            if (logFont != null) {
                return logFont;
            }
            fr = getFontResource(familyName, bold, italic, true);
        }

        if (fr == null) {
            // &quot;System&quot; is the default if we didn't recognise the family
            return LogicalFont.getLogicalFont(&quot;System&quot;, bold, italic, size);
        }
        return new PrismFont(fr, fr.getFullName(), size);
    }

    public synchronized PGFont createFont(String name, float size) {

        FontResource fr = null;
        if (name != null &amp;&amp; !name.isEmpty()) {
            PGFont logFont =
                LogicalFont.getLogicalFont(name, size);
            if (logFont != null) {
                return logFont;
            }

            fr = getFontResource(name, null, true);
        }
        if (fr == null) {
            return LogicalFont.getLogicalFont(DEFAULT_FULLNAME, size);
        }
        return new PrismFont(fr, fr.getFullName(), size);
    }

    private PrismFontFile getFontResource(String name, String file) {
        /* caller assures file not null */
        PrismFontFile fr = null;
        /* Still need decode the dfont (event when coretext is used)
         * so that JFXFontFont can read it */
        if (isMacOSX) {
            DFontDecoder decoder = null;
            if (name != null) {
                if (file.endsWith(&quot;.dfont&quot;)) {
                    decoder = new DFontDecoder();
                    try {
                        decoder.openFile();
                        decoder.decode(name);
                        decoder.closeFile();
                        file = decoder.getFile().getPath();
                    } catch (Exception e) {
                        file = null;
                        decoder.deleteFile();
                        decoder = null;
                        if (PrismFontFactory.debugFonts) {
                            e.printStackTrace();
                        }
                    }
                }
            }
            if (file != null) {
                fr = createFontResource(name, file);
            }
            if (decoder != null) {
                if (fr != null) {
                    addDecodedFont(fr);
                } else {
                    decoder.deleteFile();
                }
            }
        } else {
            fr = createFontResource(name, file);
        }
        return fr;
    }

    public synchronized PGFont deriveFont(PGFont font, boolean bold,
                                          boolean italic, float size) {
        FontResource fr = font.getFontResource();
        //TODO honor bold and italic
        return new PrismFont(fr, fr.getFullName(), size);
    }

    private FontResource lookupResource(String lcName, boolean wantComp) {
        if (wantComp) {
            return compResourceMap.get(lcName);
        } else {
            return fontResourceMap.get(lcName);
        }
    }

    public synchronized FontResource getFontResource(String name, String file,
                                                     boolean wantComp) {
        FontResource fr = null;

        // First check if the font is already known.
        if (name != null) {
            String lcName = name.toLowerCase();

            // if requesting a wrapped resource, look in the composite map
            // else look in the physical resource map
            FontResource fontResource = lookupResource(lcName, wantComp);
            if (fontResource != null) {
                return fontResource;
            }

            /* We may have registered this as an embedded font.
             * In which case we should also try to locate it in
             * the non-composite map before looking elsewhere.
             */
            if (embeddedFonts != null &amp;&amp; wantComp) {
                fr = lookupResource(lcName, false);
                if (fr != null) {
                    fr = new PrismCompositeFontResource(fr, lcName);
                }
                if (fr != null) {
                    return fr;
                }
            }
        }

        /* We have hard coded some of the most commonly used Windows fonts
         * so as to avoid the overhead of doing a lookup via GDI.
         */
        if (isWindows &amp;&amp; name != null) {
            String lcName = name.toLowerCase();
            String fontFile = WindowsFontMap.findFontFile(lcName, -1);
            if (fontFile != null) {
                fr = createFontResource(null, fontFile);
                if (fr != null) {
                    if (wantComp) {
                        fr = new PrismCompositeFontResource(fr, lcName);
                    }
                    return fr;
                }
            }
        }

        getFullNameToFileMap(); // init maps

        if (name != null &amp;&amp; file != null) {
            // Typically the TTC case used in font linking.
            // The called method adds the resources to the physical
            // map so no need  to do it here.
            fr = getFontResource(name, file);
            if (fr != null) {
                if (wantComp) {
                    fr = new PrismCompositeFontResource(fr, name.toLowerCase());
                }
                return fr;
            }
        }

        if (name != null) { // Typically normal application lookup
            fr = getFontResourceByFullName(name, wantComp);
            if (fr != null) {
                return fr;
            }
        }

        if (file != null) { // Typically the TTF case used in font linking
            fr = getFontResourceByFileName(file, wantComp);
            if (fr != null) {
                return fr;
            }
        }

        /* can't find the requested font, caller will fall back to default */
        return null;
    }

    boolean isInstalledFont(String fileName) {
        // avoid loading the full windows map. Ignore drive letter
        // as its common to install on D: too in multi-boot.
        String fileKey;
        if (isWindows) {
            if (fileName.toLowerCase().contains(&quot;\\windows\\fonts&quot;)) {
                return true;
            }
            File f = new File(fileName);
            fileKey = f.getName();
        } else {
            if (isMacOSX &amp;&amp; fileName.toLowerCase().contains(&quot;/library/fonts&quot;)) {
                // Most fonts are installed in either /System/Library/Fonts/
                // or /Library/Fonts/
                return true;
            }
            File f = new File(fileName);
            // fileToFontMap key is the full path on non-windows
            fileKey = f.getPath();
        }

        getFullNameToFileMap();
        return fileToFontMap.get(fileKey.toLowerCase()) != null;
    }

    /* To be called only by methods that already inited the maps
     */
    synchronized private FontResource
        getFontResourceByFileName(String file, boolean wantComp) {

        if (fontToFileMap.size() &lt;= 1) {
            return null;
        }

        /* This is a little tricky: we know the file we want but we need
         * to check if its already a loaded resource. The maps are set up
         * to check if a font is loaded by its name, not file.
         * To help I added a map from file-&gt;font for all the windows fonts
         * but that is valid only for TTF fonts (not TTC). So it should only
         * be used in a context where we know its a TTF (or OTF) file.
         */
        String name = fileToFontMap.get(file.toLowerCase()); // basename
        FontResource fontResource = null;
        if (name == null) {
            // We should not normally get here with a name that we did
            // not find from the platform but any EUDC font is in the
            // list of linked fonts but it is not enumerated by Windows.
            // So we need to open the file and load it as requested.
           fontResource = createFontResource(file, 0);
           if (fontResource != null) {
               String lcName = fontResource.getFullName().toLowerCase();
               storeInMap(lcName, fontResource);
               // Checking wantComp, alhough the linked/fallback font
               // case doesn't use this.
                if (wantComp) {
                    fontResource =
                        new PrismCompositeFontResource(fontResource, lcName);
                }
           }
        } else {
            String lcName = name.toLowerCase();
            fontResource = lookupResource(lcName, wantComp);

            if (fontResource == null) {
                String fullPath = findFile(lcName);
                if (fullPath != null) {
                    fontResource = getFontResource(name, fullPath);
                    if (fontResource != null) {
                        storeInMap(lcName, fontResource);
                    }
                    if (wantComp) {
                        // wrap with fallback support
                        fontResource =
                                new PrismCompositeFontResource(fontResource, lcName);
                    }
                }
            }
        }
        return fontResource; // maybe null
    }

    /* To be called only by methods that already inited the maps
     * and checked the font is not already loaded.
     */
    synchronized private FontResource
        getFontResourceByFullName(String name, boolean wantComp) {

        String lcName = name.toLowerCase();

        if (fontToFileMap.size() &lt;= 1) {
            // Do this even though findFile also fails over to Lucida, as
            // without this step, we'd create new instances.
            name = jreDefaultFont;
        }

        FontResource fontResource = null;
        String file = findFile(lcName);
        if (file != null) {
            fontResource = getFontResource(name, file);
            if (fontResource != null) {
                storeInMap(lcName, fontResource);
                if (wantComp) {
                    // wrap with fallback support
                    fontResource =
                        new PrismCompositeFontResource(fontResource, lcName);
                }
            }
        }
        return fontResource;
    }

    FontResource getDefaultFontResource(boolean wantComp) {
        FontResource fontResource = lookupResource(jreDefaultFontLC, wantComp);
        if (fontResource == null) {
            fontResource = createFontResource(jreDefaultFont,
                                              jreFontDir+jreDefaultFontFile);
            if (fontResource == null) {
                // Normally use the JRE default font as the last fallback.
                // If we can't find even that, use any platform font;
                for (String font : fontToFileMap.keySet()) {
                    String file = findFile(font); // gets full path
                    fontResource = createFontResource(jreDefaultFontLC, file);
                    if (fontResource != null) {
                        break;
                    }
                }
                if (fontResource == null &amp;&amp; isLinux) {
                    String path = FontConfigManager.getDefaultFontPath();
                    if (path != null) {
                        fontResource = createFontResource(jreDefaultFontLC,
                                                          path);
                    }
                }
                if (fontResource == null) {
                    return null; // We tried really hard!
                }
            }
            storeInMap(jreDefaultFontLC, fontResource);
            if (wantComp) {  // wrap primary for map key
                fontResource =
                    new PrismCompositeFontResource(fontResource,
                                                 jreDefaultFontLC);
            }
        }
        return fontResource;
    }

    private String findFile(String name) {

        if (name.equals(jreDefaultFontLC)) {
            return jreFontDir+jreDefaultFontFile;
        }
        getFullNameToFileMap();
        String filename = fontToFileMap.get(name);
        if (isWindows) {
            filename = getPathNameWindows(filename);
        }

        // Caller needs to check for null and explicitly request
        // the JRE default font, if that is what is needed.
        // since we don't want the JRE's Lucida font to be the
        // default for &quot;unknown&quot; fonts.
        return filename;
    }

    /* Used to indicate required return type from toArray(..); */
    private static final String[] STR_ARRAY = new String[0];

    /* Obtained from Platform APIs (windows only)
     * Map from lower-case font full name to basename of font file.
     * Eg &quot;arial bold&quot; -&gt; ARIALBD.TTF.
     * For TTC files, there is a mapping for each font in the file.
     */
    private volatile HashMap&lt;String,String&gt; fontToFileMap = null;

    /*  TTF/OTF Font File to Font Full Name */
    private HashMap&lt;String,String&gt; fileToFontMap = null;

    /* Obtained from Platform APIs (windows only)
     * Map from lower-case font full name to the name of its font family
     * Eg &quot;arial bold&quot; -&gt; &quot;Arial&quot;
     */
    private HashMap&lt;String,String&gt; fontToFamilyNameMap = null;

    /* Obtained from Platform APIs (windows only)
     * Map from a lower-case family name to a list of full names of
     * the member fonts, eg:
     * &quot;arial&quot; -&gt; [&quot;Arial&quot;, &quot;Arial Bold&quot;, &quot;Arial Italic&quot;,&quot;Arial Bold Italic&quot;]
     */
    private HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap= null;


    /* For a terminal server there may be two font directories */
    private static String sysFontDir = null;
    private static String userFontDir = null;

    private static native byte[] getFontPath();
    private static native String regReadFontLink(String searchfont);
    private static native String getEUDCFontFile();

    private static void getPlatformFontDirs() {

        if (userFontDir != null || sysFontDir != null) {
            return;
        }
        byte [] pathBytes = getFontPath();
        String path = new String(pathBytes);

        int scIdx = path.indexOf(';');
        if (scIdx &lt; 0) {
            sysFontDir = path;
        } else {
            sysFontDir = path.substring(0, scIdx);
            userFontDir = path.substring(scIdx+1, path.length());
        }
    }

    /**
      * This will return an array of size 2, each element being an array
      * list of &lt;code&gt;String&lt;/code&gt;. The first (zeroth) array holds file
      * names, and, the second array holds the corresponding fontnames.
      * If the file does not have a corresponding font name, its corresponding
      * name is assigned an empty string &quot;&quot;.
      * As a further complication, Windows 7 frequently lists a font twice,
      * once with some scaling values, and again without. We don't use this
      * so find these and exclude duplicates.
      */
    static ArrayList&lt;String&gt; [] getLinkedFonts(String searchFont,
                                               boolean addSearchFont) {


        ArrayList&lt;String&gt; [] fontRegInfo = new ArrayList[2];
        // index 0 = file names, 1 = font name.
        // the name is only specified for TTC files.
        fontRegInfo[0] = new ArrayList&lt;String&gt;();
        fontRegInfo[1] = new ArrayList&lt;String&gt;();

        if (isMacOSX) {
            // Hotkey implementation of fallback font on Mac
            fontRegInfo[0].add(&quot;/Library/Fonts/Arial Unicode.ttf&quot;);
            fontRegInfo[1].add(&quot;Arial Unicode MS&quot;);

            // Add Lucida Sans Regular to Mac OS X fallback list
            fontRegInfo[0].add(jreFontDir + jreDefaultFontFile);
            fontRegInfo[1].add(jreDefaultFont);

            // Add Apple Symbols to Mac OS X fallback list
            fontRegInfo[0].add(&quot;/System/Library/Fonts/Apple Symbols.ttf&quot;);
            fontRegInfo[1].add(&quot;Apple Symbols&quot;);

            // Add Apple Emoji Symbols to Mac OS X fallback list
            fontRegInfo[0].add(&quot;/System/Library/Fonts/Apple Color Emoji.ttc&quot;);
            fontRegInfo[1].add(&quot;Apple Color Emoji&quot;);

            // Add CJK Ext B supplementary characters.
            fontRegInfo[0].add(&quot;/System/Library/Fonts/STHeiti Light.ttf&quot;);
            fontRegInfo[1].add(&quot;Heiti SC Light&quot;);

            return fontRegInfo;
        }
        if (!isWindows) {
            return fontRegInfo;
        }

        if (addSearchFont) {
            fontRegInfo[0].add(null);
            fontRegInfo[1].add(searchFont);
        }

        String fontRegBuf = regReadFontLink(searchFont);
        if (fontRegBuf != null &amp;&amp; fontRegBuf.length() &gt; 0) {
            // split registry data into null terminated strings
            String[] fontRegList = fontRegBuf.split(&quot;\u0000&quot;);
            int linkListLen = fontRegList.length;
            for (int i=0; i &lt; linkListLen; i++) {
                String[] splitFontData = fontRegList[i].split(&quot;,&quot;);
                int len = splitFontData.length;
                String file = getPathNameWindows(splitFontData[0]);
                String name = (len &gt; 1) ? splitFontData[1] : null;
                if (name != null &amp;&amp; fontRegInfo[1].contains(name)) {
                    continue;
                } else if (name == null &amp;&amp; fontRegInfo[0].contains(file)) {
                    continue;
                }
                fontRegInfo[0].add(file);
                fontRegInfo[1].add(name);
            }
        }

        String eudcFontFile = getEUDCFontFile();
        if (eudcFontFile != null) {
            fontRegInfo[0].add(eudcFontFile);
            fontRegInfo[1].add(null);
        }

        // Add Lucida Sans Regular to Windows fallback list
        fontRegInfo[0].add(jreFontDir + jreDefaultFontFile);
        fontRegInfo[1].add(jreDefaultFont);

        if (PlatformUtil.isWinVistaOrLater()) {
            // CJK Ext B Supplementary character fallbacks.
            fontRegInfo[0].add(getPathNameWindows(&quot;mingliub.ttc&quot;));
            fontRegInfo[1].add(&quot;MingLiU-ExtB&quot;);

            if (PlatformUtil.isWin7OrLater()) {
                // Add Segoe UI Symbol to Windows 7 or later fallback list
                fontRegInfo[0].add(getPathNameWindows(&quot;seguisym.ttf&quot;));
                fontRegInfo[1].add(&quot;Segoe UI Symbol&quot;);
            } else {
                // Add Cambria Math to Windows Vista fallback list
                fontRegInfo[0].add(getPathNameWindows(&quot;cambria.ttc&quot;));
                fontRegInfo[1].add(&quot;Cambria Math&quot;);
            }
        }
        return fontRegInfo;
    }

    /* This is needed since some windows registry names don't match
     * the font names.
     * - UPC styled font names have a double space, but the
     * registry entry mapping to a file doesn't.
     * - Marlett is in a hidden file not listed in the registry
     * - The registry advertises that the file david.ttf contains a
     * font with the full name &quot;David Regular&quot; when in fact its
     * just &quot;David&quot;.
     * Directly fix up these known cases as this is faster.
     * If a font which doesn't match these known cases has no file,
     * it may be a font that has been temporarily added to the known set
     * or it may be an installed font with a missing registry entry.
     * Installed fonts are those in the windows font directories.
     * Make a best effort attempt to locate these.
     * We obtain the list of TrueType fonts in these directories and
     * filter out all the font files we already know about from the registry.
     * What remains may be &quot;bad&quot; fonts, duplicate fonts, or perhaps the
     * missing font(s) we are looking for.
     * Open each of these files to find out.
     */
    private void resolveWindowsFonts
        (HashMap&lt;String,String&gt; fontToFileMap,
         HashMap&lt;String,String&gt; fontToFamilyNameMap,
         HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap) {

        ArrayList&lt;String&gt; unmappedFontNames = null;
        for (String font : fontToFamilyNameMap.keySet()) {
            String file = fontToFileMap.get(font);
            if (file == null) {
                int dsi = font.indexOf(&quot;  &quot;);
                if (dsi &gt; 0) {
                    String newName = font.substring(0, dsi);
                    newName = newName.concat(font.substring(dsi+1));
                    file = fontToFileMap.get(newName);
                    /* If this name exists and isn't for a valid name
                     * replace the mapping to the file with this font
                     */
                    if (file != null &amp;&amp;
                        !fontToFamilyNameMap.containsKey(newName)) {
                        fontToFileMap.remove(newName);
                        fontToFileMap.put(font, file);
                    }
                } else if (font.equals(&quot;marlett&quot;)) {
                    fontToFileMap.put(font, &quot;marlett.ttf&quot;);
                } else if (font.equals(&quot;david&quot;)) {
                    file = fontToFileMap.get(&quot;david regular&quot;);
                    if (file != null) {
                        fontToFileMap.remove(&quot;david regular&quot;);
                        fontToFileMap.put(&quot;david&quot;, file);
                    }
                } else {
                    if (unmappedFontNames == null) {
                        unmappedFontNames = new ArrayList&lt;String&gt;();
                    }
                    unmappedFontNames.add(font);
                }
            }
        }

        if (unmappedFontNames != null) {
            HashSet&lt;String&gt; unmappedFontFiles = new HashSet&lt;String&gt;();

            // Used HashMap.clone() on SE but TV didn't support it.
            HashMap&lt;String,String&gt; ffmapCopy = new HashMap&lt;String,String&gt;();
            ffmapCopy.putAll(fontToFileMap);
            for (String key : fontToFamilyNameMap.keySet()) {
                ffmapCopy.remove(key);
            }
            for (String key : ffmapCopy.keySet()) {
                unmappedFontFiles.add(ffmapCopy.get(key));
                fontToFileMap.remove(key);
            }
            resolveFontFiles(unmappedFontFiles,
                             unmappedFontNames,
                             fontToFileMap,
                             fontToFamilyNameMap,
                             familyToFontListMap);

            /* remove from the set of names that will be returned to the
             * user any fonts that can't be mapped to files.
             */
            if (unmappedFontNames.size() &gt; 0) {
                int sz = unmappedFontNames.size();
                for (int i=0; i&lt;sz; i++) {
                    String name = unmappedFontNames.get(i);
                    String familyName = fontToFamilyNameMap.get(name);
                    if (familyName != null) {
                        ArrayList&lt;String&gt; family = familyToFontListMap.get(familyName);
                        if (family != null) {
                            if (family.size() &lt;= 1) {
                                familyToFontListMap.remove(familyName);
                            }
                        }
                    }
                    fontToFamilyNameMap.remove(name);
                }
            }
        }
    }

    private void resolveFontFiles(HashSet&lt;String&gt; unmappedFiles,
         ArrayList&lt;String&gt; unmappedFonts,
         HashMap&lt;String,String&gt; fontToFileMap,
         HashMap&lt;String,String&gt; fontToFamilyNameMap,
         HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap) {

        for (String file : unmappedFiles) {
            try {
                int fn = 0;
                PrismFontFile ttf;
                String fullPath = getPathNameWindows(file);
                do {
                    ttf = createFontResource(fullPath, fn++);
                    if (ttf == null) {
                        break;
                    }
                    String fontNameLC = ttf.getFullName().toLowerCase();
                    String localeNameLC =ttf.getLocaleFullName().toLowerCase();
                    if (unmappedFonts.contains(fontNameLC) ||
                        unmappedFonts.contains(localeNameLC)) {
                        fontToFileMap.put(fontNameLC, file);
                        unmappedFonts.remove(fontNameLC);
                        /* If GDI reported names using locale specific style
                         * strings we'll have those as the unmapped keys in
                         * the font to family list and also in the value
                         * array list mapped by the family.
                         * We can spot these if the localeName is what is
                         * actually in the unmapped font list, and we'll
                         * then replace all occurrences of the locale name with
                         * the English name.
                         */
                        if (unmappedFonts.contains(localeNameLC)) {
                            unmappedFonts.remove(localeNameLC);
                            String family = ttf.getFamilyName();
                            String familyLC = family.toLowerCase();
                            fontToFamilyNameMap.remove(localeNameLC);
                            fontToFamilyNameMap.put(fontNameLC, family);
                            ArrayList&lt;String&gt; familylist =
                                familyToFontListMap.get(familyLC);
                            if (familylist != null) {
                                familylist.remove(ttf.getLocaleFullName());
                            } else {
                                /* The family name was not English.
                                 * Remove the non-English family list
                                 * and replace it with the English one
                                 */
                                String localeFamilyLC =
                                    ttf.getLocaleFamilyName().toLowerCase();
                                familylist =
                                    familyToFontListMap.get(localeFamilyLC);
                                if (familylist != null) {
                                    familyToFontListMap.remove(localeFamilyLC);
                                }
                                familylist = new ArrayList&lt;String&gt;();
                                familyToFontListMap.put(familyLC, familylist);
                            }
                            familylist.add(ttf.getFullName());
                        }
                    }

                }
                while (fn &lt; ttf.getFontCount());
            } catch (Exception e) {
                if (debugFonts) {
                    e.printStackTrace();
                }
            }
        }
    }

    static native void
        populateFontFileNameMap(HashMap&lt;String,String&gt; fontToFileMap,
                                 HashMap&lt;String,String&gt; fontToFamilyNameMap,
                                 HashMap&lt;String,ArrayList&lt;String&gt;&gt;
                                     familyToFontListMap,
                                 Locale locale);

    static String getPathNameWindows(final String filename) {
        if (filename == null) {
            return null;
        }

        getPlatformFontDirs();
        File f = new File(filename);
        if (f.isAbsolute()) {
            return filename;
        }
        if (userFontDir == null) {
            return sysFontDir+&quot;\\&quot;+filename;
        }

        String path = AccessController.doPrivileged(
            new PrivilegedAction&lt;String&gt;() {
                public String run() {
                    File f = new File(sysFontDir+&quot;\\&quot;+filename);
                    if (f.exists()) {
                        return f.getAbsolutePath();
                    }
                    else {
                        return userFontDir+&quot;\\&quot;+filename;
                    }
                }
            });

            if (path != null) {
                return path;
            }
        return null; //  shouldn't happen.
    }

    private static ArrayList&lt;String&gt; allFamilyNames;
    public String[] getFontFamilyNames() {
        if (allFamilyNames == null) {
            /* Create an array list and add the families for :
             * - logical fonts
             * - Embedded fonts
             * - Fonts found on the platform (includes JRE fonts)..
             */
            ArrayList&lt;String&gt; familyNames = new ArrayList&lt;String&gt;();
            LogicalFont.addFamilies(familyNames);
            //  Putting this in here is dependendent on the FontLoader
            // loading embedded fonts before calling into here. If
            // embedded fonts can be added then we need to add these
            // dynamically for each call to this method.

            if (embeddedFonts != null) {
                for (PrismFontFile embeddedFont : embeddedFonts.values()) {
                    if (!familyNames.contains(embeddedFont.getFamilyName()))
                        familyNames.add(embeddedFont.getFamilyName());
                }
            }
            getFullNameToFileMap();
            for (String f : fontToFamilyNameMap.values()) {
                if (!familyNames.contains(f)) {
                    familyNames.add(f);
                }
            }
            Collections.sort(familyNames);
            allFamilyNames = new ArrayList&lt;String&gt;(familyNames);
        }
        return allFamilyNames.toArray(STR_ARRAY);
    }

    private static ArrayList&lt;String&gt; allFontNames;
    public String[] getFontFullNames() {
        if (allFontNames == null) {
            /* Create an array list and add
             * - logical fonts
             * - Embedded fonts
             * - Fonts found on the platform (includes JRE fonts).
             */
            ArrayList&lt;String&gt; fontNames = new ArrayList&lt;String&gt;();
            LogicalFont.addFullNames(fontNames);
            if (embeddedFonts != null) {
                for (PrismFontFile embeddedFont : embeddedFonts.values()) {
                    if (!fontNames.contains(embeddedFont.getFullName())) {
                        fontNames.add(embeddedFont.getFullName());
                    }
                }
            }
            getFullNameToFileMap();
            for (ArrayList&lt;String&gt; a : familyToFontListMap.values()) {
                for (String s : a) {
                    fontNames.add(s);
                }
            }
            Collections.sort(fontNames);
            allFontNames = fontNames;
        }
        return allFontNames.toArray(STR_ARRAY);
    }

    public String[] getFontFullNames(String family) {

        // First check if its a logical font family.
        String[] logFonts = LogicalFont.getFontsInFamily(family);
        if (logFonts != null) {
            // Caller will clone/wrap this before returning it to API
            return logFonts;
        }
        // Next check if its an embedded font family
        if (embeddedFonts != null) {
            ArrayList&lt;String&gt; embeddedFamily = null;
            for (PrismFontFile embeddedFont : embeddedFonts.values()) {
                if (embeddedFont.getFamilyName().equalsIgnoreCase(family)) {
                    if (embeddedFamily == null) {
                        embeddedFamily = new ArrayList&lt;String&gt;();
                    }
                    embeddedFamily.add(embeddedFont.getFullName());
                }
            }
            if (embeddedFamily != null) {
                return embeddedFamily.toArray(STR_ARRAY);
            }
        }

        getFullNameToFileMap();
        family = family.toLowerCase();
        ArrayList&lt;String&gt; familyFonts = familyToFontListMap.get(family);
        if (familyFonts != null) {
            return familyFonts.toArray(STR_ARRAY);
        } else {
            return STR_ARRAY; // zero-length therefore immutable.
        }
    }

    public final int getSubPixelMode() {
        return subPixelMode;
    }

    public boolean isLCDTextSupported() {
        return lcdEnabled;
    }

    @Override
    public boolean isPlatformFont(String name) {
        if (name == null) return false;
        /* Using String#startsWith as name can be either a fullName or a family name */
        String lcName = name.toLowerCase();
        if (LogicalFont.isLogicalFont(lcName)) return true;
        if (lcName.startsWith(&quot;lucida sans&quot;)) return true;
        String systemFamily = getSystemFont(LogicalFont.SYSTEM).toLowerCase();
        if (lcName.startsWith(systemFamily)) return true;
        return false;
    }

    public static boolean isJreFont(FontResource fr) {
        String file = fr.getFileName();
        return file.startsWith(jreFontDir);
    }

    public static float getLCDContrast() {
        if (lcdContrast == -1) {
            if (isWindows) {
                lcdContrast = getLCDContrastWin32() / 1000f;
            } else {
                /* REMIND: When using CoreText it likely already applies gamma
                 * correction to the glyph images. The current implementation does
                 * not take this into account when rasterizing the glyph. Thus,
                 * it is possible gamma correction is been applied twice to the
                 * final result.
                 * Consider using &quot;1&quot; for lcdContrast possibly produces visually
                 * more appealing results (although not strictly correct).
                 */
                lcdContrast = 1.3f;
            }
        }
        return lcdContrast;
    }

    private static Thread fileCloser = null;

    private synchronized void addFileCloserHook() {
        if (fileCloser == null) {
            final Runnable fileCloserRunnable = () -&gt; {
                if (embeddedFonts != null) {
                    for (PrismFontFile font : embeddedFonts.values()) {
                        font.disposeOnShutdown();
                    }
                }
                if (tmpFonts != null) {
                    for (WeakReference&lt;PrismFontFile&gt; ref : tmpFonts) {
                        PrismFontFile font = ref.get();
                        if (font != null) {
                            font.disposeOnShutdown();
                        }
                    }
                }
            };
            java.security.AccessController.doPrivileged(
                    (PrivilegedAction&lt;Object&gt;) () -&gt; {
                        /* The thread must be a member of a thread group
                         * which will not get GCed before VM exit.
                         * Make its parent the top-level thread group.
                         */
                        ThreadGroup tg = Thread.currentThread().getThreadGroup();
                        for (ThreadGroup tgn = tg;
                             tgn != null; tg = tgn, tgn = tg.getParent());
                        fileCloser = new Thread(tg, fileCloserRunnable);
                        fileCloser.setContextClassLoader(null);
                        Runtime.getRuntime().addShutdownHook(fileCloser);
                        return null;
                    }
            );
        }
    }

    private HashMap&lt;String, PrismFontFile&gt; embeddedFonts;

    public PGFont[] loadEmbeddedFont(String name, InputStream fontStream,
                                     float size,
                                     boolean register,
                                     boolean loadAll) {
        if (!hasPermission()) {
            return new PGFont[] { createFont(DEFAULT_FULLNAME, size) } ;
        }
        if (FontFileWriter.hasTempPermission()) {
            return loadEmbeddedFont0(name, fontStream, size, register, loadAll);
        }

        // Otherwise, be extra conscious of pending temp file creation and
        // resourcefully handle the temp file resources, among other things.
        FontFileWriter.FontTracker tracker =
            FontFileWriter.FontTracker.getTracker();
        boolean acquired = false;
        try {
            acquired = tracker.acquirePermit();
            if (!acquired) {
                // Timed out waiting for resources.
                return null;
            }
            return loadEmbeddedFont0(name, fontStream, size, register, loadAll);
        } catch (InterruptedException e) {
            // Interrupted while waiting to acquire a permit.
            return null;
        } finally {
            if (acquired) {
                tracker.releasePermit();
            }
        }
    }

    private PGFont[] loadEmbeddedFont0(String name, InputStream fontStream,
                                       float size,
                                       boolean register,
                                       boolean loadAll) {
        PrismFontFile[] fr = null;
        FontFileWriter fontWriter = new FontFileWriter();
        try {
            // We use a shutdown hook to close all open tmp files
            // created via this API and delete them.
            final File tFile = fontWriter.openFile();
            byte[] buf = new byte[8192];
            for (;;) {
                int bytesRead = fontStream.read(buf);
                if (bytesRead &lt; 0) {
                    break;
                }
                fontWriter.writeBytes(buf, 0, bytesRead);
            }
            fontWriter.closeFile();

            fr = loadEmbeddedFont1(name, tFile.getPath(), register, true,
                                   fontWriter.isTracking(), loadAll);

            if (fr != null &amp;&amp; fr.length &gt; 0) {
                /* Delete the file downloaded if it was decoded
                 * to another file */
                if (fr[0].isDecoded()) {
                    fontWriter.deleteFile();
                }
            }

            /* We don't want to leave the temp files around after exit.
             * Also in a shared applet-type context, after all references to
             * the applet and therefore the font are dropped, the file
             * should be removed. This isn't so much an issue so long as
             * the VM exists to serve a single FX app, but will be
             * important in an app-context model.
             * But also fonts that are over-written by new versions
             * need to be cleaned up and that applies even in the single
             * context.
             * We also need to decrement the byte count by the size
             * of the file.
             */
            addFileCloserHook();
        } catch (Exception e) {
            fontWriter.deleteFile();
        } finally {
            /* If the data isn't a valid font, so that registering it
             * returns null, or we didn't get so far as copying the data,
             * delete the tmp file and decrement the byte count
             * in the tracker object before returning.
             */
            if (fr == null) {
                fontWriter.deleteFile();
            }
        }
        if (fr != null &amp;&amp; fr.length &gt; 0) {
            if (size &lt;= 0) size = getSystemFontSize();
            int num = fr.length;
            PrismFont[] pFonts = new PrismFont[num];
            for (int i=0; i&lt;num; i++) {
                pFonts[i] = new PrismFont(fr[i], fr[i].getFullName(), size);
            }
            return pFonts;
        }
        return null;
    }

    /**
     * registerEmbeddedFont(String name, String path) is a small subset of
     * registerEmbeddedFont(String name, InputStream fontStream)
     * It does not attempt to create a temporary file and has different
     * parameters.
     *
     * @param name font name
     * @param path Path name to system file
     * @param size font size
     * @param register whether the font should be registered.
     * @param loadAll whether to load all fonts if it is a TTC
     * @return font name extracted from font file
     */
    public PGFont[] loadEmbeddedFont(String name, String path,
                                     float size,
                                     boolean register,
                                     boolean loadAll) {
        if (!hasPermission()) {
            return new PGFont[] { createFont(DEFAULT_FULLNAME, size) };
        }
        addFileCloserHook();
        FontResource[] frArr =
          loadEmbeddedFont1(name, path, register, false, false, loadAll);
        if (frArr != null &amp;&amp; frArr.length &gt; 0) {
            if (size &lt;= 0) size = getSystemFontSize();
            int num = frArr.length;
            PGFont[] pgFonts = new PGFont[num];
            for (int i=0; i&lt;num; i++) {
                pgFonts[i] =
                    new PrismFont(frArr[i], frArr[i].getFullName(), size);
            }
            return pgFonts;
        }
        return null;
    }

    /* This should make the embedded font eligible for reclaimation
     * and subsequently, disposal of native resources, once any existing
     * strong refs by the application are released.
     */
    private void removeEmbeddedFont(String name) {
        PrismFontFile font = embeddedFonts.get(name);
        if (font == null) {
            return;
        }
        embeddedFonts.remove(name);
        String lcName = name.toLowerCase();
        fontResourceMap.remove(lcName);
        compResourceMap.remove(lcName);
        // The following looks tedious, but if the compMap could have
        // the font referenced via some lookup name that applies a style
        // or used the family name, we need to find it and remove all
        // references to it, so it can be collected.
        Iterator&lt;CompositeFontResource&gt; fi = compResourceMap.values().iterator();
            while (fi.hasNext()) {
            CompositeFontResource compFont = fi.next();
            if (compFont.getSlotResource(0) == font) {
                fi.remove();
            }
        }
    }

    protected boolean registerEmbeddedFont(String path) {
        return true;
    }

    // Used for testing
    private int numEmbeddedFonts = 0;
    public int test_getNumEmbeddedFonts() {
        return numEmbeddedFonts;
    }

    private synchronized
        PrismFontFile[] loadEmbeddedFont1(String name, String path,
                                          boolean register, boolean copy,
                                          boolean tracked, boolean loadAll) {

        ++numEmbeddedFonts;
        /*
         * Fonts that aren't platform installed include those in the
         * application jar, WOFF fonts that are downloaded, and fonts
         * created via Font.loadFont. If copy==true, we can infer its
         * one of these, but its also possible for a font to be file-system
         * installed as part of the application but not known to the
         * platform. In this case copy==false, but we still need to flag
         * to the system its not a platform font so that other pipelines
         * know to reference the file directly.
         */
        PrismFontFile[] frArr = createFontResources(name, path, register,
                                                    true, copy, tracked,
                                                    loadAll);
        if (frArr == null || frArr.length == 0) {
            return null; // yes, this means the caller needs to handle null.
        }

        /* Before we return or register, make sure names are present
         * check whether any of the fonts duplicate an OS font.
         */

        if (embeddedFonts == null) {
            embeddedFonts = new HashMap&lt;String, PrismFontFile&gt;();
        }

        boolean registerEmbedded = true;
        for (int i=0; i&lt;frArr.length; i++) {
            PrismFontFile fr = frArr[i];
            String family = fr.getFamilyName();
            if (family == null || family.length() == 0) return null;
            String fullname = fr.getFullName();
            if (fullname == null || fullname.length() == 0) return null;
            String psname = fr.getPSName();
            if (psname == null || psname.length() == 0) return null;

            FontResource resource = embeddedFonts.get(fullname);
            if (resource != null &amp;&amp; fr.equals(resource)) {
                /* Do not register the same font twice in the OS */
                registerEmbedded = false;
            }
        }

        if (registerEmbedded) {
            /* Use filename from the resource so woff fonts are handled */
            if (!registerEmbeddedFont(frArr[0].getFileName())) {
                /* This font file can't be used by the underlying rasterizer */
                return null;
            }
        }

        /* If a temporary font is a copy but it is not decoded then it
         * will not be anywhere the shutdown hook can see.
         * That means if the font is keep for the entire life of the VM
         * its file will not be deleted.
         * The fix is to add this font to the list of temporary fonts.
         */
        if (copy &amp;&amp; !frArr[0].isDecoded()) {
            addTmpFont(frArr[0]);
        }

        if (!register) {
            return frArr;
        }

        /* If a font name is provided then we will also store that in the
         * map as an alias, otherwise should use the only the real name,
         * REMIND: its possible that either name may hide some installed
         * version of the font, possibly one we haven't seen yet. But
         * without loading all the platform fonts (expensive) this is
         * difficult to ascertain. A contains() check here is therefore
         * probably mostly futile.
         */
        if (name != null &amp;&amp; !name.isEmpty()) {
            embeddedFonts.put(name, frArr[0]);
            storeInMap(name, frArr[0]);
        }

        for (int i=0; i&lt;frArr.length; i++) {
            PrismFontFile fr = frArr[i];
            String family = fr.getFamilyName();
            String fullname = fr.getFullName();
            removeEmbeddedFont(fullname);
            embeddedFonts.put(fullname, fr);
            storeInMap(fullname, fr);
            family = family + dotStyleStr(fr.isBold(), fr.isItalic());
            storeInMap(family, fr);
            /* The remove call is to assist the case where we have
             * previously mapped into the composite map a different style
             * in this family as a partial match for the application request.
             * This can occur when an application requested a bold font before
             * it called Font.loadFont to register the bold font. It won't
             * fix the cases that already happened, but will fix the future ones.
             */
            compResourceMap.remove(family.toLowerCase());
        }
        return frArr;
    }

    private void
        logFontInfo(String message,
                    HashMap&lt;String,String&gt; fontToFileMap,
                    HashMap&lt;String,String&gt; fontToFamilyNameMap,
                    HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap) {

        System.err.println(message);
        for (String keyName : fontToFileMap.keySet()) {
<A NAME="78"></A>            System.err.println(&quot;font=&quot;+keyName+&quot; file=&quot;+
                               fontToFileMap.get(keyName));
        }
        <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#78',2,'match42-top.html#78',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (String keyName : fontToFamilyNameMap.keySet()) {
            System.err.println(&quot;font=&quot;+keyName+&quot; family=&quot;+
                               fontToFamilyNameMap.get(keyName));
        }
        for (String keyName : familyToFontListMap.keySet()) {
            System.err.println(&quot;family=&quot;+keyName+ &quot; fonts=&quot;+
                               familyToFontListMap.get(keyName));
        }
    }

    private synchronized HashMap&lt;String,String&gt; getFullNameToFileMap() {</B></FONT>
        if (fontToFileMap == null) {

            HashMap&lt;String, String&gt;
                tmpFontToFileMap = new HashMap&lt;String,String&gt;(100);
            fontToFamilyNameMap = new HashMap&lt;String,String&gt;(100);
            familyToFontListMap = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;(50);
            fileToFontMap = new HashMap&lt;String,String&gt;(100);

            if (isWindows) {
                getPlatformFontDirs();
                populateFontFileNameMap(tmpFontToFileMap,
                                        fontToFamilyNameMap,
                                        familyToFontListMap,
                                        Locale.ENGLISH);

                if (debugFonts) {
                    System.err.println(&quot;Windows Locale ID=&quot; + getSystemLCID());
                    logFontInfo(&quot; *** WINDOWS FONTS BEFORE RESOLVING&quot;,
                                tmpFontToFileMap,
                                fontToFamilyNameMap,
                                familyToFontListMap);
                }

                resolveWindowsFonts(tmpFontToFileMap,
                                    fontToFamilyNameMap,
                                    familyToFontListMap);

                if (debugFonts) {
                    logFontInfo(&quot; *** WINDOWS FONTS AFTER RESOLVING&quot;,
                                tmpFontToFileMap,
                                fontToFamilyNameMap,
                                familyToFontListMap);
                }

            } else if (isMacOSX || isIOS) {
                MacFontFinder.populateFontFileNameMap(tmpFontToFileMap,
                                                      fontToFamilyNameMap,
                                                      familyToFontListMap,
                                                      Locale.ENGLISH);

            } else if (isLinux) {
                FontConfigManager.populateMaps(tmpFontToFileMap,
                                               fontToFamilyNameMap,
                                               familyToFontListMap,
                                               Locale.getDefault());
                if (debugFonts) {
                    logFontInfo(&quot; *** FONTCONFIG LOCATED FONTS:&quot;,
                                tmpFontToFileMap,
                                fontToFamilyNameMap,
                                familyToFontListMap);
                }
            } else if (isAndroid) {
               AndroidFontFinder.populateFontFileNameMap(tmpFontToFileMap,
                        fontToFamilyNameMap,
                        familyToFontListMap,
                        Locale.ENGLISH);
           } else { /* unrecognised OS */
                fontToFileMap = tmpFontToFileMap;
                return fontToFileMap;
            }

            /* Reverse map from file to font. file name is base name
             * not a full path.
             */
            for (String font : tmpFontToFileMap.keySet()) {
                String file = tmpFontToFileMap.get(font);
                fileToFontMap.put(file.toLowerCase(), font);
            }

            fontToFileMap = tmpFontToFileMap;
            if (isAndroid) {
                populateFontFileNameMapGeneric(
                       AndroidFontFinder.getSystemFontsDir());
            }
            populateFontFileNameMapGeneric(jreFontDir);

//             for (String keyName : fontToFileMap.keySet()) {
//               System.out.println(&quot;font=&quot;+keyName+&quot; file=&quot;+ fontToFileMap.get(keyName));
//             }

//             for (String keyName : familyToFontListMap.keySet()) {
//               System.out.println(&quot;family=&quot;+keyName);
//             }
        }
        return fontToFileMap;
    }

    public final boolean hasPermission() {
        try {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPermission(LOAD_FONT_PERMISSION);
            }
            return true;
        } catch (SecurityException ex) {
            return false;
        }
    }

    private static class TTFilter implements FilenameFilter {
        public boolean accept(File dir,String name) {
            /* all conveniently have the same suffix length */
            int offset = name.length()-4;
            if (offset &lt;= 0) { /* must be at least A.ttf */
                return false;
            } else {
                return(name.startsWith(&quot;.ttf&quot;, offset) ||
                       name.startsWith(&quot;.TTF&quot;, offset) ||
                       name.startsWith(&quot;.ttc&quot;, offset) ||
                       name.startsWith(&quot;.TTC&quot;, offset) ||
                       name.startsWith(&quot;.otf&quot;, offset) ||
                       name.startsWith(&quot;.OTF&quot;, offset));
            }
        }

        private TTFilter() {
        }

        static TTFilter ttFilter;
        static TTFilter getInstance() {
            if (ttFilter == null) {
                ttFilter = new TTFilter();
            }
            return ttFilter;
        }
    }

    void addToMaps(PrismFontFile fr) {

        if (fr == null) {
            return;
        }

        String fullName = fr.getFullName();
        String familyName = fr.getFamilyName();

        if (fullName == null || familyName == null) {
            return;
        }

        String lcFullName = fullName.toLowerCase();
        String lcFamilyName = familyName.toLowerCase();

        fontToFileMap.put(lcFullName, fr.getFileName());
        fontToFamilyNameMap.put(lcFullName, familyName);
        ArrayList&lt;String&gt; familyList = familyToFontListMap.get(lcFamilyName);
        if (familyList == null) {
            familyList = new ArrayList&lt;String&gt;();
            familyToFontListMap.put(lcFamilyName, familyList);
        }
        familyList.add(fullName);
    }

    void populateFontFileNameMapGeneric(String fontDir) {
        final File dir = new File(fontDir);
        String[] files = null;
        try {
            files = AccessController.doPrivileged(
                    (PrivilegedExceptionAction&lt;String[]&gt;) () -&gt; dir.list(TTFilter.getInstance())
            );
        } catch (Exception e) {
        }

        if (files == null) {
            return;
        }

        for (int i=0;i&lt;files.length;i++) {
            try {
                String path = fontDir+File.separator+files[i];

                /* Use filename from the resource so woff fonts are handled */
                if (!registerEmbeddedFont(path)) {
                    /* This font file can't be used by the underlying rasterizer */
                    continue;
                }

                int index = 0;
                PrismFontFile fr = createFontResource(path, index++);
                if (fr == null) {
                    continue;
                }
                addToMaps(fr);
                while (index &lt; fr.getFontCount()) {
                    fr = createFontResource(path, index++);
                    if (fr == null) {
                        break;
                    }
                    addToMaps(fr);
                }
            } catch (Exception e) {
                /* Keep going if anything bad happens with a font */
            }
        }
    }

    static native int getLCDContrastWin32();
    private static native float getSystemFontSizeNative();
    private static native String getSystemFontNative();
    private static float systemFontSize;
    private static String systemFontFamily = null;
    private static String monospaceFontFamily = null;

    public static float getSystemFontSize() {
        if (systemFontSize == -1) {
            if (isWindows) {
                systemFontSize = getSystemFontSizeNative();
            } else if (isMacOSX || isIOS) {
                systemFontSize = MacFontFinder.getSystemFontSize();
            } else if (isAndroid) {
               systemFontSize = AndroidFontFinder.getSystemFontSize();
            } else if (isEmbedded) {
                try {
                    int screenDPI = Screen.getMainScreen().getResolutionY();
                    systemFontSize = ((float) screenDPI) / 6f; // 12 points
                } catch (NullPointerException npe) {
                    // if no screen is defined
                    systemFontSize = 13f; // same as desktop Linux
                }
            } else {
                systemFontSize = 13f; // Gnome uses 13.
            }
        }
        return systemFontSize;
    }

    /* Applies to Windows and Mac. Not used on Linux */
    public static String getSystemFont(String name) {
        if (name.equals(LogicalFont.SYSTEM)) {
            if (systemFontFamily == null) {
                if (isWindows) {
                    systemFontFamily = getSystemFontNative();
                    if (systemFontFamily == null) {
                        systemFontFamily = &quot;Arial&quot;; // play it safe.
                    }
                } else if (isMacOSX || isIOS) {
                    systemFontFamily = MacFontFinder.getSystemFont();
                    if (systemFontFamily == null) {
                        systemFontFamily = &quot;Lucida Grande&quot;;
                    }
                } else if (isAndroid) {
                   systemFontFamily = AndroidFontFinder.getSystemFont();
                } else {
                    systemFontFamily = &quot;Lucida Sans&quot;; // for now.
                }
            }
            return systemFontFamily;
        } else if (name.equals(LogicalFont.SANS_SERIF)) {
            return &quot;Arial&quot;;
        } else if (name.equals(LogicalFont.SERIF)) {
            return &quot;Times New Roman&quot;;
        } else /* if (name.equals(LogicalFont.MONOSPACED)) */ {
            if (monospaceFontFamily == null) {
                if (isMacOSX) {
                    /* This code is intentionally commented:
                     * On the OS X the preferred monospaced font is Monaco,
                     * although this can be a good choice for most Mac application
                     * it is not suitable for JavaFX because Monaco does not
                     * have neither bold nor italic.
                     */
//                    monospaceFontFamily = MacFontFinder.getMonospacedFont();
                }
            }
            if (monospaceFontFamily == null) {
                monospaceFontFamily = &quot;Courier New&quot;;
            }
            return monospaceFontFamily;
        }
    }

    /* Called from PrismFontFile which caches the return value */
    static native short getSystemLCID();
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGNode.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import javafx.scene.CacheHint;
import java.util.ArrayList;
import java.util.List;
import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.GraphicsPipeline;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.impl.PrismSettings;
import com.sun.scenario.effect.Blend;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;

/**
 * NGNode is the abstract base class peer of Node, forming
 * the basis for Prism and Scenario render graphs.
 * &lt;p&gt;
 * During synchronization, the FX scene graph will pass down to us
 * the transform which takes us from local space to parent space, the
 * content bounds (ie: geom bounds), and the transformed bounds
 * (ie: boundsInParent), and the clippedBounds. The effect bounds have
 * already been passed to the Effect peer (if there is one).
 * &lt;p&gt;
 * Whenever the transformedBounds of the NGNode are changed, we update
 * the dirtyBounds, so that the next time we need to accumulate dirty
 * regions, we will have the information we need to make sure we create
 * an appropriate dirty region.
 * &lt;p&gt;
 * NGNode maintains a single &quot;dirty&quot; flag, which indicates that this
 * node itself is dirty and must contribute to the dirty region. More
 * specifically, it indicates that this node is now dirty with respect
 * to the back buffer. Any rendering of the scene which will go on the
 * back buffer will cause the dirty flag to be cleared, whereas a
 * rendering of the scene which is for an intermediate image will not
 * clear this dirty flag.
 */
public abstract class NGNode {
    private final static GraphicsPipeline pipeline =
        GraphicsPipeline.getPipeline();

    private final static Boolean effectsSupported =
        (pipeline == null ? false : pipeline.isEffectSupported());

    public static enum DirtyFlag {
        CLEAN,
        // Means that the node is dirty, but only because of translation
        DIRTY_BY_TRANSLATION,
        DIRTY
    }

    /**
     * Used for debug purposes. Set during sync.
     */
    private String name;

    /**
     * Temporary bounds for use by this class or subclasses, designed to
     * reduce the amount of garbage we generate. If we get to the point
     * where we have multi-threaded rasterization, we might need to make
     * this per-instance instead of static.
     */
    private static final BoxBounds TEMP_BOUNDS = new BoxBounds();
    private static final RectBounds TEMP_RECT_BOUNDS = new RectBounds();
    protected static final Affine3D TEMP_TRANSFORM = new Affine3D();

    /**
     * Statics for defining what the culling bits are. We use 2 bits to
     * determine culling status
     */
    static final int DIRTY_REGION_INTERSECTS_NODE_BOUNDS = 0x1;
    static final int DIRTY_REGION_CONTAINS_NODE_BOUNDS = 0x2;
    static final int DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS =
            DIRTY_REGION_INTERSECTS_NODE_BOUNDS | DIRTY_REGION_CONTAINS_NODE_BOUNDS;

    /**
     * The transform for this node. Although we are handed all the bounds
     * during synchronization (including the transformed bounds), we still
     * need the transform so that we can apply it to the clip and so forth
     * while accumulating dirty regions and rendering.
     */
    private BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;

    /**
     * The cached transformed bounds. This is never null, but is frequently set
     * to be invalid whenever the bounds for the node have changed. These are
     * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
     * Note that this is equivalent to boundsInParent in FX.
     */
    protected BaseBounds transformedBounds = new RectBounds();

    /**
     * The cached bounds. This is never null, but is frequently set to be
     * invalid whenever the bounds for the node have changed. These are the
     * &quot;content&quot; bounds, that is, without transforms or filters applied.
     */
    protected BaseBounds contentBounds = new RectBounds();

    /**
     * We keep a reference to the last transform bounds that were valid
     * and known. We do this to significantly speed up the rendering of the
     * scene by culling and clipping based on &quot;dirty&quot; regions, which are
     * essentially the rectangle formed by the union of the dirtyBounds
     * and the transformedBounds.
     */
    BaseBounds dirtyBounds = new RectBounds();

    /**
     * Whether the node is visible. We need to know about the visibility of
     * the node so that we can determine whether to cull it out, and perform
     * other such optimizations.
     */
    private boolean visible = true;

    /**
     * Indicates that this NGNode is itself dirty and needs its full bounds
     * included in the next repaint. This means it is dirty with respect to
     * the back buffer. We don't bother differentiating between bounds dirty
     * and visuals dirty because we can simply inspect the dirtyBounds to
     * see if it is valid. If so, then bounds must be dirty.
     */
    protected DirtyFlag dirty = DirtyFlag.DIRTY;

    /**
     * The parent of the node. In the case of a normal render graph node,
     * this will be an NGGroup. However, if this node is being used as
     * a clip node, then the parent is the node it is the clip for.
     */
    private NGNode parent;

    /**
     * True if this node is a clip. This means the parent is clipped by this node.
     */
    private boolean isClip;

    /**
     * The node used for specifying the clipping shape for this node. If null,
     * then there is no clip.
     */
    private NGNode clipNode;

    /**
     * The opacity of this node.
     */
    private float opacity = 1f;

    /**
     * The view order of this node.
     */
    private double viewOrder = 0;

    /**
     * The blend mode that controls how the pixels of this node blend into
     * the rest of the scene behind it.
     */
    private Blend.Mode nodeBlendMode;

    /**
     * The depth test flag for this node. It is used when rendering if the window
     * into which we are rendering has a depth buffer.
     */
    private boolean depthTest = true;

    /**
     * A filter used when the node is cached. If null, then the node is not
     * being cached. While in theory this could be created automatically by
     * the implementation due to some form of heuristic, currently we
     * only set this if the application has requested that the node be cached.
     */
    private CacheFilter cacheFilter;

    /**
     * A filter used whenever an effect is placed on the node. Of course
     * effects can form a kind of tree, such that this one effect might be
     * an accumulation of several different effects. This will be null if
     * there are no effects on the FX scene graph node.
     */
    private EffectFilter effectFilter;

    /**
     * If this node is an NGGroup, then this flag will be used to indicate
     * whether one or more of its children is dirty. While it would seem this
     * flag should be on NGGroup, the code turns out to be a bit cleaner with
     * this flag in the NGNode class.
     */
    protected boolean childDirty = false;

    /**
     * How many children are going to be accumulated
     */
    protected int dirtyChildrenAccumulated = 0;

    /**
     * Do not iterate over all children in group. Mark group as dirty
     * when threshold was reached.
     */
    protected final static int DIRTY_CHILDREN_ACCUMULATED_THRESHOLD = 12;

    /**
     * Marks position of this node in dirty regions.
     */
    protected int cullingBits = 0x0;
    private DirtyHint hint;

    /**
     * A cached representation of the opaque region for this node. This
     * cached version needs to be recomputed whenever the opaque region becomes
     * invalid, which includes local transform changes (translations included!).
     */
    private RectBounds opaqueRegion = null;

    /**
     * To avoid object churn we keep opaqueRegion around, and just toggle this
     * boolean to indicate whether we need to recompute the opaqueRegion.
     */
    private boolean opaqueRegionInvalid = true;

    /**
     * Used for debug purposes. This field will keep track of which nodes were
     * rendered as a result of different dirty regions. These correspond to the
     * same positions as the cullingBits. So for example, if a node was rendered
     * by dirty region 0, then painted will have the lowest bit set. If it
     * was rendered by dirty region 3, then it would have the 3rd bit from the
     * right set ( that is, 1 &lt;&lt; 2)
     */
    private int painted = 0;

    protected NGNode() { }

    /***************************************************************************
     *                                                                         *
     *                Methods invoked during synchronization                   *
     *                                                                         *
     **************************************************************************/

    /**
     * Called by the FX scene graph to tell us whether we should be visible or not.
     * @param value whether it is visible
     */
    public void setVisible(boolean value) {
        // If the visibility changes, we need to mark this node as being dirty.
        // If this node is being cached, changing visibility should have no
        // effect, since it doesn't affect the rendering of the content in
        // any way. If we were to release the cached image, that might thwart
        // the developer's attempt to improve performance for things that
        // rapidly appear and disappear but which are expensive to render.
        // Ancestors, of course, must still have their caches invalidated.
        if (visible != value) {
            this.visible = value;
            markDirty();
        }
    }

    /**
     * Called by the FX scene graph to tell us what our new content bounds are.
     * @param bounds must not be null
     */
    public void setContentBounds(BaseBounds bounds) {
        // Note, there isn't anything to do here. We're dirty if geom or
        // visuals or transformed bounds or effects or clip have changed.
        // There's no point dealing with it here.
        contentBounds = contentBounds.deriveWithNewBounds(bounds);
    }

    /**
     * Called by the FX scene graph to tell us what our transformed bounds are.
     * @param bounds must not be null
     */
    public void setTransformedBounds(BaseBounds bounds, boolean byTransformChangeOnly) {
        if (transformedBounds.equals(bounds)) {
            // There has been no change, so ignore. It turns out this happens
            // a lot, because when a leaf has dirty bounds, all parents also
            // assume their bounds have changed, and only when they recompute
            // their bounds do we discover otherwise. This check could happen
            // on the FX side, however, then the FX side needs to cache the
            // former content bounds at the time of the last sync or needs to
            // be able to read state back from the NG side. Yuck. Just doing
            // it here for now.
            return;
        }
        // If the transformed bounds have changed, then we need to save off the
        // transformed bounds into the dirty bounds, so that the resulting
        // dirty region will be correct. If this node is cached, we DO NOT
        // invalidate the cache. The cacheFilter will compare its cached
        // transform to the accumulated transform to determine whether the
        // cache needs to be regenerated. So we will not invalidate it here.
        if (dirtyBounds.isEmpty()) {
            dirtyBounds = dirtyBounds.deriveWithNewBounds(transformedBounds);
            dirtyBounds = dirtyBounds.deriveWithUnion(bounds);
        } else {
            // TODO I think this is vestigial from Scenario and will never
            // actually occur in real life... (RT-23956)
            dirtyBounds = dirtyBounds.deriveWithUnion(transformedBounds);
        }
        transformedBounds = transformedBounds.deriveWithNewBounds(bounds);
        if (hasVisuals() &amp;&amp; !byTransformChangeOnly) {
            markDirty();
        }
    }

    /**
     * Called by the FX scene graph to tell us what our transform matrix is.
     * @param tx must not be null
     */
    public void setTransformMatrix(BaseTransform tx) {
        if (transform.equals(tx)) {
            return;
        }
        // If the transform matrix has changed, then we need to update it,
        // and mark this node as dirty. If this node is cached, we DO NOT
        // invalidate the cache. The cacheFilter will compare its cached
        // transform to the accumulated transform to determine whether the
        // cache needs to be regenerated. So we will not invalidate it here.
        // This approach allows the cached image to be reused in situations
        // where only the translation parameters of the accumulated transform
        // are changing. The scene will still be marked dirty and cached
        // images of any ancestors will be invalidated.
        boolean useHint = false;

        // If the parent is cached, try to check if the transformation is only a translation
        if (parent != null &amp;&amp; parent.cacheFilter != null &amp;&amp; PrismSettings.scrollCacheOpt) {
            if (hint == null) {
                // If there's no hint created yet, this is the first setTransformMatrix
                // call and we have nothing to compare to yet.
                hint = new DirtyHint();
            } else {
                if (transform.getMxx() == tx.getMxx()
                        &amp;&amp; transform.getMxy() == tx.getMxy()
                        &amp;&amp; transform.getMyy() == tx.getMyy()
                        &amp;&amp; transform.getMyx() == tx.getMyx()
                        &amp;&amp; transform.getMxz() == tx.getMxz()
                        &amp;&amp; transform.getMyz() == tx.getMyz()
                        &amp;&amp; transform.getMzx() == tx.getMzx()
                        &amp;&amp; transform.getMzy() == tx.getMzy()
                        &amp;&amp; transform.getMzz() == tx.getMzz()
                        &amp;&amp; transform.getMzt() == tx.getMzt()) {
                    useHint = true;
                    hint.translateXDelta = tx.getMxt() - transform.getMxt();
                    hint.translateYDelta = tx.getMyt() - transform.getMyt();
                }
            }
        }

        transform = transform.deriveWithNewTransform(tx);
        if (useHint) {
            markDirtyByTranslation();
        } else {
            markDirty();
        }
        invalidateOpaqueRegion();
    }

    /**
     * Called by the FX scene graph whenever the clip node for this node changes.
     * @param clipNode can be null if the clip node is being cleared
     */
    public void setClipNode(NGNode clipNode) {
        // Whenever the clipNode itself has changed (that is, the reference to
        // the clipNode), we need to be sure to mark this node dirty and to
        // invalidate the cache of this node (if there is one) and all parents.
        if (clipNode != this.clipNode) {
            // Clear the &quot;parent&quot; property of the clip node, if there was one
            if (this.clipNode != null) this.clipNode.setParent(null);
            // Make the &quot;parent&quot; property of the clip node point to this
            if (clipNode != null) clipNode.setParent(this, true);
            // Keep the reference to the new clip node
            this.clipNode = clipNode;
            // Mark this node dirty, invalidate its cache, and all parents.
            visualsChanged();
            invalidateOpaqueRegion();
        }
    }

    /**
     * Called by the FX scene graph whenever the opacity for the node changes.
     * We create a special filter when the opacity is &lt; 1.
     * @param opacity A value between 0 and 1.
     */
    public void setOpacity(float opacity) {
        // Check the argument to make sure it is valid.
        if (opacity &lt; 0 || opacity &gt; 1) {
            throw new IllegalArgumentException(&quot;Internal Error: The opacity must be between 0 and 1&quot;);
        }
        // If the opacity has changed, react. If this node is being cached,
        // then we do not want to invalidate the cache due to an opacity
        // change. However, as usual, all parent caches must be invalidated.
        if (opacity != this.opacity) {
            final float old = this.opacity;
            this.opacity = opacity;
            markDirty();
            // Even though the opacity has changed, for example from .5 to .6,
            // we don't need to invalidate the opaque region unless it has toggled
            // from 1 to !1, or from !1 to 1.
            if (old &lt; 1 &amp;&amp; (opacity == 1 || opacity == 0) || opacity &lt; 1 &amp;&amp; (old == 1 || old == 0)) {
                invalidateOpaqueRegion();
            }
        }
    }

    /**
     * Called by the FX scene graph whenever the view order for the node
     * changes.
     *
     * @param viewOrder A value between the range of negative Double.MAX_VALUE
     * and positive Double.MAX_VALUE.
     */
    public void setViewOrder(double viewOrder) {
        // If the viewOrder value has changed, react.
        if (viewOrder != this.viewOrder) {
            this.viewOrder = viewOrder;
            // Mark this node dirty and invalidate its cache.
            visualsChanged();
        }
    }

    /**
     * Set by the FX scene graph.
     * @param blendMode may be null to indicate &quot;default&quot;
     */
    public void setNodeBlendMode(Blend.Mode blendMode) {
        // The following code was a broken optimization that made an
        // incorrect assumption about null meaning the same thing as
        // SRC_OVER.  In reality, null means &quot;pass through blending
        // from children&quot; and SRC_OVER means &quot;intercept blending of
        // children, allow them to blend with each other, but pass
        // their result on in a single SRC_OVER operation into the bg&quot;.
        // For leaf nodes, those are mostly the same thing, but Regions
        // and Groups might behave differently for the two modes.
//        if (blendMode == Blend.Mode.SRC_OVER) {
//            blendMode = null;
//        }

        // If the blend mode has changed, react. If this node is being cached,
        // then we do not want to invalidate the cache due to a compositing
        // change. However, as usual, all parent caches must be invalidated.

        if (this.nodeBlendMode != blendMode) {
            this.nodeBlendMode = blendMode;
            markDirty();
            invalidateOpaqueRegion();
        }
    }

    /**
     * Called by the FX scene graph whenever the derived depth test flag for
     * the node changes.
     * @param depthTest indicates whether to perform a depth test operation
     * (if the window has a depth buffer).
     */
    public void setDepthTest(boolean depthTest) {
        // If the depth test flag has changed, react.
        if (depthTest != this.depthTest) {
            this.depthTest = depthTest;
            // Mark this node dirty, invalidate its cache, and all parents.
            visualsChanged();
        }
    }

    /**
     * Called by the FX scene graph whenever &quot;cached&quot; or &quot;cacheHint&quot; changes.
     * These hints provide a way for the developer to indicate whether they
     * want this node to be cached as a raster, which can be quite a performance
     * optimization in some cases (and lethal in others).
     * @param cached specifies whether or not this node should be cached
     * @param cacheHint never null, indicates some hint as to how to cache
     */
    public void setCachedAsBitmap(boolean cached, CacheHint cacheHint) {
        // Validate the arguments
        if (cacheHint == null) {
            throw new IllegalArgumentException(&quot;Internal Error: cacheHint must not be null&quot;);
        }

        if (cached) {
            if (cacheFilter == null) {
                cacheFilter = new CacheFilter(this, cacheHint);
                // We do not technically need to do a render pass here, but if
                // we wait for the next render pass to cache it, then we will
                // cache not the current visuals, but the visuals as defined
                // by any transform changes that happen between now and then.
                // Repainting now encourages the cached version to be as close
                // as possible to the state of the node when the cache hint
                // was set...
                markDirty();
            } else {
                if (!cacheFilter.matchesHint(cacheHint)) {
                    cacheFilter.setHint(cacheHint);
                    // Different hints may have different requirements of
                    // whether the cache is stale.  We do not have enough info
                    // right here to evaluate that, but it will be determined
                    // naturally during a repaint cycle.
                    // If the new hint is more relaxed (QUALITY =&gt; SPEED for
                    // instance) then rendering should be quick.
                    // If the new hint is more restricted (SPEED =&gt; QUALITY)
                    // then we need to render to improve the results anyway.
                    markDirty();
                }
            }
        } else {
            if (cacheFilter != null) {
                cacheFilter.dispose();
                cacheFilter = null;
                // A cache will often look worse than uncached rendering.  It
                // may look the same in some circumstances, and this may then
                // be an unnecessary rendering pass, but we do not have enough
                // information here to be able to optimize that when possible.
                markDirty();
            }
        }
    }

    /**
     * Called by the FX scene graph to set the effect.
     * @param effect the effect (can be null to clear it)
     */
    public void setEffect(Effect effect) {
        final Effect old = getEffect();
        // When effects are disabled, be sure to reset the effect filter
        if (PrismSettings.disableEffects) {
            effect = null;
        }

        // We only need to take action if the effect is different than what was
        // set previously. There are four possibilities. Of these, #1 and #3 matter:
        // 0. effectFilter == null, effect == null
        // 1. effectFilter == null, effect != null
        // 2. effectFilter != null, effectFilter.effect == effect
        // 3. effectFilter != null, effectFilter.effect != effect
        // In any case where the effect is changed, we must both invalidate
        // the cache for this node (if there is one) and all parents, and mark
        // this node as dirty.
        if (effectFilter == null &amp;&amp; effect != null) {
            effectFilter = new EffectFilter(effect, this);
            visualsChanged();
        } else if (effectFilter != null &amp;&amp; effectFilter.getEffect() != effect) {
            effectFilter.dispose();
            effectFilter = null;
            if (effect != null) {
                effectFilter = new EffectFilter(effect, this);
            }
            visualsChanged();
        }

        // The only thing we do with the effect in #computeOpaqueRegion is to check
        // whether the effect is null / not null. If the answer to these question has
        // not changed from last time, then there is no need to recompute the opaque region.
        if (old != effect) {
            if (old == null || effect == null) {
                invalidateOpaqueRegion();
            }
        }
    }

    /**
     * Called by the FX scene graph when an effect in the effect chain on the node
     * changes internally.
     */
    public void effectChanged() {
        visualsChanged();
    }

    /**
     * Return true if contentBounds is purely a 2D bounds, ie. it is a
     * RectBounds or its Z dimension is almost zero.
     */
    public boolean isContentBounds2D() {
        return contentBounds.is2D();
    }

    /***************************************************************************
     *                                                                         *
     * Hierarchy, visibility, and other such miscellaneous NGNode properties   *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the parent of this node. The parent might be an NGGroup. However,
     * if this node is a clip node on some other node, then the node on which
     * it is set as the clip will be returned. That is, suppose some node A
     * has a clip node B. The method B.getParent() will return A.
     */
    public NGNode getParent() { return parent; }

    /**
     * Only called by this class, or by the NGGroup class.
     */
    public void setParent(NGNode parent) {
        setParent(parent, false);
    }

    private void setParent(NGNode parent, boolean isClip) {
        this.parent = parent;
        this.isClip = isClip;
    }

    /**
     * Used for debug purposes.
     */
    public final void setName(String value) {
        this.name = value;
    }

    /**
     * Used for debug purposes.
     */
    public final String getName() {
        return name;
    }

    protected final Effect getEffect() { return effectFilter == null ? null : effectFilter.getEffect(); }

    /**
     * Gets whether this node's visible property is set
     */
    public boolean isVisible() { return visible; }

    public final BaseTransform getTransform() { return transform; }
    public final float getOpacity() { return opacity; }
    public final Blend.Mode getNodeBlendMode() { return nodeBlendMode; }
    public final boolean isDepthTest() { return depthTest; }
    public final CacheFilter getCacheFilter() { return cacheFilter; }
    public final EffectFilter getEffectFilter() { return effectFilter; }
    public final NGNode getClipNode() { return clipNode; }

    public BaseBounds getContentBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isTranslateOrIdentity()) {
            bounds = bounds.deriveWithNewBounds(contentBounds);
            if (!tx.isIdentity()) {
                float translateX = (float) tx.getMxt();
                float translateY = (float) tx.getMyt();
                float translateZ = (float) tx.getMzt();
                bounds = bounds.deriveWithNewBounds(
                    bounds.getMinX() + translateX,
                    bounds.getMinY() + translateY,
                    bounds.getMinZ() + translateZ,
                    bounds.getMaxX() + translateX,
                    bounds.getMaxY() + translateY,
                    bounds.getMaxZ() + translateZ);
            }
            return bounds;
        } else {
            // This is a scale / rotate / skew transform.
            // We have contentBounds cached throughout the entire tree.
            // just walk down the tree and add everything up
            return computeBounds(bounds, tx);
        }
    }

    private BaseBounds computeBounds(BaseBounds bounds, BaseTransform tx) {
        // TODO: This code almost worked, but it ignored the local to
        // parent transforms on the nodes.  The short fix is to disable
        // this block and use the more general form below, but we need
        // to revisit this and see if we can make it work more optimally.
        // @see RT-12105 http://javafx-jira.kenai.com/browse/RT-12105
        if (false &amp;&amp; this instanceof NGGroup) {
            List&lt;NGNode&gt; children = ((NGGroup)this).getChildren();
            BaseBounds tmp = TEMP_BOUNDS;
            for (int i=0; i&lt;children.size(); i++) {
                float minX = bounds.getMinX();
                float minY = bounds.getMinY();
                float minZ = bounds.getMinZ();
                float maxX = bounds.getMaxX();
                float maxY = bounds.getMaxY();
                float maxZ = bounds.getMaxZ();
                NGNode child = children.get(i);
                bounds = child.computeBounds(bounds, tx);
                tmp = tmp.deriveWithNewBounds(minX, minY, minZ, maxX, maxY, maxZ);
                bounds = bounds.deriveWithUnion(tmp);
            }
            return bounds;
        } else {
            bounds = bounds.deriveWithNewBounds(contentBounds);
            return tx.transform(contentBounds, bounds);
        }
    }

    /**
     */
    public final BaseBounds getClippedBounds(BaseBounds bounds, BaseTransform tx) {
        BaseBounds effectBounds = getEffectBounds(bounds, tx);
        if (clipNode != null) {
            // there is a clip in place, so we will save off the effect/content
            // bounds (so as not to generate garbage) and will then get the
            // bounds of the clip node and do an intersection of the two
            float ex1 = effectBounds.getMinX();
            float ey1 = effectBounds.getMinY();
            float ez1 = effectBounds.getMinZ();
            float ex2 = effectBounds.getMaxX();
            float ey2 = effectBounds.getMaxY();
            float ez2 = effectBounds.getMaxZ();
            effectBounds = clipNode.getCompleteBounds(effectBounds, tx);
            effectBounds.intersectWith(ex1, ey1, ez1, ex2, ey2, ez2);
        }
        return effectBounds;
    }

    public final BaseBounds getEffectBounds(BaseBounds bounds, BaseTransform tx) {
        if (effectFilter != null) {
            return effectFilter.getBounds(bounds, tx);
        } else {
            return getContentBounds(bounds, tx);
        }
    }

    public final BaseBounds getCompleteBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isIdentity()) {
            bounds = bounds.deriveWithNewBounds(transformedBounds);
            return bounds;
        } else if (transform.isIdentity()) {
            return getClippedBounds(bounds, tx);
        } else {
            double mxx = tx.getMxx();
            double mxy = tx.getMxy();
            double mxz = tx.getMxz();
            double mxt = tx.getMxt();
            double myx = tx.getMyx();
            double myy = tx.getMyy();
            double myz = tx.getMyz();
            double myt = tx.getMyt();
            double mzx = tx.getMzx();
            double mzy = tx.getMzy();
            double mzz = tx.getMzz();
            double mzt = tx.getMzt();
            BaseTransform boundsTx = tx.deriveWithConcatenation(this.transform);
            bounds = getClippedBounds(bounds, tx);
            if (boundsTx == tx) {
                tx.restoreTransform(mxx, mxy, mxz, mxt,
                                    myx, myy, myz, myt,
                                    mzx, mzy, mzz, mzt);
            }
            return bounds;
        }
    }

    /***************************************************************************
     *                                                                         *
     * Dirty States                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Invoked by subclasses whenever some change to the geometry or visuals
     * has occurred. This will mark the node as dirty and invalidate the cache.
     */
    protected void visualsChanged() {
        invalidateCache();
        markDirty();
    }

    protected void geometryChanged() {
        invalidateCache();
        invalidateOpaqueRegion();
        if (hasVisuals()) {
            markDirty();
        }
    }

    /**
     * Makes this node dirty, meaning that it needs to be included in the
     * next repaint to the back buffer, and its bounds should be included
     * in the dirty region. This flag means that this node itself is dirty.
     * In contrast, the childDirty flag indicates that a child of the node
     * (maybe a distant child) is dirty. This method does not invalidate the
     * cache of this node. However, it ends up walking up the tree marking
     * all parents as having a dirty child and also invalidating their caches.
     * This method has no effect if the node is already dirty.
     */
    public final void markDirty() {
        if (dirty != DirtyFlag.DIRTY) {
            dirty = DirtyFlag.DIRTY;
            markTreeDirty();
        }
    }

    /**
     * Mark the node as DIRTY_BY_TRANSLATION. This will call special cache invalidation
     */
    private void markDirtyByTranslation() {
        if (dirty == DirtyFlag.CLEAN) {
            if (parent != null &amp;&amp; parent.dirty == DirtyFlag.CLEAN &amp;&amp; !parent.childDirty) {
                dirty = DirtyFlag.DIRTY_BY_TRANSLATION;
                parent.childDirty = true;
                parent.dirtyChildrenAccumulated++;
                parent.invalidateCacheByTranslation(hint);
                parent.markTreeDirty();
            } else {
                markDirty();
            }
        }
    }

    //Mark tree dirty, but make sure this node's
    // dirtyChildrenAccumulated has not been incremented.
    // Useful when a markTree is called on a node that's not
    // the dirty source of change, e.g. group knows it has new child
    // or one of it's child has been removed
    protected final void markTreeDirtyNoIncrement() {
        if (parent != null &amp;&amp; (!parent.childDirty || dirty == DirtyFlag.DIRTY_BY_TRANSLATION)) {
            markTreeDirty();
        }
    }

    /**
     * Notifies the parent (whether an NGGroup or just a NGNode) that
     * a child has become dirty. This walk will continue all the way up
     * to the root of the tree. If a node is encountered which is already
     * dirty, or which already has childDirty set, then this loop will
     * terminate (ie: there is no point going further so we might as well
     * just bail). This method ends up invalidating the cache of each
     * parent up the tree. Since it is possible for a node to already
     * have its dirty bit set, but not have its cache invalidated, this
     * method is careful to make sure the first parent it encounters
     * which is already marked dirty still has its cache invalidated. If
     * this turns out to be expensive due to high occurrence, we can add
     * a quick &quot;invalidated&quot; flag to every node (at the cost of yet
     * another bit).
     */
    protected final void markTreeDirty() {
        NGNode p = parent;
        boolean atClip = isClip;
        boolean byTranslation = dirty == DirtyFlag.DIRTY_BY_TRANSLATION;
        while (p != null &amp;&amp; p.dirty != DirtyFlag.DIRTY &amp;&amp; (!p.childDirty || atClip || byTranslation)) {
            if (atClip) {
                p.dirty = DirtyFlag.DIRTY;
            } else if (!byTranslation) {
                p.childDirty = true;
                p.dirtyChildrenAccumulated++;
            }
            p.invalidateCache();
            atClip = p.isClip;
            byTranslation = p.dirty == DirtyFlag.DIRTY_BY_TRANSLATION;
            p = p.parent;
        }
        // if we stopped on a parent that already has dirty children, increase it's
        // dirty children count.
        // Note that when incrementDirty is false, we don't increment in this case.
        if (p != null &amp;&amp; p.dirty == DirtyFlag.CLEAN &amp;&amp; !atClip &amp;&amp; !byTranslation) {
            p.dirtyChildrenAccumulated++;
        }
        // Must make sure this happens. In some cases, a parent might
        // already be marked dirty (for example, its opacity may have
        // changed) but its cache has not been made invalid. This call
        // will make sure it is invalidated in that case
        if (p != null) p.invalidateCache();
    }

    /**
     * Gets whether this SGNode is clean. This will return true only if
     * this node and any / all child nodes are clean.
     */
    public final boolean isClean() {
        return dirty == DirtyFlag.CLEAN &amp;&amp; !childDirty;
    }

    /**
     * Clears the dirty flag. This should only happen during rendering.
     */
    protected void clearDirty() {
        dirty = DirtyFlag.CLEAN;
        childDirty = false;
        dirtyBounds.makeEmpty();
        dirtyChildrenAccumulated = 0;
    }

    /**
     * Walks down the tree clearing the &quot;painted&quot; bits for each node. This is only
     * called if we're drawing dirty rectangles or overdraw rectangles.
     */
    public void clearPainted() {
        painted = 0;
        if (this instanceof NGGroup) {
            List&lt;NGNode&gt; children = ((NGGroup)this).getChildren();
            for (int i=0; i&lt;children.size(); i++) {
                children.get(i).clearPainted();
            }
        }
    }

    public void clearDirtyTree() {
        clearDirty();
        if (getClipNode() != null) {
            getClipNode().clearDirtyTree();
        }
        if (this instanceof NGGroup) {
            List&lt;NGNode&gt; children = ((NGGroup) this).getChildren();
            for (int i = 0; i &lt; children.size(); ++i) {
                NGNode child = children.get(i);
                if (child.dirty != DirtyFlag.CLEAN || child.childDirty) {
                    child.clearDirtyTree();
                }
            }
        }
    }

    /**
     * Invalidates the cache, if it is in use. There are several operations
     * which need to cause the cached raster to become invalid so that a
     * subsequent render operation will result in the cached image being
     * reconstructed.
     */
    protected final void invalidateCache() {
        if (cacheFilter != null) {
            cacheFilter.invalidate();
        }
    }

    /**
     * Mark the cache as invalid due to a translation of a child. The cache filter
     * might use this information for optimizations.
     */
    protected final void invalidateCacheByTranslation(DirtyHint hint) {
        if (cacheFilter != null) {
            cacheFilter.invalidateByTranslation(hint.translateXDelta, hint.translateYDelta);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Dirty Regions                                                           *
     *                                                                         *
     * Need to add documentation about dirty regions and how they work. One    *
     * thing to be aware of is that during the dirty region accumulation phase *
     * we use precise floating point values, but during                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Accumulates and returns the dirty regions in transformed coordinates for
     * this node. This method is designed such that a single downward traversal
     * of the tree is sufficient to update the dirty regions.
     * &lt;p&gt;
     * This method only accumulates dirty regions for parts of the tree which lie
     * inside the clip since there is no point in accumulating dirty regions which
     * lie outside the clip. The returned dirty regions bounds  the same object
     * as that passed into the function. The returned dirty regions bounds will
     * always be adjusted such that they do not extend beyond the clip.
     * &lt;p&gt;
     * The given transform is the accumulated transform up to but not including the
     * transform of this node.
     *
     * @param clip must not be null, the clip in scene coordinates, supplied by the
     *        rendering system. At most, this is usually the bounds of the window's
     *        content area, however it might be smaller.
     * @param dirtyRegionTemp must not be null, the dirty region in scene coordinates.
     *        When this method is initially invoked by the rendering system, the
     *        dirtyRegion should be marked as invalid.
     * @param dirtyRegionContainer must not be null, the container of dirty regions in scene
     *        coordinates.
     * @param tx must not be null, the accumulated transform up to but not
     *        including this node's transform. When this method concludes, it must
     *        restore this transform if it was changed within the function.
     * @param pvTx must not be null, it's the perspective transform of the current
     *        perspective camera or identity transform if parallel camera is used.
     * @return The dirty region container. If the returned value is null, then that means
     *         the clip should be used as the dirty region. This is a special
     *         case indicating that there is no more need to walk the tree but
     *         we can take a shortcut. Note that returning null is *always*
     *         safe. Returning something other than null is simply an
     *         optimization for cases where the dirty region is substantially
     *         smaller than the clip.
     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)
     */
    public /*final*/ int accumulateDirtyRegions(final RectBounds clip,
                                                final RectBounds dirtyRegionTemp,
                                                DirtyRegionPool regionPool,
                                                final DirtyRegionContainer dirtyRegionContainer,
                                                final BaseTransform tx,
                                                final GeneralTransform3D pvTx)
    {
        // This is the main entry point, make sure to check these inputs for validity
        if (clip == null || dirtyRegionTemp == null || regionPool == null || dirtyRegionContainer == null ||
                tx == null || pvTx == null) throw new NullPointerException();

        // Even though a node with 0 visibility or 0 opacity doesn't get
        // rendered, it may contribute to the dirty bounds, for example, if it
        // WAS visible or if it HAD an opacity &gt; 0 last time we rendered then
        // we must honor its dirty region. We have front-loaded this work so
        // that we don't mark nodes as having dirty flags or dirtyBounds if
        // they shouldn't contribute to the dirty region. So we can simply
        // treat all nodes, regardless of their opacity or visibility, as
        // though their dirty regions matter. They do.

        // If this node is clean then we can simply return the dirty region as
        // there is no need to walk any further down this branch of the tree.
        // The node is &quot;clean&quot; if neither it, nor its children, are dirty.
         if (dirty == DirtyFlag.CLEAN &amp;&amp; !childDirty) {
             return DirtyRegionContainer.DTR_OK;
         }

        // We simply collect this nodes dirty region if it has its dirty flag
        // set, regardless of whether it is a group or not. However, if this
        // node is not dirty, then we can ask the accumulateGroupDirtyRegion
        // method to collect the dirty regions of the children.
        if (dirty != DirtyFlag.CLEAN) {
            return accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);
        } else {
            assert childDirty; // this must be true by this point
            return accumulateGroupDirtyRegion(clip, dirtyRegionTemp, regionPool,
                                              dirtyRegionContainer, tx, pvTx);
        }
    }

    /**
     * Accumulates the dirty region of a node.
     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)
     */
    int accumulateNodeDirtyRegion(final RectBounds clip,
                                  final RectBounds dirtyRegionTemp,
                                  final DirtyRegionContainer dirtyRegionContainer,
                                  final BaseTransform tx,
                                  final GeneralTransform3D pvTx) {

        // Get the dirty bounds of this specific node in scene coordinates
        final BaseBounds bb = computeDirtyRegion(dirtyRegionTemp, tx, pvTx);

        // Note: dirtyRegion is strictly a 2D operation. We simply need the largest
        // rectangular bounds of bb. Hence the Z-axis projection of bb; taking
        // minX, minY, maxX and maxY values from this point on. Also, in many cases
        // bb == dirtyRegionTemp. In fact, the only time this won't be true is if
        // there is (or was) a perspective transform involved on this node.
        if (bb != dirtyRegionTemp) {
            bb.flattenInto(dirtyRegionTemp);
        }

        // If my dirty region is empty, or if it doesn't intersect with the
        // clip, then we can simply return since this node's dirty region is
        // not helpful
        if (dirtyRegionTemp.isEmpty() || clip.disjoint(dirtyRegionTemp)) {
            return DirtyRegionContainer.DTR_OK;
        }

        // If the clip is completely contained within the dirty region (including
        // if they are equal) then we return DTR_CONTAINS_CLIP
        if (dirtyRegionTemp.contains(clip)) {
            return DirtyRegionContainer.DTR_CONTAINS_CLIP;
        }

        // The only overhead in calling intersectWith, and contains (above) is the repeated checking
        // if the isEmpty state. But the code is cleaner and less error prone.
        dirtyRegionTemp.intersectWith(clip);

        // Add the dirty region to the container
        dirtyRegionContainer.addDirtyRegion(dirtyRegionTemp);

        return DirtyRegionContainer.DTR_OK;
    }

    /**
     * Accumulates the dirty region of an NGGroup. This is implemented here as opposed to
     * using polymorphism because we wanted to centralize all of the dirty region
     * management code in one place, rather than having it spread between Prism,
     * Scenario, and any other future toolkits.
     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)
     */
    int accumulateGroupDirtyRegion(final RectBounds clip,
                                   final RectBounds dirtyRegionTemp,
                                   final DirtyRegionPool regionPool,
                                   DirtyRegionContainer dirtyRegionContainer,
                                   final BaseTransform tx,
                                   final GeneralTransform3D pvTx) {
        // We should have only made it to this point if this node has a dirty
        // child. If this node itself is dirty, this method never would get called.
        // If this node was not dirty and had no dirty children, then this
        // method never should have been called. So at this point, the following
        // assertions should be correct.
        assert childDirty;
        assert dirty == DirtyFlag.CLEAN;

        int status = DirtyRegionContainer.DTR_OK;

        if (dirtyChildrenAccumulated &gt; DIRTY_CHILDREN_ACCUMULATED_THRESHOLD) {
            status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);
            return status;
        }

        // If we got here, then we are following a &quot;bread crumb&quot; trail down to
        // some child (perhaps distant) which is dirty. So we need to iterate
        // over all the children and accumulate their dirty regions. Before doing
        // so we, will save off the transform state and restore it after having
        // called all the children.
        double mxx = tx.getMxx();
        double mxy = tx.getMxy();
        double mxz = tx.getMxz();
        double mxt = tx.getMxt();

        double myx = tx.getMyx();
        double myy = tx.getMyy();
        double myz = tx.getMyz();
        double myt = tx.getMyt();

        double mzx = tx.getMzx();
        double mzy = tx.getMzy();
        double mzz = tx.getMzz();
        double mzt = tx.getMzt();
        BaseTransform renderTx = tx;
        if (this.transform != null) renderTx = renderTx.deriveWithConcatenation(this.transform);

        // If this group node has a clip, then we will perform some special
        // logic which will cause the dirty region accumulation loops to run
        // faster. We already have a system whereby if a node determines that
        // its dirty region exceeds that of the clip, it simply returns null,
        // short circuiting the accumulation process. We extend that logic
        // here by also taking into account the clipNode on the group. If
        // there is a clip node, then we will union the bounds of the clip
        // node (in boundsInScene space) with the current clip and pass this
        // new clip down to the children. If they determine that their dirty
        // regions exceed the bounds of this new clip, then they will return
        // null. We'll catch that here, and use that information to know that
        // we ought to simply accumulate the bounds of this group as if it
        // were dirty. This process will do all the other optimizations we
        // already have in place for getting the normal dirty region.
        RectBounds myClip = clip;
        //Save current dirty region so we can fast-reset to (something like) the last state
        //and possibly save a few intersects() calls

        DirtyRegionContainer originalDirtyRegion = null;
        BaseTransform originalRenderTx = null;
        if (effectFilter != null) {
            try {
                myClip = new RectBounds();
                BaseBounds myClipBaseBounds = renderTx.inverseTransform(clip, TEMP_BOUNDS);
                myClipBaseBounds.flattenInto(myClip);
            } catch (NoninvertibleTransformException ex) {
                return DirtyRegionContainer.DTR_OK;
            }

            originalRenderTx = renderTx;
            renderTx = BaseTransform.IDENTITY_TRANSFORM;
            originalDirtyRegion = dirtyRegionContainer;
            dirtyRegionContainer = regionPool.checkOut();
        } else if (clipNode != null) {
            originalDirtyRegion = dirtyRegionContainer;
            myClip = new RectBounds();
            BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);
            pvTx.transform(clipBounds, clipBounds);
            clipBounds.flattenInto(myClip);
            myClip.intersectWith(clip);
            dirtyRegionContainer = regionPool.checkOut();
        }


        //Accumulate also removed children to dirty region.
        List&lt;NGNode&gt; removed = ((NGGroup) this).getRemovedChildren();
        if (removed != null) {
            NGNode removedChild;
            for (int i = removed.size() - 1; i &gt;= 0; --i) {
                removedChild = removed.get(i);
                removedChild.dirty = DirtyFlag.DIRTY;
                    status = removedChild.accumulateDirtyRegions(myClip,
                            dirtyRegionTemp,regionPool, dirtyRegionContainer, renderTx, pvTx);
                    if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {
                        break;
                    }
            }
        }

        List&lt;NGNode&gt; children = ((NGGroup) this).getChildren();
        int num = children.size();
        for (int i=0; i&lt;num &amp;&amp; status == DirtyRegionContainer.DTR_OK; i++) {
            NGNode child = children.get(i);
            // The child will check the dirty bits itself. If we tested it here
            // (as we used to), we are just doing the check twice. True, it might
            // mean fewer method calls, but hotspot will probably inline this all
            // anyway, and doing the check in one place is less error prone.
            status = child.accumulateDirtyRegions(myClip, dirtyRegionTemp, regionPool,
                                                  dirtyRegionContainer, renderTx, pvTx);
            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {
                break;
            }
        }

        if (effectFilter != null &amp;&amp; status == DirtyRegionContainer.DTR_OK) {
            //apply effect on effect dirty regions
            applyEffect(effectFilter, dirtyRegionContainer, regionPool);

            if (clipNode != null) {
                myClip = new RectBounds();
                BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);
                applyClip(clipBounds, dirtyRegionContainer);
            }

            //apply transform on effect dirty regions
            applyTransform(originalRenderTx, dirtyRegionContainer);
            renderTx = originalRenderTx;

            originalDirtyRegion.merge(dirtyRegionContainer);
            regionPool.checkIn(dirtyRegionContainer);
        }

        // If the process of applying the transform caused renderTx to not equal
        // tx, then there is no point restoring it since it will be a different
        // reference and will therefore be gc'd.
        if (renderTx == tx) {
            tx.restoreTransform(mxx, mxy, mxz, mxt, myx, myy, myz, myt, mzx, mzy, mzz, mzt);
        }

        // If the dirty region is null and there is a clip node specified, then what
        // happened is that the dirty region of content within this group exceeded
        // the clip of this group, and thus, we should accumulate the bounds of
        // this group into the dirty region. If the bounds of the group exceeds
        // the bounds of the dirty region, then we end up returning null in the
        // end. But the implementation of accumulateNodeDirtyRegion handles this.
        if (clipNode != null &amp;&amp; effectFilter == null) {
            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {
                status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, originalDirtyRegion, tx, pvTx);
            } else {
                originalDirtyRegion.merge(dirtyRegionContainer);
            }
            regionPool.checkIn(dirtyRegionContainer);
        }
        return status;
    }

    /**
     * Computes the dirty region for this Node. The specified region is in
     * scene coordinates. The specified tx can be used to convert local bounds
     * to scene bounds (it includes everything up to but not including my own
     * transform).
     *
     * @param dirtyRegionTemp A temporary RectBounds that this method can use for scratch.
     *                        In the case that no perspective transform occurs, it is best if
     *                        the returned BaseBounds is this instance.
     * @param tx Any transform that needs to be applied
     * @param pvTx must not be null, it's the perspective transform of the current
     *        perspective camera or identity transform if parallel camera is used.
     */
    private BaseBounds computeDirtyRegion(final RectBounds dirtyRegionTemp,
                                          final BaseTransform tx,
                                          final GeneralTransform3D pvTx)
    {
        if (cacheFilter != null) {
            return cacheFilter.computeDirtyBounds(dirtyRegionTemp, tx, pvTx);
        }
        // The passed in region is a scratch object that exists for me to use,
        // such that I don't have to create a temporary object. So I just
        // hijack it right here to start with. Note that any of the calls
        // in computeDirtyRegion might end up changing the region instance
        // from dirtyRegionTemp (which is a RectBounds) to a BoxBounds if any
        // of the other bounds / transforms involve a perspective transformation.
        BaseBounds region = dirtyRegionTemp;
        if (!dirtyBounds.isEmpty()) {
            region = region.deriveWithNewBounds(dirtyBounds);
        } else {
            // If dirtyBounds is empty, then we will simply set the bounds to
            // be the same as the transformedBounds (since that means the bounds
            // haven't changed and right now we don't support dirty sub regions
            // for generic nodes). This can happen if, for example, this is
            // a group with a clip and the dirty area of child nodes within
            // the group exceeds the bounds of the clip on the group. Just trust me.
            region = region.deriveWithNewBounds(transformedBounds);
        }

        // We shouldn't do anything with empty region, as we may accidentally make
        // it non empty or turn it into some nonsense (like (-1,-1,0,0) )
        if (!region.isEmpty()) {
                // Now that we have the dirty region, we will simply apply the tx
                // to it (after slightly padding it for good luck) to get the scene
                // coordinates for this.
                region = computePadding(region);
                region = tx.transform(region, region);
                region = pvTx.transform(region, region);
        }
        return region;
    }

    /**
     * LCD Text creates some painful situations where, due to the LCD text
     * algorithm, we end up with some pixels touched that are normally outside
     * the bounds. To compensate, we need a hook for NGText to add padding.
     */
    protected BaseBounds computePadding(BaseBounds region) {
        return region;
    }

    /**
     * Marks if the node has some visuals and that the bounds change
     * should be taken into account when using the dirty region.
     * This will be false for NGGroup (but not for NGRegion)
     * @return true if the node has some visuals
     */
    protected boolean hasVisuals() {
        return true;
    }

    /***************************************************************************
     *                                                                         *
     * Culling                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Culling support for multiple dirty regions.
     * Set culling bits for the whole graph.
     * @param drc Array of dirty regions. Cannot be null.
     * @param tx The transform for this render operation. Cannot be null.
     * @param pvTx Perspective camera transformation. Cannot be null.
     */
    public final void doPreCulling(DirtyRegionContainer drc, BaseTransform tx, GeneralTransform3D pvTx) {
        if (drc == null || tx == null || pvTx == null) throw new NullPointerException();
        markCullRegions(drc, -1, tx, pvTx);
    }

    /**
     * Marks placement of the node in dirty region encoded into 2 bit flag:
     * 00 - node outside dirty region
     * 01 - node intersecting dirty region
     * 11 - node completely within dirty region
     *
     * 32 bits = 15 regions max. * 2 bit each. The first two bits are not used
     * because we have a special use case for -1, so they should only be set if
     * in that case.
     *
     * @param drc The array of dirty regions.
     * @param cullingRegionsBitsOfParent culling bits of parent. -1 if there's no parent.
     * @param tx The transform for this render operation. Cannot be null.
     * @param pvTx Perspective camera transform. Cannot be null.
     */
    void markCullRegions(
            DirtyRegionContainer drc,
            int cullingRegionsBitsOfParent,
            BaseTransform tx,
            GeneralTransform3D pvTx) {

        // Spent a long time tracking down how cullingRegionsBitsOfParent works. Note that it is
        // not just the parent's bits, but also -1 in the case of the &quot;root&quot;, where the root is
        // either the actual root, or the root of a sub-render operation such as occurs with
        // render-to-texture for effects!

        if (tx.isIdentity()) {
            TEMP_BOUNDS.deriveWithNewBounds(transformedBounds);
        } else {
            tx.transform(transformedBounds, TEMP_BOUNDS);
        }

        if (!pvTx.isIdentity()) {
            pvTx.transform(TEMP_BOUNDS, TEMP_BOUNDS);
        }

        TEMP_BOUNDS.flattenInto(TEMP_RECT_BOUNDS);

        cullingBits = 0;
        RectBounds region;
        int mask = 0x1; // Check only for intersections
        for(int i = 0; i &lt; drc.size(); i++) {
            region = drc.getDirtyRegion(i);
            if (region == null || region.isEmpty()) {
                break;
            }
            // For each dirty region, we will check to see if this child
            // intersects with the dirty region and whether it contains the
            // dirty region. Note however, that we only care to mark those
            // child nodes which are inside a group that intersects. We don't
            // care about marking child nodes which are within a parent which
            // is wholly contained within the dirty region.
            if ((cullingRegionsBitsOfParent == -1 || (cullingRegionsBitsOfParent &amp; mask) != 0) &amp;&amp;
                    region.intersects(TEMP_RECT_BOUNDS)) {
                int b = DIRTY_REGION_INTERSECTS_NODE_BOUNDS;
                if (region.contains(TEMP_RECT_BOUNDS)) {
                    b = DIRTY_REGION_CONTAINS_NODE_BOUNDS;
                }
                cullingBits = cullingBits | (b &lt;&lt; (2 * i));
            }
            mask = mask &lt;&lt; 2;
        }//for

        // If we are going to cull a node/group that's dirty,
        // make sure it's dirty flags are properly cleared.
        if (cullingBits == 0 &amp;&amp; (dirty != DirtyFlag.CLEAN || childDirty)) {
            clearDirtyTree();
        }

//        System.out.printf(&quot;%s bits: %s bounds: %s\n&quot;,
//            this, Integer.toBinaryString(cullingBits), TEMP_RECT_BOUNDS);
    }

    /**
     * Fills the given StringBuilder with text representing the structure of the NG graph insofar as dirty
     * opts is concerned. Used for debug purposes. This is typically called on the root node. The List of
     * roots is the list of dirty roots as determined by successive calls to getRenderRoot for each dirty
     * region. The output will be prefixed with a key indicating how to interpret the printout.
     *
     * @param s A StringBuilder to fill with the output.
     * @param roots The list of render roots (may be empty, must not be null).
     */
    public final void printDirtyOpts(StringBuilder s, List&lt;NGNode&gt; roots) {
        s.append(&quot;\n*=Render Root\n&quot;);
        s.append(&quot;d=Dirty\n&quot;);
        s.append(&quot;dt=Dirty By Translation\n&quot;);
        s.append(&quot;i=Dirty Region Intersects the NGNode\n&quot;);
        s.append(&quot;c=Dirty Region Contains the NGNode\n&quot;);
        s.append(&quot;ef=Effect Filter\n&quot;);
        s.append(&quot;cf=Cache Filter\n&quot;);
        s.append(&quot;cl=This node is a clip node\n&quot;);
        s.append(&quot;b=Blend mode is set\n&quot;);
        s.append(&quot;or=Opaque Region\n&quot;);
        printDirtyOpts(s, this, BaseTransform.IDENTITY_TRANSFORM, &quot;&quot;, roots);
    }

    /**
     * Used for debug purposes. Recursively visits all NGNodes and prints those that are possibly part of
     * the render operation and annotates each node.
     *
     * @param s The String builder
     * @param node The node that we're printing out information about
     * @param tx The transform
     * @param prefix Some prefix to put in front of the node output (mostly spacing)
     * @param roots The different dirty roots, if any.
     */
    private final void printDirtyOpts(StringBuilder s, NGNode node, BaseTransform tx, String prefix, List&lt;NGNode&gt; roots) {
        if (!node.isVisible() || node.getOpacity() == 0) return;

        BaseTransform copy = tx.copy();
        copy = copy.deriveWithConcatenation(node.getTransform());
        List&lt;String&gt; stuff = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;roots.size(); i++) {
            NGNode root = roots.get(i);
            if (node == root) stuff.add(&quot;*&quot; + i);
        }

        if (node.dirty != NGNode.DirtyFlag.CLEAN) {
            stuff.add(node.dirty == NGNode.DirtyFlag.DIRTY ? &quot;d&quot; : &quot;dt&quot;);
        }

        if (node.cullingBits != 0) {
            int mask = 0x11;
            for (int i=0; i&lt;15; i++) {
                int bits = node.cullingBits &amp; mask;
                if (bits != 0) {
                    stuff.add(bits == 1 ? &quot;i&quot; + i : bits == 0 ? &quot;c&quot; + i : &quot;ci&quot; + i);
                }
                mask = mask &lt;&lt; 2;
            }
        }

        if (node.effectFilter != null) stuff.add(&quot;ef&quot;);
        if (node.cacheFilter != null) stuff.add(&quot;cf&quot;);
        if (node.nodeBlendMode != null) stuff.add(&quot;b&quot;);

        RectBounds opaqueRegion = node.getOpaqueRegion();
        if (opaqueRegion != null) {
            RectBounds or = new RectBounds();
            copy.transform(opaqueRegion, or);
            stuff.add(&quot;or=&quot; + or.getMinX() + &quot;, &quot; + or.getMinY() + &quot;, &quot; + or.getWidth() + &quot;, &quot; + or.getHeight());
        }

        if (stuff.isEmpty()) {
            s.append(prefix + node.name + &quot;\n&quot;);
        } else {
            String postfix = &quot; [&quot;;
            for (int i=0; i&lt;stuff.size(); i++) {
                postfix = postfix + stuff.get(i);
                if (i &lt; stuff.size() - 1) postfix += &quot; &quot;;
            }
            s.append(prefix + node.name + postfix + &quot;]\n&quot;);
        }

        if (node.getClipNode() != null) {
            printDirtyOpts(s, node.getClipNode(), copy, prefix + &quot;  cl &quot;, roots);
        }

        if (node instanceof NGGroup) {
            NGGroup g = (NGGroup)node;
            for (int i=0; i&lt;g.getChildren().size(); i++) {
                printDirtyOpts(s, g.getChildren().get(i), copy, prefix + &quot;  &quot;, roots);
            }
        }
    }

    /**
     * Helper method draws rectangles indicating the overdraw rectangles.
     *
     * @param tx The scene-&gt;parent transform.
     * @param pvTx The perspective camera transform.
     * @param clipBounds The bounds in scene coordinates
     * @param colorBuffer A pixel array where each pixel contains a color indicating how many times
     *                    it has been &quot;drawn&quot;
     * @param dirtyRegionIndex the index of the dirty region we're gathering information for. This is
     *                         needed so we can shift the &quot;painted&quot; field to find out if this node
     *                         was drawn in this dirty region.
     */
    public void drawDirtyOpts(final BaseTransform tx, final GeneralTransform3D pvTx,
                              Rectangle clipBounds, int[] colorBuffer, int dirtyRegionIndex) {
        if ((painted &amp; (1 &lt;&lt; (dirtyRegionIndex * 2))) != 0) {
            // Transforming the content bounds (which includes the clip) to screen coordinates
            tx.copy().deriveWithConcatenation(getTransform()).transform(contentBounds, TEMP_BOUNDS);
            if (pvTx != null) pvTx.transform(TEMP_BOUNDS, TEMP_BOUNDS);
            RectBounds bounds = new RectBounds();
            TEMP_BOUNDS.flattenInto(bounds);

            // Adjust the bounds so that they are relative to the clip. The colorBuffer is sized
            // exactly the same as the clip, and the elements of the colorBuffer represent the
            // pixels inside the clip. However the bounds of this node may overlap the clip in
            // some manner, so we adjust them such that x, y, w, h will be the adjusted bounds.
            assert clipBounds.width * clipBounds.height == colorBuffer.length;
            bounds.intersectWith(clipBounds);
            int x = (int) bounds.getMinX() - clipBounds.x;
            int y = (int) bounds.getMinY() - clipBounds.y;
            int w = (int) (bounds.getWidth() + .5);
            int h = (int) (bounds.getHeight() + .5);

            if (w == 0 || h == 0) {
                // I would normally say we should never reach this point, as it means something was
                // marked as painted but really couldn't have been.
                return;
            }

            // x, y, w, h are 0 based and will fit within the clip, so now we can simply update
            // all the pixels that fall within these bounds.
            for (int i = y; i &lt; y+h; i++) {
                for (int j = x; j &lt; x+w; j++) {
                    final int index = i * clipBounds.width + j;
                    int color = colorBuffer[index];

                    // This is kind of a dirty hack. The idea is to show green if 0 or 1
                    // times a pixel is drawn, Yellow for 2 or 3 times, and red for more
                    // Than that. So I use 0x80007F00 as the first green color, and
                    // 0x80008000 as the second green color, but their so close to the same
                    // thing you probably won't be able to tell them apart, but I can tell
                    // numerically they're different and increment (so I use the colors
                    // as my counters).
                    if (color == 0) {
                        color = 0x8007F00;
                    } else if ((painted &amp; (3 &lt;&lt; (dirtyRegionIndex * 2))) == 3) {
                        switch (color) {
                            case 0x80007F00:
                                color = 0x80008000;
                                break;
                            case 0x80008000:
                                color = 0x807F7F00;
                                break;
                            case 0x807F7F00:
                                color = 0x80808000;
                                break;
                            case 0x80808000:
                                color = 0x807F0000;
                                break;
                            default:
                                color = 0x80800000;
                        }
                    }
                    colorBuffer[index] = color;
                }
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Identifying render roots                                                *
     *                                                                         *
     **************************************************************************/
    protected static enum RenderRootResult {
        /**
         * A Node returns NO_RENDER_ROOT when it is not a render root because
         * it does not have an opaqueRegion which completely covers the area
         * of the clip. Maybe the node is dirty, but outside the dirty region
         * that we're currently processing. For an NGGroup, returning
         * NO_RENDER_ROOT means that there is no render root (occluder) within
         * this entire branch of the tree.
         */
        NO_RENDER_ROOT,
        /**
         * A Node returns HAS_RENDER_ROOT when its opaque region completely
         * covers the clip. An NGGroup returns HAS_RENDER_ROOT when one of
         * its children either returned HAS_RENDER_ROOT or HAS_RENDER_ROOT_AND_IS_CLEAN.
         */
        HAS_RENDER_ROOT,
        /**
         * A Node returns HAS_RENDER_ROOT_AND_IS_CLEAN when its opaque region
         * completely covers the clip and the Node is, itself, clean. An NGNode
         * returns HAS_RENDER_ROOT_AND_IS_CLEAN only if it had a child that
         * returned HAS_RENDER_ROOT_AND_IS_CLEAN and none of its children drawn
         * above the render root are dirty.
         *
         * This optimization allows us to recognize situations where perhaps there
         * were some dirty nodes, but they are completely covered by an occluder,
         * and therefore we don't actually have to draw anything.
         */
        HAS_RENDER_ROOT_AND_IS_CLEAN,
    }

    /**
     * Called &lt;strong&gt;after&lt;/strong&gt; preCullingBits in order to get the node
     * from which we should begin drawing. This is our support for occlusion culling.
     * This should only be called on the root node.
     *
     * If no render root was found, we need to render everything from this root, so the path will contain this node.
     * If no rendering is needed (everything dirty is occluded), the path will remain empty
     *
     * @param path node path to store the node path
     */
    public final void getRenderRoot(NodePath path, RectBounds dirtyRegion, int cullingIndex,
                                    BaseTransform tx, GeneralTransform3D pvTx) {

        // This is the main entry point, make sure to check these inputs for validity
        if (path == null || dirtyRegion == null || tx == null || pvTx == null) {
            throw new NullPointerException();
        }
        if (cullingIndex &lt; -1 || cullingIndex &gt; 15) {
            throw new IllegalArgumentException(&quot;cullingIndex cannot be &lt; -1 or &gt; 15&quot;);
        }

        // This method must NEVER BE CALLED if the depth buffer is turned on. I don't have a good way to test
        // for that because NGNode doesn't have a reference to the scene it is a part of...

        RenderRootResult result = computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
        if (result == RenderRootResult.NO_RENDER_ROOT) {
            // We didn't find any render root, which means that no one node was large enough
            // to obscure the entire dirty region (or, possibly, some combination of nodes in an
            // NGGroup were not, together, large enough to do the job). So we need to render
            // from the root node, which is this node.
            path.add(this);
        } else if (result == RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN) {
            // We've found a render root, and it is clean and everything above it in painter order
            // is clean, so actually we have nothing to paint this time around (some stuff must
            // have been dirty which is completely occluded by the render root). So we can clear
            // the path, which indicates to the caller that nothing needs to be painted.
            path.clear();
        }
    }

    /**
     * Searches for the last node that covers all of the specified dirty region with an opaque region,
     * in this node's subtree. Such a node can serve as a rendering root as all nodes preceding the node
     * will be covered by it.
     *
     * @param path the NodePath to populate with the path to the render root. Cannot be null.
     * @param dirtyRegion the current dirty region. Cannot be null.
     * @param cullingIndex index of culling information
     * @param tx current transform. Cannot be null.
     * @param pvTx current perspective transform. Cannot be null.
     * @return The result of visiting this node.
     */
    RenderRootResult computeRenderRoot(NodePath path, RectBounds dirtyRegion,
                                       int cullingIndex, BaseTransform tx, GeneralTransform3D pvTx) {
        return computeNodeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
    }

    private static Point2D[] TEMP_POINTS2D_4 =
            new Point2D[] { new Point2D(), new Point2D(), new Point2D(), new Point2D() };

    // Whether (px, py) is clockwise or counter-clockwise to a-&gt;b
    private static int ccw(double px, double py, Point2D a, Point2D b) {
        return (int)Math.signum(((b.x - a.x) * (py - a.y)) - (b.y - a.y) * (px - a.x));
    }

    private static boolean pointInConvexQuad(double x, double y, Point2D[] rect) {
        int ccw01 = ccw(x, y, rect[0], rect[1]);
        int ccw12 = ccw(x, y, rect[1], rect[2]);
        int ccw23 = ccw(x, y, rect[2], rect[3]);
        int ccw31 = ccw(x, y, rect[3], rect[0]);

        // Possible results after this operation:
        // 0 -&gt; 0 (0x0)
        // 1 -&gt; 1 (0x1)
        // -1 -&gt; Integer.MIN_VALUE (0x80000000)
        ccw01 ^= (ccw01 &gt;&gt;&gt; 1);
        ccw12 ^= (ccw12 &gt;&gt;&gt; 1);
        ccw23 ^= (ccw23 &gt;&gt;&gt; 1);
        ccw31 ^= (ccw31 &gt;&gt;&gt; 1);

        final int union = ccw01 | ccw12 | ccw23 | ccw31;
        // This means all ccw* were either (-1 or 0) or (1 or 0), but not all of them were 0
        return union == 0x80000000 || union == 0x1;
        // Or alternatively...
//        return (union ^ (union &lt;&lt; 31)) &lt; 0;
    }

    /**
     * Check if this node can serve as rendering root for this dirty region.
     *
     * @param path the NodePath to populate with the path to the render root. Cannot be null.
     * @param dirtyRegion the current dirty region. Cannot be null.
     * @param cullingIndex index of culling information, -1 means culling information should not be used
     * @param tx current transform. Cannot be null.
     * @param pvTx current perspective transform. Cannot be null.
     * @return NO_RENDER_ROOT if this node does &lt;em&gt;not&lt;/em&gt; have an opaque
     *         region that fills the entire dirty region. Returns HAS_RENDER_ROOT
     *         if the opaque region fills the dirty region.
     */
    final RenderRootResult computeNodeRenderRoot(NodePath path, RectBounds dirtyRegion,
                                                 int cullingIndex, BaseTransform tx, GeneralTransform3D pvTx) {

        // Nodes outside of the dirty region can be excluded immediately.
        // This can be used only if the culling information is provided.
        if (cullingIndex != -1) {
            final int bits = cullingBits &gt;&gt; (cullingIndex * 2);
            if ((bits &amp; DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS) == 0x00) {
                return RenderRootResult.NO_RENDER_ROOT;
            }
        }

        if (!isVisible()) {
            return RenderRootResult.NO_RENDER_ROOT;
        }

        final RectBounds opaqueRegion = getOpaqueRegion();
        if (opaqueRegion == null) return RenderRootResult.NO_RENDER_ROOT;

        final BaseTransform localToParentTx = getTransform();

        BaseTransform localToSceneTx = TEMP_TRANSFORM.deriveWithNewTransform(tx).deriveWithConcatenation(localToParentTx);

        // Now check if the dirty region is fully contained in our opaque region. Suppose the above
        // transform included a rotation about Z. In these cases, the transformed
        // opaqueRegion might be some non-axis aligned quad. So what we need to do is to check
        // that each corner of the dirty region lies within the (potentially rotated) quad
        // of the opaqueRegion.
        if (checkBoundsInQuad(opaqueRegion, dirtyRegion, localToSceneTx, pvTx)) {
            // This node is a render root.
            path.add(this);
            return isClean() ? RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN : RenderRootResult.HAS_RENDER_ROOT;
        }

        return RenderRootResult.NO_RENDER_ROOT;
    }

    static boolean checkBoundsInQuad(RectBounds untransformedQuad,
            RectBounds innerBounds, BaseTransform tx, GeneralTransform3D pvTx) {

        if (pvTx.isIdentity() &amp;&amp; (tx.getType() &amp; ~(BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_QUADRANT_ROTATION
                | BaseTransform.TYPE_MASK_SCALE)) == 0) {
            // If pvTx is identity and there's simple transformation that will result in axis-aligned rectangle,
            // we can do a quick test by using bound.contains()
            if (tx.isIdentity()) {
                TEMP_BOUNDS.deriveWithNewBounds(untransformedQuad);
            } else {
                tx.transform(untransformedQuad, TEMP_BOUNDS);
            }

            TEMP_BOUNDS.flattenInto(TEMP_RECT_BOUNDS);

            return TEMP_RECT_BOUNDS.contains(innerBounds);
        } else {
            TEMP_POINTS2D_4[0].setLocation(untransformedQuad.getMinX(), untransformedQuad.getMinY());
            TEMP_POINTS2D_4[1].setLocation(untransformedQuad.getMaxX(), untransformedQuad.getMinY());
            TEMP_POINTS2D_4[2].setLocation(untransformedQuad.getMaxX(), untransformedQuad.getMaxY());
            TEMP_POINTS2D_4[3].setLocation(untransformedQuad.getMinX(), untransformedQuad.getMaxY());

            for (Point2D p : TEMP_POINTS2D_4) {
                tx.transform(p, p);
                if (!pvTx.isIdentity()) {
                    pvTx.transform(p, p);
                }
            }

            return (pointInConvexQuad(innerBounds.getMinX(), innerBounds.getMinY(), TEMP_POINTS2D_4)
                    &amp;&amp; pointInConvexQuad(innerBounds.getMaxX(), innerBounds.getMinY(), TEMP_POINTS2D_4)
                    &amp;&amp; pointInConvexQuad(innerBounds.getMaxX(), innerBounds.getMaxY(), TEMP_POINTS2D_4)
                    &amp;&amp; pointInConvexQuad(innerBounds.getMinX(), innerBounds.getMaxY(), TEMP_POINTS2D_4));
        }
    }

    /**
     * Invalidates any cached representation of the opaque region for this node. On the next
     * call to getOpaqueRegion, the opaque region will be recalculated. Any changes to state
     * which is used in the {@link #hasOpaqueRegion()} call must invoke this method
     * or the opaque region calculations will be wrong.
     */
    protected final void invalidateOpaqueRegion() {
        opaqueRegionInvalid = true;
        if (isClip) parent.invalidateOpaqueRegion();
    }

    /**
     * This method exists only for the sake of testing.
     * @return value of opaqueRegionInvalid
     */
    final boolean isOpaqueRegionInvalid() {
        return opaqueRegionInvalid;
    }

    /**
     * Gets the opaque region for this node, if there is one, or returns null.
     * @return The opaque region for this node, or null.
     */
    public final RectBounds getOpaqueRegion() {
        // Note that when we invalidate the opaqueRegion of an NGNode, we don't
        // walk up the tree or communicate with the parents (unlike dirty flags).
        // An NGGroup does not compute an opaqueRegion based on the union of opaque
        // regions of its children (although this is a fine idea to consider!). See RT-32441
        // If we ever fix RT-32441, we must be sure to handle the case of a Group being used
        // as a clip node (such that invalidating a child on the group invalidates the
        // opaque region of every node up to the root).

        // Because the Effect classes have no reference to NGNode, they cannot tell the
        // NGNode to invalidate the opaque region whenever properties on the Effect that
        // would impact the opaqueRegion change. As a result, when an Effect is specified
        // on the NGNode, we will always treat it as if it were invalid. A more invasive
        // (but better) change would be to give Effect the ability to invalidate the
        // NGNode's opaque region when needed.
        if (opaqueRegionInvalid || getEffect() != null) {
            opaqueRegionInvalid = false;
            if (supportsOpaqueRegions() &amp;&amp; hasOpaqueRegion()) {
                opaqueRegion = computeOpaqueRegion(opaqueRegion == null ? new RectBounds() : opaqueRegion);
                // If we got a null result then we encountered an error condition where somebody
                // claimed supportsOpaqueRegions and hasOpaqueRegion, but then they
                // returned null! This should never happen, so we have an assert here. However since
                // assertions are disabled at runtime and we want to avoid the NPE, we also perform
                // a null check.
                assert opaqueRegion != null;
                if (opaqueRegion == null) {
                    return null;
                }
                // If there is a clip, then we need to determine the opaque region of the clip, and
                // intersect that with our existing opaque region. For example, if I had a rectangle
                // with a circle for its clip (centered over the rectangle), then the result needs to
                // be the circle's opaque region.
                final NGNode clip = getClipNode();
                if (clip != null) {
                    final RectBounds clipOpaqueRegion = clip.getOpaqueRegion();
                    // Technically a flip/quadrant rotation is allowed as well, but we don't have a convenient
                    // way to do that yet.
                    if (clipOpaqueRegion == null || (clip.getTransform().getType() &amp; ~(BaseTransform.TYPE_TRANSLATION | BaseTransform.TYPE_MASK_SCALE)) != 0) {
                        // RT-25095: If this node has a clip who's opaque region cannot be determined, then
                        // we cannot determine any opaque region for this node (in fact, it might not have one).
                        // Also, if the transform is something other than identity, scale, or translate then
                        // we're just going to bail (sorry, rotate, maybe next time!)
                        return opaqueRegion = null;
                    }
                    // We have to take into account any transform specified on the clip to put
                    // it into the same coordinate system as this node
                    final BaseBounds b = clip.getTransform().transform(clipOpaqueRegion, TEMP_BOUNDS);
                    b.flattenInto(TEMP_RECT_BOUNDS);
                    opaqueRegion.intersectWith(TEMP_RECT_BOUNDS);

                }
            } else {
                // The opaqueRegion may have been non-null in the past, but there isn't an opaque region now,
                // so we will nuke it to save some memory
                opaqueRegion = null;
            }
        }

        return opaqueRegion;
    }

    /**
     * Gets whether this NGNode supports opaque regions at all. Most node types do not,
     * but some do. If an NGNode subclass is written to support opaque regions, it must override
     * this method to return true. The subclass must then also override the computeDirtyRegion method
     * to return the dirty region, or null if the node in its current state doesn't have one.
     * This method is intended to be immutable.
     *
     * @return Whether this NGNode implementation supports opaque regions. This could also have been
     *         implemented via an interface that some NGNodes implemented, but then we'd have instanceof
     *         checks which I'd rather avoid.
     */
    protected boolean supportsOpaqueRegions() { return false; }

    /**
     * Called only on NGNode subclasses which override {@link #supportsOpaqueRegions()} to return
     * true, this method will return whether or not this NGNode is in a state where it has
     * an opaque region to actually return. If this method returns true, a subsequent call to
     * {@link #computeOpaqueRegion(com.sun.javafx.geom.RectBounds)} &lt;strong&gt;must&lt;/strong&gt; return
     * a non-null result. Any state used in the computation of this method, when it changes, must
     * result in a call to {@link #invalidateOpaqueRegion()}.
     *
     * @return Whether this NGNode currently has an opaque region.
     */
    protected boolean hasOpaqueRegion() {
        final NGNode clip = getClipNode();
        final Effect effect = getEffect();
        return (effect == null || !effect.reducesOpaquePixels()) &amp;&amp;
               getOpacity() == 1f &amp;&amp;
               (nodeBlendMode == null || nodeBlendMode == Blend.Mode.SRC_OVER) &amp;&amp;
               (clip == null ||
               (clip.supportsOpaqueRegions() &amp;&amp; clip.hasOpaqueRegion()));
    }

    /**
     * Computes and returns the opaque region for this node. This method
     * @param opaqueRegion
     * @return
     */
    protected RectBounds computeOpaqueRegion(RectBounds opaqueRegion) {
        return null;
    }

    /**
     * Returns whether a clip represented by this node can be rendered using
     * axis aligned rect clip. The default implementation returns false,
     * specific subclasses should override to return true when appropriate.
     *
     * @return whether this rectangle is axis aligned when rendered given node's
     * and rendering transform
     */
    protected boolean isRectClip(BaseTransform xform, boolean permitRoundedRectangle) {
        return false;
    }

    /***************************************************************************
     *                                                                         *
     * Rendering                                                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Render the tree of nodes to the specified G (graphics) object
     * descending from this node as the root. This method is designed to avoid
     * generated trash as much as possible while descending through the
     * render graph while rendering. This is the appropriate method both to
     * initiate painting of an entire scene, and for a branch. The NGGroup
     * implementation must call this method on each child, not doRender directly.
     *
     * @param g The graphics object we're rendering to. This must never be null.
     */
    public final void render(Graphics g) {
        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;Nodes visited during render&quot;);
        }
        // Clear the visuals changed flag
        clearDirty();
        // If it isn't visible, then punt
        if (!visible || opacity == 0f) return;

        // We know that we are going to render this node, so we call the
        // doRender method, which subclasses implement to do the actual
        // rendering work.
        doRender(g);
    }

    /**
     * Called on every render pulse for all nodes in case they have render-time
     * operations that must be completed on a pulse, but were not otherwise
     * rendered by the ordinary damage management logic.
     * The graphics argument will be the graphics that was used to render the
     * scene if it is available, but may be null for cases when the scene
     * required no visible updates and thus no back buffer graphics was
     * actually obtained.  Implementors must have a backup plan for that
     * case when the Graphics object is null.
     *
     * @param gOptional the Graphics object that was used to render the
     *                  Scene, or null
     */
    public void renderForcedContent(Graphics gOptional) {
    }

    // This node requires 2D graphics state for rendering
    boolean isShape3D() {
        return false;
    }

    /**
     * Invoked only by the final render method. Implementations
     * of this method should make sure to save &amp; restore the transform state.
     */
    protected void doRender(Graphics g) {

        g.setState3D(isShape3D());

        boolean preCullingTurnedOff = false;
        if (PrismSettings.dirtyOptsEnabled) {
            if (g.hasPreCullingBits()) {
                //preculling bits available
                final int bits = cullingBits &gt;&gt; (g.getClipRectIndex() * 2);
                if ((bits &amp; DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS) == 0) {
                    // If no culling bits are set for this region, this group
                    // does not intersect (nor is covered by) the region
                    return;
                } else if ((bits &amp; DIRTY_REGION_CONTAINS_NODE_BOUNDS) != 0) {
                    // When this group is fully covered by the region,
                    // turn off the culling checks in the subtree, as everything
                    // gets rendered
                    g.setHasPreCullingBits(false);
                    preCullingTurnedOff = true;
                }
            }
        }

        // save current depth test state
        boolean prevDepthTest = g.isDepthTest();

        // Apply Depth test for this node
        // (note that this will only be used if we have a depth buffer for the
        // surface to which we are rendering)
        g.setDepthTest(isDepthTest());

        // save current transform state
        BaseTransform prevXform = g.getTransformNoClone();

        double mxx = prevXform.getMxx();
        double mxy = prevXform.getMxy();
        double mxz = prevXform.getMxz();
        double mxt = prevXform.getMxt();

        double myx = prevXform.getMyx();
        double myy = prevXform.getMyy();
        double myz = prevXform.getMyz();
        double myt = prevXform.getMyt();

        double mzx = prevXform.getMzx();
        double mzy = prevXform.getMzy();
        double mzz = prevXform.getMzz();
        double mzt = prevXform.getMzt();

        // filters are applied in the following order:
        //   transform
        //   blend mode
        //   opacity
        //   cache
        //   clip
        //   effect
        // The clip must be below the cache filter, as this is expected in the
        // CacheFilter in order to apply scrolling optimization
        g.transform(getTransform());
        // Try to keep track of whether this node was *really* painted. Still an
        // approximation, but somewhat more accurate (at least it doesn't include
        // groups which don't paint anything themselves).
        boolean p = false;
        // NOTE: Opt out 2D operations on 3D Shapes, which are not yet handled by Prism
        if (!isShape3D() &amp;&amp; g instanceof ReadbackGraphics &amp;&amp; needsBlending()) {
            renderNodeBlendMode(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getOpacity() &lt; 1f) {
            renderOpacity(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getCacheFilter() != null) {
            renderCached(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getClipNode() != null) {
            renderClip(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getEffectFilter() != null &amp;&amp; effectsSupported) {
            renderEffect(g);
            p = true;
        } else {
            renderContent(g);
            if (PrismSettings.showOverdraw) {
                p = this instanceof NGRegion || !(this instanceof NGGroup);
            }
        }

        if (preCullingTurnedOff) {
            g.setHasPreCullingBits(true);
        }

        // restore previous transform state
        g.setTransform3D(mxx, mxy, mxz, mxt,
                         myx, myy, myz, myt,
                         mzx, mzy, mzz, mzt);

        // restore previous depth test state
        g.setDepthTest(prevDepthTest);

        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;Nodes rendered&quot;);
        }

        // Used for debug purposes. This is not entirely accurate, as it doesn't measure the
        // number of times this node drew to the pixels, and in some cases reports a node as
        // having been drawn even when it didn't lay down any pixels. We'd need to integrate
        // with our shaders or do something much more invasive to get better data here.
        if (PrismSettings.showOverdraw) {
            if (p) {
                painted |= 3 &lt;&lt; (g.getClipRectIndex() * 2);
            } else {
                painted |= 1 &lt;&lt; (g.getClipRectIndex() * 2);
            }
        }
    }

    /**
     * Return true if this node has a blend mode that requires special
     * processing.
     * Regular nodes can handle null or SRC_OVER just by rendering into
     * the existing buffer.
     * Groups override this since they must collect their children into
     * a single rendering pass if their mode is explicitly SRC_OVER.
     * @return true if this node needs special blending support
     */
    protected boolean needsBlending() {
        Blend.Mode mode = getNodeBlendMode();
        return (mode != null &amp;&amp; mode != Blend.Mode.SRC_OVER);
    }

    private void renderNodeBlendMode(Graphics g) {
        // The following is safe; curXform will not be mutated below
        BaseTransform curXform = g.getTransformNoClone();

        BaseBounds clipBounds = getClippedBounds(new RectBounds(), curXform);
        if (clipBounds.isEmpty()) {
            clearDirtyTree();
            return;
        }

        if (!isReadbackSupported(g)) {
            if (getOpacity() &lt; 1f) {
                renderOpacity(g);
            } else if (getClipNode() != null) {
                renderClip(g);
            } else {
                renderContent(g);
            }
            return;
        }

        // TODO: optimize this (RT-26936)
        // Extract clip bounds
        Rectangle clipRect = new Rectangle(clipBounds);
        clipRect.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));

        // render the node content into the first offscreen image
        FilterContext fctx = getFilterContext(g);
        PrDrawable contentImg = (PrDrawable)
            Effect.getCompatibleImage(fctx, clipRect.width, clipRect.height);
        if (contentImg == null) {
            clearDirtyTree();
            return;
        }
        Graphics gContentImg = contentImg.createGraphics();
        gContentImg.setHasPreCullingBits(g.hasPreCullingBits());
        gContentImg.setClipRectIndex(g.getClipRectIndex());
        gContentImg.translate(-clipRect.x, -clipRect.y);
        gContentImg.transform(curXform);
        if (getOpacity() &lt; 1f) {
            renderOpacity(gContentImg);
        } else if (getCacheFilter() != null) {
            renderCached(gContentImg);
        } else if (getClipNode() != null) {
            renderClip(g);
        } else if (getEffectFilter() != null) {
            renderEffect(gContentImg);
        } else {
            renderContent(gContentImg);
        }

        // the above image has already been rendered in device space, so
        // just translate to the node origin in device space here...
        RTTexture bgRTT = ((ReadbackGraphics) g).readBack(clipRect);
<A NAME="55"></A>        PrDrawable bgPrD = PrDrawable.create(fctx, bgRTT);
        Blend blend = new Blend(getNodeBlendMode(),
                                new PassThrough(bgPrD, clipRect),
                                <FONT color="#4863a0"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#55',2,'match42-top.html#55',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new PassThrough(contentImg, clipRect));
        CompositeMode oldmode = g.getCompositeMode();
        g.setTransform(null);
        g.setCompositeMode(CompositeMode.SRC);
        PrEffectHelper.render(blend, g, 0, 0, null);
        g.setCompositeMode(oldmode);
        // transform state will be restored in render() method above...

        Effect.releaseCompatibleImage(fctx, contentImg);
        ((ReadbackGraphics) g).releaseReadBackBuffer(bgRTT);
    }</B></FONT>

    private void renderRectClip(Graphics g, NGRectangle clipNode) {
        BaseBounds newClip = clipNode.getShape().getBounds();
        if (!clipNode.getTransform().isIdentity()) {
            newClip = clipNode.getTransform().transform(newClip, newClip);
        }
        final BaseTransform curXform = g.getTransformNoClone();
        final Rectangle curClip = g.getClipRectNoClone();
        newClip = curXform.transform(newClip, newClip);
        newClip.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));
        if (newClip.isEmpty() ||
            newClip.getWidth() == 0 ||
            newClip.getHeight() == 0) {
            clearDirtyTree();
            return;
        }
        // REMIND: avoid garbage by changing setClipRect to accept xywh
        g.setClipRect(new Rectangle(newClip));
        renderForClip(g);
        g.setClipRect(curClip);
        clipNode.clearDirty(); // as render() is not called on the clipNode,
                               // make sure the dirty flags are cleared
    }

    void renderClip(Graphics g) {
        //  if clip's opacity is 0 there's nothing to render
        if (getClipNode().getOpacity() == 0.0) {
            clearDirtyTree();
            return;
        }

        // The following is safe; curXform will not be mutated below
        BaseTransform curXform = g.getTransformNoClone();

        BaseBounds clipBounds = getClippedBounds(new RectBounds(), curXform);
        if (clipBounds.isEmpty()) {
            clearDirtyTree();
            return;
        }

        if (getClipNode() instanceof NGRectangle) {
            // optimized case for rectangular clip
            NGRectangle rectNode = (NGRectangle)getClipNode();
            if (rectNode.isRectClip(curXform, false)) {
                renderRectClip(g, rectNode);
                return;
            }
        }

        // TODO: optimize this (RT-26936)
        // Extract clip bounds
        Rectangle clipRect = new Rectangle(clipBounds);
        clipRect.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));

        if (!curXform.is2D()) {
            Rectangle savedClip = g.getClipRect();
            g.setClipRect(clipRect);
            NodeEffectInput clipInput =
                new NodeEffectInput(getClipNode(),
                                    NodeEffectInput.RenderType.FULL_CONTENT);
            NodeEffectInput nodeInput =
                new NodeEffectInput(this,
                                    NodeEffectInput.RenderType.CLIPPED_CONTENT);
            Blend blend = new Blend(Blend.Mode.SRC_IN, clipInput, nodeInput);
            PrEffectHelper.render(blend, g, 0, 0, null);
            clipInput.flush();
            nodeInput.flush();
            g.setClipRect(savedClip);
            // There may have been some errors in the application of the
            // effect and we would not know to what extent the nodes were
            // rendered and cleared or left dirty.  clearDirtyTree() will
            // clear both this node its clip node, and it will not recurse
            // to the children unless they are still marked dirty.  It should
            // be cheap if there was no problem and thorough if there was...
            clearDirtyTree();
            return;
        }

        // render the node content into the first offscreen image
        FilterContext fctx = getFilterContext(g);
        PrDrawable contentImg = (PrDrawable)
            Effect.getCompatibleImage(fctx, clipRect.width, clipRect.height);
        if (contentImg == null) {
            clearDirtyTree();
            return;
        }
        Graphics gContentImg = contentImg.createGraphics();
        gContentImg.setExtraAlpha(g.getExtraAlpha());
        gContentImg.setHasPreCullingBits(g.hasPreCullingBits());
        gContentImg.setClipRectIndex(g.getClipRectIndex());
        gContentImg.translate(-clipRect.x, -clipRect.y);
        gContentImg.transform(curXform);
        renderForClip(gContentImg);

        // render the mask (clipNode) into the second offscreen image
        PrDrawable clipImg = (PrDrawable)
            Effect.getCompatibleImage(fctx, clipRect.width, clipRect.height);
        if (clipImg == null) {
            getClipNode().clearDirtyTree();
            Effect.releaseCompatibleImage(fctx, contentImg);
            return;
        }
        Graphics gClipImg = clipImg.createGraphics();
        gClipImg.translate(-clipRect.x, -clipRect.y);
        gClipImg.transform(curXform);
        getClipNode().render(gClipImg);

        // the above images have already been rendered in device space, so
        // just translate to the node origin in device space here...
        g.setTransform(null);
        Blend blend = new Blend(Blend.Mode.SRC_IN,
                                new PassThrough(clipImg, clipRect),
                                new PassThrough(contentImg, clipRect));
        PrEffectHelper.render(blend, g, 0, 0, null);
        // transform state will be restored in render() method above...

        Effect.releaseCompatibleImage(fctx, contentImg);
        Effect.releaseCompatibleImage(fctx, clipImg);
    }

    void renderForClip(Graphics g) {
        if (getEffectFilter() != null) {
            renderEffect(g);
        } else {
            renderContent(g);
        }
    }

    private void renderOpacity(Graphics g) {
        if (getEffectFilter() != null ||
            getCacheFilter() != null ||
            getClipNode() != null ||
            !hasOverlappingContents())
        {
            // if the node has a non-null effect or cached==true, we don't
            // need to bother rendering to an offscreen here because the
            // contents will be flattened as part of rendering the effect
            // (or creating the cached image)
            float ea = g.getExtraAlpha();
            g.setExtraAlpha(ea*getOpacity());
            if (getCacheFilter() != null) {
                renderCached(g);
            } else if (getClipNode() != null) {
                renderClip(g);
            } else if (getEffectFilter() != null) {
                renderEffect(g);
            } else {
                renderContent(g);
            }
            g.setExtraAlpha(ea);
            return;
        }

        FilterContext fctx = getFilterContext(g);
        BaseTransform curXform = g.getTransformNoClone();
        BaseBounds bounds = getContentBounds(new RectBounds(), curXform);
        Rectangle r = new Rectangle(bounds);
        r.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));
        PrDrawable img = (PrDrawable)
            Effect.getCompatibleImage(fctx, r.width, r.height);
        if (img == null) {
            return;
        }
        Graphics gImg = img.createGraphics();
        gImg.setHasPreCullingBits(g.hasPreCullingBits());
        gImg.setClipRectIndex(g.getClipRectIndex());
        gImg.translate(-r.x, -r.y);
        gImg.transform(curXform);
        renderContent(gImg);
        // img contents have already been rendered in device space, so
        // just translate to the node origin in device space here...
        g.setTransform(null);
        float ea = g.getExtraAlpha();
        g.setExtraAlpha(getOpacity()*ea);
        g.drawTexture(img.getTextureObject(), r.x, r.y, r.width, r.height);
        g.setExtraAlpha(ea);
        // transform state will be restored in render() method above...
        Effect.releaseCompatibleImage(fctx, img);
    }

    private void renderCached(Graphics g) {
        // We will punt on 3D completely for caching.
        // The first check is for any of its children contains a 3D Transform.
        // The second check is for any of its parents and itself has a 3D Transform
        // The third check is for the printing case, which doesn't use cached
        // bitmaps for the screen and for which there is no cacheFilter.
        if (isContentBounds2D() &amp;&amp; g.getTransformNoClone().is2D() &amp;&amp;
                !(g instanceof com.sun.prism.PrinterGraphics)) {
            getCacheFilter().render(g);
        } else {
            renderContent(g);
        }
    }

    protected void renderEffect(Graphics g) {
        getEffectFilter().render(g);
    }

    protected abstract void renderContent(Graphics g);

    protected abstract boolean hasOverlappingContents();

    /***************************************************************************
     *                                                                         *
     *                       Static Helper Methods.                            *
     *                                                                         *
     **************************************************************************/

    boolean isReadbackSupported(Graphics g) {
        return ((g instanceof ReadbackGraphics) &amp;&amp;
                ((ReadbackGraphics) g).canReadBack());
    }

    /***************************************************************************
     *                                                                         *
     *                      Filters (Cache, Effect, etc).                      *
     *                                                                         *
     **************************************************************************/

    static FilterContext getFilterContext(Graphics g) {
        Screen s = g.getAssociatedScreen();
        if (s == null) {
            return PrFilterContext.getPrinterContext(g.getResourceFactory());
        } else {
            return PrFilterContext.getInstance(s);
        }
    }

    /**
     * A custom effect implementation that has a filter() method that
     * simply wraps the given pre-rendered PrDrawable in an ImageData
     * and returns that result.  This is only used by the renderClip()
     * implementation so we cut some corners here (for example, we assume
     * that the given PrDrawable image is already in device space).
     */
    private static class PassThrough extends Effect {
        private PrDrawable img;
        private Rectangle bounds;

        PassThrough(PrDrawable img, Rectangle bounds) {
            this.img = img;
            this.bounds = bounds;
        }

        @Override
        public ImageData filter(FilterContext fctx,
                                BaseTransform transform,
                                Rectangle outputClip,
                                Object renderHelper,
                                Effect defaultInput)
        {
            img.lock();
            ImageData id = new ImageData(fctx, img, new Rectangle(bounds));
            id.setReusable(true);
            return id;
        }

        @Override
        public RectBounds getBounds(BaseTransform transform,
                                  Effect defaultInput)
        {
            return new RectBounds(bounds);
        }

        @Override
        public AccelType getAccelType(FilterContext fctx) {
            return AccelType.INTRINSIC;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null; //Never called
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stuff                                                                   *
     *                                                                         *
     **************************************************************************/

    public void release() {
    }

    @Override public String toString() {
        return name == null ? super.toString() : name;
    }

    public void applyTransform(final BaseTransform tx, DirtyRegionContainer drc) {
        for (int i = 0; i &lt; drc.size(); i++) {
            drc.setDirtyRegion(i, (RectBounds) tx.transform(drc.getDirtyRegion(i), drc.getDirtyRegion(i)));
<A NAME="84"></A>            if (drc.checkAndClearRegion(i)) {
                --i;
            }
        <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#84',2,'match42-top.html#84',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    }

    public void applyClip(final BaseBounds clipBounds, DirtyRegionContainer drc) {
        for (int i = 0; i &lt; drc.size(); i++) {
            drc.getDirtyRegion</B></FONT>(i).intersectWith(clipBounds);
            if (drc.checkAndClearRegion(i)) {
                --i;
            }
        }
    }

    public void applyEffect(final EffectFilter effectFilter, DirtyRegionContainer drc, DirtyRegionPool regionPool) {
        Effect effect = effectFilter.getEffect();
        EffectDirtyBoundsHelper helper = EffectDirtyBoundsHelper.getInstance();
        helper.setInputBounds(contentBounds);
        helper.setDirtyRegions(drc);
        final DirtyRegionContainer effectDrc = effect.getDirtyRegions(helper, regionPool);
        drc.deriveWithNewContainer(effectDrc);
        regionPool.checkIn(effectDrc);
    }

    private static class EffectDirtyBoundsHelper extends Effect {
        private BaseBounds bounds;
        private static EffectDirtyBoundsHelper instance = null;
        private DirtyRegionContainer drc;

        public void setInputBounds(BaseBounds inputBounds) {
            bounds = inputBounds;
        }

        @Override
        public ImageData filter(FilterContext fctx,
                BaseTransform transform,
                Rectangle outputClip,
                Object renderHelper,
                Effect defaultInput) {
            throw new UnsupportedOperationException();
        }

        @Override
        public BaseBounds getBounds(BaseTransform transform, Effect defaultInput) {
            if (bounds.getBoundsType() == BaseBounds.BoundsType.RECTANGLE) {
                return bounds;
            } else {
                //RT-29453 - CCE: in case we get 3D bounds we need to &quot;flatten&quot; them
                return new RectBounds(bounds.getMinX(), bounds.getMinY(), bounds.getMaxX(), bounds.getMaxY());
            }
        }

        @Override
        public Effect.AccelType getAccelType(FilterContext fctx) {
            return null;
        }

        public static EffectDirtyBoundsHelper getInstance() {
            if (instance == null) {
                instance = new EffectDirtyBoundsHelper();
            }
            return instance;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return true;
        }

        private void setDirtyRegions(DirtyRegionContainer drc) {
            this.drc = drc;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            DirtyRegionContainer ret = regionPool.checkOut();
            ret.deriveWithNewContainer(drc);

            return ret;
        }

    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/OverlayWarning.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import javafx.animation.Animation.Status;
import javafx.animation.FadeTransition;
import javafx.animation.PauseTransition;
import javafx.animation.SequentialTransition;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Rectangle2D;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.util.Duration;

public class OverlayWarning extends Group {
    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        OverlayWarningHelper.setOverlayWarningAccessor(
                new OverlayWarningHelper.OverlayWarningAccessor() {
            @Override
            public void doUpdatePeer(Node node) {
                ((OverlayWarning) node).doUpdatePeer();
            }

            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                ((OverlayWarning) node).doMarkDirty(dirtyBit);
            }
        });
    }

    private static final float  PAD      = 40f;
    private static final float  RECTW    = 600f;
    private static final float  RECTH    = 100f;
    private static final float  ARC      = 20f;
    private static final int    FONTSIZE = 24;

    private ViewScene               view;
    private SequentialTransition    overlayTransition;
    private boolean                 warningTransition;

    {
        // To initialize the class helper at the begining each constructor of this class
        OverlayWarningHelper.initHelper(this);
    }

    public OverlayWarning(final ViewScene vs) {
        view = vs;

        createOverlayGroup();

        PauseTransition pause = new PauseTransition(Duration.millis(4000));
        FadeTransition fade = new FadeTransition(Duration.millis(1000), this);
        fade.setFromValue(1);
        fade.setToValue(0);

        overlayTransition = new SequentialTransition();
        overlayTransition.getChildren().add(pause);
        overlayTransition.getChildren().add(fade);
        overlayTransition.setOnFinished(event -&gt; {
            warningTransition = false;
            view.getWindowStage().setWarning(null);
        });
    }

    protected ViewScene getView() {
        return view;
    }

    protected final void setView(ViewScene vs) {
        if (view != null) {
            view.getWindowStage().setWarning(null);
        }

        view = vs;
        view.entireSceneNeedsRepaint();
   }

    protected void warn(String msg) {
        text.setText(msg);

        warningTransition = true;
        overlayTransition.play();
    }

    protected void cancel() {
        if (overlayTransition != null &amp;&amp;
            overlayTransition.getStatus() == Status.RUNNING) {
            overlayTransition.stop();
            warningTransition = false;
        }
        view.getWindowStage().setWarning(null);
    }

    protected boolean inWarningTransition() {
<A NAME="51"></A>        return warningTransition;
    }

    <FONT color="#b38481"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#51',2,'match42-top.html#51',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private Text text = new Text();
    private Rectangle background;

    private void createOverlayGroup() {
        final Font font = new Font(Font.getDefault</B></FONT>().getFamily(), FONTSIZE);
        final Rectangle2D screenBounds = new Rectangle2D(0, 0,
                view.getSceneState().getScreenWidth(),
                view.getSceneState().getScreenHeight());

        String TEXT_CSS =
            &quot;-fx-effect: dropshadow(two-pass-box, rgba(0,0,0,0.75), 3, 0.0, 0, 2);&quot;;
        text.setStroke(Color.WHITE);
        text.setFill(Color.WHITE);
        text.setFont(font);
        text.setWrappingWidth(RECTW - PAD - PAD);
        text.setStyle(TEXT_CSS);
        text.setTextAlignment(TextAlignment.CENTER);

        background = createBackground(text, screenBounds);

        getChildren().add(background);
        getChildren().add(text);
    }

    private Rectangle createBackground(Text text, Rectangle2D screen) {
        Rectangle rectangle = new Rectangle();
        double textW = text.getLayoutBounds().getWidth();
        double textH = text.getLayoutBounds().getHeight();
        double rectX = (screen.getWidth() - RECTW) / 2.0;
        double rectY = (screen.getHeight() / 2.0);

        rectangle.setWidth(RECTW);
        rectangle.setHeight(RECTH);
        rectangle.setX(rectX);
        rectangle.setY(rectY - RECTH);
        rectangle.setArcWidth(ARC);
        rectangle.setArcHeight(ARC);
        rectangle.setFill(Color.gray(0.0, 0.6));

        text.setX(rectX + ((RECTW - textW) / 2.0));
        text.setY(rectY - (RECTH  / 2.0) + ((textH - text.getBaselineOffset()) / 2.0));

        return rectangle;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        NodeHelper.updatePeer(text);
        NodeHelper.updatePeer(background);
    }

    @Override
    protected void updateBounds() {
        super.updateBounds();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        view.synchroniseOverlayWarning();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/SwipeGestureRecognizer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import com.sun.glass.events.KeyEvent;
<A NAME="8"></A>import com.sun.glass.events.TouchEvent;

import java.security.AccessController;
<FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#8',2,'match42-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.security.PrivilegedAction;
import java.util.HashMap;
import java.util.Map;
import javafx.event.EventType;
import javafx.scene.input.SwipeEvent;

class SwipeGestureRecognizer implements GestureRecognizer {

    private static final double TANGENT_30_DEGREES = 0.577;

    private static final double TANGENT_45_DEGREES = 1;

    private static final boolean VERBOSE = false;

    // Swipes must be longer than that
    private static final double DISTANCE_THRESHOLD = 10; // pixel

    // Traveling this distance against the swipe direction at its end cancels it
    private static final double BACKWARD_DISTANCE_THRASHOLD = 5; // pixel

    private SwipeRecognitionState state = SwipeRecognitionState.IDLE;
    MultiTouchTracker tracker = new MultiTouchTracker();
    private ViewScene scene</B></FONT>;

    SwipeGestureRecognizer(final ViewScene scene) {
        this.scene = scene;
    }

    @Override
    public void notifyBeginTouchEvent(long time, int modifiers, boolean isDirect,
            int touchEventCount) {
        tracker.params(modifiers, isDirect);
    }

    @Override
    public void notifyNextTouchEvent(long time, int type, long touchId,
                                     int x, int y, int xAbs, int yAbs) {
        switch(type) {
            case TouchEvent.TOUCH_PRESSED:
                tracker.pressed(touchId, time, x, y, xAbs, yAbs);
                break;
            case TouchEvent.TOUCH_STILL:
                /* NOBREAK */
            case TouchEvent.TOUCH_MOVED:
                tracker.progress(touchId, time, xAbs, yAbs);
                break;
            case TouchEvent.TOUCH_RELEASED:
                tracker.released(touchId, time, x, y, xAbs, yAbs);
                break;
            default:
                throw new RuntimeException(&quot;Error in swipe gesture recognition: &quot;
                        + &quot;unknown touch state: &quot; + state);
        }
    }

    @Override
    public void notifyEndTouchEvent(long time) {
        // nothing to do
    }

    private EventType&lt;SwipeEvent&gt; calcSwipeType(TouchPointTracker tracker) {

        final double distanceX = tracker.getDistanceX();
        final double distanceY = tracker.getDistanceY();
        final double absDistanceX = Math.abs(distanceX);
        final double absDistanceY = Math.abs(distanceY);

        final boolean horizontal = absDistanceX &gt; absDistanceY;

        final double primaryDistance = horizontal ? distanceX : distanceY;
        final double absPrimaryDistance = horizontal ? absDistanceX : absDistanceY;
        final double absSecondaryDistance = horizontal ? absDistanceY : absDistanceX;
        final double absPrimaryLength = horizontal ?
                tracker.lengthX : tracker.lengthY;
        final double maxSecondaryDeviation = horizontal ?
                tracker.maxDeviationY : tracker.maxDeviationX;
        final double lastPrimaryMovement = horizontal ?
                tracker.lastXMovement : tracker.lastYMovement;

        if (absPrimaryDistance &lt;= DISTANCE_THRESHOLD) {
            // too small movement
            return null;
        }

        if (absSecondaryDistance &gt; absPrimaryDistance * TANGENT_30_DEGREES) {
            // too diagonal - in range of 60 degrees
            return null;
        }

        if (maxSecondaryDeviation &gt; absPrimaryDistance * TANGENT_45_DEGREES) {
            // maximum deviation on the secondary axis, is too big
            return null;
        }

        int swipeMaxDuration = Integer.getInteger(&quot;com.sun.javafx.gestures.swipe.maxduration&quot;, 300);
        if (tracker.getDuration() &gt; swipeMaxDuration) {
            return null;
        }

        if (absPrimaryLength &gt; absPrimaryDistance * 1.5) {
            // too much back and forth
            return null;
        }

        if (Math.signum(primaryDistance) != Math.signum(lastPrimaryMovement) &amp;&amp;
                Math.abs(lastPrimaryMovement) &gt; BACKWARD_DISTANCE_THRASHOLD) {
            // gesture finished in the oposite direction
            return null;
        }

        if (horizontal) {
            return tracker.getDistanceX() &lt; 0
                    ? SwipeEvent.SWIPE_LEFT : SwipeEvent.SWIPE_RIGHT;
        } else {
            return tracker.getDistanceY() &lt; 0
                    ? SwipeEvent.SWIPE_UP : SwipeEvent.SWIPE_DOWN;
        }
    }

    private void handleSwipeType(final EventType&lt;SwipeEvent&gt; swipeType,
            final CenterComputer cc, final int touchCount, final int modifiers, final boolean isDirect)
    {
        if (swipeType == null) {
            return;
        }
        if (VERBOSE) {
            System.err.println(&quot;handleSwipeType swipeType=&quot; + swipeType);
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            if (scene.sceneListener != null) {
                scene.sceneListener.swipeEvent(swipeType, touchCount,
                    cc.getX(), cc.getY(),
                    cc.getAbsX(), cc.getAbsY(),
                    (modifiers &amp; KeyEvent.MODIFIER_SHIFT) != 0,
                    (modifiers &amp; KeyEvent.MODIFIER_CONTROL) != 0,
                    (modifiers &amp; KeyEvent.MODIFIER_ALT) != 0,
                    (modifiers &amp; KeyEvent.MODIFIER_WINDOWS) != 0,
                    isDirect);
            }
            return null;
        }, scene.getAccessControlContext());
    }

    private static class CenterComputer {
        double totalAbsX = 0, totalAbsY = 0;
        double totalX = 0, totalY = 0;
        int count = 0;

        public void add(double x, double y, double xAbs, double yAbs) {
            totalAbsX += xAbs;
            totalAbsY += yAbs;
            totalX += x;
            totalY += y;

            count++;
        }

        public double getX() {
            return count == 0 ? 0 : totalX / count;
        }

        public double getY() {
            return count == 0 ? 0 : totalY / count;
        }

        public double getAbsX() {
            return count == 0 ? 0 : totalAbsX / count;
        }

        public double getAbsY() {
            return count == 0 ? 0 : totalAbsY / count;
        }

        public void reset() {
            totalX = 0;
            totalY = 0;
            totalAbsX = 0;
            totalAbsY = 0;
            count = 0;
        }
    }

    private class MultiTouchTracker {
        SwipeRecognitionState state = SwipeRecognitionState.IDLE;
        Map&lt;Long, TouchPointTracker&gt; trackers =
                new HashMap&lt;Long, TouchPointTracker&gt;();
        CenterComputer cc = new CenterComputer();
        int modifiers;
        boolean direct;
        private int touchCount;
        private int currentTouchCount;
        private EventType&lt;SwipeEvent&gt; type;

        public void params(int modifiers, boolean direct) {
            this.modifiers = modifiers;
            this.direct = direct;
        }

        public void pressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {
            currentTouchCount++;
            switch (state) {
                case IDLE:
                    currentTouchCount = 1;
                    state = SwipeRecognitionState.ADDING;
                    /* NOBREAK */
                case ADDING:
                    TouchPointTracker tracker = new TouchPointTracker();
                    tracker.start(nanos, x, y, xAbs, yAbs);
                    trackers.put(id, tracker);
                    break;
                case REMOVING:
                    // we don't allow for swipes with varying touch count
                    state = SwipeRecognitionState.FAILURE;
                    break;
                default:
                    break;
            }
        }

        public void released(long id, long nanos, int x, int y, int xAbs, int yAbs) {
            if (state != SwipeRecognitionState.FAILURE) {
                TouchPointTracker tracker = trackers.get(id);

                if (tracker == null) {
                    // we don't know this ID, something went completely wrong
                    state = SwipeRecognitionState.FAILURE;
                    throw new RuntimeException(&quot;Error in swipe gesture &quot;
                            + &quot;recognition: released unknown touch point&quot;);
                }

                tracker.end(nanos, x, y, xAbs, yAbs);
                cc.add(tracker.beginX, tracker.beginY,
                        tracker.beginAbsX, tracker.beginAbsY);
                cc.add(tracker.endX, tracker.endY,
                        tracker.endAbsX, tracker.endAbsY);

                final EventType&lt;SwipeEvent&gt; swipeType = calcSwipeType(tracker);

                switch (state) {
                    case IDLE:
                        reset();
                        throw new RuntimeException(&quot;Error in swipe gesture &quot;
                                + &quot;recognition: released touch point outside &quot;
                                + &quot;of gesture&quot;);
                    case ADDING:
                        state = SwipeRecognitionState.REMOVING;
                        touchCount = currentTouchCount;
                        type = swipeType;
                        break;
                    case REMOVING:
                        if (type != swipeType) {
                            // each finger does something else
                            state = SwipeRecognitionState.FAILURE;
                        }
                        break;
                    default:
                        break;
                }
                trackers.remove(id);
            }

            currentTouchCount--;

            if (currentTouchCount == 0) {
                if (state == SwipeRecognitionState.REMOVING) {
                    handleSwipeType(type, cc, touchCount, modifiers, direct);
                }

                state = SwipeRecognitionState.IDLE;
                reset();
            }
        }

        public void progress(long id, long nanos, int x, int y) {

            if (state == SwipeRecognitionState.FAILURE) {
                return;
            }

            TouchPointTracker tracker = trackers.get(id);

            if (tracker == null) {
                // we don't know this ID, something went completely wrong
                state = SwipeRecognitionState.FAILURE;
                throw new RuntimeException(&quot;Error in swipe gesture &quot;
                        + &quot;recognition: reported unknown touch point&quot;);
            }

            tracker.progress(nanos, x, y);
        }

        void reset() {
            trackers.clear();
            cc.reset();
            state = SwipeRecognitionState.IDLE;
        }
    }

    private static class TouchPointTracker {
        long beginTime, endTime;
        double beginX, beginY, endX, endY;
        double beginAbsX, beginAbsY, endAbsX, endAbsY;
        double lengthX, lengthY;
        double maxDeviationX, maxDeviationY;
        double lastXMovement, lastYMovement;
        double lastX, lastY;

        public void start(long nanos, double x, double y, double absX, double absY) {
            beginX = x;
            beginY = y;
            beginAbsX = absX;
            beginAbsY = absY;
            lastX = absX;
            lastY = absY;
            beginTime = nanos / 1000000;
        }

        public void end(long nanos, double x, double y, double absX, double absY) {
            progress(nanos, absX, absY);
            endX = x;
            endY = y;
            endAbsX = absX;
            endAbsY = absY;
            endTime = nanos / 1000000;
        }

        public void progress(long nanos, double x, double y) {
            final double deltaX = x - lastX;
            final double deltaY = y - lastY;

            lengthX += Math.abs(deltaX);
            lengthY += Math.abs(deltaY);
            lastX = x;
            lastY = y;

            final double devX = Math.abs(x - beginAbsX);
            if (devX &gt; maxDeviationX) { maxDeviationX = devX; }

            final double devY = Math.abs(y - beginAbsY);
            if (devY &gt; maxDeviationY) { maxDeviationY = devY; }

            if (Math.signum(deltaX) == Math.signum(lastXMovement)) {
                lastXMovement += deltaX;
            } else {
                lastXMovement = deltaX;
            }

            if (Math.signum(deltaY) == Math.signum(lastYMovement)) {
                lastYMovement += deltaY;
            } else {
                lastYMovement = deltaY;
            }
        }

        public double getDistanceX() {
            return endX - beginX;
        }

        public double getDistanceY() {
            return endY - beginY;
        }

        public long getDuration() {
            return endTime - beginTime;
        }
    }

    private enum SwipeRecognitionState {
        IDLE,
        ADDING,
        REMOVING,
        FAILURE
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/ViewPainter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.ReentrantLock;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGPerspectiveCamera;
import com.sun.javafx.sg.prism.NodePath;
import com.sun.prism.Graphics;
import com.sun.prism.GraphicsResource;
import com.sun.prism.Image;
import com.sun.prism.Presentable;
import com.sun.prism.RTTexture;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Paint;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;

/**
 * Responsible for &quot;painting&quot; a scene. It invokes as appropriate API on the root NGNode
 * of a scene to determine dirty regions, render roots, etc. Also calls the render root
 * to render. Also invokes code to print dirty opts and paint overdraw rectangles according
 * to debug flags.
 */
abstract class ViewPainter implements Runnable {
    /**
     * An array of initially empty ROOT_PATHS. They are created on demand as
     * needed. Each path is associated with a different dirty region. We have
     * up to PrismSettings.dirtyRegionCount max dirty regions
     */
    private static NodePath[] ROOT_PATHS = new NodePath[PrismSettings.dirtyRegionCount];

    /*
     * This could be a per-scene lock but there is no guarantee that the
     * FX handlers called in GlassViewEventHandler would not modify other scenes.
     */
    protected static final ReentrantLock renderLock = new ReentrantLock();

    // Pen dimensions. Pen width and height are checked on every repaint
    // to match its scene width/height. If any difference is found, the
    // pen surface (Presentable or RTTexture) is recreated.
    protected int penWidth = -1;
    protected int penHeight = -1;
    protected int viewWidth;
    protected int viewHeight;

    protected final SceneState sceneState;

    protected Presentable presentable;
    protected ResourceFactory factory;
    protected boolean freshBackBuffer;

    private int width;
    private int height;

    /**
     * root is the root node of the scene. overlayRoot is the root node of any
     * overlay which may be present (such as used for full screen overlay).
     */
    private NGNode root, overlayRoot;

    // These variables are all used as part of the dirty region optimizations,
    // and if dirty opts are turned off via a runtime flag, then these fields
    // are never initialized or used.
    private Rectangle dirtyRect;
    private RectBounds clip;
    private RectBounds dirtyRegionTemp;
    private DirtyRegionPool dirtyRegionPool;
    private DirtyRegionContainer dirtyRegionContainer;
    private Affine3D tx;
    private Affine3D scaleTx;
    private GeneralTransform3D viewProjTx;
    private GeneralTransform3D projTx;

    /**
     * This is used for drawing dirty regions and overdraw rectangles in cases where we are
     * not drawing the entire scene every time (specifically, when depth buffer is disabled).
     * In those cases we will draw the scene to the sceneBuffer, clear the actual back buffer,
     * blit the sceneBuffer into the back buffer, and then scribble on top of the back buffer
     * with the dirty regions and/or overdraw rectangles.
     *
     * When the depthBuffer is enabled on a scene, we always end up drawing the entire scene
     * anyway, so we don't bother with this sceneBuffer in that case. Of course, if dirty
     * region / overdraw rectangle drawing is turned off, then we don't use this. Thus,
     * only when you are doing some kind of debugging would this field be used and the
     * extra buffer copy incurred.
     */
    private RTTexture sceneBuffer;

    protected ViewPainter(GlassScene gs) {
        sceneState = gs.getSceneState();
        if (sceneState == null) {
<A NAME="58"></A>            throw new NullPointerException(&quot;Scene state is null&quot;);
        }

        if (PrismSettings.dirtyOptsEnabled) <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#58',2,'match42-top.html#58',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            tx = new Affine3D();
            viewProjTx = new GeneralTransform3D();
            projTx = new GeneralTransform3D();
            scaleTx = new Affine3D();
            c</B></FONT>lip = new RectBounds();
            dirtyRect = new Rectangle();
            dirtyRegionTemp = new RectBounds();
            dirtyRegionPool = new DirtyRegionPool(PrismSettings.dirtyRegionCount);
            dirtyRegionContainer = dirtyRegionPool.checkOut();
        }
    }

    protected final void setRoot(NGNode node) {
        root = node;
    }

    protected final void setOverlayRoot(NGNode node) {
        overlayRoot = node;
    }

    private void adjustPerspective(NGCamera camera) {
        // This should definitely be true since this is only called by setDirtyRect
        assert PrismSettings.dirtyOptsEnabled;
        if (camera instanceof NGPerspectiveCamera) {
            scaleTx.setToScale(width / 2.0, -height / 2.0, 1);
            scaleTx.translate(1, -1);
            projTx.mul(scaleTx);
            viewProjTx = camera.getProjViewTx(viewProjTx);
            projTx.mul(viewProjTx);
        }
    }

    protected void paintImpl(final Graphics backBufferGraphics) {
        // We should not be painting anything with a width / height
        // that is &lt;= 0, so we might as well bail right off.
        if (width &lt;= 0 || height &lt;= 0 || backBufferGraphics == null) {
            root.renderForcedContent(backBufferGraphics);
            return;
        }

        // This &quot;g&quot; variable might represent the back buffer graphics, or it
        // might be reassigned to the sceneBuffer graphics.
        Graphics g = backBufferGraphics;
        // Take into account the pixel scale factor for retina displays
        final float pixelScaleX = getPixelScaleFactorX();
        final float pixelScaleY = getPixelScaleFactorY();
        // Cache pixelScale in Graphics for use in 3D shaders such as camera and light positions.
        g.setPixelScaleFactors(pixelScaleX, pixelScaleY);

        // Initialize renderEverything based on various conditions that will cause us to render
        // the entire scene every time.
        boolean renderEverything = overlayRoot != null ||
                freshBackBuffer ||
                sceneState.getScene().isEntireSceneDirty() ||
                sceneState.getScene().getDepthBuffer() ||
                !PrismSettings.dirtyOptsEnabled;
        // We are going to draw dirty opt boxes either if we're supposed to show the dirty
        // regions, or if we're supposed to show the overdraw boxes.
        final boolean showDirtyOpts = PrismSettings.showDirtyRegions || PrismSettings.showOverdraw;
        // If showDirtyOpts is turned on and we're not using a depth buffer
        // then we will render the scene to an intermediate texture, and then at the end we'll
        // draw that intermediate texture to the back buffer.
        if (showDirtyOpts &amp;&amp; !sceneState.getScene().getDepthBuffer()) {
            final int bufferWidth = (int) Math.ceil(width * pixelScaleX);
            final int bufferHeight = (int) Math.ceil(height * pixelScaleY);
            // Check whether the sceneBuffer texture needs to be reconstructed
            if (sceneBuffer != null) {
                sceneBuffer.lock();
                if (sceneBuffer.isSurfaceLost() ||
                        bufferWidth != sceneBuffer.getContentWidth() ||
                        bufferHeight != sceneBuffer.getContentHeight()) {
                    sceneBuffer.unlock();
                    sceneBuffer.dispose();
                    sceneBuffer = null;
                }
            }
            // If sceneBuffer is null, we need to create a new texture. In this
            // case we will also need to render the whole scene (so don't bother
            // with dirty opts)
            if (sceneBuffer == null) {
                sceneBuffer = g.getResourceFactory().createRTTexture(
                        bufferWidth,
                        bufferHeight,
                        Texture.WrapMode.CLAMP_TO_ZERO,
                        false);
                renderEverything = true;
            }
            sceneBuffer.contentsUseful();
            // Hijack the &quot;g&quot; graphics variable
            g = sceneBuffer.createGraphics();
            g.setPixelScaleFactors(pixelScaleX, pixelScaleY);
            g.scale(pixelScaleX, pixelScaleY);
        } else if (sceneBuffer != null) {
            // We're in a situation where we have previously rendered to the sceneBuffer, but in
            // this render pass for whatever reason we're going to draw directly to the back buffer.
            // In this case we need to release the sceneBuffer.
            sceneBuffer.dispose();
            sceneBuffer = null;
        }

        // The status will be set only if we're rendering with dirty regions
        int status = -1;

        // If we're rendering with dirty regions, then we'll call the root node to accumulate
        // the dirty regions and then again to do the pre culling.
        if (!renderEverything) {
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Dirty Opts Computed&quot;);
            }
            clip.setBounds(0, 0, width, height);
            dirtyRegionTemp.makeEmpty();
            dirtyRegionContainer.reset();
            tx.setToIdentity();
            projTx.setIdentity();
            adjustPerspective(sceneState.getCamera());
            status = root.accumulateDirtyRegions(clip, dirtyRegionTemp,
                                                     dirtyRegionPool, dirtyRegionContainer,
                                                     tx, projTx);
            dirtyRegionContainer.roundOut();
            if (status == DirtyRegionContainer.DTR_OK) {
                root.doPreCulling(dirtyRegionContainer, tx, projTx);
            }
        }

        // We're going to need to iterate over the dirty region container a lot, so we
        // might as well save this reference.
        final int dirtyRegionSize = status == DirtyRegionContainer.DTR_OK ? dirtyRegionContainer.size() : 0;

        if (dirtyRegionSize &gt; 0) {
            // We set this flag on Graphics so that subsequent code in the render paths of
            // NGNode know whether they ought to be paying attention to dirty region
            // culling bits.
            g.setHasPreCullingBits(true);

            // Find the render roots. There is a different render root for each dirty region
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Render Roots Discovered&quot;);
            }
            for (int i = 0; i &lt; dirtyRegionSize; ++i) {
                NodePath path = getRootPath(i);
                path.clear();
                root.getRenderRoot(getRootPath(i), dirtyRegionContainer.getDirtyRegion(i), i, tx, projTx);
            }

            // For debug purposes, write out to the pulse logger the number and size of the dirty
            // regions that are being used to render this pulse.
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.addMessage(dirtyRegionSize + &quot; different dirty regions to render&quot;);
                for (int i=0; i&lt;dirtyRegionSize; i++) {
                    PulseLogger.addMessage(&quot;Dirty Region &quot; + i + &quot;: &quot; + dirtyRegionContainer.getDirtyRegion(i));
                    PulseLogger.addMessage(&quot;Render Root Path &quot; + i + &quot;: &quot; + getRootPath(i));
                }
            }

            // If -Dprism.printrendergraph=true then we want to print out the render graph to the
            // pulse logger, annotated with all the dirty opts. Invisible nodes are skipped.
            if (PULSE_LOGGING_ENABLED &amp;&amp; PrismSettings.printRenderGraph) {
                StringBuilder s = new StringBuilder();
                List&lt;NGNode&gt; roots = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; dirtyRegionSize; i++) {
                    final RectBounds dirtyRegion = dirtyRegionContainer.getDirtyRegion(i);
                    // TODO it should be impossible to have ever created a dirty region that was empty...
                    if (dirtyRegion.getWidth() &gt; 0 &amp;&amp; dirtyRegion.getHeight() &gt; 0) {
                        NodePath nodePath = getRootPath(i);
                        if (!nodePath.isEmpty()) {
                            roots.add(nodePath.last());
                        }
                    }
                }
                root.printDirtyOpts(s, roots);
                PulseLogger.addMessage(s.toString());
            }

            // Paint each dirty region
            for (int i = 0; i &lt; dirtyRegionSize; ++i) {
                final RectBounds dirtyRegion = dirtyRegionContainer.getDirtyRegion(i);
                // TODO it should be impossible to have ever created a dirty region that was empty...
                // Make sure we are not trying to render in some invalid region
                if (dirtyRegion.getWidth() &gt; 0 &amp;&amp; dirtyRegion.getHeight() &gt; 0) {
                    // Set the clip rectangle using integer bounds since a fractional bounding box will
                    // still require a complete repaint on pixel boundaries
                    int x0, y0;
                    dirtyRect.x = x0 = (int) Math.floor(dirtyRegion.getMinX() * pixelScaleX);
                    dirtyRect.y = y0 = (int) Math.floor(dirtyRegion.getMinY() * pixelScaleY);
                    dirtyRect.width  = (int) Math.ceil (dirtyRegion.getMaxX() * pixelScaleX) - x0;
                    dirtyRect.height = (int) Math.ceil (dirtyRegion.getMaxY() * pixelScaleY) - y0;
                    g.setClipRect(dirtyRect);
                    g.setClipRectIndex(i);
                    doPaint(g, getRootPath(i));
                }
            }
        } else {
            // There are no dirty regions, so just paint everything
            g.setHasPreCullingBits(false);
            g.setClipRect(null);
            this.doPaint(g, null);
        }
        root.renderForcedContent(g);

        // If we have an overlay then we need to render it too.
        if (overlayRoot != null) {
            overlayRoot.render(g);
        }

        // If we're showing dirty regions or overdraw, then we're going to need to draw
        // over-top the normal scene. If we have been drawing do the back buffer, then we
        // will just draw on top of it. If we have been drawing to the sceneBuffer, then
        // we will first blit the sceneBuffer into the back buffer, and then draw directly
        // on the back buffer.
        if (showDirtyOpts) {
            if (sceneBuffer != null) {
                g.sync();
                backBufferGraphics.clear();
                backBufferGraphics.drawTexture(sceneBuffer, 0, 0, width, height,
                        sceneBuffer.getContentX(), sceneBuffer.getContentY(),
                        sceneBuffer.getContentX() + sceneBuffer.getContentWidth(),
                        sceneBuffer.getContentY() + sceneBuffer.getContentHeight());
                sceneBuffer.unlock();
            }

            if (PrismSettings.showOverdraw) {
                // We are going to show the overdraw rectangles.
                if (dirtyRegionSize &gt; 0) {
                    // In this case we have dirty regions, so we will iterate over them all
                    // and draw each dirty region's overdraw individually
                    for (int i = 0; i &lt; dirtyRegionSize; i++) {
                        final Rectangle clip = new Rectangle(dirtyRegionContainer.getDirtyRegion(i));
                        backBufferGraphics.setClipRectIndex(i);
                        paintOverdraw(backBufferGraphics, clip);
                        backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                        backBufferGraphics.drawRect(clip.x, clip.y, clip.width, clip.height);
                    }
                } else {
                    // In this case there were no dirty regions, so the clip is the entire scene
                    final Rectangle clip = new Rectangle(0, 0, width, height);
                    assert backBufferGraphics.getClipRectIndex() == 0;
                    paintOverdraw(backBufferGraphics, clip);
                    backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                    backBufferGraphics.drawRect(clip.x, clip.y, clip.width, clip.height);
                }
            } else {
                // We are going to show the dirty regions
                if (dirtyRegionSize &gt; 0) {
                    // We have dirty regions to draw
                    backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                    for (int i = 0; i &lt; dirtyRegionSize; i++) {
                        final RectBounds reg = dirtyRegionContainer.getDirtyRegion(i);
                        backBufferGraphics.fillRect(reg.getMinX(), reg.getMinY(), reg.getWidth(), reg.getHeight());
                    }
                } else {
                    // No dirty regions, fill the entire view area
                    backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                    backBufferGraphics.fillRect(0, 0, width, height);
                }
            }
            root.clearPainted();
        }
    }

    /**
     * Utility method for painting the overdraw rectangles. Right now we're using a computationally
     * intensive approach of having an array of integers (image data) that we then write to in the
     * NGNodes, recording how many times each pixel position has been touched (well, technically, we're
     * just recording the bounds of drawn objects, so some pixels might be &quot;red&quot; but actually were never
     * drawn).
     *
     * @param g
     * @param clip
     */
    private void paintOverdraw(final Graphics g, final Rectangle clip) {
        final int[] pixels = new int[clip.width * clip.height];
        root.drawDirtyOpts(BaseTransform.IDENTITY_TRANSFORM, projTx, clip, pixels, g.getClipRectIndex());
        final Image image = Image.fromIntArgbPreData(pixels, clip.width, clip.height);
        final Texture texture = factory.getCachedTexture(image, Texture.WrapMode.CLAMP_TO_EDGE);
        g.drawTexture(texture, clip.x, clip.y, clip.x+clip.width, clip.y+clip.height, 0, 0, clip.width, clip.height);
        texture.unlock();
    }

    private static NodePath getRootPath(int i) {
        if (ROOT_PATHS[i] == null) {
            ROOT_PATHS[i] = new NodePath();
        }
        return ROOT_PATHS[i];
    }

    protected void disposePresentable() {
        if (presentable instanceof GraphicsResource) {
            ((GraphicsResource)presentable).dispose();
        }
        presentable = null;
    }

    protected boolean validateStageGraphics() {
        if (!sceneState.isValid()) {
            // indicates something happened between the scheduling of the
            // job and the running of this job.
            return false;
        }

        width = viewWidth = sceneState.getWidth();
        height = viewHeight = sceneState.getHeight();

        return sceneState.isWindowVisible() &amp;&amp; !sceneState.isWindowMinimized();
    }

    protected float getPixelScaleFactorX() {
        return presentable == null ? 1.0f : presentable.getPixelScaleFactorX();
    }

    protected float getPixelScaleFactorY() {
        return presentable == null ? 1.0f : presentable.getPixelScaleFactorY();
    }

    private void doPaint(Graphics g, NodePath renderRootPath) {
        // Null path indicates that occlusion culling is not used
        if (renderRootPath != null) {
            if (renderRootPath.isEmpty()) {
                // empty render path indicates that no rendering is needed.
                // There may be occluded dirty Nodes however, so we need to clear them
                root.clearDirtyTree();
                return;
            }
            // If the path is not empty, the first node must be the root node
            assert(renderRootPath.getCurrentNode() == root);
        }
        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.newPhase(&quot;Painting&quot;);
        }
        GlassScene scene = sceneState.getScene();
        scene.clearEntireSceneDirty();
        g.setLights(scene.getLights());
        g.setDepthBuffer(scene.getDepthBuffer());
        Color clearColor = sceneState.getClearColor();
        if (clearColor != null) {
            g.clear(clearColor);
        }
        Paint curPaint = sceneState.getCurrentPaint();
        if (curPaint != null) {
            if (curPaint.getType() != com.sun.prism.paint.Paint.Type.COLOR) {
                g.getRenderTarget().setOpaque(curPaint.isOpaque());
            }
            g.setPaint(curPaint);
            g.fillQuad(0, 0, width, height);
        }
        g.setCamera(sceneState.getCamera());
        g.setRenderRoot(renderRootPath);
        root.render(g);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/d3d/D3DGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.d3d;

import com.sun.javafx.geom.transform.Affine3D;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.ps.BaseShaderGraphics;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Paint;

class D3DGraphics extends BaseShaderGraphics implements D3DContextSource {

    private D3DContext context;

    private D3DGraphics(D3DContext context, RenderTarget target) {
        super(context, target);
        this.context = context;
    }

    @Override
    public void getPaintShaderTransform(Affine3D ret) {
        super.getPaintShaderTransform(ret);
        ret.preTranslate(-0.5, -0.5, 0.0);
    }

    static Graphics create(RenderTarget target, D3DContext context) {
        if (target == null) {
            return null;
        }
        long resourceHandle = ((D3DRenderTarget)target).getResourceHandle();
        if (resourceHandle == 0) {
            return null;
        }

        if (PrismSettings.verbose &amp;&amp; context.isLost()) {
            System.err.println(&quot;Create graphics while the device is lost&quot;);
        }

        return new D3DGraphics(context, target);
    }

<A NAME="46"></A>    public void clearQuad(float x1, float y1, float x2, float y2) {
        // note that unlike clear(), this method does not currently
        // attempt to clear the depth buffer...
        <FONT color="#92c7c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#46',2,'match42-top.html#46',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>context.setRenderTarget(this);
        context.flushVertexBuffer();
        // set the blend mode to CLEAR and any regular Color as paint
        CompositeMode oldMode = getCompositeMode();
        setCompositeMode(CompositeMode.CLEAR);
        Paint oldPaint = getPaint();
        setPaint(Color.BLACK); // any color will do...
        fillQuad(x1, y1, x2, y2);
        context.flushVertexBuffer();
        // restore prior paint and blend mode
        setPaint(oldPaint);
        setCompositeMode(oldMode);
    }

    publi</B></FONT>c void clear(Color color) {
        context.validateClearOp(this);
        this.getRenderTarget().setOpaque(color.isOpaque());
        int res = nClear(context.getContextHandle(),
                          color.getIntArgbPre(), isDepthBuffer(), false);
        context.validate(res);
    }

    public void sync() {
        context.flushVertexBuffer();
    }

    public D3DContext getContext() {
        return context;
    }

    private static native int nClear(long pContext, int colorArgbPre,
                                      boolean clearDepth, boolean ignoreScissor);
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/ps/BaseShaderGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.ps;

import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PrismFontFactory;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.AffineBase;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.MaskTextureGraphics;
import com.sun.prism.MultiTexture;
import com.sun.prism.PixelFormat;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.ReadbackRenderTarget;
import com.sun.prism.RenderTarget;
import com.sun.prism.Texture;
import com.sun.prism.impl.BaseGraphics;
import com.sun.prism.impl.GlyphCache;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.VertexBuffer;
import com.sun.prism.impl.ps.BaseShaderContext.MaskType;
import com.sun.prism.impl.shape.MaskData;
import com.sun.prism.impl.shape.ShapeUtil;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderGraphics;

public abstract class BaseShaderGraphics
    extends BaseGraphics
    implements ShaderGraphics, ReadbackGraphics, MaskTextureGraphics
{
    private static Affine2D TEMP_TX2D = new Affine2D();
    private static Affine3D TEMP_TX3D = new Affine3D();

    private final BaseShaderContext context;
    private Shader externalShader;
    private boolean isComplexPaint;

    protected BaseShaderGraphics(BaseShaderContext context,
                                 RenderTarget renderTarget)
    {
        super(context, renderTarget);
        this.context = context;
    }

    BaseShaderContext getContext() {
        return context;
    }

    boolean isComplexPaint() {
        return isComplexPaint;
    }

    public void getPaintShaderTransform(Affine3D ret) {
        ret.setTransform(getTransformNoClone());
    }

    public Shader getExternalShader() {
        return externalShader;
    }

    public void setExternalShader(Shader shader) {
        this.externalShader = shader;
        context.setExternalShader(this, shader);
    }

    @Override
    public void setPaint(Paint paint) {
        if (paint.getType().isGradient()) {
            Gradient grad = (Gradient)paint;
            isComplexPaint = grad.getNumStops() &gt; PaintHelper.MULTI_MAX_FRACTIONS;
        } else {
            isComplexPaint = false;
        }
        super.setPaint(paint);
    }

    private NGLightBase lights[] = null;

    public void setLights(NGLightBase lights[]) { this.lights = lights; }

    public final NGLightBase[] getLights() { return this.lights; }

    @Override
    public void drawTexture(Texture tex,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2)
    {
        // intercept MultiTexture operations
        // FIXME: this should be pushed up to Graphics interface so that non-shader
        //        renderers can use MultiTexture too
        if (tex instanceof MultiTexture) {
            drawMultiTexture((MultiTexture)tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        } else {
            super.drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        }
    }

    @Override
    public void drawTexture3SliceH(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dh1, float dh2, float sh1, float sh2)
    {
        if (!(tex instanceof MultiTexture)) {
            super.drawTexture3SliceH(tex,
                                     dx1, dy1, dx2, dy2,
                                     sx1, sy1, sx2, sy2,
                                     dh1, dh2, sh1, sh2);
            return;
        }
        MultiTexture mtex = (MultiTexture) tex;
        drawMultiTexture(mtex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
        drawMultiTexture(mtex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
        drawMultiTexture(mtex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
    }

    @Override
    public void drawTexture3SliceV(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dv1, float dv2, float sv1, float sv2)
    {
        if (!(tex instanceof MultiTexture)) {
            super.drawTexture3SliceV(tex,
                                     dx1, dy1, dx2, dy2,
                                     sx1, sy1, sx2, sy2,
                                     dv1, dv2, sv1, sv2);
            return;
        }
        MultiTexture mtex = (MultiTexture) tex;
        drawMultiTexture(mtex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
        drawMultiTexture(mtex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
        drawMultiTexture(mtex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
    }

    @Override
    public void drawTexture9Slice(Texture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2,
                                  float dh1, float dv1, float dh2, float dv2,
                                  float sh1, float sv1, float sh2, float sv2)
    {
        if (!(tex instanceof MultiTexture)) {
            super.drawTexture9Slice(tex,
                                    dx1, dy1, dx2, dy2,
                                    sx1, sy1, sx2, sy2,
                                    dh1, dv1, dh2, dv2,
                                    sh1, sv1, sh2, sv2);
            return;
        }
        MultiTexture mtex = (MultiTexture) tex;
        drawMultiTexture(mtex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
        drawMultiTexture(mtex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
        drawMultiTexture(mtex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);

        drawMultiTexture(mtex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
        drawMultiTexture(mtex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
        drawMultiTexture(mtex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);

        drawMultiTexture(mtex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
        drawMultiTexture(mtex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
        drawMultiTexture(mtex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
    }

    private static float calculateScaleFactor(float contentDim, float physicalDim) {
        if (contentDim == physicalDim) {
            return 1f;
        }
        // we have to subtract 1 to eliminate the &quot;green line of death&quot;
        return (contentDim-1) / physicalDim;
    }

    protected void drawMultiTexture(MultiTexture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2)
    {
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        if (isSimpleTranslate) {
            xform = IDENT;
            dx1 += transX;
            dy1 += transY;
            dx2 += transX;
            dy2 += transY;
        }

        Texture textures[] = ((MultiTexture)tex).getTextures();
        Shader shader = context.validateTextureOp(this, xform, textures, tex.getPixelFormat());

        if (null == shader) {
            // FIXME: throw exception?? We can't do anything without the shader..
            return;
        }

        if (tex.getPixelFormat() == PixelFormat.MULTI_YCbCr_420) {
            Texture lumaTex = textures[PixelFormat.YCBCR_PLANE_LUMA];
            Texture cbTex = textures[PixelFormat.YCBCR_PLANE_CHROMABLUE];
            Texture crTex = textures[PixelFormat.YCBCR_PLANE_CHROMARED];

            // sampler scaling factors
            float imgWidth = (float)tex.getContentWidth();
            float imgHeight = (float)tex.getContentHeight();
            float lumaScaleX, lumaScaleY;
            float alphaScaleX, alphaScaleY;
            float cbScaleX, cbScaleY;
            float crScaleX, crScaleY;

            lumaScaleX = calculateScaleFactor(imgWidth, (float)lumaTex.getPhysicalWidth());
            lumaScaleY = calculateScaleFactor(imgHeight, (float)lumaTex.getPhysicalHeight());

            if (textures.length &gt; 3) {
                Texture alphaTex = textures[PixelFormat.YCBCR_PLANE_ALPHA];
                alphaScaleX = calculateScaleFactor(imgWidth, (float)alphaTex.getPhysicalWidth());
                alphaScaleY = calculateScaleFactor(imgHeight, (float)alphaTex.getPhysicalHeight());
            } else {
                alphaScaleX = alphaScaleY = 0f;
            }

<A NAME="2"></A>            float chromaWidth = (float)Math.floor((double)imgWidth/2.0);
            float chromaHeight = (float)Math.floor((double)imgHeight/2.0);

            cbScaleX = calculateScaleFactor(chromaWidth, (float)<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#2',2,'match42-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>cbTex.getPhysicalWidth());
            cbScaleY = calculateScaleFactor(chromaHeight, (float)cbTex.getPhysicalHeight());
            crScaleX = calculateScaleFactor(chromaWidth, (float)crTex.getPhysicalWidth());
            crScaleY = calculateScaleFactor(chromaHeight, (float)crTex.getPhysicalHeight());

            shader.setConstant(&quot;lumaAlphaScale&quot;, lumaScaleX, lumaScaleY, alphaScaleX, alphaScaleY);
            shader.setConstant</B></FONT>(&quot;cbCrScale&quot;, cbScaleX, cbScaleY, crScaleX, crScaleY);

            float tx1 = sx1 / imgWidth;
            float ty1 = sy1 / imgHeight;
            float tx2 = sx2 / imgWidth;
            float ty2 = sy2 / imgHeight;

            VertexBuffer vb = context.getVertexBuffer();
            vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
        } else {
            // should have been caught by validateTextureOp, but just in case
            throw new UnsupportedOperationException(&quot;Unsupported multitexture format &quot;+tex.getPixelFormat());
        }
    }

    public void drawTextureRaw2(Texture src1, Texture src2,
                                float dx1, float dy1, float dx2, float dy2,
                                float t1x1, float t1y1, float t1x2, float t1y2,
                                float t2x1, float t2y1, float t2x2, float t2y2)
    {
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        if (isSimpleTranslate) {
            xform = IDENT;
            dx1 += transX;
            dy1 += transY;
            dx2 += transX;
            dy2 += transY;
        }
        context.validateTextureOp(this, xform, src1, src2,
                                  PixelFormat.INT_ARGB_PRE);

        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2,
                   t1x1, t1y1, t1x2, t1y2,
                   t2x1, t2y1, t2x2, t2y2);
    }

    public void drawMappedTextureRaw2(Texture src1, Texture src2,
                                      float dx1, float dy1, float dx2, float dy2,
                                      float t1x11, float t1y11, float t1x21, float t1y21,
                                      float t1x12, float t1y12, float t1x22, float t1y22,
                                      float t2x11, float t2y11, float t2x21, float t2y21,
                                      float t2x12, float t2y12, float t2x22, float t2y22)
    {
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        if (isSimpleTranslate) {
            xform = IDENT;
            dx1 += transX;
            dy1 += transY;
            dx2 += transX;
            dy2 += transY;
        }
        context.validateTextureOp(this, xform, src1, src2,
                                  PixelFormat.INT_ARGB_PRE);

        VertexBuffer vb = context.getVertexBuffer();
        vb.addMappedQuad(dx1, dy1, dx2, dy2,
                         t1x11, t1y11, t1x21, t1y21,
                         t1x12, t1y12, t1x22, t1y22,
                         t2x11, t2y11, t2x21, t2y21,
                         t2x12, t2y12, t2x22, t2y22);
    }

    public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
                                 int dx, int dy, int dw, int dh,
                                 int ix, int iy, int mx, int my)
    {
        if (dw &lt;= 0 || dh &lt;= 0) return;
        float iw = imgtex.getPhysicalWidth();
        float ih = imgtex.getPhysicalHeight();
        float mw = masktex.getPhysicalWidth();
        float mh = masktex.getPhysicalHeight();
        float dx1 = dx;
        float dy1 = dy;
        float dx2 = dx + dw;
        float dy2 = dy + dh;
        float ix1 = ix / iw;
        float iy1 = iy / ih;
        float ix2 = (ix + dw) / iw;
        float iy2 = (iy + dh) / ih;
        float mx1 = mx / mw;
        float my1 = my / mh;
        float mx2 = (mx + dw) / mw;
        float my2 = (my + dh) / mh;
        context.validateMaskTextureOp(this, IDENT, imgtex, masktex,
                                      PixelFormat.INT_ARGB_PRE);
        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2,
                   ix1, iy1, ix2, iy2,
                   mx1, my1, mx2, my2);
    }

    public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex,
                                      int dx, int dy, int dw, int dh,
                                      int ix, int iy, int mx, int my)
    {
        if (dw &lt;= 0 || dh &lt;= 0) return;
        float iw = imgtex.getPhysicalWidth();
        float ih = imgtex.getPhysicalHeight();
        float mw = masktex.getPhysicalWidth();
        float mh = masktex.getPhysicalHeight();
        float dx1 = dx;
        float dy1 = dy;
        float dx2 = dx + dw;
        float dy2 = dy + dh;
        float ix1 = ix / iw;
        float iy1 = iy / ih;
        float ix2 = (ix + dw) / iw;
        float iy2 = (iy + dh) / ih;
        float mx1 = mx / mw;
        float my1 = my / mh;
        float mx2 = (mx + dw) / mw;
        float my2 = (my + dh) / mh;
        CompositeMode oldmode = getCompositeMode();
        setCompositeMode(CompositeMode.DST_OUT);
        context.validateTextureOp(this, IDENT, masktex,
                                  PixelFormat.INT_ARGB_PRE);
        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2,
                   mx1, my1, mx2, my2);

        setCompositeMode(CompositeMode.ADD);
        context.validateMaskTextureOp(this, IDENT, imgtex, masktex,
                                      PixelFormat.INT_ARGB_PRE);
        vb.addQuad(dx1, dy1, dx2, dy2,
                   ix1, iy1, ix2, iy2,
                   mx1, my1, mx2, my2);

        setCompositeMode(oldmode);
    }

    private void renderWithComplexPaint(Shape shape, BasicStroke stroke,
                                        float bx, float by, float bw, float bh)
    {
        // creating/updating the mask texture may unset the current
        // texture used by pending vertices, so flush the vertex buffer first
        context.flushVertexBuffer();

        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        MaskData maskData =
            ShapeUtil.rasterizeShape(shape, stroke, getFinalClipNoClone(), xform, true, isAntialiasedShape());
        int maskW = maskData.getWidth();
        int maskH = maskData.getHeight();

        float dx1 = maskData.getOriginX();
        float dy1 = maskData.getOriginY();
        float dx2 = dx1 + maskW;
        float dy2 = dy1 + maskH;

        // Note that we could use multitexturing here (upload mask
        // data to texture unit 0 and paint data to texture unit 1
        // then set the texture mode to modulate) but this operation is
        // already plenty slow and not worth optimizing at this time,
        // so for now we will merge the mask with the paint data in software.
        Gradient grad = (Gradient)paint;
        TEMP_TX2D.setToTranslation(-dx1, -dy1);
        TEMP_TX2D.concatenate(xform);
        Texture tex = context.getGradientTexture(grad, TEMP_TX2D,
                                                 maskW, maskH, maskData,
                                                 bx, by, bw, bh);

        float tx1 = 0f;
        float ty1 = 0f;
        float tx2 = tx1 + ((float)maskW) / tex.getPhysicalWidth();
        float ty2 = ty1 + ((float)maskH) / tex.getPhysicalHeight();

        // the mask has been generated in device space, so we use
        // identity transform here
        VertexBuffer vb = context.getVertexBuffer();
        context.validateTextureOp(this, IDENT, tex, null, tex.getPixelFormat());
        vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
        tex.unlock();
    }

    private static RectBounds TMP_BOUNDS = new RectBounds();
    @Override
    protected void renderShape(Shape shape, BasicStroke stroke,
                               float bx, float by, float bw, float bh)
    {
        if (isComplexPaint) {
            renderWithComplexPaint(shape, stroke, bx, by, bw, bh);
            return;
        }

        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        MaskData maskData =
            ShapeUtil.rasterizeShape(shape, stroke, getFinalClipNoClone(), xform, true, isAntialiasedShape());
        Texture maskTex = context.validateMaskTexture(maskData, false);

        AffineBase paintTx;
        if (PrismSettings.primTextureSize != 0) {
            // the mask has been generated in device space, so we use
            // identity transform here
            Shader shader =
                context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE, maskTex,
                                        bx, by, bw, bh);

            paintTx = getPaintTextureTx(xform, shader, bx, by, bw, bh);
        } else {
            // the mask has been generated in device space, so we use
            // identity transform here
            context.validatePaintOp(this, IDENT, maskTex, bx, by, bw, bh);
            paintTx = null;
        }

        context.updateMaskTexture(maskData, TMP_BOUNDS, false);

        float dx1 = maskData.getOriginX();
        float dy1 = maskData.getOriginY();
        float dx2 = dx1 + maskData.getWidth();
        float dy2 = dy1 + maskData.getHeight();
        float tx1 = TMP_BOUNDS.getMinX();
        float ty1 = TMP_BOUNDS.getMinY();
        float tx2 = TMP_BOUNDS.getMaxX();
        float ty2 = TMP_BOUNDS.getMaxY();

        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2, paintTx);

        maskTex.unlock();
    }

    private static float getStrokeExpansionFactor(BasicStroke stroke) {
        if (stroke.getType() == BasicStroke.TYPE_OUTER) {
            return 1f;
        } else if (stroke.getType() == BasicStroke.TYPE_CENTERED) {
            return 0.5f;
        } else {
            return 0f;
        }
    }

    private static final float FRINGE_FACTOR;
    static {
        String v = (String) AccessController.doPrivileged((PrivilegedAction) () -&gt; System.getProperty(&quot;prism.primshaderpad&quot;));
        if (v == null) {
            FRINGE_FACTOR = -0.5f;
        } else {
            FRINGE_FACTOR = -Float.valueOf(v);
            System.out.println(&quot;Prism ShaderGraphics primitive shader pad = &quot;+FRINGE_FACTOR);
        }
    }

    private BaseTransform extract3Dremainder(BaseTransform xform) {
        if (xform.is2D()) {
            return IDENT;
        }
        TEMP_TX3D.setTransform(xform);
        TEMP_TX2D.setTransform(xform.getMxx(), xform.getMyx(),
                               xform.getMxy(), xform.getMyy(),
                               xform.getMxt(), xform.getMyt());
        try {
            TEMP_TX2D.invert();
            TEMP_TX3D.concatenate(TEMP_TX2D);
        } catch (NoninvertibleTransformException ex) {
        }
        return TEMP_TX3D;
    }

    private void renderGeneralRoundedRect(float rx, float ry, float rw, float rh,
                                          float arcw, float arch,
                                          MaskType type, BasicStroke stroke)
    {
        // NOTE: using floats here for now, not sure if it's a problem yet...
        float bx, by, bw, bh, ifractw, ifracth;
        float ox, oy, wdx, wdy, hdx, hdy;
        if (stroke == null) {
            bx = rx;
            by = ry;
            bw = rw;
            bh = rh;
            ifractw = ifracth = 0f;
        } else {
            float sw = stroke.getLineWidth();
            float ow = getStrokeExpansionFactor(stroke) * sw;
            bx = rx - ow;
            by = ry - ow;
            ow *= 2f;
            bw = rw + ow;
            bh = rh + ow;
            if (arcw &gt; 0 &amp;&amp; arch &gt; 0) {
                arcw += ow;
                arch += ow;
            } else {
                if (stroke.getLineJoin() == BasicStroke.JOIN_ROUND) {
                    arcw = arch = ow;
                    type = MaskType.DRAW_ROUNDRECT;
                } else {
                    arcw = arch = 0f;
                }
            }
            ifractw = (bw - sw * 2f) / bw;
            ifracth = (bh - sw * 2f) / bh;
            if (ifractw &lt;= 0f || ifracth &lt;= 0f) {
                type = type.getFillType();
            }
        }

        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        BaseTransform rendertx;
        if (isSimpleTranslate) {
            wdx = hdy = 1f;
            wdy = hdx = 0f;
            ox = bx + transX;
            oy = by + transY;
            rendertx = IDENT;
        } else {
            rendertx = extract3Dremainder(xform);
            wdx = (float)xform.getMxx();
            hdx = (float)xform.getMxy();
            wdy = (float)xform.getMyx();
            hdy = (float)xform.getMyy();
            ox = (bx * wdx) + (by * hdx) + (float)xform.getMxt();
            oy = (bx * wdy) + (by * hdy) + (float)xform.getMyt();
        }

        wdx *= bw;
        wdy *= bw;
        hdx *= bh;
        hdy *= bh;

        float arcfractw = arcw / bw;
        float arcfracth = arch / bh;
        renderGeneralRoundedPgram(ox, oy, wdx, wdy, hdx, hdy,
                                  arcfractw, arcfracth, ifractw, ifracth,
                                  rendertx, type, rx, ry, rw, rh);
    }

    private void renderGeneralRoundedPgram(float ox, float oy,
                                           float wvecx, float wvecy,
                                           float hvecx, float hvecy,
                                           float arcfractw, float arcfracth,
                                           float ifractw, float ifracth,
                                           BaseTransform rendertx, MaskType type,
                                           float rx, float ry, float rw, float rh)
    {
        float wlen = len(wvecx, wvecy);
        float hlen = len(hvecx, hvecy);
        if (wlen == 0 || hlen == 0) {
            // parallelogram has collapsed to a line or point
            return;
        }

        // Calculate the 4 corners of the pgram in device space.
        // Note that the UL,UR,LL,LR (Upper/Lower Left/Right) designations
        // are virtual since the wdxy and hdxy vectors can point in any
        // direction depending on the transform being applied.
        float xUL = ox;
        float yUL = oy;
        float xUR = ox + wvecx;
        float yUR = oy + wvecy;
        float xLL = ox + hvecx;
        float yLL = oy + hvecy;
        float xLR = xUR + hvecx;
        float yLR = yUR + hvecy;

        // Calculate the unit vectors along each side of the pgram as well
        // as the device space perpendicular dimension across the pgram
        // (which is different than the lengths of the two pairs of sides
        //  since it is measured perpendicular to the &quot;other&quot; sides, not
        //  along the original sides).
        // The perpendicular dimension is the dot product of the perpendicular
        // of the unit vector for one pair of sides with the displacement
        // vector for the other pair of sides.
        // The unit vector perpendicular to (dx,dy) is given by:
        // normx = dx / len(dx, dy);
        // normy = dy / len(dx, dy);
        // The (ccw) perpendicular vectors would then be:
        // unitperpx = +normy = +dy / len;
        // unitperpy = -normx = -dx / len;
        // Thus the perpendicular width and height distances are:
        // pwdist = wvec.uphvec = wvecx * (hvecy/hlen) - wvecy * (hvecx/hlen)
        // phdist = hvec.upwvec = hvecx * (wvecy/wlen) - hvecy * (wvecx/wlen)
        // If we factor out the divide by the lengths then we are left
        // with numerators that are simply negations of each other:
        // pwdist = (wvecx * hvecy - wvecy * hvecx) / hlen
        // phdist = (hvecx * wvecy - hvecy * wvecx) / wlen
        // Finally we multiply by 0.5 since we want the distance to the
        // edges of the parallelgram from the center point, not across the
        // whole pgram.  And, since we want the absolute value, we can
        // ignore the fact that the numerator is negated between the two
        // formulas since we will just have to negate one of the 2 values
        // afterwards anyway to make them both positive.
        // Note that the numerators are the formula for the area of the
        // parallelogram (without the abs() operation).  Dividing by the
        // length of one of the sides would then give the length of the
        // perpendicular across to the other side.
        float halfarea = (wvecx * hvecy - wvecy * hvecx) * 0.5f;
        float pwdist = halfarea / hlen;
        float phdist = halfarea / wlen;
        if (pwdist &lt; 0) pwdist = -pwdist;
        if (phdist &lt; 0) phdist = -phdist;

        // Now we calculate the normalized unit vectors.
        float nwvecx = wvecx / wlen;
        float nwvecy = wvecy / wlen;
        float nhvecx = hvecx / hlen;
        float nhvecy = hvecy / hlen;

        // Bias the parallelogram corner coordinates &quot;outward&quot; by half a
        // pixel distance.
        // The most general way to do this is to move each parallelogram
        // edge outward by a specified distance and then find the new
        // intersection point.
        // The general form for the intersection of 2 lines is:
        // line1 = (x1,y1) -&gt; (x2,y2)
        // line2 = (x3,y3) -&gt; (x4,y4)
        // t = ((x4-x3)(y1-y3) - (y4-y3)(x1-x3))
        //   / ((y4-y3)(x2-x1) - (x4-x3)(y2-y1))
        // intersection point = (x1 + t*(x2-x1), y1 + t*(y2-y1))
        // Now consider if these lines are displaced versions of 2
        // other lines which share a common end point (such as is the
        // case of pushing 2 adjacent edges of the pgram outward:
        // line1 = (xa+dx1, ya+dy1) -&gt; (xb+dx1, yb+dy1)
        // line2 = (xa+dx2, ya+dy2) -&gt; (xc+dx2, yc+dy2)
        // &quot;x4-x3&quot; = (xc+dx2) - (xa+dx2) = xc-xa
        // &quot;y4-y3&quot; = (yc+dy2) - (ya+dy2) = yc-ya
        // &quot;x2-x1&quot; = (xb+dx1) - (xa+dx1) = xb-xa
        // &quot;y2-y1&quot; = (yb+dy1) - (ya+dy1) = yb-ya
        // &quot;y1-y3&quot; = (y1+dy1) - (y1+dy2) = dy1 - dy2
        // &quot;x1-x3&quot; = (xa+dx1) - (xa+dx2) = dx1 - dx2
        // t = ((xc-xa)(dy1-dy2) - ((yc-ya)(dx1-dx2))
        //   / ((yc-ya)(xb-xa) - (xc-xa)(yb-ya))
        // Now we need to displace these 2 lines &quot;outward&quot; by half a
        // pixel distance.  We will start by looking at applying a unit
        // pixel distance and then cutting the adjustment in half (it
        // can be seen to scale linearly when you look at the final
        // equations).  This is achieved by applying one of our unit
        // vectors with a cw rotation to one line and the other unit
        // vector with a ccw rotation to the other line.  Ideally we
        // would choose which to apply cw vs. ccw by the way that this
        // corner of the pgram is turning, but as it turns out, the
        // consequences of getting it backward is that our &quot;t&quot; will
        // turn out negative (just negate all of the d[xy][12] values
        // in the t equation above and you will see that it changes
        // sign.  Since we are calculating the new corner using the
        // equation newx = (xa+dx1) + t*(xb-xa), we want the value of
        // t that drives the point &quot;away from xb,yb&quot;, in other words,
        // we want the negative t.  So, if t is positive then we want
        // to use negative t and reverse the perpendicular offset we
        // applied to xa:
        // t &lt; 0 =&gt; newx = (xa+dx) + t*(xb-xa) = xa + (dx + t*(xb-xa))
        // t &gt; 0 =&gt; newx = (xa-dx) - t*(xb-xa) = xa - (dx + t*(xb-xa))
        // where (copying t equation from above again):
        // t = ((xc-xa)(dy1-dy2) - ((yc-ya)(dx1-dx2))
        //   / ((yc-ya)(xb-xa) - (xc-xa)(yb-ya))
        // For xa,ya = xUL,yUL and xb,yb = xUR,yUR and xc,yc = xLL,yLL:
        // [xy]b - [xy]a = [xy]UR - [xy]UL = wvec
        // [xy]c - [xy]a = [xy]LL - [xy]UL = hvec
        // dx1,dy1 = +nwvecy, -nwvecx  // ccw on xa-&gt;xb
        // dx2,dy2 = -nhvecy, +nhvecx  //  cw on xa-&gt;xc
        // dx1 - dx2 = +nwvecy - -nhvecy = nwvecy + nhvecy
        // dy1 - dy2 = -nwvecx - +nhvecx = -(nwvecx + nhvecx)
        float num = -hvecx*(nwvecx + nhvecx) - hvecy*(nwvecy + nhvecy);
        float den = hvecy*wvecx - hvecx*wvecy;
        float t = num / den;
        // Negating the sign of t and multiplying by 0.5 gets us the
        // proper sign for the offset and cuts it down to half a pixel
        float factor = FRINGE_FACTOR * Math.signum(t);
        float offx = (t * wvecx + nwvecy) * factor;
        float offy = (t * wvecy - nwvecx) * factor;
        xUL += offx; yUL += offy;
        // x22 is offset by the reverse amounts
        xLR -= offx; yLR -= offy;
        // For xa,ya = xUR,yUR and xb,yb = xLR,yLR and xc,yc = xUL,yUL
        // Note that xa,ya =&gt; xc,yc is negative of wvec
        // [xy]b - [xy]a = [xy]LR - [xy]UR = +hvec
        // [xy]c - [xy]a = [xy]UL - [xy]UR = -wvec
        // dx1,dy1                          = +nhvecy, -nhvecx
        // dx2,dy2 = -(-nwvecy), +(-nwvecx) = +nwvecy, -nwvecx
        // dx1 - dx2                     = nhvecy - nwvecy
        // dy1 - dy2 = -nhvecx - -nwvecx = nwvecx - nhvecx
        // den = -wvecy * hvecx - -wvecx * hvecy
        //     = hvecy * wvecx - hvecx * wvecy (already computed)
        // num = -wvecx * (nwvecx - nhvecx) - -wvecy * (nhvecy - nwvecy)
        //     = wvecy * (nhvecy - nwvecy) - wvecx * (nwvecx - nhvecx)
        num = wvecy * (nhvecy - nwvecy) - wvecx * (nwvecx - nhvecx);
        t = num / den;
        factor = FRINGE_FACTOR * Math.signum(t);
        offx = (t * hvecx + nhvecy) * factor;
        offy = (t * hvecy - nhvecx) * factor;
        xUR += offx; yUR += offy;
        xLL -= offx; yLL -= offy;

        // texture coordinates (uv) will be calculated using a transform
        // by the perpendicular unit vectors so that the texture U
        // coordinates measure our progress along the pwdist axis (i.e.
        // perpendicular to hvec and the texture V coordinates measure
        // our progress along phdist (perpendicular to wvec):
        // u = x * nhvecy - y * nhvecx;
        // v = x * nwvecy - y * nwvecx;

        // We now calculate the uv paramters for the 4 corners such that
        //     uv(cx,cy) = 0,0
        //     uv(corners - center) = +/-(wlen/2), +/-(hlen/2)
        // Note that:
        //     uv(corner - center) = uv(corner) - uv(center)
        // Calculate the center of the parallelogram and its uv values
        float xC = (xUL + xLR) * 0.5f;
        float yC = (yUL + yLR) * 0.5f;
        float uC = xC * nhvecy - yC * nhvecx;
        float vC = xC * nwvecy - yC * nwvecx;
        // Now use that to calculate the corner values relative to the center
        float uUL = xUL * nhvecy - yUL * nhvecx - uC;
        float vUL = xUL * nwvecy - yUL * nwvecx - vC;
        float uUR = xUR * nhvecy - yUR * nhvecx - uC;
        float vUR = xUR * nwvecy - yUR * nwvecx - vC;
        float uLL = xLL * nhvecy - yLL * nhvecx - uC;
        float vLL = xLL * nwvecy - yLL * nwvecx - vC;
        float uLR = xLR * nhvecy - yLR * nhvecx - uC;
        float vLR = xLR * nwvecy - yLR * nwvecx - vC;

        // the pgram params have been calculated in device space, so we use
        // identity transform here
        if (type == MaskType.DRAW_ROUNDRECT || type == MaskType.FILL_ROUNDRECT) {
            float oarcw = pwdist * arcfractw;
            float oarch = phdist * arcfracth;
            if (oarcw &lt; 0.5 || oarch &lt; 0.5) {
                // The pgram renderer fades the entire primitive if the arc
                // sizes fall below 0.5 pixels since the interiors act as if
                // they are sampled at the center of the indicated circle and
                // radii smaller than that produce less than full coverage
                // even at the circle center.  If the arcwh are less than
                // 0.5 then the difference in area of the corner pixels
                // compared to a PGRAM primitive of the same size is just the
                // tiny corner cutout of area (4-PI)/16 which is less than
                // .06 pixels.  Thus, we can convert the primitive to a
                // PGRAM without any loss of precision.
                type = (type == MaskType.DRAW_ROUNDRECT)
                    ? MaskType.DRAW_PGRAM : MaskType.FILL_PGRAM;
            } else {
                float flatw = pwdist - oarcw;
                float flath = phdist - oarch;
                float ivalw, ivalh;
                if (type == MaskType.DRAW_ROUNDRECT) {
                    float iwdist = pwdist * ifractw;
                    float ihdist = phdist * ifracth;
                    // First we calculate the inner arc radii and see if they
                    // are large enough to render.
                    ivalw = iwdist - flatw;
                    ivalh = ihdist - flath;
                    // As above we need to fix things if we get inner arc
                    // radii below half a pixel.  We have a special shader
                    // for doing a &quot;semi round&quot; rect which has a round outer
                    // shell and a rectangular (pgram) inner shell...
                    if (ivalw &lt; 0.5f || ivalh &lt; 0.5f) {
                        // inner val is idim
                        ivalw = iwdist;
                        ivalh = ihdist;
                        type = MaskType.DRAW_SEMIROUNDRECT;
                    } else {
                        // inner val is invarcradii
                        ivalw = 1.0f / ivalw;
                        ivalh = 1.0f / ivalh;
                    }
                } else {
                    // Not used by FILL_ROUNDRECT, but we need constant
                    // values that will not cause an unnecessary vertex
                    // buffer flush in the validateOp below.
                    ivalw = ivalh = 0f;
                }
                oarcw = 1.0f / oarcw;
                oarch = 1.0f / oarch;
                Shader shader =
                    context.validatePaintOp(this, rendertx, type,
                                            rx, ry, rw, rh,
                                            oarcw, oarch,
                                            ivalw, ivalh, 0, 0);
                shader.setConstant(&quot;oinvarcradii&quot;, oarcw, oarch);
                if (type == MaskType.DRAW_ROUNDRECT) {
                    shader.setConstant(&quot;iinvarcradii&quot;, ivalw, ivalh);
                } else if (type == MaskType.DRAW_SEMIROUNDRECT) {
                    shader.setConstant(&quot;idim&quot;, ivalw, ivalh);
                }
                pwdist = flatw;
                phdist = flath;
            }
        } // no else here as we may have converted an RRECT to a PGRAM above
        if (type == MaskType.DRAW_PGRAM || type == MaskType.DRAW_ELLIPSE) {
            float idimw = pwdist * ifractw;
            float idimh = phdist * ifracth;
            if (type == MaskType.DRAW_ELLIPSE) {
                if (Math.abs(pwdist - phdist) &lt; .01) {
                    type = MaskType.DRAW_CIRCLE;
                    // The phdist and idimh parameters will not be used by this
                    // shader, but we do need the maximum single pixel coverage
                    // so we coopt them to be min(1.0, area):
                    phdist = (float) Math.min(1.0, phdist * phdist * Math.PI);
                    idimh = (float) Math.min(1.0, idimh * idimh * Math.PI);
                } else {
                    // the ellipse drawing shader uses inverted arc dimensions
                    // to turn divides into multiplies
                    pwdist = 1.0f / pwdist;
                    phdist = 1.0f / phdist;
                    idimw = 1.0f / idimw;
                    idimh = 1.0f / idimh;
                }
            }
            Shader shader =
                context.validatePaintOp(this, rendertx, type,
                                        rx, ry, rw, rh,
                                        idimw, idimh, 0f, 0f, 0f, 0f);
            shader.setConstant(&quot;idim&quot;, idimw, idimh);
        } else if (type == MaskType.FILL_ELLIPSE) {
            if (Math.abs(pwdist - phdist) &lt; .01) {
                type = MaskType.FILL_CIRCLE;
                // The phdist parameter will not be used by this shader,
                // but we do need the maximum single pixel contribution
                // so we coopt the value to be min(1.0, area):
                phdist = (float) Math.min(1.0, phdist * phdist * Math.PI);
            } else {
                // the ellipse filling shader uses inverted arc dimensions to
                // turn divides into multiplies:
                pwdist = 1.0f / pwdist;
                phdist = 1.0f / phdist;
                uUL *= pwdist;    vUL *= phdist;
                uUR *= pwdist;    vUR *= phdist;
                uLL *= pwdist;    vLL *= phdist;
                uLR *= pwdist;    vLR *= phdist;
            }
            context.validatePaintOp(this, rendertx, type, rx, ry, rw, rh);
        } else if (type == MaskType.FILL_PGRAM) {
            context.validatePaintOp(this, rendertx, type, rx, ry, rw, rh);
        }

        context.getVertexBuffer().addMappedPgram(xUL, yUL, xUR, yUR,
                                                 xLL, yLL, xLR, yLR,
                                                 uUL, vUL, uUR, vUR,
                                                 uLL, vLL, uLR, vLR,
                                                 pwdist, phdist);
    }

    AffineBase getPaintTextureTx(BaseTransform renderTx, Shader shader,
                                 float rx, float ry, float rw, float rh)
    {
        switch (paint.getType()) {
            case COLOR:
                return null;
            case LINEAR_GRADIENT:
                return PaintHelper.getLinearGradientTx((LinearGradient) paint,
                                                       shader, renderTx,
                                                       rx, ry, rw, rh);
            case RADIAL_GRADIENT:
                return PaintHelper.getRadialGradientTx((RadialGradient) paint,
                                                       shader, renderTx,
                                                       rx, ry, rw, rh);
            case IMAGE_PATTERN:
                return PaintHelper.getImagePatternTx(this, (ImagePattern) paint,
                                                     shader, renderTx,
                                                     rx, ry, rw, rh);
        }
        throw new InternalError(&quot;Unrecogized paint type: &quot;+paint);
    }

    // The second set of rectangular bounds are for validating a
    // proportional paint.  They should be identical to the first
    // set for a fillRect() operation, but they may be different
    // for a vertical or horizontal drawLine() operation.
    boolean fillPrimRect(float x, float y, float w, float h,
                         Texture rectTex, Texture wrapTex,
                         float bx, float by, float bw, float bh)
    {
        BaseTransform xform = getTransformNoClone();
        float mxx = (float) xform.getMxx();
        float mxy = (float) xform.getMxy();
        float mxt = (float) xform.getMxt();
        float myx = (float) xform.getMyx();
        float myy = (float) xform.getMyy();
        float myt = (float) xform.getMyt();
        float dxdist = len(mxx, myx);
        float dydist = len(mxy, myy);
        if (dxdist == 0.0f || dydist == 0.0f) {
            // entire path has collapsed and occupies no area
            return true;
        }
        float pixelw = 1.0f / dxdist;
        float pixelh = 1.0f / dydist;
        float x0 = x - pixelw * 0.5f;
        float y0 = y - pixelh * 0.5f;
        float x1 = x + w + pixelw * 0.5f;
        float y1 = y + h + pixelh * 0.5f;
        int cellw = (int) Math.ceil(w * dxdist - 1.0f/512.0f);
        int cellh = (int) Math.ceil(h * dydist - 1.0f/512.0f);
        VertexBuffer vb = context.getVertexBuffer();
        int max = context.getRectTextureMaxSize();
        if (cellw &lt;= max &amp;&amp; cellh &lt;= max) {
            float u0 = ((cellw * (cellw + 1)) / 2) - 0.5f;
            float v0 = ((cellh * (cellh + 1)) / 2) - 0.5f;
            float u1 = u0 + cellw + 1.0f;
            float v1 = v0 + cellh + 1.0f;
            u0 /= rectTex.getPhysicalWidth();
            v0 /= rectTex.getPhysicalHeight();
            u1 /= rectTex.getPhysicalWidth();
            v1 /= rectTex.getPhysicalHeight();
            if (xform.isTranslateOrIdentity()) {
                x0 += mxt;
                y0 += myt;
                x1 += mxt;
                y1 += myt;
                xform = IDENT;
            } else if (xform.is2D()) {
                Shader shader =
                    context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE, rectTex,
                                            bx, by, bw, bh);
                AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
                if (paintTx == null) {
                    vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                      x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                      x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                      x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                      u0, v0, u1, v0, u0, v1, u1, v1, 0, 0);
                } else {
                    vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                      x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                      x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                      x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                      u0, v0, u1, v0, u0, v1, u1, v1,
                                      x0, y0, x1, y1, paintTx);
                }
                return true;
            } else {
                System.out.println(&quot;Not a 2d transform!&quot;);
                mxt = myt = 0.0f;
            }
            Shader shader =
                context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rectTex,
                                        bx, by, bw, bh);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
            if (paintTx == null) {
                vb.addQuad(x0, y0, x1, y1,
                           u0, v0, u1, v1);
            } else {
                paintTx.translate(-mxt, -myt);
                vb.addQuad(x0, y0, x1, y1,
                           u0, v0, u1, v1,
                           paintTx);
            }
            return true;
        }
        if (wrapTex == null) {
            return false;
        }
        float u0 = 0.5f / wrapTex.getPhysicalWidth();
        float v0 = 0.5f / wrapTex.getPhysicalHeight();
        float uc = (cellw * 0.5f + 1.0f) / wrapTex.getPhysicalWidth();
        float vc = (cellh * 0.5f + 1.0f) / wrapTex.getPhysicalHeight();
        float xc = x + w * 0.5f;
        float yc = y + h * 0.5f;
        if (xform.isTranslateOrIdentity()) {
            x0 += mxt;
            y0 += myt;
            xc += mxt;
            yc += myt;
            x1 += mxt;
            y1 += myt;
            xform = IDENT;
        } else if (xform.is2D()) {
            Shader shader =
                context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE, wrapTex,
                                        bx, by, bw, bh);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
            float mxx_x0 = mxx * x0, myx_x0 = myx * x0;
            float mxy_y0 = mxy * y0, myy_y0 = myy * y0;
            float mxx_xc = mxx * xc, myx_xc = myx * xc;
            float mxy_yc = mxy * yc, myy_yc = myy * yc;
            float mxx_x1 = mxx * x1, myx_x1 = myx * x1;
            float mxy_y1 = mxy * y1, myy_y1 = myy * y1;
            // xcc,ycc used in all 4 quads
            float xcc = mxx_xc + mxy_yc + mxt;
            float ycc = myx_xc + myy_yc + myt;
            // xcn, ycn and xnc, ync all used in 2 quads each
            float xc0 = mxx_xc + mxy_y0 + mxt;
            float yc0 = myx_xc + myy_y0 + myt;
            float x0c = mxx_x0 + mxy_yc + mxt;
            float y0c = myx_x0 + myy_yc + myt;
            float xc1 = mxx_xc + mxy_y1 + mxt;
            float yc1 = myx_xc + myy_y1 + myt;
            float x1c = mxx_x1 + mxy_yc + mxt;
            float y1c = myx_x1 + myy_yc + myt;
            // Note that all quads use same 00-&gt;c0-&gt;0c-&gt;cc coordinates for
            // the inner and outer uv texture coordinates regardless of the
            // reflection of the quad of vertex coordinates

            if (paintTx == null) {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                           xc0, yc0, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                           xc0, yc0, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                           xc1, yc1, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                           xc1, yc1, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
            } else {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                           xc0, yc0, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x0, y0, xc, yc, paintTx);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                           xc0, yc0, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x1, y0, xc, yc, paintTx);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                           xc1, yc1, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x0, y1, xc, yc, paintTx);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                           xc1, yc1, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x1, y1, xc, yc, paintTx);
            }
            return true;
        } else {
            System.out.println(&quot;Not a 2d transform!&quot;);
            mxt = myt = 0;
        }
        Shader shader =
            context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, wrapTex,
                                    bx, by, bw, bh);
        AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
        if (paintTx != null) {
            paintTx.translate(-mxt, -myt);
        }
        vb.addQuad(x0, y0, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        vb.addQuad(x1, y0, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        vb.addQuad(x0, y1, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        vb.addQuad(x1, y1, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        return true;
    }

    boolean drawPrimRect(float x, float y, float w, float h) {
        float lw = stroke.getLineWidth();
        float pad = getStrokeExpansionFactor(stroke) * lw;
        BaseTransform xform = getTransformNoClone();
        float mxx = (float) xform.getMxx();
        float mxy = (float) xform.getMxy();
        float mxt = (float) xform.getMxt();
        float myx = (float) xform.getMyx();
        float myy = (float) xform.getMyy();
        float myt = (float) xform.getMyt();
        float dxdist = len(mxx, myx);
        float dydist = len(mxy, myy);
        if (dxdist == 0.0f || dydist == 0.0f) {
            // entire path has collapsed and occupies no area
            return true;
        }
        float pixelw = 1.0f / dxdist;
        float pixelh = 1.0f / dydist;
        float x0 = x - pad - pixelw * 0.5f;
        float y0 = y - pad - pixelh * 0.5f;
        float xc = x + w * 0.5f;
        float yc = y + h * 0.5f;
        float x1 = x + w + pad + pixelw * 0.5f;
        float y1 = y + h + pad + pixelh * 0.5f;
        Texture rTex = context.getWrapRectTexture();
        float wscale = 1.0f / rTex.getPhysicalWidth();
        float hscale = 1.0f / rTex.getPhysicalHeight();
        float ou0 = 0.5f * wscale;
        float ov0 = 0.5f * hscale;
        float ouc = ((w * 0.5f + pad) * dxdist + 1.0f) * wscale;
        float ovc = ((h * 0.5f + pad) * dydist + 1.0f) * hscale;
        float offsetx = lw * dxdist * wscale;
        float offsety = lw * dydist * hscale;
        VertexBuffer vb = context.getVertexBuffer();
        if (xform.isTranslateOrIdentity()) {
            x0 += mxt;
            y0 += myt;
            xc += mxt;
            yc += myt;
            x1 += mxt;
            y1 += myt;
            xform = IDENT;
        } else if (xform.is2D()) {
            Shader shader =
                context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE_DIFF,
                                        rTex, x, y, w, h,
                                        offsetx, offsety, 0, 0, 0, 0);
            shader.setConstant(&quot;innerOffset&quot;, offsetx, offsety);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, x, y, w, h);
            float mxx_x0 = mxx * x0, myx_x0 = myx * x0;
            float mxy_y0 = mxy * y0, myy_y0 = myy * y0;
            float mxx_xc = mxx * xc, myx_xc = myx * xc;
            float mxy_yc = mxy * yc, myy_yc = myy * yc;
            float mxx_x1 = mxx * x1, myx_x1 = myx * x1;
            float mxy_y1 = mxy * y1, myy_y1 = myy * y1;

            // xcc,ycc used in all 4 quads
            float xcc = mxx_xc + mxy_yc + mxt;
            float ycc = myx_xc + myy_yc + myt;
            // xcn, ycn and xnc, ync all used in 2 quads each
            float xc0 = mxx_xc + mxy_y0 + mxt;
            float yc0 = myx_xc + myy_y0 + myt;
            float x0c = mxx_x0 + mxy_yc + mxt;
            float y0c = myx_x0 + myy_yc + myt;
            float xc1 = mxx_xc + mxy_y1 + mxt;
            float yc1 = myx_xc + myy_y1 + myt;
            float x1c = mxx_x1 + mxy_yc + mxt;
            float y1c = myx_x1 + myy_yc + myt;
            // Note that all quads use same 00-&gt;c0-&gt;0c-&gt;cc coordinates for
            // the inner and outer uv texture coordinates regardless of the
            // reflection of the quad of vertex coordinates

            if (paintTx == null) {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(mxx_x0 + mxy_y0 + mxt, myx_x0 + myy_y0 + myt,
                                            xc0, yc0, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(mxx_x1 + mxy_y0 + mxt, myx_x1 + myy_y0 + myt,
                                            xc0, yc0, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(mxx_x0 + mxy_y1 + mxt, myx_x0 + myy_y1 + myt,
                                            xc1, yc1, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(mxx_x1 + mxy_y1 + mxt, myx_x1 + myy_y1 + myt,
                                            xc1, yc1, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
            } else {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(mxx_x0 + mxy_y0 + mxt, myx_x0 + myy_y0 + myt,
                                            xc0, yc0, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x0, y0, xc, yc, paintTx);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(mxx_x1 + mxy_y0 + mxt, myx_x1 + myy_y0 + myt,
                                            xc0, yc0, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x1, y0, xc, yc, paintTx);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(mxx_x0 + mxy_y1 + mxt, myx_x0 + myy_y1 + myt,
                                            xc1, yc1, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x0, y1, xc, yc, paintTx);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(mxx_x1 + mxy_y1 + mxt, myx_x1 + myy_y1 + myt,
                                            xc1, yc1, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x1, y1, xc, yc, paintTx);
            }
            rTex.unlock();
            return true;
        } else {
            System.out.println(&quot;Not a 2d transform!&quot;);
            mxt = myt = 0.0f;
        }
        Shader shader =
            context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE_DIFF,
                                    rTex, x, y, w, h,
                                    offsetx, offsety, 0, 0, 0, 0);
        shader.setConstant(&quot;innerOffset&quot;, offsetx, offsety);
        AffineBase paintTx = getPaintTextureTx(IDENT, shader, x, y, w, h);
        if (paintTx != null) {
            paintTx.translate(-mxt, -myt);
        }
        vb.addQuad( x0,  y0,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        vb.addQuad( x1,  y0,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        vb.addQuad( x0,  y1,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        vb.addQuad( x1,  y1,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        rTex.unlock();
        return true;
    }

    boolean drawPrimDiagonal(float x1, float y1, float x2, float y2,
                             float lw, int cap,
                             float bx, float by, float bw, float bh)
    {
        // assert x1 != x2 &amp;&amp; y1 != y2, otherwise caller would have
        // vectored us to fillPrimRect()
        if (stroke.getType() == BasicStroke.TYPE_CENTERED) {
            lw *= 0.5f;
        }
        float dx = x2 - x1;
        float dy = y2 - y1;
        float len = len(dx, dy);
        dx /= len;
        dy /= len;
        float ldx = dx * lw;
        float ldy = dy * lw;
        // First expand perpendicularly using (ldy, -ldx)
        float xUL = x1 + ldy,  yUL = y1 - ldx;
        float xUR = x2 + ldy,  yUR = y2 - ldx;
        float xLL = x1 - ldy,  yLL = y1 + ldx;
        float xLR = x2 - ldy,  yLR = y2 + ldx;
        if (cap == BasicStroke.CAP_SQUARE) {
            // Then add SQUARE end caps using (ldx, ldy) if needed
            xUL -= ldx;  yUL -= ldy;
            xLL -= ldx;  yLL -= ldy;
            xUR += ldx;  yUR += ldy;
            xLR += ldx;  yLR += ldy;
        }

        float hdx, hdy, vdx, vdy;
        int cellw, cellh;
        BaseTransform xform = getTransformNoClone();
        float mxt = (float) xform.getMxt();
        float myt = (float) xform.getMyt();
        if (xform.isTranslateOrIdentity()) {
            hdx = dx;  hdy =  dy;
            vdx = dy;  vdy = -dx;
            cellw = (int) Math.ceil(len(xUR - xUL, yUR - yUL));
            cellh = (int) Math.ceil(len(xLL - xUL, yLL - yUL));
            xform = IDENT;
        } else if (xform.is2D()) {
            float mxx = (float) xform.getMxx();
            float mxy = (float) xform.getMxy();
            float myx = (float) xform.getMyx();
            float myy = (float) xform.getMyy();
            float tx, ty;
            tx = mxx * xUL + mxy * yUL;
            ty = myx * xUL + myy * yUL;
            xUL = tx;  yUL = ty;
            tx = mxx * xUR + mxy * yUR;
            ty = myx * xUR + myy * yUR;
            xUR = tx;  yUR = ty;
            tx = mxx * xLL + mxy * yLL;
            ty = myx * xLL + myy * yLL;
            xLL = tx;  yLL = ty;
            tx = mxx * xLR + mxy * yLR;
            ty = myx * xLR + myy * yLR;
            xLR = tx;  yLR = ty;
            // hdx, hdy are transformed unit vectors along the line
            hdx = mxx * dx + mxy * dy;
            hdy = myx * dx + myy * dy;
            float dlen = len(hdx, hdy);
            if (dlen == 0.0f) return true;
            hdx /= dlen;
            hdy /= dlen;
            // vdx, vdy are transformed perpendicular unit vectors
            // (perpendicular to the line in user space, but then transformed)
            vdx = mxx * dy - mxy * dx;
            vdy = myx * dy - myy * dx;
            dlen = len(vdx, vdy);
            if (dlen == 0.0f) return true;
            vdx /= dlen;
            vdy /= dlen;
            cellw = (int) Math.ceil(Math.abs((xUR - xUL) * hdx + (yUR - yUL) * hdy));
            cellh = (int) Math.ceil(Math.abs((xLL - xUL) * vdx + (yLL - yUL) * vdy));
            xform = IDENT;
        } else {
            System.out.println(&quot;Not a 2d transform!&quot;);
            return false;
        }
        hdx *= 0.5f;
        hdy *= 0.5f;
        vdx *= 0.5f;
        vdy *= 0.5f;
        xUL = xUL + mxt + vdx - hdx;
        yUL = yUL + myt + vdy - hdy;
        xUR = xUR + mxt + vdx + hdx;
        yUR = yUR + myt + vdy + hdy;
        xLL = xLL + mxt - vdx - hdx;
        yLL = yLL + myt - vdy - hdy;
        xLR = xLR + mxt - vdx + hdx;
        yLR = yLR + myt - vdy + hdy;
        VertexBuffer vb = context.getVertexBuffer();
        int cellmax = context.getRectTextureMaxSize();
        if (cellh &lt;= cellmax) {
            float v0 = ((cellh * (cellh + 1)) / 2) - 0.5f;
            float v1 = v0 + cellh + 1.0f;
            Texture rTex = context.getRectTexture();
            v0 /= rTex.getPhysicalHeight();
            v1 /= rTex.getPhysicalHeight();
            if (cellw &lt;= cellmax) {
                float u0 = ((cellw * (cellw + 1)) / 2) - 0.5f;
                float u1 = u0 + cellw + 1.0f;
                u0 /= rTex.getPhysicalWidth();
                u1 /= rTex.getPhysicalWidth();
                context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                        bx, by, bw, bh);
                vb.addMappedPgram(xUL, yUL, xUR, yUR, xLL, yLL, xLR, yLR,
                                   u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                                  0, 0);
//                System.out.print(&quot;1&quot;); System.out.flush();
                rTex.unlock();
                return true;
            }
            // long thin line (cellw is along the line, cellh is across it)
            if (cellw &lt;= cellmax * 2 - 1) {
                // 2-slice the line at its midpoint.
                // use the cellmax,cellh cell for maximum coverage of each half
                // we can use at most (cellmax-0.5) per half so that we do not
                // see the antialias drop off on the last half pixel of the far
                // end of the cell.  This lets us support a line of &quot;length&quot; up
                // to (cellmax-0.5 + cellmax-0.5) or (cellmax*2-1).
                float xUC = (xUL + xUR) * 0.5f;
                float yUC = (yUL + yUR) * 0.5f;
                float xLC = (xLL + xLR) * 0.5f;
                float yLC = (yLL + yLR) * 0.5f;
                float u0 = ((cellmax * (cellmax + 1)) / 2) - 0.5f;
                float u1 = u0 + 0.5f + cellw * 0.5f;
                u0 /= rTex.getPhysicalWidth();
                u1 /= rTex.getPhysicalWidth();
                context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                        bx, by, bw, bh);
                // first half of line x1,y1 -&gt; midpoint
                vb.addMappedPgram(xUL, yUL, xUC, yUC, xLL, yLL, xLC, yLC,
                                   u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                                  0, 0);
                // second half of line midpoint -&gt; x2,y2
                vb.addMappedPgram(xUR, yUR, xUC, yUC, xLR, yLR, xLC, yLC,
                                   u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                                  0, 0);
//                System.out.print(&quot;2&quot;); System.out.flush();
                rTex.unlock();
                return true;
            }
            // Finally, 3-slice the line (left edge, huge middle, right edge)
            float u0 = 0.5f / rTex.getPhysicalWidth();
            float u1 = 1.5f / rTex.getPhysicalWidth();
            // The lower case L or R indicates &quot;inner left&quot; or &quot;inner right&quot;
            hdx *= 2.0f;
            hdy *= 2.0f;
            float xUl = xUL + hdx;
            float yUl = yUL + hdy;
            float xUr = xUR - hdx;
            float yUr = yUR - hdy;
            float xLl = xLL + hdx;
            float yLl = yLL + hdy;
            float xLr = xLR - hdx;
            float yLr = yLR - hdy;
            context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                    bx, by, bw, bh);
            // first pixel of line x1,y1 -&gt; x1,y1+pixel
            vb.addMappedPgram(xUL, yUL, xUl, yUl, xLL, yLL, xLl, yLl,
                               u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                              0, 0);
            // middle part of line x1,y1+pixel -&gt; x2,y2-pixel
            vb.addMappedPgram(xUl, yUl, xUr, yUr, xLl, yLl, xLr, yLr,
                               u1,  v0,  u1,  v0,  u1,  v1,  u1,  v1,
                              0, 0);
            // last part of line x2,y2-pixel -&gt; x2,y2
            vb.addMappedPgram(xUr, yUr, xUR, yUR, xLr, yLr, xLR, yLR,
                               u1,  v0,  u0,  v0,  u1,  v1,  u0,  v1,
                              0, 0);
//            System.out.print(&quot;3&quot;); System.out.flush();
            rTex.unlock();
            return true;
        }
        // we could 2 and 3 slice extremely wide short lines, but they
        // are very rare in practice so we just jump straight to a
        // standard 4-slice off of the wrap-rect texture
        float xUC = (xUL + xUR) * 0.5f;
        float yUC = (yUL + yUR) * 0.5f;
        float xLC = (xLL + xLR) * 0.5f;
        float yLC = (yLL + yLR) * 0.5f;
        float xCL = (xUL + xLL) * 0.5f;
        float yCL = (yUL + yLL) * 0.5f;
        float xCR = (xUR + xLR) * 0.5f;
        float yCR = (yUR + yLR) * 0.5f;
        float xCC = (xUC + xLC) * 0.5f;
        float yCC = (yUC + yLC) * 0.5f;
        Texture rTex = context.getWrapRectTexture();
        float u0 = 0.5f / rTex.getPhysicalWidth();
        float v0 = 0.5f / rTex.getPhysicalHeight();
        float uc = (cellw * 0.5f + 1.0f) / rTex.getPhysicalWidth();
        float vc = (cellh * 0.5f + 1.0f) / rTex.getPhysicalHeight();
        context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                bx, by, bw, bh);
        vb.addMappedPgram(xUL, yUL, xUC, yUC, xCL, yCL, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
        vb.addMappedPgram(xUR, yUR, xUC, yUC, xCR, yCR, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
        vb.addMappedPgram(xLL, yLL, xLC, yLC, xCL, yCL, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
        vb.addMappedPgram(xLR, yLR, xLC, yLC, xCR, yCR, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
//        System.out.print(&quot;4&quot;); System.out.flush();
        rTex.unlock();
        return true;
    }

    public void fillRect(float x, float y, float w, float h) {
        if (w &lt;= 0 || h &lt;= 0) {
            return;
        }
        if (!isAntialiasedShape()) {
           fillQuad(x, y, x + w, y + h);
           return;
        }
        if (isComplexPaint) {
            scratchRRect.setRoundRect(x, y, w, h, 0, 0);
            renderWithComplexPaint(scratchRRect, null, x, y, w, h);
            return;
        }
        if (PrismSettings.primTextureSize != 0) {
            Texture rTex = context.getRectTexture();
            Texture wTex = context.getWrapRectTexture();
            boolean success = fillPrimRect(x, y, w, h, rTex, wTex, x, y, w, h);
            rTex.unlock();
            wTex.unlock();
            if (success) return;
        }
        renderGeneralRoundedRect(x, y, w, h, 0f, 0f,
                                 MaskType.FILL_PGRAM, null);
    }

    public void fillEllipse(float x, float y, float w, float h) {
        if (w &lt;= 0 || h &lt;= 0) {
            return;
        }
        if (isComplexPaint) {
            scratchEllipse.setFrame(x, y, w, h);
            renderWithComplexPaint(scratchEllipse, null, x, y, w, h);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchEllipse.setFrame(x, y, w, h);
            renderShape(scratchEllipse, null, x, y, w, h);
            return;
        }
        if (PrismSettings.primTextureSize != 0) {
            if (fillPrimRect(x, y, w, h,
                             context.getOvalTexture(),
                             null,
                             x, y, w, h))
            {
                return;
            }
        }
        renderGeneralRoundedRect(x, y, w, h, w, h,
                                 MaskType.FILL_ELLIPSE, null);
    }

    public void fillRoundRect(float x, float y, float w, float h,
                              float arcw, float arch)
    {
        arcw = Math.min(Math.abs(arcw), w);
        arch = Math.min(Math.abs(arch), h);

        if (w &lt;= 0 || h &lt;= 0) {
            return;
        }
        if (isComplexPaint) {
            scratchRRect.setRoundRect(x, y, w, h, arcw, arch);
            renderWithComplexPaint(scratchRRect, null, x, y, w, h);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchRRect.setRoundRect(x, y, w, h, arcw, arch);
            renderShape(scratchRRect, null, x, y, w, h);
            return;
        }
        renderGeneralRoundedRect(x, y, w, h, arcw, arch,
                                 MaskType.FILL_ROUNDRECT, null);
    }

    public void fillQuad(float x1, float y1, float x2, float y2) {
        float bx, by, bw, bh;
        if (x1 &lt;= x2) {
            bx = x1;
            bw = x2 - x1;
        } else {
            bx = x2;
            bw = x1 - x2;
        }
        if (y1 &lt;= y2) {
            by = y1;
            bh = y2 - y1;
        } else {
            by = y2;
            bh = y1 - y2;
        }

        if (isComplexPaint) {
            scratchRRect.setRoundRect(bx, by, bw, bh, 0, 0);
            renderWithComplexPaint(scratchRRect, null, bx, by, bw, bh);
            return;
        }

        BaseTransform xform = getTransformNoClone();
        if (PrismSettings.primTextureSize != 0) {
            float mxt, myt;
            if (xform.isTranslateOrIdentity()) {
                mxt = (float) xform.getMxt();
                myt = (float) xform.getMyt();
                xform = IDENT;
                x1 += mxt;
                y1 += myt;
                x2 += mxt;
                y2 += myt;
            } else {
                mxt = myt = 0.0f;
            }
            Shader shader =
                context.validatePaintOp(this, xform, MaskType.ALPHA_ONE, null,
                                        bx, by, bw, bh);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
            if (paintTx != null) {
                paintTx.translate(-mxt, -myt);
            }
            context.getVertexBuffer().addQuad(x1, y1, x2, y2, 0, 0, 0, 0, paintTx);
            return;
        }
        if (isSimpleTranslate) {
            xform = IDENT;
            bx += transX;
            by += transY;
        }
        context.validatePaintOp(this, xform, MaskType.SOLID, bx, by, bw, bh);

        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(bx, by, bx+bw, by+bh);
    }

    private static final double SQRT_2 = Math.sqrt(2.0);
    private static boolean canUseStrokeShader(BasicStroke bs) {
        // RT-27378
        // TODO: Expand the cases that renderGeneralRoundRect() can handle...
        return (!bs.isDashed() &amp;&amp;
                (bs.getType() == BasicStroke.TYPE_INNER ||
                 bs.getLineJoin() == BasicStroke.JOIN_ROUND ||
                 (bs.getLineJoin() == BasicStroke.JOIN_MITER &amp;&amp;
                  bs.getMiterLimit() &gt;= SQRT_2)));
    }

    public void blit(RTTexture srcTex, RTTexture dstTex,
                     int srcX0, int srcY0, int srcX1, int srcY1,
                     int dstX0, int dstY0, int dstX1, int dstY1) {
        if (dstTex == null) {
            context.setRenderTarget(this);
        } else {
            context.setRenderTarget((BaseGraphics)dstTex.createGraphics());
        }
        context.blit(srcTex, dstTex, srcX0, srcY0, srcX1, srcY1,
                dstX0, dstY0, dstX1, dstY1);
    }

    public void drawRect(float x, float y, float w, float h) {
        if (w &lt; 0 || h &lt; 0) {
            return;
        }
        if (w == 0 || h == 0) {
            drawLine(x, y, x + w, y + h);
            return;
        }
        if (isComplexPaint) {
            scratchRRect.setRoundRect(x, y, w, h, 0, 0);
            renderWithComplexPaint(scratchRRect, stroke, x, y, w, h);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchRRect.setRoundRect(x, y, w, h, 0, 0);
            renderShape(scratchRRect, stroke, x, y, w, h);
            return;
        }
        if (canUseStrokeShader(stroke)) {
            if (PrismSettings.primTextureSize != 0 &amp;&amp;
                stroke.getLineJoin() != BasicStroke.CAP_ROUND)
            {
                if (drawPrimRect(x, y, w, h)) {
                    return;
                }
            }
            renderGeneralRoundedRect(x, y, w, h, 0f, 0f,
                                     MaskType.DRAW_PGRAM, stroke);
            return;
        }
        scratchRRect.setRoundRect(x, y, w, h, 0, 0);
        renderShape(scratchRRect, stroke, x, y, w, h);
    }

    private boolean checkInnerCurvature(float arcw, float arch) {
        // Test to see if inner ellipse satisfies (flattening &lt; 0.5)
        // otherwise it will not be approximated by a &quot;parallel ellipse&quot;
        // very well and we should just use shape rendering.

        // RT-27378
        // TODO: Implement better &quot;distance to ellipse&quot; formulas in the shaders
        float inset = stroke.getLineWidth() *
            (1f - getStrokeExpansionFactor(stroke));
        arcw -= inset;
        arch -= inset;
        // Note that if either inset arcw,h go to &lt;= 0 then we will invoke the
        // fill primitive for ellipse, or the round rect primitive will
        // invoke its &quot;tiny inner corner&quot; fixes and we will be safe
        return (arcw &lt;= 0 || arch &lt;= 0 ||
                (arcw * 2f &gt; arch &amp;&amp; arch * 2f &gt; arcw));
    }

    public void drawEllipse(float x, float y, float w, float h) {
        if (w &lt; 0 || h &lt; 0) {
            return;
        }
        if (!isComplexPaint &amp;&amp; !stroke.isDashed() &amp;&amp;
            checkInnerCurvature(w, h) &amp;&amp; isAntialiasedShape())
        {
            renderGeneralRoundedRect(x, y, w, h, w, h,
                                     MaskType.DRAW_ELLIPSE, stroke);
            return;
        }
        scratchEllipse.setFrame(x, y, w, h);
        renderShape(scratchEllipse, stroke, x, y, w, h);
    }

    public void drawRoundRect(float x, float y, float w, float h,
                              float arcw, float arch)
    {
        arcw = Math.min(Math.abs(arcw), w);
        arch = Math.min(Math.abs(arch), h);

        if (w &lt; 0 || h &lt; 0) {
            return;
        }
        if (!isComplexPaint &amp;&amp; !stroke.isDashed() &amp;&amp;
            checkInnerCurvature(arcw, arch) &amp;&amp; isAntialiasedShape())
        {
            renderGeneralRoundedRect(x, y, w, h, arcw, arch,
                                     MaskType.DRAW_ROUNDRECT, stroke);
            return;
        }
        scratchRRect.setRoundRect(x, y, w, h, arcw, arch);
        renderShape(scratchRRect, stroke, x, y, w, h);
    }

    public void drawLine(float x1, float y1, float x2, float y2) {
        float bx, by, bw, bh;
        if (x1 &lt;= x2) {
            bx = x1;
            bw = x2 - x1;
        } else {
            bx = x2;
            bw = x1 - x2;
        }
        if (y1 &lt;= y2) {
            by = y1;
            bh = y2 - y1;
        } else {
            by = y2;
            bh = y1 - y2;
        }

        // RT-27378
        // TODO: casting down to floats everywhere here; evaluate later
        // to see if this is enough precision...
        // TODO: stroke normalization control?
        if (stroke.getType() == BasicStroke.TYPE_INNER) {
            return;
        }
        if (isComplexPaint) {
            scratchLine.setLine(x1, y1, x2, y2);
            renderWithComplexPaint(scratchLine, stroke, bx, by, bw, bh);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchLine.setLine(x1, y1, x2, y2);
            renderShape(scratchLine, stroke, bx, by, bw, bh);
            return;
        }
        int cap = stroke.getEndCap();
        if (stroke.isDashed()) {
            // NOTE: we could construct the GeneralPath directly
            // for CAP_ROUND and save a lot of processing in that case...
            // And again, we would need to deal with dropout control...
            scratchLine.setLine(x1, y1, x2, y2);
            renderShape(scratchLine, stroke, bx, by, bw, bh);
            return;
        }
        float lw = stroke.getLineWidth();
        if (PrismSettings.primTextureSize != 0 &amp;&amp;
            cap != BasicStroke.CAP_ROUND)
        {
            float pad = lw;
            if (stroke.getType() == BasicStroke.TYPE_CENTERED) {
                pad *= 0.5f;
            }
            if (bw == 0.0f || bh == 0.0f) {
                float padx, pady;
                if (cap == BasicStroke.CAP_SQUARE) {
                    // CAP_SQUARE pads the same on all sides
                    padx = pady = pad;
//                    System.out.print(&quot;S&quot;); System.out.flush();
                } else if (bw != 0.0f) {
                    // Horizontal CAP_BUTT line - widen vertically
                    padx = 0.0f;
                    pady = pad;
//                    System.out.print(&quot;H&quot;); System.out.flush();
                } else if (bh != 0.0f) {
                    // Vertical CAP_BUTT line - widen horizontally
                    padx = pad;
                    pady = 0.0f;
//                    System.out.print(&quot;V&quot;); System.out.flush();
                } else {
//                    System.out.print(&quot;0&quot;); System.out.flush();
                    // Zero length line - NOP for CAP_BUTT
                    return;
                }
                Texture rTex = context.getRectTexture();
                Texture wTex = context.getWrapRectTexture();
                boolean success = fillPrimRect(bx - padx,        by - pady,
                                               bw + padx + padx, bh + pady + pady,
                                               rTex, wTex, bx, by, bw, bh);
                rTex.unlock();
                wTex.unlock();
                if (success) return;
            } else {
                if (drawPrimDiagonal(x1, y1, x2, y2, lw, cap,
                                     bx, by, bw, bh))
                {
                    return;
                }
            }
        }
//        System.out.print(&quot;#&quot;); System.out.flush();
        if (stroke.getType() == BasicStroke.TYPE_OUTER) {
            lw *= 2f;
        }
        float dx = x2 - x1;
        float dy = y2 - y1;
        float len = len(dx, dy);
        float ldx, ldy;  // lw length vector in direction of line in user space
        if (len == 0) {
            if (cap == BasicStroke.CAP_BUTT) {
                return;
            }
            ldx = lw;
            ldy = 0;
        } else {
            ldx = lw * dx / len;
            ldy = lw * dy / len;
        }
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        BaseTransform rendertx;
        float pdx, pdy;  // ldx,ldy rotated 90 in user space then transformed
        if (isSimpleTranslate) {
            double tx = xform.getMxt();
            double ty = xform.getMyt();
            x1 += tx;
            y1 += ty;
            x2 += tx;
            y2 += ty;
            pdx = ldy;
            pdy = -ldx;
            rendertx = IDENT;
        } else {
            rendertx = extract3Dremainder(xform);
            double coords[] = {x1, y1, x2, y2};
            xform.transform(coords, 0, coords, 0, 2);
            x1 = (float)coords[0];
            y1 = (float)coords[1];
            x2 = (float)coords[2];
            y2 = (float)coords[3];
            dx = x2 - x1;
            dy = y2 - y1;
            coords[0] = ldx;
            coords[1] = ldy;
            coords[2] = ldy;
            coords[3] = -ldx;
            xform.deltaTransform(coords, 0, coords, 0, 2);
            ldx = (float) coords[0];
            ldy = (float) coords[1];
            pdx = (float) coords[2];
            pdy = (float) coords[3];
        }
        float px = x1 - pdx / 2f;
        float py = y1 - pdy / 2f;
        float arcfractw, arcfracth;
        MaskType type;
        if (cap != BasicStroke.CAP_BUTT) {
            px -= ldx / 2f;
            py -= ldy / 2f;
            dx += ldx;
            dy += ldy;
            if (cap == BasicStroke.CAP_ROUND) {
                arcfractw = len(ldx, ldy) / len(dx, dy);
                arcfracth = 1f;
                type = MaskType.FILL_ROUNDRECT;
            } else {
                arcfractw = arcfracth = 0f;
                type = MaskType.FILL_PGRAM;
            }
        } else {
            arcfractw = arcfracth = 0f;
            type = MaskType.FILL_PGRAM;
        }
        renderGeneralRoundedPgram(px, py, dx, dy, pdx, pdy,
                                  arcfractw, arcfracth, 0f, 0f,
                                  rendertx, type,
                                  bx, by, bw, bh);
    }

    private static float len(float x, float y) {
        return ((x == 0f) ? Math.abs(y)
                : ((y == 0f) ? Math.abs(x)
                   : (float)Math.sqrt(x * x + y * y)));
    }

    private boolean lcdSampleInvalid = false;

    public void setNodeBounds(RectBounds bounds) {
        nodeBounds = bounds;
        lcdSampleInvalid = bounds != null;
    }

    private void initLCDSampleRT() {
        if (lcdSampleInvalid) {
            RectBounds textBounds = new RectBounds();
            getTransformNoClone().transform(nodeBounds, textBounds);
            Rectangle clipRect = getClipRectNoClone();
            if (clipRect != null &amp;&amp; !clipRect.isEmpty()) {
                // Reduce sample area if there is any clipping bounds set
                textBounds.intersectWith(clipRect);
            }
            // LCD mixing with background will often lead to extra pixel at edge
            // thus adding a single pixel, as padding, at edges and bottom.
            float bx = textBounds.getMinX() - 1.0f;
            float by = textBounds.getMinY() - 1.0f;
            float bw = textBounds.getWidth() + 2.0f;
            float bh = textBounds.getHeight() + 2.0f;

            context.validateLCDBuffer(getRenderTarget());

            // Create a graphics for us to render into the LCDBuffer
            // Note this also sets the current RenderTarget as the LCDBuffer
            BaseShaderGraphics bsg = (BaseShaderGraphics) context.getLCDBuffer().createGraphics();
            bsg.setCompositeMode(CompositeMode.SRC);
            context.validateLCDOp(bsg, IDENT, (Texture) getRenderTarget(), null, true, null);

            int srch = getRenderTarget().getPhysicalHeight();
            int srcw = getRenderTarget().getPhysicalWidth();
            float tx1 = bx / srcw;
            float ty1 = by / srch;
            float tx2 = (bx + bw) / srcw;
            float ty2 = (by + bh) / srch;

            //sample the source RT in the following bounds and store it in the LCDBuffer RT.
            bsg.drawLCDBuffer(bx, by, bw, bh, tx1, ty1, tx2, ty2);
            context.setRenderTarget(this);
        }
        lcdSampleInvalid = false;
    }

    public void drawString(GlyphList gl, FontStrike strike, float x, float y,
                           Color selectColor, int selectStart, int selectEnd) {

        if (isComplexPaint ||
            paint.getType().isImagePattern() ||
            strike.drawAsShapes())
        {
            // FontStrike.drawAsShapes() may be true for very large font sizes
            // in which case so no glyph images are cached.
            // The Prism Text node handles such cases directly, but Webnode relies
            // upon Prism's drawString method, so we need to handle it here too.

            // this is not a very optimal approach and may not hit exactly
            // the same pixels that we would hit in the case where the
            // glyph cache is used, but the complex paint case is not
            // common enough to warrant further optimization
            BaseTransform xform = BaseTransform.getTranslateInstance(x, y);
            Shape shape = strike.getOutline(gl, xform);
            fill(shape);
            return;
        }

        BaseTransform xform = getTransformNoClone();

        Paint textPaint = getPaint();
        Color textColor = textPaint.getType() == Paint.Type.COLOR ?
                          (Color) textPaint : null;

        CompositeMode blendMode = getCompositeMode();
        // LCD support requires several attributes to function:
        // FontStrike supports LCD, SRC_OVER CompositeMode and Paint is a COLOR
        boolean lcdSupported = blendMode == CompositeMode.SRC_OVER &amp;&amp;
                               textColor != null &amp;&amp;
                               xform.is2D() &amp;&amp;
                               !getRenderTarget().isMSAA();

        /* If the surface can't support LCD text we need to replace an
         * LCD mode strike with the equivalent grey scale one.
         */
        if (strike.getAAMode() == FontResource.AA_LCD &amp;&amp; !lcdSupported) {
            FontResource fr = strike.getFontResource();
            float size = strike.getSize();
            BaseTransform tx = strike.getTransform();
            strike = fr.getStrike(size, tx, FontResource.AA_GREYSCALE);
        }

        float bx = 0f, by = 0f, bw = 0f, bh = 0f;
        if (paint.getType().isGradient() &amp;&amp; ((Gradient)paint).isProportional()) {
            // If drawString is called directly without using setNodeBounds,
            // then nodeBounds is null, and we must determine the bounds based
            // on the str(vs. the node).
            RectBounds textBounds = nodeBounds;
            if (textBounds == null) {
                Metrics m = strike.getMetrics();
                float pad = -m.getAscent() * 0.4f;
                textBounds = new RectBounds(-pad,
                                            m.getAscent(),
                                            gl.getWidth() + 2.0f *pad,
                                            m.getDescent() + m.getLineGap());
                bx = x;
                by = y;
            }

            bx += textBounds.getMinX();
            by += textBounds.getMinY();
            bw = textBounds.getWidth();
            bh = textBounds.getHeight();
        }

        BaseBounds clip = null;
        Point2D p2d = new Point2D(x, y);
        if (isSimpleTranslate) {
            /* Only use clip for simple transforms so that coordinates in the
             * glyph list (user space) and the coordinates of the clip
             * (device space) can be intersected.
             */
            clip = getFinalClipNoClone();
            xform = IDENT;
            p2d.x += transX;
            p2d.y += transY;
        }

        /* Cache look up needs to be on the font as rendered, including
         * AA mode, metrics mode, glyph transform (pt size combined with
         * the full graphics transform). Most of this info is expected to
         * be in the font, which here is close to being a full strike
         * description.
         */
        GlyphCache glyphCache = context.getGlyphCache(strike);
        Texture cacheTex = glyphCache.getBackingStore();

        //Since we currently cannot support LCD text on transparant surfaces, we
        //verify that we are drawing to an opaque surface.
        if (strike.getAAMode() == FontResource.AA_LCD) {
            if (nodeBounds == null) {
                // If drawString is called directly without using
                // setNodeBounds then we must determine the bounds of the str,
                // before we render background to texture.
                // This is slow, but required by webnode.

                Metrics m = strike.getMetrics();
                // Ruff guess for padding, since lots of glyphs exceed advance
                RectBounds textBounds =
                        new RectBounds(x - 2,
                                       y + m.getAscent(),
                                       x + 2 + gl.getWidth(),
                                       y + 1 + m.getDescent() + m.getLineGap());

                setNodeBounds(textBounds);
                initLCDSampleRT();
                setNodeBounds(null);
            } else {
                initLCDSampleRT();
            }
            float invgamma = PrismFontFactory.getLCDContrast();
            float gamma = 1.0f/invgamma;
            textColor = new Color((float)Math.pow(textColor.getRed(),   invgamma),
                                  (float)Math.pow(textColor.getGreen(), invgamma),
                                  (float)Math.pow(textColor.getBlue(),  invgamma),
                                  (float)Math.pow(textColor.getAlpha(), invgamma));
            if (selectColor != null) {
                selectColor = new Color(
                        (float)Math.pow(selectColor.getRed(),   invgamma),
                        (float)Math.pow(selectColor.getGreen(), invgamma),
                        (float)Math.pow(selectColor.getBlue(),  invgamma),
                        (float)Math.pow(selectColor.getAlpha(), invgamma));
            }

            // In order to handle transparency, the LCD shader need to manually
            // composite source with destination. Thus, SRC_OVER compositing
            // needs to be set to SRC, while shader is active.
            setCompositeMode(CompositeMode.SRC);

            //set our 2nd LCD shader.
            Shader shader = context.validateLCDOp(this, IDENT,
                                                context.getLCDBuffer(),
                                                cacheTex, false, textColor);

            float unitXCoord = 1.0f/((float)cacheTex.getPhysicalWidth());
            shader.setConstant(&quot;gamma&quot;, gamma, invgamma, unitXCoord);
            setCompositeMode(blendMode); // Restore composite mode
        } else {
            context.validatePaintOp(this, IDENT, cacheTex, bx, by, bw, bh);
        }
        if (isSimpleTranslate) {
            // Applying this rounding allows for smoother text animation,
            // when animating simple translated text.
            // Asking glyph textures to be rendered at non-integral
            // locations produces very poor text. This doesn't solve
            // the problem for scaled (etc) cases, but addresses a
            // common case.
            p2d.y = Math.round(p2d.y);
            p2d.x = Math.round(p2d.x);
        }
        glyphCache.render(context, gl, p2d.x, p2d.y, selectStart, selectEnd,
                          selectColor, textColor, xform, clip);
    }

    //This function is used by the LCD path to render a quad into the
    //LCD RTT Texture. here the presentable is set as input and
    //sampled using texture coordinates. This is later used in a
    //second pass to provide the dst color as input.
    private void drawLCDBuffer(float bx, float by, float bw, float bh,
            float tx1, float ty1, float tx2, float ty2)
    {
        context.setRenderTarget(this);
        context.getVertexBuffer().addQuad(bx, by, bx + bw, by + bh, tx1, ty1, tx2, ty2);
    }

    public boolean canReadBack() {
        RenderTarget rt = getRenderTarget();
        return rt instanceof ReadbackRenderTarget &amp;&amp;
            ((ReadbackRenderTarget) rt).getBackBuffer() != null;
    }

    public RTTexture readBack(Rectangle view) {
        RenderTarget rt = getRenderTarget();
        context.flushVertexBuffer();
        context.validateLCDBuffer(rt);
        RTTexture lcdrtt = context.getLCDBuffer();
        Texture bbtex = ((ReadbackRenderTarget) rt).getBackBuffer();

        float x1 = view.x;
        float y1 = view.y;
        float x2 = x1 + view.width;
        float y2 = y1 + view.height;

        // Create a graphics for us to render into the LCDBuffer
        // Note this also sets the current RenderTarget as the LCDBuffer
        BaseShaderGraphics bsg = (BaseShaderGraphics) lcdrtt.createGraphics();
        bsg.setCompositeMode(CompositeMode.SRC);
        context.validateTextureOp(bsg, IDENT, bbtex, bbtex.getPixelFormat());

        // sample the source RT in the following bounds and store it in the LCDBuffer RT.
        bsg.drawTexture(bbtex, 0, 0, view.width, view.height, x1, y1, x2, y2);
        context.flushVertexBuffer();

        // set the RenderTarget back to this.
        context.setRenderTarget(this);
        return lcdrtt;
    }

    public void releaseReadBackBuffer(RTTexture rtt) {
        // This will be needed when we track LCD buffer locks and uses.
        // (See RT-29488)
//        context.releaseLCDBuffer();
    }

    public void setup3DRendering() {
        context.setRenderTarget(this);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/J2DPrismGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d;

import java.awt.LinearGradientPaint;
import java.awt.font.GlyphVector;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.lang.ref.WeakReference;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import com.sun.glass.ui.Screen;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.font.CompositeGlyphMapper;
import com.sun.javafx.font.CompositeStrike;
import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NodePath;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.MaskTextureGraphics;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.j2d.paint.MultipleGradientPaint.ColorSpaceType;
import com.sun.prism.j2d.paint.RadialGradientPaint;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.paint.Stop;
import static java.awt.RenderingHints.KEY_ANTIALIASING;
import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_OFF;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;
import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;
import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;

public class J2DPrismGraphics
    // Do not subclass BaseGraphics without fixing drawTextureVO below...
    implements ReadbackGraphics, MaskTextureGraphics
    // Do not implement RectShadowGraphics without fixing RT-15016 (note that
    // BaseGraphics implements RectShadowGraphics).
{
    static {
        // Assuming direct translation of BasicStroke enums:
        assert(com.sun.prism.BasicStroke.CAP_BUTT == java.awt.BasicStroke.CAP_BUTT);
        assert(com.sun.prism.BasicStroke.CAP_ROUND == java.awt.BasicStroke.CAP_ROUND);
        assert(com.sun.prism.BasicStroke.CAP_SQUARE == java.awt.BasicStroke.CAP_SQUARE);
        assert(com.sun.prism.BasicStroke.JOIN_BEVEL == java.awt.BasicStroke.JOIN_BEVEL);
        assert(com.sun.prism.BasicStroke.JOIN_MITER == java.awt.BasicStroke.JOIN_MITER);
        assert(com.sun.prism.BasicStroke.JOIN_ROUND == java.awt.BasicStroke.JOIN_ROUND);
        // Assuming direct translation of PathIterator enums:
        assert(com.sun.javafx.geom.PathIterator.WIND_EVEN_ODD == java.awt.geom.PathIterator.WIND_EVEN_ODD);
        assert(com.sun.javafx.geom.PathIterator.WIND_NON_ZERO == java.awt.geom.PathIterator.WIND_NON_ZERO);
        assert(com.sun.javafx.geom.PathIterator.SEG_MOVETO == java.awt.geom.PathIterator.SEG_MOVETO);
        assert(com.sun.javafx.geom.PathIterator.SEG_LINETO == java.awt.geom.PathIterator.SEG_LINETO);
        assert(com.sun.javafx.geom.PathIterator.SEG_QUADTO == java.awt.geom.PathIterator.SEG_QUADTO);
        assert(com.sun.javafx.geom.PathIterator.SEG_CUBICTO == java.awt.geom.PathIterator.SEG_CUBICTO);
        assert(com.sun.javafx.geom.PathIterator.SEG_CLOSE == java.awt.geom.PathIterator.SEG_CLOSE);
    }
    static final LinearGradientPaint.CycleMethod LGP_CYCLE_METHODS[] = {
        LinearGradientPaint.CycleMethod.NO_CYCLE,
        LinearGradientPaint.CycleMethod.REFLECT,
        LinearGradientPaint.CycleMethod.REPEAT,
    };
    static final RadialGradientPaint.CycleMethod RGP_CYCLE_METHODS[] = {
        RadialGradientPaint.CycleMethod.NO_CYCLE,
        RadialGradientPaint.CycleMethod.REFLECT,
        RadialGradientPaint.CycleMethod.REPEAT,
    };

    private static final BasicStroke DEFAULT_STROKE =
        new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f);
    private static final Paint DEFAULT_PAINT = Color.WHITE;
    static java.awt.geom.AffineTransform J2D_IDENTITY =
        new java.awt.geom.AffineTransform();
    private int clipRectIndex;
    private boolean hasPreCullingBits = false;
    private float pixelScaleX = 1.0f;
    private float pixelScaleY = 1.0f;

    static java.awt.Color toJ2DColor(Color c) {
        return new java.awt.Color(c.getRed(),
                                  c.getGreen(),
                                  c.getBlue(),
                                  c.getAlpha());
    }

    /*
     * Ensure that no fractions are equal
     *
     * Note that the J2D objects reject equal fractions, but the FX versions
     * allow them.
     *
     * The FX version treats values with equal fractions such that as you
     * approach the fractional value from below it interpolates to the
     * first color associated with that fraction and as you interpolate
     * away from it from above it interpolates the last such color.
     *
     * To get the J2D version to exhibit the FX behavior we collapse all
     * adjacent fractional values into a pair of values that are stored
     * with a pair of immediately adjacent floating point values.  This way
     * they have unique fractions, but no fractional value can be generated
     * which fits between them.  Yet, as you approach from below it will
     * interpolate to the first of the pair of colors and as you move away
     * above it, the second value will take precedence for interpolation.
     *
     * Math.ulp() is used to generate an &quot;immediately adjacent fp value&quot;.
     */
    static int fixFractions(float fractions[], java.awt.Color colors[]) {
        float fprev = fractions[0];
        int i = 1;  // index of next incoming color/fractions we will examine
        int n = 1;  // index of next outgoing color/fraction we will store
        while (i &lt; fractions.length) {
            float f = fractions[i];
            java.awt.Color c = colors[i++];
            if (f &lt;= fprev) {
                // If we find any duplicates after we reach 1.0 we can
                // just ignore the rest of the array.  Not only is there
                // no more &quot;fraction room&quot; to assign them to, but we will
                // never generate a fraction &gt;1.0 to access them anyway
                if (f &gt;= 1.0f) break;
                // Find all fractions that are either fprev or fprev+ulp
                // and collapse them into two entries, the first at fprev
                // which is already stored, and the last matching entry
                // will be stored with fraction fprev+ulp
                f = fprev + Math.ulp(fprev);
                while (i &lt; fractions.length) {
                    if (fractions[i] &gt; f) break;
                    // We continue to remember the color of the last
                    // &quot;matching&quot; entry so it can be stored below
                    c = colors[i++];
                }
            }
            fractions[n] = fprev = f;
            colors[n++] = c;
        }
        return n;
    }

    java.awt.Paint toJ2DPaint(Paint p, java.awt.geom.Rectangle2D b) {
        if (p instanceof Color) {
            return toJ2DColor((Color) p);
        } else if (p instanceof Gradient) {
            Gradient g = (Gradient) p;
            if (g.isProportional()) {
                if (b == null) {
                    return null;
                }
            }
            List&lt;Stop&gt; stops = g.getStops();
            int n = stops.size();
            float fractions[] = new float[n];
            java.awt.Color colors[] = new java.awt.Color[n];
            float prevf = -1f;
            boolean needsFix = false;
            for (int i = 0; i &lt; n; i++) {
                Stop stop = stops.get(i);
                float f = stop.getOffset();
                needsFix = (needsFix || f &lt;= prevf);
                fractions[i] = prevf = f;
                colors[i] = toJ2DColor(stop.getColor());
            }
            if (needsFix) {
                n = fixFractions(fractions, colors);
                if (n &lt; fractions.length) {
                    float newf[] = new float[n];
                    System.arraycopy(fractions, 0, newf, 0, n);
                    fractions = newf;
                    java.awt.Color newc[] = new java.awt.Color[n];
                    System.arraycopy(colors, 0, newc, 0, n);
                    colors = newc;
                }
            }
            if (g instanceof LinearGradient) {
                LinearGradient lg = (LinearGradient) p;
                float x1 = lg.getX1();
                float y1 = lg.getY1();
                float x2 = lg.getX2();
                float y2 = lg.getY2();
                if (g.isProportional()) {
                    float x = (float) b.getX();
                    float y = (float) b.getY();
                    float w = (float) b.getWidth();
                    float h = (float) b.getHeight();
                    x1 = x + w * x1;
                    y1 = y + h * y1;
                    x2 = x + w * x2;
                    y2 = y + h * y2;
                }
                if (x1 == x2 &amp;&amp; y1 == y2) {
                    // Hardware pipelines use an inverse transform of
                    // all zeros to choose colors when the start and end
                    // point are the same so that the first color is
                    // always chosen...
                    return colors[0];
                }
                java.awt.geom.Point2D p1 =
                    new java.awt.geom.Point2D.Float(x1, y1);
                java.awt.geom.Point2D p2 =
                    new java.awt.geom.Point2D.Float(x2, y2);
                LinearGradientPaint.CycleMethod method =
                    LGP_CYCLE_METHODS[g.getSpreadMethod()];
                return new LinearGradientPaint(p1, p2, fractions, colors, method);
            } else if (g instanceof RadialGradient) {
                RadialGradient rg = (RadialGradient) g;
                float cx = rg.getCenterX();
                float cy = rg.getCenterY();
                float r = rg.getRadius();
                double fa = Math.toRadians(rg.getFocusAngle());
                float fd = rg.getFocusDistance();
                java.awt.geom.AffineTransform at = J2D_IDENTITY;
                if (g.isProportional()) {
                    float x = (float) b.getX();
                    float y = (float) b.getY();
                    float w = (float) b.getWidth();
                    float h = (float) b.getHeight();
                    float dim = Math.min(w, h);
                    float bcx = x + w * 0.5f;
                    float bcy = y + h * 0.5f;
                    cx = bcx + (cx - 0.5f) * dim;
                    cy = bcy + (cy - 0.5f) * dim;
                    r *= dim;
                    if (w != h &amp;&amp; w != 0.0 &amp;&amp; h != 0.0) {
                        at = java.awt.geom.AffineTransform.getTranslateInstance(bcx, bcy);
                        at.scale(w / dim, h / dim);
                        at.translate(-bcx, -bcy);
                    }
                }
                java.awt.geom.Point2D center =
                    new java.awt.geom.Point2D.Float(cx, cy);
                float fx = (float) (cx + fd * r * Math.cos(fa));
                float fy = (float) (cy + fd * r * Math.sin(fa));
                java.awt.geom.Point2D focus =
                    new java.awt.geom.Point2D.Float(fx, fy);
                RadialGradientPaint.CycleMethod method =
                    RGP_CYCLE_METHODS[g.getSpreadMethod()];
                return new RadialGradientPaint(center, r, focus, fractions, colors,
                                               method, ColorSpaceType.SRGB, at);
            }
        } else if (p instanceof ImagePattern) {
            ImagePattern imgpat = (ImagePattern) p;
            float x = imgpat.getX();
            float y = imgpat.getY();
            float w = imgpat.getWidth();
            float h = imgpat.getHeight();
            if (p.isProportional()) {
                if (b == null) {
                    return null;
                }
                float bx = (float) b.getX();
                float by = (float) b.getY();
                float bw = (float) b.getWidth();
                float bh = (float) b.getHeight();
                w += x;
                h += y;
                x = bx + x * bw;
                y = by + y * bh;
                w = bx + w * bw;
                h = by + h * bh;
                w -= x;
                h -= y;
            }
            Texture tex =
                getResourceFactory().getCachedTexture(imgpat.getImage(), WrapMode.REPEAT);
            java.awt.image.BufferedImage bimg = ((J2DTexture) tex).getBufferedImage();
            tex.unlock();
            return new java.awt.TexturePaint(bimg, tmpRect(x, y, w, h));
        }
        throw new UnsupportedOperationException(&quot;Paint &quot;+p+&quot; not supported yet.&quot;);
    }

    static java.awt.Stroke toJ2DStroke(BasicStroke stroke) {
        float lineWidth = stroke.getLineWidth();
        int type = stroke.getType();
        if (type != BasicStroke.TYPE_CENTERED) {
            lineWidth *= 2;
        }
        java.awt.BasicStroke bs =
                new java.awt.BasicStroke(lineWidth,
                                         stroke.getEndCap(),
                                         stroke.getLineJoin(),
                                         stroke.getMiterLimit(),
                                         stroke.getDashArray(),
                                         stroke.getDashPhase());
        if (type == BasicStroke.TYPE_INNER) {
            return new InnerStroke(bs);
        } else if (type == BasicStroke.TYPE_OUTER) {
            return new OuterStroke(bs);
        } else {
            return bs;
        }
    }

    private static ConcurrentHashMap&lt;java.awt.Font,
                                     WeakReference&lt;java.awt.Font&gt;&gt;
        fontMap = new ConcurrentHashMap&lt;java.awt.Font,
                                        WeakReference&lt;java.awt.Font&gt;&gt;();
    private static volatile int cleared = 0;

    private static java.awt.Font toJ2DFont(FontStrike strike) {
        FontResource fr = strike.getFontResource();
        java.awt.Font j2dfont;
        Object peer = fr.getPeer();
        if (peer == null &amp;&amp; fr.isEmbeddedFont()) {
            J2DFontFactory.registerFont(fr);
            peer = fr.getPeer();
        }
        if (peer != null &amp;&amp; peer instanceof java.awt.Font) {
            j2dfont = (java.awt.Font)peer;
        } else {
            if (PlatformUtil.isMac()) {
                // Looking up J2D fonts via full name is not reliable on the
                // Mac, however using the PostScript font name is. The likely
                // cause is Mac platform internals heavy reliance on PostScript
                // names for font identification.
                String psName = fr.getPSName();
                // dummy size
                j2dfont = new java.awt.Font(psName, java.awt.Font.PLAIN, 12);

                // REMIND: Due to bugs in j2d font lookup, these two workarounds
                // are required to ensure the correct font is used. Once fixed
                // in the jdk these workarounds should be removed.
                if (!j2dfont.getPSName().equals(psName)) {
                    // 1. Lookup font via family and style. This covers the
                    // case when the J2D PostScript name does not match psName
                    // in font file. For example &quot;HelveticaCYBold&quot; has the
                    // psName &quot;HelveticaCY-Bold&quot; in j2d.
                    int style = fr.isBold() ? java.awt.Font.BOLD : 0;
                    style = style | (fr.isItalic() ? java.awt.Font.ITALIC : 0);
                    j2dfont = new java.awt.Font(fr.getFamilyName(), style, 12);

                    if(!j2dfont.getPSName().equals(psName)) {
                        // 2. J2D seems to be unable to find a few fonts where
                        // psName == familyName.  Workaround is an exhaustive
                        // search of all fonts.
                        java.awt.Font[] allj2dFonts =
                                java.awt.GraphicsEnvironment.
                                getLocalGraphicsEnvironment().getAllFonts();
                        for (java.awt.Font f : allj2dFonts) {
                            if (f.getPSName().equals(psName)) {
                                j2dfont = f;
                                break;
                            }
                        }
                    }
                }
            } else {
                // dummy size
                j2dfont = new java.awt.Font(fr.getFullName(),
                                            java.awt.Font.PLAIN, 12);
            }

            // Adding j2dfont as peer is OK since fr is a decomposed
            // FontResource. Thus preventing font lookup next time we render.
            fr.setPeer(j2dfont);
        }
        // deriveFont(...) still has a bug and will cause #2 problem to occur
        j2dfont = j2dfont.deriveFont(strike.getSize()); // exact float font size
        java.awt.Font compFont = null;
        WeakReference&lt;java.awt.Font&gt; ref = fontMap.get(j2dfont);
        if (ref != null) {
            compFont = ref.get();
            if (compFont == null) {
                cleared++;
            }
        }
        if (compFont == null) {
            if (fontMap.size() &gt; 100 &amp;&amp; cleared &gt; 10) { // purge the map.
                for (java.awt.Font key : fontMap.keySet()) {
                    ref = fontMap.get(key);
                    if (ref == null || ref.get() == null) {
                        fontMap.remove(key);
                    }
                }
                cleared = 0;
            }
            compFont = J2DFontFactory.getCompositeFont(j2dfont);
            ref = new WeakReference(compFont);
            fontMap.put(j2dfont, ref);
        }
        return compFont;
    }

    public static java.awt.geom.AffineTransform
        toJ2DTransform(BaseTransform t)
    {
        return new java.awt.geom.AffineTransform(t.getMxx(), t.getMyx(),
                                                 t.getMxy(), t.getMyy(),
                                                 t.getMxt(), t.getMyt());
    }

    private static java.awt.geom.AffineTransform tmpAT =
        new java.awt.geom.AffineTransform();
    static java.awt.geom.AffineTransform tmpJ2DTransform(BaseTransform t)
    {
        tmpAT.setTransform(t.getMxx(), t.getMyx(),
                           t.getMxy(), t.getMyy(),
                           t.getMxt(), t.getMyt());
        return tmpAT;
    }

    static BaseTransform toPrTransform(java.awt.geom.AffineTransform t)
    {
        return BaseTransform.getInstance(t.getScaleX(), t.getShearY(),
                                         t.getShearX(), t.getScaleY(),
                                         t.getTranslateX(), t.getTranslateY());
    }

    static Rectangle toPrRect(java.awt.Rectangle r)
    {
        return new Rectangle(r.x, r.y, r.width, r.height);
    }

    private static java.awt.geom.Path2D tmpQuadShape =
        new java.awt.geom.Path2D.Float();
    private static java.awt.Shape tmpQuad(float x1, float y1,
                                          float x2, float y2)
    {
        tmpQuadShape.reset();
        tmpQuadShape.moveTo(x1, y1);
        tmpQuadShape.lineTo(x2, y1);
        tmpQuadShape.lineTo(x2, y2);
        tmpQuadShape.lineTo(x1, y2);
        tmpQuadShape.closePath();
        return tmpQuadShape;
    }

    private static java.awt.geom.Rectangle2D.Float tmpRect =
        new java.awt.geom.Rectangle2D.Float();
    private static java.awt.geom.Rectangle2D tmpRect(float x, float y, float w, float h) {
        tmpRect.setRect(x, y, w, h);
        return tmpRect;
    }

    private static java.awt.geom.Ellipse2D tmpEllipse =
        new java.awt.geom.Ellipse2D.Float();
    private static java.awt.Shape tmpEllipse(float x, float y, float w, float h) {
        tmpEllipse.setFrame(x, y, w, h);
        return tmpEllipse;
    }

    private static java.awt.geom.RoundRectangle2D tmpRRect =
        new java.awt.geom.RoundRectangle2D.Float();
    private static java.awt.Shape tmpRRect(float x, float y, float w, float h,
                                           float aw, float ah)
    {
        tmpRRect.setRoundRect(x, y, w, h, aw, ah);
        return tmpRRect;
    }

    private static java.awt.geom.Line2D tmpLine =
        new java.awt.geom.Line2D.Float();
    private static java.awt.Shape tmpLine(float x1, float y1, float x2, float y2) {
        tmpLine.setLine(x1, y1, x2, y2);
        return tmpLine;
    }

    private static AdaptorShape tmpAdaptor = new AdaptorShape();
    private static java.awt.Shape tmpShape(Shape s) {
        tmpAdaptor.setShape(s);
        return tmpAdaptor;
    }

    private boolean antialiasedShape = true;
    J2DPresentable target;
    java.awt.Graphics2D g2d;
    Affine2D transform;
    Rectangle clipRect;
    RectBounds devClipRect;
    RectBounds finalClipRect;
    Paint paint;
    boolean paintWasProportional;
    BasicStroke stroke;
    boolean cull;

    J2DPrismGraphics(J2DPresentable target, java.awt.Graphics2D g2d) {
        this(g2d, target.getContentWidth(), target.getContentHeight());
        this.target = target;
    }

    J2DPrismGraphics(java.awt.Graphics2D g2d, int width, int height) {
        this.g2d = g2d;
        captureTransform(g2d);
        this.transform = new Affine2D();
        this.devClipRect = new RectBounds(0, 0, width, height);
        this.finalClipRect = new RectBounds(0, 0, width, height);
        this.cull = true;

        g2d.setRenderingHint(java.awt.RenderingHints.KEY_STROKE_CONTROL,
                             java.awt.RenderingHints.VALUE_STROKE_PURE);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                              java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_INTERPOLATION,
                             java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        /* Set the text hints to those most equivalent to FX rendering.
         * Will need to revisit this since its unlikely to be sufficient.
         */
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
                           java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
                             java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);


        setTransform(BaseTransform.IDENTITY_TRANSFORM);
        setPaint(DEFAULT_PAINT);
        setStroke(DEFAULT_STROKE);
    }

    public RenderTarget getRenderTarget() {
        return target;
    }

    public Screen getAssociatedScreen() {
        return target.getAssociatedScreen();
    }

    public ResourceFactory getResourceFactory() {
        return target.getResourceFactory();
    }

    public void reset() {
    }

    public Rectangle getClipRect() {
        return clipRect == null ? null : new Rectangle(clipRect);
    }

    public Rectangle getClipRectNoClone() {
        return clipRect;
    }

    public RectBounds getFinalClipNoClone() {
        return finalClipRect;
    }

    public void setClipRect(Rectangle clipRect) {
        this.finalClipRect.setBounds(devClipRect);
<A NAME="20"></A>        if (clipRect == null) {
            this.clipRect = null;
            g2d.setClip(null);
        } else <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#20',2,'match42-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            this.clipRect = new Rectangle(clipRect);
            this.finalClipRect.intersectWith(clipRect);
            setTransformG2D(J2D_IDENTITY);
            g2d.setClip(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
            setTransformG2D(tmpJ2DTransform</B></FONT>(transform));
        }
    }

    private java.awt.AlphaComposite getAWTComposite() {
        return (java.awt.AlphaComposite) g2d.getComposite();
    }

    public float getExtraAlpha() {
        return getAWTComposite().getAlpha();
    }

    public void setExtraAlpha(float extraAlpha) {
        g2d.setComposite(getAWTComposite().derive(extraAlpha));
    }

    public CompositeMode getCompositeMode() {
        int rule = getAWTComposite().getRule();
        switch (rule) {
            case java.awt.AlphaComposite.CLEAR:
                return CompositeMode.CLEAR;
            case java.awt.AlphaComposite.SRC:
                return CompositeMode.SRC;
            case java.awt.AlphaComposite.SRC_OVER:
                return CompositeMode.SRC_OVER;
            default:
                throw new InternalError(&quot;Unrecognized AlphaCompsite rule: &quot;+rule);
        }
    }

    public void setCompositeMode(CompositeMode mode) {
        java.awt.AlphaComposite awtComp = getAWTComposite();
        switch (mode) {
            case CLEAR:
                awtComp = awtComp.derive(java.awt.AlphaComposite.CLEAR);
                break;
            case SRC:
                awtComp = awtComp.derive(java.awt.AlphaComposite.SRC);
                break;
            case SRC_OVER:
                awtComp = awtComp.derive(java.awt.AlphaComposite.SRC_OVER);
                break;
            default:
                throw new InternalError(&quot;Unrecognized composite mode: &quot;+mode);
        }
        g2d.setComposite(awtComp);
    }

    public Paint getPaint() {
        return paint;
    }

    public void setPaint(Paint paint) {
        this.paint = paint;
        java.awt.Paint j2dpaint = toJ2DPaint(paint, null);
        if (j2dpaint == null) {
            paintWasProportional = true;
        } else {
            paintWasProportional = false;
            g2d.setPaint(j2dpaint);
        }
    }

    public BasicStroke getStroke() {
        return stroke;
    }

    public void setStroke(BasicStroke stroke) {
        this.stroke = stroke;
        g2d.setStroke(toJ2DStroke(stroke));
    }

    public BaseTransform getTransformNoClone() {
        return transform;
    }

    public void translate(float tx, float ty) {
        transform.translate(tx, ty);
        g2d.translate(tx, ty);
    }

    public void scale(float sx, float sy) {
        transform.scale(sx, sy);
        g2d.scale(sx, sy);
    }

    public void transform(BaseTransform xform) {
        if (!xform.is2D()) {
            // No-op until we support 3D
            return;
        }
        transform.concatenate(xform);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void setTransform(BaseTransform xform) {
        // TODO: Modify PrEffectHelper to not pass a null... (RT-27384)
        if (xform == null) xform = BaseTransform.IDENTITY_TRANSFORM;
        transform.setTransform(xform);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void setTransform(double m00, double m10,
                             double m01, double m11,
                             double m02, double m12)
    {
        transform.setTransform(m00, m10, m01, m11, m02, m12);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void clear() {
        clear(Color.TRANSPARENT);
    }

    public void clear(Color color) {
        this.getRenderTarget().setOpaque(color.isOpaque());
        clear(toJ2DColor(color));
    }

    void clear(java.awt.Color c) {
        java.awt.Graphics2D gtmp = (java.awt.Graphics2D) g2d.create();
        gtmp.setTransform(J2D_IDENTITY);
        gtmp.setComposite(java.awt.AlphaComposite.Src);
        gtmp.setColor(c);
        gtmp.fillRect(0, 0, target.getContentWidth(), target.getContentHeight());
        gtmp.dispose();
    }

    public void clearQuad(float x1, float y1, float x2, float y2) {
        g2d.setComposite(java.awt.AlphaComposite.Clear);
        g2d.fill(tmpQuad(x1, y1, x2, y2));
    }

    void fill(java.awt.Shape shape) {
        if (paintWasProportional) {
            if (nodeBounds != null) {
                g2d.setPaint(toJ2DPaint(paint, nodeBounds));
            } else {
                g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
            }
        }
        g2d.fill(shape);
    }

    public void fill(Shape shape) {
        fill(tmpShape(shape));
    }

    public void fillRect(float x, float y, float width, float height) {
        fill(tmpRect(x, y, width, height));
    }

    public void fillRoundRect(float x, float y, float width, float height,
                              float arcw, float arch)
    {
        fill(tmpRRect(x, y, width, height, arcw, arch));
    }

    public void fillEllipse(float x, float y, float width, float height) {
        fill(tmpEllipse(x, y, width, height));
    }

    public void fillQuad(float x1, float y1, float x2, float y2) {
        fill(tmpQuad(x1, y1, x2, y2));
    }

    void draw(java.awt.Shape shape) {
        if (paintWasProportional) {
            if (nodeBounds != null) {
                g2d.setPaint(toJ2DPaint(paint, nodeBounds));
            } else {
                g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
            }
        }
        try {
            g2d.draw(shape);
        } catch (Throwable t) {
            // Workaround for JDK bug 6670624
            // We may get a Ductus PRError (extends RuntimeException)
            // or we may get an InternalError (extends Error)
            // The only common superclass of the two is Throwable...
        }
    }

    public void draw(Shape shape) {
        draw(tmpShape(shape));
    }

    public void drawLine(float x1, float y1, float x2, float y2) {
        draw(tmpLine(x1, y1, x2, y2));
    }

    public void drawRect(float x, float y, float width, float height) {
        draw(tmpRect(x, y, width, height));
    }

    public void drawRoundRect(float x, float y, float width, float height, float arcw, float arch) {
        draw(tmpRRect(x, y, width, height, arcw, arch));
    }

    public void drawEllipse(float x, float y, float width, float height) {
        draw(tmpEllipse(x, y, width, height));
    }

    Rectangle2D nodeBounds = null;

    public void setNodeBounds(RectBounds bounds) {
        nodeBounds = bounds != null ?
                new Rectangle2D.Float(bounds.getMinX(), bounds.getMinY(),
                                      bounds.getWidth(),bounds.getHeight()) :
                null;
    }

    private void drawString(GlyphList gl, int start, int end,
                            FontStrike strike, float x, float y) {
        if (start == end) return;
        int count = end - start;
        int[] glyphs = new int[count];
        for (int i = 0; i &lt; count; i++) {
            glyphs[i] = gl.getGlyphCode(start + i) &amp; CompositeGlyphMapper.GLYPHMASK;
        }
        java.awt.Font j2dfont = toJ2DFont(strike);
        GlyphVector gv = j2dfont.createGlyphVector(g2d.getFontRenderContext(), glyphs);
        java.awt.geom.Point2D pt = new java.awt.geom.Point2D.Float();
        for (int i = 0; i &lt; count; i++) {
            pt.setLocation(gl.getPosX(start + i), gl.getPosY(start + i));
            gv.setGlyphPosition(i, pt);
        }
        g2d.drawGlyphVector(gv, x, y);
    }

    public void drawString(GlyphList gl, FontStrike strike, float x, float y,
                           Color selectColor, int start, int end) {

        int count = gl.getGlyphCount();
        if (count == 0) return;

        // In JDK6, setting graphics AA disables fast text loops
        g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_OFF);

        // If the surface has Alpha, JDK will ignore the LCD loops.
        // So for this to have any effect we need to fix JDK, or
        // ensure an opaque surface type.
        if (strike.getAAMode() == FontResource.AA_LCD) {
            g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_LCD_HRGB);
        }

        if (paintWasProportional) {
            Rectangle2D rectBounds = nodeBounds;
            if (rectBounds == null) {
                Metrics m = strike.getMetrics();
                rectBounds = new Rectangle2D.Float(0,
                                                   m.getAscent(),
                                                   gl.getWidth(),
                                                   m.getLineHeight());
            }
            g2d.setPaint(toJ2DPaint(paint, rectBounds));
        }

        CompositeStrike cStrike = null;
        int slot = 0;
        if (strike instanceof CompositeStrike) {
            cStrike = (CompositeStrike)strike;
            int glyphCode = gl.getGlyphCode(0);
            slot = cStrike.getStrikeSlotForGlyph(glyphCode);
        }
        java.awt.Color sColor = null;
        java.awt.Color tColor = null;
        boolean selected = false;
        if (selectColor != null) {
            sColor = toJ2DColor(selectColor);
            tColor = g2d.getColor();
            int offset = gl.getCharOffset(0);
            selected = start &lt;= offset &amp;&amp; offset &lt; end;
        }
        int index = 0;
        if (sColor != null || cStrike != null) {
            /* Draw a segment every time selection or font changes */
            for (int i = 1; i &lt; count; i++) {
                if (sColor != null) {
                    int offset = gl.getCharOffset(i);
                    boolean glyphSelected = start &lt;= offset &amp;&amp; offset &lt; end;
                    if (selected != glyphSelected) {
                        if (cStrike != null) {
                            strike = cStrike.getStrikeSlot(slot);
                        }
                        g2d.setColor(selected ? sColor : tColor);
                        drawString(gl, index, i, strike, x, y);
                        index = i;
                        selected = glyphSelected;
                    }
                }
                if (cStrike != null) {
                    int glyphCode = gl.getGlyphCode(i);
                    int glyphSlot = cStrike.getStrikeSlotForGlyph(glyphCode);
                    if (slot != glyphSlot) {
                        strike = cStrike.getStrikeSlot(slot);
                        if (sColor != null) {
                            g2d.setColor(selected ? sColor : tColor);
                        }
                        drawString(gl, index, i, strike, x, y);
                        index = i;
                        slot = glyphSlot;
                    }
                }
            }

            /* Set strike and color to draw the last segment */
            if (cStrike != null) {
                strike = cStrike.getStrikeSlot(slot);
            }
            if (sColor != null) {
                g2d.setColor(selected ? sColor : tColor);
            }
        }
        drawString(gl, index, count, strike, x, y);

        /* Always restore the graphics to its initial color */
        if (selectColor != null) {
            g2d.setColor(tColor);
        }

        // Set hints back to the default.
        g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);
        g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
    }

    /**
     * Overridden by printing subclass to preserve the printer graphics
     * transform.
     */
    protected void setTransformG2D(java.awt.geom.AffineTransform tx) {
        g2d.setTransform(tx);
    }

    /**
     * Needed only by printing subclass, which over-rides it.
     */
    protected void captureTransform(java.awt.Graphics2D g2d) {
        return;
    }

    public void drawMappedTextureRaw(Texture tex,
                                     float dx1, float dy1, float dx2, float dy2,
                                     float tx11, float ty11, float tx21, float ty21,
                                     float tx12, float ty12, float tx22, float ty22)
    {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        float mxx = tx21-tx11;
        float myx = ty21-ty11;
        float mxy = tx12-tx11;
        float myy = ty12-ty11;
//        assert(Math.abs(mxx - (tx22-tx12)) &lt; .000001);
//        assert(Math.abs(myx - (ty22-ty12)) &lt; .000001);
//        assert(Math.abs(mxy - (tx22-tx21)) &lt; .000001);
//        assert(Math.abs(myy - (ty22-ty21)) &lt; .000001);
        setTransformG2D(J2D_IDENTITY);
        tmpAT.setTransform(mxx, myx, mxy, myy, tx11, ty11);
        try {
            tmpAT.invert();
            g2d.translate(dx1, dy1);
            g2d.scale(dx2-dx1, dy2-dy1);
            g2d.transform(tmpAT);
            g2d.drawImage(img, 0, 0, 1, 1, null);
        } catch (NoninvertibleTransformException e) {
        }
        setTransform(transform);
    }

    public void drawTexture(Texture tex, float x, float y, float w, float h) {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        g2d.drawImage(img, (int) x, (int) y, (int) (x+w), (int) (y+h), 0, 0, (int)w, (int) h, null);
    }

    public void drawTexture(Texture tex,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2)
    {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        // Simply casting the subimage coordinates to integers does not
        // produce the same behavior as the Prism hw pipelines (see RT-19270).
        g2d.drawImage(img,
                (int) dx1, (int) dy1, (int) dx2, (int) dy2,
                (int) sx1, (int) sy1, (int) sx2, (int) sy2,
                null);
    }

    @Override
    public void drawTexture3SliceH(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dh1, float dh2, float sh1, float sh2)
    {
        // Workaround for problems in NGRegion which may pass zero-width
        // source image area.
        if (sh1 + 0.1f &gt; sh2) sh2 += 1;
        drawTexture(tex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
        drawTexture(tex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
        drawTexture(tex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
    }

    @Override
    public void drawTexture3SliceV(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dv1, float dv2, float sv1, float sv2)
    {
        // Workaround for problems in NGRegion which may pass zero-height
        // source image area.
        if (sv1 +0.1f &gt; sv2) sv2 += 1;
        drawTexture(tex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
        drawTexture(tex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
        drawTexture(tex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
    }

    @Override
    public void drawTexture9Slice(Texture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2,
                                  float dh1, float dv1, float dh2, float dv2,
                                  float sh1, float sv1, float sh2, float sv2)
    {
        // Workaround for problems in NGRegion which may pass zero-width
        // or zero height source image area.
        if (sh1 + 0.1f &gt; sh2) sh2 += 1;
        if (sv1 + 0.1f &gt; sv2) sv2 += 1;
        drawTexture(tex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
        drawTexture(tex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
        drawTexture(tex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);

        drawTexture(tex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
        drawTexture(tex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
        drawTexture(tex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);

        drawTexture(tex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
        drawTexture(tex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
        drawTexture(tex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
    }

    public void drawTextureRaw(Texture tex,
                               float dx1, float dy1, float dx2, float dy2,
                               float tx1, float ty1, float tx2, float ty2)
    {
        int w = tex.getContentWidth();
        int h = tex.getContentHeight();
        tx1 *= w;
        ty1 *= h;
        tx2 *= w;
        ty2 *= h;
        drawTexture(tex, dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
    }

    public void drawTextureVO(Texture tex,
                              float topopacity, float botopacity,
                              float dx1, float dy1, float dx2, float dy2,
                              float sx1, float sy1, float sx2, float sy2)
    {
        // assert(caller is PrReflectionPeer and buffer is cleared to transparent)
        // NOTE: the assert conditions are true because that is the only
        // place where this method is used (unless we subclass BaseGraphics),
        // but there is no code here to verify that information.
        // The workarounds to do this for the general case would cost a lot
        // because they would involve creating a temporary intermediate buffer,
        // doing the operations below into the buffer, and then applying the
        // buffer to the destination.  That is not hard, but it costs a lot
        // of buffer allocation (or caching) when it is not really necessary
        // given the way this method is called currently.
        // Note that isoEdgeMask is ignored here, but since this is only ever
        // called by PrReflectionPeer and that code always uses ISOLATE_NONE
        // then we would only need to support ISOLATE_NONE.  The code below
        // does not yet verify if the results will be compatible with
        // ISOLATE_NONE, but given that the source coordinates are rounded to
        // integers in drawTexture() there is not much it can do to get exact
        // edge condition behavior until that deficiency is fixed (see
        // RT-19270 and RT-19271).
        java.awt.Paint savepaint = g2d.getPaint();
        java.awt.Composite savecomp = g2d.getComposite();
        java.awt.Color c1 = new java.awt.Color(1f, 1f, 1f, topopacity);
        java.awt.Color c2 = new java.awt.Color(1f, 1f, 1f, botopacity);
        g2d.setPaint(new java.awt.GradientPaint(0f, dy1, c1, 0f, dy2, c2, true));
        g2d.setComposite(java.awt.AlphaComposite.Src);
        int x = (int) Math.floor(Math.min(dx1, dx2));
        int y = (int) Math.floor(Math.min(dy1, dy2));
        int w = (int) Math.ceil(Math.max(dx1, dx2)) - x;
        int h = (int) Math.ceil(Math.max(dy1, dy2)) - y;
        g2d.fillRect(x, y, w, h);
        g2d.setComposite(java.awt.AlphaComposite.SrcIn);
        drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        g2d.setComposite(savecomp);
        g2d.setPaint(savepaint);
    }

    public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
                                 int dx, int dy, int dw, int dh,
                                 int ix, int iy, int mx, int my)
    {
        doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
                          dx, dy, dw, dh,
                          ix, iy, mx, my,
                          true);
    }

    public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex, int dx,
                                      int dy, int dw, int dh, int ix, int iy,
                                      int mx, int my) {
        doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
                          dx, dy, dw, dh,
                          ix, iy, mx, my,
                          false);
    }

    private void doDrawMaskTexture(J2DRTTexture imgtex, J2DRTTexture masktex,
                                   int dx, int dy, int dw, int dh,
                                   int ix, int iy, int mx, int my,
                                   boolean srcover)
    {
        int cx0 = clipRect.x;
        int cy0 = clipRect.y;
        int cx1 = cx0 + clipRect.width;
        int cy1 = cy0 + clipRect.height;

        if (dw &lt;= 0 || dh &lt;= 0) return;
        if (dx &lt; cx0) {
            int bump = cx0 - dx;
            if ((dw -= bump) &lt;= 0) return;
            ix += bump;
            mx += bump;
            dx = cx0;
        }
        if (dy &lt; cy0) {
            int bump = cy0 - dy;
            if ((dh -= bump) &lt;= 0) return;
            iy += bump;
            my += bump;
            dy = cy0;
        }
        if (dx + dw &gt; cx1 &amp;&amp; (dw = cx1 - dx) &lt;= 0) return;
        if (dy + dh &gt; cy1 &amp;&amp; (dh = cy1 - dy) &lt;= 0) return;

        int iw = imgtex.getContentWidth();
        int ih = imgtex.getContentHeight();
        if (ix &lt; 0) {
            if ((dw += ix) &lt;= 0) return;
            dx -= ix;
            mx -= ix;
            ix = 0;
        }
        if (iy &lt; 0) {
            if ((dh += iy) &lt;= 0) return;
            dy -= iy;
            my -= iy;
            iy = 0;
        }
        if (ix + dw &gt; iw &amp;&amp; (dw = iw - ix) &lt;= 0) return;
        if (iy + dh &gt; ih &amp;&amp; (dh = ih - iy) &lt;= 0) return;

        int mw = masktex.getContentWidth();
        int mh = masktex.getContentHeight();
        if (mx &lt; 0) {
            if ((dw += mx) &lt;= 0) return;
            dx -= mx;
            ix -= mx;
            mx = 0;
        }
        if (my &lt; 0) {
            if ((dh += my) &lt;= 0) return;
            dy -= my;
            iy -= my;
            my = 0;
        }
        if (mx + dw &gt; mw &amp;&amp; (dw = mw - mx) &lt;= 0) return;
        if (my + dh &gt; mh &amp;&amp; (dh = mh - my) &lt;= 0) return;

        int imgbuf[] = imgtex.getPixels();
        int maskbuf[] = masktex.getPixels();
        java.awt.image.DataBuffer db = target.getBackBuffer().getRaster().getDataBuffer();
        int dstbuf[] = ((java.awt.image.DataBufferInt) db).getData();
        int iscan = imgtex.getBufferedImage().getWidth();
        int mscan = masktex.getBufferedImage().getWidth();
        int dscan = target.getBackBuffer().getWidth();
        int ioff = iy * iscan + ix;
        int moff = my * mscan + mx;
        int doff = dy * dscan + dx;
        if (srcover) {
            for (int y = 0; y &lt; dh; y++) {
                for (int x = 0; x &lt; dw; x++) {
                    int a, r, g, b;
                    int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
                    if (maskalpha == 0) continue;
                    int imgpix = imgbuf[ioff+x];
                    a = (imgpix &gt;&gt;&gt; 24);
                    if (a == 0) continue;
                    if (maskalpha &lt; 0xff) {
                        maskalpha += (maskalpha &gt;&gt; 7);
                        a *= maskalpha;
                        r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
                        g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
                        b = ((imgpix       ) &amp; 0xff) * maskalpha;
                    } else if (a &lt; 0xff) {
                        a &lt;&lt;= 8;
                        r = ((imgpix &gt;&gt;  16) &amp; 0xff) &lt;&lt; 8;
                        g = ((imgpix &gt;&gt;   8) &amp; 0xff) &lt;&lt; 8;
                        b = ((imgpix       ) &amp; 0xff) &lt;&lt; 8;
                    } else {
                        dstbuf[doff+x] = imgpix;
                        continue;
                    }
                    maskalpha = ((a + 128) &gt;&gt; 8);
                    maskalpha += (maskalpha &gt;&gt; 7);
                    maskalpha = 256 - maskalpha;
                    imgpix = dstbuf[doff+x];
                    a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
                    r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
                    g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
                    b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
                    imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
                             ((r &gt;&gt; 8) &lt;&lt; 16) +
                             ((g &gt;&gt; 8) &lt;&lt;  8) +
                             ((b &gt;&gt; 8)      );
                    dstbuf[doff+x] = imgpix;
                }
                ioff += iscan;
                moff += mscan;
                doff += dscan;
            }
        } else {
            for (int y = 0; y &lt; dh; y++) {
                for (int x = 0; x &lt; dw; x++) {
                    int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
                    if (maskalpha == 0) continue;
                    int imgpix = imgbuf[ioff+x];
                    if (maskalpha &lt; 0xff) {
                        maskalpha += (maskalpha &gt;&gt; 7);
                        int a = ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha;
                        int r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
                        int g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
                        int b = ((imgpix       ) &amp; 0xff) * maskalpha;
                        maskalpha = 256 - maskalpha;
                        imgpix = dstbuf[doff+x];
                        a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
                        r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
                        g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
                        b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
                        imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
                                 ((r &gt;&gt; 8) &lt;&lt; 16) +
                                 ((g &gt;&gt; 8) &lt;&lt;  8) +
                                 ((b &gt;&gt; 8)      );
                    }
                    dstbuf[doff+x] = imgpix;
                }
                ioff += iscan;
                moff += mscan;
                doff += dscan;
            }
        }
    }

    public boolean canReadBack() {
        return true;
    }

    public RTTexture readBack(Rectangle view) {
        J2DRTTexture rtt = target.getReadbackBuffer();
        java.awt.Graphics2D rttg2d = rtt.createAWTGraphics2D();
        rttg2d.setComposite(java.awt.AlphaComposite.Src);
        int x0 = view.x;
        int y0 = view.y;
        int w = view.width;
        int h = view.height;
        int x1 = x0 + w;
        int y1 = y0 + h;
        rttg2d.drawImage(target.getBackBuffer(),
                          0,  0,  w,  h,
                         x0, y0, x1, y1, null);
        rttg2d.dispose();
        return rtt;
    }

    public void releaseReadBackBuffer(RTTexture view) {
        // This will be needed when we track LCD buffer locks and uses.
        // (See RT-29488)
//        target.getReadbackBuffer().unlock();
    }

    public NGCamera getCameraNoClone() {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setPerspectiveTransform(GeneralTransform3D transform) {
    }


    public boolean isDepthBuffer() {
        return false;
    }

    public boolean isDepthTest() {
        return false;
    }

    public boolean isAlphaTestShader() {
        if (PrismSettings.verbose &amp;&amp; PrismSettings.forceAlphaTestShader) {
            System.out.println(&quot;J2D pipe doesn't support shader with alpha testing&quot;);
        }
        return false;
    }

    public void setAntialiasedShape(boolean aa) {
        antialiasedShape = aa;
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                antialiasedShape ? java.awt.RenderingHints.VALUE_ANTIALIAS_ON
                        : java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
    }

    public boolean isAntialiasedShape() {
        return antialiasedShape;
    }

    public void scale(float sx, float sy, float sz) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setTransform3D(double mxx, double mxy, double mxz, double mxt,
                               double myx, double myy, double myz, double myt,
                               double mzx, double mzy, double mzz, double mzt)
    {
        if (mxz != 0.0 || myz != 0.0 ||
            mzx != 0.0 || mzy != 0.0 || mzz != 1.0 || mzt != 0.0)
        {
            throw new UnsupportedOperationException(&quot;3D transforms not supported.&quot;);
        }
        setTransform(mxx, myx, mxy, myy, mxt, myt);
    }

    public void setCamera(NGCamera camera) {
        // No-op until we support 3D
        /*
        if (!(camera instanceof PrismParallelCameraImpl)) {

            throw new UnsupportedOperationException(camera+&quot; not supported.&quot;);
        }
        */
    }

    public void setDepthBuffer(boolean depthBuffer) {
        // No-op until we support 3D
    }

    public void setDepthTest(boolean depthTest) {
        // No-op until we support 3D
    }

    public void sync() {
    }

    public void translate(float tx, float ty, float tz) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setCulling(boolean cull) {
        this.cull = cull;
    }

    public boolean isCulling() {
        return this.cull;
    }

 public void setClipRectIndex(int index) {
        this.clipRectIndex = index;
    }
    public int getClipRectIndex() {
        return this.clipRectIndex;
    }

    public void setHasPreCullingBits(boolean hasBits) {
        this.hasPreCullingBits = hasBits;
    }

    public boolean hasPreCullingBits() {
        return hasPreCullingBits;
    }

    private NodePath renderRoot;
    @Override
    public void setRenderRoot(NodePath root) {
        this.renderRoot = root;
    }

    @Override
    public NodePath getRenderRoot() {
        return renderRoot;
    }

    public void setState3D(boolean flag) {
    }

    public boolean isState3D() {
        return false;
    }

    public void setup3DRendering() {
    }

    @Override
    public void setPixelScaleFactors(float pixelScaleX, float pixelScaleY) {
        this.pixelScaleX = pixelScaleX;
        this.pixelScaleY = pixelScaleY;
    }

    @Override
    public float getPixelScaleFactorX() {
        return pixelScaleX;
    }

    @Override
    public float getPixelScaleFactorY() {
        return pixelScaleY;
    }

    @Override
    public void blit(RTTexture srcTex, RTTexture dstTex,
            int srcX0, int srcY0, int srcX1, int srcY1,
            int dstX0, int dstY0, int dstX1, int dstY1) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    private static class AdaptorShape implements java.awt.Shape {
        private Shape prshape;

        public void setShape(Shape prshape) {
            this.prshape = prshape;
        }

        public boolean contains(double x, double y) {
            return prshape.contains((float) x, (float) y);
        }

        public boolean contains(java.awt.geom.Point2D p) {
            return contains(p.getX(), p.getY());
        }

        public boolean contains(double x, double y, double w, double h) {
            return prshape.contains((float) x, (float) y, (float) w, (float) h);
        }

        public boolean contains(java.awt.geom.Rectangle2D r) {
            return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
        }

        public boolean intersects(double x, double y, double w, double h) {
            return prshape.intersects((float) x, (float) y, (float) w, (float) h);
        }

        public boolean intersects(java.awt.geom.Rectangle2D r) {
            return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
        }

        public java.awt.Rectangle getBounds() {
            return getBounds2D().getBounds();
        }

        public java.awt.geom.Rectangle2D getBounds2D() {
            RectBounds b = prshape.getBounds();
            java.awt.geom.Rectangle2D r2d =
                new java.awt.geom.Rectangle2D.Float();
            r2d.setFrameFromDiagonal(b.getMinX(), b.getMinY(), b.getMaxX(), b.getMaxY());
            return r2d;
        }

        private static AdaptorPathIterator tmpAdaptor =
                new AdaptorPathIterator();
        private static java.awt.geom.PathIterator tmpAdaptor(PathIterator pi) {
            tmpAdaptor.setIterator(pi);
            return tmpAdaptor;
        }

        public java.awt.geom.PathIterator
            getPathIterator(java.awt.geom.AffineTransform at)
        {
            BaseTransform tx = (at == null) ? null : toPrTransform(at);
            return tmpAdaptor(prshape.getPathIterator(tx));
        }

        public java.awt.geom.PathIterator
            getPathIterator(java.awt.geom.AffineTransform at,
                            double flatness)
        {
            BaseTransform tx = (at == null) ? null : toPrTransform(at);
            return tmpAdaptor(prshape.getPathIterator(tx, (float) flatness));
        }
    }

    private static class AdaptorPathIterator
        implements java.awt.geom.PathIterator
    {
        private static int NUM_COORDS[] = { 2, 2, 4, 6, 0 };
        PathIterator priterator;
        float tmpcoords[];

        public void setIterator(PathIterator priterator) {
            this.priterator = priterator;
        }

        public int currentSegment(float[] coords) {
            return priterator.currentSegment(coords);
        }

        public int currentSegment(double[] coords) {
            if (tmpcoords == null) {
                tmpcoords = new float[6];
            }
            int ret = priterator.currentSegment(tmpcoords);
            for (int i = 0; i &lt; NUM_COORDS[ret]; i++) {
                coords[i] = (double) tmpcoords[i];
            }
            return ret;
        }

        public int getWindingRule() {
            return priterator.getWindingRule();
        }

        public boolean isDone() {
            return priterator.isDone();
        }

        public void next() {
            priterator.next();
        }
    }

    static abstract class FilterStroke implements java.awt.Stroke {
        protected java.awt.BasicStroke stroke;

        FilterStroke(java.awt.BasicStroke stroke) {
            this.stroke = stroke;
        }

        abstract protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r);
        abstract protected java.awt.Shape makeStrokedShape(java.awt.Shape s);

        public java.awt.Shape createStrokedShape(java.awt.Shape p) {
            if (p instanceof java.awt.geom.Rectangle2D) {
                java.awt.Shape s = makeStrokedRect((java.awt.geom.Rectangle2D) p);
                if (s != null) {
                    return s;
                }
            }
            return makeStrokedShape(p);
        }

        // ArcIterator.btan(Math.PI/2)
        static final double CtrlVal = 0.5522847498307933;

        static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
                                                      float x0, float y0,
                                                      float xc, float yc,
                                                      float x1, float y1)
        {
            return cornerArc(gp, x0, y0, xc, yc, x1, y1, 0.5f);
        }

        static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
                                                      float x0, float y0,
                                                      float xc, float yc,
                                                      float x1, float y1, float t)
        {
            float xc0 = (float) (x0 + CtrlVal * (xc - x0));
            float yc0 = (float) (y0 + CtrlVal * (yc - y0));
            float xc1 = (float) (x1 + CtrlVal * (xc - x1));
            float yc1 = (float) (y1 + CtrlVal * (yc - y1));
            gp.curveTo(xc0, yc0, xc1, yc1, x1, y1);

            return new java.awt.geom.Point2D.Float(eval(x0, xc0, xc1, x1, t),
                                                   eval(y0, yc0, yc1, y1, t));
        }

        static float eval(float c0, float c1, float c2, float c3, float t) {
            c0 = c0 + (c1-c0) * t;
            c1 = c1 + (c2-c1) * t;
            c2 = c2 + (c3-c2) * t;
            c0 = c0 + (c1-c0) * t;
            c1 = c1 + (c2-c1) * t;
            return c0 + (c1-c0) * t;
        }
    }

    static class InnerStroke extends FilterStroke {
        InnerStroke(java.awt.BasicStroke stroke) {
            super(stroke);
        }

        protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            if (pad &gt;= r.getWidth() || pad &gt;= r.getHeight()) {
                return r;
            }
            float rx0 = (float) r.getX();
            float ry0 = (float) r.getY();
            float rx1 = rx0 + (float) r.getWidth();
            float ry1 = ry0 + (float) r.getHeight();
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx1, ry0);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx0, ry1);
            gp.closePath();
            rx0 += pad;
            ry0 += pad;
            rx1 -= pad;
            ry1 -= pad;
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx0, ry1);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx1, ry0);
            gp.closePath();
            return gp;
        }

        // NOTE: This is a work in progress, not used yet
        protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float w = (float) e.getWidth();
            float h = (float) e.getHeight();
            if (w - 2*pad &gt; h * 2 || h - 2*pad &gt; w * 2) {
                // If the inner ellipse is too &quot;squashed&quot; then we can not
                // approximate it with just a single cubic per quadrant.
                // NOTE: measure so we can relax this restriction and
                // also consider modifying the code below to insert
                // more cubics in those cases.
                return null;
            }
            if (pad &gt;= w || pad &gt;= h) {
                return e;
            }
            float x0 = (float) e.getX();
            float y0 = (float) e.getY();
            float xc = x0 + w / 2f;
            float yc = y0 + h / 2f;
            float x1 = x0 + w;
            float y1 = y0 + h;
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x1, y0, x1, yc);
            cornerArc(gp, x1, yc, x1, y1, xc, y1);
            cornerArc(gp, xc, y1, x0, y1, x0, yc);
            cornerArc(gp, x0, yc, x0, y0, xc, y0);
            gp.closePath();
            x0 += pad;
            y0 += pad;
            x1 -= pad;
            y1 -= pad;
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x0, y0, x0, yc);
            cornerArc(gp, x0, yc, x0, y1, xc, y1);
            cornerArc(gp, xc, y1, x1, y1, x1, yc);
            cornerArc(gp, x1, yc, x1, y0, xc, y0);
            gp.closePath();
            return gp;
        }

        @Override
        protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
            java.awt.Shape ss = stroke.createStrokedShape(s);
            java.awt.geom.Area b = new java.awt.geom.Area(ss);
            b.intersect(new java.awt.geom.Area(s));
            return b;
        }
    }

    static class OuterStroke extends FilterStroke {
        static double SQRT_2 = Math.sqrt(2);

        OuterStroke(java.awt.BasicStroke stroke) {
            super(stroke);
        }

        protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float rx0 = (float) r.getX();
            float ry0 = (float) r.getY();
            float rx1 = rx0 + (float) r.getWidth();
            float ry1 = ry0 + (float) r.getHeight();
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            // clockwise
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx1, ry0);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx0, ry1);
            gp.closePath();
            float ox0 = rx0 - pad;
            float oy0 = ry0 - pad;
            float ox1 = rx1 + pad;
            float oy1 = ry1 + pad;
            switch (stroke.getLineJoin()) {
            case BasicStroke.JOIN_MITER:
                // A miter limit of less than sqrt(2) bevels right angles...
                if (stroke.getMiterLimit() &gt;= SQRT_2) {
                    // counter-clockwise
                    gp.moveTo(ox0, oy0);
                    gp.lineTo(ox0, oy1);
                    gp.lineTo(ox1, oy1);
                    gp.lineTo(ox1, oy0);
                    gp.closePath();
                    break;
                }
                // NO BREAK
            case BasicStroke.JOIN_BEVEL:
                // counter-clockwise
                gp.moveTo(ox0, ry0);
                gp.lineTo(ox0, ry1);  // left edge
                gp.lineTo(rx0, oy1);  // ll corner
                gp.lineTo(rx1, oy1);  // bottom edge
                gp.lineTo(ox1, ry1);  // lr corner
                gp.lineTo(ox1, ry0);  // right edge
                gp.lineTo(rx1, oy0);  // ur corner
                gp.lineTo(rx0, oy0);  // top edge
                gp.closePath();       // ul corner
                break;
            case BasicStroke.JOIN_ROUND:
                // counter-clockwise
                gp.moveTo(ox0, ry0);
                gp.lineTo(ox0, ry1);                          // left edge
                cornerArc(gp, ox0, ry1, ox0, oy1, rx0, oy1);  // ll corner
                gp.lineTo(rx1, oy1);                          // bottom edge
                cornerArc(gp, rx1, oy1, ox1, oy1, ox1, ry1);  // lr corner
                gp.lineTo(ox1, ry0);                          // right edge
                cornerArc(gp, ox1, ry0, ox1, oy0, rx1, oy0);  // ur corner
                gp.lineTo(rx0, oy0);                          // top edge
                cornerArc(gp, rx0, oy0, ox0, oy0, ox0, ry0);  // ul corner
                gp.closePath();
                break;
            default:
                throw new InternalError(&quot;Unrecognized line join style&quot;);
            }
            return gp;
        }

        // NOTE: This is a work in progress, not used yet
        protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float w = (float) e.getWidth();
            float h = (float) e.getHeight();
            if (w &gt; h * 2 || h &gt; w * 2) {
                // If the inner ellipse is too &quot;squashed&quot; then we can not
                // approximate it with just a single cubic per quadrant.
                // NOTE: measure so we can relax this restriction and
                // also consider modifying the code below to insert
                // more cubics in those cases.
                return null;
            }
            float x0 = (float) e.getX();
            float y0 = (float) e.getY();
            float xc = x0 + w / 2f;
            float yc = y0 + h / 2f;
            float x1 = x0 + w;
            float y1 = y0 + h;
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x1, y0, x1, yc);
            cornerArc(gp, x1, yc, x1, y1, xc, y1);
            cornerArc(gp, xc, y1, x0, y1, x0, yc);
            cornerArc(gp, x0, yc, x0, y0, xc, y0);
            gp.closePath();
            x0 -= pad;
            y0 -= pad;
            x1 += pad;
            y1 += pad;
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x0, y0, x0, yc);
            cornerArc(gp, x0, yc, x0, y1, xc, y1);
            cornerArc(gp, xc, y1, x1, y1, x1, yc);
            cornerArc(gp, x1, yc, x1, y0, xc, y0);
            gp.closePath();
            return gp;
        }

        @Override
        protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
            java.awt.Shape ss = stroke.createStrokedShape(s);
            java.awt.geom.Area b = new java.awt.geom.Area(ss);
            b.subtract(new java.awt.geom.Area(s));
            return b;
        }
    }

    @Override
    public void setLights(NGLightBase[] lights) {
        // Light are not supported by J2d
    }

    @Override
    public NGLightBase[] getLights() {
        // Light are not supported by J2d
        return null;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/InnerShadow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect;

import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.BaseTransform;

/**
 * A high-level effect that renders a shadow inside the edges of the
 * given content with the specified color, radius, and offset.
 */
public class InnerShadow extends DelegateEffect {

    private final InvertMask invert;
    private AbstractShadow shadow;
    private final Blend blend;

    /**
     * Constructs a new {@code InnerShadow} effect, with the default
     * blur radius (10.0), x offset (0.0), and y offset (0.0), using the
     * default input for source data.
     * This is a shorthand equivalent to:
     * &lt;pre&gt;
     *     new InnerShadow(DefaultInput, DefaultInput)
     * &lt;/pre&gt;
     */
    public InnerShadow() {
        this(DefaultInput, DefaultInput);
    }

    /**
     * Constructs a new {@code InnerShadow} effect, with the default
     * blur radius (10.0), x offset (0.0), and y offset (0.0).
     * This is a shorthand equivalent to:
     * &lt;pre&gt;
     *     new InnerShadow(input, input);
     * &lt;/pre&gt;
     *
     * @param input the single input {@code Effect}
     */
    public InnerShadow(Effect input) {
        this(input, input);
    }

    /**
     * Constructs a new {@code InnerShadow} effect, with the default
     * blur radius (10.0), x offset (0.0), and y offset (0.0).
     * &lt;p&gt;
     * This constructor is intended for advanced developers only.  Most
     * developers will only ever need to use the default constructor.
     * &lt;p&gt;
     * The {@code shadowSourceInput} is used to create the background shadow,
     * and the {@code contentInput} is used to render the content over that
     * shadow.
     *
     * @param shadowSourceInput the input {@code Effect} used to create
     * the background shadow
     * @param contentInput the input {@code Effect} used to render the content
     * over the shadow
     */
    public InnerShadow(Effect shadowSourceInput, Effect contentInput) {
        super(shadowSourceInput, contentInput);
        //
        //          (ssInput)
        //             |
        //           Invert
        //             |
        //  (cInput) Shadow
        //       |   |
        //       Blend
        //         |
        //
        this.invert = new InvertMask(10, shadowSourceInput);
        this.shadow = new GaussianShadow(10f, Color4f.BLACK, invert);
        this.blend = new Blend(Blend.Mode.SRC_ATOP, contentInput, shadow);
    }

    public AbstractShadow.ShadowMode getShadowMode() {
        return shadow.getMode();
    }

    public void setShadowMode(AbstractShadow.ShadowMode mode) {
        AbstractShadow.ShadowMode old = shadow.getMode();
        AbstractShadow s = shadow.implFor(mode);
        if (s != shadow) {
            blend.setTopInput(s);
        }
        this.shadow = s;
    }

    protected Effect getDelegate() {
        return blend;
    }

    @Override
    public BaseBounds getBounds(BaseTransform transform,
                              Effect defaultInput)
    {
        Effect input = getDefaultedInput(getContentInput(), defaultInput);
        return input.getBounds(transform, defaultInput);
    }

    /**
     * Returns the shadow source input for this {@code Effect}.
     *
     * @return the shadow source input for this {@code Effect}
     */
    public final Effect getShadowSourceInput() {
        return invert.getInput();
    }

    /**
     * Sets the shadow source input for this {@code Effect} to a specific
     * {@code Effect} or to the default input if {@code input} is
     * {@code null}.
     *
     * @param shadowSourceInput the shadow source input for this {@code Effect}
     */
    public void setShadowSourceInput(Effect shadowSourceInput) {
        invert.setInput(shadowSourceInput);
    }

    /**
     * Returns the content input for this {@code Effect}.
     *
     * @return the content input for this {@code Effect}
     */
    public final Effect getContentInput() {
        return blend.getBottomInput();
    }

    /**
     * Sets the content input for this {@code Effect} to a specific
     * {@code Effect} or to the default input if {@code input} is
     * {@code null}.
     *
     * @param contentInput the content input for this {@code Effect}
     */
    public void setContentInput(Effect contentInput) {
        blend.setBottomInput(contentInput);
    }

    /**
     * Returns the radius of the Gaussian kernel.
     *
     * @return the radius of the Gaussian kernel
     */
    public float getRadius() {
        return shadow.getGaussianRadius();
    }

    /**
     * Sets the radius of the shadow blur kernel.
     * &lt;pre&gt;
     *       Min:   0.0
     *       Max: 127.0
     *   Default:  10.0
     *  Identity:   0.0
     * &lt;/pre&gt;
     *
     * @param radius the radius of the shadow blur kernel
     * @throws IllegalArgumentException if {@code radius} is outside the
     * allowable range
     */
    public void setRadius(float radius) {
        float old = shadow.getGaussianRadius();
        invert.setPad((int)Math.ceil(radius));
        shadow.setGaussianRadius(radius);
    }

    public float getGaussianRadius() {
        return shadow.getGaussianRadius();
    }

    public float getGaussianWidth() {
        return shadow.getGaussianWidth();
    }

    public float getGaussianHeight() {
        return shadow.getGaussianHeight();
    }

    public void setGaussianRadius(float r) {
        setRadius(r);
<A NAME="54"></A>    }

    public void setGaussianWidth(float w) {
        float old = <FONT color="#4e8975"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#54',2,'match42-top.html#54',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>shadow.getGaussianWidth();
        float maxr = (Math.max(w, shadow.getGaussianHeight()) - 1.0f) / 2.0f;
        invert.setPad((int) Math.ceil(maxr));
        shadow.setGaussianWidth(w);
    }

    public void setGaussianHeight(float h) {
        float old = shadow.getGaussianHeight()</B></FONT>;
        float maxr = (Math.max(shadow.getGaussianWidth(), h) - 1.0f) / 2.0f;
        invert.setPad((int) Math.ceil(maxr));
        shadow.setGaussianHeight(h);
    }

    /**
     * Gets the choke of the shadow effect.
     *
     * @return the choke of the shadow effect
     */
    public float getChoke() {
        return shadow.getSpread();
    }

    /**
     * Sets the choke of the shadow effect.
     * The choke is the portion of the radius where the contribution of
     * the source material will be 100%.
     * The remaining portion of the radius will have a contribution
     * controlled by the Gaussian kernel.
     * A choke of {@code 0.0} will result in a pure Gaussian distribution
     * of the shadow.
     * A choke of {@code 1.0} will result in a solid growth inward of the
     * shadow from the edges to the limit of the radius with a very sharp
     * cutoff to transparency inside the radius.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 1.0
     *   Default: 0.0
     *  Identity: 0.0
     * &lt;/pre&gt;
     *
     * @param choke the choke of the shadow effect
     * @throws IllegalArgumentException if {@code choke} is outside the
     * allowable range
     */
    public void setChoke(float choke) {
        float old = shadow.getSpread();
        shadow.setSpread(choke);
    }

    /**
     * Returns the shadow color.
     *
     * @return the shadow color
     */
    public Color4f getColor() {
        return shadow.getColor();
    }

    /**
     * Sets the shadow color.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: Color4f.BLACK
     *  Identity: n/a
     * &lt;/pre&gt;
     *
     * @param color the shadow color
     * @throws IllegalArgumentException if {@code color} is null
     */
    public void setColor(Color4f color) {
        Color4f old = shadow.getColor();
        shadow.setColor(color);
    }

    /**
     * Returns the offset in the x direction, in pixels.
     *
     * @return the offset in the x direction, in pixels.
     */
    public int getOffsetX() {
        return invert.getOffsetX();
    }

    /**
     * Sets the offset in the x direction, in pixels.
     * &lt;pre&gt;
     *       Min: Integer.MIN_VALUE
     *       Max: Integer.MAX_VALUE
     *   Default: 0
     *  Identity: 0
     * &lt;/pre&gt;
     *
     * @param xoff the offset in the x direction, in pixels
     */
    public void setOffsetX(int xoff) {
        int old = invert.getOffsetX();
        invert.setOffsetX(xoff);
    }

    /**
     * Returns the offset in the x direction, in pixels.
     *
     * @return the offset in the x direction, in pixels.
     */
    public int getOffsetY() {
        return invert.getOffsetY();
    }

    /**
     * Sets the offset in the y direction, in pixels.
     * &lt;pre&gt;
     *       Min: Integer.MIN_VALUE
     *       Max: Integer.MAX_VALUE
     *   Default: 0
     *  Identity: 0
     * &lt;/pre&gt;
     *
     * @param yoff the offset in the y direction, in pixels
     */
    public void setOffsetY(int yoff) {
        int old = invert.getOffsetY();
        invert.setOffsetY(yoff);
    }

    @Override
    public Point2D transform(Point2D p, Effect defaultInput) {
        return getDefaultedInput(1, defaultInput).transform(p, defaultInput);
    }

    @Override
    public Point2D untransform(Point2D p, Effect defaultInput) {
        return getDefaultedInput(1, defaultInput).untransform(p, defaultInput);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/prism/PrEffectHelper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl.prism;

import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGPerspectiveCamera;
import com.sun.prism.Graphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.EffectPeer;
import com.sun.scenario.effect.impl.ImagePool;

public class PrEffectHelper {

    /**
     * Applies the given filter effect to the series of inputs and then renders
     * the result to the provided {@code Graphics} at the specified
     * location.
     * This method is similar to the following pseudo-code:
     * &lt;pre&gt;
     *     g.drawTexture(effect.filter(g.getTransform()), x, y);
     * &lt;/pre&gt;
     * except that it is likely to be more efficient (and correct).
     *
     * @param effect the effect to be rendered
     * @param g the {@code Graphics} to which the {@code Effect} will be
     *          rendered
     * @param x the x location of the filtered result
     * @param y the y location of the filtered result
     * @param defaultInput the default input {@code Effect} to be used if
     *                     any of the inputs for any of the effects in the
     *                     chain are unspecified (i.e. {@code null}).
     */
    public static void render(Effect effect,
                              Graphics g, float x, float y,
                              Effect defaultInput)
    {
        BaseTransform transform;
        Rectangle rclip = getGraphicsClipNoClone(g);
        BaseTransform origtx = g.getTransformNoClone().copy();
        BaseTransform rendertx;
        if (origtx.is2D()) {
            // process the effect using the current 2D transform, and then
            // render the resulting image in device space (i.e., with identity)
            if (x != 0f || y != 0f || !origtx.isIdentity()) {
                transform = new Affine2D(origtx);
                ((Affine2D) transform).translate(x, y);
            } else {
                transform = BaseTransform.IDENTITY_TRANSFORM;
            }
            g.setTransform(null);
            rendertx = null;
        } else {
            // process the effect with an identity (2D) transform, and then
            // render the resulting image using the current (3D) modelview
            // and/or projection transform
            // RT-27555
            // TODO: this will not work if the effect is applied to a Group
            // that has children with 3D transforms (relative to the Group),
            // but at least it's good enough for simple effects applied to
            // leaf nodes (e.g. applying a Reflection to a leaf ImageView node)
            double scalex = Math.hypot(origtx.getMxx(), origtx.getMyx());
            double scaley = Math.hypot(origtx.getMxy(), origtx.getMyy());
            double scale = Math.max(scalex, scaley);
            if (scale &lt;= 1.0) {
                transform = BaseTransform.IDENTITY_TRANSFORM;
                rendertx = origtx;
            } else {
                transform = BaseTransform.getScaleInstance(scale, scale);
                rendertx = new Affine3D(origtx);
                scale = 1.0 / scale;
                ((Affine3D) rendertx).scale(scale, scale);
            }
            NGCamera cam = g.getCameraNoClone();
            BaseTransform inv;
            try {
                inv = rendertx.createInverse();
            } catch (NoninvertibleTransformException e) {
                return;
            }
            PickRay ray = new PickRay();
            Vec3d tmpvec = new Vec3d();
            // See FilterEffect.untransformClip for a description of
            // why we round in by half a pixel here.
            float x1 = rclip.x + 0.5f;
            float y1 = rclip.y + 0.5f;
            float x2 = rclip.x + rclip.width - 0.5f;
            float y2 = rclip.y + rclip.height - 0.5f;
            double rtw = g.getRenderTarget().getContentWidth();
            double rth = g.getRenderTarget().getContentHeight();
            Point2D cul = project(x1, y1, rtw, rth, cam, inv, ray, tmpvec, null);
            Point2D cur = project(x2, y1, rtw, rth, cam, inv, ray, tmpvec, null);
            Point2D cll = project(x1, y2, rtw, rth, cam, inv, ray, tmpvec, null);
            Point2D clr = project(x2, y2, rtw, rth, cam, inv, ray, tmpvec, null);
            rclip = clipbounds(cul, cur, cll, clr);
        }

        Screen screen = g.getAssociatedScreen();
        FilterContext fctx;
        // RT-27555
        if (screen == null) {
            ResourceFactory factory = g.getResourceFactory();
            fctx = PrFilterContext.getPrinterContext(factory);
        } else {
            fctx = PrFilterContext.getInstance(screen);
        }
        // TODO: Pass the camera down so that nodes can render with it
        // for proper perspective below this level.
        PrRenderInfo prinfo;
        if (rendertx != null) {
            // Whatever results are produced will have to be post-transformed
            // so attempts at direct rendering would use the wrong transform.
            prinfo = null;
        } else if (g.isDepthBuffer() &amp;&amp; g.isDepthTest()) {
            // Some of the multi-step operations may produce both flat image
            // results that would not track the actual Z depth of any direct
            // Node rendering so we must disable direct rendering to avoid
            // depth buffer conflicts.
            prinfo = null;
        } else {
            // If none of the above conditions apply, then the PrRenderInfo
            // can represent all information necessary to directly render
            // any ImageData or Node to the destination.
            prinfo = new PrRenderInfo(g);
        }
        boolean valid;
        ImagePool.numEffects++;

        do {
            ImageData res = effect.filter(fctx, transform, rclip, prinfo, defaultInput);
            if (res == null) return;
            if (valid = res.validate(fctx)) {
                Rectangle r = res.getUntransformedBounds();
                // the actual image may be much larger than the region
                // of interest (&quot;r&quot;), so to improve performance we render
                // only that subregion here
                Texture tex = ((PrTexture)res.getUntransformedImage()).getTextureObject();
                g.setTransform(rendertx);
                g.transform(res.getTransform());
                g.drawTexture(tex, r.x, r.y, r.width, r.height);
            }
            res.unref();
        } while (!valid);
        g.setTransform(origtx);
    }

    static Point2D project(float x, float y, double vw, double vh,
                           NGCamera cam, BaseTransform inv,
                           PickRay tmpray, Vec3d tmpvec, Point2D ret)
    {
        // Calculations in cam.computePickRay are done relative to the
        // view w,h in the camera which may not match our actual view
        // dimensions so we scale them to that rectangle, compute the
        // pick rays, then scale the back to the actual device space before
        // intersecting with our chosen rendering plane.
        double xscale = cam.getViewWidth() / vw;
        double yscale = cam.getViewHeight() / vh;
        x *= xscale;
        y *= yscale;
        tmpray = cam.computePickRay(x, y, tmpray);
        unscale(tmpray.getOriginNoClone(), xscale, yscale);
        unscale(tmpray.getDirectionNoClone(), xscale, yscale);
        return tmpray.projectToZeroPlane(inv, cam instanceof NGPerspectiveCamera,
                                         tmpvec, ret);
    }
    private static void unscale(Vec3d v, double sx, double sy) {
        v.x /= sx;
        v.y /= sy;
    }

    static Rectangle clipbounds(Point2D cul, Point2D cur, Point2D cll, Point2D clr) {
        // Note that 3D perspective transforms frequently deal with infinite
        // values as a plane is rotated towards an end-on view from the eye.
        // The standard ways of getting the bounds of 4 float points tend to
        // ignore overflow, but we would frequently see trouble as objects are
        // flipped over if we didn't have the tests for integer overflow near
        // the bottom of this method.  When those conditions occur it usually
        // means we can see down an arbitrary distance (perhaps to the horizon)
        // on the plane of the node being rendered so we need to render it
        // with no clip to make sure we get all the data for the effect.
        if (cul != null &amp;&amp; cur != null &amp;&amp; cll != null &amp;&amp; clr != null) {
            double x1, y1, x2, y2;
            if (cul.x &lt; cur.x) {
                x1 = cul.x; x2 = cur.x;
            } else {
                x1 = cur.x; x2 = cul.x;
            }
<A NAME="66"></A>            if (cul.y &lt; cur.y) {
                y1 = cul.y; y2 = cur.y;
            } else {
                <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#66',2,'match42-top.html#66',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>y1 = cur.y; y2 = cul.y;
            }
            if (cll.x &lt; clr.x) {
                x1 = Math.min(x1, cll.x); x</B></FONT>2 = Math.max(x2, clr.x);
            } else {
                x1 = Math.min(x1, clr.x); x2 = Math.max(x2, cll.x);
            }
            if (cll.y &lt; clr.y) {
                y1 = Math.min(y1, cll.y); y2 = Math.max(y2, clr.y);
            } else {
                y1 = Math.min(y1, clr.y); y2 = Math.max(y2, cll.y);
            }
            // See FilterEffect.untransformClip for a description of
            // why we round out by half a pixel here.
            x1 = Math.floor(x1-0.5f);
            y1 = Math.floor(y1-0.5f);
            x2 = Math.ceil(x2+0.5f)-x1;
            y2 = Math.ceil(y2+0.5f)-y1;
            int x = (int) x1;
            int y = (int) y1;
            int w = (int) x2;
            int h = (int) y2;
            if (x == x1 &amp;&amp; y == y1 &amp;&amp; w == x2 &amp;&amp; h == y2) {
                // Return a valid rectangle only if we do not overflow,
                // otherwise let the method return a null below for
                // unclipped operation.
                return new Rectangle(x, y, w, h);
            }
        }
        return null;
    }

    public static Rectangle getGraphicsClipNoClone(Graphics g) {
        Rectangle rclip = g.getClipRectNoClone();
        if (rclip == null) {
            RenderTarget rt = g.getRenderTarget();
            rclip = new Rectangle(rt.getContentWidth(), rt.getContentHeight());
        }
        return rclip;
    }

    public static void renderImageData(Graphics gdst,
                                       ImageData srcData,
                                       Rectangle dstBounds)
    {
        int w = dstBounds.width;
        int h = dstBounds.height;
        PrDrawable src = (PrDrawable) srcData.getUntransformedImage();
        BaseTransform srcTx = srcData.getTransform();
        Rectangle srcBounds = srcData.getUntransformedBounds();
        float dx1 = 0f;
        float dy1 = 0f;
        float dx2 = dx1 + w;
        float dy2 = dy1 + h;
        if (srcTx.isTranslateOrIdentity()) {
            float tx = (float) srcTx.getMxt();
            float ty = (float) srcTx.getMyt();
            float sx1 = dstBounds.x - (srcBounds.x + tx);
            float sy1 = dstBounds.y - (srcBounds.y + ty);
            float sx2 = sx1 + w;
            float sy2 = sy1 + h;
            gdst.drawTexture(src.getTextureObject(),
                             dx1, dy1, dx2, dy2,
                             sx1, sy1, sx2, sy2);
        } else {
            float[] srcRect = new float[8];
            int srcCoords =
                EffectPeer.getTextureCoordinates(srcRect,
                                                 srcBounds.x, srcBounds.y,
                                                 src.getPhysicalWidth(),
                                                 src.getPhysicalHeight(),
                                                 dstBounds, srcTx);
            if (srcCoords &lt; 8) {
                gdst.drawTextureRaw(src.getTextureObject(),
                                    dx1, dy1, dx2, dy2,
                                    srcRect[0], srcRect[1],
                                    srcRect[2], srcRect[3]);
            } else {
                gdst.drawMappedTextureRaw(src.getTextureObject(),
                                          dx1, dy1, dx2, dy2,
                                          srcRect[0], srcRect[1],
                                          srcRect[4], srcRect[5],
                                          srcRect[6], srcRect[7],
                                          srcRect[2], srcRect[3]);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/prism/PrReflectionPeer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl.prism;

import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.prism.Graphics;
import com.sun.prism.Texture;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.Reflection;
import com.sun.scenario.effect.impl.EffectPeer;
import com.sun.scenario.effect.impl.Renderer;
import com.sun.scenario.effect.impl.state.RenderState;

public class PrReflectionPeer extends EffectPeer {

    public PrReflectionPeer(FilterContext fctx, Renderer r, String uniqueName) {
        super(fctx, r, uniqueName);
    }

    @Override
    public ImageData filter(Effect effect,
                            RenderState rstate,
                            BaseTransform transform,
                            Rectangle outputClip,
                            ImageData... inputs)
    {
        FilterContext fctx = getFilterContext();
        Reflection reflect = (Reflection)effect;

        Rectangle inputbounds = inputs[0].getUntransformedBounds();
        int srcW = inputbounds.width;
        int srcH = inputbounds.height;
        float refY = srcH + reflect.getTopOffset();
        float refH = reflect.getFraction() * srcH;
        int irefY1 = (int) Math.floor(refY);
        int irefY2 = (int) Math.ceil(refY + refH);
        int irefH = irefY2 - irefY1;

        int dstH = (irefY2 &gt; srcH) ? irefY2 : srcH;
        // RT-27389: take clipping into account...
        PrDrawable dst = (PrDrawable)getRenderer().getCompatibleImage(srcW, dstH);
        if (!inputs[0].validate(fctx) || dst == null) {
<A NAME="1"></A>            return new ImageData(fctx, null, inputbounds);
        }
        PrDrawable src = (PrDrawable)inputs[0].getUntransformedImage();
        Texture srctex = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#1',2,'match42-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>src.getTextureObject();

        Graphics gdst = dst.createGraphics();
        gdst.transform(inputs[0].getTransform());
        float sx1 = 0f;
        float sy1 = srcH-irefH;
        float sx2 = srcW;
        float sy2 = srcH</B></FONT>;
        gdst.drawTextureVO(srctex,
                           reflect.getBottomOpacity(),
                           reflect.getTopOpacity(),
                           0, irefY2, srcW, irefY1,
                           sx1, sy1, sx2, sy2);
        gdst.drawTexture(srctex, 0, 0, srcW, srcH);

        Rectangle newbounds =
            new Rectangle(inputbounds.x, inputbounds.y, srcW, dstH);
        return new ImageData(fctx, dst, newbounds);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/concurrent/ScheduledService.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.concurrent;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.util.Callback;
import javafx.util.Duration;
import java.util.Timer;
import java.util.TimerTask;

/**
 * &lt;p&gt;The ScheduledService is a {@link Service} which will automatically restart
 * itself after a successful execution, and under some conditions will
 * restart even in case of failure. A new ScheduledService begins in
 * the READY state, just as a normal Service. After calling
 * &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;restart&lt;/code&gt;, the ScheduledService will
 * enter the SCHEDULED state for the duration specified by &lt;code&gt;delay&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Once RUNNING, the ScheduledService will execute its Task. On successful
 * completion, the ScheduledService will transition to the SUCCEEDED state,
 * and then to the READY state and back to the SCHEDULED state. The amount
 * of time the ScheduledService will remain in this state depends on the
 * amount of time between the last state transition to RUNNING, and the
 * current time, and the &lt;code&gt;period&lt;/code&gt;. In short, the &lt;code&gt;period&lt;/code&gt;
 * defines the minimum amount of time from the start of one run and the start of
 * the next. If the previous execution completed before &lt;code&gt;period&lt;/code&gt; expires,
 * then the ScheduledService will remain in the SCHEDULED state until the period
 * expires. If on the other hand the execution took longer than the
 * specified period, then the ScheduledService will immediately transition
 * back to RUNNING. &lt;/p&gt;
 *
 * &lt;p&gt;If, while RUNNING, the ScheduledService's Task throws an error or in
 * some other way ends up transitioning to FAILED, then the ScheduledService
 * will either restart or quit, depending on the values for
 * &lt;code&gt;backoffStrategy&lt;/code&gt;, &lt;code&gt;restartOnFailure&lt;/code&gt;, and
 * &lt;code&gt;maximumFailureCount&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;If a failure occurs and &lt;code&gt;restartOnFailure&lt;/code&gt; is false, then
 * the ScheduledService will transition to FAILED and will stop. To restart
 * a failed ScheduledService, you must call restart manually.&lt;/p&gt;
 *
 * &lt;p&gt;If a failure occurs and &lt;code&gt;restartOnFailure&lt;/code&gt; is true, then
 * the the ScheduledService &lt;em&gt;may&lt;/em&gt; restart automatically. First,
 * the result of calling &lt;code&gt;backoffStrategy&lt;/code&gt; will become the
 * new &lt;code&gt;cumulativePeriod&lt;/code&gt;. In this way, after each failure, you can cause
 * the service to wait a longer and longer period of time before restarting.
 * Once the task completes successfully, the cumulativePeriod is reset to
 * the value of &lt;code&gt;period&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;ScheduledService defines static EXPONENTIAL_BACKOFF_STRATEGY and LOGARITHMIC_BACKOFF_STRATEGY
 * implementations, of which LOGARITHMIC_BACKOFF_STRATEGY is the default value for
 * backoffStrategy. After &lt;code&gt;maximumFailureCount&lt;/code&gt; is reached, the
 * ScheduledService will transition to FAILED in exactly the same way as if
 * &lt;code&gt;restartOnFailure&lt;/code&gt; were false.&lt;/p&gt;
 *
 * &lt;p&gt;If the &lt;code&gt;period&lt;/code&gt; or &lt;code&gt;delay&lt;/code&gt; is changed while the
 * ScheduledService is running, the new values will be taken into account on the
 * next iteration. For example, if the &lt;code&gt;period&lt;/code&gt; is increased, then the next time the
 * ScheduledService enters the SCHEDULED state, the new &lt;code&gt;period&lt;/code&gt; will be used.
 * Likewise, if the &lt;code&gt;delay&lt;/code&gt; is changed, the new value will be honored on
 * the next restart or reset/start.&lt;/p&gt;
 *
 * The ScheduledService is typically used for use cases that involve polling. For
 * example, you may want to ping a server on a regular basis to see if there are
 * any updates. Such as ScheduledService might be implemented like this:
 *
 * &lt;pre&gt;&lt;code&gt;
 * {@literal ScheduledService&lt;Document&gt; svc = new ScheduledService&lt;Document&gt;()} {
 *     {@literal protected Task&lt;Document&gt; createTask()} {
 *         {@literal return new Task&lt;Document&gt;()} {
 *             protected Document call() {
 *                 // Connect to a Server
 *                 // Get the XML document
 *                 // Parse it into a document
 *                 return document;
 *             }
 *         };
 *     }
 * };
 * svc.setPeriod(Duration.seconds(1));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * This example will ping the remote server every 1 second.
 *
 * &lt;p&gt;Timing for this class is not absolutely reliable. A very busy event thread might introduce some timing
 * lag into the beginning of the execution of the background Task, so very small values for the period or
 * delay are likely to be inaccurate. A delay or period in the hundreds of milliseconds or larger should be
 * fairly reliable.&lt;/p&gt;
 *
 * &lt;p&gt;The ScheduledService in its default configuration has a default &lt;code&gt;period&lt;/code&gt; of 0 and a
 * default &lt;code&gt;delay&lt;/code&gt; of 0. This will cause the ScheduledService to execute the task immediately
 * upon {@link #start()}, and re-executing immediately upon successful completion.&lt;/p&gt;
 *
 * &lt;p&gt;For this purposes of this class, any Duration that answers true to {@link javafx.util.Duration#isUnknown()}
 * will treat that duration as if it were Duration.ZERO. Likewise, any Duration which answers true
 * to {@link javafx.util.Duration#isIndefinite()} will be treated as if it were a duration of Double.MAX_VALUE
 * milliseconds. Any null Duration is treated as Duration.ZERO. Any custom implementation of an backoff strategy
 * callback must be prepared to handle these different potential values.&lt;/p&gt;
 *
 * &lt;p&gt;The ScheduledService introduces a new property called {@link #lastValueProperty() lastValue}. The lastValue is the value that
 * was last successfully computed. Because a Service clears its {@code value} property on each run, and
 * because the ScheduledService will reschedule a run immediately after completion (unless it enters the
 * cancelled or failed states), the value property is not overly useful on a ScheduledService. In most cases
 * you will want to instead use the value returned by lastValue.&lt;/p&gt;
 *
 * &lt;b&gt;Implementer Note:&lt;/b&gt; The {@link #ready()}, {@link #scheduled()}, {@link #running()}, {@link #succeeded()},
 * {@link #cancelled()}, and {@link #failed()} methods are implemented in this class. Subclasses which also
 * override these methods must take care to invoke the super implementation.
 *
 * @param &lt;V&gt; The computed value of the ScheduledService
 * @since JavaFX 8.0
 */
public abstract class ScheduledService&lt;V&gt; extends Service&lt;V&gt; {
    /**
     * A Callback implementation for the &lt;code&gt;backoffStrategy&lt;/code&gt; property which
     * will exponentially backoff the period between re-executions in the case of
     * a failure. This computation takes the original period and the number of
     * consecutive failures and computes the backoff amount from that information.
     *
     * &lt;p&gt;If the {@code service} is null, then Duration.ZERO is returned. If the period is 0 then
     * the result of this method will simply be {@code Math.exp(currentFailureCount)}. In all other cases,
     * the returned value is the same as {@code period + (period * Math.exp(currentFailureCount))}.&lt;/p&gt;
     */
    public static final Callback&lt;ScheduledService&lt;?&gt;, Duration&gt; EXPONENTIAL_BACKOFF_STRATEGY
            = new Callback&lt;ScheduledService&lt;?&gt;, Duration&gt;() {
        @Override public Duration call(ScheduledService&lt;?&gt; service) {
            if (service == null) return Duration.ZERO;
            final double period = service.getPeriod() == null ? 0 : service.getPeriod().toMillis();
            final double x = service.getCurrentFailureCount();
            return Duration.millis(period == 0 ? Math.exp(x) : period + (period * Math.exp(x)));
        }
    };

    /**
     * A Callback implementation for the &lt;code&gt;backoffStrategy&lt;/code&gt; property which
     * will logarithmically backoff the period between re-executions in the case of
     * a failure. This computation takes the original period and the number of
     * consecutive failures and computes the backoff amount from that information.
     *
     * &lt;p&gt;If the {@code service} is null, then Duration.ZERO is returned. If the period is 0 then
     * the result of this method will simply be {@code Math.log1p(currentFailureCount)}. In all other cases,
     * the returned value is the same as {@code period + (period * Math.log1p(currentFailureCount))}.&lt;/p&gt;
     */
    public static final Callback&lt;ScheduledService&lt;?&gt;, Duration&gt; LOGARITHMIC_BACKOFF_STRATEGY
            = new Callback&lt;ScheduledService&lt;?&gt;, Duration&gt;() {
        @Override public Duration call(ScheduledService&lt;?&gt; service) {
            if (service == null) return Duration.ZERO;
            final double period = service.getPeriod() == null ? 0 : service.getPeriod().toMillis();
            final double x = service.getCurrentFailureCount();
            return Duration.millis(period == 0 ? Math.log1p(x) : period + (period * Math.log1p(x)));
        }
    };

    /**
     * A Callback implementation for the &lt;code&gt;backoffStrategy&lt;/code&gt; property which
     * will linearly backoff the period between re-executions in the case of
     * a failure. This computation takes the original period and the number of
     * consecutive failures and computes the backoff amount from that information.
     *
     * &lt;p&gt;If the {@code service} is null, then Duration.ZERO is returned. If the period is 0 then
     * the result of this method will simply be {@code currentFailureCount}. In all other cases,
     * the returned value is the same as {@code period + (period * currentFailureCount)}.&lt;/p&gt;
     */
    public static final Callback&lt;ScheduledService&lt;?&gt;, Duration&gt; LINEAR_BACKOFF_STRATEGY
            = new Callback&lt;ScheduledService&lt;?&gt;, Duration&gt;() {
        @Override public Duration call(ScheduledService&lt;?&gt; service) {
            if (service == null) return Duration.ZERO;
            final double period = service.getPeriod() == null ? 0 : service.getPeriod().toMillis();
            final double x = service.getCurrentFailureCount();
            return Duration.millis(period == 0 ? x : period + (period * x));
        }
    };

    /**
     * This Timer is used to schedule the delays for each ScheduledService. A single timer
     * ought to be able to easily service thousands of ScheduledService objects.
     */
    private static final Timer DELAY_TIMER = new Timer(&quot;ScheduledService Delay Timer&quot;, true);

    /**
     * The initial delay between when the ScheduledService is first started, and when it will begin
     * operation. This is the amount of time the ScheduledService will remain in the SCHEDULED state,
     * before entering the RUNNING state, following a fresh invocation of {@link #start()} or {@link #restart()}.
     */
    private ObjectProperty&lt;Duration&gt; delay = new SimpleObjectProperty&lt;&gt;(this, &quot;delay&quot;, Duration.ZERO);
    public final Duration getDelay() { return delay.get(); }
    public final void setDelay(Duration value) { delay.set(value); }
    public final ObjectProperty&lt;Duration&gt; delayProperty() { return delay; }

    /**
     * The minimum amount of time to allow between the start of the last run and the start of the next run.
     * The actual period (also known as &lt;code&gt;cumulativePeriod&lt;/code&gt;)
     * will depend on this property as well as the &lt;code&gt;backoffStrategy&lt;/code&gt; and number of failures.
     */
    private ObjectProperty&lt;Duration&gt; period = new SimpleObjectProperty&lt;&gt;(this, &quot;period&quot;, Duration.ZERO);
    public final Duration getPeriod() { return period.get(); }
    public final void setPeriod(Duration value) { period.set(value); }
    public final ObjectProperty&lt;Duration&gt; periodProperty() { return period; }

    /**
     * Computes the amount of time to add to the period on each failure. This cumulative amount is reset whenever
     * the the ScheduledService is manually restarted.
     */
    private ObjectProperty&lt;Callback&lt;ScheduledService&lt;?&gt;,Duration&gt;&gt; backoffStrategy =
            new SimpleObjectProperty&lt;&gt;(this, &quot;backoffStrategy&quot;, LOGARITHMIC_BACKOFF_STRATEGY);
    public final Callback&lt;ScheduledService&lt;?&gt;,Duration&gt; getBackoffStrategy() { return backoffStrategy.get(); }
    public final void setBackoffStrategy(Callback&lt;ScheduledService&lt;?&gt;, Duration&gt; value) { backoffStrategy.set(value); }
    public final ObjectProperty&lt;Callback&lt;ScheduledService&lt;?&gt;,Duration&gt;&gt; backoffStrategyProperty() { return backoffStrategy; }

    /**
     * Indicates whether the ScheduledService should automatically restart in the case of a failure in the Task.
     */
    private BooleanProperty restartOnFailure = new SimpleBooleanProperty(this, &quot;restartOnFailure&quot;, true);
    public final boolean getRestartOnFailure() { return restartOnFailure.get(); }
    public final void setRestartOnFailure(boolean value) { restartOnFailure.set(value); }
    public final BooleanProperty restartOnFailureProperty() { return restartOnFailure; }

    /**
     * The maximum number of times the ScheduledService can fail before it simply ends in the FAILED
     * state. You can of course restart the ScheduledService manually, which will cause the current
     * count to be reset.
     */
    private IntegerProperty maximumFailureCount = new SimpleIntegerProperty(this, &quot;maximumFailureCount&quot;, Integer.MAX_VALUE);
    public final int getMaximumFailureCount() { return maximumFailureCount.get(); }
    public final void setMaximumFailureCount(int value) { maximumFailureCount.set(value); }
    public final IntegerProperty maximumFailureCountProperty() { return maximumFailureCount; }

    /**
     * The current number of times the ScheduledService has failed. This is reset whenever the
     * ScheduledService is manually restarted.
     */
    private ReadOnlyIntegerWrapper currentFailureCount = new ReadOnlyIntegerWrapper(this, &quot;currentFailureCount&quot;, 0);
    public final int getCurrentFailureCount() { return currentFailureCount.get(); }
    public final ReadOnlyIntegerProperty currentFailureCountProperty() { return currentFailureCount.getReadOnlyProperty(); }
    private void setCurrentFailureCount(int value) {
        currentFailureCount.set(value);
    }

    /**
     * The current cumulative period in use between iterations. This will be the same as &lt;code&gt;period&lt;/code&gt;,
     * except after a failure, in which case the result of the backoffStrategy will be used as the cumulative period
     * following each failure. This is reset whenever the ScheduledService is manually restarted or an iteration
     * is successful. The cumulativePeriod is modified when the ScheduledService enters the scheduled state.
     * The cumulativePeriod can be capped by setting the {@code maximumCumulativePeriod}.
     */
    private ReadOnlyObjectWrapper&lt;Duration&gt; cumulativePeriod = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;cumulativePeriod&quot;, Duration.ZERO);
    public final Duration getCumulativePeriod() { return cumulativePeriod.get(); }
    public final ReadOnlyObjectProperty&lt;Duration&gt; cumulativePeriodProperty() { return cumulativePeriod.getReadOnlyProperty(); }
    void setCumulativePeriod(Duration value) { // package private for testing
        // Make sure any null value is turned into ZERO
        Duration newValue = value == null || value.toMillis() &lt; 0 ? Duration.ZERO : value;
        // Cap the newValue based on the maximumCumulativePeriod.
        Duration maxPeriod = maximumCumulativePeriod.get();
        if (maxPeriod != null &amp;&amp; !maxPeriod.isUnknown() &amp;&amp; !newValue.isUnknown()) {
            if (maxPeriod.toMillis() &lt; 0) {
                newValue = Duration.ZERO;
            } else if (!maxPeriod.isIndefinite() &amp;&amp; newValue.greaterThan(maxPeriod)) {
                newValue = maxPeriod;
            }
        }
        cumulativePeriod.set(newValue);
    }

    /**
     * The maximum allowed value for the cumulativePeriod. Setting this value will help ensure that in the case of
     * repeated failures the back-off algorithm doesn't end up producing unreasonably large values for
     * cumulative period. The cumulative period is guaranteed not to be any larger than this value. If the
     * maximumCumulativePeriod is negative, then cumulativePeriod will be capped at 0. If maximumCumulativePeriod
     * is NaN or null, then it will not influence the cumulativePeriod.
     */
    private ObjectProperty&lt;Duration&gt; maximumCumulativePeriod = new SimpleObjectProperty&lt;&gt;(this, &quot;maximumCumulativePeriod&quot;, Duration.INDEFINITE);
    public final Duration getMaximumCumulativePeriod() { return maximumCumulativePeriod.get(); }
    public final void setMaximumCumulativePeriod(Duration value) { maximumCumulativePeriod.set(value); }
    public final ObjectProperty&lt;Duration&gt; maximumCumulativePeriodProperty() { return maximumCumulativePeriod; }

    /**
     * The last successfully computed value. During each iteration, the &quot;value&quot; of the ScheduledService will be
     * reset to null, as with any other Service. The &quot;lastValue&quot; however will be set to the most recently
     * successfully computed value, even across iterations. It is reset however whenever you manually call
     * reset or restart.
     */
    private ReadOnlyObjectWrapper&lt;V&gt; lastValue = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;lastValue&quot;, null);
    public final V getLastValue() { return lastValue.get(); }
    public final ReadOnlyObjectProperty&lt;V&gt; lastValueProperty() { return lastValue.getReadOnlyProperty(); }

    /**
     * The timestamp of the last time the task was run. This is used to compute the amount
     * of delay between successive iterations by taking the cumulativePeriod into account.
     */
    private long lastRunTime = 0L;

    /**
     * Whether or not this iteration is a &quot;fresh start&quot;, such as the initial call to start,
     * or a call to restart, or a call to reset followed by a call to start.
     */
    private boolean freshStart = true;

    /**
     * This is a TimerTask scheduled with the DELAY_TIMER. All it does is kick off the execution
     * of the actual background Task.
     */
    private TimerTask delayTask = null;

    /**
     * This is set to false when the &quot;cancel&quot; method is called, and reset to true on &quot;reset&quot;.
     * We need this so that any time the developer calls 'cancel', even when from within one
     * of the event handlers, it will cause us to transition to the cancelled state.
     */
    private boolean stop = false;

    // This method is invoked by Service to actually execute the task. In the normal implementation
    // in Service, this method will simply delegate to the Executor. In ScheduledService, however,
    // we instead will delay the correct amount of time before we finally invoke executeTaskNow,
    // which is where we end up delegating to the executor.
    @Override protected void executeTask(final Task&lt;V&gt; task) {
        assert task != null;
        checkThread();

        if (freshStart) {
            // The delayTask should have concluded and been made null by this point.
            // If not, then somehow we were paused waiting for another iteration and
            // somebody caused the system to run again. However resetting things should
            // have cleared the delayTask.
            assert delayTask == null;

            // The cumulativePeriod needs to be initialized
            setCumulativePeriod(getPeriod());

            // Pause for the &quot;delay&quot; amount of time and then execute
            final long d = (long) normalize(getDelay());
            if (d == 0) {
                // If the delay is zero or null, then just start immediately
                executeTaskNow(task);
            } else {
                schedule(delayTask = createTimerTask(task), d);
            }
        } else {
            // We are executing as a result of an iteration, not a fresh start.
            // If the runPeriod (time between the last run and now) exceeds the cumulativePeriod, then
            // we need to execute immediately. Otherwise, we will pause until the cumulativePeriod has
            // been reached, and then run.
            double cumulative = normalize(getCumulativePeriod()); // Can never be null.
            double runPeriod = clock() - lastRunTime;
            if (runPeriod &lt; cumulative) {
                // Pause and then execute
                assert delayTask == null;
                schedule(delayTask = createTimerTask(task), (long) (cumulative - runPeriod));
            } else {
                // Execute immediately
<A NAME="37"></A>                executeTaskNow(task);
            }
        }
    <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#37',2,'match42-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * {@inheritDoc}
     *
     * Implementation Note: Subclasses which override this method must call this super implementation.
     */
    @Override protected void succeeded() {
        super.succeeded();
        lastValue.set(getValue());
        // Reset the cumulative time
        Duration d = getPeriod();
        setCumulativePeriod(d);
        // Have to save this off, since it will be reset here in a second
        final boolean wasCancelled = stop;
        // Call the super implementation of reset, which will not cause us
        // to think this is a new fresh start.
        superReset</B></FONT>();
        assert freshStart == false;
        // If it was cancelled then we will progress from READY to SCHEDULED to CANCELLED so that
        // the lifecycle changes are predictable according to the Service specification.
        if (wasCancelled) {
            cancelFromReadyState();
        } else {
            // Fire it up!
            start();
        }
    }

    /**
     * {@inheritDoc}
     *
     * Implementation Note: Subclasses which override this method must call this super implementation.
     */
    @Override protected void failed() {
        super.failed();
        assert delayTask == null;
        // Restart as necessary
        setCurrentFailureCount(getCurrentFailureCount() + 1);
        if (getRestartOnFailure() &amp;&amp; getMaximumFailureCount() &gt; getCurrentFailureCount()) {
            // We've not yet maxed out the number of failures we can
            // encounter, so we're going to iterate
            Callback&lt;ScheduledService&lt;?&gt;,Duration&gt; func = getBackoffStrategy();
            if (func != null) {
                Duration d = func.call(this);
                setCumulativePeriod(d);
            }

            superReset();
            assert freshStart == false;
            start();
        } else {
            // We've maxed out, so do nothing and things will just stop.
        }
    }

    /**
     * {@inheritDoc}
     *
     * Implementation Note: Subclasses which override this method must call this super implementation.
     */
    @Override public void reset() {
        super.reset();
        stop = false;
        setCumulativePeriod(getPeriod());
        lastValue.set(null);
        setCurrentFailureCount(0);
        lastRunTime = 0L;
        freshStart = true;
    }

    /**
     * Cancels any currently running task and stops this scheduled service, such that
     * no additional iterations will occur.
     *
     * @return whether any running task was cancelled, false if no task was cancelled.
     *         In any case, the ScheduledService will stop iterating.
     */
    @Override public boolean cancel() {
        boolean ret = super.cancel();
        stop = true;
        if (delayTask != null) {
            delayTask.cancel();
            delayTask = null;
        }
        return ret;
    }

    /**
     * This method exists only for testing purposes. The normal implementation
     * will delegate to a java.util.Timer, however during testing we want to simply
     * inspect the value for the delay and execute immediately.
     * @param task not null
     * @param delay &amp;gt;= 0
     */
    void schedule(TimerTask task, long delay) {
        DELAY_TIMER.schedule(task, delay);
    }

    /**
     * This method only exists for the sake of testing.
     * @return freshStart
     */
    boolean isFreshStart() { return freshStart; }

    /**
     * Gets the time of the current clock. At runtime this is simply getting the results
     * of System.currentTimeMillis, however during testing this is hammered so as to return
     * a time that works well during testing.
     * @return The clock time
     */
    long clock() {
        return System.currentTimeMillis();
    }

    /**
     * Called by this class when we need to avoid calling this class' implementation of
     * reset which has the side effect of resetting the &quot;freshStart&quot;, currentFailureCount,
     * and other state.
     */
    private void superReset() {
        super.reset();
    }

    /**
     * Creates the TimerTask used for delaying execution. The delay can either be due to
     * the initial delay (if this is a freshStart), or it can be the computed delay in order
     * to execute the task on its fixed schedule.
     *
     * @param task must not be null.
     * @return the delay TimerTask.
     */
    private TimerTask createTimerTask(final Task&lt;V&gt; task) {
        assert task != null;
        return new TimerTask() {
            @Override public void run() {
                Runnable r = () -&gt; {
                    executeTaskNow(task);
                    delayTask = null;
                };

                // We must make sure that executeTaskNow is called from the FX thread.
                // This must happen on th FX thread because the super implementation of
                // executeTask is going to call getExecutor so it can use any user supplied
                // executor, and this property can only be read on the FX thread.
                if (isFxApplicationThread()) {
                    r.run();
                } else {
                    runLater(r);
                }
            }
        };
    }

    /**
     * Called when it is time to actually execute the task (any delay has by now been
     * accounted for). Essentially this ends up simply calling the super implementation
     * of executeTask and doing some bookkeeping.
     *
     * @param task must not be null
     */
    private void executeTaskNow(Task&lt;V&gt; task) {
        assert task != null;
        lastRunTime = clock();
        freshStart = false;
        super.executeTask(task);
    }

    /**
     * Normalize our handling of Durations according to the class documentation.
     * @param d can be null
     * @return a double representing the millis.
     */
    private static double normalize(Duration d) {
        if (d == null || d.isUnknown()) return 0;
        if (d.isIndefinite()) return Double.MAX_VALUE;
        return d.toMillis();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/css/CssParser.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.css;

import com.sun.javafx.css.Combinator;
import com.sun.javafx.css.FontFaceImpl;
import com.sun.javafx.css.ParsedValueImpl;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.util.Utils;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.DurationConverter;
import javafx.css.converter.EffectConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.FontConverter;
import javafx.css.converter.InsetsConverter;
import javafx.css.converter.PaintConverter;
import javafx.css.converter.SizeConverter;
import javafx.css.converter.SizeConverter.SequenceConverter;
import javafx.css.converter.StringConverter;
import javafx.css.converter.URLConverter;
import javafx.css.converter.DeriveColorConverter;
import javafx.css.converter.LadderConverter;
import javafx.css.converter.StopConverter;
import com.sun.javafx.css.parser.Token;
import com.sun.javafx.scene.layout.region.BackgroundPositionConverter;
import com.sun.javafx.scene.layout.region.BackgroundSizeConverter;
import com.sun.javafx.scene.layout.region.BorderImageSliceConverter;
import com.sun.javafx.scene.layout.region.BorderImageSlices;
import com.sun.javafx.scene.layout.region.BorderImageWidthConverter;
import com.sun.javafx.scene.layout.region.BorderImageWidthsSequenceConverter;
import com.sun.javafx.scene.layout.region.BorderStrokeStyleSequenceConverter;
import com.sun.javafx.scene.layout.region.BorderStyleConverter;
import com.sun.javafx.scene.layout.region.CornerRadiiConverter;
import com.sun.javafx.scene.layout.region.LayeredBackgroundPositionConverter;
import com.sun.javafx.scene.layout.region.LayeredBackgroundSizeConverter;
import com.sun.javafx.scene.layout.region.LayeredBorderPaintConverter;
import com.sun.javafx.scene.layout.region.LayeredBorderStyleConverter;
import com.sun.javafx.scene.layout.region.Margins;
import com.sun.javafx.scene.layout.region.RepeatStruct;
import com.sun.javafx.scene.layout.region.RepeatStructConverter;
import com.sun.javafx.scene.layout.region.SliceSequenceConverter;
import com.sun.javafx.scene.layout.region.StrokeBorderPaintConverter;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.effect.BlurType;
import javafx.scene.effect.Effect;
import javafx.scene.layout.BackgroundPosition;
import javafx.scene.layout.BackgroundRepeat;
import javafx.scene.layout.BackgroundSize;
import javafx.scene.layout.BorderStrokeStyle;
import javafx.scene.layout.BorderWidths;
import javafx.scene.layout.CornerRadii;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.Paint;
import javafx.scene.paint.Stop;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;


import java.io.BufferedReader;
import java.io.CharArrayReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Stack;

/**
 * @since 9
 */
final public class CssParser {

    public CssParser() {
        properties = new HashMap&lt;String,String&gt;();
    }

    // stylesheet as a string from parse method. This will be null if the
    // stylesheet is being parsed from a file; otherwise, the parser is parsing
    // a string and this is that string.
    private String     stylesheetAsText;

    // the url of the stylesheet file, or the docbase of an applet. This will
    // be null if the source is not a file or from an applet.
    private String        sourceOfStylesheet;

    // the Styleable from the node with an in-line style. This will be null
    // unless the source of the styles is a Node's styleProperty. In this case,
    // the stylesheetString will also be set.
    private Styleable sourceOfInlineStyle;

    // source is a file
    private void setInputSource(String url, String str) {
        stylesheetAsText = str;
        sourceOfStylesheet = url;
        sourceOfInlineStyle = null;
    }

    // source as string only
    private void setInputSource(String str) {
        stylesheetAsText = str;
        sourceOfStylesheet = null;
        sourceOfInlineStyle = null;
    }

    // source is in-line style
    private void setInputSource(Styleable styleable) {
        stylesheetAsText = styleable != null ? styleable.getStyle() : null;
        sourceOfStylesheet = null;
        sourceOfInlineStyle = styleable;
    }

    private static final PlatformLogger LOGGER = com.sun.javafx.util.Logging.getCSSLogger();

    private static final class ParseException extends Exception {
        ParseException(String message) {
            this(message,null,null);
        }
        ParseException(String message, Token tok, CssParser parser) {
            super(message);
            this.tok = tok;
            if (parser.sourceOfStylesheet != null) {
                source = parser.sourceOfStylesheet;
            } else if (parser.sourceOfInlineStyle != null) {
                source = parser.sourceOfInlineStyle.toString();
            } else if (parser.stylesheetAsText != null) {
                source = parser.stylesheetAsText;
            } else {
                source = &quot;?&quot;;
            }
        }
        @Override public String toString() {
            StringBuilder builder = new StringBuilder(super.getMessage());
            builder.append(source);
            if (tok != null) builder.append(&quot;: &quot;).append(tok.toString());
            return builder.toString();
        }
        private final Token tok;
        private final String source;
    }

    /**
     * Creates a stylesheet from a CSS document string.
     *
     * @param stylesheetText the CSS document to parse
     * @return the Stylesheet
     */
    public Stylesheet parse(final String stylesheetText) {
        final Stylesheet stylesheet = new Stylesheet();
        if (stylesheetText != null &amp;&amp; !stylesheetText.trim().isEmpty()) {
            setInputSource(stylesheetText);
            try (Reader reader = new CharArrayReader(stylesheetText.toCharArray())) {
                parse(stylesheet, reader);
            } catch (IOException ioe) {
                // this method doesn't explicitly throw IOException
            }
        }
        return stylesheet;
    }

    /**
     * Creates a stylesheet from a CSS document string using docbase as the base
     * URL for resolving references within stylesheet.
     *
     * @param docbase the doc base for resolving URL references
     * @param stylesheetText the CSS document to parse
     * @return the Stylesheet
     * @throws java.io.IOException the exception
     */
    public Stylesheet parse(final String docbase, final String stylesheetText) throws IOException {
        final Stylesheet stylesheet = new Stylesheet(docbase);
        if (stylesheetText != null &amp;&amp; !stylesheetText.trim().isEmpty()) {
            setInputSource(docbase, stylesheetText);
            try (Reader reader = new CharArrayReader(stylesheetText.toCharArray())) {
                parse(stylesheet, reader);
            }
        }
        return stylesheet;
    }

    /**
     * Updates the given stylesheet by reading a CSS document from a URL,
     * assuming UTF-8 encoding.
     *
     *@param  url URL of the stylesheet to parse
     *@return the stylesheet
     *@throws IOException the exception
     */
    public Stylesheet parse(final URL url) throws IOException {

        final String path = url != null ? url.toExternalForm() : null;
        final Stylesheet stylesheet = new Stylesheet(path);
        if (url != null) {
            setInputSource(path, null);
            try (Reader reader = new BufferedReader(new InputStreamReader(url.openStream()))) {
                parse(stylesheet, reader);
            }
        }
        return stylesheet;
    }

    /* All of the other function calls should wind up here */
    private void parse(final Stylesheet stylesheet, final Reader reader) {
        CssLexer lex = new CssLexer();
        lex.setReader(reader);

        try {
            this.parse(stylesheet, lex);
        } catch (Exception ex) {
            // Sometimes bad syntax causes an exception. The code should be
            // fixed to handle the bad syntax, but the fallback is
            // to handle the exception here. Uncaught, the exception can cause
            // problems like RT-20311
            reportException(ex);
        }

    }

    /** Parse an in-line style from a Node.
     * @param node the styleable node
     * @return the style sheet
     */
    public Stylesheet parseInlineStyle(final Styleable node) {

        Stylesheet stylesheet = new Stylesheet();

        final String stylesheetText = (node != null) ? node.getStyle() : null;
        if (stylesheetText != null &amp;&amp; !stylesheetText.trim().isEmpty()) {
            setInputSource(node);
            final List&lt;Rule&gt; rules = new ArrayList&lt;Rule&gt;();
            try (Reader reader = new CharArrayReader(stylesheetText.toCharArray())) {
                final CssLexer lexer = new CssLexer();
                lexer.setReader(reader);
                currentToken = nextToken(lexer);
                final List&lt;Declaration&gt; declarations = declarations(lexer);
                if (declarations != null &amp;&amp; !declarations.isEmpty()) {
                    final Selector selector = Selector.getUniversalSelector();
                    final Rule rule = new Rule(
                        Collections.singletonList(selector),
                        declarations
                    );
                    rules.add(rule);
                }
            } catch (IOException ioe) {
            } catch (Exception ex) {
                // Sometimes bad syntax causes an exception. The code should be
                // fixed to handle the bad syntax, but the fallback is
                // to handle the exception here. Uncaught, the exception can cause
                // problems like RT-20311
                reportException(ex);
            }
            stylesheet.getRules().addAll(rules);
        }

        // don't retain reference to the styleable
        setInputSource((Styleable) null);

        return stylesheet;
    }

    /**
     * Convenience method for unit tests.
     * @param property the property
     * @param expr the expression
     * @return the parsed value
     */
    ParsedValue parseExpr(String property, String expr) {
        if (property == null || expr == null) return null;

        ParsedValueImpl value = null;
        setInputSource(null, property + &quot;: &quot; + expr);
        char buf[] = new char[expr.length() + 1];
        System.arraycopy(expr.toCharArray(), 0, buf, 0, expr.length());
        buf[buf.length-1] = ';';

        try (Reader reader = new CharArrayReader(buf)) {
            CssLexer lex = new CssLexer();
            lex.setReader(reader);

            currentToken = nextToken(lex);
            CssParser.Term term = this.expr(lex);
            value = valueFor(property, term, lex);
        } catch (IOException ioe) {
        } catch (ParseException e) {
            if (LOGGER.isLoggable(Level.WARNING)) {
                LOGGER.warning(&quot;\&quot;&quot; +property + &quot;: &quot; + expr  + &quot;\&quot; &quot; + e.toString());
            }
        } catch (Exception ex) {
            // Sometimes bad syntax causes an exception. The code should be
            // fixed to handle the bad syntax, but the fallback is
            // to handle the exception here. Uncaught, the exception can cause
            // problems like RT-20311
            reportException(ex);
        }
        return value;
    }
    /*
     * Map of property names found while parsing. If a value matches a
     * property name, then the value is a lookup.
     */
    private final Map&lt;String,String&gt; properties;

    /*
     * While parsing a declaration, tokens from parsing value (that is,
     * the expr rule) are held in this tree structure which is then passed
     * to methods which convert the tree into a ParsedValueImpl.
     *
     * Each term in expr is a Term. For simple terms, like HASH, the
     * Term is just the Token. If the term is a function, then the
     * Term is a linked-list of Term, the first being the function
     * name and each nextArg being the arguments.
     *
     * If there is more than one term in the expr (insets, for example),
     * then the terms are linked on nextInSequence. If there is more than one
     * layer (sequence of terms), then each layer becomes the nextLayer
     * to the last root in the previous sequence.
     *
     * The easiest way to think of it is that a comma starts a nextLayer (except
     * when a function arg).
     *
     * The expr part of the declaration &quot;-fx-padding 1 2, 3 4;&quot; would look
     * like this:
     * [1 | nextLayer | nextInSeries]--&gt;[2 | nextLayer | nextInSeries]--&gt;null
     *            |                            |
     *          null                           |
     *       .---------------------------------'
     *       '--&gt;[3 | nextLayer | nextInSeries]--&gt;[4 | nextLayer | nextInSeries]--&gt;null
     *                    |                              |
     *                   null                           null
     *
     * The first argument in a function needs to be distinct from the
     * remaining args so that the args of a function in the middle of
     * a function will not be omitted. Consider 'f0(a, f1(b, c), d)'
     * If we relied only on nextArg, then the next arg of f0 would be a but
     * the nextArg of f1 would be d. With firstArg, the firstArg of f0 is a,
     * the nextArg of a is f1, the firstArg of f1 is b and the nextArg of f1 is d.
     *
     * TODO: now that the parser is the parser and not an adjunct to an ANTLR
     * parser, this Term stuff shouldn't be needed.
     */
    static class Term {
        final Token token;
        Term nextInSeries;
        Term nextLayer;
        Term firstArg;
        Term nextArg;
        Term(Token token) {
            this.token = token;
            this.nextLayer = null;
            this.nextInSeries = null;
            this.firstArg = null;
            this.nextArg = null;
        }
        Term() {
            this(null);
        }

        @Override public String toString() {
            StringBuilder buf = new StringBuilder();
            if (token != null) buf.append(String.valueOf(token.getText()));
            if (nextInSeries != null) {
                buf.append(&quot;&lt;nextInSeries&gt;&quot;);
                buf.append(nextInSeries.toString());
                buf.append(&quot;&lt;/nextInSeries&gt;\n&quot;);
            }
            if (nextLayer != null) {
                buf.append(&quot;&lt;nextLayer&gt;&quot;);
                buf.append(nextLayer.toString());
                buf.append(&quot;&lt;/nextLayer&gt;\n&quot;);
            }
            if (firstArg != null) {
                buf.append(&quot;&lt;args&gt;&quot;);
                buf.append(firstArg.toString());
                if (nextArg != null) {
                    buf.append(nextArg.toString());
                }
                buf.append(&quot;&lt;/args&gt;&quot;);
            }

            return buf.toString();
        }

    }

    private ParseError createError(String msg) {

        ParseError error = null;
        if (sourceOfStylesheet != null) {
            error = new ParseError.StylesheetParsingError(sourceOfStylesheet, msg);
        } else if (sourceOfInlineStyle != null) {
            error = new ParseError.InlineStyleParsingError(sourceOfInlineStyle, msg);
        } else {
            error = new ParseError.StringParsingError(stylesheetAsText, msg);
        }
        return error;
    }

    private void reportError(ParseError error) {
        List&lt;ParseError&gt; errors = null;
        if ((errors = StyleManager.getErrors()) != null) {
            errors.add(error);
        }
    }

    private void error(final Term root, final String msg) throws ParseException {

        final Token token = root != null ? root.token : null;
        final ParseException pe = new ParseException(msg,token,this);
        reportError(createError(pe.toString()));
        throw pe;
    }

    private void reportException(Exception exception) {

        if (LOGGER.isLoggable(Level.WARNING)) {
            final StackTraceElement[] stea = exception.getStackTrace();
            if (stea.length &gt; 0) {
                final StringBuilder buf =
                    new StringBuilder(&quot;Please report &quot;);
                buf.append(exception.getClass().getName())
                   .append(&quot; at:&quot;);
                int end = 0;
                while(end &lt; stea.length) {
                    // only report parser part of the stack trace.
                    if (!getClass().getName().equals(stea[end].getClassName())) {
                        break;
                    }
                    buf.append(&quot;\n\t&quot;)
                    .append(stea[end++].toString());
                }
                LOGGER.warning(buf.toString());
            }
        }
    }

    private String formatDeprecatedMessage(final Term root, final String syntax) {
        final StringBuilder buf =
            new StringBuilder(&quot;Using deprecated syntax for &quot;);
        buf.append(syntax);
        if (sourceOfStylesheet != null){
            buf.append(&quot; at &quot;)
               .append(sourceOfStylesheet)
               .append(&quot;[&quot;)
               .append(root.token.getLine())
               .append(',')
               .append(root.token.getOffset())
               .append(&quot;]&quot;);
        }
        buf.append(&quot;. Refer to the CSS Reference Guide.&quot;);
        return buf.toString();
    }

    // Assumes string is not a lookup!
    private ParsedValueImpl&lt;Color,Color&gt; colorValueOfString(String str) {

        if(str.startsWith(&quot;#&quot;) || str.startsWith(&quot;0x&quot;)) {

            double a = 1.0f;
            String c = str;
            final int prefixLength = (str.startsWith(&quot;#&quot;)) ? 1 : 2;

            final int len = c.length();
            // rgba or rrggbbaa - trim off the alpha
            if ( (len-prefixLength) == 4) {
                a = Integer.parseInt(c.substring(len-1), 16) / 15.0f;
                c = c.substring(0,len-1);
            } else if ((len-prefixLength) == 8) {
                a = Integer.parseInt(c.substring(len-2), 16) / 255.0f;
                c = c.substring(0,len-2);
            }
            // else color was rgb or rrggbb (no alpha)
            return new ParsedValueImpl&lt;Color,Color&gt;(Color.web(c,a), null);
        }

        try {
            return new ParsedValueImpl&lt;Color,Color&gt;(Color.web(str), null);
        } catch (final IllegalArgumentException e) {
        } catch (final NullPointerException e) {
        }

        // not a color
        return null;
    }

    private String stripQuotes(String string) {
        return com.sun.javafx.util.Utils.stripQuotes(string);
    }

    private double clamp(double min, double val, double max) {
        if (val &lt; min) return min;
        if (max &lt; val) return max;
        return val;
    }

    // Return true if the token is a size type or an identifier
    // (which would indicate a lookup).
    private boolean isSize(Token token) {
        final int ttype = token.getType();
        switch (ttype) {
        case CssLexer.NUMBER:
        case CssLexer.PERCENTAGE:
        case CssLexer.EMS:
        case CssLexer.EXS:
        case CssLexer.PX:
        case CssLexer.CM:
        case CssLexer.MM:
        case CssLexer.IN:
        case CssLexer.PT:
        case CssLexer.PC:
        case CssLexer.DEG:
        case CssLexer.GRAD:
        case CssLexer.RAD:
        case CssLexer.TURN:
            return true;
        default:
            return token.getType() == CssLexer.IDENT;
        }
    }

    private Size size(final Token token) throws ParseException {
        SizeUnits units = SizeUnits.PX;
        // Amount to trim off the suffix, if any. Most are 2 chars.
        int trim = 2;
        final String sval = token.getText().trim();
        final int len = sval.length();
        final int ttype = token.getType();
        switch (ttype) {
        case CssLexer.NUMBER:
            units = SizeUnits.PX;
            trim = 0;
            break;
        case CssLexer.PERCENTAGE:
            units = SizeUnits.PERCENT;
            trim = 1;
            break;
        case CssLexer.EMS:
            units = SizeUnits.EM;
            break;
        case CssLexer.EXS:
            units = SizeUnits.EX;
            break;
        case CssLexer.PX:
            units = SizeUnits.PX;
            break;
        case CssLexer.CM:
            units = SizeUnits.CM;
            break;
        case CssLexer.MM:
            units = SizeUnits.MM;
            break;
        case CssLexer.IN:
            units = SizeUnits.IN;
            break;
        case CssLexer.PT:
            units = SizeUnits.PT;
            break;
        case CssLexer.PC:
            units = SizeUnits.PC;
            break;
        case CssLexer.DEG:
            units = SizeUnits.DEG;
            trim = 3;
            break;
        case CssLexer.GRAD:
            units = SizeUnits.GRAD;
            trim = 4;
            break;
        case CssLexer.RAD:
            units = SizeUnits.RAD;
            trim = 3;
            break;
        case CssLexer.TURN:
            units = SizeUnits.TURN;
            trim = 4;
            break;
        case CssLexer.SECONDS:
            units = SizeUnits.S;
            trim = 1;
            break;
        case CssLexer.MS:
            units = SizeUnits.MS;
            break;
        default:
            if (LOGGER.isLoggable(Level.FINEST)) {
                LOGGER.finest(&quot;Expected \'&lt;number&gt;\'&quot;);
            }
            ParseException re = new ParseException(&quot;Expected \'&lt;number&gt;\'&quot;,token, this);
            reportError(createError(re.toString()));
            throw re;
        }
        // TODO: Handle NumberFormatException
        return new Size(
            Double.parseDouble(sval.substring(0,len-trim)),
            units
        );
    }

    // Count the number of terms in a series
    private int numberOfTerms(final Term root) {
        if (root == null) return 0;

        int nTerms = 0;
        Term term = root;
        do {
            nTerms += 1;
            term = term.nextInSeries;
        } while (term != null);
        return nTerms;
    }

    // Count the number of series of terms
    private int numberOfLayers(final Term root) {
        if (root == null) return 0;

        int nLayers = 0;
        Term term = root;
        do {
            nLayers += 1;
            while (term.nextInSeries != null) {
                term = term.nextInSeries;
            }
            term = term.nextLayer;
        } while (term != null);
        return nLayers;
    }

    // Count the number of args of terms. root is the function.
    private int numberOfArgs(final Term root) {
        if (root == null) return 0;

        int nArgs = 0;
        Term term = root.firstArg;
        while (term != null) {
            nArgs += 1;
            term = term.nextArg;
        }
        return nArgs;
    }

    // Get the next layer following this term, which may be null
    private Term nextLayer(final Term root) {
        if (root == null) return null;

        Term term = root;
        while (term.nextInSeries != null) {
            term = term.nextInSeries;
        }
        return term.nextLayer;
    }

    ////////////////////////////////////////////////////////////////////////////
    //
    // Parsing routines
    //
    ////////////////////////////////////////////////////////////////////////////

    ParsedValueImpl valueFor(String property, Term root, CssLexer lexer) throws ParseException {
        final String prop = property.toLowerCase(Locale.ROOT);
        properties.put(prop, prop);
        if (root == null || root.token == null) {
            error(root, &quot;Expected value for property \'&quot; + prop + &quot;\'&quot;);
        }

        if (root.token.getType() == CssLexer.IDENT) {
            final String txt = root.token.getText();
            if (&quot;inherit&quot;.equalsIgnoreCase(txt)) {
                return new ParsedValueImpl&lt;String,String&gt;(&quot;inherit&quot;, null);
            } else if (&quot;null&quot;.equalsIgnoreCase(txt)
                    || &quot;none&quot;.equalsIgnoreCase(txt)) {
                return new ParsedValueImpl&lt;String,String&gt;(&quot;null&quot;, null);
            }
        }
        if (&quot;-fx-fill&quot;.equals(prop)) {
             ParsedValueImpl pv = parse(root);
            if (pv.getConverter() == StyleConverter.getUrlConverter()) {
                // ImagePatternConverter expects array of ParsedValue where element 0 is the URL
                // Pending RT-33574
                pv = new ParsedValueImpl(new ParsedValue[] {pv},PaintConverter.ImagePatternConverter.getInstance());
            }
            return pv;
        }
        else if (&quot;-fx-background-color&quot;.equals(prop)) {
            return parsePaintLayers(root);
        } else if (&quot;-fx-background-image&quot;.equals(prop)) {
            return parseURILayers(root);
        } else if (&quot;-fx-background-insets&quot;.equals(prop)) {
             return parseInsetsLayers(root);
        } else if (&quot;-fx-opaque-insets&quot;.equals(prop)) {
            return parseInsetsLayer(root);
        } else if (&quot;-fx-background-position&quot;.equals(prop)) {
             return parseBackgroundPositionLayers(root);
        } else if (&quot;-fx-background-radius&quot;.equals(prop)) {
            return parseCornerRadius(root);
        } else if (&quot;-fx-background-repeat&quot;.equals(prop)) {
             return parseBackgroundRepeatStyleLayers(root);
        } else if (&quot;-fx-background-size&quot;.equals(prop)) {
             return parseBackgroundSizeLayers(root);
        } else if (&quot;-fx-border-color&quot;.equals(prop)) {
             return parseBorderPaintLayers(root);
        } else if (&quot;-fx-border-insets&quot;.equals(prop)) {
             return parseInsetsLayers(root);
        } else if (&quot;-fx-border-radius&quot;.equals(prop)) {
             return parseCornerRadius(root);
        } else if (&quot;-fx-border-style&quot;.equals(prop)) {
             return parseBorderStyleLayers(root);
        } else if (&quot;-fx-border-width&quot;.equals(prop)) {
             return parseMarginsLayers(root);
        } else if (&quot;-fx-border-image-insets&quot;.equals(prop)) {
             return parseInsetsLayers(root);
        } else if (&quot;-fx-border-image-repeat&quot;.equals(prop)) {
             return parseBorderImageRepeatStyleLayers(root);
        } else if (&quot;-fx-border-image-slice&quot;.equals(prop)) {
             return parseBorderImageSliceLayers(root);
        } else if (&quot;-fx-border-image-source&quot;.equals(prop)) {
             return parseURILayers(root);
        } else if (&quot;-fx-border-image-width&quot;.equals(prop)) {
             return parseBorderImageWidthLayers(root);
        } else if (&quot;-fx-padding&quot;.equals(prop)) {
            ParsedValueImpl&lt;?,Size&gt;[] sides = parseSize1to4(root);
            return new ParsedValueImpl&lt;ParsedValue[],Insets&gt;(sides, InsetsConverter.getInstance());
        } else if (&quot;-fx-label-padding&quot;.equals(prop)) {
            ParsedValueImpl&lt;?,Size&gt;[] sides = parseSize1to4(root);
            return new ParsedValueImpl&lt;ParsedValue[],Insets&gt;(sides, InsetsConverter.getInstance());
        } else if (prop.endsWith(&quot;font-family&quot;)) {
            return parseFontFamily(root);
        } else if (prop.endsWith(&quot;font-size&quot;)) {
            ParsedValueImpl fsize = parseFontSize(root);
            if (fsize == null) error(root, &quot;Expected \'&lt;font-size&gt;\'&quot;);
            return fsize;
        } else if (prop.endsWith(&quot;font-style&quot;)) {
            ParsedValueImpl fstyle = parseFontStyle(root);
            if (fstyle == null) error(root, &quot;Expected \'&lt;font-style&gt;\'&quot;);
            return fstyle;
        } else if (prop.endsWith(&quot;font-weight&quot;)) {
            ParsedValueImpl fweight = parseFontWeight(root);
            if (fweight == null) error(root, &quot;Expected \'&lt;font-style&gt;\'&quot;);
            return fweight;
        } else if (prop.endsWith(&quot;font&quot;)) {
            return parseFont(root);
        } else if (&quot;-fx-stroke-dash-array&quot;.equals(prop)) {
            // TODO: Figure out a way that these properties don't need to be
            // special cased.
            Term term = root;
            int nArgs = numberOfTerms(term);
            ParsedValueImpl&lt;?,Size&gt;[] segments = new ParsedValueImpl[nArgs];
            int segment = 0;
            while(term != null) {
                segments[segment++] = parseSize(term);
                term = term.nextInSeries;
            }

            return new ParsedValueImpl&lt;ParsedValue[],Number[]&gt;(segments,SequenceConverter.getInstance());

        } else if (&quot;-fx-stroke-line-join&quot;.equals(prop)) {
            // TODO: Figure out a way that these properties don't need to be
            // special cased.
            ParsedValueImpl[] values = parseStrokeLineJoin(root);
            if (values == null) error(root, &quot;Expected \'miter', \'bevel\' or \'round\'&quot;);
            return values[0];
        } else if (&quot;-fx-stroke-line-cap&quot;.equals(prop)) {
            // TODO: Figure out a way that these properties don't need to be
            // special cased.
            ParsedValueImpl value = parseStrokeLineCap(root);
            if (value == null) error(root, &quot;Expected \'square', \'butt\' or \'round\'&quot;);
            return value;
        } else if (&quot;-fx-stroke-type&quot;.equals(prop)) {
            // TODO: Figure out a way that these properties don't need to be
            // special cased.
            ParsedValueImpl value = parseStrokeType(root);
            if (value == null) error(root, &quot;Expected \'centered', \'inside\' or \'outside\'&quot;);
            return value;
        } else if (&quot;-fx-font-smoothing-type&quot;.equals(prop)) {
            // TODO: Figure out a way that these properties don't need to be
            // special cased.
            String str = null;
            int ttype = -1;
            final Token token = root.token;

            if (root.token == null
                    || ((ttype = root.token.getType()) != CssLexer.STRING
                         &amp;&amp; ttype != CssLexer.IDENT)
                    || (str = root.token.getText()) == null
                    || str.isEmpty()) {
                error(root,  &quot;Expected STRING or IDENT&quot;);
            }
            return new ParsedValueImpl&lt;String, String&gt;(stripQuotes(str), null, false);
        }
        return parse(root);
    }

    private ParsedValueImpl parse(Term root) throws ParseException {

        if (root.token == null) error(root, &quot;Parse error&quot;);
        final Token token = root.token;
        ParsedValueImpl value = null; // value to return;

        final int ttype = token.getType();
        switch (ttype) {
        case CssLexer.NUMBER:
        case CssLexer.PERCENTAGE:
        case CssLexer.EMS:
        case CssLexer.EXS:
        case CssLexer.PX:
        case CssLexer.CM:
        case CssLexer.MM:
        case CssLexer.IN:
        case CssLexer.PT:
        case CssLexer.PC:
        case CssLexer.DEG:
        case CssLexer.GRAD:
        case CssLexer.RAD:
        case CssLexer.TURN:
            if (root.nextInSeries == null) {
                ParsedValueImpl sizeValue = new ParsedValueImpl&lt;Size,Number&gt;(size(token), null);
                value = new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;, Number&gt;(sizeValue, SizeConverter.getInstance());
            } else {
                ParsedValueImpl&lt;Size,Size&gt;[] sizeValue = parseSizeSeries(root);
                value = new ParsedValueImpl&lt;ParsedValue[],Number[]&gt;(sizeValue, SizeConverter.SequenceConverter.getInstance());
            }
            break;
        case CssLexer.SECONDS:
        case CssLexer.MS: {
            ParsedValue&lt;Size, Size&gt; sizeValue = new ParsedValueImpl&lt;Size, Size&gt;(size(token), null);
            value = new ParsedValueImpl&lt;ParsedValue&lt;?, Size&gt;, Duration&gt;(sizeValue, DurationConverter.getInstance());
            break;
        }
        case CssLexer.STRING:
        case CssLexer.IDENT:
            boolean isIdent = ttype == CssLexer.IDENT;
            final String str = stripQuotes(token.getText());
            final String text = str.toLowerCase(Locale.ROOT);
            if (&quot;ladder&quot;.equals(text)) {
                value = ladder(root);
            } else if (&quot;linear&quot;.equals(text) &amp;&amp; (root.nextInSeries) != null) {
                // if nextInSeries is null, then assume this is _not_ an old-style linear gradient
                value = linearGradient(root);
            } else if (&quot;radial&quot;.equals(text) &amp;&amp; (root.nextInSeries) != null) {
                // if nextInSeries is null, then assume this is _not_ an old-style radial gradient
                value = radialGradient(root);
            } else if (&quot;infinity&quot;.equals(text)) {
                Size size = new Size(Double.MAX_VALUE, SizeUnits.PX);
                ParsedValueImpl sizeValue = new ParsedValueImpl&lt;Size,Number&gt;(size, null);
                value = new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt;(sizeValue, SizeConverter.getInstance());
            } else if (&quot;indefinite&quot;.equals(text)) {
                Size size = new Size(Double.POSITIVE_INFINITY, SizeUnits.PX);
                ParsedValueImpl&lt;Size,Size&gt; sizeValue = new ParsedValueImpl&lt;&gt;(size, null);
                value = new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Duration&gt;(sizeValue, DurationConverter.getInstance());
            } else if (&quot;true&quot;.equals(text)) {
                // TODO: handling of boolean is really bogus
                value = new ParsedValueImpl&lt;String,Boolean&gt;(&quot;true&quot;,BooleanConverter.getInstance());
            } else if (&quot;false&quot;.equals(text)) {
                // TODO: handling of boolean is really bogus
                value = new ParsedValueImpl&lt;String,Boolean&gt;(&quot;false&quot;,BooleanConverter.getInstance());
            } else {
                // if the property value is another property, then it needs to be looked up.
                boolean needsLookup = isIdent &amp;&amp; properties.containsKey(text);
                if (needsLookup || ((value = colorValueOfString(str)) == null )) {
                    // If the value is a lookup, make sure to use the lower-case text so it matches the property
                    // in the Declaration. If the value is not a lookup, then use str since the value might
                    // be a string which could have some case sensitive meaning
                    //
                    // TODO: isIdent is needed here because of RT-38345. This effectively undoes RT-38201
                    value = new ParsedValueImpl&lt;String,String&gt;(needsLookup ? text : str, null, isIdent || needsLookup);
                }
            }
            break;
        case CssLexer.HASH:
            final String clr = token.getText();
            try {
                value = new ParsedValueImpl&lt;Color,Color&gt;(Color.web(clr), null);
            } catch (final IllegalArgumentException e) {
                error(root, e.getMessage());
            }
            break;
        case CssLexer.FUNCTION:
            return  parseFunction(root);
        case CssLexer.URL:
            return parseURI(root);
        default:
            final String msg = &quot;Unknown token type: \'&quot; + ttype + &quot;\'&quot;;
            error(root, msg);
        }
        return value;

    }

    /* Parse size.
     * @throw RecongnitionExcpetion if the token is not a size type or a lookup.
     */
    private ParsedValueImpl&lt;?,Size&gt; parseSize(final Term root) throws ParseException {

        if (root.token == null || !isSize(root.token)) error(root, &quot;Expected \'&lt;size&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; value = null;

        if (root.token.getType() != CssLexer.IDENT) {

            Size size = size(root.token);
            value = new ParsedValueImpl&lt;Size,Size&gt;(size, null);

        } else {

            String key = root.token.getText();
            value = new ParsedValueImpl&lt;String,Size&gt;(key, null, true);

        }

        return value;
    }

    private ParsedValueImpl&lt;?,Color&gt; parseColor(final Term root) throws ParseException {

        ParsedValueImpl&lt;?,Color&gt; color = null;
        if (root.token != null &amp;&amp;
            (root.token.getType() == CssLexer.IDENT ||
             root.token.getType() == CssLexer.HASH ||
             root.token.getType() == CssLexer.FUNCTION)) {

            color = parse(root);

        } else {
            error(root,  &quot;Expected \'&lt;color&gt;\'&quot;);
        }
        return color;
    }

    // rgb(NUMBER, NUMBER, NUMBER)
    // rgba(NUMBER, NUMBER, NUMBER, NUMBER)
    // rgb(PERCENTAGE, PERCENTAGE, PERCENTAGE)
    // rgba(PERCENTAGE, PERCENTAGE, PERCENTAGE, NUMBER)
    private ParsedValueImpl rgb(Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;rgb&quot;.regionMatches(true, 0, fn, 0, 3)) {
            final String msg = &quot;Expected \'rgb\' or \'rgba\'&quot;;
            error(root, msg);
        }

        Term arg = root;
        Token rtok, gtok, btok, atok;

        if ((arg = arg.firstArg) == null) error(root, &quot;Expected \'&lt;number&gt;\' or \'&lt;percentage&gt;\'&quot;);
        if ((rtok = arg.token) == null ||
            (rtok.getType() != CssLexer.NUMBER &amp;&amp;
             rtok.getType() != CssLexer.PERCENTAGE)) error(arg, &quot;Expected \'&lt;number&gt;\' or \'&lt;percentage&gt;\'&quot;);

        root = arg;

        if ((arg = arg.nextArg) == null) error(root, &quot;Expected \'&lt;number&gt;\' or \'&lt;percentage&gt;\'&quot;);
        if ((gtok = arg.token) == null ||
            (gtok.getType() != CssLexer.NUMBER &amp;&amp;
             gtok.getType() != CssLexer.PERCENTAGE)) error(arg, &quot;Expected \'&lt;number&gt;\' or \'&lt;percentage&gt;\'&quot;);

        root = arg;

        if ((arg = arg.nextArg) == null) error(root, &quot;Expected \'&lt;number&gt;\' or \'&lt;percentage&gt;\'&quot;);
        if ((btok = arg.token) == null ||
            (btok.getType() != CssLexer.NUMBER &amp;&amp;
             btok.getType() != CssLexer.PERCENTAGE)) error(arg, &quot;Expected \'&lt;number&gt;\' or \'&lt;percentage&gt;\'&quot;);

        root = arg;

        if ((arg = arg.nextArg) != null) {
            if ((atok = arg.token) == null ||
                 atok.getType() != CssLexer.NUMBER) error(arg, &quot;Expected \'&lt;number&gt;\'&quot;);
        } else {
            atok = null;
        }

        int argType = rtok.getType();
        if (argType != gtok.getType() || argType != btok.getType() ||
            (argType != CssLexer.NUMBER &amp;&amp; argType != CssLexer.PERCENTAGE)) {
            error(root, &quot;Argument type mistmatch&quot;);
        }

        final String rtext = rtok.getText();
        final String gtext = gtok.getText();
        final String btext = btok.getText();

        double rval = 0;
        double gval = 0;
        double bval = 0;
        if (argType == CssLexer.NUMBER) {
            rval = clamp(0.0f, Double.parseDouble(rtext) / 255.0f, 1.0f);
            gval = clamp(0.0f, Double.parseDouble(gtext) / 255.0f, 1.0f);
            bval = clamp(0.0f, Double.parseDouble(btext) / 255.0f, 1.0f);
        } else {
            rval = clamp(0.0f, Double.parseDouble(rtext.substring(0,rtext.length()-1)) / 100.0f, 1.0f);
            gval = clamp(0.0f, Double.parseDouble(gtext.substring(0,gtext.length()-1)) / 100.0f, 1.0f);
            bval = clamp(0.0f, Double.parseDouble(btext.substring(0,btext.length()-1)) / 100.0f, 1.0f);
        }

        final String atext = (atok != null) ? atok.getText() : null;
        final double aval =  (atext != null) ? clamp(0.0f, Double.parseDouble(atext), 1.0f) : 1.0;

        return new ParsedValueImpl&lt;Color,Color&gt;(Color.color(rval,gval,bval,aval), null);

    }

    // hsb(NUMBER, PERCENTAGE, PERCENTAGE)
    // hsba(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
    private ParsedValueImpl hsb(Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;hsb&quot;.regionMatches(true, 0, fn, 0, 3)) {
            final String msg = &quot;Expected \'hsb\' or \'hsba\'&quot;;
            error(root, msg);
        }

        Term arg = root;
        Token htok, stok, btok, atok;

        if ((arg = arg.firstArg) == null) error(root, &quot;Expected \'&lt;number&gt;\'&quot;);
        if ((htok = arg.token) == null || htok.getType() != CssLexer.NUMBER) error(arg, &quot;Expected \'&lt;number&gt;\'&quot;);

        root = arg;

        if ((arg = arg.nextArg) == null) error(root, &quot;Expected \'&lt;percent&gt;\'&quot;);
        if ((stok = arg.token) == null || stok.getType() != CssLexer.PERCENTAGE) error(arg, &quot;Expected \'&lt;percent&gt;\'&quot;);

        root = arg;

        if ((arg = arg.nextArg) == null) error(root, &quot;Expected \'&lt;percent&gt;\'&quot;);
        if ((btok = arg.token) == null || btok.getType() != CssLexer.PERCENTAGE) error(arg, &quot;Expected \'&lt;percent&gt;\'&quot;);

        root = arg;

        if ((arg = arg.nextArg) != null) {
            if ((atok = arg.token) == null || atok.getType() != CssLexer.NUMBER) error(arg, &quot;Expected \'&lt;number&gt;\'&quot;);
        } else {
            atok = null;
        }

        final Size hval = size(htok);
        final Size sval = size(stok);
        final Size bval = size(btok);

        final double hue = hval.pixels(); // no clamp - hue can be negative
        final double saturation = clamp(0.0f, sval.pixels(), 1.0f);
        final double brightness = clamp(0.0f, bval.pixels(), 1.0f);

        final Size aval = (atok != null) ? size(atok) : null;
        final double opacity =  (aval != null) ? clamp(0.0f, aval.pixels(), 1.0f) : 1.0;

        return new ParsedValueImpl&lt;Color,Color&gt;(Color.hsb(hue, saturation, brightness, opacity), null);
    }

    // derive(color, pct)
    private ParsedValueImpl&lt;ParsedValue[],Color&gt; derive(final Term root)
            throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;derive&quot;.regionMatches(true, 0, fn, 0, 6)) {
            final String msg = &quot;Expected \'derive\'&quot;;
            error(root, msg);
        }

        Term arg = root;
        if ((arg = arg.firstArg) == null) error(root, &quot;Expected \'&lt;color&gt;\'&quot;);

        final ParsedValueImpl&lt;?,Color&gt; color = parseColor(arg);

        final Term prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;percent\'&quot;);

        final ParsedValueImpl&lt;?,Size&gt; brightness = parseSize(arg);

        ParsedValueImpl[] values = new ParsedValueImpl[] { color, brightness };
        return new ParsedValueImpl&lt;ParsedValue[],Color&gt;(values, DeriveColorConverter.getInstance());
    }

    // 'ladder' color 'stops' stop+
    private ParsedValueImpl&lt;ParsedValue[],Color&gt; ladder(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;ladder&quot;.regionMatches(true, 0, fn, 0, 6)) {
            final String msg = &quot;Expected \'ladder\'&quot;;
            error(root, msg);
        }

        if (LOGGER.isLoggable(Level.WARNING)) {
            LOGGER.warning(formatDeprecatedMessage(root, &quot;ladder&quot;));
        }

        Term term = root;

        if ((term = term.nextInSeries) == null) error(root, &quot;Expected \'&lt;color&gt;\'&quot;);
        final ParsedValueImpl&lt;?,Color&gt; color = parse(term);

        Term prev = term;

        if ((term = term.nextInSeries) == null) error(prev,  &quot;Expected \'stops\'&quot;);
        if (term.token == null ||
            term.token.getType() != CssLexer.IDENT ||
            !&quot;stops&quot;.equalsIgnoreCase(term.token.getText())) error(term,  &quot;Expected \'stops\'&quot;);

        prev = term;

        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'(&lt;number&gt;, &lt;color&gt;)\'&quot;);

        int nStops = 0;
        Term temp = term;
        do {
            nStops += 1;
            // if next token type is IDENT, then we have CycleMethod
        } while (((temp = temp.nextInSeries) != null) &amp;&amp;
                 ((temp.token != null) &amp;&amp; (temp.token.getType() == CssLexer.LPAREN)));

        ParsedValueImpl[] values = new ParsedValueImpl[nStops+1];
        values[0] = color;
        int stopIndex = 1;
        do {
            ParsedValueImpl&lt;ParsedValue[],Stop&gt; stop = stop(term);
            if (stop != null) values[stopIndex++] = stop;
            prev = term;
        } while(((term = term.nextInSeries) != null) &amp;&amp;
                 (term.token.getType() == CssLexer.LPAREN));

        // if term is not null and the last term was not an lparen,
        // then term starts a new series of Paint. Point
        // root.nextInSeries to term so the next loop skips over the
        // already parsed ladder bits.
        if (term != null) {
            root.nextInSeries = term;
        }

        // if term is null, then we are at the end of a series.
        // root points to 'ladder', now we want the next term after root
        // to be the term after the last stop, which may be another layer
        else {
            root.nextInSeries = null;
            root.nextLayer = prev.nextLayer;
        }

        return new ParsedValueImpl&lt;ParsedValue[], Color&gt;(values, LadderConverter.getInstance());
    }

    // &lt;ladder&gt; = ladder(&lt;color&gt;, &lt;color-stop&gt;[, &lt;color-stop&gt;]+ )
    private ParsedValueImpl&lt;ParsedValue[],Color&gt; parseLadder(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;ladder&quot;.regionMatches(true, 0, fn, 0, 6)) {
            final String msg = &quot;Expected \'ladder\'&quot;;
            error(root, msg);
        }

        Term term = root;

        if ((term = term.firstArg) == null) error(root, &quot;Expected \'&lt;color&gt;\'&quot;);
        final ParsedValueImpl&lt;?,Color&gt; color = parse(term);

        Term prev = term;

        if ((term = term.nextArg) == null)
            error(prev,  &quot;Expected \'&lt;color-stop&gt;[, &lt;color-stop&gt;]+\'&quot;);

        ParsedValueImpl&lt;ParsedValue[],Stop&gt;[] stops = parseColorStops(term);

        ParsedValueImpl[] values = new ParsedValueImpl[stops.length+1];
        values[0] = color;
        System.arraycopy(stops, 0, values, 1, stops.length);
        return new ParsedValueImpl&lt;ParsedValue[], Color&gt;(values, LadderConverter.getInstance());
    }

    // parse (&lt;number&gt;, &lt;color&gt;)+
    // root.token should be a size
    // root.token.next should be a color
    private ParsedValueImpl&lt;ParsedValue[], Stop&gt; stop(final Term root)
            throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;(&quot;.equals(fn)) {
            final String msg = &quot;Expected \'(\'&quot;;
            error(root, msg);
        }

        Term arg = null;

        if ((arg = root.firstArg) == null) error(root,  &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; size = parseSize(arg);

        Term prev = arg;
        if ((arg = arg.nextArg) == null) error(prev,  &quot;Expected \'&lt;color&gt;\'&quot;);

        ParsedValueImpl&lt;?,Color&gt; color = parseColor(arg);

        ParsedValueImpl[] values = new ParsedValueImpl[] { size, color };
        return new ParsedValueImpl&lt;ParsedValue[],Stop&gt;(values, StopConverter.getInstance());

    }

    // http://dev.w3.org/csswg/css3-images/#color-stop-syntax
    // &lt;color-stop&gt; = &lt;color&gt; [ &lt;percentage&gt; | &lt;length&gt; ]?
    private ParsedValueImpl&lt;ParsedValue[], Stop&gt;[] parseColorStops(final Term root)
            throws ParseException {

        int nArgs = 1;
        Term temp = root;
        while(temp != null) {
            if (temp.nextArg != null) {
                nArgs += 1;
                temp = temp.nextArg;
            } else if (temp.nextInSeries != null) {
                temp = temp.nextInSeries;
            } else {
                break;
            }
        }

        if (nArgs &lt; 2) {
            error(root, &quot;Expected \'&lt;color-stop&gt;\'&quot;);
        }

        ParsedValueImpl&lt;?,Color&gt;[] colors = new ParsedValueImpl[nArgs];
        Size[] positions = new Size[nArgs];
        java.util.Arrays.fill(positions, null);

        Term stop = root;
        Term prev = root;
        SizeUnits units = null;
        for (int n = 0; n&lt;nArgs; n++) {

            colors[n] = parseColor(stop);

            prev = stop;
            Term term = stop.nextInSeries;
            if (term != null) {
                if (isSize(term.token)) {
                    positions[n] = size(term.token);
                    if (units != null) {
                        if (units != positions[n].getUnits()) {
                            error(term, &quot;Parser unable to handle mixed \'&lt;percent&gt;\' and \'&lt;length&gt;\'&quot;);
                        }
                    }
                } else {
                    error(prev, &quot;Expected \'&lt;percent&gt;\' or \'&lt;length&gt;\'&quot;);
                }
                prev = term;
                stop = term.nextArg;
            } else {
                prev = stop;
                stop = stop.nextArg;
            }

        }

        //
        // normalize positions according to
        // http://dev.w3.org/csswg/css3-images/#color-stop-syntax
        //
        // If the first color-stop does not have a position, set its
        // position to 0%. If the last color-stop does not have a position,
        // set its position to 100%.
        if (positions[0] == null) positions[0] = new Size(0, SizeUnits.PERCENT);
        if (positions[nArgs-1] == null) positions[nArgs-1] = new Size(100, SizeUnits.PERCENT);

        // If a color-stop has a position that is less than the specified
        // position of any color-stop before it in the list, set its
        // position to be equal to the largest specified position of any
        // color-stop before it.
        Size max = null;
        for (int n = 1 ; n&lt;nArgs; n++) {
            Size pos0 = positions[n-1];
            if (pos0 == null) continue;
            if (max == null || max.getValue() &lt; pos0.getValue()) {
                // TODO: this doesn't work with mixed length and percent
                max = pos0;
            }
            Size pos1 = positions[n];
            if (pos1 == null) continue;

            if (pos1.getValue() &lt; max.getValue()) positions[n] = max;
        }

        // If any color-stop still does not have a position, then,
        // for each run of adjacent color-stops without positions, set
        // their positions so that they are evenly spaced between the
        // preceding and following color-stops with positions.
        Size preceding = null;
        int withoutIndex = -1;
        for (int n = 0 ; n&lt;nArgs; n++) {
            Size pos = positions[n];
            if (pos == null) {
                if (withoutIndex == -1) withoutIndex = n;
            } else {
                if (withoutIndex &gt; -1) {

                    int nWithout = n - withoutIndex;
                    double precedingValue = preceding.getValue();
                    double delta =
                        (pos.getValue() - precedingValue) / (nWithout + 1);

                    while(withoutIndex &lt; n) {
                        precedingValue += delta;
                        positions[withoutIndex++] =
                            new Size(precedingValue, pos.getUnits());
                    }
                    withoutIndex = -1;
                    preceding = pos;
                } else {
                    preceding = pos;
                }
            }
        }

        ParsedValueImpl&lt;ParsedValue[],Stop&gt;[] stops = new ParsedValueImpl[nArgs];
        for (int n=0; n&lt;nArgs; n++) {
            stops[n] = new ParsedValueImpl&lt;ParsedValue[],Stop&gt;(
                new ParsedValueImpl[] {
                    new ParsedValueImpl&lt;Size,Size&gt;(positions[n], null),
                    colors[n]
                },
                StopConverter.getInstance()
            );
        }

        return stops;

    }

    // parse (&lt;number&gt;, &lt;number&gt;)
    private ParsedValueImpl[] point(final Term root) throws ParseException {

        if (root.token == null ||
            root.token.getType() != CssLexer.LPAREN) error(root, &quot;Expected \'(&lt;number&gt;, &lt;number&gt;)\'&quot;);

        final String fn = root.token.getText();
        if (fn == null || !&quot;(&quot;.equalsIgnoreCase(fn)) {
            final String msg = &quot;Expected \'(\'&quot;;
            error(root, msg);
        }

        Term arg = null;

        // no &lt;number&gt;
        if ((arg = root.firstArg) == null)  error(root, &quot;Expected \'&lt;number&gt;\'&quot;);

        final ParsedValueImpl&lt;?,Size&gt; ptX = parseSize(arg);

        final Term prev = arg;

        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        final ParsedValueImpl&lt;?,Size&gt; ptY = parseSize(arg);

        return new ParsedValueImpl[] { ptX, ptY };
    }

    private ParsedValueImpl parseFunction(final Term root) throws ParseException {

        // Text from parser is function name plus the lparen, e.g., 'derive('
        final String fcn = (root.token != null) ? root.token.getText() : null;
        if (fcn == null) {
            error(root, &quot;Expected function name&quot;);
        } else if (&quot;rgb&quot;.regionMatches(true, 0, fcn, 0, 3)) {
            return rgb(root);
        } else if (&quot;hsb&quot;.regionMatches(true, 0, fcn, 0, 3)) {
            return hsb(root);
        } else if (&quot;derive&quot;.regionMatches(true, 0, fcn, 0, 6)) {
            return derive(root);
        } else if (&quot;innershadow&quot;.regionMatches(true, 0, fcn, 0, 11)) {
            return innershadow(root);
        } else if (&quot;dropshadow&quot;.regionMatches(true, 0, fcn, 0, 10)) {
            return dropshadow(root);
        } else if (&quot;linear-gradient&quot;.regionMatches(true, 0, fcn, 0, 15)) {
            return parseLinearGradient(root);
        } else if (&quot;radial-gradient&quot;.regionMatches(true, 0, fcn, 0, 15)) {
            return parseRadialGradient(root);
        } else if (&quot;image-pattern&quot;.regionMatches(true, 0, fcn, 0, 13)) {
            return parseImagePattern(root);
        } else if (&quot;repeating-image-pattern&quot;.regionMatches(true, 0, fcn, 0, 23)) {
            return parseRepeatingImagePattern(root);
        } else if (&quot;ladder&quot;.regionMatches(true, 0, fcn, 0, 6)) {
            return parseLadder(root);
        } else if (&quot;region&quot;.regionMatches(true, 0, fcn, 0, 6)) {
            return parseRegion(root);
        } else {
            error(root, &quot;Unexpected function \'&quot; + fcn + &quot;\'&quot;);
        }
        return null;
    }

    private ParsedValueImpl&lt;String,BlurType&gt; blurType(final Term root) throws ParseException {

        if (root == null) return null;
        if (root.token == null ||
            root.token.getType() != CssLexer.IDENT ||
            root.token.getText() == null ||
            root.token.getText().isEmpty()) {
            final String msg = &quot;Expected \'gaussian\', \'one-pass-box\', \'two-pass-box\', or \'three-pass-box\'&quot;;
            error(root, msg);
        }
        final String blurStr = root.token.getText().toLowerCase(Locale.ROOT);
        BlurType blurType = BlurType.THREE_PASS_BOX;
        if (&quot;gaussian&quot;.equals(blurStr)) {
            blurType = BlurType.GAUSSIAN;
        } else if (&quot;one-pass-box&quot;.equals(blurStr)) {
            blurType = BlurType.ONE_PASS_BOX;
        } else if (&quot;two-pass-box&quot;.equals(blurStr)) {
            blurType = BlurType.TWO_PASS_BOX;
        } else if (&quot;three-pass-box&quot;.equals(blurStr)) {
            blurType = BlurType.THREE_PASS_BOX;
        } else {
            final String msg = &quot;Expected \'gaussian\', \'one-pass-box\', \'two-pass-box\', or \'three-pass-box\'&quot;;
            error(root, msg);
        }
        return new ParsedValueImpl&lt;String,BlurType&gt;(blurType.name(), new EnumConverter&lt;BlurType&gt;(BlurType.class));
    }

    // innershadow &lt;blur-type&gt; &lt;color&gt; &lt;radius&gt; &lt;choke&gt; &lt;offset-x&gt; &lt;offset-y&gt;
    private ParsedValueImpl innershadow(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;innershadow&quot;.regionMatches(true, 0, fn, 0, 11)) {
            final String msg = &quot;Expected \'innershadow\'&quot;;
            error(root, msg);
        }

        Term arg;

        if ((arg = root.firstArg) == null) error(root, &quot;Expected \'&lt;blur-type&gt;\'&quot;);
        ParsedValueImpl&lt;String,BlurType&gt; blurVal = blurType(arg);

        Term prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;color&gt;\'&quot;);

        ParsedValueImpl&lt;?,Color&gt; colorVal = parseColor(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; radiusVal = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; chokeVal = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; offsetXVal = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; offsetYVal = parseSize(arg);

        ParsedValueImpl[] values = new ParsedValueImpl[] {
            blurVal,
            colorVal,
            radiusVal,
            chokeVal,
            offsetXVal,
            offsetYVal
        };
        return new ParsedValueImpl&lt;ParsedValue[],Effect&gt;(values, EffectConverter.InnerShadowConverter.getInstance());
    }

    // dropshadow &lt;blur-type&gt; &lt;color&gt; &lt;radius&gt; &lt;spread&gt; &lt;offset-x&gt; &lt;offset-y&gt;
    private ParsedValueImpl dropshadow(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;dropshadow&quot;.regionMatches(true, 0, fn, 0, 10)) {
            final String msg = &quot;Expected \'dropshadow\'&quot;;
            error(root, msg);
        }

        Term arg;

        if ((arg = root.firstArg) == null) error(root, &quot;Expected \'&lt;blur-type&gt;\'&quot;);
        ParsedValueImpl&lt;String,BlurType&gt; blurVal = blurType(arg);

        Term prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;color&gt;\'&quot;);

        ParsedValueImpl&lt;?,Color&gt; colorVal = parseColor(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; radiusVal = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; spreadVal = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; offsetXVal = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt; offsetYVal = parseSize(arg);

        ParsedValueImpl[] values = new ParsedValueImpl[] {
            blurVal,
            colorVal,
            radiusVal,
            spreadVal,
            offsetXVal,
            offsetYVal
        };
        return new ParsedValueImpl&lt;ParsedValue[],Effect&gt;(values, EffectConverter.DropShadowConverter.getInstance());
    }

    // returns null if the Term is null or is not a cycle method.
    private ParsedValueImpl&lt;String, CycleMethod&gt; cycleMethod(final Term root) {
        CycleMethod cycleMethod = null;
        if (root != null &amp;&amp; root.token.getType() == CssLexer.IDENT) {

            final String text = root.token.getText().toLowerCase(Locale.ROOT);
            if (&quot;repeat&quot;.equals(text)) {
                cycleMethod = CycleMethod.REPEAT;
            } else if (&quot;reflect&quot;.equals(text)) {
                cycleMethod = CycleMethod.REFLECT;
            } else if (&quot;no-cycle&quot;.equals(text)) {
                cycleMethod = CycleMethod.NO_CYCLE;
            }
        }
        if (cycleMethod != null)
            return new ParsedValueImpl&lt;String,CycleMethod&gt;(cycleMethod.name(), new EnumConverter&lt;CycleMethod&gt;(CycleMethod.class));
        else
            return null;
    }

    // linear &lt;point&gt; TO &lt;point&gt; STOPS &lt;stop&gt;+ cycleMethod?
    private ParsedValueImpl&lt;ParsedValue[],Paint&gt; linearGradient(final Term root) throws ParseException {

        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;linear&quot;.equalsIgnoreCase(fn)) {
            final String msg = &quot;Expected \'linear\'&quot;;
            error(root, msg);
        }

        if (LOGGER.isLoggable(Level.WARNING)) {
            LOGGER.warning(formatDeprecatedMessage(root, &quot;linear gradient&quot;));
        }

        Term term = root;

        if ((term = term.nextInSeries) == null) error(root, &quot;Expected \'(&lt;number&gt;, &lt;number&gt;)\'&quot;);

        final ParsedValueImpl&lt;?,Size&gt;[] startPt = point(term);

        Term prev = term;
        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'to\'&quot;);
        if (term.token == null ||
            term.token.getType() != CssLexer.IDENT ||
            !&quot;to&quot;.equalsIgnoreCase(term.token.getText())) error(root, &quot;Expected \'to\'&quot;);

        prev = term;
        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'(&lt;number&gt;, &lt;number&gt;)\'&quot;);

        final ParsedValueImpl&lt;?,Size&gt;[] endPt = point(term);

        prev = term;
        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'stops\'&quot;);
        if (term.token == null ||
            term.token.getType() != CssLexer.IDENT ||
            !&quot;stops&quot;.equalsIgnoreCase(term.token.getText())) error(term, &quot;Expected \'stops\'&quot;);

        prev = term;
        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'(&lt;number&gt;, &lt;number&gt;)\'&quot;);

        int nStops = 0;
        Term temp = term;
        do {
            nStops += 1;
            // if next token type is IDENT, then we have CycleMethod
        } while (((temp = temp.nextInSeries) != null) &amp;&amp;
                 ((temp.token != null) &amp;&amp; (temp.token.getType() == CssLexer.LPAREN)));

        ParsedValueImpl[] stops = new ParsedValueImpl[nStops];
        int stopIndex = 0;
        do {
            ParsedValueImpl&lt;ParsedValue[],Stop&gt; stop = stop(term);
            if (stop != null) stops[stopIndex++] = stop;
            prev = term;
        } while(((term = term.nextInSeries) != null) &amp;&amp;
                (term.token.getType() == CssLexer.LPAREN));

        // term is either null or is a cycle method, or the start of another Paint.
        ParsedValueImpl&lt;String,CycleMethod&gt; cycleMethod = cycleMethod(term);

        if (cycleMethod == null) {

            cycleMethod = new ParsedValueImpl&lt;String,CycleMethod&gt;(CycleMethod.NO_CYCLE.name(), new EnumConverter&lt;CycleMethod&gt;(CycleMethod.class));

            // if term is not null and the last term was not a cycle method,
            // then term starts a new series or layer of Paint
            if (term != null) {
                root.nextInSeries = term;
            }

            // if term is null, then we are at the end of a series.
            // root points to 'linear', now we want the next term after root
            // to be the term after the last stop, which may be another layer
            else {
                root.nextInSeries = null;
                root.nextLayer = prev.nextLayer;
            }


        } else {
            // last term was a CycleMethod, so term is not null.
            // root points at 'linear', now we want the next term after root
            // to be the term after cyclemethod, which may be another series
            // of paint or another layer.
            //
            root.nextInSeries = term.nextInSeries;
            root.nextLayer = term.nextLayer;
        }

        ParsedValueImpl[] values = new ParsedValueImpl[5 + stops.length];
        int index = 0;
        values[index++] = (startPt != null) ? startPt[0] : null;
        values[index++] = (startPt != null) ? startPt[1] : null;
        values[index++] = (endPt != null) ? endPt[0] : null;
        values[index++] = (endPt != null) ? endPt[1] : null;
        values[index++] = cycleMethod;
        for (int n=0; n&lt;stops.length; n++) values[index++] = stops[n];
        return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.LinearGradientConverter.getInstance());
    }

    // Based off http://dev.w3.org/csswg/css3-images/#linear-gradients
    //
    // &lt;linear-gradient&gt; = linear-gradient(
    //        [ [from &lt;point&gt; to &lt;point&gt;] | [ to &lt;side-or-corner&gt; ] ] ,]? [ [ repeat | reflect ] ,]?
    //        &lt;color-stop&gt;[, &lt;color-stop&gt;]+
    // )
    //
    //
    // &lt;point&gt; = &lt;percentage&gt; &lt;percentage&gt; | &lt;length&gt; &lt;length&gt;
    // &lt;side-or-corner&gt; = [left | right] || [top | bottom]
    //
    // If neither repeat nor reflect are given, then the CycleMethod defaults &quot;NO_CYCLE&quot;.
    // If neither [from &lt;point&gt; to &lt;point&gt;] nor [ to &lt;side-or-corner&gt; ] are given,
    // then the gradient direction defaults to 'to bottom'.
    // Stops are per http://dev.w3.org/csswg/css3-images/#color-stop-syntax.
    private ParsedValueImpl parseLinearGradient(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;linear-gradient&quot;.regionMatches(true, 0, fn, 0, 15)) {
            final String msg = &quot;Expected \'linear-gradient\'&quot;;
            error(root, msg);
        }

        Term arg;

        if ((arg = root.firstArg) == null ||
             arg.token == null ||
             arg.token.getText().isEmpty()) {
            error(root,
                &quot;Expected \'from &lt;point&gt; to &lt;point&gt;\' or \'to &lt;side-or-corner&gt;\' &quot; +
                &quot;or \'&lt;cycle-method&gt;\' or \'&lt;color-stop&gt;\'&quot;);
        }

        Term prev = arg;
//        ParsedValueImpl&lt;Size,Size&gt; angleVal = null;
        ParsedValueImpl&lt;?,Size&gt;[] startPt = null;
        ParsedValueImpl&lt;?,Size&gt;[] endPt = null;

        if (&quot;from&quot;.equalsIgnoreCase(arg.token.getText())) {

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'&lt;point&gt;\'&quot;);

            ParsedValueImpl&lt;?,Size&gt; ptX = parseSize(arg);

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'&lt;point&gt;\'&quot;);

            ParsedValueImpl&lt;?,Size&gt; ptY = parseSize(arg);

            startPt = new ParsedValueImpl[] { ptX, ptY };

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'to\'&quot;);
            if (arg.token == null ||
                arg.token.getType() != CssLexer.IDENT ||
                !&quot;to&quot;.equalsIgnoreCase(arg.token.getText())) error(prev, &quot;Expected \'to\'&quot;);

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'&lt;point&gt;\'&quot;);

            ptX = parseSize(arg);

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'&lt;point&gt;\'&quot;);

            ptY = parseSize(arg);

            endPt = new ParsedValueImpl[] { ptX, ptY };

            prev = arg;
            arg = arg.nextArg;

        } else if(&quot;to&quot;.equalsIgnoreCase(arg.token.getText())) {

            prev = arg;
            if ((arg = arg.nextInSeries) == null ||
                arg.token == null ||
                arg.token.getType() != CssLexer.IDENT ||
                arg.token.getText().isEmpty()) {
                error (prev, &quot;Expected \'&lt;side-or-corner&gt;\'&quot;);
            }


            int startX = 0;
            int startY = 0;
<A NAME="61"></A>            int endX = 0;
            int endY = 0;

            <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#61',2,'match42-top.html#61',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>String sideOrCorner1 = arg.token.getText().toLowerCase(Locale.ROOT);
            // The keywords denote the direction.
            if (&quot;top&quot;.equals(sideOrCorner1)) {
                // going toward the top, then start at the bottom
                startY = 100;
                endY = 0;

            } else if (&quot;bottom&quot;.equals(sideOrCorner1)) {
                // going toward the bottom, then start at the top
                startY = 0;
                endY = 100;

            }</B></FONT> else if (&quot;right&quot;.equals(sideOrCorner1)) {
                // going toward the right, then start at the left
                startX = 0;
                endX = 100;

            } else if (&quot;left&quot;.equals(sideOrCorner1)) {
                // going toward the left, then start at the right
                startX = 100;
                endX = 0;

            } else {
                error(arg, &quot;Invalid \'&lt;side-or-corner&gt;\'&quot;);
            }

            prev = arg;
            if (arg.nextInSeries != null) {
                arg = arg.nextInSeries;
                if (arg.token != null &amp;&amp;
                    arg.token.getType() == CssLexer.IDENT &amp;&amp;
                    !arg.token.getText().isEmpty()) {

                    String sideOrCorner2 = arg.token.getText().toLowerCase(Locale.ROOT);

                    // if right or left has already been given,
                    // then either startX or endX will not be zero.
                    if (&quot;right&quot;.equals(sideOrCorner2) &amp;&amp;
                        startX == 0 &amp;&amp; endX == 0) {
                        // start left, end right
                        startX = 0;
                        endX = 100;
                    } else if (&quot;left&quot;.equals(sideOrCorner2) &amp;&amp;
                        startX == 0 &amp;&amp; endX == 0) {
                        // start right, end left
                        startX = 100;
                        endX = 0;

                    // if top or bottom has already been given,
                    // then either startY or endY will not be zero.
                    } else if(&quot;top&quot;.equals(sideOrCorner2) &amp;&amp;
                        startY == 0 &amp;&amp; endY == 0) {
                        // start bottom, end top
                        startY = 100;
                        endY = 0;
                    } else if (&quot;bottom&quot;.equals(sideOrCorner2) &amp;&amp;
                        startY == 0 &amp;&amp; endY == 0) {
                        // start top, end bottom
                        startY = 0;
                        endY = 100;

                    } else {
                        error(arg, &quot;Invalid \'&lt;side-or-corner&gt;\'&quot;);
                    }

                } else {
                    error (prev, &quot;Expected \'&lt;side-or-corner&gt;\'&quot;);
                }
            }


            startPt = new ParsedValueImpl[] {
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(startX, SizeUnits.PERCENT), null),
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(startY, SizeUnits.PERCENT), null)
            };

            endPt = new ParsedValueImpl[] {
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(endX, SizeUnits.PERCENT), null),
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(endY, SizeUnits.PERCENT), null)
            };

            prev = arg;
            arg = arg.nextArg;
        }

        if (startPt == null &amp;&amp; endPt == null) {
            // spec says defaults to bottom
            startPt = new ParsedValueImpl[] {
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(0, SizeUnits.PERCENT), null),
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(0, SizeUnits.PERCENT), null)
            };

            endPt = new ParsedValueImpl[] {
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(0, SizeUnits.PERCENT), null),
                new ParsedValueImpl&lt;Size,Size&gt;(new Size(100, SizeUnits.PERCENT), null)
            };
        }

        if (arg == null ||
            arg.token == null ||
            arg.token.getText().isEmpty()) {
            error(prev, &quot;Expected \'&lt;cycle-method&gt;\' or \'&lt;color-stop&gt;\'&quot;);
        }

        CycleMethod cycleMethod = CycleMethod.NO_CYCLE;
        if (&quot;reflect&quot;.equalsIgnoreCase(arg.token.getText())) {
            cycleMethod = CycleMethod.REFLECT;
            prev = arg;
            arg = arg.nextArg;
        } else if (&quot;repeat&quot;.equalsIgnoreCase(arg.token.getText())) {
            cycleMethod = CycleMethod.REFLECT;
            prev = arg;
            arg = arg.nextArg;
        }

        if (arg == null  ||
            arg.token == null ||
            arg.token.getText().isEmpty()) {
            error(prev, &quot;Expected \'&lt;color-stop&gt;\'&quot;);
        }

        ParsedValueImpl&lt;ParsedValue[],Stop&gt;[] stops = parseColorStops(arg);

        ParsedValueImpl[] values = new ParsedValueImpl[5 + stops.length];
        int index = 0;
        values[index++] = (startPt != null) ? startPt[0] : null;
        values[index++] = (startPt != null) ? startPt[1] : null;
        values[index++] = (endPt != null) ? endPt[0] : null;
        values[index++] = (endPt != null) ? endPt[1] : null;
        values[index++] = new ParsedValueImpl&lt;String,CycleMethod&gt;(cycleMethod.name(), new EnumConverter&lt;CycleMethod&gt;(CycleMethod.class));
        for (int n=0; n&lt;stops.length; n++) values[index++] = stops[n];
        return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.LinearGradientConverter.getInstance());

    }

    // radial [focus-angle &lt;number | percent&gt;]? [focus-distance &lt;size&gt;]?
    // [center (&lt;size&gt;,&lt;size&gt;)]? &lt;size&gt;
    // stops [ ( &lt;number&gt; , &lt;color&gt; ) ]+ [ repeat | reflect ]?
    private ParsedValueImpl&lt;ParsedValue[], Paint&gt; radialGradient(final Term root) throws ParseException {

        final String fn = (root.token != null) ? root.token.getText() : null;
        if (fn == null || !&quot;radial&quot;.equalsIgnoreCase(fn)) {
            final String msg = &quot;Expected \'radial\'&quot;;
            error(root, msg);
        }

        if (LOGGER.isLoggable(Level.WARNING)) {
            LOGGER.warning(formatDeprecatedMessage(root, &quot;radial gradient&quot;));
        }

        Term term = root;
        Term prev = root;

        if ((term = term.nextInSeries) == null) error(root, &quot;Expected \'focus-angle &lt;number&gt;\', \'focus-distance &lt;number&gt;\', \'center (&lt;number&gt;,&lt;number&gt;)\' or \'&lt;size&gt;\'&quot;);
        if (term.token == null) error(term, &quot;Expected \'focus-angle &lt;number&gt;\', \'focus-distance &lt;number&gt;\', \'center (&lt;number&gt;,&lt;number&gt;)\' or \'&lt;size&gt;\'&quot;);


        ParsedValueImpl&lt;?,Size&gt; focusAngle = null;
        if (term.token.getType() == CssLexer.IDENT) {
            final String keyword = term.token.getText().toLowerCase(Locale.ROOT);
            if (&quot;focus-angle&quot;.equals(keyword)) {

                prev = term;
                if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);
                if (term.token == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

                focusAngle = parseSize(term);

                prev = term;
                if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'focus-distance &lt;number&gt;\', \'center (&lt;number&gt;,&lt;number&gt;)\' or \'&lt;size&gt;\'&quot;);
                if (term.token == null) error(term,  &quot;Expected \'focus-distance &lt;number&gt;\', \'center (&lt;number&gt;,&lt;number&gt;)\' or \'&lt;size&gt;\'&quot;);
            }
        }

        ParsedValueImpl&lt;?,Size&gt; focusDistance = null;
        if (term.token.getType() == CssLexer.IDENT) {
            final String keyword = term.token.getText().toLowerCase(Locale.ROOT);
            if (&quot;focus-distance&quot;.equals(keyword)) {

                prev = term;
                if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);
                if (term.token == null) error(prev, &quot;Expected \'&lt;number&gt;\'&quot;);

                focusDistance = parseSize(term);

                prev = term;
                if ((term = term.nextInSeries) == null) error(prev, &quot;Expected  \'center (&lt;number&gt;,&lt;number&gt;)\' or \'&lt;size&gt;\'&quot;);
                if (term.token == null) error(term,  &quot;Expected  \'center (&lt;number&gt;,&lt;number&gt;)\' or \'&lt;size&gt;\'&quot;);
            }
        }

        ParsedValueImpl&lt;?,Size&gt;[] centerPoint = null;
        if (term.token.getType() == CssLexer.IDENT) {
            final String keyword = term.token.getText().toLowerCase(Locale.ROOT);
            if (&quot;center&quot;.equals(keyword)) {

                prev = term;
                if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'(&lt;number&gt;,&lt;number&gt;)\'&quot;);
                if (term.token == null ||
                    term.token.getType() != CssLexer.LPAREN) error(term, &quot;Expected \'(&lt;number&gt;,&lt;number&gt;)\'&quot;);

                centerPoint = point(term);

                prev = term;
                if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'&lt;size&gt;\'&quot;);
                if (term.token == null) error(term,  &quot;Expected \'&lt;size&gt;\'&quot;);
            }
        }

        ParsedValueImpl&lt;?,Size&gt; radius = parseSize(term);

        prev = term;
        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'stops\' keyword&quot;);
        if (term.token == null ||
            term.token.getType() != CssLexer.IDENT) error(term, &quot;Expected \'stops\' keyword&quot;);

        if (!&quot;stops&quot;.equalsIgnoreCase(term.token.getText())) error(term, &quot;Expected \'stops\'&quot;);

        prev = term;
        if ((term = term.nextInSeries) == null) error(prev, &quot;Expected \'(&lt;number&gt;, &lt;number&gt;)\'&quot;);

        int nStops = 0;
        Term temp = term;
        do {
            nStops += 1;
            // if next token type is IDENT, then we have CycleMethod
        } while (((temp = temp.nextInSeries) != null) &amp;&amp;
                 ((temp.token != null) &amp;&amp; (temp.token.getType() == CssLexer.LPAREN)));

        ParsedValueImpl[] stops = new ParsedValueImpl[nStops];
        int stopIndex = 0;
        do {
            ParsedValueImpl&lt;ParsedValue[],Stop&gt; stop = stop(term);
            if (stop != null) stops[stopIndex++] = stop;
            prev = term;
        } while(((term = term.nextInSeries) != null) &amp;&amp;
                (term.token.getType() == CssLexer.LPAREN));

        // term is either null or is a cycle method, or the start of another Paint.
        ParsedValueImpl&lt;String,CycleMethod&gt; cycleMethod = cycleMethod(term);

        if (cycleMethod == null) {

            cycleMethod = new ParsedValueImpl&lt;String,CycleMethod&gt;(CycleMethod.NO_CYCLE.name(), new EnumConverter&lt;CycleMethod&gt;(CycleMethod.class));

            // if term is not null and the last term was not a cycle method,
            // then term starts a new series or layer of Paint
            if (term != null) {
                root.nextInSeries = term;
            }

            // if term is null, then we are at the end of a series.
            // root points to 'linear', now we want the next term after root
            // to be the term after the last stop, which may be another layer
            else {
                root.nextInSeries = null;
                root.nextLayer = prev.nextLayer;
            }


        } else {
            // last term was a CycleMethod, so term is not null.
            // root points at 'linear', now we want the next term after root
            // to be the term after cyclemethod, which may be another series
            // of paint or another layer.
            //
            root.nextInSeries = term.nextInSeries;
            root.nextLayer = term.nextLayer;
        }

        ParsedValueImpl[] values = new ParsedValueImpl[6 + stops.length];
        int index = 0;
        values[index++] = focusAngle;
        values[index++] = focusDistance;
        values[index++] = (centerPoint != null) ? centerPoint[0] : null;
        values[index++] = (centerPoint != null) ? centerPoint[1] : null;
        values[index++] = radius;
        values[index++] = cycleMethod;
        for (int n=0; n&lt;stops.length; n++) values[index++] = stops[n];
        return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.RadialGradientConverter.getInstance());
    }

    // Based off http://dev.w3.org/csswg/css3-images/#radial-gradients
    //
    // &lt;radial-gradient&gt; = radial-gradient(
    //        [ focus-angle &lt;angle&gt;, ]?
    //        [ focus-distance &lt;percentage&gt;, ]?
    //        [ center &lt;point&gt;, ]?
    //        radius &lt;length&gt;,
    //        [ [ repeat | reflect ] ,]?
    //        &lt;color-stop&gt;[, &lt;color-stop&gt;]+ )
    //
    // Stops are per http://dev.w3.org/csswg/css3-images/#color-stop-syntax.
    private ParsedValueImpl parseRadialGradient(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;radial-gradient&quot;.regionMatches(true, 0, fn, 0, 15)) {
            final String msg = &quot;Expected \'radial-gradient\'&quot;;
            error(root, msg);
        }

        Term arg;

        if ((arg = root.firstArg) == null ||
             arg.token == null ||
             arg.token.getText().isEmpty()) {
            error(root,
                &quot;Expected \'focus-angle &lt;angle&gt;\' &quot; +
                &quot;or \'focus-distance &lt;percentage&gt;\' &quot; +
                &quot;or \'center &lt;point&gt;\' &quot; +
                &quot;or \'radius [&lt;length&gt; | &lt;percentage&gt;]\'&quot;);
        }

        Term prev = arg;
        ParsedValueImpl&lt;?,Size&gt;focusAngle = null;
        ParsedValueImpl&lt;?,Size&gt;focusDistance = null;
        ParsedValueImpl&lt;?,Size&gt;[] centerPoint = null;
        ParsedValueImpl&lt;?,Size&gt;radius = null;

        if (&quot;focus-angle&quot;.equalsIgnoreCase(arg.token.getText())) {

            prev = arg;
            if ((arg = arg.nextInSeries) == null ||
                    !isSize(arg.token)) error(prev, &quot;Expected \'&lt;angle&gt;\'&quot;);

            Size angle = size(arg.token);
            switch(angle.getUnits()) {
                case DEG:
                case RAD:
                case GRAD:
                case TURN:
                case PX:
                    break;
                default:
                    error(arg, &quot;Expected [deg | rad | grad | turn ]&quot;);
            }
            focusAngle = new ParsedValueImpl&lt;Size,Size&gt;(angle, null);

            prev = arg;
            if ((arg = arg.nextArg) == null)
                error(prev, &quot;Expected \'focus-distance &lt;percentage&gt;\' &quot; +
                            &quot;or \'center &lt;point&gt;\' &quot; +
                            &quot;or \'radius [&lt;length&gt; | &lt;percentage&gt;]\'&quot;);

        }

        if (&quot;focus-distance&quot;.equalsIgnoreCase(arg.token.getText())) {

            prev = arg;
            if ((arg = arg.nextInSeries) == null ||
                    !isSize(arg.token)) error(prev, &quot;Expected \'&lt;percentage&gt;\'&quot;);

            Size distance = size(arg.token);

            // &quot;The focus point is always specified relative to the center
            // point by an angle and a distance relative to the radius.&quot;
            switch(distance.getUnits()) {
                case PERCENT:
                    break;
                default:
                    error(arg, &quot;Expected \'%\'&quot;);
            }
            focusDistance = new ParsedValueImpl&lt;Size,Size&gt;(distance, null);

            prev = arg;
            if ((arg = arg.nextArg) == null)
                error(prev, &quot;Expected \'center &lt;center&gt;\' &quot; +
                            &quot;or \'radius &lt;length&gt;\'&quot;);

        }

        if (&quot;center&quot;.equalsIgnoreCase(arg.token.getText())) {

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'&lt;point&gt;\'&quot;);

            ParsedValueImpl&lt;?,Size&gt; ptX = parseSize(arg);

            prev = arg;
            if ((arg = arg.nextInSeries) == null) error(prev, &quot;Expected \'&lt;point&gt;\'&quot;);

            ParsedValueImpl&lt;?,Size&gt; ptY = parseSize(arg);

            centerPoint = new ParsedValueImpl[] { ptX, ptY };

            prev = arg;
            if ((arg = arg.nextArg) == null)
                error(prev, &quot;Expected \'radius [&lt;length&gt; | &lt;percentage&gt;]\'&quot;);
        }

        if (&quot;radius&quot;.equalsIgnoreCase(arg.token.getText())) {

            prev = arg;
            if ((arg = arg.nextInSeries) == null ||
                !isSize(arg.token)) error(prev, &quot;Expected \'[&lt;length&gt; | &lt;percentage&gt;]\'&quot;);

            radius = parseSize(arg);

            prev = arg;
            if ((arg = arg.nextArg) == null)
                error(prev, &quot;Expected \'radius [&lt;length&gt; | &lt;percentage&gt;]\'&quot;);
        }

        CycleMethod cycleMethod = CycleMethod.NO_CYCLE;
        if (&quot;reflect&quot;.equalsIgnoreCase(arg.token.getText())) {
            cycleMethod = CycleMethod.REFLECT;
            prev = arg;
            arg = arg.nextArg;
        } else if (&quot;repeat&quot;.equalsIgnoreCase(arg.token.getText())) {
            cycleMethod = CycleMethod.REFLECT;
            prev = arg;
            arg = arg.nextArg;
        }

        if (arg == null  ||
            arg.token == null ||
            arg.token.getText().isEmpty()) {
            error(prev, &quot;Expected \'&lt;color-stop&gt;\'&quot;);
        }

        ParsedValueImpl&lt;ParsedValue[],Stop&gt;[] stops = parseColorStops(arg);

        ParsedValueImpl[] values = new ParsedValueImpl[6 + stops.length];
        int index = 0;
        values[index++] = focusAngle;
        values[index++] = focusDistance;
        values[index++] = (centerPoint != null) ? centerPoint[0] : null;
        values[index++] = (centerPoint != null) ? centerPoint[1] : null;
        values[index++] = radius;
        values[index++] = new ParsedValueImpl&lt;String,CycleMethod&gt;(cycleMethod.name(), new EnumConverter&lt;CycleMethod&gt;(CycleMethod.class));
        for (int n=0; n&lt;stops.length; n++) values[index++] = stops[n];
        return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.RadialGradientConverter.getInstance());

    }

    // Based off ImagePattern constructor
    //
    // image-pattern(&lt;uri-string&gt;[,&lt;size&gt;,&lt;size&gt;,&lt;size&gt;,&lt;size&gt;[,&lt;boolean&gt;]?]?)
    //
    private ParsedValueImpl&lt;ParsedValue[], Paint&gt; parseImagePattern(final Term root) throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;image-pattern&quot;.regionMatches(true, 0, fn, 0, 13)) {
            final String msg = &quot;Expected \'image-pattern\'&quot;;
            error(root, msg);
        }

        Term arg;
        if ((arg = root.firstArg) == null ||
             arg.token == null ||
             arg.token.getText().isEmpty()) {
            error(root,
                &quot;Expected \'&lt;uri-string&gt;\'&quot;);
        }

        Term prev = arg;

        final String uri = arg.token.getText();
        ParsedValueImpl[] uriValues = new ParsedValueImpl[] {
            new ParsedValueImpl&lt;String,String&gt;(uri, StringConverter.getInstance()),
            null // placeholder for Stylesheet URL
        };
        ParsedValueImpl parsedURI = new ParsedValueImpl&lt;ParsedValue[],String&gt;(uriValues, URLConverter.getInstance());

        // If nextArg is null, then there are no remaining arguments, so we are done.
        if (arg.nextArg == null) {
            ParsedValueImpl[] values = new ParsedValueImpl[1];
            values[0] = parsedURI;
            return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.ImagePatternConverter.getInstance());
        }

        // There must now be 4 sizes in a row.
        Token token;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;size&gt;\'&quot;);
        ParsedValueImpl&lt;?, Size&gt; x = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;size&gt;\'&quot;);
        ParsedValueImpl&lt;?, Size&gt; y = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;size&gt;\'&quot;);
        ParsedValueImpl&lt;?, Size&gt; w = parseSize(arg);

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;size&gt;\'&quot;);
        ParsedValueImpl&lt;?, Size&gt; h = parseSize(arg);

        // If there are no more args, then we are done.
        if (arg.nextArg == null) {
            ParsedValueImpl[] values = new ParsedValueImpl[5];
            values[0] = parsedURI;
            values[1] = x;
            values[2] = y;
            values[3] = w;
            values[4] = h;
            return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.ImagePatternConverter.getInstance());
        }

        prev = arg;
        if ((arg = arg.nextArg) == null) error(prev, &quot;Expected \'&lt;boolean&gt;\'&quot;);
        if ((token = arg.token) == null || token.getText() == null) error(arg, &quot;Expected \'&lt;boolean&gt;\'&quot;);

        ParsedValueImpl[] values = new ParsedValueImpl[6];
        values[0] = parsedURI;
        values[1] = x;
        values[2] = y;
        values[3] = w;
        values[4] = h;
        values[5] = new ParsedValueImpl&lt;Boolean, Boolean&gt;(Boolean.parseBoolean(token.getText()), null);
        return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.ImagePatternConverter.getInstance());
    }

    // For tiling ImagePatterns easily.
    //
    // repeating-image-pattern(&lt;uri-string&gt;)
    //
    private ParsedValueImpl&lt;ParsedValue[], Paint&gt; parseRepeatingImagePattern(final Term root) throws ParseException {
        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;repeating-image-pattern&quot;.regionMatches(true, 0, fn, 0, 23)) {
            final String msg = &quot;Expected \'repeating-image-pattern\'&quot;;
            error(root, msg);
        }

        Term arg;
        if ((arg = root.firstArg) == null ||
             arg.token == null ||
             arg.token.getText().isEmpty()) {
            error(root,
                &quot;Expected \'&lt;uri-string&gt;\'&quot;);
        }

        final String uri = arg.token.getText();
        ParsedValueImpl[] uriValues = new ParsedValueImpl[] {
            new ParsedValueImpl&lt;String,String&gt;(uri, StringConverter.getInstance()),
            null // placeholder for Stylesheet URL
        };
        ParsedValueImpl parsedURI = new ParsedValueImpl&lt;ParsedValue[],String&gt;(uriValues, URLConverter.getInstance());
        ParsedValueImpl[] values = new ParsedValueImpl[1];
        values[0] = parsedURI;
        return new ParsedValueImpl&lt;ParsedValue[], Paint&gt;(values, PaintConverter.RepeatingImagePatternConverter.getInstance());
    }

    // parse a series of paint values separated by commas.
    // i.e., &lt;paint&gt; [, &lt;paint&gt;]*
    private ParsedValueImpl&lt;ParsedValue&lt;?,Paint&gt;[],Paint[]&gt; parsePaintLayers(Term root)
            throws ParseException {

        // how many paints in the series?
        int nPaints = numberOfLayers(root);

        ParsedValueImpl&lt;?,Paint&gt;[] paints = new ParsedValueImpl[nPaints];

        Term temp = root;
        int paint = 0;

        do {
            if (temp.token == null ||
                temp.token.getText() == null ||
                temp.token.getText().isEmpty()) error(temp, &quot;Expected \'&lt;paint&gt;\'&quot;);

            paints[paint++] = (ParsedValueImpl&lt;?,Paint&gt;)parse(temp);

            temp = nextLayer(temp);
        } while (temp != null);

        return new ParsedValueImpl&lt;ParsedValue&lt;?,Paint&gt;[],Paint[]&gt;(paints, PaintConverter.SequenceConverter.getInstance());

    }

    // An size or a series of four size values
    // &lt;size&gt; | &lt;size&gt; &lt;size&gt; &lt;size&gt; &lt;size&gt;
    private ParsedValueImpl&lt;?,Size&gt;[] parseSize1to4(final Term root)
            throws ParseException {

        Term temp = root;
        ParsedValueImpl&lt;?,Size&gt;[] sides = new ParsedValueImpl[4];
        int side = 0;

        while (side &lt; 4 &amp;&amp; temp != null) {
            sides[side++] = parseSize(temp);
            temp = temp.nextInSeries;
        }

        if (side &lt; 2) sides[1] = sides[0]; // right = top
        if (side &lt; 3) sides[2] = sides[0]; // bottom = top
        if (side &lt; 4) sides[3] = sides[1]; // left = right

        return sides;
    }

    // A series of inset or sets of four inset values
    // &lt;size&gt; | &lt;size&gt; &lt;size&gt; &lt;size&gt; &lt;size&gt; [ , [ &lt;size&gt; | &lt;size&gt; &lt;size&gt; &lt;size&gt; &lt;size&gt;] ]*
    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],Insets&gt;[], Insets[]&gt; parseInsetsLayers(Term root)
            throws ParseException {

        int nLayers = numberOfLayers(root);

        Term temp = root;
        int layer = 0;
        ParsedValueImpl&lt;ParsedValue[],Insets&gt;[] layers = new ParsedValueImpl[nLayers];

        while(temp != null) {
            ParsedValueImpl&lt;?,Size&gt;[] sides = parseSize1to4(temp);
            layers[layer++] = new ParsedValueImpl&lt;ParsedValue[],Insets&gt;(sides, InsetsConverter.getInstance());
            while(temp.nextInSeries != null) {
                temp = temp.nextInSeries;
            }
            temp = nextLayer(temp);
        }

        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],Insets&gt;[], Insets[]&gt;(layers, InsetsConverter.SequenceConverter.getInstance());
    }

    // A single inset (1, 2, 3, or 4 digits)
    // &lt;size&gt; | &lt;size&gt; &lt;size&gt; &lt;size&gt; &lt;size&gt;
    private ParsedValueImpl&lt;ParsedValue[],Insets&gt; parseInsetsLayer(Term root)
            throws ParseException {

        Term temp = root;
        ParsedValueImpl&lt;ParsedValue[],Insets&gt; layer = null;

        while(temp != null) {
            ParsedValueImpl&lt;?,Size&gt;[] sides = parseSize1to4(temp);
            layer = new ParsedValueImpl&lt;ParsedValue[],Insets&gt;(sides, InsetsConverter.getInstance());
            while(temp.nextInSeries != null) {
                temp = temp.nextInSeries;
            }
            temp = nextLayer(temp);
        }
        return layer;
    }

    // &lt;size&gt; | &lt;size&gt; &lt;size&gt; &lt;size&gt; &lt;size&gt;
    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],Margins&gt;[], Margins[]&gt; parseMarginsLayers(Term root)
            throws ParseException {

        int nLayers = numberOfLayers(root);

        Term temp = root;
        int layer = 0;
        ParsedValueImpl&lt;ParsedValue[],Margins&gt;[] layers = new ParsedValueImpl[nLayers];

        while(temp != null) {
            ParsedValueImpl&lt;?,Size&gt;[] sides = parseSize1to4(temp);
            layers[layer++] = new ParsedValueImpl&lt;ParsedValue[],Margins&gt;(sides, Margins.Converter.getInstance());
            while(temp.nextInSeries != null) {
                temp = temp.nextInSeries;
            }
            temp = nextLayer(temp);
        }

        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],Margins&gt;[], Margins[]&gt;(layers, Margins.SequenceConverter.getInstance());
    }

    // &lt;size&gt; | &lt;size&gt; &lt;size&gt; &lt;size&gt; &lt;size&gt;
    private ParsedValueImpl&lt;Size, Size&gt;[] parseSizeSeries(Term root)
            throws ParseException {

        if (root.token == null) error(root, &quot;Parse error&quot;);

        List&lt;ParsedValueImpl&lt;Size,Size&gt;&gt; sizes = new ArrayList&lt;&gt;();

        Term term = root;
        while(term != null) {
            Token token = term.token;
            final int ttype = token.getType();
            switch (ttype) {
                case CssLexer.NUMBER:
                case CssLexer.PERCENTAGE:
                case CssLexer.EMS:
                case CssLexer.EXS:
                case CssLexer.PX:
                case CssLexer.CM:
                case CssLexer.MM:
                case CssLexer.IN:
                case CssLexer.PT:
                case CssLexer.PC:
                case CssLexer.DEG:
                case CssLexer.GRAD:
                case CssLexer.RAD:
                case CssLexer.TURN:
                    ParsedValueImpl sizeValue = new ParsedValueImpl&lt;Size, Size&gt;(size(token), null);
                    sizes.add(sizeValue);
                    break;
                default:
                    error (root, &quot;expected series of &lt;size&gt;&quot;);
            }
            term = term.nextInSeries;
        }
        return sizes.toArray(new ParsedValueImpl[sizes.size()]);

    }

    // http://www.w3.org/TR/css3-background/#the-border-radius
    // &lt;size&gt;{1,4} [ '/' &lt;size&gt;{1,4}]? [',' &lt;size&gt;{1,4} [ '/' &lt;size&gt;{1,4}]?]?
    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue&lt;?,Size&gt;[][],CornerRadii&gt;[], CornerRadii[]&gt; parseCornerRadius(Term root)
            throws ParseException {


        int nLayers = numberOfLayers(root);

        Term term = root;
        int layer = 0;
        ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;[][],CornerRadii&gt;[] layers = new ParsedValueImpl[nLayers];

        while(term != null) {

            int nHorizontalTerms = 0;
            Term temp = term;
            while (temp != null) {
                if (temp.token.getType() == CssLexer.SOLIDUS) {
                    temp = temp.nextInSeries;
                    break;
                }
                nHorizontalTerms += 1;
                temp = temp.nextInSeries;
            };

            int nVerticalTerms = 0;
            while (temp != null) {
                if (temp.token.getType() == CssLexer.SOLIDUS) {
                    error(temp, &quot;unexpected SOLIDUS&quot;);
                    break;
                }
                nVerticalTerms += 1;
                temp = temp.nextInSeries;
            }

            if ((nHorizontalTerms == 0 || nHorizontalTerms &gt; 4) || nVerticalTerms &gt; 4) {
                error(root, &quot;expected [&lt;length&gt;|&lt;percentage&gt;]{1,4} [/ [&lt;length&gt;|&lt;percentage&gt;]{1,4}]?&quot;);
            }

            // used as index into margins[]. horizontal = 0, vertical = 1
            int orientation = 0;

            // at most, there should be four radii in the horizontal orientation and four in the vertical.
            ParsedValueImpl&lt;?,Size&gt;[][] radii = new ParsedValueImpl[2][4];

            ParsedValueImpl&lt;?,Size&gt; zero = new ParsedValueImpl&lt;Size,Size&gt;(new Size(0,SizeUnits.PX), null);
            for (int r=0; r&lt;4; r++) { radii[0][r] = zero; radii[1][r] = zero; }

            int hr = 0;
            int vr = 0;

            Term lastTerm = term;
            while ((hr &lt;= 4) &amp;&amp; (vr &lt;= 4) &amp;&amp; (term != null)) {

                if (term.token.getType() == CssLexer.SOLIDUS) {
                    orientation += 1;
                } else  {
                    ParsedValueImpl&lt;?,Size&gt; parsedValue = parseSize(term);
                    if (orientation == 0) {
                        radii[orientation][hr++] = parsedValue;
                    } else {
                        radii[orientation][vr++] = parsedValue;
                    }
                }
                lastTerm = term;
                term = term.nextInSeries;
            }

            //
            // http://www.w3.org/TR/css3-background/#the-border-radius
            // The four values for each radii are given in the order top-left, top-right, bottom-right, bottom-left.
            // If bottom-left is omitted it is the same as top-right.
            // If bottom-right is omitted it is the same as top-left.
            // If top-right is omitted it is the same as top-left.
            //
            // If there is no vertical component, then set both equally.
            // If either is zero, then both are zero.
            //

            // if hr == 0, then there were no horizontal radii (which would be an error caught above)
            if (hr != 0) {
                if (hr &lt; 2) radii[0][1] = radii[0][0]; // top-right = top-left
                if (hr &lt; 3) radii[0][2] = radii[0][0]; // bottom-right = top-left
                if (hr &lt; 4) radii[0][3] = radii[0][1]; // bottom-left = top-right
            } else {
                assert(false);
            }

            // if vr == 0, then there were no vertical radii
            if (vr != 0) {
                if (vr &lt; 2) radii[1][1] = radii[1][0]; // top-right = top-left
                if (vr &lt; 3) radii[1][2] = radii[1][0]; // bottom-right = top-left
                if (vr &lt; 4) radii[1][3] = radii[1][1]; // bottom-left = top-right
            } else {
                // if no vertical, the vertical value is same as horizontal
                radii[1][0] = radii[0][0];
                radii[1][1] = radii[0][1];
                radii[1][2] = radii[0][2];
                radii[1][3] = radii[0][3];
            }

            // if either is zero, both are zero
            if (zero.equals(radii[0][0]) || zero.equals(radii[1][0])) { radii[1][0] = radii[0][0] = zero; }
            if (zero.equals(radii[0][1]) || zero.equals(radii[1][1])) { radii[1][1] = radii[0][1] = zero; }
            if (zero.equals(radii[0][2]) || zero.equals(radii[1][2])) { radii[1][2] = radii[0][2] = zero; }
            if (zero.equals(radii[0][3]) || zero.equals(radii[1][3])) { radii[1][3] = radii[0][3] = zero; }

            layers[layer++] = new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;[][],CornerRadii&gt;(radii, null);

            term = nextLayer(lastTerm);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue&lt;?,Size&gt;[][],CornerRadii&gt;[], CornerRadii[]&gt;(layers, CornerRadiiConverter.getInstance());
    }

    /* Constant for background position */
    private final static ParsedValueImpl&lt;Size,Size&gt; ZERO_PERCENT =
            new ParsedValueImpl&lt;Size,Size&gt;(new Size(0f, SizeUnits.PERCENT), null);
    /* Constant for background position */
    private final static ParsedValueImpl&lt;Size,Size&gt; FIFTY_PERCENT =
            new ParsedValueImpl&lt;Size,Size&gt;(new Size(50f, SizeUnits.PERCENT), null);
    /* Constant for background position */
    private final static ParsedValueImpl&lt;Size,Size&gt; ONE_HUNDRED_PERCENT =
            new ParsedValueImpl&lt;Size,Size&gt;(new Size(100f, SizeUnits.PERCENT), null);

    private static boolean isPositionKeyWord(String value) {
        return &quot;center&quot;.equalsIgnoreCase(value) || &quot;top&quot;.equalsIgnoreCase(value) || &quot;bottom&quot;.equalsIgnoreCase(value) || &quot;left&quot;.equalsIgnoreCase(value) || &quot;right&quot;.equalsIgnoreCase(value);
    }

    /*
     * http://www.w3.org/TR/css3-background/#the-background-position
     *
     * &lt;bg-position&gt; = [
     *   [ top | bottom ]
     * |
     *   [ &lt;percentage&gt; | &lt;length&gt; | left | center | right ]
     *   [ &lt;percentage&gt; | &lt;length&gt; | top  | center | bottom ]?
     * |
     *   [ center | [ left | right  ] [ &lt;percentage&gt; | &lt;length&gt; ]? ] &amp;&amp;
     *   [ center | [ top  | bottom ] [ &lt;percentage&gt; | &lt;length&gt; ]? ]
     * ]
     *
     * From the W3 spec:
     *
     * returned ParsedValueImpl is [size, size, size, size] with the semantics
     * [top offset, right offset, bottom offset left offset]
     */
    private ParsedValueImpl&lt;ParsedValue[], BackgroundPosition&gt; parseBackgroundPosition(Term term)
        throws ParseException {

        if (term.token == null ||
            term.token.getText() == null ||
            term.token.getText().isEmpty()) error(term, &quot;Expected \'&lt;bg-position&gt;\'&quot;);

        Term  termOne = term;
        Token valueOne = term.token;

        Term  termTwo = termOne.nextInSeries;
        Token valueTwo = (termTwo != null) ? termTwo.token : null;

        Term termThree = (termTwo != null) ? termTwo.nextInSeries : null;
        Token valueThree = (termThree != null) ? termThree.token : null;

        Term termFour = (termThree != null) ? termThree.nextInSeries : null;
        Token valueFour = (termFour != null) ? termFour.token : null;

        // are the horizontal and vertical exchanged
        if( valueOne != null &amp;&amp; valueTwo != null &amp;&amp; valueThree == null &amp;&amp; valueFour == null ) {
            // 2 values filled
            String v1 = valueOne.getText();
            String v2 = valueTwo.getText();
            if( (&quot;top&quot;.equals(v1) || &quot;bottom&quot;.equals(v1))
                    &amp;&amp; (&quot;left&quot;.equals(v2) || &quot;right&quot;.equals(v2) || &quot;center&quot;.equals(v2)) ) {
                {
                    Token tmp = valueTwo;
                    valueTwo = valueOne;
                    valueOne = tmp;
                }

                {
                    Term tmp = termTwo;
                    termTwo = termOne;
                    termOne = tmp;
                }
            }
        } else if( valueOne != null &amp;&amp; valueTwo != null &amp;&amp; valueThree != null ) {
            Term[] termArray = null;
            Token[] tokeArray = null;
            // 4 values filled
            if( valueFour != null ) {
                if( (&quot;top&quot;.equals(valueOne.getText()) || &quot;bottom&quot;.equals(valueOne.getText()))
                        &amp;&amp; (&quot;left&quot;.equals(valueThree.getText()) || &quot;right&quot;.equals(valueThree.getText())) ) {
                    // e.g. top 50 left 20
                    termArray = new Term[] { termThree, termFour, termOne, termTwo };
                    tokeArray = new Token[] { valueThree, valueFour, valueOne, valueTwo };
                }
            } else {
                if( (&quot;top&quot;.equals(valueOne.getText()) || &quot;bottom&quot;.equals(valueOne.getText())) ) {
                    if( (&quot;left&quot;.equals(valueTwo.getText()) || &quot;right&quot;.equals(valueTwo.getText())) ) {
                        // e.g. top left 50
                        termArray = new Term[] { termTwo, termThree, termOne, null };
                        tokeArray = new Token[] { valueTwo, valueThree, valueOne, null };
                    } else {
                        // e.g. top 50 left
                        termArray = new Term[] { termThree, termOne, termTwo, null };
                        tokeArray = new Token[] { valueThree, valueOne, valueTwo, null };
                    }
                }
            }

            if( termArray != null ) {
                termOne = termArray[0];
                termTwo = termArray[1];
                termThree = termArray[2];
                termFour = termArray[3];

                valueOne = tokeArray[0];
                valueTwo = tokeArray[1];
                valueThree = tokeArray[2];
                valueFour = tokeArray[3];
            }
        }


        ParsedValueImpl&lt;?,Size&gt; top, right, bottom, left;
        top = right = bottom = left = ZERO_PERCENT;
        {
            if(valueOne == null &amp;&amp; valueTwo == null &amp;&amp; valueThree == null &amp;&amp; valueFour == null) {
                error(term, &quot;No value found for background-position&quot;);
            } else if( valueOne != null &amp;&amp; valueTwo == null &amp;&amp; valueThree == null &amp;&amp; valueFour == null ) {
                // Only one value
                String v1 = valueOne.getText();

                if( &quot;center&quot;.equals(v1) ) {
                    left = FIFTY_PERCENT;
                    right = ZERO_PERCENT;

                    top = FIFTY_PERCENT;
                    bottom = ZERO_PERCENT;

                } else if(&quot;left&quot;.equals(v1)) {
                    left = ZERO_PERCENT;
                    right = ZERO_PERCENT;

                    top = FIFTY_PERCENT;
                    bottom = ZERO_PERCENT;

                } else if( &quot;right&quot;.equals(v1) ) {
                    left = ONE_HUNDRED_PERCENT;
                    right = ZERO_PERCENT;

                    top = FIFTY_PERCENT;
                    bottom = ZERO_PERCENT;

                } else if( &quot;top&quot;.equals(v1) ) {
                    left = FIFTY_PERCENT;
                    right = ZERO_PERCENT;

                    top = ZERO_PERCENT;
                    bottom = ZERO_PERCENT;

                } else if( &quot;bottom&quot;.equals(v1) ) {
                    left = FIFTY_PERCENT;
                    right = ZERO_PERCENT;

                    top = ONE_HUNDRED_PERCENT;
                    bottom = ZERO_PERCENT;
                } else {
                    left = parseSize(termOne);
                    right = ZERO_PERCENT;
                    top = FIFTY_PERCENT;
                    bottom = ZERO_PERCENT;
                }
            } else if( valueOne != null &amp;&amp; valueTwo != null &amp;&amp; valueThree == null &amp;&amp; valueFour == null ) {
                // 2 values
                String v1 = valueOne.getText().toLowerCase(Locale.ROOT);
                String v2 = valueTwo.getText().toLowerCase(Locale.ROOT);

                if( ! isPositionKeyWord(v1) ) {
                    left = parseSize(termOne);
                    right = ZERO_PERCENT;

                    if( &quot;top&quot;.equals(v2) ) {
                        top = ZERO_PERCENT;
                        bottom = ZERO_PERCENT;
                    } else if( &quot;bottom&quot;.equals(v2) ) {
                        top = ONE_HUNDRED_PERCENT;
                        bottom = ZERO_PERCENT;
                    } else if( &quot;center&quot;.equals(v2) ) {
                        top = FIFTY_PERCENT;
                        bottom = ZERO_PERCENT;
                    } else if( !isPositionKeyWord(v2) ) {
                        top = parseSize(termTwo);
                        bottom = ZERO_PERCENT;
                    } else {
                        error(termTwo,&quot;Expected 'top', 'bottom', 'center' or &lt;size&gt;&quot;);
                    }
                } else if( v1.equals(&quot;left&quot;) || v1.equals(&quot;right&quot;) ) {
                    left = v1.equals(&quot;right&quot;) ? ONE_HUNDRED_PERCENT : ZERO_PERCENT;
                    right = ZERO_PERCENT;

                    if( ! isPositionKeyWord(v2) ) {
                        top = parseSize(termTwo);
                        bottom = ZERO_PERCENT;
                    } else if( v2.equals(&quot;top&quot;) || v2.equals(&quot;bottom&quot;) || v2.equals(&quot;center&quot;) ) {
                        if( v2.equals(&quot;top&quot;) ) {
                            top = ZERO_PERCENT;
                            bottom = ZERO_PERCENT;
                        } else if(v2.equals(&quot;center&quot;)) {
                            top = FIFTY_PERCENT;
                            bottom = ZERO_PERCENT;
                        } else {
                            top = ONE_HUNDRED_PERCENT;
                            bottom = ZERO_PERCENT;
                        }
                    } else {
                        error(termTwo,&quot;Expected 'top', 'bottom', 'center' or &lt;size&gt;&quot;);
                    }
                } else if( v1.equals(&quot;center&quot;) ) {
                    left = FIFTY_PERCENT;
                    right = ZERO_PERCENT;

                    if( v2.equals(&quot;top&quot;) ) {
                        top = ZERO_PERCENT;
                        bottom = ZERO_PERCENT;
                    } else if( v2.equals(&quot;bottom&quot;) ) {
                        top = ONE_HUNDRED_PERCENT;
                        bottom = ZERO_PERCENT;
                    } else if( v2.equals(&quot;center&quot;) ) {
                        top = FIFTY_PERCENT;
                        bottom = ZERO_PERCENT;
                    } else if( ! isPositionKeyWord(v2) ) {
                        top = parseSize(termTwo);
                        bottom = ZERO_PERCENT;
                    } else {
                        error(termTwo,&quot;Expected 'top', 'bottom', 'center' or &lt;size&gt;&quot;);
                    }
                }
            } else if( valueOne != null &amp;&amp; valueTwo != null &amp;&amp; valueThree != null &amp;&amp; valueFour == null ) {
                String v1 = valueOne.getText().toLowerCase(Locale.ROOT);
                String v2 = valueTwo.getText().toLowerCase(Locale.ROOT);
                String v3 = valueThree.getText().toLowerCase(Locale.ROOT);

                if( ! isPositionKeyWord(v1) || &quot;center&quot;.equals(v1) ) {
                    // 1 is horizontal
                    // means 2 &amp; 3 are vertical
                    if( &quot;center&quot;.equals(v1) ) {
                        left = FIFTY_PERCENT;
                    } else {
                        left = parseSize(termOne);
                    }
                    right = ZERO_PERCENT;

                    if( !isPositionKeyWord(v3) ) {
                        if( &quot;top&quot;.equals(v2) ) {
                            top = parseSize(termThree);
                            bottom = ZERO_PERCENT;
                        } else if( &quot;bottom&quot;.equals(v2) ) {
                            top = ZERO_PERCENT;
                            bottom = parseSize(termThree);
                        } else {
                            error(termTwo,&quot;Expected 'top' or 'bottom'&quot;);
                        }
                    } else {
                        error(termThree,&quot;Expected &lt;size&gt;&quot;);
                    }
                } else if( &quot;left&quot;.equals(v1) || &quot;right&quot;.equals(v1)  ) {
                    if( ! isPositionKeyWord(v2) ) {
                        // 1 &amp; 2 are horizontal
                        // 3 is vertical
                        if( &quot;left&quot;.equals(v1) ) {
                            left = parseSize(termTwo);
                            right = ZERO_PERCENT;
                        } else {
                            left = ZERO_PERCENT;
                            right = parseSize(termTwo);
                        }

                        if( &quot;top&quot;.equals(v3) ) {
                            top = ZERO_PERCENT;
                            bottom = ZERO_PERCENT;
                        } else if( &quot;bottom&quot;.equals(v3) ) {
                            top = ONE_HUNDRED_PERCENT;
                            bottom = ZERO_PERCENT;
                        } else if( &quot;center&quot;.equals(v3) ) {
                            top = FIFTY_PERCENT;
                            bottom = ZERO_PERCENT;
                        } else {
                            error(termThree,&quot;Expected 'top', 'bottom' or 'center'&quot;);
                        }
                    } else {
                        // 1 is horizontal
                        // 2 &amp; 3 are vertical
                        if( &quot;left&quot;.equals(v1) ) {
                            left = ZERO_PERCENT;
                            right = ZERO_PERCENT;
                        } else {
                            left = ONE_HUNDRED_PERCENT;
                            right = ZERO_PERCENT;
                        }

                        if( ! isPositionKeyWord(v3) ) {
                            if( &quot;top&quot;.equals(v2) ) {
                                top = parseSize(termThree);
                                bottom = ZERO_PERCENT;
                            } else if( &quot;bottom&quot;.equals(v2) ) {
                                top = ZERO_PERCENT;
                                bottom = parseSize(termThree);
                            } else {
                                error(termTwo,&quot;Expected 'top' or 'bottom'&quot;);
                            }
                        } else {
                            error(termThree,&quot;Expected &lt;size&gt;&quot;);
                        }
                    }
                }
            } else {
                String v1 = valueOne.getText().toLowerCase(Locale.ROOT);
                String v2 = valueTwo.getText().toLowerCase(Locale.ROOT);
                String v3 = valueThree.getText().toLowerCase(Locale.ROOT);
                String v4 = valueFour.getText().toLowerCase(Locale.ROOT);

                if( (v1.equals(&quot;left&quot;) || v1.equals(&quot;right&quot;)) &amp;&amp; (v3.equals(&quot;top&quot;) || v3.equals(&quot;bottom&quot;) ) &amp;&amp; ! isPositionKeyWord(v2) &amp;&amp; ! isPositionKeyWord(v4) ) {
                    if( v1.equals(&quot;left&quot;) ) {
                        left = parseSize(termTwo);
                        right = ZERO_PERCENT;
                    } else {
                        left = ZERO_PERCENT;
                        right = parseSize(termTwo);
                    }

                    if( v3.equals(&quot;top&quot;) ) {
                        top = parseSize(termFour);
                        bottom = ZERO_PERCENT;
                    } else {
                        top = ZERO_PERCENT;
                        bottom = parseSize(termFour);
                    }

                } else {
                    error(term,&quot;Expected 'left' or 'right' followed by &lt;size&gt; followed by 'top' or 'bottom' followed by &lt;size&gt;&quot;);
                }
            }
        }

        ParsedValueImpl&lt;?,Size&gt;[] values = new ParsedValueImpl[] {top, right, bottom, left};
        return new ParsedValueImpl&lt;ParsedValue[], BackgroundPosition&gt;(values, BackgroundPositionConverter.getInstance());
    }

    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[], BackgroundPosition&gt;[], BackgroundPosition[]&gt;
            parseBackgroundPositionLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;ParsedValue[], BackgroundPosition&gt;[] layers = new ParsedValueImpl[nLayers];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseBackgroundPosition(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[], BackgroundPosition&gt;[], BackgroundPosition[]&gt;(layers, LayeredBackgroundPositionConverter.getInstance());
    }

    /*
    http://www.w3.org/TR/css3-background/#the-background-repeat
    &lt;repeat-style&gt; = repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
    */
    private ParsedValueImpl&lt;String, BackgroundRepeat&gt;[] parseRepeatStyle(final Term root)
            throws ParseException {

        BackgroundRepeat xAxis, yAxis;
        xAxis = yAxis = BackgroundRepeat.NO_REPEAT;

        Term term = root;

        if (term.token == null ||
            term.token.getType() != CssLexer.IDENT ||
            term.token.getText() == null ||
            term.token.getText().isEmpty()) error(term, &quot;Expected \'&lt;repeat-style&gt;\'&quot;);

        String text = term.token.getText().toLowerCase(Locale.ROOT);
        if (&quot;repeat-x&quot;.equals(text)) {
            xAxis = BackgroundRepeat.REPEAT;
            yAxis = BackgroundRepeat.NO_REPEAT;
        } else if (&quot;repeat-y&quot;.equals(text)) {
            xAxis = BackgroundRepeat.NO_REPEAT;
            yAxis = BackgroundRepeat.REPEAT;
        } else if (&quot;repeat&quot;.equals(text)) {
            xAxis = BackgroundRepeat.REPEAT;
            yAxis = BackgroundRepeat.REPEAT;
        } else if (&quot;space&quot;.equals(text)) {
            xAxis = BackgroundRepeat.SPACE;
            yAxis = BackgroundRepeat.SPACE;
        } else if (&quot;round&quot;.equals(text)) {
            xAxis = BackgroundRepeat.ROUND;
            yAxis = BackgroundRepeat.ROUND;
        } else if (&quot;no-repeat&quot;.equals(text)) {
            xAxis = BackgroundRepeat.NO_REPEAT;
            yAxis = BackgroundRepeat.NO_REPEAT;
        } else if (&quot;stretch&quot;.equals(text)) {
            xAxis = BackgroundRepeat.NO_REPEAT;
            yAxis = BackgroundRepeat.NO_REPEAT;
        } else {
            error(term, &quot;Expected  \'&lt;repeat-style&gt;\' &quot; + text);
        }

        if ((term = term.nextInSeries) != null &amp;&amp;
             term.token != null &amp;&amp;
             term.token.getType() == CssLexer.IDENT &amp;&amp;
             term.token.getText() != null &amp;&amp;
             !term.token.getText().isEmpty()) {

            text = term.token.getText().toLowerCase(Locale.ROOT);
            if (&quot;repeat-x&quot;.equals(text)) {
                error(term, &quot;Unexpected \'repeat-x\'&quot;);
            } else if (&quot;repeat-y&quot;.equals(text)) {
                error(term, &quot;Unexpected \'repeat-y\'&quot;);
            } else if (&quot;repeat&quot;.equals(text)) {
                yAxis = BackgroundRepeat.REPEAT;
            } else if (&quot;space&quot;.equals(text)) {
                yAxis = BackgroundRepeat.SPACE;
            } else if (&quot;round&quot;.equals(text)) {
                yAxis = BackgroundRepeat.ROUND;
            } else if (&quot;no-repeat&quot;.equals(text)) {
                yAxis = BackgroundRepeat.NO_REPEAT;
            } else if (&quot;stretch&quot;.equals(text)) {
                yAxis = BackgroundRepeat.NO_REPEAT;
            } else {
                error(term, &quot;Expected  \'&lt;repeat-style&gt;\'&quot;);
            }
        }

        return new ParsedValueImpl[] {
            new ParsedValueImpl&lt;String,BackgroundRepeat&gt;(xAxis.name(), new EnumConverter&lt;BackgroundRepeat&gt;(BackgroundRepeat.class)),
            new ParsedValueImpl&lt;String,BackgroundRepeat&gt;(yAxis.name(), new EnumConverter&lt;BackgroundRepeat&gt;(BackgroundRepeat.class))
        };
    }

    private ParsedValueImpl&lt;ParsedValue&lt;String, BackgroundRepeat&gt;[][],RepeatStruct[]&gt;
            parseBorderImageRepeatStyleLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;String, BackgroundRepeat&gt;[][] layers = new ParsedValueImpl[nLayers][];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseRepeatStyle(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;String, BackgroundRepeat&gt;[][],RepeatStruct[]&gt;(layers, RepeatStructConverter.getInstance());
    }


    private ParsedValueImpl&lt;ParsedValue&lt;String, BackgroundRepeat&gt;[][], RepeatStruct[]&gt;
            parseBackgroundRepeatStyleLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;String, BackgroundRepeat&gt;[][] layers = new ParsedValueImpl[nLayers][];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseRepeatStyle(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;String, BackgroundRepeat&gt;[][], RepeatStruct[]&gt;(layers, RepeatStructConverter.getInstance());
    }

    /*
    http://www.w3.org/TR/css3-background/#the-background-size
    &lt;bg-size&gt; = [ &lt;length&gt; | &lt;percentage&gt; | auto ]{1,2} | cover | contain
    */
    private ParsedValueImpl&lt;ParsedValue[], BackgroundSize&gt; parseBackgroundSize(final Term root)
        throws ParseException {

        ParsedValueImpl&lt;?,Size&gt; height = null, width = null;
        boolean cover = false, contain = false;

        Term term = root;
        if (term.token == null) error(term, &quot;Expected \'&lt;bg-size&gt;\'&quot;);

        if (term.token.getType() == CssLexer.IDENT) {
            final String text =
                (term.token.getText() != null) ? term.token.getText().toLowerCase(Locale.ROOT) : null;

            if (&quot;auto&quot;.equals(text)) {
                // We don't do anything because width / height are already initialized
            } else if (&quot;cover&quot;.equals(text)) {
                cover = true;
            } else if (&quot;contain&quot;.equals(text)) {
                contain = true;
            } else if (&quot;stretch&quot;.equals(text)) {
                width = ONE_HUNDRED_PERCENT;
                height = ONE_HUNDRED_PERCENT;
            } else {
                error(term, &quot;Expected \'auto\', \'cover\', \'contain\', or  \'stretch\'&quot;);
            }
        } else if (isSize(term.token)) {
            width = parseSize(term);
            height = null;
        } else {
            error(term, &quot;Expected \'&lt;bg-size&gt;\'&quot;);
        }

        if ((term = term.nextInSeries) != null) {
            if (cover || contain) error(term, &quot;Unexpected \'&lt;bg-size&gt;\'&quot;);

            if (term.token.getType() == CssLexer.IDENT) {
                final String text =
                    (term.token.getText() != null) ? term.token.getText().toLowerCase(Locale.ROOT) : null;

                if (&quot;auto&quot;.equals(text)) {
                    height = null;
                } else if (&quot;cover&quot;.equals(text)) {
                    error(term, &quot;Unexpected \'cover\'&quot;);
                } else if (&quot;contain&quot;.equals(text)) {
                    error(term, &quot;Unexpected \'contain\'&quot;);
                } else if (&quot;stretch&quot;.equals(text)) {
                    height = ONE_HUNDRED_PERCENT;
                } else {
                    error(term, &quot;Expected \'auto\' or \'stretch\'&quot;);
                }
            } else if (isSize(term.token)) {
                height = parseSize(term);
            } else {
                error(term, &quot;Expected \'&lt;bg-size&gt;\'&quot;);
            }

        }

        ParsedValueImpl[] values = new ParsedValueImpl[] {
            width,
            height,
            // TODO: handling of booleans is really bogus
            new ParsedValueImpl&lt;String,Boolean&gt;((cover ? &quot;true&quot; : &quot;false&quot;), BooleanConverter.getInstance()),
            new ParsedValueImpl&lt;String,Boolean&gt;((contain ? &quot;true&quot; : &quot;false&quot;), BooleanConverter.getInstance())
        };
        return new ParsedValueImpl&lt;ParsedValue[], BackgroundSize&gt;(values, BackgroundSizeConverter.getInstance());
    }

    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[], BackgroundSize&gt;[],  BackgroundSize[]&gt;
            parseBackgroundSizeLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;ParsedValue[], BackgroundSize&gt;[] layers = new ParsedValueImpl[nLayers];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseBackgroundSize(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[], BackgroundSize&gt;[], BackgroundSize[]&gt;(layers, LayeredBackgroundSizeConverter.getInstance());
    }

    private ParsedValueImpl&lt;ParsedValue&lt;?,Paint&gt;[], Paint[]&gt; parseBorderPaint(final Term root)
        throws ParseException {

        Term term = root;
        ParsedValueImpl&lt;?,Paint&gt;[] paints = new ParsedValueImpl[4];
        int paint = 0;

        while(term != null) {
            if (term.token == null || paints.length &lt;= paint) error(term, &quot;Expected \'&lt;paint&gt;\'&quot;);
            paints[paint++] = parse(term);
            term = term.nextInSeries;
        }

        if (paint &lt; 2) paints[1] = paints[0]; // right = top
        if (paint &lt; 3) paints[2] = paints[0]; // bottom = top
        if (paint &lt; 4) paints[3] = paints[1]; // left = right

        return new ParsedValueImpl&lt;ParsedValue&lt;?,Paint&gt;[], Paint[]&gt;(paints, StrokeBorderPaintConverter.getInstance());
    }

    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue&lt;?,Paint&gt;[],Paint[]&gt;[], Paint[][]&gt; parseBorderPaintLayers(final Term root)
        throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;ParsedValue&lt;?,Paint&gt;[],Paint[]&gt;[] layers = new ParsedValueImpl[nLayers];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseBorderPaint(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue&lt;?,Paint&gt;[],Paint[]&gt;[], Paint[][]&gt;(layers, LayeredBorderPaintConverter.getInstance());
    }

    // borderStyle (borderStyle (borderStyle borderStyle?)?)?
    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderStrokeStyle&gt;[],BorderStrokeStyle[]&gt; parseBorderStyleSeries(final Term root)
            throws ParseException {

        Term term = root;
        ParsedValueImpl&lt;ParsedValue[],BorderStrokeStyle&gt;[] borders = new ParsedValueImpl[4];
        int border = 0;
        while (term != null) {
            borders[border++] = parseBorderStyle(term);
            term = term.nextInSeries;
        }

        if (border &lt; 2) borders[1] = borders[0]; // right = top
        if (border &lt; 3) borders[2] = borders[0]; // bottom = top
        if (border &lt; 4) borders[3] = borders[1]; // left = right

        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderStrokeStyle&gt;[],BorderStrokeStyle[]&gt;(borders, BorderStrokeStyleSequenceConverter.getInstance());
    }


    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue&lt;ParsedValue[],BorderStrokeStyle&gt;[],BorderStrokeStyle[]&gt;[], BorderStrokeStyle[][]&gt;
            parseBorderStyleLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderStrokeStyle&gt;[],BorderStrokeStyle[]&gt;[] layers = new ParsedValueImpl[nLayers];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseBorderStyleSeries(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue&lt;ParsedValue[],BorderStrokeStyle&gt;[],BorderStrokeStyle[]&gt;[], BorderStrokeStyle[][]&gt;(layers, LayeredBorderStyleConverter.getInstance());
    }

    // Only meant to be used from parseBorderStyle, but might be useful elsewhere
    private String getKeyword(final Term term) {
        if (term != null &amp;&amp;
             term.token != null &amp;&amp;
             term.token.getType() == CssLexer.IDENT &amp;&amp;
             term.token.getText() != null &amp;&amp;
             !term.token.getText().isEmpty()) {

            return term.token.getText().toLowerCase(Locale.ROOT);
        }
        return null;
    }

    //&lt;border-style&gt; [ , &lt;border-style&gt; ]*
    // where &lt;border-style&gt; =
    //      &lt;dash-style&gt; [centered | inside | outside]? [line-join [miter &lt;number&gt; | bevel | round]]? [line-cap [square | butt | round]]?
    // where &lt;dash-style&gt; =
    //      [ none | solid | dotted | dashed ]
    private ParsedValueImpl&lt;ParsedValue[],BorderStrokeStyle&gt; parseBorderStyle(final Term root)
            throws ParseException {


        ParsedValue&lt;ParsedValue[],Number[]&gt; dashStyle = null;
        ParsedValue&lt;ParsedValue&lt;?,Size&gt;,Number&gt; dashPhase = null;
        ParsedValue&lt;String,StrokeType&gt; strokeType = null;
        ParsedValue&lt;String,StrokeLineJoin&gt; strokeLineJoin = null;
        ParsedValue&lt;ParsedValue&lt;?,Size&gt;,Number&gt; strokeMiterLimit = null;
        ParsedValue&lt;String,StrokeLineCap&gt; strokeLineCap = null;

        Term term = root;

        dashStyle = dashStyle(term);

        Term prev = term;
        term = term.nextInSeries;
        String keyword = getKeyword(term);

        // dash-style might be followed by 'phase &lt;size&gt;'
        if (&quot;phase&quot;.equals(keyword)) {

            prev = term;
            if ((term = term.nextInSeries) == null ||
                 term.token == null ||
                 !isSize(term.token)) error(term, &quot;Expected \'&lt;size&gt;\'&quot;);

            ParsedValueImpl&lt;?,Size&gt; sizeVal = parseSize(term);
            dashPhase = new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt;(sizeVal,SizeConverter.getInstance());

            prev = term;
            term = term.nextInSeries;
        }

        // stroke type might be next
        strokeType = parseStrokeType(term);
        if (strokeType != null) {
            prev = term;
            term = term.nextInSeries;
        }

        keyword = getKeyword(term);

        if (&quot;line-join&quot;.equals(keyword)) {

            prev = term;
            term = term.nextInSeries;

            ParsedValueImpl[] lineJoinValues = parseStrokeLineJoin(term);
            if (lineJoinValues != null) {
                strokeLineJoin = lineJoinValues[0];
                strokeMiterLimit = lineJoinValues[1];
            } else {
                error(term, &quot;Expected \'miter &lt;size&gt;?\', \'bevel\' or \'round\'&quot;);
            }
            prev = term;
            term = term.nextInSeries;
            keyword = getKeyword(term);
        }

        if (&quot;line-cap&quot;.equals(keyword)) {

            prev = term;
            term = term.nextInSeries;

            strokeLineCap = parseStrokeLineCap(term);
            if (strokeLineCap == null) {
                error(term, &quot;Expected \'square\', \'butt\' or \'round\'&quot;);
            }

            prev = term;
            term = term.nextInSeries;
        }

        if (term != null) {
            // if term is not null, then we have gotten to the end of
            // one border style and term is start of another border style
            root.nextInSeries = term;
        } else {
            // If term is null, then we have gotten to the end of
            // a border style with no more to follow in this series.
            // But there may be another layer.
            root.nextInSeries = null;
            root.nextLayer = prev.nextLayer;
        }

        final ParsedValue[] values = new ParsedValue[]{
            dashStyle,
            dashPhase,
            strokeType,
            strokeLineJoin,
            strokeMiterLimit,
            strokeLineCap
        };

        return new ParsedValueImpl(values, BorderStyleConverter.getInstance());
    }

    //
    // segments(&lt;size&gt; [, &lt;size&gt;]+) | &lt;border-style&gt;
    //
    private ParsedValue&lt;ParsedValue[],Number[]&gt; dashStyle(final Term root) throws ParseException {

        if (root.token == null) error(root, &quot;Expected \'&lt;dash-style&gt;\'&quot;);

        final int ttype = root.token.getType();

        ParsedValue&lt;ParsedValue[],Number[]&gt;  segments = null;
        if (ttype == CssLexer.IDENT) {
            segments = borderStyle(root);
        } else if (ttype == CssLexer.FUNCTION) {
            segments = segments(root);
        } else {
            error(root, &quot;Expected \'&lt;dash-style&gt;\'&quot;);
        }

        return segments;
    }

    /*
    &lt;border-style&gt; = none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset
    */
    private ParsedValue&lt;ParsedValue[],Number[]&gt;  borderStyle(Term root)
            throws ParseException {

        if (root.token == null ||
            root.token.getType() != CssLexer.IDENT ||
            root.token.getText() == null ||
            root.token.getText().isEmpty()) error(root, &quot;Expected \'&lt;border-style&gt;\'&quot;);

        final String text = root.token.getText().toLowerCase(Locale.ROOT);

        if (&quot;none&quot;.equals(text)) {
            return BorderStyleConverter.NONE;
        } else if (&quot;hidden&quot;.equals(text)) {
            // The &quot;hidden&quot; mode doesn't make sense for FX, because it is the
            // same as &quot;none&quot; except for border-collapsed CSS tables
            return BorderStyleConverter.NONE;
        } else if (&quot;dotted&quot;.equals(text)) {
            return BorderStyleConverter.DOTTED;
        } else if (&quot;dashed&quot;.equals(text)) {
            return BorderStyleConverter.DASHED;
        } else if (&quot;solid&quot;.equals(text)) {
            return BorderStyleConverter.SOLID;
        } else if (&quot;double&quot;.equals(text)) {
            error(root, &quot;Unsupported &lt;border-style&gt; \'double\'&quot;);
        } else if (&quot;groove&quot;.equals(text)) {
            error(root, &quot;Unsupported &lt;border-style&gt; \'groove\'&quot;);
        } else if (&quot;ridge&quot;.equals(text)) {
            error(root, &quot;Unsupported &lt;border-style&gt; \'ridge\'&quot;);
        } else if (&quot;inset&quot;.equals(text)) {
            error(root, &quot;Unsupported &lt;border-style&gt; \'inset\'&quot;);
        } else if (&quot;outset&quot;.equals(text)) {
            error(root, &quot;Unsupported &lt;border-style&gt; \'outset\'&quot;);
        } else {
            error(root, &quot;Unsupported &lt;border-style&gt; \'&quot; + text + &quot;\'&quot;);
        }
        // error throws so we should never get here.
        // but the compiler wants a return, so here it is.
        return BorderStyleConverter.SOLID;
    }

    private ParsedValueImpl&lt;ParsedValue[],Number[]&gt; segments(Term root)
            throws ParseException {

        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;segments&quot;.regionMatches(true, 0, fn, 0, 8)) {
            error(root,&quot;Expected \'segments\'&quot;);
        }

        Term arg = root.firstArg;
        if (arg == null) error(null, &quot;Expected \'&lt;size&gt;\'&quot;);

        int nArgs = numberOfArgs(root);
        ParsedValueImpl&lt;?,Size&gt;[] segments = new ParsedValueImpl[nArgs];
        int segment = 0;
        while(arg != null) {
            segments[segment++] = parseSize(arg);
            arg = arg.nextArg;
        }

        return new ParsedValueImpl&lt;ParsedValue[],Number[]&gt;(segments,SizeConverter.SequenceConverter.getInstance());

    }

    private ParsedValueImpl&lt;String,StrokeType&gt; parseStrokeType(final Term root)
        throws ParseException {

        final String keyword = getKeyword(root);


        if (&quot;centered&quot;.equals(keyword) ||
            &quot;inside&quot;.equals(keyword) ||
            &quot;outside&quot;.equals(keyword)) {

            return new ParsedValueImpl&lt;String,StrokeType&gt;(keyword, new EnumConverter(StrokeType.class));

        }
        return null;
    }

    // Root term is the term just after the line-join keyword
    // Returns an array of two Values or null.
    // ParsedValueImpl[0] is ParsedValueImpl&lt;StrokeLineJoin,StrokeLineJoin&gt;
    // ParsedValueImpl[1] is ParsedValueImpl&lt;Value&lt;?,Size&gt;,Number&gt; if miter limit is given, null otherwise.
    // If the token is not a StrokeLineJoin, then null is returned.
    private ParsedValueImpl[] parseStrokeLineJoin(final Term root)
        throws ParseException {

        final String keyword = getKeyword(root);

        if (&quot;miter&quot;.equals(keyword) ||
            &quot;bevel&quot;.equals(keyword) ||
            &quot;round&quot;.equals(keyword)) {

            ParsedValueImpl&lt;String,StrokeLineJoin&gt; strokeLineJoin =
                    new ParsedValueImpl&lt;String,StrokeLineJoin&gt;(keyword, new EnumConverter(StrokeLineJoin.class));

            ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt; strokeMiterLimit = null;
            if (&quot;miter&quot;.equals(keyword)) {

                Term next = root.nextInSeries;
                if (next != null &amp;&amp;
                    next.token != null &amp;&amp;
                    isSize(next.token)) {

                    root.nextInSeries = next.nextInSeries;
                    ParsedValueImpl&lt;?,Size&gt; sizeVal = parseSize(next);
                    strokeMiterLimit = new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt;(sizeVal,SizeConverter.getInstance());
                }

            }

            return new ParsedValueImpl[] { strokeLineJoin, strokeMiterLimit };
        }
        return null;
    }

    // Root term is the term just after the line-cap keyword
    // If the token is not a StrokeLineCap, then null is returned.
    private ParsedValueImpl&lt;String,StrokeLineCap&gt; parseStrokeLineCap(final Term root)
        throws ParseException {

        final String keyword = getKeyword(root);

        if (&quot;square&quot;.equals(keyword) ||
            &quot;butt&quot;.equals(keyword) ||
            &quot;round&quot;.equals(keyword)) {

            return new ParsedValueImpl&lt;String,StrokeLineCap&gt;(keyword, new EnumConverter(StrokeLineCap.class));
        }
        return null;
    }

    /*
     * http://www.w3.org/TR/css3-background/#the-border-image-slice
     * [&lt;number&gt; | &lt;percentage&gt;]{1,4} &amp;&amp; fill?
     */
    private ParsedValueImpl&lt;ParsedValue[],BorderImageSlices&gt; parseBorderImageSlice(final Term root)
        throws ParseException {

        Term term = root;
        if (term.token == null || !isSize(term.token))
                error(term, &quot;Expected \'&lt;size&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt;[] insets = new ParsedValueImpl[4];
        Boolean fill = Boolean.FALSE;

        int inset = 0;
        while (inset &lt; 4 &amp;&amp; term != null) {
            insets[inset++] = parseSize(term);

            if ((term = term.nextInSeries) != null &amp;&amp;
                 term.token != null &amp;&amp;
                 term.token.getType() == CssLexer.IDENT) {

                if(&quot;fill&quot;.equalsIgnoreCase(term.token.getText())) {
                    fill = Boolean.TRUE;
                    break;
                }
            }
        }

        if (inset &lt; 2) insets[1] = insets[0]; // right = top
        if (inset &lt; 3) insets[2] = insets[0]; // bottom = top
        if (inset &lt; 4) insets[3] = insets[1]; // left = right

        ParsedValueImpl[] values = new ParsedValueImpl[] {
                new ParsedValueImpl&lt;ParsedValue[],Insets&gt;(insets, InsetsConverter.getInstance()),
                new ParsedValueImpl&lt;Boolean,Boolean&gt;(fill, null)
        };
        return new ParsedValueImpl&lt;ParsedValue[], BorderImageSlices&gt;(values, BorderImageSliceConverter.getInstance());
    }

    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderImageSlices&gt;[],BorderImageSlices[]&gt;
            parseBorderImageSliceLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;ParsedValue[], BorderImageSlices&gt;[] layers = new ParsedValueImpl[nLayers];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseBorderImageSlice(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderImageSlices&gt;[],BorderImageSlices[]&gt; (layers, SliceSequenceConverter.getInstance());
    }

    /*
     * http://www.w3.org/TR/css3-background/#border-image-width
     * [ &lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | auto ]{1,4}
     */
    private ParsedValueImpl&lt;ParsedValue[], BorderWidths&gt; parseBorderImageWidth(final Term root)
            throws ParseException {

        Term term = root;
        if (term.token == null || !isSize(term.token))
            error(term, &quot;Expected \'&lt;size&gt;\'&quot;);

        ParsedValueImpl&lt;?,Size&gt;[] insets = new ParsedValueImpl[4];

        int inset = 0;
        while (inset &lt; 4 &amp;&amp; term != null) {
            insets[inset++] = parseSize(term);

            if ((term = term.nextInSeries) != null &amp;&amp;
                    term.token != null &amp;&amp;
                    term.token.getType() == CssLexer.IDENT) {
            }
        }

        if (inset &lt; 2) insets[1] = insets[0]; // right = top
        if (inset &lt; 3) insets[2] = insets[0]; // bottom = top
        if (inset &lt; 4) insets[3] = insets[1]; // left = right

        return new ParsedValueImpl&lt;ParsedValue[], BorderWidths&gt;(insets, BorderImageWidthConverter.getInstance());
    }

    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderWidths&gt;[],BorderWidths[]&gt;
        parseBorderImageWidthLayers(final Term root) throws ParseException {

        int nLayers = numberOfLayers(root);
        ParsedValueImpl&lt;ParsedValue[], BorderWidths&gt;[] layers = new ParsedValueImpl[nLayers];
        int layer = 0;
        Term term = root;
        while (term != null) {
            layers[layer++] = parseBorderImageWidth(term);
            term = nextLayer(term);
        }
        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],BorderWidths&gt;[],BorderWidths[]&gt; (layers, BorderImageWidthsSequenceConverter.getInstance());
    }

    // parse a Region value
    // i.e., region(&quot;.styleClassForRegion&quot;) or region(&quot;#idForRegion&quot;)
    private static final String SPECIAL_REGION_URL_PREFIX = &quot;SPECIAL-REGION-URL:&quot;;
    private ParsedValueImpl&lt;String,String&gt; parseRegion(Term root)
            throws ParseException {
        // first term in the chain is the function name...
        final String fn = (root.token != null) ? root.token.getText() : null;
        if (!&quot;region&quot;.regionMatches(true, 0, fn, 0, 6)) {
            error(root,&quot;Expected \'region\'&quot;);
        }

        Term arg = root.firstArg;
        if (arg == null) error(root, &quot;Expected \'region(\&quot;&lt;styleclass-or-id-string&gt;\&quot;)\'&quot;);

        if (arg.token == null ||
                arg.token.getType() != CssLexer.STRING ||
                arg.token.getText() == null ||
                arg.token.getText().isEmpty())  error(root, &quot;Expected \'region(\&quot;&lt;styleclass-or-id-string&gt;\&quot;)\'&quot;);

        final String styleClassOrId = SPECIAL_REGION_URL_PREFIX+ Utils.stripQuotes(arg.token.getText());
        return new ParsedValueImpl&lt;String,String&gt;(styleClassOrId, StringConverter.getInstance());
    }

    // url(&quot;&lt;uri&gt;&quot;) is tokenized by the lexer, so the root arg should be a URL token.
    private ParsedValueImpl&lt;ParsedValue[],String&gt; parseURI(Term root)
            throws ParseException {

        if (root == null) error(root, &quot;Expected \'url(\&quot;&lt;uri-string&gt;\&quot;)\'&quot;);

        if (root.token == null ||
            root.token.getType() != CssLexer.URL ||
            root.token.getText() == null ||
            root.token.getText().isEmpty()) error(root, &quot;Expected \'url(\&quot;&lt;uri-string&gt;\&quot;)\'&quot;);

        final String uri = root.token.getText();
        ParsedValueImpl[] uriValues = new ParsedValueImpl[] {
            new ParsedValueImpl&lt;String,String&gt;(uri, StringConverter.getInstance()),
            null // placeholder for Stylesheet URL
        };
        return new ParsedValueImpl&lt;ParsedValue[],String&gt;(uriValues, URLConverter.getInstance());
    }

    // parse a series of URI values separated by commas.
    // i.e., &lt;uri&gt; [, &lt;uri&gt;]*
    private ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],String&gt;[],String[]&gt; parseURILayers(Term root)
            throws ParseException {

        int nLayers = numberOfLayers(root);

        Term temp = root;
        int layer = 0;
        ParsedValueImpl&lt;ParsedValue[],String&gt;[] layers = new ParsedValueImpl[nLayers];

        while(temp != null) {
            layers[layer++] = parseURI(temp);
            temp = nextLayer(temp);
        }

        return new ParsedValueImpl&lt;ParsedValue&lt;ParsedValue[],String&gt;[],String[]&gt;(layers, URLConverter.SequenceConverter.getInstance());
    }

    ////////////////////////////////////////////////////////////////////////////
    //
    // http://www.w3.org/TR/css3-fonts
    //
    ////////////////////////////////////////////////////////////////////////////

    /* http://www.w3.org/TR/css3-fonts/#font-size-the-font-size-property */
    private ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt; parseFontSize(final Term root) throws ParseException {

        if (root == null) return null;
        final Token token = root.token;
        if (token == null || !isSize(token)) error(root, &quot;Expected \'&lt;font-size&gt;\'&quot;);

        Size size = null;
        if (token.getType() == CssLexer.IDENT) {
            final String ident = token.getText().toLowerCase(Locale.ROOT);
            double value = -1;
            if (&quot;inherit&quot;.equals(ident)) {
                value = 100;
            } else if (&quot;xx-small&quot;.equals(ident)) {
                value = 60;
            } else if (&quot;x-small&quot;.equals(ident)) {
                value = 75;
            } else if (&quot;small&quot;.equals(ident)) {
                value = 80;
            } else if (&quot;medium&quot;.equals(ident)) {
                value = 100;
            } else if (&quot;large&quot;.equals(ident)) {
                value = 120;
            } else if (&quot;x-large&quot;.equals(ident)) {
                value = 150;
            } else if (&quot;xx-large&quot;.equals(ident)) {
                value = 200;
            } else if (&quot;smaller&quot;.equals(ident)) {
                value = 80;
            } else if (&quot;larger&quot;.equals(ident)) {
                value = 120;
            }

            if (value &gt; -1) {
                size = new Size(value, SizeUnits.PERCENT);
            }
        }

        // if size is null, then size is not one of the keywords above.
        if (size == null) {
            size = size(token);
        }

        ParsedValueImpl&lt;?,Size&gt; svalue = new ParsedValueImpl&lt;Size,Size&gt;(size, null);
        return new ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt;(svalue, FontConverter.FontSizeConverter.getInstance());
    }

    /* http://www.w3.org/TR/css3-fonts/#font-style-the-font-style-property */
    private ParsedValueImpl&lt;String,FontPosture&gt; parseFontStyle(Term root) throws ParseException {

        if (root == null) return null;
        final Token token = root.token;
        if (token == null ||
            token.getType() != CssLexer.IDENT ||
            token.getText() == null ||
            token.getText().isEmpty()) error(root, &quot;Expected \'&lt;font-style&gt;\'&quot;);

        final String ident = token.getText().toLowerCase(Locale.ROOT);
        String posture = FontPosture.REGULAR.name();

        if (&quot;normal&quot;.equals(ident)) {
            posture = FontPosture.REGULAR.name();
        } else if (&quot;italic&quot;.equals(ident)) {
            posture = FontPosture.ITALIC.name();
        } else if (&quot;oblique&quot;.equals(ident)) {
            posture = FontPosture.ITALIC.name();
        } else if (&quot;inherit&quot;.equals(ident)) {
            posture = &quot;inherit&quot;;
        } else {
            return null;
        }

        return new ParsedValueImpl&lt;String,FontPosture&gt;(posture, FontConverter.FontStyleConverter.getInstance());
    }

    /* http://www.w3.org/TR/css3-fonts/#font-weight-the-font-weight-property */
    private ParsedValueImpl&lt;String, FontWeight&gt; parseFontWeight(Term root) throws ParseException {

        if (root == null) return null;
        final Token token = root.token;
        if (token == null ||
            token.getText() == null ||
            token.getText().isEmpty()) error(root, &quot;Expected \'&lt;font-weight&gt;\'&quot;);

        final String ident = token.getText().toLowerCase(Locale.ROOT);
        String weight = FontWeight.NORMAL.name();

        if (&quot;inherit&quot;.equals(ident)) {
            weight = FontWeight.NORMAL.name();
        } else if (&quot;normal&quot;.equals(ident)) {
            weight = FontWeight.NORMAL.name();
        } else if (&quot;bold&quot;.equals(ident)) {
            weight = FontWeight.BOLD.name();
        } else if (&quot;bolder&quot;.equals(ident)) {
            weight = FontWeight.BOLD.name();
        } else if (&quot;lighter&quot;.equals(ident)) {
            weight = FontWeight.LIGHT.name();
        } else if (&quot;100&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(100).name();
        } else if (&quot;200&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(200).name();
        } else if (&quot;300&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(300).name();
        } else if (&quot;400&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(400).name();
        } else if (&quot;500&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(500).name();
        } else if (&quot;600&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(600).name();
        } else if (&quot;700&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(700).name();
        } else if (&quot;800&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(800).name();
        } else if (&quot;900&quot;.equals(ident)) {
            weight = FontWeight.findByWeight(900).name();
        } else {
            error(root, &quot;Expected \'&lt;font-weight&gt;\'&quot;);
        }
        return new ParsedValueImpl&lt;String,FontWeight&gt;(weight, FontConverter.FontWeightConverter.getInstance());
    }

    private ParsedValueImpl&lt;String,String&gt;  parseFontFamily(Term root) throws ParseException {

        if (root == null) return null;
        final Token token = root.token;
        String text = null;
        if (token == null ||
            (token.getType() != CssLexer.IDENT &amp;&amp;
             token.getType() != CssLexer.STRING) ||
            (text = token.getText()) == null ||
            text.isEmpty()) error(root, &quot;Expected \'&lt;font-family&gt;\'&quot;);

        final String fam = stripQuotes(text.toLowerCase(Locale.ROOT));
        if (&quot;inherit&quot;.equals(fam)) {
            return new ParsedValueImpl&lt;String,String&gt;(&quot;inherit&quot;, StringConverter.getInstance());
        } else if (&quot;serif&quot;.equals(fam) ||
            &quot;sans-serif&quot;.equals(fam) ||
            &quot;cursive&quot;.equals(fam) ||
            &quot;fantasy&quot;.equals(fam) ||
            &quot;monospace&quot;.equals(fam)) {
            return new ParsedValueImpl&lt;String,String&gt;(fam, StringConverter.getInstance());
        } else {
            return new ParsedValueImpl&lt;String,String&gt;(token.getText(), StringConverter.getInstance());
        }
    }

    // (fontStyle || fontVariant || fontWeight)* fontSize (SOLIDUS size)? fontFamily
    private ParsedValueImpl&lt;ParsedValue[],Font&gt; parseFont(Term root) throws ParseException {

        // Because style, variant, weight, size and family can inherit
        // AND style, variant and weight are optional, parsing this backwards
        // is easier.
        Term next = root.nextInSeries;
        root.nextInSeries = null;
        while (next != null) {
            Term temp = next.nextInSeries;
            next.nextInSeries = root;
            root = next;
            next = temp;
        }

        // Now, root should point to fontFamily
        Token token = root.token;
        int ttype = token.getType();
        if (ttype != CssLexer.IDENT &amp;&amp;
            ttype != CssLexer.STRING) error(root, &quot;Expected \'&lt;font-family&gt;\'&quot;);
        ParsedValueImpl&lt;String,String&gt; ffamily = parseFontFamily(root);

        Term term = root;
        if ((term = term.nextInSeries) == null) error(root, &quot;Expected \'&lt;size&gt;\'&quot;);
        if (term.token == null || !isSize(term.token)) error(term, &quot;Expected \'&lt;size&gt;\'&quot;);

        // Now, term could be the font size or it could be the line-height.
        // If the next term is a forward slash, then it's line-height.
        Term temp;
        if (((temp = term.nextInSeries) != null) &amp;&amp;
            (temp.token != null &amp;&amp; temp.token.getType() == CssLexer.SOLIDUS)) {

            root = temp;

            if ((term = temp.nextInSeries) == null) error(root, &quot;Expected \'&lt;size&gt;\'&quot;);
            if (term.token == null || !isSize(term.token)) error(term, &quot;Expected \'&lt;size&gt;\'&quot;);

            token = term.token;
        }

        ParsedValueImpl&lt;ParsedValue&lt;?,Size&gt;,Number&gt; fsize = parseFontSize(term);
        if (fsize == null) error(root, &quot;Expected \'&lt;size&gt;\'&quot;);

        ParsedValueImpl&lt;String,FontPosture&gt; fstyle = null;
        ParsedValueImpl&lt;String,FontWeight&gt; fweight = null;
        String fvariant = null;

        while ((term = term.nextInSeries) != null) {

            if (term.token == null ||
                term.token.getType() != CssLexer.IDENT ||
                term.token.getText() == null ||
                term.token.getText().isEmpty())
                error(term, &quot;Expected \'&lt;font-weight&gt;\', \'&lt;font-style&gt;\' or \'&lt;font-variant&gt;\'&quot;);

            if (fstyle == null &amp;&amp; ((fstyle = parseFontStyle(term)) != null)) {
                ;
            } else if (fvariant == null &amp;&amp; &quot;small-caps&quot;.equalsIgnoreCase(term.token.getText())) {
                fvariant = term.token.getText();
            } else if (fweight == null &amp;&amp; ((fweight = parseFontWeight(term)) != null)) {
                ;
            }
        }

        ParsedValueImpl[] values = new ParsedValueImpl[]{ ffamily, fsize, fweight, fstyle };
        return new ParsedValueImpl&lt;ParsedValue[],Font&gt;(values, FontConverter.getInstance());
    }

    //
    // Parser state machine
    //
    Token currentToken = null;

    // return the next token that is not whitespace.
    private Token nextToken(CssLexer lexer) {

        Token token = null;

        do {
            token = lexer.nextToken();
        } while ((token != null) &amp;&amp;
                (token.getType() == CssLexer.WS) ||
                (token.getType() == CssLexer.NL));

        if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.finest(token.toString());
        }

        return token;

    }

    // keep track of what is in process of being parsed to avoid import loops
    private static Stack&lt;String&gt; imports;

    private void parse(Stylesheet stylesheet, CssLexer lexer) {

        // need to read the first token
        currentToken = nextToken(lexer);

        while((currentToken != null) &amp;&amp;
                (currentToken.getType() == CssLexer.AT_KEYWORD)) {

            currentToken = nextToken(lexer);

            if (currentToken == null || currentToken.getType() != CssLexer.IDENT) {

                // just using ParseException for a nice error message, not for throwing the exception.
                ParseException parseException = new ParseException(&quot;Expected IDENT&quot;, currentToken, this);
                final String msg = parseException.toString();
                ParseError error = createError(msg);
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(error.toString());
                }
                reportError(error);

                // get past EOL or SEMI
                do {
                    currentToken = lexer.nextToken();
                } while ((currentToken != null) &amp;&amp;
                        (currentToken.getType() == CssLexer.SEMI) ||
                        (currentToken.getType() == CssLexer.WS) ||
                        (currentToken.getType() == CssLexer.NL));
                continue;
            }

            String keyword = currentToken.getText().toLowerCase(Locale.ROOT);
            if (&quot;font-face&quot;.equals(keyword)) {
                FontFace fontFace = fontFace(lexer);
                if (fontFace != null) stylesheet.getFontFaces().add(fontFace);
                currentToken = nextToken(lexer);
                continue;

            } else if (&quot;import&quot;.equals(keyword)) {

                if (CssParser.imports == null) {
                    CssParser.imports = new Stack&lt;&gt;();
                }

                if (!imports.contains(sourceOfStylesheet)) {

                    imports.push(sourceOfStylesheet);

                    Stylesheet importedStylesheet = handleImport(lexer);

                    if (importedStylesheet != null) {
                        stylesheet.importStylesheet(importedStylesheet);
                    }

                    imports.pop();

                    if (CssParser.imports.isEmpty()) {
                        CssParser.imports = null;
                    }

                } else {
// Import imports import!
                    final int line = currentToken.getLine();
                    final int pos = currentToken.getOffset();
                    final String msg =
                            MessageFormat.format(&quot;Recursive @import at {2} [{0,number,#},{1,number,#}]&quot;,
                                    line, pos, imports.peek());
                    ParseError error = createError(msg);
                    if (LOGGER.isLoggable(Level.WARNING)) {
                        LOGGER.warning(error.toString());
                    }
                    reportError(error);
                }

                // get past EOL or SEMI
                do {
                    currentToken = lexer.nextToken();
                } while ((currentToken != null) &amp;&amp;
                        (currentToken.getType() == CssLexer.SEMI) ||
                        (currentToken.getType() == CssLexer.WS) ||
                        (currentToken.getType() == CssLexer.NL));

                continue;

            }
        }

        while ((currentToken != null) &amp;&amp;
               (currentToken.getType() != Token.EOF)) {

            List&lt;Selector&gt; selectors = selectors(lexer);
            if (selectors == null) return;

            if ((currentToken == null) ||
                (currentToken.getType() != CssLexer.LBRACE)) {
                    final int line = currentToken != null ? currentToken.getLine() : -1;
                    final int pos = currentToken != null ? currentToken.getOffset() : -1;
                    final String msg =
                        MessageFormat.format(&quot;Expected LBRACE at [{0,number,#},{1,number,#}]&quot;,
                                line, pos);
                    ParseError error = createError(msg);
                    if (LOGGER.isLoggable(Level.WARNING)) {
                        LOGGER.warning(error.toString());
                    }
                    reportError(error);
                currentToken = null;
                return;
            }

            // get past the LBRACE
            currentToken = nextToken(lexer);

            List&lt;Declaration&gt; declarations = declarations(lexer);
            if (declarations == null) return;

            if ((currentToken != null) &amp;&amp;
                (currentToken.getType() != CssLexer.RBRACE)) {
                    final int line = currentToken.getLine();
                    final int pos = currentToken.getOffset();
                    final String msg =
                        MessageFormat.format(&quot;Expected RBRACE at [{0,number,#},{1,number,#}]&quot;,
                                line, pos);
                    ParseError error = createError(msg);
                    if (LOGGER.isLoggable(Level.WARNING)) {
                        LOGGER.warning(error.toString());
                    }
                    reportError(error);
                currentToken = null;
                return;
            }

            stylesheet.getRules().add(new Rule(selectors, declarations));

            currentToken = nextToken(lexer);

        }
        currentToken = null;
    }

    private FontFace fontFace(CssLexer lexer) {
        final Map&lt;String,String&gt; descriptors = new HashMap&lt;String,String&gt;();
        final List&lt;FontFaceImpl.FontFaceSrc&gt; sources = new ArrayList&lt;FontFaceImpl.FontFaceSrc&gt;();
        while(true) {
            currentToken = nextToken(lexer);
            if (currentToken.getType() == CssLexer.IDENT) {
                String key = currentToken.getText();
                // ignore the colon that follows
                currentToken = nextToken(lexer);
                // get the next token after colon
                currentToken = nextToken(lexer);
                // ignore all but &quot;src&quot;
                if (&quot;src&quot;.equalsIgnoreCase(key)) {
                    while(true) {
                        if((currentToken != null) &amp;&amp;
                                (currentToken.getType() != CssLexer.SEMI) &amp;&amp;
                                (currentToken.getType() != CssLexer.RBRACE) &amp;&amp;
                                (currentToken.getType() != Token.EOF)) {

                            if (currentToken.getType() == CssLexer.IDENT) {
                                // simple reference to other font-family
                                sources.add(new FontFaceImpl.FontFaceSrc(FontFaceImpl.FontFaceSrcType.REFERENCE,currentToken.getText()));

                            } else if (currentToken.getType() == CssLexer.URL) {

                                // let URLConverter do the conversion
                                ParsedValueImpl[] uriValues = new ParsedValueImpl[] {
                                        new ParsedValueImpl&lt;String,String&gt;(currentToken.getText(), StringConverter.getInstance()),
                                        new ParsedValueImpl&lt;String,String&gt;(sourceOfStylesheet, null)
                                };
                                ParsedValue&lt;ParsedValue[], String&gt; parsedValue =
                                        new ParsedValueImpl&lt;ParsedValue[], String&gt;(uriValues, URLConverter.getInstance());
                                String urlStr = parsedValue.convert(null);

                                URL url = null;
                                try {
                                    URI fontUri = new URI(urlStr);
                                    url = fontUri.toURL();
                                } catch (URISyntaxException |  MalformedURLException malf) {

                                    final int line = currentToken.getLine();
                                    final int pos = currentToken.getOffset();
                                    final String msg = MessageFormat.format(&quot;Could not resolve @font-face url [{2}] at [{0,number,#},{1,number,#}]&quot;, line, pos, urlStr);
                                    ParseError error = createError(msg);
                                    if (LOGGER.isLoggable(Level.WARNING)) {
                                        LOGGER.warning(error.toString());
                                    }
                                    reportError(error);

                                    // skip the rest.
                                    while(currentToken != null) {
                                        int ttype = currentToken.getType();
                                        if (ttype == CssLexer.RBRACE ||
                                                ttype == Token.EOF) {
                                            return null;
                                        }
                                        currentToken = nextToken(lexer);
                                    }
                                }

                                String format = null;
                                while(true) {
                                    currentToken = nextToken(lexer);
                                    final int ttype = (currentToken != null) ? currentToken.getType() : Token.EOF;
                                    if (ttype == CssLexer.FUNCTION) {
                                        if (&quot;format(&quot;.equalsIgnoreCase(currentToken.getText())) {
                                            continue;
                                        } else {
                                            break;
                                        }
                                    } else if (ttype == CssLexer.IDENT ||
                                            ttype == CssLexer.STRING) {

                                        format = Utils.stripQuotes(currentToken.getText());
                                    } else if (ttype == CssLexer.RPAREN) {
                                        continue;
                                    } else {
                                        break;
                                    }
                                }
                                sources.add(new FontFaceImpl.FontFaceSrc(FontFaceImpl.FontFaceSrcType.URL,url.toExternalForm(), format));

                            } else if (currentToken.getType() == CssLexer.FUNCTION) {
                                if (&quot;local(&quot;.equalsIgnoreCase(currentToken.getText())) {
                                    // consume the function token
                                    currentToken = nextToken(lexer);
                                    // parse function contents
                                    final StringBuilder localSb = new StringBuilder();
                                    while(true) {
                                        if((currentToken != null) &amp;&amp; (currentToken.getType() != CssLexer.RPAREN) &amp;&amp;
                                                (currentToken.getType() != Token.EOF)) {
                                            localSb.append(currentToken.getText());
                                        } else {
                                            break;
                                        }
                                        currentToken = nextToken(lexer);
                                    }
                                    int start = 0, end = localSb.length();
                                    if (localSb.charAt(start) == '\'' || localSb.charAt(start) == '\&quot;') start ++;
                                    if (localSb.charAt(end-1) == '\'' || localSb.charAt(end-1) == '\&quot;') end --;
                                    final String local = localSb.substring(start,end);
                                    sources.add(new FontFaceImpl.FontFaceSrc(FontFaceImpl.FontFaceSrcType.LOCAL,local));
                                } else {
                                    // error unknown fontface src type
                                    final int line = currentToken.getLine();
                                    final int pos = currentToken.getOffset();
                                    final String msg = MessageFormat.format(&quot;Unknown @font-face src type [&quot; + currentToken.getText() + &quot;)] at [{0,number,#},{1,number,#}]&quot;, line, pos);
                                    ParseError error = createError(msg);
                                    if (LOGGER.isLoggable(Level.WARNING)) {
                                        LOGGER.warning(error.toString());
                                    }
                                    reportError(error);

                                }
                            } else  if (currentToken.getType() == CssLexer.COMMA) {
                                // ignore
                            } else {
                                // error unexpected token
                                final int line = currentToken.getLine();
                                final int pos = currentToken.getOffset();
                                final String msg = MessageFormat.format(&quot;Unexpected TOKEN [&quot; + currentToken.getText() + &quot;] at [{0,number,#},{1,number,#}]&quot;, line, pos);
                                ParseError error = createError(msg);
                                if (LOGGER.isLoggable(Level.WARNING)) {
                                    LOGGER.warning(error.toString());
                                }
                                reportError(error);
                            }
                        } else {
                            break;
                        }
                        currentToken = nextToken(lexer);
                    }
                } else {
                    StringBuilder descriptorVal = new StringBuilder();
                    while(true) {
                        if((currentToken != null) &amp;&amp; (currentToken.getType() != CssLexer.SEMI) &amp;&amp;
                            (currentToken.getType() != Token.EOF)) {
                            descriptorVal.append(currentToken.getText());
                        } else {
                            break;
                        }
                        currentToken = nextToken(lexer);
                    }
                    descriptors.put(key,descriptorVal.toString());
                }
//                continue;
            }

            if ((currentToken == null) ||
                (currentToken.getType() == CssLexer.RBRACE) ||
                (currentToken.getType() == Token.EOF)) {
                break;
            }

        }
        return new FontFaceImpl(descriptors, sources);
    }

    private Stylesheet handleImport(CssLexer lexer) {
        currentToken = nextToken(lexer);

        if (currentToken == null || currentToken.getType() == Token.EOF) {
            return null;
        }

        int ttype = currentToken.getType();

        String fname = null;
        if (ttype == CssLexer.STRING || ttype == CssLexer.URL) {
            fname = currentToken.getText();
        }

        Stylesheet importedStylesheet = null;
        final String _sourceOfStylesheet = sourceOfStylesheet;

        if (fname != null) {
            // let URLConverter do the conversion
            ParsedValueImpl[] uriValues = new ParsedValueImpl[] {
                    new ParsedValueImpl&lt;String,String&gt;(fname, StringConverter.getInstance()),
                    new ParsedValueImpl&lt;String,String&gt;(sourceOfStylesheet, null)
            };
            ParsedValue&lt;ParsedValue[], String&gt; parsedValue =
                    new ParsedValueImpl&lt;ParsedValue[], String&gt;(uriValues, URLConverter.getInstance());

            String urlString = parsedValue.convert(null);
            importedStylesheet = StyleManager.loadStylesheet(urlString);

            // When we load an imported stylesheet, the sourceOfStylesheet field
            // gets set to the new stylesheet. Once it is done loading we must reset
            // this field back to the previous value, otherwise we will potentially
            // run into problems (for example, see RT-40346).
            sourceOfStylesheet = _sourceOfStylesheet;
        }
        if (importedStylesheet == null) {
            final String msg =
                    MessageFormat.format(&quot;Could not import {0}&quot;, fname);
            ParseError error = createError(msg);
            if (LOGGER.isLoggable(Level.WARNING)) {
                LOGGER.warning(error.toString());
            }
            reportError(error);
        }
        return importedStylesheet;
    }

    private List&lt;Selector&gt; selectors(CssLexer lexer) {

        List&lt;Selector&gt; selectors = new ArrayList&lt;Selector&gt;();

        while(true) {
            Selector selector = selector(lexer);
            if (selector == null) {
                // some error happened, skip the rule...
                while ((currentToken != null) &amp;&amp;
                       (currentToken.getType() != CssLexer.RBRACE) &amp;&amp;
                       (currentToken.getType() != Token.EOF)) {
                    currentToken = nextToken(lexer);
                }

                // current token is either RBRACE or EOF. Calling
                // currentToken will get the next token or EOF.
                currentToken = nextToken(lexer);

                // skipped the last rule?
                if (currentToken == null || currentToken.getType() == Token.EOF) {
                    currentToken = null;
                    return null;
                }

                continue;
            }
            selectors.add(selector);

            if ((currentToken != null) &amp;&amp;
                (currentToken.getType() == CssLexer.COMMA)) {
                // get past the comma
                currentToken = nextToken(lexer);
                continue;
            }

            // currentToken was either null or not a comma
            // so we are done with selectors.
            break;
        }

        return selectors;
    }

    private Selector selector(CssLexer lexer) {

        List&lt;Combinator&gt; combinators = null;
        List&lt;SimpleSelector&gt; sels = null;

        SimpleSelector ancestor = simpleSelector(lexer);
        if (ancestor == null) return null;

        while (true) {
            Combinator comb = combinator(lexer);
            if (comb != null) {
                if (combinators == null) {
                    combinators = new ArrayList&lt;Combinator&gt;();
                }
                combinators.add(comb);
                SimpleSelector descendant = simpleSelector(lexer);
                if (descendant == null) return null;
                if (sels == null) {
                    sels = new ArrayList&lt;SimpleSelector&gt;();
                    sels.add(ancestor);
                }
                sels.add(descendant);
            } else {
                break;
            }
        }

        // RT-15473
        // We might return from selector with a NL token instead of an
        // LBRACE, so skip past the NL here.
        if (currentToken != null &amp;&amp; currentToken.getType() == CssLexer.NL) {
            currentToken = nextToken(lexer);
        }


        if (sels == null) {
            return ancestor;
        } else {
            return new CompoundSelector(sels,combinators);
        }

    }

    private SimpleSelector simpleSelector(CssLexer lexer) {

        String esel = &quot;*&quot;; // element selector. default to universal
        String isel = &quot;&quot;; // id selector
        List&lt;String&gt; csels = null; // class selector
        List&lt;String&gt; pclasses = null; // pseudoclasses

        while (true) {

            final int ttype =
                (currentToken != null) ? currentToken.getType() : Token.INVALID;

            switch(ttype) {
                // element selector
                case CssLexer.STAR:
                case CssLexer.IDENT:
                    esel = currentToken.getText();
                    break;

                // class selector
                case CssLexer.DOT:
                    currentToken = nextToken(lexer);
                    if (currentToken != null &amp;&amp;
                        currentToken.getType() == CssLexer.IDENT) {
                        if (csels == null) {
                            csels = new ArrayList&lt;String&gt;();
                        }
                        csels.add(currentToken.getText());
                    } else {
                        currentToken = Token.INVALID_TOKEN;
                        return null;
                    }
                    break;

                // id selector
                case CssLexer.HASH:
                    isel = currentToken.getText().substring(1);
                    break;

                case CssLexer.COLON:
                    currentToken = nextToken(lexer);
                    if (currentToken != null &amp;&amp; pclasses == null) {
                        pclasses = new ArrayList&lt;String&gt;();
                    }

                    if (currentToken.getType() == CssLexer.IDENT) {
                        pclasses.add(currentToken.getText());
                    } else if (currentToken.getType() == CssLexer.FUNCTION){
                        String pclass = functionalPseudo(lexer);
                        pclasses.add(pclass);
                    } else {
                        currentToken = Token.INVALID_TOKEN;
                    }

                    if (currentToken.getType() == Token.INVALID) {
                        return null;
                    }
                    break;

                case CssLexer.NL:
                case CssLexer.WS:
                case CssLexer.COMMA:
                case CssLexer.GREATER:
                case CssLexer.LBRACE:
                case Token.EOF:
                    return new SimpleSelector(esel, csels, pclasses, isel);

                default:
                    return null;


            }

            // get the next token, but don't skip whitespace
            // since it may be a combinator
            currentToken = lexer.nextToken();
            if (LOGGER.isLoggable(Level.FINEST)) {
                LOGGER.finest(currentToken.toString());
            }
        }
    }

    // From http://www.w3.org/TR/selectors/#grammar
    //  functional_pseudo
    //      : FUNCTION S* expression ')'
    //      ;
    //  expression
    //      /* In CSS3, the expressions are identifiers, strings, */
    //      /* or of the form &quot;an+b&quot; */
    //      : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
    //      ;
    private String functionalPseudo(CssLexer lexer) {

        // TODO: This is not how we should handle functional pseudo-classes in the long-run!

        StringBuilder pclass = new StringBuilder(currentToken.getText());

        while(true) {

            currentToken = nextToken(lexer);

            switch(currentToken.getType()) {

                // TODO: lexer doesn't really scan right and isn't CSS3,
                // so PLUS, '-', NUMBER, etc are all useless at this point.
                case CssLexer.STRING:
                case CssLexer.IDENT:
                    pclass.append(currentToken.getText());
                    break;

                case CssLexer.RPAREN:
                    pclass.append(')');
                    return pclass.toString();

                default:
                    currentToken = Token.INVALID_TOKEN;
                    return null;
            }
        }

    }

    private Combinator combinator(CssLexer lexer) {

        Combinator combinator = null;

        while (true) {

            final int ttype =
                (currentToken != null) ? currentToken.getType() : Token.INVALID;

            switch(ttype) {

                case CssLexer.WS:
                    // need to check if combinator is null since child token
                    // might be surrounded by whitespace.
                    if (combinator == null &amp;&amp; &quot; &quot;.equals(currentToken.getText())) {
                        combinator = Combinator.DESCENDANT;
                    }
                    break;

                case CssLexer.GREATER:
                    // no need to check if combinator is null here
                    combinator = Combinator.CHILD;
                    break;

                case CssLexer.STAR:
                case CssLexer.IDENT:
                case CssLexer.DOT:
                case CssLexer.HASH:
                case CssLexer.COLON:
                    return combinator;

                default:
                    // only selector is expected
                    return null;

            }

            // get the next token, but don't skip whitespace
            currentToken = lexer.nextToken();
            if (LOGGER.isLoggable(Level.FINEST)) {
                LOGGER.finest(currentToken.toString());
            }
        }
    }

    private List&lt;Declaration&gt; declarations(CssLexer lexer) {

        List&lt;Declaration&gt; declarations = new ArrayList&lt;Declaration&gt;();

        while (true) {

            Declaration decl = declaration(lexer);
            if (decl != null) {
                declarations.add(decl);
            } else {
                // some error happened, skip the decl...
                while ((currentToken != null) &amp;&amp;
                       (currentToken.getType() != CssLexer.SEMI) &amp;&amp;
                       (currentToken.getType() != CssLexer.RBRACE) &amp;&amp;
                       (currentToken.getType() != Token.EOF)) {
                    currentToken = nextToken(lexer);
                }

                // current token is either SEMI, RBRACE or EOF.
                if (currentToken != null &amp;&amp;
                    currentToken.getType() != CssLexer.SEMI)
                    return declarations;
            }

            // declaration; declaration; ???
            // RT-17830 - allow declaration;;
            while ((currentToken != null) &amp;&amp;
                    (currentToken.getType() == CssLexer.SEMI)) {
                currentToken = nextToken(lexer);
            }

            // if it is delcaration; declaration, then the
            // next token should be an IDENT.
            if ((currentToken != null) &amp;&amp;
                (currentToken.getType() == CssLexer.IDENT)) {
                continue;
            }

            break;
        }

        return declarations;
    }

    private Declaration declaration(CssLexer lexer) {

        final int ttype =
            (currentToken != null) ? currentToken.getType() : Token.INVALID;

        if ((currentToken == null) ||
            (currentToken.getType() != CssLexer.IDENT)) {
//
//            RT-16547: this warning was misleading because an empty rule
//            not invalid. Some people put in empty rules just as placeholders.
//
//            if (LOGGER.isLoggable(PlatformLogger.WARNING)) {
//                final int line = currentToken != null ? currentToken.getLine() : -1;
//                final int pos = currentToken != null ? currentToken.getOffset() : -1;
//                final String url =
//                    (stylesheet != null &amp;&amp; stylesheet.getUrl() != null) ?
//                        stylesheet.getUrl().toExternalForm() : &quot;?&quot;;
//                LOGGER.warning(&quot;Expected IDENT at {0}[{1,number,#},{2,number,#}]&quot;,
//                    url,line,pos);
//            }
            return null;
        }

        String property = currentToken.getText();

        currentToken = nextToken(lexer);

        if ((currentToken == null) ||
            (currentToken.getType() != CssLexer.COLON)) {
                final int line = currentToken.getLine();
                final int pos = currentToken.getOffset();
                final String msg =
                        MessageFormat.format(&quot;Expected COLON at [{0,number,#},{1,number,#}]&quot;,
                                line, pos);
                ParseError error = createError(msg);
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(error.toString());
                }
                reportError(error);
            return null;
        }

        currentToken = nextToken(lexer);

        Term root = expr(lexer);
        ParsedValueImpl value = null;
        try {
            value = (root != null) ? valueFor(property, root, lexer) : null;
        } catch (ParseException re) {
                Token badToken = re.tok;
                final int line = badToken != null ? badToken.getLine() : -1;
                final int pos = badToken != null ? badToken.getOffset() : -1;
                final String msg =
                        MessageFormat.format(&quot;{2} while parsing ''{3}'' at [{0,number,#},{1,number,#}]&quot;,
                    line,pos,re.getMessage(),property);
                ParseError error = createError(msg);
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(error.toString());
                }
                reportError(error);
            return null;
        }

        boolean important = currentToken.getType() == CssLexer.IMPORTANT_SYM;
        if (important) currentToken = nextToken(lexer);

        Declaration decl = (value != null)
                ? new Declaration(property.toLowerCase(Locale.ROOT), value, important) : null;
        return decl;
    }

    private Term expr(CssLexer lexer) {

        final Term expr = term(lexer);
        Term current = expr;

        while(true) {

            // if current is null, then term returned null
            final int ttype =
                (current != null &amp;&amp; currentToken != null)
                    ? currentToken.getType() : Token.INVALID;

            if (ttype == Token.INVALID) {
                skipExpr(lexer);
                return null;
            } else if (ttype == CssLexer.SEMI ||
                ttype == CssLexer.IMPORTANT_SYM ||
                ttype == CssLexer.RBRACE ||
                ttype == Token.EOF) {
                return expr;
            } else if (ttype == CssLexer.COMMA) {
            // comma breaks up sequences of terms.
                // next series of terms chains off the last term in
                // the current series.
                currentToken = nextToken(lexer);
                current = current.nextLayer = term(lexer);
            } else {
                current = current.nextInSeries = term(lexer);
            }

        }
    }

    private void skipExpr(CssLexer lexer) {

        while(true) {

            currentToken = nextToken(lexer);

            final int ttype =
                (currentToken != null) ? currentToken.getType() : Token.INVALID;

            if (ttype == CssLexer.SEMI ||
                ttype == CssLexer.RBRACE ||
                ttype == Token.EOF) {
                return;
            }
        }
    }

    private Term term(CssLexer lexer) {

        final int ttype =
            (currentToken != null) ? currentToken.getType() : Token.INVALID;

        switch (ttype) {

            case CssLexer.NUMBER:
            case CssLexer.CM:
            case CssLexer.EMS:
            case CssLexer.EXS:
            case CssLexer.IN:
            case CssLexer.MM:
            case CssLexer.PC:
            case CssLexer.PT:
            case CssLexer.PX:
            case CssLexer.DEG:
            case CssLexer.GRAD:
            case CssLexer.RAD:
            case CssLexer.TURN:
            case CssLexer.PERCENTAGE:
            case CssLexer.SECONDS:
            case CssLexer.MS:
                break;

            case CssLexer.STRING:
                break;
            case CssLexer.IDENT:
                break;

            case CssLexer.HASH:
                break;

            case CssLexer.FUNCTION:
            case CssLexer.LPAREN:

                Term function = new Term(currentToken);
                currentToken = nextToken(lexer);

                Term arg = term(lexer);
                function.firstArg = arg;

                while(true) {

                    final int operator =
                        currentToken != null ? currentToken.getType() : Token.INVALID;

                    if (operator == CssLexer.RPAREN) {
                        currentToken = nextToken(lexer);
                        return function;
                    } else if (operator == CssLexer.COMMA) {
                        // comma breaks up sequences of terms.
                        // next series of terms chains off the last term in
                        // the current series.
                        currentToken = nextToken(lexer);
                        arg = arg.nextArg = term(lexer);

                    } else {
                        arg = arg.nextInSeries = term(lexer);
                    }

                }

            case CssLexer.URL:
                break;

            case CssLexer.SOLIDUS:
                break;

            default:
                final int line = currentToken != null ? currentToken.getLine() : -1;
                final int pos = currentToken != null ? currentToken.getOffset() : -1;
                final String text = currentToken != null ? currentToken.getText() : &quot;&quot;;
                final String msg =
                    MessageFormat.format(&quot;Unexpected token {0}{1}{0} at [{2,number,#},{3,number,#}]&quot;,
                    &quot;\'&quot;,text,line,pos);
                ParseError error = createError(msg);
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.warning(error.toString());
                }
                reportError(error);
                return null;
//                currentToken = nextToken(lexer);
//
//                return new Term(Token.INVALID_TOKEN);
        }

        Term term = new Term(currentToken);
        currentToken = nextToken(lexer);
        return term;
    }

    public static ObservableList&lt;ParseError&gt; errorsProperty() {
        return StyleManager.errorsProperty();
    }



    /**
     * Encapsulate information about the source and nature of errors encountered
     * while parsing CSS or applying styles to Nodes.
     */
    public static class ParseError {

        /** @return The error message from the CSS code. */
        public final String getMessage() {
            return message;
        }

        public ParseError(String message) {
            this.message = message;
        }

        final String message;

        @Override public String toString() {
            return &quot;CSS Error: &quot; + message;
        }

        /** Encapsulate errors arising from parsing of stylesheet files */
        public final static class StylesheetParsingError extends ParseError {

            StylesheetParsingError(String url, String message) {
                super(message);
                this.url = url;
            }

            String getURL() {
                return url;
            }

            private final String url;

            @Override public String toString() {
                final String path = url != null ? url : &quot;?&quot;;
                // TBD: i18n
                return &quot;CSS Error parsing &quot; + path + &quot;: &quot; + message;
            }

        }

        /** Encapsulate errors arising from parsing of Node's style property */
        public final static class InlineStyleParsingError extends ParseError {

            InlineStyleParsingError(Styleable styleable, String message) {
                super(message);
                this.styleable = styleable;
            }

            Styleable getStyleable() {
                return styleable;
            }

            private final Styleable styleable;

            @Override public String toString() {
                final String inlineStyle = styleable.getStyle();
                final String source = styleable.toString();
                // TBD: i18n
                return &quot;CSS Error parsing in-line style \'&quot; + inlineStyle +
                        &quot;\' from &quot; + source + &quot;: &quot; + message;
            }
        }

        /**
         * Encapsulate errors arising from parsing when the style is not
         * an in-line style nor is the style from a stylesheet. Primarily to
         * support unit testing.
         */
        public final static class StringParsingError extends ParseError {
            private final String style;

            StringParsingError(String style, String message) {
                super(message);
                this.style = style;
            }

            String getStyle() {
                return style;
            }

            @Override public String toString() {
                // TBD: i18n
                return &quot;CSS Error parsing \'&quot; + style + &quot;: &quot; + message;
            }
        }

        /** Encapsulates errors arising from applying a style to a Node. */
        public final static class PropertySetError extends ParseError {
            private final CssMetaData styleableProperty;
            private final Styleable styleable;

            public PropertySetError(CssMetaData styleableProperty,
                    Styleable styleable, String message) {
                super(message);
                this.styleableProperty = styleableProperty;
                this.styleable = styleable;
            }

            Styleable getStyleable() {
                return styleable;
            }

            CssMetaData getProperty() {
                return styleableProperty;
            }

            @Override public String toString() {
                // TBD: i18n
                return &quot;CSS Error parsing \'&quot; + styleableProperty + &quot;: &quot; + message;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/css/Rule.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.css;

import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.scene.Node;

import com.sun.javafx.collections.TrackableObservableList;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/*
 * A selector is a collection of selectors and declarations.
 *
 * @since 9
 */
final public class Rule {

    private List&lt;Selector&gt; selectors = null;

    /**
     * The list returned from this method should be treated as unmodifiable.
     * Tools should use {@link #getSelectors()} which tracks adds and removes.
     */
    List&lt;Selector&gt;  getUnobservedSelectorList() {
        if (selectors == null) {
            selectors = new ArrayList&lt;Selector&gt;();
        }
        return selectors;
    }

    private List&lt;Declaration&gt; declarations = null;
    /**
     * The list returned from this method should be treated as unmodifiable.
     * Tools should use {@link #getDeclarations()} which tracks adds and removes.
     */
    List&lt;Declaration&gt; getUnobservedDeclarationList() {

        if (declarations == null &amp;&amp; serializedDecls != null) {

            try {
                ByteArrayInputStream bis = new ByteArrayInputStream(serializedDecls);
                DataInputStream dis = new DataInputStream(bis);

                short nDeclarations = dis.readShort();
                declarations = new ArrayList&lt;Declaration&gt;(nDeclarations);
                for (int i = 0; i &lt; nDeclarations; i++) {

                    Declaration decl = Declaration.readBinary(bssVersion, dis, stylesheet.getStringStore());
                    decl.rule = Rule.this;

                    if (stylesheet != null &amp;&amp; stylesheet.getUrl() != null) {
                        String stylesheetUrl = stylesheet.getUrl();
                        decl.fixUrl(stylesheetUrl);
                    }

                    declarations.add(decl);
                }

            } catch (IOException ioe) {
                declarations = new ArrayList&lt;&gt;();
                assert false; ioe.getMessage();

            } finally {
                serializedDecls = null;
            }

        }

        return declarations;
    }

    private Observables observables = null;

    /**
     * This method is to support tooling that may want to add declarations to
     * or remove declarations from a Rule. Changes to the list are tracked
     * so that added declarations are tagged as belonging to this rule, and
     * the rule for removed declarations is nulled out.
     * @return a observable list of declarations
     */
    public final ObservableList&lt;Declaration&gt; getDeclarations() {

        if (observables == null) {
            observables = new Observables(this);
        }

        return observables.getDeclarations();
    }

    /**
     * This method is to support tooling that may want to add selectors to
     * or remove selectors from a Rule. Changes to the list are tracked
     * so that added selectors are tagged as belonging to this rule, and
     * the rule for removed selectors is nulled out.
     * @return an observable list of selectors
     */
    public final ObservableList&lt;Selector&gt; getSelectors() {

        if (observables == null) {
            observables = new Observables(this);
        }

        return observables.getSelectors();
    }

    /** The stylesheet this selector belongs to */
    private Stylesheet stylesheet;
    public Stylesheet getStylesheet() {
        return stylesheet;
    }

    /* package */
    void setStylesheet(Stylesheet stylesheet) {

        this.stylesheet = stylesheet;

        if (stylesheet != null &amp;&amp; stylesheet.getUrl() != null) {
            final String stylesheetUrl = stylesheet.getUrl();

            int nDeclarations = declarations != null ? declarations.size() : 0;
            for (int d=0; d&lt;nDeclarations; d++) {
                declarations.get(d).fixUrl(stylesheetUrl);
            }
        }
    }

    public StyleOrigin getOrigin() {
        return stylesheet != null ? stylesheet.getOrigin() : null;
    }


    Rule(List&lt;Selector&gt; selectors, List&lt;Declaration&gt; declarations) {

        this.selectors = selectors;
        this.declarations = declarations;
        serializedDecls = null;
        this.bssVersion = Stylesheet.BINARY_CSS_VERSION;

        int sMax = selectors != null ? selectors.size() : 0;
        for(int i = 0; i &lt; sMax; i++) {
            Selector sel = selectors.get(i);
            sel.setRule(Rule.this);
        }

        int dMax = declarations != null ? declarations.size() : 0;
        for (int d=0; d&lt;dMax; d++) {
            Declaration decl = declarations.get(d);
            decl.rule = this;
        }
    }

    private byte[] serializedDecls;
    private final int bssVersion;

    private Rule(List&lt;Selector&gt; selectors, byte[] buf, int bssVersion) {

        this.selectors = selectors;
        this.declarations = null;
        this.serializedDecls = buf;
        this.bssVersion = bssVersion;

        int sMax = selectors != null ? selectors.size() : 0;
        for(int i = 0; i &lt; sMax; i++) {
            Selector sel = selectors.get(i);
            sel.setRule(Rule.this);
        }

    }

    // Return mask of selectors that match
    long applies(Node node, Set&lt;PseudoClass&gt;[] triggerStates) {
        long mask = 0;
        for (int i = 0; i &lt; selectors.size(); i++) {
            Selector sel = selectors.get(i);
            if (sel.applies(node, triggerStates, 0)) {
                mask |= 1l &lt;&lt; i;
<A NAME="52"></A>            }
        }
        return mask;
    <FONT color="#2b60de"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#52',2,'match42-top.html#52',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /** Converts this object to a string.
     * @return the converted string
     */
    @Override public String toString() {
        StringBuilder sb = new StringBuilder();
        if (selectors.size()&gt;0) {</B></FONT>
            sb.append(selectors.get(0));
        }
        for (int n=1; n&lt;selectors.size(); n++) {
            sb.append(',');
            sb.append(selectors.get(n));
        }
        sb.append(&quot;{\n&quot;);
        int nDeclarations = declarations != null ? declarations.size() : 0;
        for (int n=0; n&lt;nDeclarations; n++) {
            sb.append(&quot;\t&quot;);
            sb.append(declarations.get(n));
            sb.append(&quot;\n&quot;);
        }
        sb .append(&quot;}&quot;);
        return sb.toString();
    }

    /*
     * If an authoring tool adds or removes a selector or declaration,
     * then the selector or declaration needs to be tweaked to know that
     * this is the Rule to which it belongs.
     */
    private final static class Observables {

        private Observables(Rule rule) {

            this.rule = rule;

            selectorObservableList = new TrackableObservableList&lt;Selector&gt;(rule.getUnobservedSelectorList()) {
                @Override protected void onChanged(Change&lt;Selector&gt; c) {
                    while (c.next()) {
                        if (c.wasAdded()) {
                            List&lt;Selector&gt; added = c.getAddedSubList();
                            for(int i = 0, max = added.size(); i &lt; max; i++) {
                                Selector sel = added.get(i);
                                sel.setRule(Observables.this.rule);
                            }
                        }

                        if (c.wasRemoved()) {
                            List&lt;Selector&gt; removed = c.getAddedSubList();
                            for(int i = 0, max = removed.size(); i &lt; max; i++) {
                                Selector sel = removed.get(i);
                                if (sel.getRule() == Observables.this.rule) {
                                    sel.setRule(null);
                                }
                            }
                        }
                    }
                }
            };

            declarationObservableList = new TrackableObservableList&lt;Declaration&gt;(rule.getUnobservedDeclarationList()) {
                @Override protected void onChanged(Change&lt;Declaration&gt; c) {
                    while (c.next()) {
                        if (c.wasAdded()) {
                            List&lt;Declaration&gt; added = c.getAddedSubList();
                            for(int i = 0, max = added.size(); i &lt; max; i++) {
                                Declaration decl = added.get(i);
                                decl.rule = Observables.this.rule;

                                Stylesheet stylesheet = Observables.this.rule.stylesheet;
                                if (stylesheet != null &amp;&amp; stylesheet.getUrl() != null) {
                                    final String stylesheetUrl = stylesheet.getUrl();
                                    decl.fixUrl(stylesheetUrl);
                                }
                            }
                        }

                        if (c.wasRemoved()) {
                            List&lt;Declaration&gt; removed = c.getRemoved();
                            for(int i = 0, max = removed.size(); i &lt; max; i++) {
                                Declaration decl = removed.get(i);
                                if (decl.rule == Observables.this.rule) {
                                    decl.rule = null;
                                }
                            }
                        }
                    }
                }
            };

        }

        private ObservableList&lt;Selector&gt; getSelectors() {
            return selectorObservableList;
        }

        private ObservableList&lt;Declaration&gt; getDeclarations() {
            return declarationObservableList;
        }

        private final Rule rule;
        private final ObservableList&lt;Selector&gt; selectorObservableList;
        private final ObservableList&lt;Declaration&gt; declarationObservableList;

    }

    final void writeBinary(DataOutputStream os, StyleConverter.StringStore stringStore)
            throws IOException {

        final int nSelectors = this.selectors != null ? this.selectors.size() : 0;
        os.writeShort(nSelectors);
        for (int i = 0; i &lt; nSelectors; i++) {
            Selector sel = this.selectors.get(i);
            sel.writeBinary(os, stringStore);
        }

        List&lt;Declaration&gt; decls = getUnobservedDeclarationList();
        if (decls != null) {

            ByteArrayOutputStream bos = new ByteArrayOutputStream(5192);
            DataOutputStream dos = new DataOutputStream(bos);

            int nDeclarations =  decls.size();
            dos.writeShort(nDeclarations);

            for (int i = 0; i &lt; nDeclarations; i++) {
                Declaration decl = declarations.get(i);
                decl.writeBinary(dos, stringStore);
            }

            os.writeInt(bos.size());
            os.write(bos.toByteArray());

        } else {
            // no declarations!
            os.writeShort(0);
        }
    }

    static Rule readBinary(int bssVersion, DataInputStream is, String[] strings)
            throws IOException
    {
        short nSelectors = is.readShort();
        List&lt;Selector&gt; selectors = new ArrayList&lt;Selector&gt;(nSelectors);
        for (int i = 0; i &lt; nSelectors; i++) {
            Selector s = Selector.readBinary(bssVersion, is, strings);
            selectors.add(s);
        }

        if (bssVersion &lt; 4) {
            short nDeclarations = is.readShort();
            List&lt;Declaration&gt; declarations = new ArrayList&lt;Declaration&gt;(nDeclarations);
            for (int i = 0; i &lt; nDeclarations; i++) {
                Declaration d = Declaration.readBinary(bssVersion, is, strings);
                declarations.add(d);
            }

            return new Rule(selectors, declarations);
        }

        // de-serialize decls into byte array
        int nBytes = is.readInt();
        byte[] buf = new byte[nBytes];

        if (nBytes &gt; 0) {
            is.readFully(buf);
        }
        return new Rule(selectors, buf, bssVersion);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Node.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;


import com.sun.javafx.geometry.BoundsUtils;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.BooleanExpression;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanPropertyBase;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;
import javafx.css.CssMetaData;
import javafx.css.ParsedValue;
import javafx.css.PseudoClass;
import javafx.css.StyleConverter;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.Event;
import javafx.event.EventDispatchChain;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.geometry.Rectangle2D;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.Effect;
import javafx.scene.image.WritableImage;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.DragEvent;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputEvent;
import javafx.scene.input.InputMethodEvent;
import javafx.scene.input.InputMethodRequests;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.PickResult;
import javafx.scene.input.RotateEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.input.ZoomEvent;
import javafx.scene.text.Font;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Transform;
import javafx.stage.Window;
import javafx.util.Callback;
import java.security.AccessControlContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.sun.glass.ui.Accessible;
import com.sun.glass.ui.Application;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.TempState;
import com.sun.javafx.util.Utils;
import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.beans.event.AbstractNotifyListener;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.collections.UnmodifiableListSet;
import com.sun.javafx.css.PseudoClassState;
import javafx.css.Selector;
import javafx.css.Style;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.CursorConverter;
import javafx.css.converter.EffectConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.javafx.scene.CameraHelper;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.EventHandlerProperties;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.NodeEventDispatcher;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.SceneUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.scene.transform.TransformUtils;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.impl.PrismSettings;
import com.sun.scenario.effect.EffectHelper;

import javafx.scene.shape.Shape3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

/**
 * Base class for scene graph nodes. A scene graph is a set of tree data structures
 * where every item has zero or one parent, and each item is either
 * a &quot;leaf&quot; with zero sub-items or a &quot;branch&quot; with zero or more sub-items.
 * &lt;p&gt;
 * Each item in the scene graph is called a {@code Node}. Branch nodes are
 * of type {@link Parent}, whose concrete subclasses are {@link Group},
 * {@link javafx.scene.layout.Region}, and {@link javafx.scene.control.Control},
 * or subclasses thereof.
 * &lt;p&gt;
 * Leaf nodes are classes such as
 * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},
 * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},
 * or other such leaf classes which cannot have children. Only a single node within
 * each scene graph tree will have no parent, which is referred to as the &quot;root&quot; node.
 * &lt;p&gt;
 * There may be several trees in the scene graph. Some trees may be part of
 * a {@link Scene}, in which case they are eligible to be displayed.
 * Other trees might not be part of any {@link Scene}.
 * &lt;p&gt;
 * A node may occur at most once anywhere in the scene graph. Specifically,
 * a node must appear no more than once in all of the following:
 * as the root node of a {@link Scene},
 * the children ObservableList of a {@link Parent},
 * or as the clip of a {@link Node}.
 * &lt;p&gt;
 * The scene graph must not have cycles. A cycle would exist if a node is
 * an ancestor of itself in the tree, considering the {@link Group} content
 * ObservableList, {@link Parent} children ObservableList, and {@link Node} clip relationships
 * mentioned above.
 * &lt;p&gt;
 * If a program adds a child node to a Parent (including Group, Region, etc)
 * and that node is already a child of a different Parent or the root of a Scene,
 * the node is automatically (and silently) removed from its former parent.
 * If a program attempts to modify the scene graph in any other way that violates
 * the above rules, an exception is thrown, the modification attempt is ignored
 * and the scene graph is restored to its previous state.
 * &lt;p&gt;
 * It is possible to rearrange the structure of the scene graph, for
 * example, to move a subtree from one location in the scene graph to
 * another. In order to do this, one would normally remove the subtree from
 * its old location before inserting it at the new location. However, the
 * subtree will be automatically removed as described above if the application
 * doesn't explicitly remove it.
 * &lt;p&gt;
 * Node objects may be constructed and modified on any thread as long they are
 * not yet attached to a {@link Scene} in a {@link Window} that is
 * {@link Window#isShowing showing}.
 * An application must attach nodes to such a Scene or modify them on the JavaFX
 * Application Thread.
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An application should not extend the Node class directly. Doing so may lead to
 * an UnsupportedOperationException being thrown.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;String ID&lt;/h3&gt;
 * &lt;p&gt;
 * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
 * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
 * and developer to ensure that the {@code id} is unique within the scene graph.
 * A convenience function called {@link #lookup(String)} can be used to find
 * a node with a unique id within the scene graph, or within a subtree of the
 * scene graph. The id can also be used identify nodes for applying styles; see
 * the CSS section below.
 *
 * &lt;h3&gt;Coordinate System&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
 * coordinate system in which the {@code x} axis increases to the right and the
 * {@code y} axis increases downwards.  The concrete node classes for shapes
 * provide variables for defining the geometry and location of the shape
 * within this local coordinate space.  For example,
 * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
 * {@code width}, {@code height} variables while
 * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
 * and {@code radius}.
 * &lt;p&gt;
 * At the device pixel level, integer coordinates map onto the corners and
 * cracks between the pixels and the centers of the pixels appear at the
 * midpoints between integer pixel locations.  Because all coordinate values
 * are specified with floating point numbers, coordinates can precisely
 * point to these corners (when the floating point values have exact integer
 * values) or to any location on the pixel.  For example, a coordinate of
 * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
 * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
 * of {@code 10} by {@code 10} would span from the upper left corner of the
 * upper left pixel on the {@code Stage} to the lower right corner of the
 * 10th pixel on the 10th scanline.  The pixel center of the last pixel
 * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
 * &lt;p&gt;
 * In practice, most nodes have transformations applied to their coordinate
 * system as mentioned below.  As a result, the information above describing
 * the alignment of device coordinates to the pixel grid is relative to
 * the transformed coordinates, not the local coordinates of the nodes.
 * The {@link javafx.scene.shape.Shape Shape} class describes some additional
 * important context-specific information about coordinate mapping and how
 * it can affect rendering.
 *
 * &lt;h3&gt;Transformations&lt;/h3&gt;
 * &lt;p&gt;
 * Any {@code Node} can have transformations applied to it. These include
 * translation, rotation, scaling, or shearing.
 * &lt;p&gt;
 * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
 * node's coordinate space along either the x or y axis. For example, if you
 * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
 * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
 * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
 * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
 * 100 points wide and 50 tall. Note that the origin was shifted, not the
 * {@code x} variable of the rectangle.
 * &lt;p&gt;
 * A common node transform is a translation by an integer distance, most often
 * used to lay out nodes on the stage.  Such integer translations maintain the
 * device pixel mapping so that local coordinates that are integers still
 * map to the cracks between pixels.
 * &lt;p&gt;
 * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
 * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
 * For example, if you create a {@link javafx.scene.shape.Rectangle} which is
 * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
 * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
 * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
 * the rectangle will be drawn as if its x and y were zero but its height was
 * 100 and its width -30. That is, it is as if a pin is being stuck at the top
 * left corner and the rectangle is rotating 90 degrees clockwise around that
 * pin. If the pivot point is instead placed in the center of the rectangle
 * (at point x=50, y=15) then the rectangle will instead appear to rotate about
 * its center.
 * &lt;p&gt;
 * Note that as with all transformations, the x, y, width, and height variables
 * of the rectangle (which remain relative to the local coordinate space) have
 * not changed, but rather the transformation alters the entire coordinate space
 * of the rectangle.
 * &lt;p&gt;
 * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
 * smaller depending on the scaling factor. Scaling alters the coordinate space
 * of the node such that each unit of distance along the axis in local
 * coordinates is multiplied by the scale factor. As with rotation
 * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
 * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For
 * example, if you create a {@link javafx.scene.shape.Rectangle} with a
 * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
 * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
 * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
 * (including the stroke) will double in size, growing to the right and
 * downwards from the origin.
 * &lt;p&gt;
 * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
 * rotates one axis so that the x and y axes are no longer perpendicular.
 * &lt;p&gt;
 * Multiple transformations may be applied to a node by specifying an ordered
 * chain of transforms.  The order in which the transforms are applied is
 * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
 *
 * &lt;h3&gt;Bounding Rectangles&lt;/h3&gt;
 * &lt;p&gt;
 * Since every {@code Node} has transformations, every Node's geometric
 * bounding rectangle can be described differently depending on whether
 * transformations are accounted for or not.
 * &lt;p&gt;
 * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
 * variable which specifies the bounding rectangle of the {@code Node} in
 * untransformed local coordinates. {@code boundsInLocal} includes the
 * Node's shape geometry, including any space required for a
 * non-zero stroke that may fall outside the local position/size variables,
 * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
 * &lt;p&gt;
 * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
 * specifies the bounding rectangle of the {@code Node} after all transformations
 * have been applied, including those set in {@link #getTransforms transforms},
 * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
 * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
 * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
 * parent's coordinate system.  This is the 'visual' bounds of the node.
 * &lt;p&gt;
 * Finally, the {@link #layoutBoundsProperty layoutBounds} variable defines the rectangular bounds of
 * the {@code Node} that should be used as the basis for layout calculations and
 * may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
 * layoutBounds by default includes only the shape geometry, including space required
 * for a non-zero {@code strokeWidth}, but does &lt;i&gt;not&lt;/i&gt; include the effect,
 * clip, or any transforms. For resizable classes (Regions and Controls)
 * layoutBounds will always map to {@code 0,0 width x height}.
 *
 * &lt;p&gt; The image shows a node without any transformation and its {@code boundsInLocal}:
 * &lt;p&gt; &lt;img src=&quot;doc-files/boundsLocal.png&quot; alt=&quot;A sine wave shape enclosed by
 * an axis-aligned rectangular bounds&quot;&gt; &lt;/p&gt;
 * If we rotate the image by 20 degrees we get following result:
 * &lt;p&gt; &lt;img src=&quot;doc-files/boundsParent.png&quot; alt=&quot;An axis-aligned rectangular
 * bounds that encloses the shape rotated by 20 degrees&quot;&gt; &lt;/p&gt;
 * The red rectangle represents {@code boundsInParent} in the
 * coordinate space of the Node's parent. The {@code boundsInLocal} stays the same
 * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
 * in the coordinate space of the Node.
 *
 * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
 * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
 * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
 *
 * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
 * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
 * (the stroke is centered by default, so only half of it is outside
 * of the original bounds; it is also possible to create inside or outside
 * stroke).
 *
 * Since neither of the rectangles has any transformation applied,
 * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
 * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
 * respective bounds&quot;&gt; &lt;/p&gt;
 *
 *
 * &lt;h3&gt;CSS&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code Node} class contains {@code id}, {@code styleClass}, and
 * {@code style} variables that are used in styling this node from
 * CSS. The {@code id} and {@code styleClass} variables are used in
 * CSS style sheets to identify nodes to which styles should be
 * applied. The {@code style} variable contains style properties and
 * values that are applied directly to this node.
 * &lt;p&gt;
 * For further information about CSS and how to apply CSS styles
 * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
 * Guide&lt;/a&gt;.
 * @since JavaFX 2.0
 */
@IDProperty(&quot;id&quot;)
public abstract class Node implements EventTarget, Styleable {

    /*
     * Store the singleton instance of the NodeHelper subclass corresponding
     * to the subclass of this instance of Node
     */
    private NodeHelper nodeHelper = null;

    static {
        PerformanceTracker.logEvent(&quot;Node class loaded&quot;);

        // This is used by classes in different packages to get access to
        // private and package private methods.
        NodeHelper.setNodeAccessor(new NodeHelper.NodeAccessor() {
            @Override
            public NodeHelper getHelper(Node node) {
                return node.nodeHelper;
            }

            @Override
            public void setHelper(Node node, NodeHelper nodeHelper) {
                node.nodeHelper = nodeHelper;
            }

            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                node.doMarkDirty(dirtyBit);
            }

            @Override
            public void doUpdatePeer(Node node) {
                node.doUpdatePeer();
            }

            @Override
            public BaseTransform getLeafTransform(Node node) {
                return node.getLeafTransform();
            }

            @Override
            public Bounds doComputeLayoutBounds(Node node) {
                return node.doComputeLayoutBounds();
            }

            @Override
            public void doTransformsChanged(Node node) {
                node.doTransformsChanged();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                node.doPickNodeLocal(localPickRay, result);
            }

            @Override
            public boolean doComputeIntersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return node.doComputeIntersects(pickRay, pickResult);
            }

            @Override
            public void doGeomChanged(Node node) {
                node.doGeomChanged();
            }

            @Override
            public void doNotifyLayoutBoundsChanged(Node node) {
                node.doNotifyLayoutBoundsChanged();
            }

            @Override
            public void doProcessCSS(Node node) {
                node.doProcessCSS();
            }

            @Override
            public boolean isDirty(Node node, DirtyBits dirtyBit) {
                return node.isDirty(dirtyBit);
            }

            @Override
            public boolean isDirtyEmpty(Node node) {
                return node.isDirtyEmpty();
            }

            @Override
            public void syncPeer(Node node) {
                node.syncPeer();
            }

            @Override
            public void layoutBoundsChanged(Node node) {
                node.layoutBoundsChanged();
            }

            @Override
            public &lt;P extends NGNode&gt; P getPeer(Node node) {
                return node.getPeer();
            }

            @Override
            public void setShowMnemonics(Node node, boolean value) {
                node.setShowMnemonics(value);
            }

            @Override
            public boolean isShowMnemonics(Node node) {
                return node.isShowMnemonics();
            }

            @Override
            public BooleanProperty showMnemonicsProperty(Node node) {
                return node.showMnemonicsProperty();
            }

            @Override
            public boolean traverse(Node node, Direction direction) {
                return node.traverse(direction);
            }

            @Override
            public double getPivotX(Node node) {
                return node.getPivotX();
            }

            @Override
            public double getPivotY(Node node) {
                return node.getPivotY();
            }

            @Override
            public double getPivotZ(Node node) {
                return node.getPivotZ();
            }

            @Override
            public void pickNode(Node node,PickRay pickRay,
                    PickResultChooser result) {
                node.pickNode(pickRay, result);
            }

            @Override
            public boolean intersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return node.intersects(pickRay, pickResult);
            }

            @Override
            public double intersectsBounds(Node node, PickRay pickRay) {
                return node.intersectsBounds(pickRay);
            }

            @Override
            public void layoutNodeForPrinting(Node node) {
                node.doCSSLayoutSyncForSnapshot();
            }

            @Override
            public boolean isDerivedDepthTest(Node node) {
                return node.isDerivedDepthTest();
            }

            @Override
            public SubScene getSubScene(Node node) {
                return node.getSubScene();
            }

            @Override
            public void setLabeledBy(Node node, Node labeledBy) {
                node.labeledBy = labeledBy;
            }

            @Override
            public Accessible getAccessible(Node node) {
                return node.getAccessible();
            }

            @Override
            public void reapplyCSS(Node node) {
                node.reapplyCSS();
            }

            @Override
            public boolean isTreeVisible(Node node) {
                return node.isTreeVisible();
            }

            @Override
            public BooleanExpression treeVisibleProperty(Node node) {
                return node.treeVisibleProperty();
            }

            @Override
            public boolean isTreeShowing(Node node) {
                return node.isTreeShowing();
            }

            @Override
            public BooleanExpression treeShowingProperty(Node node) {
                return node.treeShowingProperty();
            }

            @Override
            public List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData,
                    Styleable styleable) {
                return Node.getMatchingStyles(cssMetaData, styleable);
            }

            @Override
            public Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; findStyles(Node node,
                    Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
                return node.findStyles(styleMap);
            }
        });
    }

    /**************************************************************************
     *                                                                        *
     * Methods and state for managing the dirty bits of a Node. The dirty     *
     * bits are flags used to keep track of what things are dirty on the      *
     * node and therefore need processing on the next pulse. Since the pulse  *
     * happens asynchronously to the change that made the node dirty (for     *
     * performance reasons), we need to keep track of what things have        *
     * changed.                                                               *
     *                                                                        *
     *************************************************************************/

    /*
     * Set of dirty bits that are set when state is invalidated and cleared by
     * the updateState method, which is called from the synchronizer.
     */
    private int dirtyBits;

    /*
     * Mark the specified bit as dirty, and add this node to the scene's dirty list.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        if (isDirtyEmpty()) {
            addToSceneDirtyList();
        }

        dirtyBits |= dirtyBit.getMask();
    }

    private void addToSceneDirtyList() {
        Scene s = getScene();
        if (s != null) {
            s.addToDirtyList(this);
            if (getSubScene() != null) {
                getSubScene().setDirty(this);
            }
        }
    }

    /*
     * Test whether the specified dirty bit is set
     */
    final boolean isDirty(DirtyBits dirtyBit) {
        return (dirtyBits &amp; dirtyBit.getMask()) != 0;
    }

    /*
     * Clear the specified dirty bit
     */
    final void clearDirty(DirtyBits dirtyBit) {
        dirtyBits &amp;= ~dirtyBit.getMask();
    }

    /*
     * Set all dirty bits
     */
    private void setDirty() {
        dirtyBits = ~0;
    }

    /*
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    /*
     * Test whether the set of dirty bits is empty
     */
    final boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**************************************************************************
     *                                                                        *
     * Methods for synchronizing state from this Node to its PG peer. This    *
     * should only *ever* be called during synchronization initialized as a   *
     * result of a pulse. Any attempt to synchronize at any other time may    *
     * cause rendering artifacts.                                             *
     *                                                                        *
     *************************************************************************/

    /*
     * Called by the synchronizer to update the state and
     * clear dirtybits of this node in the PG graph
     */
    final void syncPeer() {
        // Do not synchronize invisible nodes unless their visibility has changed
        // or they have requested a forced synchronization
        if (!isDirtyEmpty() &amp;&amp; (treeVisible
                                     || isDirty(DirtyBits.NODE_VISIBLE)
                                     || isDirty(DirtyBits.NODE_FORCE_SYNC)))
        {
            NodeHelper.updatePeer(this);
            clearDirty();
        }
    }

    /**
     * A temporary rect used for computing bounds by the various bounds
     * variables. This bounds starts life as a RectBounds, but may be promoted
     * to a BoxBounds if there is a 3D transform mixed into its computation.
     * These two fields were held in a thread local, but were then pulled
     * out of it so that we could compute bounds before holding the
     * synchronization lock. These objects have to be per-instance so
     * that we can pass the right data down to the PG side later during
     * synchronization (rather than statics as they were before).
     */
    private BaseBounds _geomBounds = new RectBounds(0, 0, -1, -1);
    private BaseBounds _txBounds = new RectBounds(0, 0, -1, -1);

    private boolean pendingUpdateBounds = false;

    // Happens before we hold the sync lock
    void updateBounds() {
        // Note: the clip must be handled before the visibility is checked. This is because the visiblity might be
        // changing in the clip and it is going to be synchronized, so it needs to recompute the bounds.
        Node n = getClip();
        if (n != null) {
            n.updateBounds();
        }

        // See syncPeer()
        if (!treeVisible &amp;&amp; !isDirty(DirtyBits.NODE_VISIBLE)) {

            // Need to save the dirty bits since they will be cleared even for the
            // case of short circuiting dirty bit processing.
            if (isDirty(DirtyBits.NODE_TRANSFORM)
                    || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)
                    || isDirty(DirtyBits.NODE_BOUNDS)) {
                pendingUpdateBounds = true;
            }

            return;
        }

        // Set transform and bounds dirty bits when this node becomes visible
        if (pendingUpdateBounds) {
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
            NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);

            pendingUpdateBounds = false;
        }

        if (isDirty(DirtyBits.NODE_TRANSFORM) || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
            if (isDirty(DirtyBits.NODE_TRANSFORM)) {
                updateLocalToParentTransform();
            }
            _txBounds = getTransformedBounds(_txBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
        }

        if (isDirty(DirtyBits.NODE_BOUNDS)) {
            _geomBounds = getGeomBounds(_geomBounds,
                    BaseTransform.IDENTITY_TRANSFORM);
        }

    }

    /*
     * This function is called during synchronization to update the state of the
     * NG Node from the FX Node. Subclasses of Node should override this method
     * and must call NodeHelper.updatePeer(this)
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGNode peer = getPeer();

        // For debug / diagnostic purposes, we will copy across a name for this node down to
        // the NG layer, where we can use the name to figure out what the NGNode represents.
        // An alternative would be to have a back-reference from the NGNode back to the Node it
        // is a peer to, however it was felt that this would make it too easy to communicate back
        // to the Node and possibly violate thread invariants. But of course, we only need to do this
        // if we're going to print the render graph (otherwise all the work we'd do to keep the name
        // properly updated would be a waste).
        if (PrismSettings.printRenderGraph &amp;&amp; isDirty(DirtyBits.DEBUG)) {
            final String id = getId();
            String className = getClass().getSimpleName();
            if (className.isEmpty()) {
                className = getClass().getName();
            }
            peer.setName(id == null ? className : id + &quot;(&quot; + className + &quot;)&quot;);
        }

        if (isDirty(DirtyBits.NODE_TRANSFORM)) {
            peer.setTransformMatrix(localToParentTx);
        }

        if (isDirty(DirtyBits.NODE_VIEW_ORDER)) {
            peer.setViewOrder(getViewOrder());
        }

        if (isDirty(DirtyBits.NODE_BOUNDS)) {
            peer.setContentBounds(_geomBounds);
        }

        if (isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
            peer.setTransformedBounds(_txBounds, !isDirty(DirtyBits.NODE_BOUNDS));
        }

        if (isDirty(DirtyBits.NODE_OPACITY)) {
            peer.setOpacity((float)Utils.clamp(0, getOpacity(), 1));
        }

        if (isDirty(DirtyBits.NODE_CACHE)) {
            peer.setCachedAsBitmap(isCache(), getCacheHint());
        }

        if (isDirty(DirtyBits.NODE_CLIP)) {
            peer.setClipNode(getClip() != null ? getClip().getPeer() : null);
        }

        if (isDirty(DirtyBits.EFFECT_EFFECT)) {
            if (getEffect() != null) {
                EffectHelper.sync(getEffect());
                peer.effectChanged();
            }
        }

        if (isDirty(DirtyBits.NODE_EFFECT)) {
            peer.setEffect(getEffect() != null ? EffectHelper.getPeer(getEffect()) : null);
        }

        if (isDirty(DirtyBits.NODE_VISIBLE)) {
            peer.setVisible(isVisible());
        }

        if (isDirty(DirtyBits.NODE_DEPTH_TEST)) {
            peer.setDepthTest(isDerivedDepthTest());
        }

        if (isDirty(DirtyBits.NODE_BLENDMODE)) {
            BlendMode mode = getBlendMode();
            peer.setNodeBlendMode((mode == null)
                                  ? null
                                  : EffectHelper.getToolkitBlendMode(mode));
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this node
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Node has properties.
     * @return true if node has properties.
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Node#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Node#getUserData()}.
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Node#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /**************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/

    /**
     * The parent of this {@code Node}. If this {@code Node} has not been added
     * to a scene graph, then parent will be null.
     *
     * @defaultValue null
     */
    private ReadOnlyObjectWrapper&lt;Parent&gt; parent;

    final void setParent(Parent value) {
        parentPropertyImpl().set(value);
    }

    public final Parent getParent() {
        return parent == null ? null : parent.get();
    }

    public final ReadOnlyObjectProperty&lt;Parent&gt; parentProperty() {
        return parentPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Parent&gt; parentPropertyImpl() {
        if (parent == null) {
            parent = new ReadOnlyObjectWrapper&lt;Parent&gt;() {
                private Parent oldParent;

                @Override
                protected void invalidated() {
                    if (oldParent != null) {
                        oldParent.disabledProperty().removeListener(parentDisabledChangedListener);
                        oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);
                        if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
                            ((Node) oldParent).localToSceneTransformProperty().removeListener(
                                    nodeTransformation.getLocalToSceneInvalidationListener());
                        }
                    }
                    updateDisabled();
                    computeDerivedDepthTest();
                    final Parent newParent = get();
                    if (newParent != null) {
                        newParent.disabledProperty().addListener(parentDisabledChangedListener);
                        newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);
                        if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
                            ((Node) newParent).localToSceneTransformProperty().addListener(
                                    nodeTransformation.getLocalToSceneInvalidationListener());
                        }
                        //
                        // if parent changed, then CSS needs to be reapplied so
                        // that this node will get the right styles. This used
                        // to be done from Parent.children's onChanged method.
                        // See the comments there, also.
                        //
                        reapplyCSS();
                    } else {
                        // RT-31168: reset CssFlag to clean so css will be reapplied if the node is added back later.
                        // If flag is REAPPLY, then reapplyCSS() will just return and the call to
                        // notifyParentsOfInvalidatedCSS() will be skipped thus leaving the node un-styled.
                        cssFlag = CssFlags.CLEAN;
                    }
                    updateTreeVisible(true);
                    oldParent = newParent;
                    invalidateLocalToSceneTransform();
                    parentResolvedOrientationInvalidated();
                    notifyAccessibleAttributeChanged(AccessibleAttribute.PARENT);
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;parent&quot;;
                }
            };
        }
        return parent;
    }

    private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; updateDisabled();

    private final InvalidationListener parentTreeVisibleChangedListener = valueModel -&gt; updateTreeVisible(true);

    private final ChangeListener&lt;Boolean&gt; windowShowingChangedListener
            = (win, oldVal, newVal) -&gt; updateTreeShowing();

    private final ChangeListener&lt;Window&gt; sceneWindowChangedListener = (scene, oldWindow, newWindow) -&gt; {
        // Replace the windowShowingListener and call updateTreeShowing()
        if (oldWindow != null) {
            oldWindow.showingProperty().removeListener(windowShowingChangedListener);
        }
        if (newWindow != null) {
            newWindow.showingProperty().addListener(windowShowingChangedListener);
        }
        updateTreeShowing();
    };

    private SubScene subScene = null;

    /**
     * The {@link Scene} that this {@code Node} is part of. If the Node is not
     * part of a scene, then this variable will be null.
     *
     * @defaultValue null
     */
    private ReadOnlyObjectWrapperManualFire&lt;Scene&gt; scene = new ReadOnlyObjectWrapperManualFire&lt;Scene&gt;();

    private class ReadOnlyObjectWrapperManualFire&lt;T&gt; extends ReadOnlyObjectWrapper&lt;T&gt; {
        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;scene&quot;;
        }

        @Override
        protected void fireValueChangedEvent() {
            /*
             * Note: This method has been intentionally made into a no-op. In
             * order to override the default set behavior. By default calling
             * set(...) on a different scene will trigger:
             * - invalidated();
             * - fireValueChangedEvent();
             * Both of the above are no-ops, but are handled manually via
             * - Node.this.setScenes(...)
             * - Node.this.invalidatedScenes(...)
             * - forceValueChangedEvent()
             */
        }

        public void fireSuperValueChangedEvent() {
            super.fireValueChangedEvent();
        }
    }

    private void invalidatedScenes(Scene oldScene, SubScene oldSubScene) {
        Scene newScene = sceneProperty().get();
        boolean sceneChanged = oldScene != newScene;
        SubScene newSubScene = subScene;

        if (getClip() != null) {
            getClip().setScenes(newScene, newSubScene);
        }
        if (sceneChanged) {
            updateCanReceiveFocus();
            if (isFocusTraversable()) {
                if (newScene != null) {
                    newScene.initializeInternalEventDispatcher();
                }
            }
            focusSetDirty(oldScene);
            focusSetDirty(newScene);
        }
        scenesChanged(newScene, newSubScene, oldScene, oldSubScene);

        // isTreeShowing needs to take into account of Window's showing
        if (oldScene != null) {
            oldScene.windowProperty().removeListener(sceneWindowChangedListener);
        }
        if (newScene != null) {
            newScene.windowProperty().addListener(sceneWindowChangedListener);
        }
        updateTreeShowing();

        if (sceneChanged) reapplyCSS();

        if (sceneChanged &amp;&amp; !isDirtyEmpty()) {
            //Note: no need to remove from scene's dirty list
            //Scene's is checking if the node's scene is correct
            /* TODO: looks like an existing bug when a node is moved from one
             * location to another, setScenes will be called twice by
             * Parent.VetoableListDecorator onProposedChange and onChanged
             * respectively. Removing the node and setting setScense(null,null)
             * then adding it back to potentially the same scene. Causing the
             * same node to being added twice to the same scene.
             */
            addToSceneDirtyList();
        }

        if (newScene == null &amp;&amp; peer != null) {
            peer.release();
        }

        if (oldScene != null) {
            oldScene.clearNodeMnemonics(this);
        }
        if (getParent() == null) {
            // if we are the root we need to handle scene change
            parentResolvedOrientationInvalidated();
        }

        if (sceneChanged) { scene.fireSuperValueChangedEvent(); }

        /* Dispose the accessible peer, if any. If AT ever needs this node again
         * a new accessible peer is created. */
        if (accessible != null) {
            /* Generally accessibility does not retain any state, therefore deleting objects
             * generally does not cause problems (AT just asks everything back).
             * The exception to this rule is when the object sends a notifications to the AT,
             * in which case it is expected to be around to answer request for the new values.
             * It is possible that a object is reparented (within the scene) in the middle of
             * this process. For example, when a tree item is expanded, the notification is
             * sent to the AT by the cell. But when the TreeView relayouts the cell can be
             * reparented before AT can query the relevant information about the expand event.
             * If the accessible was disposed, AT can't properly report the event.
             *
             * The fix is to defer the disposal of the accessible to the next pulse.
             * If at that time the node is placed back to the scene, then the accessible is hooked
             * to Node and AT requests are processed. Otherwise the accessible is disposed.
             */
            if (oldScene != null &amp;&amp; oldScene != newScene &amp;&amp; newScene == null) {
                // Strictly speaking we need some type of accessible.thaw() at this point.
                oldScene.addAccessible(Node.this, accessible);
            } else {
                accessible.dispose();
            }
            /* Always set to null to ensure this accessible is never on more than one
             * Scene#accMap at the same time (At lest not with the same accessible).
             */
            accessible = null;
        }
    }

    final void setScenes(Scene newScene, SubScene newSubScene) {
        Scene oldScene = sceneProperty().get();
        if (newScene != oldScene || newSubScene != subScene) {
            scene.set(newScene);
            SubScene oldSubScene = subScene;
            subScene = newSubScene;
            invalidatedScenes(oldScene, oldSubScene);
            if (this instanceof SubScene) { // TODO: find better solution
                SubScene thisSubScene = (SubScene)this;
                thisSubScene.getRoot().setScenes(newScene, thisSubScene);
            }
        }
    }

    final SubScene getSubScene() {
        return subScene;
    }

    public final Scene getScene() {
        return scene.get();
    }

    public final ReadOnlyObjectProperty&lt;Scene&gt; sceneProperty() {
        return scene.getReadOnlyProperty();
    }

    /**
     * Exists for Parent and LightBase
     */
    void scenesChanged(final Scene newScene, final SubScene newSubScene,
                       final Scene oldScene, final SubScene oldSubScene) { }


    /**
     * The id of this {@code Node}. This simple string identifier is useful for
     * finding a specific Node within the scene graph. While the id of a Node
     * should be unique within the scene graph, this uniqueness is not enforced.
     * This is analogous to the &quot;id&quot; attribute on an HTML element
     * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
     * &lt;p&gt;
     *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
     *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @defaultValue null
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     */
    private StringProperty id;

    public final void setId(String value) {
        idProperty().set(value);
    }

    //TODO: this is copied from the property in order to add the @return statement.
    //      We should have a better, general solution without the need to copy it.
    /**
     * The id of this {@code Node}. This simple string identifier is useful for
     * finding a specific Node within the scene graph. While the id of a Node
     * should be unique within the scene graph, this uniqueness is not enforced.
     * This is analogous to the &quot;id&quot; attribute on an HTML element
     * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
     *
     * @return the id assigned to this {@code Node} using the {@code setId}
     *         method or {@code null}, if no id has been assigned.
     * @defaultValue null
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final String getId() {
        return id == null ? null : id.get();
    }

    public final StringProperty idProperty() {
        if (id == null) {
            id = new StringPropertyBase() {

                @Override
                protected void invalidated() {
                    reapplyCSS();
                    if (PrismSettings.printRenderGraph) {
                        NodeHelper.markDirty(Node.this, DirtyBits.DEBUG);
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;id&quot;;
                }
            };
        }
        return id;
    }

    /**
     * A list of String identifiers which can be used to logically group
     * Nodes, specifically for an external style engine. This variable is
     * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
     * each element of the list is a style class to which this Node belongs.
     *
     * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * @defaultValue null
     */
    private ObservableList&lt;String&gt; styleClass = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            reapplyCSS();
        }

        @Override
        public String toString() {
            if (size() == 0) {
                return &quot;&quot;;
            } else if (size() == 1) {
                return get(0);
            } else {
                StringBuilder buf = new StringBuilder();
                for (int i = 0; i &lt; size(); i++) {
                    buf.append(get(i));
                    if (i + 1 &lt; size()) {
                        buf.append(' ');
                    }
                }
                return buf.toString();
            }
        }
    };

    @Override
    public final ObservableList&lt;String&gt; getStyleClass() {
        return styleClass;
    }

    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @defaultValue empty string
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     */
    private StringProperty style;

    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @param value The inline CSS style to use for this {@code Node}.
     *         {@code null} is implicitly converted to an empty String.
     * @defaultValue empty string
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final void setStyle(String value) {
        styleProperty().set(value);
    }

    // TODO: javadoc copied from property for the sole purpose of providing a return tag
    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @defaultValue empty string
     * @return The inline CSS style associated with this {@code Node}.
     *         If this {@code Node} does not have an inline style,
     *         an empty String is returned.
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final String getStyle() {
        return style == null ? &quot;&quot; : style.get();
    }

    public final StringProperty styleProperty() {
        if (style == null) {
            style = new StringPropertyBase(&quot;&quot;) {

                @Override public void set(String value) {
                    // getStyle returns an empty string if the style property
                    // is null. To be consistent, getStyle should also return
                    // an empty string when the style property's value is null.
                    super.set((value != null) ? value : &quot;&quot;);
                }

                @Override
                protected void invalidated() {
                    // If the style has changed, then styles of this node
                    // and child nodes might be affected.
                    reapplyCSS();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;style&quot;;
                }
            };
        }
        return style;
    }

    /**
     * Specifies whether this {@code Node} and any subnodes should be rendered
     * as part of the scene graph. A node may be visible and yet not be shown
     * in the rendered scene if, for instance, it is off the screen or obscured
     * by another Node. Invisible nodes never receive mouse events or
     * keyboard focus and never maintain keyboard focus when they become
     * invisible.
     *
     * @defaultValue true
     */
    private BooleanProperty visible;

    public final void setVisible(boolean value) {
        visibleProperty().set(value);
    }

    public final boolean isVisible() {
        return visible == null ? true : visible.get();
    }

    public final BooleanProperty visibleProperty() {
        if (visible == null) {
            visible = new StyleableBooleanProperty(true) {
                boolean oldValue = true;
                @Override
                protected void invalidated() {
                    if (oldValue != get()) {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_VISIBLE);
                        NodeHelper.geomChanged(Node.this);
                        updateTreeVisible(false);
                        if (getParent() != null) {
                            // notify the parent of the potential change in visibility
                            // of this node, since visibility affects bounds of the
                            // parent node
                            getParent().childVisibilityChanged(Node.this);
                        }
                        oldValue = get();
                    }
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.VISIBILITY;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;visible&quot;;
                }
            };
        }
        return visible;
    }

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return (miscProperties == null) ? DEFAULT_CURSOR
                                        : miscProperties.getCursor();
    }

    /**
     * Defines the mouse cursor for this {@code Node} and subnodes. If null,
     * then the cursor of the first parent node with a non-null cursor will be
     * used. If no Node in the scene graph defines a cursor, then the cursor
     * of the {@code Scene} will be used.
     *
     * @return the mouse cursor for this {@code Node} and subnodes
     * @defaultValue null
     */
    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        return getMiscProperties().cursorProperty();
    }

    /**
     * Specifies how opaque (that is, solid) the {@code Node} appears. A Node
     * with 0% opacity is fully translucent. That is, while it is still
     * {@link #visibleProperty visible} and rendered, you generally won't be able to see it. The
     * exception to this rule is when the {@code Node} is combined with a
     * blending mode and blend effect in which case a translucent Node may still
     * have an impact in rendering. An opacity of 50% will render the node as
     * being 50% transparent.
     * &lt;p&gt;
     * A {@link #visibleProperty visible} node with any opacity setting still receives mouse
     * events and can receive keyboard focus. For example, if you want to have
     * a large invisible rectangle overlay all {@code Node}s in the scene graph
     * in order to intercept mouse events but not be visible to the user, you could
     * create a large {@code Rectangle} that had an opacity of 0%.
     * &lt;p&gt;
     * Opacity is specified as a value between 0 and 1. Values less than 0 are
     * treated as 0, values greater than 1 are treated as 1.
     * &lt;p&gt;
     * On some platforms ImageView might not support opacity variable.
     *
     * &lt;p&gt;
     * There is a known limitation of mixing opacity &amp;lt; 1.0 with a 3D Transform.
     * Opacity/Blending is essentially a 2D image operation. The result of
     * an opacity &amp;lt; 1.0 set on a {@link Group} node with 3D transformed children
     * will cause its children to be rendered in order without Z-buffering
     * applied between those children.
     *
     * @defaultValue 1.0
     */
    private DoubleProperty opacity;

    public final void setOpacity(double value) {
        opacityProperty().set(value);
    }
    public final double getOpacity() {
        return opacity == null ? 1 : opacity.get();
    }

    public final DoubleProperty opacityProperty() {
        if (opacity == null) {
            opacity = new StyleableDoubleProperty(1) {

                @Override
                public void invalidated() {
                    NodeHelper.markDirty(Node.this, DirtyBits.NODE_OPACITY);
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.OPACITY;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;opacity&quot;;
                }
            };
        }
        return opacity;
    }

    /**
     * The {@link javafx.scene.effect.BlendMode} used to blend this individual node
     * into the scene behind it. If this node happens to be a Group then all of the
     * children will be composited individually into a temporary buffer using their
     * own blend modes and then that temporary buffer will be composited into the
     * scene using the specified blend mode.
     *
     * A value of {@code null} is treated as pass-though this means no effect on a
     * parent such as a Group and the equivalent of SRC_OVER for a single Node.
     *
     * @defaultValue null
     */
    private javafx.beans.property.ObjectProperty&lt;BlendMode&gt; blendMode;

    public final void setBlendMode(BlendMode value) {
        blendModeProperty().set(value);
    }
    public final BlendMode getBlendMode() {
        return blendMode == null ? null : blendMode.get();
    }

    public final ObjectProperty&lt;BlendMode&gt; blendModeProperty() {
        if (blendMode == null) {
            blendMode = new StyleableObjectProperty&lt;BlendMode&gt;(null) {
                @Override public void invalidated() {
                    NodeHelper.markDirty(Node.this, DirtyBits.NODE_BLENDMODE);
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.BLEND_MODE;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;blendMode&quot;;
                }
            };
        }
        return blendMode;
    }

    public final void setClip(Node value) {
        clipProperty().set(value);
    }

    public final Node getClip() {
        return (miscProperties == null) ? DEFAULT_CLIP
                                        : miscProperties.getClip();
    }

    /**
     * Specifies a {@code Node} to use to define the the clipping shape for this
     * Node. This clipping Node is not a child of this {@code Node} in the scene
     * graph sense. Rather, it is used to define the clip for this {@code Node}.
     * &lt;p&gt;
     * For example, you can use an {@link javafx.scene.image.ImageView} Node as
     * a mask to represent the Clip. Or you could use one of the geometric shape
     * Nodes such as {@link javafx.scene.shape.Rectangle} or
     * {@link javafx.scene.shape.Circle}. Or you could use a
     * {@link javafx.scene.text.Text} node to represent the Clip.
     * &lt;p&gt;
     * See the class documentation for {@link Node} for scene graph structure
     * restrictions on setting the clip. If these restrictions are violated by
     * a change to the clip variable, the change is ignored and the
     * previous value of the clip variable is restored.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SHAPE_CLIP ConditionalFeature.SHAPE_CLIP}
     * for more information.
     * &lt;p&gt;
     * There is a known limitation of mixing Clip with a 3D Transform.
     * Clipping is essentially a 2D image operation. The result of
     * a Clip set on a {@link Group} node with 3D transformed children
     * will cause its children to be rendered in order without Z-buffering
     * applied between those children.
     *
     * @return the the clipping shape for this {@code Node}
     * @defaultValue null
     */
    public final ObjectProperty&lt;Node&gt; clipProperty() {
        return getMiscProperties().clipProperty();
    }

    public final void setCache(boolean value) {
        cacheProperty().set(value);
    }

    public final boolean isCache() {
        return (miscProperties == null) ? DEFAULT_CACHE
                                        : miscProperties.isCache();
    }

    /**
     * A performance hint to the system to indicate that this {@code Node}
     * should be cached as a bitmap. Rendering a bitmap representation of a node
     * will be faster than rendering primitives in many cases, especially in the
     * case of primitives with effects applied (such as a blur). However, it
     * also increases memory usage. This hint indicates whether that trade-off
     * (increased memory usage for increased performance) is worthwhile. Also
     * note that on some platforms such as GPU accelerated platforms there is
     * little benefit to caching Nodes as bitmaps when blurs and other effects
     * are used since they are very fast to render on the GPU.
     *
     * The {@link #cacheHintProperty} variable provides additional options for enabling
     * more aggressive bitmap caching.
     *
     * &lt;p&gt;
     * Caching may be disabled for any node that has a 3D transform on itself,
     * any of its ancestors, or any of its descendants.
     *
     * @return the hint to cache for this {@code Node}
     * @see #cacheHintProperty
     * @defaultValue false
     */
    public final BooleanProperty cacheProperty() {
        return getMiscProperties().cacheProperty();
    }

    public final void setCacheHint(CacheHint value) {
        cacheHintProperty().set(value);
    }

    public final CacheHint getCacheHint() {
        return (miscProperties == null) ? DEFAULT_CACHE_HINT
                                        : miscProperties.getCacheHint();
    }

    /**
     * Additional hint for controlling bitmap caching.
     * &lt;p&gt;
     * Under certain circumstances, such as animating nodes that are very
     * expensive to render, it is desirable to be able to perform
     * transformations on the node without having to regenerate the cached
     * bitmap.  An option in such cases is to perform the transforms on the
     * cached bitmap itself.
     * &lt;p&gt;
     * This technique can provide a dramatic improvement to animation
     * performance, though may also result in a reduction in visual quality.
     * The {@code cacheHint} variable provides a hint to the system about how
     * and when that trade-off (visual quality for animation performance) is
     * acceptable.
     * &lt;p&gt;
     * It is possible to enable the cacheHint only at times when your node is
     * animating.  In this way, expensive nodes can appear on screen with full
     * visual quality, yet still animate smoothly.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;{@code
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     }&lt;/pre&gt;
     *
     * Note that {@code cacheHint} is only a hint to the system.  Depending on
     * the details of the node or the transform, this hint may be ignored.
     *
     * &lt;p&gt;
     * If {@code Node.cache} is false, cacheHint is ignored.
     * Caching may be disabled for any node that has a 3D transform on itself,
     * any of its ancestors, or any of its descendants.
     *
     * @return the {@code CacheHint} for this {@code Node}
     * @see #cacheProperty
     * @defaultValue CacheHint.DEFAULT
     */
    public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
        return getMiscProperties().cacheHintProperty();
    }

    public final void setEffect(Effect value) {
        effectProperty().set(value);
    }

    public final Effect getEffect() {
        return (miscProperties == null) ? DEFAULT_EFFECT
                                        : miscProperties.getEffect();
    }

    /**
     * Specifies an effect to apply to this {@code Node}.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
     * for more information.
     *
     * &lt;p&gt;
     * There is a known limitation of mixing Effect with a 3D Transform. Effect is
     * essentially a 2D image operation. The result of an Effect set on
     * a {@link Group} node with 3D transformed children will cause its children
     * to be rendered in order without Z-buffering applied between those
     * children.
     *
     * @return the effect for this {@code Node}
     * @defaultValue null
     */
    public final ObjectProperty&lt;Effect&gt; effectProperty() {
        return getMiscProperties().effectProperty();
    }

    public final void setDepthTest(DepthTest value) {
        depthTestProperty().set(value);
    }

    public final DepthTest getDepthTest() {
        return (miscProperties == null) ? DEFAULT_DEPTH_TEST
                                        : miscProperties.getDepthTest();
    }

    /**
     * Indicates whether depth testing is used when rendering this node.
     * If the depthTest flag is {@code DepthTest.DISABLE}, then depth testing
     * is disabled for this node.
     * If the depthTest flag is {@code DepthTest.ENABLE}, then depth testing
     * is enabled for this node.
     * If the depthTest flag is {@code DepthTest.INHERIT}, then depth testing
     * is enabled for this node if it is enabled for the parent node or the
     * parent node is null.
     * &lt;p&gt;
     * The depthTest flag is only used when the depthBuffer flag for
     * the {@link Scene} is true (meaning that the
     * {@link Scene} has an associated depth buffer)
     * &lt;p&gt;
     * Depth test comparison is only done among nodes with depthTest enabled.
     * A node with depthTest disabled does not read, test, or write the depth buffer,
     * that is to say its Z value will not be considered for depth testing
     * with other nodes.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     * &lt;p&gt;
     * See the constructor in Scene with depthBuffer as one of its input
     * arguments.
     *
     * @return the depth test setting for this {@code Node}
     * @see javafx.scene.Scene
     * @defaultValue INHERIT
     */
    public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
        return getMiscProperties().depthTestProperty();
    }

    /**
     * Recompute the derived depth test flag. This flag is true
     * if the depthTest flag for this node is true and the
     * depth test flag for each ancestor node is true. It is false
     * otherwise. Equivalently, the derived depth flag is true
     * if the depthTest flag for this node is true and the derivedDepthTest
     * flag for its parent is true.
     */
    void computeDerivedDepthTest() {
        boolean newDDT;
        if (getDepthTest() == DepthTest.INHERIT) {
            if (getParent() != null) {
                newDDT = getParent().isDerivedDepthTest();
            } else {
                newDDT = true;
            }
        } else if (getDepthTest() == DepthTest.ENABLE) {
            newDDT = true;
        } else {
            newDDT = false;
        }

        if (isDerivedDepthTest() != newDDT) {
            NodeHelper.markDirty(this, DirtyBits.NODE_DEPTH_TEST);
            setDerivedDepthTest(newDDT);
        }
    }

    // This is the derived depthTest value to pass to PG level
    private boolean derivedDepthTest = true;

    void setDerivedDepthTest(boolean value) {
        derivedDepthTest = value;
    }

    boolean isDerivedDepthTest() {
        return derivedDepthTest;
    }

    public final void setDisable(boolean value) {
        disableProperty().set(value);
    }

    public final boolean isDisable() {
        return (miscProperties == null) ? DEFAULT_DISABLE
                                        : miscProperties.isDisable();
    }

    /**
     * Defines the individual disabled state of this {@code Node}. Setting
     * {@code disable} to true will cause this {@code Node} and any subnodes to
     * become disabled. This property should be used only to set the disabled
     * state of a {@code Node}.  For querying the disabled state of a
     * {@code Node}, the {@link #disabledProperty disabled} property should instead be used,
     * since it is possible that a {@code Node} was disabled as a result of an
     * ancestor being disabled even if the individual {@code disable} state on
     * this {@code Node} is {@code false}.
     *
     * @return the disabled state for this {@code Node}
     * @defaultValue false
     */
    public final BooleanProperty disableProperty() {
        return getMiscProperties().disableProperty();
    }


//    /**
//     * TODO document - null by default, could be non-null in subclasses (e.g. Control)
//     */
//    public final ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMapProperty() {
//        if (inputMap == null) {
//            inputMap = new SimpleObjectProperty&lt;InputMap&lt;?&gt;&gt;(this, &quot;inputMap&quot;) {
//                private InputMap&lt;?&gt; currentMap = get();
//                @Override protected void invalidated() {
//                    if (currentMap != null) {
//                        currentMap.dispose();
//                    }
//                    currentMap = get();
//                }
//            };
//        }
//        return inputMap;
//    }
//    public final void setInputMap(InputMap&lt;?&gt; value) { inputMapProperty().set(value); }
//    public final InputMap&lt;?&gt; getInputMap() { return inputMapProperty().getValue(); }
//    private ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMap;


    /**************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/
    /**
     * Defines how the picking computation is done for this node when
     * triggered by a {@code MouseEvent} or a {@code contains} function call.
     *
     * If {@code pickOnBounds} is {@code true}, then picking is computed by
     * intersecting with the bounds of this node, else picking is computed
     * by intersecting with the geometric shape of this node.
     *
     * The default value of this property is {@code false} unless
     * overridden by a subclass. The default value is {@code true}
     * for {@link javafx.scene.layout.Region}.
     *
     * @defaultValue false; true for {@code Region}
     */
    private BooleanProperty pickOnBounds;

    public final void setPickOnBounds(boolean value) {
        pickOnBoundsProperty().set(value);
    }

    public final boolean isPickOnBounds() {
        return pickOnBounds == null ? false : pickOnBounds.get();
    }

    public final BooleanProperty pickOnBoundsProperty() {
        if (pickOnBounds == null) {
            pickOnBounds = new SimpleBooleanProperty(this, &quot;pickOnBounds&quot;);
        }
        return pickOnBounds;
    }

    /**
     * Indicates whether or not this {@code Node} is disabled.  A {@code Node}
     * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
     * itself or one of its ancestors in the scene graph.
     * &lt;p&gt;
     * A disabled {@code Node} should render itself differently to indicate its
     * disabled state to the user.
     * Such disabled rendering is dependent on the implementation of the
     * {@code Node}. The shape classes contained in {@code javafx.scene.shape}
     * do not implement such rendering by default, therefore applications using
     * shapes for handling input must implement appropriate disabled rendering
     * themselves. The user-interface controls defined in
     * {@code javafx.scene.control} will implement disabled-sensitive rendering,
     * however.
     * &lt;p&gt;
     * A disabled {@code Node} does not receive mouse or key events.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper disabled;

    protected final void setDisabled(boolean value) {
        disabledPropertyImpl().set(value);
    }

    public final boolean isDisabled() {
        return disabled == null ? false : disabled.get();
    }

    public final ReadOnlyBooleanProperty disabledProperty() {
        return disabledPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper disabledPropertyImpl() {
        if (disabled == null) {
            disabled = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, get());
                    updateCanReceiveFocus();
                    focusSetDirty(getScene());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;disabled&quot;;
                }
            };
        }
        return disabled;
    }

    private void updateDisabled() {
        boolean isDisabled = isDisable();
        if (!isDisabled) {
            isDisabled = getParent() != null ? getParent().isDisabled() :
                    getSubScene() != null &amp;&amp; getSubScene().isDisabled();
        }
        setDisabled(isDisabled);
        if (this instanceof SubScene) {
            ((SubScene)this).getRoot().setDisabled(isDisabled);
        }
    }

    /**
     * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.
     * If this node is a {@code Parent}, then this function will traverse down
     * into the branch until it finds a match. If more than one sub-node matches the
     * specified selector, this function returns the first of them.
     * &lt;p&gt;
     *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
     *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param selector The css selector of the node to find
     * @return The first node, starting from this {@code Node}, which matches
     *         the CSS {@code selector}, null if none is found.
     */
    public Node lookup(String selector) {
        if (selector == null) return null;
        Selector s = Selector.createSelector(selector);
        return s != null &amp;&amp; s.applies(this) ? this : null;
    }

    /**
     * Finds all {@code Node}s, including this one and any children, which match
     * the given CSS selector. If no matches are found, an empty unmodifiable set is
     * returned. The set is explicitly unordered.
     *
     * @param selector The css selector of the nodes to find
     * @return All nodes, starting from and including this {@code Node}, which match
     *         the CSS {@code selector}. The returned set is always unordered and
     *         unmodifiable, and never null.
     */
    public Set&lt;Node&gt; lookupAll(String selector) {
        final Selector s = Selector.createSelector(selector);
        final Set&lt;Node&gt; empty = Collections.emptySet();
        if (s == null) return empty;
        List&lt;Node&gt; results = lookupAll(s, null);
        return results == null ? empty : new UnmodifiableListSet&lt;Node&gt;(results);
    }

    /**
     * Used by Node and Parent for traversing the tree and adding all nodes which
     * match the given selector.
     *
     * @param selector The Selector. This will never be null.
     * @param results The results. This will never be null.
     */
    List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
        if (selector.applies(this)) {
            // Lazily create the set to reduce some trash.
            if (results == null) {
                results = new LinkedList&lt;Node&gt;();
            }
            results.add(this);
        }
        return results;
    }

    /**
     * Moves this {@code Node} to the back of its sibling nodes in terms of
     * z-order.  This is accomplished by moving this {@code Node} to the
     * first position in its parent's {@code content} ObservableList.
     * This function has no effect if this {@code Node} is not part of a group.
     */
    public void toBack() {
        if (getParent() != null) {
            getParent().toBack(this);
        }
    }

    /**
     * Moves this {@code Node} to the front of its sibling nodes in terms of
     * z-order.  This is accomplished by moving this {@code Node} to the
     * last position in its parent's {@code content} ObservableList.
     * This function has no effect if this {@code Node} is not part of a group.
     */
    public void toFront() {
        if (getParent() != null) {
            getParent().toFront(this);
        }
    }

    // TODO: need to verify whether this is OK to do starting from a node in
    // the scene graph other than the root.
    private void doCSSPass() {
        if (this.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS

            // Don't clear the dirty bit in case it will cause problems
            // with a full CSS pass on the scene.
            // TODO: is this the right thing to do?
            // this.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);

            this.processCSS();
        }
    }

    /**
     * Recursive function for synchronizing a node and all descendents
     */
    private static void syncAll(Node node) {
        node.syncPeer();
        if (node instanceof Parent) {
            Parent p = (Parent) node;
            final int childrenCount = p.getChildren().size();

            for (int i = 0; i &lt; childrenCount; i++) {
                Node n = p.getChildren().get(i);
                if (n != null) {
                    syncAll(n);
                }
            }
        }
        if (node.getClip() != null) {
            syncAll(node.getClip());
        }
    }

    private void doLayoutPass() {
        if (this instanceof Parent) {
            // TODO: As an optimization we only need to layout those dirty
            // roots that are descendants of this node
            Parent p = (Parent)this;
            for (int i = 0; i &lt; 3; i++) {
                p.layout();
            }
        }
    }

    private void doCSSLayoutSyncForSnapshot() {
        doCSSPass();
        doLayoutPass();
        updateBounds();
        Scene.setAllowPGAccess(true);
        syncAll(this);
        Scene.setAllowPGAccess(false);
    }

    private WritableImage doSnapshot(SnapshotParameters params, WritableImage img) {
        if (getScene() != null) {
            getScene().doCSSLayoutSyncForSnapshot(this);
        } else {
            doCSSLayoutSyncForSnapshot();
        }

        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
        if (params.getTransform() != null) {
            Affine3D tempTx = new Affine3D();
            TransformHelper.apply(params.getTransform(), tempTx);
            transform = tempTx;
        }
        double x;
        double y;
        double w;
        double h;
        Rectangle2D viewport = params.getViewport();
        if (viewport != null) {
            // Use the specified viewport
            x = viewport.getMinX();
            y = viewport.getMinY();
            w = viewport.getWidth();
            h = viewport.getHeight();
        } else {
            // Get the bounds in parent of this node, transformed by the
            // specified transform.
            BaseBounds tempBounds = TempState.getInstance().bounds;
            tempBounds = getTransformedBounds(tempBounds, transform);
            x = tempBounds.getMinX();
            y = tempBounds.getMinY();
            w = tempBounds.getWidth();
            h = tempBounds.getHeight();
        }
        WritableImage result = Scene.doSnapshot(getScene(), x, y, w, h,
                this, transform, params.isDepthBufferInternal(),
                params.getFill(), params.getEffectiveCamera(), img);

        return result;
    }

    /**
     * Takes a snapshot of this node and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the node, and any of its
     * children, prior to rendering it.
     * The entire destination image is cleared to the fill {@code Paint}
     * specified by the SnapshotParameters. This node is then rendered to
     * the image.
     * If the viewport specified by the SnapshotParameters is null, the
     * upper-left pixel of the {@code boundsInParent} of this
     * node, after first applying the transform specified by the
     * SnapshotParameters,
     * is mapped to the upper-left pixel (0,0) in the image.
     * If a non-null viewport is specified,
     * the upper-left pixel of the viewport is mapped to upper-left pixel
     * (0,0) in the image.
     * In both cases, this mapping to (0,0) of the image is done with an integer
     * translation. The portion of the node that is outside of the rendered
     * image will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: In order for CSS and layout to function correctly, the node
     * must be part of a Scene (the Scene may be attached to a Stage, but need
     * not be).
     * &lt;/p&gt;
     *
     * @param params the snapshot parameters containing attributes that
     * will control the rendering. If the SnapshotParameters object is null,
     * then the Scene's attributes will be used if this node is part of a scene,
     * or default attributes will be used if this node is not part of a scene.
     *
     * @param image the writable image that will be used to hold the rendered node.
     * It may be null in which case a new WritableImage will be constructed.
     * The new image is constructed using integer width and
     * height values that are derived either from the transformed bounds of this
     * Node or from the size of the viewport as specified in the
     * SnapShotParameters. These integer values are chosen such that the image
     * will wholly contain the bounds of this Node or the specified viewport.
     * If the image is non-null, the node will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the bounds or
     * viewport.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(SnapshotParameters params, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        if (params == null) {
            params = new SnapshotParameters();
            Scene s = getScene();
            if (s != null) {
                params.setCamera(s.getEffectiveCamera());
                params.setDepthBuffer(s.isDepthBufferInternal());
                params.setFill(s.getFill());
            }
        }

        return doSnapshot(params, image);
    }

    /**
     * Takes a snapshot of this node at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the node, and any of its
     * children, prior to rendering it.
     * The entire destination image is cleared to the fill {@code Paint}
     * specified by the SnapshotParameters. This node is then rendered to
     * the image.
     * If the viewport specified by the SnapshotParameters is null, the
     * upper-left pixel of the {@code boundsInParent} of this
     * node, after first applying the transform specified by the
     * SnapshotParameters,
     * is mapped to the upper-left pixel (0,0) in the image.
     * If a non-null viewport is specified,
     * the upper-left pixel of the viewport is mapped to upper-left pixel
     * (0,0) in the image.
     * In both cases, this mapping to (0,0) of the image is done with an integer
     * translation. The portion of the node that is outside of the rendered
     * image will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the node is rendered.
     * If any such events modify the node, or any of its children, that
     * modification will be reflected in the rendered image (just like it
     * will also be reflected in the frame rendered to the Stage, if this node
     * is part of a live scene graph).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a node that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: In order for CSS and layout to function correctly, the node
     * must be part of a Scene (the Scene may be attached to a Stage, but need
     * not be).
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image, the source node
     * that was rendered, and a copy of the SnapshotParameters.
     * The callback parameter must not be null.
     *
     * @param params the snapshot parameters containing attributes that
     * will control the rendering. If the SnapshotParameters object is null,
     * then the Scene's attributes will be used if this node is part of a scene,
     * or default attributes will be used if this node is not part of a scene.
     *
     * @param image the writable image that will be used to hold the rendered node.
     * It may be null in which case a new WritableImage will be constructed.
     * The new image is constructed using integer width and
     * height values that are derived either from the transformed bounds of this
     * Node or from the size of the viewport as specified in the
     * SnapShotParameters. These integer values are chosen such that the image
     * will wholly contain the bounds of this Node or the specified viewport.
     * If the image is non-null, the node will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the bounds or
     * viewport.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback,
            SnapshotParameters params, WritableImage image) {

        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        if (params == null) {
            params = new SnapshotParameters();
            Scene s = getScene();
            if (s != null) {
                params.setCamera(s.getEffectiveCamera());
                params.setDepthBuffer(s.isDepthBufferInternal());
                params.setFill(s.getFill());
            }
        } else {
            params = params.copy();
        }

        final SnapshotParameters theParams = params;
        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theParams, theImage);
            SnapshotResult result = new SnapshotResult(img, Node.this, theParams);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };

//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        Scene.addSnapshotRunnable(snapshotRunnable);
    }

    /* ************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/

    public final void setOnDragEntered(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragEntered();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Node}.
     * @return the event handler that is called when drag gesture enters this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragEnteredProperty() {
        return getEventHandlerProperties().onDragEnteredProperty();
    }

    public final void setOnDragExited(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragExited();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Node}.
     * @return the event handler that is called when drag gesture exits this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragExitedProperty() {
        return getEventHandlerProperties().onDragExitedProperty();
    }

    public final void setOnDragOver(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragOver();
    }

    /**
     * Defines a function to be called when drag gesture progresses within
     * this {@code Node}.
     * @return the event handler that is called when drag gesture progresses
     * within this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragOverProperty() {
        return getEventHandlerProperties().onDragOverProperty();
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    public final void setOnDragTransferModeChanged(
//            EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return (eventHandlerProperties == null)
//                ? null : eventHandlerProperties.getOnDragTransferModeChanged();
//    }
//
//    /**
//     * Defines a function to be called this {@code Node} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
//            onDragTransferModeChangedProperty() {
//        return getEventHandlerProperties().onDragTransferModeChangedProperty();
//    }

    public final void setOnDragDropped(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDropped();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Node} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the event handler that is called when the mouse button is
     * released on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragDroppedProperty() {
        return getEventHandlerProperties().onDragDroppedProperty();
    }

    public final void setOnDragDone(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDone();
    }

    /**
     * Defines a function to be called when this {@code Node} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * @return the event handler that is called when this {@code Node} is a drag
     * and drop gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragDoneProperty() {
        return getEventHandlerProperties().onDragDoneProperty();
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Node}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Node}'s data on the
     * {@link Dragboard} also identifies this {@code Node} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Node}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling or
     * this node is not in scene).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        if (getScene() != null) {
            return getScene().startDragAndDrop(this, transferModes);
        }

        throw new IllegalStateException(&quot;Cannot start drag and drop on node &quot;
                + &quot;that is not in scene&quot;);
    }

    /**
     * Starts a full press-drag-release gesture with this node as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling or this node is not in scene).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        if (getScene() != null) {
            getScene().startFullDrag(this);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag on node &quot;
                + &quot;that is not in scene&quot;);
    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

    /**
     * If this Node is being used as the clip of another Node, that other node
     * is referred to as the clipParent. If the boundsInParent of this Node
     * changes, it must update the clipParent's bounds as well.
     */
    private Node clipParent;
    // Use a getter function instead of giving clipParent package access,
    // so that clipParent doesn't get turned into a Location.
    final Node getClipParent() {
        return clipParent;
    }

    /**
     * Determines whether this node is connected anywhere in the scene graph.
     */
    boolean isConnected() {
        // don't need to check scene, because if scene is non-null
        // parent must also be non-null
        return getParent() != null || clipParent != null;
    }

    /**
     * Tests whether creating a parent-child relationship between these
     * nodes would cause a cycle. The parent relationship includes not only
     * the &quot;real&quot; parent (child of Group) but also the clipParent.
     */
    boolean wouldCreateCycle(Node parent, Node child) {
        if (child != null &amp;&amp; child.getClip() == null &amp;&amp; (!(child instanceof Parent))) {
            return false;
    }

        Node n = parent;
        while (n != child) {
            if (n.getParent() != null) {
                n = n.getParent();
            } else if (n.getSubScene() != null) {
                n = n.getSubScene();
            } else if (n.clipParent != null) {
                n = n.clipParent;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * The peer node created by the graphics Toolkit/Pipeline implementation
     */
    private NGNode peer;

    @SuppressWarnings(&quot;CallToPrintStackTrace&quot;)
    &lt;P extends NGNode&gt; P getPeer() {
        if (Utils.assertionEnabled()) {
            // Assertion checking code
            if (getScene() != null &amp;&amp; !Scene.isPGAccessAllowed()) {
                java.lang.System.err.println();
                java.lang.System.err.println(&quot;*** unexpected PG access&quot;);
                java.lang.Thread.dumpStack();
            }
        }

        if (peer == null) {
            //if (PerformanceTracker.isLoggingEnabled()) {
            //    PerformanceTracker.logEvent(&quot;Creating NGNode for [{this}, id=\&quot;{id}\&quot;]&quot;);
            //}
            peer = NodeHelper.createPeer(this);
            //if (PerformanceTracker.isLoggingEnabled()) {
            //    PerformanceTracker.logEvent(&quot;NGNode created&quot;);
            //}
        }
        return (P) peer;
    }

    /***************************************************************************
     *                                                                         *
     *                              Initialization                             *
     *                                                                         *
     *  To Note limit the number of bounds computations and improve startup    *
     *  performance.                                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new instance of Node.
     */
    protected Node() {
        //if (PerformanceTracker.isLoggingEnabled()) {
        //    PerformanceTracker.logEvent(&quot;Node.init for [{this}, id=\&quot;{id}\&quot;]&quot;);
        //}
        setDirty();
        updateTreeVisible(false);
        //if (PerformanceTracker.isLoggingEnabled()) {
        //    PerformanceTracker.logEvent(&quot;Node.postinit &quot; +
        //                                &quot;for [{this}, id=\&quot;{id}\&quot;] finished&quot;);
        //}
    }

    /***************************************************************************
     *                                                                         *
     * Layout related APIs.                                                    *
     *                                                                         *
     **************************************************************************/
    /**
     * Defines whether or not this node's layout will be managed by it's parent.
     * If the node is managed, it's parent will factor the node's geometry
     * into its own preferred size and {@link #layoutBoundsProperty layoutBounds}
     * calculations and will lay it
     * out during the scene's layout pass.  If a managed node's layoutBounds
     * changes, it will automatically trigger relayout up the scene-graph
     * to the nearest layout root (which is typically the scene's root node).
     * &lt;p&gt;
     * If the node is unmanaged, its parent will ignore the child in both preferred
     * size computations and layout.   Changes in layoutBounds will not trigger
     * relayout above it.   If an unmanaged node is of type {@link javafx.scene.Parent Parent},
     * it will act as a &quot;layout root&quot;, meaning that calls to {@link Parent#requestLayout()}
     * beneath it will cause only the branch rooted by the node to be relayed out,
     * thereby isolating layout changes to that root and below.  It's the application's
     * responsibility to set the size and position of an unmanaged node.
     * &lt;p&gt;
     * By default all nodes are managed.
     * &lt;/p&gt;
     *
     * @see #isResizable()
     * @see #layoutBoundsProperty()
     * @see Parent#requestLayout()
     *
     */
    private BooleanProperty managed;

    public final void setManaged(boolean value) {
        managedProperty().set(value);
    }

    public final boolean isManaged() {
        return managed == null ? true : managed.get();
    }

    public final BooleanProperty managedProperty() {
        if (managed == null) {
            managed = new BooleanPropertyBase(true) {

                @Override
                protected void invalidated() {
                    final Parent parent = getParent();
                    if (parent != null) {
                        parent.managedChildChanged();
                    }
                    notifyManagedChanged();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;managed&quot;;
                }

            };
        }
        return managed;
    }

    /**
     * Called whenever the &quot;managed&quot; flag has changed. This is only
     * used by Parent as an optimization to keep track of whether a
     * Parent node is a layout root or not.
     */
    void notifyManagedChanged() { }

    /**
     * Defines the x coordinate of the translation that is added to this {@code Node}'s
     * transform for the purpose of layout. The value should be computed as the
     * offset required to adjust the position of the node from its current
     * {@link #layoutBoundsProperty() layoutBounds minX} position (which might not be 0) to the desired location.
     *
     * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalX}
     * &lt;pre&gt;{@code
     *     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Failure to subtract {@code layoutBounds minX} may result in misplacement
     * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
     * correct computation and should generally be used over setting layoutX directly.
     * &lt;p&gt;
     * The node's final translation will be computed as {@code layoutX} + {@link #translateXProperty translateX},
     * where {@code layoutX} establishes the node's stable position
     * and {@code translateX} optionally makes dynamic adjustments to that
     * position.
     * &lt;p&gt;
     * If the node is managed and has a {@link javafx.scene.layout.Region}
     * as its parent, then the layout region will set {@code layoutX} according to its
     * own layout policy.   If the node is unmanaged or parented by a {@link Group},
     * then the application may set {@code layoutX} directly to position it.
     *
     * @see #relocate(double, double)
     * @see #layoutBoundsProperty()
     *
     */
    private DoubleProperty layoutX;

    public final void setLayoutX(double value) {
        layoutXProperty().set(value);
    }

    public final double getLayoutX() {
        return layoutX == null ? 0.0 : layoutX.get();
    }

    public final DoubleProperty layoutXProperty() {
        if (layoutX == null) {
            layoutX = new DoublePropertyBase(0.0) {

                @Override
                protected void invalidated() {
                    NodeHelper.transformsChanged(Node.this);
                    final Parent p = getParent();

                    // Propagate layout if this change isn't triggered by its parent
                    if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
                        if (isManaged()) {
                            // Force its parent to fix the layout since it is a managed child.
                            p.requestLayout(true);
                        } else {
                            // Parent size changed, parent's parent might need to re-layout
                            p.clearSizeCache();
                            p.requestParentLayout();
                        }
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;layoutX&quot;;
                }
            };
        }
        return layoutX;
    }

    /**
     * Defines the y coordinate of the translation that is added to this {@code Node}'s
     * transform for the purpose of layout. The value should be computed as the
     * offset required to adjust the position of the node from its current
     * {@link #layoutBoundsProperty() layoutBounds minY} position (which might not be 0) to the desired location.
     *
     * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalY}
     * &lt;pre&gt;{@code
     *     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Failure to subtract {@code layoutBounds minY} may result in misplacement
     * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
     * correct computation and should generally be used over setting layoutY directly.
     * &lt;p&gt;
     * The node's final translation will be computed as {@code layoutY} + {@link #translateYProperty translateY},
     * where {@code layoutY} establishes the node's stable position
     * and {@code translateY} optionally makes dynamic adjustments to that
     * position.
     * &lt;p&gt;
     * If the node is managed and has a {@link javafx.scene.layout.Region}
     * as its parent, then the region will set {@code layoutY} according to its
     * own layout policy.   If the node is unmanaged or parented by a {@link Group},
     * then the application may set {@code layoutY} directly to position it.
     *
     * @see #relocate(double, double)
     * @see #layoutBoundsProperty()
     */
    private DoubleProperty layoutY;

    public final void setLayoutY(double value) {
        layoutYProperty().set(value);
    }

    public final double getLayoutY() {
        return layoutY == null ? 0.0 : layoutY.get();
    }

    public final DoubleProperty layoutYProperty() {
        if (layoutY == null) {
            layoutY = new DoublePropertyBase(0.0) {

                @Override
                protected void invalidated() {
                    NodeHelper.transformsChanged(Node.this);
                    final Parent p = getParent();

                    // Propagate layout if this change isn't triggered by its parent
                    if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
                        if (isManaged()) {
                            // Force its parent to fix the layout since it is a managed child.
                            p.requestLayout(true);
                        } else {
                            // Parent size changed, parent's parent might need to re-layout
                            p.clearSizeCache();
                            p.requestParentLayout();
                        }
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;layoutY&quot;;
                }

            };
        }
        return layoutY;
    }

    /**
     * Sets the node's layoutX and layoutY translation properties in order to
     * relocate this node to the x,y location in the parent.
     * &lt;p&gt;
     * This method does not alter translateX or translateY, which if also set
     * will be added to layoutX and layoutY, adjusting the final location by
     * corresponding amounts.
     *
     * @param x the target x coordinate location
     * @param y the target y coordinate location
     */
    public void relocate(double x, double y) {
        setLayoutX(x - getLayoutBounds().getMinX());
        setLayoutY(y - getLayoutBounds().getMinY());

        PlatformLogger logger = Logging.getLayoutLogger();
        if (logger.isLoggable(Level.FINER)) {
            logger.finer(this.toString()+&quot; moved to (&quot;+x+&quot;,&quot;+y+&quot;)&quot;);
        }
    }

    /**
     * Indicates whether this node is a type which can be resized by its parent.
     * If this method returns true, then the parent will resize the node (ideally
     * within its size range) by calling node.resize(width,height) during the
     * layout pass.  All Regions, Controls, and WebView are resizable classes
     * which depend on their parents resizing them during layout once all sizing
     * and CSS styling information has been applied.
     * &lt;p&gt;
     * If this method returns false, then the parent cannot resize it during
     * layout (resize() is a no-op) and it should return its layoutBounds for
     * minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
     * resizable and hence depend on the application to establish their sizing
     * by setting appropriate properties (e.g.  width/height for Rectangle,
     * text on Text, and so on).  Non-resizable nodes may still be relocated
     * during layout.
     *
     * @see #getContentBias()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     * @see #resize(double, double)
     * @see #getLayoutBounds()
     *
     * @return whether or not this node type can be resized by its parent during layout
     */
    public boolean isResizable() {
        return false;
    }

    /**
     * Returns the orientation of a node's resizing bias for layout purposes.
     * If the node type has no bias, returns null.  If the node is resizable and
     * it's height depends on its width, returns HORIZONTAL, else if its width
     * depends on its height, returns VERTICAL.
     * &lt;p&gt;
     * Resizable subclasses should override this method to return an
     * appropriate value.
     *
     * @see #isResizable()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     *
     * @return orientation of width/height dependency or null if there is none
     */
    public Orientation getContentBias() {
        return null;
    }

    /**
     * Returns the node's minimum width for use in layout calculations.
     * If the node is resizable, its parent should not resize its width any
     * smaller than this value.  If the node is not resizable, returns its
     * layoutBounds width.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the minimum width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #maxWidth(double)} is lower than this number,
     * {@code minWidth} takes precedence. This means the Node should never be resized below {@code minWidth}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param height the height that should be used if minimum width depends on it
     * @return the minimum width that the node should be resized to during layout.
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double minWidth(double height) {
        return prefWidth(height);
    }

    /**
     * Returns the node's minimum height for use in layout calculations.
     * If the node is resizable, its parent should not resize its height any
     * smaller than this value.  If the node is not resizable, returns its
     * layoutBounds height.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the minimum height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the width
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the width parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #maxHeight(double)} is lower than this number,
     * {@code minHeight} takes precedence. This means the Node should never be resized below {@code minHeight}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param width the width that should be used if minimum height depends on it
     * @return the minimum height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double minHeight(double width) {
        return prefHeight(width);
    }

    /**
     * Returns the node's preferred width for use in layout calculations.
     * If the node is resizable, its parent should treat this value as the
     * node's ideal width within its range.  If the node is not resizable,
     * just returns its layoutBounds width, which should be treated as the rigid
     * width of the node.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the preferred width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     *
     * @param height the height that should be used if preferred width depends on it
     * @return the preferred width that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double prefWidth(double height) {
        final double result = getLayoutBounds().getWidth();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Returns the node's preferred height for use in layout calculations.
     * If the node is resizable, its parent should treat this value as the
     * node's ideal height within its range.  If the node is not resizable,
     * just returns its layoutBounds height, which should be treated as the rigid
     * height of the node.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the preferred height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     *
     * @see #getContentBias()
     * @see #autosize()
     *
     * @param width the width that should be used if preferred height depends on it
     * @return the preferred height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double prefHeight(double width) {
        final double result = getLayoutBounds().getHeight();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Returns the node's maximum width for use in layout calculations.
     * If the node is resizable, its parent should not resize its width any
     * larger than this value.  A value of Double.MAX_VALUE indicates the
     * parent may expand the node's width beyond its preferred without limits.
     * &lt;p&gt;
     * If the node is not resizable, returns its layoutBounds width.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the maximum width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #minWidth(double)} is greater, it should take precedence
     * over the {@code maxWidth}. This means the Node should never be resized below {@code minWidth}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param height the height that should be used if maximum width depends on it
     * @return the maximum width that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double maxWidth(double height) {
        return prefWidth(height);
    }

    /**
     * Returns the node's maximum height for use in layout calculations.
     * If the node is resizable, its parent should not resize its height any
     * larger than this value.  A value of Double.MAX_VALUE indicates the
     * parent may expand the node's height beyond its preferred without limits.
     * &lt;p&gt;
     * If the node is not resizable, returns its layoutBounds height.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the maximum height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the width
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the width parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #minHeight(double)} is greater, it should take precedence
     * over the {@code maxHeight}.  This means the Node should never be resized below {@code minHeight}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param width the width that should be used if maximum height depends on it
     * @return the maximum height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double maxHeight(double width) {
        return prefHeight(width);
    }

    /**
     * If the node is resizable, will set its layout bounds to the specified
     * width and height.   If the node is not resizable, this method is a no-op.
     * &lt;p&gt;
     * This method should generally only be called by parent nodes from their
     * layoutChildren() methods.   All Parent classes will automatically resize
     * resizable children, so resizing done directly by the application will be
     * overridden by the node's parent, unless the child is unmanaged.
     * &lt;p&gt;
     * Parents are responsible for ensuring the width and height values fall
     * within the resizable node's preferred range.  The autosize() method may
     * be used if the parent just needs to resize the node to its preferred size.
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     * @see #getLayoutBounds()
     *
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     */
    public void resize(double width, double height) {
    }

    /**
     * If the node is resizable, will set its layout bounds to its current preferred
     * width and height. If the node is not resizable, this method is a no-op.
     * &lt;p&gt;
     * This method automatically queries the node's content-bias and if it's
     * horizontal, will pass in the node's preferred width to get the preferred
     * height; if vertical, will pass in the node's preferred height to get the width,
     * and if null, will compute the preferred width/height independently.
     * &lt;/p&gt;
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     */
    public final void autosize() {
        if (isResizable()) {
            Orientation contentBias = getContentBias();
            double w, h;
            if (contentBias == null) {
                w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
                h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
            } else if (contentBias == Orientation.HORIZONTAL) {
                w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
                h = boundedSize(prefHeight(w), minHeight(w), maxHeight(w));
            } else { // bias == VERTICAL
                h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
                w = boundedSize(prefWidth(h), minWidth(h), maxWidth(h));
            }
            resize(w,h);
        }
    }

    double boundedSize(double value, double min, double max) {
        // if max &lt; value, return max
        // if min &gt; value, return min
        // if min &gt; max, return min
        return Math.min(Math.max(value, min), Math.max(min,max));
    }

    /**
     * If the node is resizable, will set its layout bounds to the specified
     * width and height.   If the node is not resizable, the resize step is skipped.
     * &lt;p&gt;
     * Once the node has been resized (if resizable) then sets the node's layoutX
     * and layoutY translation properties in order to relocate it to x,y in the
     * parent's coordinate space.
     * &lt;p&gt;
     * This method should generally only be called by parent nodes from their
     * layoutChildren() methods.   All Parent classes will automatically resize
     * resizable children, so resizing done directly by the application will be
     * overridden by the node's parent, unless the child is unmanaged.
     * &lt;p&gt;
     * Parents are responsible for ensuring the width and height values fall
     * within the resizable node's preferred range.  The autosize() and relocate()
     * methods may be used if the parent just needs to resize the node to its
     * preferred size and reposition it.
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     *
     * @param x the target x coordinate location
     * @param y the target y coordinate location
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     *
     */
    public void resizeRelocate(double x, double y, double width, double height) {
        resize(width, height);
        relocate(x,y);
    }

    /**
     * This is a special value that might be returned by {@link #getBaselineOffset()}.
     * This means that the Parent (layout Pane) of this Node should use the height of this Node as a baseline.
     */
    public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;

    /**
     * The 'alphabetic' (or 'roman') baseline offset from the node's layoutBounds.minY location
     * that should be used when this node is being vertically aligned by baseline with
     * other nodes.  By default this returns {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} for resizable Nodes
     * and layoutBounds height for non-resizable.  Subclasses
     * which contain text should override this method to return their actual text baseline offset.
     *
     * @return offset of text baseline from layoutBounds.minY for non-resizable Nodes or {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} otherwise
     */
    public double getBaselineOffset() {
        if (isResizable()) {
            return BASELINE_OFFSET_SAME_AS_HEIGHT;
        } else {
            return getLayoutBounds().getHeight();
        }
    }

    /**
     * Returns the area of this {@code Node} projected onto the
     * physical screen in pixel units.
     * @return the area of this {@code Node} projected onto the physical screen
     * @since JavaFX 8.0
     */
    public double computeAreaInScreen() {
        return doComputeAreaInScreen();
    }

    /*
     * Help application or utility to implement LOD support by returning the
     * projected area of a Node in pixel unit. The projected area is not clipped.
     *
     * For perspective camera, this method first exams node's bounds against
     * camera's clipping plane to cut off those out of viewing frustrum. After
     * computing areaInScreen, it applies a tight viewing frustrum check using
     * canonical view volume.
     *
     * The result of areaInScreen comes from the product of
     * (projViewTx x localToSceneTransform x localBounds).
     *
     * Returns 0 for those fall outside viewing frustrum.
     */
    private double doComputeAreaInScreen() {
        Scene tmpScene = getScene();
        if (tmpScene != null) {
            Bounds bounds = getBoundsInLocal();
            Camera camera = tmpScene.getEffectiveCamera();
            boolean isPerspective = camera instanceof PerspectiveCamera ? true : false;
            Transform localToSceneTx = getLocalToSceneTransform();
            Affine3D tempTx = TempState.getInstance().tempTx;
            BaseBounds localBounds = new BoxBounds((float) bounds.getMinX(),
                                                   (float) bounds.getMinY(),
                                                   (float) bounds.getMinZ(),
                                                   (float) bounds.getMaxX(),
                                                   (float) bounds.getMaxY(),
                                                   (float) bounds.getMaxZ());

            // NOTE: Viewing frustrum check on camera's clipping plane is now only
            // for perspective camera.
            // TODO: Need to hook up parallel camera's nearClip and farClip.
            if (isPerspective) {
                Transform cameraL2STx = camera.getLocalToSceneTransform();

                // If camera transform only contains translate, compare in scene
                // coordinate. Otherwise, compare in camera coordinate.
                if (cameraL2STx.getMxx() == 1.0
                        &amp;&amp; cameraL2STx.getMxy() == 0.0
                        &amp;&amp; cameraL2STx.getMxz() == 0.0
                        &amp;&amp; cameraL2STx.getMyx() == 0.0
                        &amp;&amp; cameraL2STx.getMyy() == 1.0
                        &amp;&amp; cameraL2STx.getMyz() == 0.0
                        &amp;&amp; cameraL2STx.getMzx() == 0.0
                        &amp;&amp; cameraL2STx.getMzy() == 0.0
                        &amp;&amp; cameraL2STx.getMzz() == 1.0) {

                    double minZ, maxZ;

                    // If node transform only contains translate, only convert
                    // minZ and maxZ to scene coordinate. Otherwise, convert
                    // node bounds to scene coordinate.
                    if (localToSceneTx.getMxx() == 1.0
                            &amp;&amp; localToSceneTx.getMxy() == 0.0
                            &amp;&amp; localToSceneTx.getMxz() == 0.0
                            &amp;&amp; localToSceneTx.getMyx() == 0.0
                            &amp;&amp; localToSceneTx.getMyy() == 1.0
                            &amp;&amp; localToSceneTx.getMyz() == 0.0
                            &amp;&amp; localToSceneTx.getMzx() == 0.0
                            &amp;&amp; localToSceneTx.getMzy() == 0.0
                            &amp;&amp; localToSceneTx.getMzz() == 1.0) {

                        Vec3d tempV3D = TempState.getInstance().vec3d;
                        tempV3D.set(0, 0, bounds.getMinZ());
                        localToScene(tempV3D);
                        minZ = tempV3D.z;

                        tempV3D.set(0, 0, bounds.getMaxZ());
                        localToScene(tempV3D);
                        maxZ = tempV3D.z;
                    } else {
                        Bounds nodeInSceneBounds = localToScene(bounds);
                        minZ = nodeInSceneBounds.getMinZ();
                        maxZ = nodeInSceneBounds.getMaxZ();
                    }

                    if (minZ &gt; camera.getFarClipInScene()
                            || maxZ &lt; camera.getNearClipInScene()) {
                        return 0;
                    }

                } else {
                    BaseBounds nodeInCameraBounds = new BoxBounds();

                    // We need to set tempTx to identity since it is a recycled transform.
                    // This is because TransformHelper.apply() is a matrix concatenation operation.
                    tempTx.setToIdentity();
                    TransformHelper.apply(localToSceneTx, tempTx);

                    // Convert node from local coordinate to camera coordinate
                    tempTx.preConcatenate(camera.getSceneToLocalTransform());
                    tempTx.transform(localBounds, nodeInCameraBounds);

                    // Compare in camera coordinate
                    if (nodeInCameraBounds.getMinZ() &gt; camera.getFarClip()
                            || nodeInCameraBounds.getMaxZ() &lt; camera.getNearClip()) {
                        return 0;
                    }
                }
            }

            GeneralTransform3D projViewTx = TempState.getInstance().projViewTx;
            projViewTx.set(camera.getProjViewTransform());

            // We need to set tempTx to identity since it is a recycled transform.
            // This is because TransformHelper.apply() is a matrix concatenation operation.
            tempTx.setToIdentity();
            TransformHelper.apply(localToSceneTx, tempTx);

            // The product of projViewTx * localToSceneTransform
            GeneralTransform3D tx = projViewTx.mul(tempTx);

            // Transform localBounds to projected bounds
            localBounds = tx.transform(localBounds, localBounds);
            double area = localBounds.getWidth() * localBounds.getHeight();

            // Use canonical view volume to check whether object is outside the
            // viewing frustrum
            if (isPerspective) {
                localBounds.intersectWith(-1, -1, 0, 1, 1, 1);
                area = (localBounds.getWidth() &lt; 0 || localBounds.getHeight() &lt; 0) ? 0 : area;
            }
            return area * (camera.getViewWidth() / 2 * camera.getViewHeight() / 2);
        }
        return 0;
    }

    /* *************************************************************************
     *                                                                         *
     * Bounds related APIs                                                     *
     *                                                                         *
     **************************************************************************/

    public final Bounds getBoundsInParent() {
        return boundsInParentProperty().get();
    }

    /**
     * The rectangular bounds of this {@code Node} which include its transforms.
     * {@code boundsInParent} is calculated by
     * taking the local bounds (defined by {@link #boundsInLocalProperty boundsInLocal}) and applying
     * the transform created by setting the following additional variables
     * &lt;ol&gt;
     * &lt;li&gt;{@link #getTransforms transforms} ObservableList&lt;/li&gt;
     * &lt;li&gt;{@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}&lt;/li&gt;
     * &lt;li&gt;{@link #rotateProperty rotate}&lt;/li&gt;
     * &lt;li&gt;{@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY}&lt;/li&gt;
     * &lt;li&gt;{@link #translateXProperty translateX}, {@link #translateYProperty translateY},
     * {@link #translateZProperty translateZ}&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * The resulting bounds will be conceptually in the coordinate space of the
     * {@code Node}'s parent, however the node need not have a parent to calculate
     * these bounds.
     * &lt;p&gt;
     * Note that this method does not take the node's visibility into account;
     * the computation is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * This property will always have a non-null value.
     * &lt;p&gt;
     * Note that {@code boundsInParent} is automatically recomputed whenever the
     * geometry of a node changes, or when any of the following the change:
     * transforms {@code ObservableList}, any of the translate, layout or scale
     * variables, or the rotate variable. For this reason, it is an error
     * to bind any of these values in a node to an expression that depends upon
     * this variable. For example, the x or y variables of a shape, or
     * {@code translateX}, {@code translateY} should never be bound to
     * {@code boundsInParent} for the purpose of positioning the node.
     * @return the boundsInParent for this {@code Node}
     */
    public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
        return getMiscProperties().boundsInParentProperty();
    }

    private void invalidateBoundsInParent() {
        if (miscProperties != null) {
            miscProperties.invalidateBoundsInParent();
        }
    }

    public final Bounds getBoundsInLocal() {
        return boundsInLocalProperty().get();
    }

    /**
     * The rectangular bounds of this {@code Node} in the node's
     * untransformed local coordinate space.  For nodes that extend
     * {@link javafx.scene.shape.Shape}, the local bounds will also include
     * space required for a non-zero stroke that may fall outside the shape's
     * geometry that is defined by position and size attributes.
     * The local bounds will also include any clipping set with {@link #clipProperty clip}
     * as well as effects set with {@link #effectProperty effect}.
     *
     * &lt;p&gt;
     * Note that this method does not take the node's visibility into account;
     * the computation is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * This property will always have a non-null value.
     * &lt;p&gt;
     * Note that boundsInLocal is automatically recomputed whenever the
     * geometry of a node changes. For this reason, it is an error to bind any
     * of these values in a node to an expression that depends upon this variable.
     * For example, the x or y variables of a shape should never be bound
     * to boundsInLocal for the purpose of positioning the node.
     * @return the boundsInLocal for this {@code Node}
     */
    public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
        return getMiscProperties().boundsInLocalProperty();
    }

    private void invalidateBoundsInLocal() {
        if (miscProperties != null) {
            miscProperties.invalidateBoundsInLocal();
        }
    }

    /**
     * The rectangular bounds that should be used for layout calculations for
     * this node. {@code layoutBounds} may differ from the visual bounds
     * of the node and is computed differently depending on the node type.
     * &lt;p&gt;
     * If the node type is resizable ({@link javafx.scene.layout.Region Region},
     * {@link javafx.scene.control.Control Control}, or {@link javafx.scene.web.WebView WebView})
     * then the layoutBounds will always be {@code 0,0 width x height}.
     * If the node type is not resizable ({@link javafx.scene.shape.Shape Shape},
     * {@link javafx.scene.text.Text Text}, or {@link Group}), then the {@code layoutBounds}
     * are computed based on the node's geometric properties and does not include the
     * node's clip, effect, or transforms.  See individual class documentation
     * for details.
     * &lt;p&gt;
     * Note that the {@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY},
     * {@link #translateXProperty translateX}, and {@link #translateYProperty translateY}
     * variables are not included in the layoutBounds.
     * This is important because layout code must first determine the current
     * size and location of the node (using {@code layoutBounds}) and then set
     * {@code layoutX} and {@code layoutY} to adjust the translation of the
     * node so that it will have the desired layout position.
     * &lt;p&gt;
     * Because the computation of layoutBounds is often tied to a node's
     * geometric variables, it is an error to bind any such variables to an
     * expression that depends upon {@code layoutBounds}. For example, the
     * x or y variables of a shape should never be bound to {@code layoutBounds}
     * for the purpose of positioning the node.
     * &lt;p&gt;
     * Note that for 3D shapes, the layout bounds is actually a rectangular box
     * with X, Y, and Z values, although only X and Y are used in layout calculations.
     * &lt;p&gt;
     * The {@code layoutBounds} will never be null.
     *
     */
    private LazyBoundsProperty layoutBounds = new LazyBoundsProperty() {
        @Override
        protected Bounds computeBounds() {
            return NodeHelper.computeLayoutBounds(Node.this);
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;layoutBounds&quot;;
        }
    };

    public final Bounds getLayoutBounds() {
        return layoutBoundsProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;Bounds&gt; layoutBoundsProperty() {
        return layoutBounds;
    }

    /*
     *                  Bounds And Transforms Computation
     *
     *  This section of the code is responsible for computing and caching
     *  various bounds and transforms. For optimal performance and minimal
     *  recomputation of bounds (which can be quite expensive), we cache
     *  values on two different levels. We expose two public immutable
     *  Bounds boundsInParent objects and boundsInLocal. Because they are
     *  immutable and because they may change quite frequently (especially
     *  in the case of a Parent whose children are animated), it is
     *  important that the system does not rely on these variables, because
     *  doing so would produce a large amount of garbage. Rather, these
     *  variables are provided solely for the convenience of application
     *  developers and, being lazily bound, should generally be created at
     *  most once per frame.
     *
     *  The second level of caching are within local Bounds2D variables.
     *  These variables, txBounds and geomBounds, are mutable and as such
     *  can be cached and updated as frequently as necessary without creating
     *  excessive garbage. However, since the computation of bounds is still
     *  expensive, it is desirable to cache both the geometric bounds and
     *  the &quot;complete&quot; transformed bounds (essentially, boundsInParent).
     *  Cached txBounds is particularly useful when computing the geometric
     *  bounds of a Parent since it would not require complete or partial
     *  recomputation of each child.
     *
     *  Finally, we cache the complete transform for this node which converts
     *  its coord system from local to parent coords. This is useful both for
     *  minimizing bounds recomputations in the case of the geometry having
     *  changed but the transform not having changed, and also because the tx
     *  is required for several different computations (for example, it must
     *  be computed once during state synchronization with the PG peer, and
     *  must also be computed when the pivot point changes, and also when
     *  deriving the txBounds of the Node).
     *
     *  As with any caching system, a subtle and non-trivial amount of code
     *  is devoted to invalidating the bounds / transforms at appropriate
     *  times and in appropriate places to make sure bounds / transforms
     *  are recomputed at all necessary times.
     *
     *  There are three computeXXX functions. One is for computing the
     *  boundsInParent, the second for computing boundsInLocal, and the
     *  third for computing the default layout bounds (which, by default,
     *  is based on the geometric bounds). These functions are all prefixed
     *  with &quot;compute&quot; because they create and return new immutable
     *  Bounds objects.
     *
     *  There are three getXXXBounds functions. One is for returning the
     *  complete transformed bounds. The second is for returning the
     *  local bounds. The last is for returning the geometric bounds. These
     *  functions are all prefixed with &quot;get&quot; because they may well return
     *  a cached value, or may actually compute the bounds if necessary. These
     *  functions all have the same signature. They take a Bounds2D and
     *  BaseTransform, and return a Bounds2D (the same as they took). These
     *  functions essentially populate the supplied bounds2D with the
     *  appropriate bounds information, leveraging cached bounds if possible.
     *
     *  There is a single NodeHelper.computeGeomBoundsImpl function which is abstract.
     *  This must be implemented in each subclass, and is responsible for
     *  computing the actual geometric bounds for the Node. For example, Parent
     *  is written such that this function is the union of the transformed
     *  bounds of each child. Rectangle is written such that this takes into
     *  account the size and stroke. Text is written such that it is computed
     *  based on the actual glyphs.
     *
     *  There are two updateXXX functions, updateGeomBounds and updateTxBounds.
     *  These functions are for ensuring that geomBounds and txBounds are
     *  valid. They only execute in the case of the cached value being invalid,
     *  so the function call is very cheap in cases where the cached bounds
     *  values are still valid.
     */

    /**
     * An affine transform that holds the computed local-to-parent transform.
     * This is the concatenation of all transforms in this node, including all
     * of the convenience transforms.
     */
    private BaseTransform localToParentTx = BaseTransform.IDENTITY_TRANSFORM;

    /**
     * This flag is used to indicate that localToParentTx is dirty and needs
     * to be recomputed.
     */
    private boolean transformDirty = true;

    /**
     * The cached transformed bounds. This is never null, but is frequently set
     * to be invalid whenever the bounds for the node have changed. These are
     * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
     * Note that this is equivalent to boundsInParent
     */
    private BaseBounds txBounds = new RectBounds();

    /**
     * The cached bounds. This is never null, but is frequently set to be
     * invalid whenever the bounds for the node have changed. These are the
     * &quot;content&quot; bounds, that is, without transforms or effects applied.
     */
    private BaseBounds geomBounds = new RectBounds();

    /**
     * The cached local bounds (without transforms, with clip and effects).
     * If there is neither clip nor effect
     * local bounds are equal to geom bounds, so in this case we don't keep
     * the extra instance and set null to this variable.
     */
    private BaseBounds localBounds = null;

    /**
     * This special flag is used only by Parent to flag whether or not
     * the *parent* has processed the fact that bounds have changed for this
     * child Node. We need some way of flagging this on a per-node basis to
     * enable the significant performance optimizations and fast paths that
     * are in the Parent code.
     * &lt;p&gt;
     * To reduce confusion, although this variable is defined on Node, it
     * really belongs to the Parent of the node and should *only* be modified
     * by the parent.
     */
    boolean boundsChanged;

    /*
     * Returns geometric bounds, but may be over-ridden by a subclass.
     */
    private Bounds doComputeLayoutBounds() {
        BaseBounds tempBounds = TempState.getInstance().bounds;
        tempBounds = getGeomBounds(tempBounds,
                                   BaseTransform.IDENTITY_TRANSFORM);
        return new BoundingBox(tempBounds.getMinX(),
                               tempBounds.getMinY(),
                               tempBounds.getMinZ(),
                               tempBounds.getWidth(),
                               tempBounds.getHeight(),
                               tempBounds.getDepth());
    }

    /*
     * Subclasses may customize the layoutBounds by means of overriding the
     * NodeHelper.computeLayoutBoundsImpl method. If the layout bounds need to be
     * recomputed, the subclass must notify the Node implementation of this
     * fact so that appropriate notifications and internal state can be
     * kept in sync. Subclasses must call NodeHelper.layoutBoundsChanged to
     * let Node know that the layout bounds are invalid and need to be
     * recomputed.
     */
    final void layoutBoundsChanged() {
        if (!layoutBounds.valid) {
            return;
        }
        layoutBounds.invalidate();
        if ((nodeTransformation != null &amp;&amp; nodeTransformation.hasScaleOrRotate()) || hasMirroring()) {
            // if either the scale or rotate convenience variables are used,
            // then we need a valid pivot point. Since the layoutBounds
            // affects the pivot we need to invalidate the transform
            NodeHelper.transformsChanged(this);
        }
    }

    /**
     * Loads the given bounds object with the transformed bounds relative to,
     * and based on, the given transform. That is, this is the local bounds
     * with the local-to-parent transform applied.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getTransformedBounds(BaseBounds bounds, BaseTransform tx) {
        updateLocalToParentTransform();
        if (tx.isTranslateOrIdentity()) {
            updateTxBounds();
            bounds = bounds.deriveWithNewBounds(txBounds);
            if (!tx.isIdentity()) {
                final double translateX = tx.getMxt();
                final double translateY = tx.getMyt();
                final double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds(
                                    (float) (bounds.getMinX() + translateX),
                                    (float) (bounds.getMinY() + translateY),
                                    (float) (bounds.getMinZ() + translateZ),
                                    (float) (bounds.getMaxX() + translateX),
                                    (float) (bounds.getMaxY() + translateY),
                                    (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (localToParentTx.isIdentity()) {
            return getLocalBounds(bounds, tx);
        } else {
            double mxx = tx.getMxx();
            double mxy = tx.getMxy();
            double mxz = tx.getMxz();
            double mxt = tx.getMxt();
            double myx = tx.getMyx();
            double myy = tx.getMyy();
            double myz = tx.getMyz();
            double myt = tx.getMyt();
            double mzx = tx.getMzx();
            double mzy = tx.getMzy();
            double mzz = tx.getMzz();
            double mzt = tx.getMzt();
            BaseTransform boundsTx = tx.deriveWithConcatenation(localToParentTx);
            bounds = getLocalBounds(bounds, boundsTx);
            if (boundsTx == tx) {
                tx.restoreTransform(mxx, mxy, mxz, mxt,
                                    myx, myy, myz, myt,
                                    mzx, mzy, mzz, mzt);
            }
            return bounds;
        }
    }

    /**
     * Loads the given bounds object with the local bounds relative to,
     * and based on, the given transform. That is, these are the geometric
     * bounds + clip and effect.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getLocalBounds(BaseBounds bounds, BaseTransform tx) {
        if (getEffect() == null &amp;&amp; getClip() == null) {
            return getGeomBounds(bounds, tx);
        }

        if (tx.isTranslateOrIdentity()) {
            // we can take a fast path since we know tx is either a simple
            // translation or is identity
            updateLocalBounds();
            bounds = bounds.deriveWithNewBounds(localBounds);
            if (!tx.isIdentity()) {
                double translateX = tx.getMxt();
                double translateY = tx.getMyt();
                double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
                        (float) (bounds.getMinY() + translateY),
                        (float) (bounds.getMinZ() + translateZ),
                        (float) (bounds.getMaxX() + translateX),
                        (float) (bounds.getMaxY() + translateY),
                        (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (tx.is2D()
                &amp;&amp; (tx.getType()
                &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
            // this is a non-uniform scale / non-quadrant rotate / skew transform
            return computeLocalBounds(bounds, tx);
        } else {
            // 3D transformations and
            // selected 2D transformations (uniform transform, flip, quadrant rotation).
            // These 2D transformation will yield tight bounds when applied on the pre-computed
            // geomBounds
            // Note: Transforming the local bounds into a 3D space will yield a bounds
            // that isn't as tight as transforming its geometry and compute it bounds.
            updateLocalBounds();
            return tx.transform(localBounds, bounds);
        }
    }

    /**
     * Loads the given bounds object with the geometric bounds relative to,
     * and based on, the given transform.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getGeomBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isTranslateOrIdentity()) {
            // we can take a fast path since we know tx is either a simple
            // translation or is identity
            updateGeomBounds();
            bounds = bounds.deriveWithNewBounds(geomBounds);
            if (!tx.isIdentity()) {
                double translateX = tx.getMxt();
                double translateY = tx.getMyt();
                double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
                        (float) (bounds.getMinY() + translateY),
                        (float) (bounds.getMinZ() + translateZ),
                        (float) (bounds.getMaxX() + translateX),
                        (float) (bounds.getMaxY() + translateY),
                        (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (tx.is2D()
                &amp;&amp; (tx.getType()
                &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
            // this is a non-uniform scale / non-quadrant rotate / skew transform
            return NodeHelper.computeGeomBounds(this, bounds, tx);
        } else {
            // 3D transformations and
            // selected 2D transformations (unifrom transform, flip, quadrant rotation).
            // These 2D transformation will yield tight bounds when applied on the pre-computed
            // geomBounds
            // Note: Transforming the local geomBounds into a 3D space will yield a bounds
            // that isn't as tight as transforming its geometry and compute it bounds.
            updateGeomBounds();
            return tx.transform(geomBounds, bounds);
        }
    }

    /**
     * If necessary, recomputes the cached geom bounds. If the bounds are not
     * invalid, then this method is a no-op.
     */
    void updateGeomBounds() {
        if (geomBoundsInvalid) {
            geomBounds = NodeHelper.computeGeomBounds(this, geomBounds, BaseTransform.IDENTITY_TRANSFORM);
            geomBoundsInvalid = false;
        }
    }

    /**
     * Computes the local bounds of this Node.
     */
    private BaseBounds computeLocalBounds(BaseBounds bounds, BaseTransform tx) {
        // We either get the bounds of the effect (if it isn't null)
        // or we get the geom bounds (if effect is null). We will then
        // intersect this with the clip.
        if (getEffect() != null) {
            BaseBounds b = EffectHelper.getBounds(getEffect(), bounds, tx, this, boundsAccessor);
            bounds = bounds.deriveWithNewBounds(b);
        } else {
            bounds = getGeomBounds(bounds, tx);
        }
        // intersect with the clip. Take care with &quot;bounds&quot; as it may
        // actually be TEMP_BOUNDS, so we save off state
        if (getClip() != null
                // FIXME: All 3D picking is currently ignored by rendering.
                // Until this is fixed or defined differently (RT-28510),
                // we follow this behavior.
                &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(getClip() instanceof Shape3D)) {
            double x1 = bounds.getMinX();
            double y1 = bounds.getMinY();
            double x2 = bounds.getMaxX();
            double y2 = bounds.getMaxY();
            double z1 = bounds.getMinZ();
            double z2 = bounds.getMaxZ();
            bounds = getClip().getTransformedBounds(bounds, tx);
            bounds.intersectWith((float)x1, (float)y1, (float)z1,
                    (float)x2, (float)y2, (float)z2);
        }
        return bounds;
    }


    /**
     * If necessary, recomputes the cached local bounds. If the bounds are not
     * invalid, then this method is a no-op.
     */
    private void updateLocalBounds() {
        if (localBoundsInvalid) {
            if (getClip() != null || getEffect() != null) {
                localBounds = computeLocalBounds(
                        localBounds == null ? new RectBounds() : localBounds,
                        BaseTransform.IDENTITY_TRANSFORM);
            } else {
                localBounds = null;
            }
            localBoundsInvalid = false;
        }
    }

    /**
     * If necessary, recomputes the cached transformed bounds.
     * If the cached transformed bounds are not invalid, then
     * this method is a no-op.
     */
    void updateTxBounds() {
        if (txBoundsInvalid) {
            updateLocalToParentTransform();
            txBounds = getLocalBounds(txBounds, localToParentTx);
            txBoundsInvalid = false;
        }
    }

    /*
     *                   Bounds Invalidation And Notification
     *
     *  The goal of this section is to efficiently propagate bounds
     *  invalidation through the scenegraph while also being semantically
     *  correct.
     *
     *  The code path for invalidation of layout bounds is somewhat confusing
     *  primarily due to performance enhancements and the desire to reduce the
     *  number of requestLayout() calls that are performed when layout bounds
     *  change. Before diving into layout bounds, I will first describe how
     *  normal bounds invalidation occurs.
     *
     *  When a node's geometry changes (for example, if the width of a
     *  Rectangle is changed) then the Node must call NodeHelper.geomChanged().
     *  Invoking this function will eventually clear all cached bounds and
     *  notify to each parent up the tree that their bounds may have changed.
     *
     *  After invalidating geomBounds (and after kicking off layout bounds
     *  notification), NodeHelper.geomChanged calls localBoundsChanged(). It should
     *  be noted that NodeHelper.geomChanged should only be called when the geometry
     *  of the node has changed such that it may result in the geom bounds
     *  actually changing.
     *
     *  localBoundsChanged() simply invalidates boundsInLocal and then calls
     *  transformedBoundsChanged().
     *
     *  transformedBoundsChanged() is responsible for invalidating
     *  boundsInParent and txBounds. If the Node is not visible, then there is
     *  no need to notify the parent of the bounds change because the parent's
     *  bounds do not include invisible nodes. If the node is visible, then
     *  it must tell the parent that this child node's bounds have changed.
     *  It is up to the parent to eventually invoke its own NodeHelper.geomChanged
     *  function. If instead of a parent this node has a clipParent, then the
     *  clipParent's localBoundsChanged() is called instead.
     *
     *  There are a few other ways in which we enter the invalidate steps
     *  beyond just the geometry changes. If the visibility of a Node changes,
     *  its own bounds are not affected but its parent's bounds are. So a
     *  special call to parent.childVisibilityChanged is made so the parent
     *  can react accordingly.
     *
     *  If a transform is changed (layoutX, layoutY, rotate, transforms, etc)
     *  then the transform must be invalidated. When a transform is invalidated,
     *  it must also invalidate the txBounds by invoking
     *  transformedBoundsChanged, which will in turn notify the parent as
     *  before.
     *
     *  If an effect is changed or replaced then the local bounds must be
     *  invalidated, as well as the transformedBounds and the parent notified
     *  of the change in bounds.
     *
     *  layoutBound is somewhat unique in that it can be redefined in
     *  subclasses. By default, the layoutBounds is the geomBounds, and so
     *  whenever the geomBounds() function is called the layoutBounds
     *  must be invalidated. However in subclasses, especially Resizables,
     *  the layout bounds may not be defined to be the same as the geometric
     *  bounds. This is both useful and provides a very nice performance
     *  optimization for regions and controls. In this case, subclasses
     *  need some way to interpose themselves such that a call to
     *  NodeHelper.geomChanged() *does not* invalidate the layout bounds.
     *
     *  This interposition happens by providing the
     *  NodeHelper.notifyLayoutBoundsChanged function. The default implementation
     *  simply invalidates boundsInLocal. Subclasses (such as Region and
     *  Control) can override this function so that it does not invalidate
     *  the layout bounds.
     *
     *  An on invalidate trigger on layoutBounds handles kicking off the rest
     *  of the invalidate process for layoutBounds. Because the layout bounds
     *  define the pivot point, if scaleX, scaleY, or rotate contain
     *  non-identity values then whenever the layoutBounds change the
     *  transformed bounds also change. Finally, if this node's parent is
     *  a Region and if the Node is being managed by the Region, then
     *  we must call requestLayout on the Region whenever the layout bounds
     *  have changed.
     */

    /*
     * Invoked by subclasses whenever their geometric bounds have changed.
     * Because the default layout bounds is based on the node geometry, this
     * function will invoke NodeHelper.notifyLayoutBoundsChanged. The default
     * implementation of NodeHelper.notifyLayoutBoundsChanged() will simply invalidate
     * layoutBounds. Resizable subclasses will want to override this function
     * in most cases to be a no-op.
     *
     * This function will also invalidate the cached geom bounds, and then
     * invoke localBoundsChanged() which will eventually end up invoking a
     * chain of functions up the tree to ensure that each parent of this
     * Node is notified that its bounds may have also changed.
     *
     * This function should be treated as though it were final. It is not
     * intended to be overridden by subclasses.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doGeomChanged() {
        if (geomBoundsInvalid) {
            // GeomBoundsInvalid is false when node geometry changed and
            // the untransformed node bounds haven't been recalculated yet.
            // Most of the time, the recalculation of layout and transformed
            // node bounds don't require validation of untransformed bounds
            // and so we can not skip the following notifications.
            NodeHelper.notifyLayoutBoundsChanged(this);
            transformedBoundsChanged();
            return;
        }
        geomBounds.makeEmpty();
        geomBoundsInvalid = true;
        NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
        NodeHelper.notifyLayoutBoundsChanged(this);
        localBoundsChanged();
    }

    private boolean geomBoundsInvalid = true;
    private boolean localBoundsInvalid = true;
    private boolean txBoundsInvalid = true;

    /**
     * Responds to changes in the local bounds by invalidating boundsInLocal
     * and notifying this node that its transformed bounds have changed.
     */
    void localBoundsChanged() {
        localBoundsInvalid = true;
        invalidateBoundsInLocal();
        transformedBoundsChanged();
    }

    /**
     * Responds to changes in the transformed bounds by invalidating txBounds
     * and boundsInParent. If this Node is not visible, then we have no need
     * to walk further up the tree but can instead simply invalidate state.
     * Otherwise, this function will notify parents (either the parent or the
     * clipParent) that this child Node's bounds have changed.
     */
    void transformedBoundsChanged() {
        if (!txBoundsInvalid) {
            txBounds.makeEmpty();
            txBoundsInvalid = true;
            invalidateBoundsInParent();
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
        }
        if (isVisible()) {
            notifyParentOfBoundsChange();
        }
    }

    /*
     * Invoked by geomChanged(). Since layoutBounds is by default based
     * on the geometric bounds, the default implementation of this function will
     * invalidate the layoutBounds. Resizable Node subclasses generally base
     * layoutBounds on the width/height instead of the geometric bounds, and so
     * will generally want to override this function to be a no-op.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doNotifyLayoutBoundsChanged() {
        layoutBoundsChanged();
        // notify the parent
        // Group instanceof check a little hoaky, but it allows us to disable
        // unnecessary layout for the case of a non-resizable within a group
        Parent p = getParent();

        // Need to propagate layout if parent isn't part of performing layout
        if (isManaged() &amp;&amp; (p != null) &amp;&amp; !(p instanceof Group &amp;&amp; !isResizable())
                &amp;&amp; !p.isPerformingLayout()) {
            // Force its parent to fix the layout since it is a managed child.
            p.requestLayout(true);
        }
    }

    /**
     * Notifies both the real parent and the clip parent (if they exist) that
     * the bounds of the child has changed. Note that since FX doesn't throw
     * NPE's, things actually are faster if we don't check twice for Null
     * (we check once, the compiler checks again)
     */
    void notifyParentOfBoundsChange() {
        // let the parent know which node has changed and the parent will
        // deal with marking itself invalid correctly
        Parent p = getParent();
        if (p != null) {
            p.childBoundsChanged(this);
        }
        // since the clip is used to compute the local bounds (and not the
        // geom bounds), we just need to notify that local bounds on the
        // clip parent have changed
        if (clipParent != null) {
            clipParent.localBoundsChanged();
        }
    }

    /***************************************************************************
     *                                                                         *
     * Geometry and coordinate system related APIs. For example, methods       *
     * related to containment, intersection, coordinate space conversion, etc. *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns {@code true} if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the shape of
     * this {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * @param localX the x coordinate of the point in Node's space
     * @param localY the y coordinate of the point in Node's space
     * @return the result of contains for this {@code Node}
     */
    public boolean contains(double localX, double localY) {
        if (containsBounds(localX, localY)) {
            return (isPickOnBounds() || NodeHelper.computeContains(this, localX, localY));
        }
        return false;
    }

    /*
     * This method only does the contains check based on the bounds, clip and
     * effect of this node, excluding its shape (or geometry).
     *
     * Returns true if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the bounds,
     * clip and effect of this node.
     */
    private boolean containsBounds(double localX, double localY) {
        final TempState tempState = TempState.getInstance();
        BaseBounds tempBounds = tempState.bounds;

        // first, we do a quick test to see if the point is contained in
        // our local bounds. If so, then we will go the next step and check
        // the clip, effect, and geometry for containment.
        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);
        if (tempBounds.contains((float)localX, (float)localY)) {
            // if the clip is defined, then check it for containment, being
            // sure to convert from this node's local coordinate system
            // to the local coordinate system of the clip node
            if (getClip() != null) {
                tempState.point.x = (float)localX;
                tempState.point.y = (float)localY;
                try {
                    getClip().parentToLocal(tempState.point);
                } catch (NoninvertibleTransformException e) {
                    return false;
                }
                if (!getClip().contains(tempState.point.x, tempState.point.y)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Returns {@code true} if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the shape of
     * this {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * @param localPoint the 2D point in Node's space
     * @return the result of contains for this {@code Node}
     */
    public boolean contains(Point2D localPoint) {
        return contains(localPoint.getX(), localPoint.getY());
    }

    /**
     * Returns {@code true} if the given rectangle (specified in the local
     * coordinate space of this {@code Node}) intersects the shape of this
     * {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * The default behavior of this function is simply to check if the
     * given coordinates intersect with the local bounds.
     * @param localX the x coordinate of a rectangle in Node's space
     * @param localY the y coordinate of a rectangle in Node's space
     * @param localWidth the width of a rectangle in Node's space
     * @param localHeight the height of a rectangle in Node's space
     * @return the result of intersects for this {@code Node}
     */
    public boolean intersects(double localX, double localY, double localWidth, double localHeight) {
        BaseBounds tempBounds = TempState.getInstance().bounds;
        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);
        return tempBounds.intersects((float)localX,
                                     (float)localY,
                                     (float)localWidth,
                                     (float)localHeight);
    }

    /**
     * Returns {@code true} if the given bounds (specified in the local
     * coordinate space of this {@code Node}) intersects the shape of this
     * {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * The default behavior of this function is simply to check if the
     * given coordinates intersect with the local bounds.
     * @param localBounds the bounds
     * @return the result of intersects for this {@code Node}
     */
    public boolean intersects(Bounds localBounds) {
        return intersects(localBounds.getMinX(), localBounds.getMinY(), localBounds.getWidth(), localBounds.getHeight());
    }

    /**
     * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
     * into the local coordinate space of this {@code Node}.
     * @param screenX x coordinate of a point on a Screen
     * @param screenY y coordinate of a point on a Screen
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point2D screenToLocal(double screenX, double screenY) {
        Scene scene = getScene();
        if (scene == null) return null;
        Window window = scene.getWindow();
        if (window == null) return null;

        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;

        tempPt.setLocation((float)(screenX - scene.getX() - window.getX()),
                           (float)(screenY - scene.getY() - window.getY()));

        final SubScene subScene = getSubScene();
        if (subScene != null) {
            final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
                    new Point2D(tempPt.x, tempPt.y));
            if (ssCoord == null) {
                return null;
            }
            tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
        }

        final Point3D ppIntersect =
                scene.getEffectiveCamera().pickProjectPlane(tempPt.x, tempPt.y);
        tempPt.setLocation((float) ppIntersect.getX(), (float) ppIntersect.getY());

        try {
            sceneToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
     * into the local coordinate space of this {@code Node}.
     * @param screenPoint a point on a Screen
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point2D screenToLocal(Point2D screenPoint) {
        return screenToLocal(screenPoint.getX(), screenPoint.getY());
    }

    /**
     * Transforms a rectangle from the coordinate space of the
     * {@link javafx.stage.Screen} into the local coordinate space of this
     * {@code Node}. Returns reasonable result only in 2D space.
     * @param screenBounds bounds on a Screen
     * @return bounds in the local Node'space or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Bounds screenToLocal(Bounds screenBounds) {
        final Point2D p1 = screenToLocal(screenBounds.getMinX(), screenBounds.getMinY());
        final Point2D p2 = screenToLocal(screenBounds.getMinX(), screenBounds.getMaxY());
        final Point2D p3 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMinY());
        final Point2D p4 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMaxY());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
    }


    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(double, double)}.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the point
     * @since JavaFX 8u40
     */
    public Point2D sceneToLocal(double x, double y, boolean rootScene) {
        if (!rootScene) {
            return sceneToLocal(x, y);
        }
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;

        tempPt.setLocation((float)(x), (float)y);

        final SubScene subScene = getSubScene();
        if (subScene != null) {
            final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
                    new Point2D(tempPt.x, tempPt.y));
            if (ssCoord == null) {
                return null;
            }
            tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
        }

        try {
            sceneToLocal(tempPt);
            return new Point2D(tempPt.x, tempPt.y);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(javafx.geometry.Point2D)}.
     *
     * @param point the point
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the point
     * @since JavaFX 8u40
     */
    public Point2D sceneToLocal(Point2D point, boolean rootScene) {
        return sceneToLocal(point.getX(), point.getY(), rootScene);
    }

    /**
     * Transforms a bounds from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(javafx.geometry.Bounds)}.
     * &lt;p&gt;
     *     Since 3D bounds cannot be converted with {@code rootScene} set to {@code true}, trying to convert 3D bounds will yield {@code null}.
     * &lt;/p&gt;
     * @param bounds the bounds
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the bounds
     * @since JavaFX 8u40
     */
    public Bounds sceneToLocal(Bounds bounds, boolean rootScene) {
        if (!rootScene) {
            return sceneToLocal(bounds);
        }
        if (bounds.getMinZ() != 0 || bounds.getMaxZ() != 0) {
            return null;
        }
        final Point2D p1 = sceneToLocal(bounds.getMinX(), bounds.getMinY(), true);
        final Point2D p2 = sceneToLocal(bounds.getMinX(), bounds.getMaxY(), true);
        final Point2D p3 = sceneToLocal(bounds.getMaxX(), bounds.getMinY(), true);
        final Point2D p4 = sceneToLocal(bounds.getMaxX(), bounds.getMaxY(), true);

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneX x coordinate of a point on a Scene
     * @param sceneY y coordinate of a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Point2D sceneToLocal(double sceneX, double sceneY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)sceneX, (float)sceneY);
        try {
            sceneToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param scenePoint a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Point2D sceneToLocal(Point2D scenePoint) {
        return sceneToLocal(scenePoint.getX(), scenePoint.getY());
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param scenePoint a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point3D sceneToLocal(Point3D scenePoint) {
        return sceneToLocal(scenePoint.getX(), scenePoint.getY(), scenePoint.getZ());
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneX x coordinate of a point on a Scene
     * @param sceneY y coordinate of a point on a Scene
     * @param sceneZ z coordinate of a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point3D sceneToLocal(double sceneX, double sceneY, double sceneZ) {
        try {
            return sceneToLocal0(sceneX, sceneY, sceneZ);
        } catch (NoninvertibleTransformException ex) {
            return null;
        }
    }

    /**
     * Internal method to transform a point from scene to local coordinates.
     */
    private Point3D sceneToLocal0(double x, double y, double z) throws NoninvertibleTransformException {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        sceneToLocal(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a rectangle from the coordinate space of the
     * scene into the local coordinate space of this
     * {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneBounds bounds on a Scene
     * @return bounds in the local Node'space or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Bounds sceneToLocal(Bounds sceneBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (sceneBounds.getMinZ() == 0) &amp;&amp; (sceneBounds.getMaxZ() == 0)) {
            Point2D p1 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMinY());
            Point2D p2 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMinY());
            Point2D p3 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMaxY());
            Point2D p4 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        try {
            Point3D p1 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
            Point3D p2 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
            Point3D p3 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
            Point3D p4 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
            Point3D p5 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
            Point3D p6 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
            Point3D p7 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
            Point3D p8 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
            return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(double localX, double localY) {
        return localToScreen(localX, localY, 0.0);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localPoint a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(Point2D localPoint) {
        return localToScreen(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @param localZ z coordinate of a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(double localX, double localY, double localZ) {
        Scene scene = getScene();
        if (scene == null) return null;
        Window window = scene.getWindow();
        if (window == null) return null;

        Point3D pt = localToScene(localX, localY, localZ);
        final SubScene subScene = getSubScene();
        if (subScene != null) {
            pt = SceneUtils.subSceneToScene(subScene, pt);
        }
        final Point2D projection = CameraHelper.project(
                SceneHelper.getEffectiveCamera(getScene()), pt);

        return new Point2D(projection.getX() + scene.getX() + window.getX(),
                           projection.getY() + scene.getY() + window.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localPoint a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(Point3D localPoint) {
        return localToScreen(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localBounds bounds in Node's space
     * @return the bounds in screen coordinates or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Bounds localToScreen(Bounds localBounds) {
        final Point2D p1 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        final Point2D p2 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        final Point2D p3 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        final Point2D p4 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        final Point2D p5 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        final Point2D p6 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        final Point2D p7 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        final Point2D p8 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @return scene coordinates of the point or null if Node is not in a {@link Window}
     */
    public Point2D localToScene(double localX, double localY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)localX, (float)localY);
        localToScene(tempPt);
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localPoint a point in Node's space
     * @return scene coordinates of the point or null if Node is not in a {@link Window}
     */
    public Point2D localToScene(Point2D localPoint) {
        return localToScene(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localPoint a 3D point in Node's space
     * @return the transformed 3D point in Scene's space
     * @see #localToScene(javafx.geometry.Point3D, boolean)
     * @since JavaFX 8.0
     */
    public Point3D localToScene(Point3D localPoint) {
        return localToScene(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param x the x coordinate of a point in Node's space
     * @param y the y coordinate of a point in Node's space
     * @param z the z coordinate of a point in Node's space
     * @return the transformed 3D point in Scene's space
     * @see #localToScene(double, double, double, boolean)
     * @since JavaFX 8.0
     */
    public Point3D localToScene(double x, double y, double z) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        localToScene(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Point3D)}.
     *
     * @param localPoint the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(javafx.geometry.Point3D)
     * @since JavaFX 8u40
     */
    public Point3D localToScene(Point3D localPoint, boolean rootScene) {
        Point3D pt = localToScene(localPoint);
        if (rootScene) {
            final SubScene subScene = getSubScene();
            if (subScene != null) {
                pt = SceneUtils.subSceneToScene(subScene, pt);
            }
        }
        return pt;
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(double, double, double)}.
     *
     * @param x the x coordinate of the point in local coordinates
     * @param y the y coordinate of the point in local coordinates
     * @param z the z coordinate of the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(double, double, double)
     * @since JavaFX 8u40
     */
    public Point3D localToScene(double x, double y, double z, boolean rootScene) {
        return localToScene(new Point3D(x, y, z), rootScene);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Point2D)}.
     *
     * @param localPoint the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(javafx.geometry.Point2D)
     * @since JavaFX 8u40
     */
    public Point2D localToScene(Point2D localPoint, boolean rootScene) {
        if (!rootScene) {
            return localToScene(localPoint);
        }
        Point3D pt = localToScene(localPoint.getX(), localPoint.getY(), 0, rootScene);
        return new Point2D(pt.getX(), pt.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(double, double)}.
     *
     * @param x the x coordinate of the point in local coordinates
     * @param y the y coordinate of the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(double, double)
     * @since JavaFX 8u40
     */
    public Point2D localToScene(double x, double y, boolean rootScene) {
        return localToScene(new Point2D(x, y), rootScene);
    }

    /**
     * Transforms a bounds from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result bounds are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Bounds)}.
     *
     * @param localBounds the bounds in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed bounds
     *
     * @see #localToScene(javafx.geometry.Bounds)
     * @since JavaFX 8u40
     */
<A NAME="36"></A>    public Bounds localToScene(Bounds localBounds, boolean rootScene) {
        if (!rootScene) {
            return localToScene(localBounds);
        <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#36',2,'match42-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ(), true);
        Point3D p2 = localToScene(localBounds.getMinX</B></FONT>(), localBounds.getMinY(), localBounds.getMaxZ(), true);
        Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
        Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
        Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
        Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
        Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ(), true);
        Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localBounds bounds in Node's space
     * @return the bounds in the scene coordinates or null if Node is not in a {@link Window}
     * @see #localToScene(javafx.geometry.Bounds, boolean)
     */
    public Bounds localToScene(Bounds localBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
            Point2D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY());
            Point2D p2 = localToScene(localBounds.getMaxX(), localBounds.getMinY());
            Point2D p3 = localToScene(localBounds.getMaxX(), localBounds.getMaxY());
            Point2D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);

    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentX the x coordinate in Parent's space
     * @param parentY the y coordinate in Parent's space
     * @return the transformed 2D point in Node's space
     */
    public Point2D parentToLocal(double parentX, double parentY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)parentX, (float)parentY);
        try {
            parentToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentPoint the 2D point in Parent's space
     * @return the transformed 2D point in Node's space
     */
    public Point2D parentToLocal(Point2D parentPoint) {
        return parentToLocal(parentPoint.getX(), parentPoint.getY());
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentPoint parentPoint the 3D point in Parent's space
     * @return the transformed 3D point in Node's space
     * @since JavaFX 8.0
     */
    public Point3D parentToLocal(Point3D parentPoint) {
        return parentToLocal(parentPoint.getX(), parentPoint.getY(), parentPoint.getZ());
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentX the x coordinate in Parent's space
     * @param parentY the y coordinate in Parent's space
     * @param parentZ the z coordinate in Parent's space
     * @return the transformed 3D point in Node's space
     * @since JavaFX 8.0
     */
    public Point3D parentToLocal(double parentX, double parentY, double parentZ) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(parentX, parentY, parentZ);
        try {
            parentToLocal(tempV3D);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a rectangle from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentBounds the bounds in Parent's space
     * @return the transformed bounds in Node's space
     */
    public Bounds parentToLocal(Bounds parentBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (parentBounds.getMinZ() == 0) &amp;&amp; (parentBounds.getMaxZ() == 0)) {
            Point2D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY());
            Point2D p2 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY());
            Point2D p3 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY());
            Point2D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMinZ());
        Point3D p2 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMaxZ());
        Point3D p3 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMinZ());
        Point3D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
        Point3D p5 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMinZ());
        Point3D p6 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
        Point3D p7 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMinZ());
        Point3D p8 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localX the x coordinate of the point in Node's space
     * @param localY the y coordinate of the point in Node's space
     * @return the transformed 2D point in Parent's space
     */
    public Point2D localToParent(double localX, double localY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)localX, (float)localY);
        localToParent(tempPt);
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localPoint the 2D point in Node's space
     * @return the transformed 2D point in Parent's space
     */
    public Point2D localToParent(Point2D localPoint) {
        return localToParent(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localPoint the 3D point in Node's space
     * @return the transformed 3D point in Parent's space
     * @since JavaFX 8.0
     */
    public Point3D localToParent(Point3D localPoint) {
        return localToParent(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param x the x coordinate of the point in Node's space
     * @param y the y coordinate of the point in Node's space
     * @param z the z coordinate of the point in Node's space
     * @return the transformed 3D point in Parent's space
     * @since JavaFX 8.0
     */
    public Point3D localToParent(double x, double y, double z) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        localToParent(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its parent.
     * @param localBounds the bounds in Node's space
     * @return the transformed bounds in Parent's space
     */
    public Bounds localToParent(Bounds localBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
            Point2D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY());
            Point2D p2 = localToParent(localBounds.getMaxX(), localBounds.getMinY());
            Point2D p3 = localToParent(localBounds.getMaxX(), localBounds.getMaxY());
            Point2D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p2 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        Point3D p3 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p5 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p6 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p7 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p8 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Copy the localToParent transform into specified transform.
     */
    BaseTransform getLocalToParentTransform(BaseTransform tx) {
        updateLocalToParentTransform();
        tx.setTransform(localToParentTx);
        return tx;
    }

    /*
     * Currently used only by PathTransition
     */
    final BaseTransform getLeafTransform() {
        return getLocalToParentTransform(TempState.getInstance().leafTx);
    }

    /*
     * Invoked whenever the transforms[] ObservableList changes, or by the transforms
     * in that ObservableList whenever they are changed.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doTransformsChanged() {
        if (!transformDirty) {
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
            transformDirty = true;
            transformedBoundsChanged();
        }
        invalidateLocalToParentTransform();
        invalidateLocalToSceneTransform();
    }

    final double getPivotX() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinX() + bounds.getWidth()/2;
    }

    final double getPivotY() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinY() + bounds.getHeight()/2;
    }

    final double getPivotZ() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinZ() + bounds.getDepth()/2;
    }

    /**
     * This helper function will update the transform matrix on the peer based
     * on the &quot;complete&quot; transform for this node.
     */
    void updateLocalToParentTransform() {
        if (transformDirty) {
            localToParentTx.setToIdentity();

            boolean mirror = false;
            double mirroringCenter = 0;
            if (hasMirroring()) {
                final Scene sceneValue = getScene();
                if ((sceneValue != null) &amp;&amp; (sceneValue.getRoot() == this)) {
                    // handle scene mirroring in this branch
                    // (must be the last transformation)
                    mirroringCenter = sceneValue.getWidth() / 2;
                    if (mirroringCenter == 0.0) {
                        mirroringCenter = getPivotX();
                    }

                    localToParentTx = localToParentTx.deriveWithTranslation(
                            mirroringCenter, 0.0);
                    localToParentTx = localToParentTx.deriveWithScale(
                            -1.0, 1.0, 1.0);
                    localToParentTx = localToParentTx.deriveWithTranslation(
                            -mirroringCenter, 0.0);
                } else {
                    // mirror later
                    mirror = true;
                    mirroringCenter = getPivotX();
                }
            }

            if (getScaleX() != 1 || getScaleY() != 1 || getScaleZ() != 1 || getRotate() != 0) {
                // recompute pivotX, pivotY and pivotZ
                double pivotX = getPivotX();
                double pivotY = getPivotY();
                double pivotZ = getPivotZ();

                localToParentTx = localToParentTx.deriveWithTranslation(
                        getTranslateX() + getLayoutX() + pivotX,
                        getTranslateY() + getLayoutY() + pivotY,
                        getTranslateZ() + pivotZ);
                localToParentTx = localToParentTx.deriveWithRotation(
                        Math.toRadians(getRotate()), getRotationAxis().getX(),
                        getRotationAxis().getY(), getRotationAxis().getZ());
                localToParentTx = localToParentTx.deriveWithScale(
                        getScaleX(), getScaleY(), getScaleZ());
                localToParentTx = localToParentTx.deriveWithTranslation(
                        -pivotX, -pivotY, -pivotZ);
            } else {
                localToParentTx = localToParentTx.deriveWithTranslation(
                        getTranslateX() + getLayoutX(),
                        getTranslateY() + getLayoutY(),
                        getTranslateZ());
            }

            if (hasTransforms()) {
                for (Transform t : getTransforms()) {
                    localToParentTx = TransformHelper.derive(t, localToParentTx);
                }
            }

            // Check to see whether the node requires mirroring
            if (mirror) {
                localToParentTx = localToParentTx.deriveWithTranslation(
                        mirroringCenter, 0);
                localToParentTx = localToParentTx.deriveWithScale(
                        -1.0, 1.0, 1.0);
                localToParentTx = localToParentTx.deriveWithTranslation(
                        -mirroringCenter, 0);
            }

            transformDirty = false;
        }
    }

    /**
     * Transforms in place the specified point from parent coords to local
     * coords. Made package private for the sake of testing.
     */
    void parentToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
        updateLocalToParentTransform();
        localToParentTx.inverseTransform(pt, pt);
    }

    void parentToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
        updateLocalToParentTransform();
        localToParentTx.inverseTransform(pt, pt);
    }

    void sceneToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
        if (getParent() != null) {
            getParent().sceneToLocal(pt);
        }
        parentToLocal(pt);
    }

    void sceneToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
        if (getParent() != null) {
            getParent().sceneToLocal(pt);
        }
        parentToLocal(pt);
    }

    void localToScene(com.sun.javafx.geom.Point2D pt) {
        localToParent(pt);
        if (getParent() != null) {
            getParent().localToScene(pt);
        }
    }

    void localToScene(com.sun.javafx.geom.Vec3d pt) {
        localToParent(pt);
        if (getParent() != null) {
            getParent().localToScene(pt);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Mouse event related APIs                                                *
     *                                                                         *
     **************************************************************************/

    /**
     * Transforms in place the specified point from local coords to parent
     * coords. Made package private for the sake of testing.
     */
    void localToParent(com.sun.javafx.geom.Point2D pt) {
        updateLocalToParentTransform();
        localToParentTx.transform(pt, pt);
    }

    void localToParent(com.sun.javafx.geom.Vec3d pt) {
        updateLocalToParentTransform();
        localToParentTx.transform(pt, pt);
    }

    /*
     * Finds a top-most child node that contains the given local coordinates.
     *
     * The result argument is used for storing the picking result.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
        intersects(localPickRay, result);
    }

    /*
     * Finds a top-most child node that intersects the given ray.
     *
     * The result argument is used for storing the picking result.
     */
    final void pickNode(PickRay pickRay, PickResultChooser result) {

        // In some conditions we can omit picking this node or subgraph
        if (!isVisible() || isDisable() || isMouseTransparent()) {
            return;
        }

        final Vec3d o = pickRay.getOriginNoClone();
        final double ox = o.x;
        final double oy = o.y;
        final double oz = o.z;
        final Vec3d d = pickRay.getDirectionNoClone();
        final double dx = d.x;
        final double dy = d.y;
        final double dz = d.z;

        updateLocalToParentTransform();
        try {
            localToParentTx.inverseTransform(o, o);
            localToParentTx.inverseDeltaTransform(d, d);

            // Delegate to a function which can be overridden by subclasses which
            // actually does the pick. The implementation is markedly different
            // for leaf nodes vs. parent nodes vs. region nodes.
            NodeHelper.pickNodeLocal(this, pickRay, result);
        } catch (NoninvertibleTransformException e) {
            // in this case we just don't pick anything
        }

        pickRay.setOrigin(ox, oy, oz);
        pickRay.setDirection(dx, dy, dz);
    }

    /*
     * Returns {@code true} if the given ray (start, dir), specified in the
     * local coordinate space of this {@code Node}, intersects the
     * shape of this {@code Node}. Note that this method does not take visibility
     * into account; the test is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * The pickResult is updated if the found intersection is closer than
     * the currently held one.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     */
    final boolean intersects(PickRay pickRay, PickResultChooser pickResult) {
        double boundsDistance = intersectsBounds(pickRay);
        if (!Double.isNaN(boundsDistance)) {
            if (isPickOnBounds()) {
                if (pickResult != null) {
                    pickResult.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
                }
                return true;
            } else {
                return NodeHelper.computeIntersects(this, pickRay, pickResult);
            }
        }
        return false;
    }

    /*
     * Computes the intersection of the pickRay with this node.
     * The pickResult argument is updated if the found intersection
     * is closer than the passed one. On the other hand, the return value
     * specifies whether the intersection exists, regardless of its comparison
     * with the given pickResult.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
        double origZ = pickRay.getOriginNoClone().z;
        double dirZ = pickRay.getDirectionNoClone().z;
        // Handle the case where pickRay is almost parallel to the Z-plane
        if (almostZero(dirZ)) {
            return false;
        }
        double t = -origZ / dirZ;
        if (t &lt; pickRay.getNearClip() || t &gt; pickRay.getFarClip()) {
            return false;
        }
        double x = pickRay.getOriginNoClone().x + (pickRay.getDirectionNoClone().x * t);
        double y = pickRay.getOriginNoClone().y + (pickRay.getDirectionNoClone().y * t);

        if (contains((float) x, (float) y)) {
            if (pickResult != null) {
                pickResult.offer(this, t, PickResultChooser.computePoint(pickRay, t));
            }
            return true;
        }
        return false;
    }

    /*
     * Computes the intersection of the pickRay with the bounds of this node.
     * The return value is the distance between the camera and the intersection
     * point, measured in pickRay direction magnitudes. If there is
     * no intersection, it returns NaN.
     *
     * @param pickRay The pick ray
     * @return Distance of the intersection point, a NaN if there
     *         is no intersection
     */
    final double intersectsBounds(PickRay pickRay) {

        final Vec3d dir = pickRay.getDirectionNoClone();
        double tmin, tmax;

        final Vec3d origin = pickRay.getOriginNoClone();
        final double originX = origin.x;
        final double originY = origin.y;
        final double originZ = origin.z;

        final TempState tempState = TempState.getInstance();
        BaseBounds tempBounds = tempState.bounds;

        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);

        if (dir.x == 0.0 &amp;&amp; dir.y == 0.0) {
            // fast path for the usual 2D picking

            if (dir.z == 0.0) {
                return Double.NaN;
            }

            if (originX &lt; tempBounds.getMinX() ||
                    originX &gt; tempBounds.getMaxX() ||
                    originY &lt; tempBounds.getMinY() ||
                    originY &gt; tempBounds.getMaxY()) {
                return Double.NaN;
            }

            final double invDirZ = 1.0 / dir.z;
            final boolean signZ = invDirZ &lt; 0.0;

            final double minZ = tempBounds.getMinZ();
            final double maxZ = tempBounds.getMaxZ();
            tmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
            tmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;

        } else if (tempBounds.getDepth() == 0.0) {
            // fast path for 3D picking of 2D bounds

            if (almostZero(dir.z)) {
                return Double.NaN;
            }

            final double t = (tempBounds.getMinZ() - originZ) / dir.z;
            final double x = originX + (dir.x * t);
            final double y = originY + (dir.y * t);

            if (x &lt; tempBounds.getMinX() ||
                    x &gt; tempBounds.getMaxX() ||
                    y &lt; tempBounds.getMinY() ||
                    y &gt; tempBounds.getMaxY()) {
                return Double.NaN;
            }

            tmin = tmax = t;

        } else {

            final double invDirX = dir.x == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.x);
            final double invDirY = dir.y == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.y);
            final double invDirZ = dir.z == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.z);
            final boolean signX = invDirX &lt; 0.0;
            final boolean signY = invDirY &lt; 0.0;
            final boolean signZ = invDirZ &lt; 0.0;
            final double minX = tempBounds.getMinX();
            final double minY = tempBounds.getMinY();
            final double maxX = tempBounds.getMaxX();
            final double maxY = tempBounds.getMaxY();

            tmin = Double.NEGATIVE_INFINITY;
            tmax = Double.POSITIVE_INFINITY;
            if (Double.isInfinite(invDirX)) {
                if (minX &lt;= originX &amp;&amp; maxX &gt;= originX) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                tmin = ((signX ? maxX : minX) - originX) * invDirX;
                tmax = ((signX ? minX : maxX) - originX) * invDirX;
            }

            if (Double.isInfinite(invDirY)) {
                if (minY &lt;= originY &amp;&amp; maxY &gt;= originY) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                final double tymin = ((signY ? maxY : minY) - originY) * invDirY;
                final double tymax = ((signY ? minY : maxY) - originY) * invDirY;

                if ((tmin &gt; tymax) || (tymin &gt; tmax)) {
                    return Double.NaN;
                }
                if (tymin &gt; tmin) {
                    tmin = tymin;
                }
                if (tymax &lt; tmax) {
                    tmax = tymax;
                }
            }

            final double minZ = tempBounds.getMinZ();
            final double maxZ = tempBounds.getMaxZ();
            if (Double.isInfinite(invDirZ)) {
                if (minZ &lt;= originZ &amp;&amp; maxZ &gt;= originZ) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                final double tzmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
                final double tzmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;

                if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) {
                    return Double.NaN;
                }
                if (tzmin &gt; tmin) {
                    tmin = tzmin;
                }
                if (tzmax &lt; tmax) {
                    tmax = tzmax;
                }
            }
        }

        // For clip we use following semantics: pick the node normally
        // if there is an intersection with the clip node. We don't consider
        // clip node distance.
        Node clip = getClip();
        if (clip != null
                // FIXME: All 3D picking is currently ignored by rendering.
                // Until this is fixed or defined differently (RT-28510),
                // we follow this behavior.
                &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(clip instanceof Shape3D)) {
            final double dirX = dir.x;
            final double dirY = dir.y;
            final double dirZ = dir.z;

            clip.updateLocalToParentTransform();

            boolean hitClip = true;
            try {
                clip.localToParentTx.inverseTransform(origin, origin);
                clip.localToParentTx.inverseDeltaTransform(dir, dir);
            } catch (NoninvertibleTransformException e) {
                hitClip = false;
            }
            hitClip = hitClip &amp;&amp; clip.intersects(pickRay, null);
            pickRay.setOrigin(originX, originY, originZ);
            pickRay.setDirection(dirX, dirY, dirZ);

            if (!hitClip) {
                return Double.NaN;
            }
        }

        if (Double.isInfinite(tmin) || Double.isNaN(tmin)) {
            // We've got a nonsense pick ray or bounds.
            return Double.NaN;
        }

        final double minDistance = pickRay.getNearClip();
        final double maxDistance = pickRay.getFarClip();
        if (tmin &lt; minDistance) {
            if (tmax &gt;= minDistance) {
                // we are inside bounds
                return 0.0;
            } else {
                return Double.NaN;
            }
        } else if (tmin &gt; maxDistance) {
            return Double.NaN;
        }

        return tmin;
    }


    // Good to find a home for commonly use util. code such as EPS.
    // and almostZero. This code currently defined in multiple places,
    // such as Affine3D and GeneralTransform3D.
    private static final double EPSILON_ABSOLUTE = 1.0e-5;

    static boolean almostZero(double a) {
        return ((a &lt; EPSILON_ABSOLUTE) &amp;&amp; (a &gt; -EPSILON_ABSOLUTE));
    }

    /***************************************************************************
     *                                                                         *
     *                      viewOrder property handling                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines the rendering and picking order of this {@code Node} within its
     * parent.
     * &lt;p&gt;
     * This property is used to alter the rendering and picking order of a node
     * within its parent without reordering the parent's {@code children} list.
     * For example, this can be used as a more efficient way to implement
     * transparency sorting. To do this, an application can assign the viewOrder
     * value of each node to the computed distance between that node and the
     * viewer.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parent will traverse its {@code children} in decreasing
     * {@code viewOrder} order. This means that a child with a lower
     * {@code viewOrder} will be in front of a child with a higher
     * {@code viewOrder}. If two children have the same {@code viewOrder}, the
     * parent will traverse them in the order they appear in the parent's
     * {@code children} list.
     * &lt;/p&gt;
     * &lt;p&gt;
     * However, {@code viewOrder} does not alter the layout and focus traversal
     * order of this Node within its parent. A parent always traverses its
     * {@code children} list in order when doing layout or focus traversal.
     * &lt;/p&gt;
     *
     * @return the view order for this {@code Node}
     * @defaultValue 0.0
     *
     * @since 9
     */
    public final DoubleProperty viewOrderProperty() {
        return getMiscProperties().viewOrderProperty();
    }

    public final void setViewOrder(double value) {
        viewOrderProperty().set(value);
    }

    public final double getViewOrder() {
        return (miscProperties == null) ? DEFAULT_VIEW_ORDER
                : miscProperties.getViewOrder();
    }

    /***************************************************************************
     *                                                                         *
     *                             Transformations                             *
     *                                                                         *
     **************************************************************************/
    /**
     * Defines the ObservableList of {@link javafx.scene.transform.Transform} objects
     * to be applied to this {@code Node}. This ObservableList of transforms is applied
     * before {@link #translateXProperty translateX}, {@link #translateYProperty translateY}, {@link #scaleXProperty scaleX}, and
     * {@link #scaleYProperty scaleY}, {@link #rotateProperty rotate} transforms.
     *
     * @return the transforms for this {@code Node}
     * @defaultValue empty
     */
    public final ObservableList&lt;Transform&gt; getTransforms() {
        return transformsProperty();
    }

    private ObservableList&lt;Transform&gt; transformsProperty() {
        return getNodeTransformation().getTransforms();
    }

    public final void setTranslateX(double value) {
        translateXProperty().set(value);
    }

    public final double getTranslateX() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_X
                : nodeTransformation.getTranslateX();
    }

    /**
     * Defines the x coordinate of the translation that is added to this {@code Node}'s
     * transform.
     * &lt;p&gt;
     * The node's final translation will be computed as {@link #layoutXProperty layoutX} + {@code translateX},
     * where {@code layoutX} establishes the node's stable position and {@code translateX}
     * optionally makes dynamic adjustments to that position.
     *&lt;p&gt;
     * This variable can be used to alter the location of a node without disturbing
     * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node's location.
     *
     * @return the translateX for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateXProperty() {
        return getNodeTransformation().translateXProperty();
    }

    public final void setTranslateY(double value) {
        translateYProperty().set(value);
    }

    public final double getTranslateY() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_Y
                : nodeTransformation.getTranslateY();
    }

    /**
     * Defines the y coordinate of the translation that is added to this {@code Node}'s
     * transform.
     * &lt;p&gt;
     * The node's final translation will be computed as {@link #layoutYProperty layoutY} + {@code translateY},
     * where {@code layoutY} establishes the node's stable position and {@code translateY}
     * optionally makes dynamic adjustments to that position.
     * &lt;p&gt;
     * This variable can be used to alter the location of a node without disturbing
     * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node's location.
     *
     * @return the translateY for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateYProperty() {
        return getNodeTransformation().translateYProperty();
    }

    public final void setTranslateZ(double value) {
        translateZProperty().set(value);
    }

    public final double getTranslateZ() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_Z
                : nodeTransformation.getTranslateZ();
    }

    /**
     * Defines the Z coordinate of the translation that is added to the
     * transformed coordinates of this {@code Node}.  This value will be added
     * to any translation defined by the {@code transforms} ObservableList and
     * {@code layoutZ}.
     * &lt;p&gt;
     * This variable can be used to alter the location of a Node without
     * disturbing its layout bounds, which makes it useful for animating a
     * node's location.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the translateZ for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateZProperty() {
        return getNodeTransformation().translateZProperty();
    }

    public final void setScaleX(double value) {
        scaleXProperty().set(value);
    }

    public final double getScaleX() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_X
                                            : nodeTransformation.getScaleX();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the X axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     *
     * @return the scaleX for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleXProperty() {
        return getNodeTransformation().scaleXProperty();
    }

    public final void setScaleY(double value) {
        scaleYProperty().set(value);
    }

    public final double getScaleY() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_Y
                                            : nodeTransformation.getScaleY();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the Y axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     *
     * @return the scaleY for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleYProperty() {
        return getNodeTransformation().scaleYProperty();
    }

    public final void setScaleZ(double value) {
        scaleZProperty().set(value);
    }

    public final double getScaleZ() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_Z
                                            : nodeTransformation.getScaleZ();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the Z axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * rectangular bounds formed by taking {@link #boundsInLocalProperty boundsInLocal} and applying
     * all the transforms in the {@link #getTransforms transforms} ObservableList.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the scaleZ for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleZProperty() {
        return getNodeTransformation().scaleZProperty();
    }

    public final void setRotate(double value) {
        rotateProperty().set(value);
    }

    public final double getRotate() {
        return (nodeTransformation == null) ? DEFAULT_ROTATE
                                            : nodeTransformation.getRotate();
    }

    /**
     * Defines the angle of rotation about the {@code Node}'s center, measured in
     * degrees. This is used to rotate the {@code Node}.
     * &lt;p&gt;
     * This rotation factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for rotating the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the rotation occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     * &lt;p&gt;
     * Note that because the pivot point is computed as the center of this
     * {@code Node}'s layout bounds, any change to the layout bounds will cause
     * the pivot point to change, which can move the object. For a leaf node,
     * any change to the geometry will cause the layout bounds to change.
     * For a group node, any change to any of its children, including a
     * change in a child's geometry, clip, effect, position, orientation, or
     * scale, will cause the group's layout bounds to change. If this movement
     * of the pivot point is not
     * desired, applications should instead use the Node's {@link #getTransforms transforms}
     * ObservableList, and add a {@link javafx.scene.transform.Rotate} transform,
     * which has a user-specifiable pivot point.
     *
     * @return the rotate for this {@code Node}
     * @defaultValue 0.0
     */
    public final DoubleProperty rotateProperty() {
        return getNodeTransformation().rotateProperty();
    }

    public final void setRotationAxis(Point3D value) {
        rotationAxisProperty().set(value);
    }

    public final Point3D getRotationAxis() {
        return (nodeTransformation == null)
                ? DEFAULT_ROTATION_AXIS
                : nodeTransformation.getRotationAxis();
    }

    /**
     * Defines the axis of rotation of this {@code Node}.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the rotationAxis for this {@code Node}
     * @defaultValue Rotate.Z_AXIS
     */
    public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
        return getNodeTransformation().rotationAxisProperty();
    }

    /**
     * An affine transform that holds the computed local-to-parent transform.
     * This is the concatenation of all transforms in this node, including all
     * of the convenience transforms.
     * @return the localToParent transform for this {@code Node}
     * @since JavaFX 2.2
     */
    public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
        return getNodeTransformation().localToParentTransformProperty();
    }

    private void invalidateLocalToParentTransform() {
        if (nodeTransformation != null) {
            nodeTransformation.invalidateLocalToParentTransform();
        }
    }

    public final Transform getLocalToParentTransform() {
        return localToParentTransformProperty().get();
    }

    /**
     * An affine transform that holds the computed local-to-scene transform.
     * This is the concatenation of all transforms in this node's parents and
     * in this node, including all of the convenience transforms up to the root.
     * If this node is in a {@link javafx.scene.SubScene}, this property represents
     * transforms up to the subscene, not the root scene.
     *
     * &lt;p&gt;
     * Note that when you register a listener or a binding to this property,
     * it needs to listen for invalidation on all its parents to the root node.
     * This means that registering a listener on this
     * property on many nodes may negatively affect performance of
     * transformation changes in their common parents.
     * &lt;/p&gt;
     *
     * @return the localToScene transform for this {@code Node}
     * @since JavaFX 2.2
     */
    public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
        return getNodeTransformation().localToSceneTransformProperty();
    }

    private void invalidateLocalToSceneTransform() {
        if (nodeTransformation != null) {
            nodeTransformation.invalidateLocalToSceneTransform();
        }
    }

    public final Transform getLocalToSceneTransform() {
        return localToSceneTransformProperty().get();
    }

    private NodeTransformation nodeTransformation;

    private NodeTransformation getNodeTransformation() {
        if (nodeTransformation == null) {
            nodeTransformation = new NodeTransformation();
        }

        return nodeTransformation;
    }

    private boolean hasTransforms() {
        return (nodeTransformation != null)
                &amp;&amp; nodeTransformation.hasTransforms();
    }

    // for tests only
    Transform getCurrentLocalToSceneTransformState() {
        if (nodeTransformation == null ||
                nodeTransformation.localToSceneTransform == null) {
            return null;
        }

        return nodeTransformation.localToSceneTransform.transform;
    }

    private static final double DEFAULT_TRANSLATE_X = 0;
    private static final double DEFAULT_TRANSLATE_Y = 0;
    private static final double DEFAULT_TRANSLATE_Z = 0;
    private static final double DEFAULT_SCALE_X = 1;
    private static final double DEFAULT_SCALE_Y = 1;
    private static final double DEFAULT_SCALE_Z = 1;
    private static final double DEFAULT_ROTATE = 0;
    private static final Point3D DEFAULT_ROTATION_AXIS = Rotate.Z_AXIS;

    private final class NodeTransformation {
        private DoubleProperty translateX;
        private DoubleProperty translateY;
        private DoubleProperty translateZ;
        private DoubleProperty scaleX;
        private DoubleProperty scaleY;
        private DoubleProperty scaleZ;
        private DoubleProperty rotate;
        private ObjectProperty&lt;Point3D&gt; rotationAxis;
        private ObservableList&lt;Transform&gt; transforms;
        private LazyTransformProperty localToParentTransform;
        private LazyTransformProperty localToSceneTransform;
        private int listenerReasons = 0;
        private InvalidationListener localToSceneInvLstnr;

        private InvalidationListener getLocalToSceneInvalidationListener() {
            if (localToSceneInvLstnr == null) {
                localToSceneInvLstnr = observable -&gt; invalidateLocalToSceneTransform();
            }
            return localToSceneInvLstnr;
        }

        public void incListenerReasons() {
            if (listenerReasons == 0) {
                Node n = Node.this.getParent();
                if (n != null) {
                    n.localToSceneTransformProperty().addListener(
                            getLocalToSceneInvalidationListener());
                }
            }
            listenerReasons++;
        }

        public void decListenerReasons() {
            listenerReasons--;
            if (listenerReasons == 0) {
                Node n = Node.this.getParent();
                if (n != null) {
                    n.localToSceneTransformProperty().removeListener(
                            getLocalToSceneInvalidationListener());
                }
                if (localToSceneTransform != null) {
                    localToSceneTransform.validityUnknown();
                }
            }
        }

        public final Transform getLocalToParentTransform() {
            return localToParentTransformProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
            if (localToParentTransform == null) {
                localToParentTransform = new LazyTransformProperty() {
                    @Override
                    protected Transform computeTransform(Transform reuse) {
                        updateLocalToParentTransform();
                        return TransformUtils.immutableTransform(reuse,
                                localToParentTx.getMxx(), localToParentTx.getMxy(), localToParentTx.getMxz(), localToParentTx.getMxt(),
                                localToParentTx.getMyx(), localToParentTx.getMyy(), localToParentTx.getMyz(), localToParentTx.getMyt(),
                                localToParentTx.getMzx(), localToParentTx.getMzy(), localToParentTx.getMzz(), localToParentTx.getMzt());
                    }

                    @Override
                    protected boolean validityKnown() {
                        return true;
                    }

                    @Override
                    protected int computeValidity() {
                        return valid;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;localToParentTransform&quot;;
                    }
                };
            }

            return localToParentTransform;
        }

        public void invalidateLocalToParentTransform() {
            if (localToParentTransform != null) {
                localToParentTransform.invalidate();
            }
        }

        public final Transform getLocalToSceneTransform() {
            return localToSceneTransformProperty().get();
        }

        class LocalToSceneTransformProperty extends LazyTransformProperty {
            // need this to track number of listeners
            private List localToSceneListeners;
            // stamps to watch for parent changes when the listeners
            // are not present
            private long stamp, parentStamp;

            @Override
            protected Transform computeTransform(Transform reuse) {
                stamp++;
                updateLocalToParentTransform();

                Node parentNode = Node.this.getParent();
                if (parentNode != null) {
                    final LocalToSceneTransformProperty parentProperty =
                            (LocalToSceneTransformProperty) parentNode.localToSceneTransformProperty();
                    final Transform parentTransform = parentProperty.getInternalValue();

                    parentStamp = parentProperty.stamp;

                    return TransformUtils.immutableTransform(reuse,
                            parentTransform,
                            ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
                } else {
                    return TransformUtils.immutableTransform(reuse,
                            ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
                }
            }

            @Override
            public Object getBean() {
                return Node.this;
            }

            @Override
            public String getName() {
                return &quot;localToSceneTransform&quot;;
            }

            @Override
            protected boolean validityKnown() {
                return listenerReasons &gt; 0;
            }

            @Override
            protected int computeValidity() {
                if (valid != VALIDITY_UNKNOWN) {
                    return valid;
                }

                Node n = (Node) getBean();
                Node parent = n.getParent();

                if (parent != null) {
                    final LocalToSceneTransformProperty parentProperty =
                            (LocalToSceneTransformProperty) parent.localToSceneTransformProperty();

                    if (parentStamp != parentProperty.stamp) {
                        valid = INVALID;
                        return INVALID;
                    }

                    int parentValid = parentProperty.computeValidity();
                    if (parentValid == INVALID) {
                        valid = INVALID;
                    }
                    return parentValid;
                }

                // Validity unknown for root means it is valid
                return VALID;
            }

            @Override
            public void addListener(InvalidationListener listener) {
                incListenerReasons();
                if (localToSceneListeners == null) {
                    localToSceneListeners = new LinkedList&lt;Object&gt;();
                }
                localToSceneListeners.add(listener);
                super.addListener(listener);
            }

            @Override
            public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
                incListenerReasons();
                if (localToSceneListeners == null) {
                    localToSceneListeners = new LinkedList&lt;Object&gt;();
                }
                localToSceneListeners.add(listener);
                super.addListener(listener);
            }

            @Override
            public void removeListener(InvalidationListener listener) {
                if (localToSceneListeners != null &amp;&amp;
                        localToSceneListeners.remove(listener)) {
                    decListenerReasons();
                }
                super.removeListener(listener);
            }

            @Override
            public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
                if (localToSceneListeners != null &amp;&amp;
                        localToSceneListeners.remove(listener)) {
                    decListenerReasons();
                }
                super.removeListener(listener);
            }
        }

        public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
            if (localToSceneTransform == null) {
                localToSceneTransform = new LocalToSceneTransformProperty();
            }

            return localToSceneTransform;
        }

        public void invalidateLocalToSceneTransform() {
            if (localToSceneTransform != null) {
                localToSceneTransform.invalidate();
            }
        }

        public double getTranslateX() {
            return (translateX == null) ? DEFAULT_TRANSLATE_X
                                        : translateX.get();
        }

        public final DoubleProperty translateXProperty() {
            if (translateX == null) {
                translateX = new StyleableDoubleProperty(DEFAULT_TRANSLATE_X) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_X;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateX&quot;;
                    }
                };
            }
            return translateX;
        }

        public double getTranslateY() {
            return (translateY == null) ? DEFAULT_TRANSLATE_Y : translateY.get();
        }

        public final DoubleProperty translateYProperty() {
            if (translateY == null) {
                translateY = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Y) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_Y;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateY&quot;;
                    }
                };
            }
            return translateY;
        }

        public double getTranslateZ() {
            return (translateZ == null) ? DEFAULT_TRANSLATE_Z : translateZ.get();
        }

        public final DoubleProperty translateZProperty() {
            if (translateZ == null) {
                translateZ = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Z) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_Z;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateZ&quot;;
                    }
                };
            }
            return translateZ;
        }

        public double getScaleX() {
            return (scaleX == null) ? DEFAULT_SCALE_X : scaleX.get();
        }

        public final DoubleProperty scaleXProperty() {
            if (scaleX == null) {
                scaleX = new StyleableDoubleProperty(DEFAULT_SCALE_X) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_X;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleX&quot;;
                    }
                };
            }
            return scaleX;
        }

        public double getScaleY() {
            return (scaleY == null) ? DEFAULT_SCALE_Y : scaleY.get();
        }

        public final DoubleProperty scaleYProperty() {
            if (scaleY == null) {
                scaleY = new StyleableDoubleProperty(DEFAULT_SCALE_Y) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_Y;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleY&quot;;
                    }
                };
            }
            return scaleY;
        }

        public double getScaleZ() {
            return (scaleZ == null) ? DEFAULT_SCALE_Z : scaleZ.get();
        }

        public final DoubleProperty scaleZProperty() {
            if (scaleZ == null) {
                scaleZ = new StyleableDoubleProperty(DEFAULT_SCALE_Z) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_Z;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleZ&quot;;
                    }
                };
            }
            return scaleZ;
        }

        public double getRotate() {
            return (rotate == null) ? DEFAULT_ROTATE : rotate.get();
        }

        public final DoubleProperty rotateProperty() {
            if (rotate == null) {
                rotate = new StyleableDoubleProperty(DEFAULT_ROTATE) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.ROTATE;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;rotate&quot;;
                    }
                };
            }
            return rotate;
        }

        public Point3D getRotationAxis() {
            return (rotationAxis == null) ? DEFAULT_ROTATION_AXIS
                                          : rotationAxis.get();
        }

        public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
            if (rotationAxis == null) {
                rotationAxis = new ObjectPropertyBase&lt;Point3D&gt;(
                                           DEFAULT_ROTATION_AXIS) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;rotationAxis&quot;;
                    }
                };
            }
            return rotationAxis;
        }

        public ObservableList&lt;Transform&gt; getTransforms() {
            if (transforms == null) {
                transforms = new TrackableObservableList&lt;Transform&gt;() {
                    @Override
                    protected void onChanged(Change&lt;Transform&gt; c) {
                        while (c.next()) {
                            for (Transform t : c.getRemoved()) {
                                TransformHelper.remove(t, Node.this);
                            }
                            for (Transform t : c.getAddedSubList()) {
                                TransformHelper.add(t, Node.this);
                            }
                        }

                        NodeHelper.transformsChanged(Node.this);
                    }
                };
            }

            return transforms;
        }

        public boolean canSetTranslateX() {
            return (translateX == null) || !translateX.isBound();
        }

        public boolean canSetTranslateY() {
            return (translateY == null) || !translateY.isBound();
        }

        public boolean canSetTranslateZ() {
            return (translateZ == null) || !translateZ.isBound();
        }

        public boolean canSetScaleX() {
            return (scaleX == null) || !scaleX.isBound();
        }

        public boolean canSetScaleY() {
            return (scaleY == null) || !scaleY.isBound();
        }

        public boolean canSetScaleZ() {
            return (scaleZ == null) || !scaleZ.isBound();
        }

        public boolean canSetRotate() {
            return (rotate == null) || !rotate.isBound();
        }

        public boolean hasTransforms() {
            return (transforms != null &amp;&amp; !transforms.isEmpty());
        }

        public boolean hasScaleOrRotate() {
            if (scaleX != null &amp;&amp; scaleX.get() != DEFAULT_SCALE_X) {
                return true;
            }
            if (scaleY != null &amp;&amp; scaleY.get() != DEFAULT_SCALE_Y) {
                return true;
            }
            if (scaleZ != null &amp;&amp; scaleZ.get() != DEFAULT_SCALE_Z) {
                return true;
            }
            if (rotate != null &amp;&amp; rotate.get() != DEFAULT_ROTATE) {
                return true;
            }
            return false;
        }

    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

    /***************************************************************************
     *                                                                         *
     *                        Event Handler Properties                         *
     *                                                                         *
     **************************************************************************/

    private EventHandlerProperties eventHandlerProperties;

    private EventHandlerProperties getEventHandlerProperties() {
        if (eventHandlerProperties == null) {
            eventHandlerProperties =
                    new EventHandlerProperties(
                        getInternalEventDispatcher().getEventHandlerManager(),
                        this);
        }

        return eventHandlerProperties;
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private static final byte EFFECTIVE_ORIENTATION_LTR = 0;
    private static final byte EFFECTIVE_ORIENTATION_RTL = 1;
    private static final byte EFFECTIVE_ORIENTATION_MASK = 1;
    private static final byte AUTOMATIC_ORIENTATION_LTR = 0;
    private static final byte AUTOMATIC_ORIENTATION_RTL = 2;
    private static final byte AUTOMATIC_ORIENTATION_MASK = 2;

    private byte resolvedNodeOrientation =
            EFFECTIVE_ORIENTATION_LTR | AUTOMATIC_ORIENTATION_LTR;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? NodeOrientation.INHERIT : nodeOrientation.get();
    }
    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(NodeOrientation.INHERIT) {
                @Override
                protected void invalidated() {
                    nodeResolvedOrientationInvalidated();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }

            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        return (getEffectiveOrientation(resolvedNodeOrientation)
<A NAME="13"></A>                    == EFFECTIVE_ORIENTATION_LTR)
                       ? NodeOrientation.LEFT_TO_RIGHT
                       : NodeOrientation.RIGHT_TO_LEFT;
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#13',2,'match42-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * The effective orientation of a node resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the node orientation for this {@code Node}
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    /**
     * Determines whether a node should be mirrored when node orientation
     * is right-to-left.
     * &lt;p&gt;
     * When a node is mirrored, the origin is automatically moved to the
     * top right corner causing the node to layout children and draw from
     * right to left using a mirroring transformation.  Some nodes may wish
     * to draw from right to left without using a transformation.  These
     * nodes will will answer {@code false} and implement right-to-left
     * orientation without using the automatic transformation.
     * &lt;/p&gt;
     * @return true if this {@code Node} should be mirrored
     * @since JavaFX 8.0
     */
    public boolean usesMirroring() {
        return true;
    }

    final void parentResolvedOrientation</B></FONT>Invalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            nodeResolvedOrientationInvalidated();
        } else {
            // mirroring changed
            NodeHelper.transformsChanged(this);
        }
    }

    final void nodeResolvedOrientationInvalidated() {
        final byte oldResolvedNodeOrientation =
                resolvedNodeOrientation;

        resolvedNodeOrientation =
                (byte) (calcEffectiveNodeOrientation()
                            | calcAutomaticNodeOrientation());

        if ((effectiveNodeOrientationProperty != null)
                &amp;&amp; (getEffectiveOrientation(resolvedNodeOrientation)
                        != getEffectiveOrientation(
                               oldResolvedNodeOrientation))) {
            effectiveNodeOrientationProperty.invalidate();
        }

        // mirroring changed
        NodeHelper.transformsChanged(this);

        if (resolvedNodeOrientation != oldResolvedNodeOrientation) {
            nodeResolvedOrientationChanged();
        }
    }

    void nodeResolvedOrientationChanged() {
        // overriden in Parent
    }

    private Node getMirroringOrientationParent() {
        Node parentValue = getParent();
        while (parentValue != null) {
            if (parentValue.usesMirroring()) {
                return parentValue;
            }
            parentValue = parentValue.getParent();
        }

        final Node subSceneValue = getSubScene();
        if (subSceneValue != null) {
            return subSceneValue;
        }

        return null;
    }

    private Node getOrientationParent() {
        final Node parentValue = getParent();
        if (parentValue != null) {
            return parentValue;
        }

        final Node subSceneValue = getSubScene();
        if (subSceneValue != null) {
            return subSceneValue;
        }

        return null;
    }

    private byte calcEffectiveNodeOrientation() {
        final NodeOrientation nodeOrientationValue = getNodeOrientation();
        if (nodeOrientationValue != NodeOrientation.INHERIT) {
            return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
                       ? EFFECTIVE_ORIENTATION_LTR
                       : EFFECTIVE_ORIENTATION_RTL;
        }

        final Node parentValue = getOrientationParent();
        if (parentValue != null) {
            return getEffectiveOrientation(parentValue.resolvedNodeOrientation);
        }

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            return (sceneValue.getEffectiveNodeOrientation()
                        == NodeOrientation.LEFT_TO_RIGHT)
                           ? EFFECTIVE_ORIENTATION_LTR
                           : EFFECTIVE_ORIENTATION_RTL;
        }

        return EFFECTIVE_ORIENTATION_LTR;
    }

    private byte calcAutomaticNodeOrientation() {
        if (!usesMirroring()) {
            return AUTOMATIC_ORIENTATION_LTR;
        }

        final NodeOrientation nodeOrientationValue = getNodeOrientation();
        if (nodeOrientationValue != NodeOrientation.INHERIT) {
            return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
                       ? AUTOMATIC_ORIENTATION_LTR
                       : AUTOMATIC_ORIENTATION_RTL;
        }

        final Node parentValue = getMirroringOrientationParent();
        if (parentValue != null) {
            // automatic node orientation is inherited
            return getAutomaticOrientation(parentValue.resolvedNodeOrientation);
        }

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            return (sceneValue.getEffectiveNodeOrientation()
                        == NodeOrientation.LEFT_TO_RIGHT)
                           ? AUTOMATIC_ORIENTATION_LTR
                           : AUTOMATIC_ORIENTATION_RTL;
        }

        return AUTOMATIC_ORIENTATION_LTR;
    }

    // Return true if the node needs to be mirrored.
    // A node has mirroring if the orientation differs from the parent
    // package private for testing
    final boolean hasMirroring() {
        final Node parentValue = getOrientationParent();

        final byte thisOrientation =
                getAutomaticOrientation(resolvedNodeOrientation);
        final byte parentOrientation =
                (parentValue != null)
                    ? getAutomaticOrientation(
                          parentValue.resolvedNodeOrientation)
                    : AUTOMATIC_ORIENTATION_LTR;

        return thisOrientation != parentOrientation;
    }

    private static byte getEffectiveOrientation(
            final byte resolvedNodeOrientation) {
        return (byte) (resolvedNodeOrientation &amp; EFFECTIVE_ORIENTATION_MASK);
    }

    private static byte getAutomaticOrientation(
            final byte resolvedNodeOrientation) {
        return (byte) (resolvedNodeOrientation &amp; AUTOMATIC_ORIENTATION_MASK);
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    /***************************************************************************
     *                                                                         *
     *                       Misc Seldom Used Properties                       *
     *                                                                         *
     **************************************************************************/

    private MiscProperties miscProperties;

    private MiscProperties getMiscProperties() {
        if (miscProperties == null) {
            miscProperties = new MiscProperties();
        }

        return miscProperties;
    }

    private static final double DEFAULT_VIEW_ORDER = 0;
    private static final boolean DEFAULT_CACHE = false;
    private static final CacheHint DEFAULT_CACHE_HINT = CacheHint.DEFAULT;
    private static final Node DEFAULT_CLIP = null;
    private static final Cursor DEFAULT_CURSOR = null;
    private static final DepthTest DEFAULT_DEPTH_TEST = DepthTest.INHERIT;
    private static final boolean DEFAULT_DISABLE = false;
    private static final Effect DEFAULT_EFFECT = null;
    private static final InputMethodRequests DEFAULT_INPUT_METHOD_REQUESTS =
            null;
    private static final boolean DEFAULT_MOUSE_TRANSPARENT = false;

    private final class MiscProperties {
        private LazyBoundsProperty boundsInParent;
        private LazyBoundsProperty boundsInLocal;
        private BooleanProperty cache;
        private ObjectProperty&lt;CacheHint&gt; cacheHint;
        private ObjectProperty&lt;Node&gt; clip;
        private ObjectProperty&lt;Cursor&gt; cursor;
        private ObjectProperty&lt;DepthTest&gt; depthTest;
        private BooleanProperty disable;
        private ObjectProperty&lt;Effect&gt; effect;
        private ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequests;
        private BooleanProperty mouseTransparent;
        private DoubleProperty viewOrder;

        public double getViewOrder() {
            return (viewOrder == null) ? DEFAULT_VIEW_ORDER : viewOrder.get();
        }

        public final DoubleProperty viewOrderProperty() {
            if (viewOrder == null) {
                viewOrder = new StyleableDoubleProperty(DEFAULT_VIEW_ORDER) {
                    @Override
                    public void invalidated() {
                        Parent p = getParent();
                        if (p != null) {
                            // Parent will be responsible to update sorted children list
                            p.markViewOrderChildrenDirty();
                        }
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_VIEW_ORDER);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.VIEW_ORDER;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;viewOrder&quot;;
                    }
                };
            }
            return viewOrder;
        }

        public final Bounds getBoundsInParent() {
            return boundsInParentProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
            if (boundsInParent == null) {
                boundsInParent = new LazyBoundsProperty() {
                    /**
                     * Computes the bounds including the clip, effects, and all
                     * transforms. This function is essentially how to compute
                     * the boundsInParent. Optimizations are made to compute as
                     * little as possible and create as little trash as
                     * possible.
                     */
                    @Override
                    protected Bounds computeBounds() {
                        BaseBounds tempBounds = TempState.getInstance().bounds;
                        tempBounds = getTransformedBounds(
                                             tempBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
                        return new BoundingBox(tempBounds.getMinX(),
                                               tempBounds.getMinY(),
                                               tempBounds.getMinZ(),
                                               tempBounds.getWidth(),
                                               tempBounds.getHeight(),
                                               tempBounds.getDepth());
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;boundsInParent&quot;;
                    }
                };
            }

            return boundsInParent;
        }

        public void invalidateBoundsInParent() {
            if (boundsInParent != null) {
                boundsInParent.invalidate();
            }
        }

        public final Bounds getBoundsInLocal() {
            return boundsInLocalProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
            if (boundsInLocal == null) {
                boundsInLocal = new LazyBoundsProperty() {
                    @Override
                    protected Bounds computeBounds() {
                        BaseBounds tempBounds = TempState.getInstance().bounds;
                        tempBounds = getLocalBounds(
                                             tempBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
                        return new BoundingBox(tempBounds.getMinX(),
                                               tempBounds.getMinY(),
                                               tempBounds.getMinZ(),
                                               tempBounds.getWidth(),
                                               tempBounds.getHeight(),
                                               tempBounds.getDepth());
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;boundsInLocal&quot;;
                    }
                };
            }

            return boundsInLocal;
        }

        public void invalidateBoundsInLocal() {
            if (boundsInLocal != null) {
                boundsInLocal.invalidate();
            }
        }

        public final boolean isCache() {
            return (cache == null) ? DEFAULT_CACHE
                                   : cache.get();
        }

        public final BooleanProperty cacheProperty() {
            if (cache == null) {
                cache = new BooleanPropertyBase(DEFAULT_CACHE) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cache&quot;;
                    }
                };
            }
            return cache;
        }

        public final CacheHint getCacheHint() {
            return (cacheHint == null) ? DEFAULT_CACHE_HINT
                                       : cacheHint.get();
        }

        public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
            if (cacheHint == null) {
                cacheHint = new ObjectPropertyBase&lt;CacheHint&gt;(DEFAULT_CACHE_HINT) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cacheHint&quot;;
                    }
                };
            }
            return cacheHint;
        }

        public final Node getClip() {
            return (clip == null) ? DEFAULT_CLIP : clip.get();
        }

        public final ObjectProperty&lt;Node&gt; clipProperty() {
            if (clip == null) {
                clip = new ObjectPropertyBase&lt;Node&gt;(DEFAULT_CLIP) {

                    //temp variables used when clip was invalid to rollback to
                    // last value
                    private Node oldClip;

                    @Override
                    protected void invalidated() {
                        final Node newClip = get();
                        if ((newClip != null)
                                &amp;&amp; ((newClip.isConnected()
                                           &amp;&amp; newClip.clipParent != Node.this)
                                       || wouldCreateCycle(Node.this,
                                                           newClip))) {
                            // Assigning this node to clip is illegal.
                            // Roll back to the previous state and throw an
                            // exception.
                            final String cause =
                                    newClip.isConnected()
                                        &amp;&amp; (newClip.clipParent != Node.this)
                                            ? &quot;node already connected&quot;
                                            : &quot;cycle detected&quot;;

                            if (isBound()) {
                                unbind();
                                set(oldClip);
                                throw new IllegalArgumentException(
                                        &quot;Node's clip set to incorrect value &quot;
                                            + &quot; through binding&quot;
                                            + &quot; (&quot; + cause + &quot;, node  = &quot;
                                                   + Node.this + &quot;, clip = &quot;
                                                   + clip + &quot;).&quot;
                                            + &quot; Binding has been removed.&quot;);
                            } else {
                                set(oldClip);
                                throw new IllegalArgumentException(
                                        &quot;Node's clip set to incorrect value&quot;
                                            + &quot; (&quot; + cause + &quot;, node  = &quot;
                                                   + Node.this + &quot;, clip = &quot;
                                                   + clip + &quot;).&quot;);
                            }
                        } else {
                            if (oldClip != null) {
                                oldClip.clipParent = null;
                                oldClip.setScenes(null, null);
                                oldClip.updateTreeVisible(false);
                            }

                            if (newClip != null) {
                                newClip.clipParent = Node.this;
                                newClip.setScenes(getScene(), getSubScene());
                                newClip.updateTreeVisible(true);
                            }

                            NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);

                            // the local bounds have (probably) changed
                            localBoundsChanged();

                            oldClip = newClip;
                        }
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;clip&quot;;
                    }
                };
            }
            return clip;
        }

        public final Cursor getCursor() {
            return (cursor == null) ? DEFAULT_CURSOR : cursor.get();
        }

        public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
            if (cursor == null) {
                cursor = new StyleableObjectProperty&lt;Cursor&gt;(DEFAULT_CURSOR) {

                    @Override
                    protected void invalidated() {
                        final Scene sceneValue = getScene();
                        if (sceneValue != null) {
                            sceneValue.markCursorDirty();
                        }
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.CURSOR;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cursor&quot;;
                    }

                };
            }
            return cursor;
        }

        public final DepthTest getDepthTest() {
            return (depthTest == null) ? DEFAULT_DEPTH_TEST
                                       : depthTest.get();
        }

        public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
            if (depthTest == null) {
                depthTest = new ObjectPropertyBase&lt;DepthTest&gt;(DEFAULT_DEPTH_TEST) {
                    @Override protected void invalidated() {
                        computeDerivedDepthTest();
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;depthTest&quot;;
                    }
                };
            }
            return depthTest;
        }

        public final boolean isDisable() {
            return (disable == null) ? DEFAULT_DISABLE : disable.get();
        }

        public final BooleanProperty disableProperty() {
            if (disable == null) {
                disable = new BooleanPropertyBase(DEFAULT_DISABLE) {
                    @Override
                    protected void invalidated() {
                        updateDisabled();
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;disable&quot;;
                    }
                };
            }
            return disable;
        }

        public final Effect getEffect() {
            return (effect == null) ? DEFAULT_EFFECT : effect.get();
        }

        public final ObjectProperty&lt;Effect&gt; effectProperty() {
            if (effect == null) {
                effect = new StyleableObjectProperty&lt;Effect&gt;(DEFAULT_EFFECT) {
                    private Effect oldEffect = null;
                    private int oldBits;

                    private final AbstractNotifyListener effectChangeListener =
                            new AbstractNotifyListener() {

                        @Override
                        public void invalidated(Observable valueModel) {
                            int newBits = ((IntegerProperty) valueModel).get();
                            int changedBits = newBits ^ oldBits;
                            oldBits = newBits;
                            if (EffectDirtyBits.isSet(
                                    changedBits,
                                    EffectDirtyBits.EFFECT_DIRTY)
                                &amp;&amp; EffectDirtyBits.isSet(
                                       newBits,
                                       EffectDirtyBits.EFFECT_DIRTY)) {
                                NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
                            }
                            if (EffectDirtyBits.isSet(
                                    changedBits,
                                    EffectDirtyBits.BOUNDS_CHANGED)) {
                                localBoundsChanged();
                            }
                        }
                    };

                    @Override
                    protected void invalidated() {
                        Effect _effect = get();
                        if (oldEffect != null) {
                            EffectHelper.effectDirtyProperty(oldEffect).removeListener(
                                    effectChangeListener.getWeakListener());
                        }
                        oldEffect = _effect;
                        if (_effect != null) {
                            EffectHelper.effectDirtyProperty(_effect)
                                   .addListener(
                                       effectChangeListener.getWeakListener());
                            if (EffectHelper.isEffectDirty(_effect)) {
                                NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
                            }
                            oldBits = EffectHelper.effectDirtyProperty(_effect).get();
                        }

                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_EFFECT);
                        // bounds may have changed regardless whether
                        // the dirty flag on effect is set
                        localBoundsChanged();
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.EFFECT;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;effect&quot;;
                    }
                };
            }
            return effect;
        }

        public final InputMethodRequests getInputMethodRequests() {
            return (inputMethodRequests == null) ? DEFAULT_INPUT_METHOD_REQUESTS
                                                 : inputMethodRequests.get();
        }

        public ObjectProperty&lt;InputMethodRequests&gt;
                inputMethodRequestsProperty() {
            if (inputMethodRequests == null) {
                inputMethodRequests =
                        new SimpleObjectProperty&lt;InputMethodRequests&gt;(
                                Node.this,
                                &quot;inputMethodRequests&quot;,
                                DEFAULT_INPUT_METHOD_REQUESTS);
            }
            return inputMethodRequests;
        }

        public final boolean isMouseTransparent() {
            return (mouseTransparent == null) ? DEFAULT_MOUSE_TRANSPARENT
                                              : mouseTransparent.get();
        }

        public final BooleanProperty mouseTransparentProperty() {
            if (mouseTransparent == null) {
                mouseTransparent =
                        new SimpleBooleanProperty(
                                Node.this,
                                &quot;mouseTransparent&quot;,
                                DEFAULT_MOUSE_TRANSPARENT);
            }
            return mouseTransparent;
        }

        public boolean canSetCursor() {
            return (cursor == null) || !cursor.isBound();
        }

        public boolean canSetEffect() {
            return (effect == null) || !effect.isBound();
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    public final void setMouseTransparent(boolean value) {
        mouseTransparentProperty().set(value);
    }

    public final boolean isMouseTransparent() {
        return (miscProperties == null) ? DEFAULT_MOUSE_TRANSPARENT
                                        : miscProperties.isMouseTransparent();
    }

    /**
     * If {@code true}, this node (together with all its children) is completely
     * transparent to mouse events. When choosing target for mouse event, nodes
     * with {@code mouseTransparent} set to {@code true} and their subtrees
     * won't be taken into account.
     * @return is this {@code Node} (together with all its children) is completely
     * transparent to mouse events.
     */
    public final BooleanProperty mouseTransparentProperty() {
        return getMiscProperties().mouseTransparentProperty();
    }

    /**
     * Whether or not this {@code Node} is being hovered over. Typically this is
     * due to the mouse being over the node, though it could be due to a pen
     * hovering on a graphics tablet or other form of input.
     *
     * &lt;p&gt;Note that current implementation of hover relies on mouse enter and
     * exit events to determine whether this Node is in the hover state; this
     * means that this feature is currently supported only on systems that
     * have a mouse. Future implementations may provide alternative means of
     * supporting hover.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper hover;

    protected final void setHover(boolean value) {
        hoverPropertyImpl().set(value);
    }

    public final boolean isHover() {
        return hover == null ? false : hover.get();
    }

    public final ReadOnlyBooleanProperty hoverProperty() {
        return hoverPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper hoverPropertyImpl() {
        if (hover == null) {
            hover = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    PlatformLogger logger = Logging.getInputLogger();
                    if (logger.isLoggable(Level.FINER)) {
                        logger.finer(this + &quot; hover=&quot; + get());
                    }
                    pseudoClassStateChanged(HOVER_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;hover&quot;;
                }
            };
        }
        return hover;
    }

    /**
     * Whether or not the {@code Node} is pressed. Typically this is true when
     * the primary mouse button is down, though subclasses may define other
     * mouse button state or key state to cause the node to be &quot;pressed&quot;.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper pressed;

    protected final void setPressed(boolean value) {
        pressedPropertyImpl().set(value);
    }

    public final boolean isPressed() {
        return pressed == null ? false : pressed.get();
    }

    public final ReadOnlyBooleanProperty pressedProperty() {
        return pressedPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper pressedPropertyImpl() {
        if (pressed == null) {
            pressed = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    PlatformLogger logger = Logging.getInputLogger();
                    if (logger.isLoggable(Level.FINER)) {
                        logger.finer(this + &quot; pressed=&quot; + get());
                    }
                    pseudoClassStateChanged(PRESSED_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;pressed&quot;;
                }
            };
        }
        return pressed;
    }

    public final void setOnContextMenuRequested(
            EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.onContextMenuRequested();
    }

    /**
     * Defines a function to be called when a context menu
     * has been requested on this {@code Node}.
     * @return the event handler that is called when a context menu has been
     * requested on this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;
            onContextMenuRequestedProperty() {
        return getEventHandlerProperties().onContextMenuRequestedProperty();
    }

    public final void setOnMouseClicked(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseClicked();
    }

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * clicked (pressed and released) on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseClickedProperty() {
        return getEventHandlerProperties().onMouseClickedProperty();
    }

    public final void setOnMouseDragged(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragged();
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Node} and then dragged.
     * @return the event handler that is called when a mouse button is pressed
     * on this {@code Node} and then dragged
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseDraggedProperty() {
        return getEventHandlerProperties().onMouseDraggedProperty();
    }

    public final void setOnMouseEntered(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseEntered();
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Node}.
     * @return the event handler that is called when a mouse enters this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseEnteredProperty() {
        return getEventHandlerProperties().onMouseEnteredProperty();
    }

    public final void setOnMouseExited(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseExited();
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Node}.
     * @return the event handler that is called when a mouse exits this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseExitedProperty() {
        return getEventHandlerProperties().onMouseExitedProperty();
    }

    public final void setOnMouseMoved(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseMoved();
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Node} but no buttons have been pushed.
     * @return the event handler that is called when a mouse cursor moves
     * within this {@code Node} but no buttons have been pushed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseMovedProperty() {
        return getEventHandlerProperties().onMouseMovedProperty();
    }

    public final void setOnMousePressed(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMousePressed();
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * pressed on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMousePressedProperty() {
        return getEventHandlerProperties().onMousePressedProperty();
    }

    public final void setOnMouseReleased(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseReleased();
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * released on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseReleasedProperty() {
        return getEventHandlerProperties().onMouseReleasedProperty();
    }

    public final void setOnDragDetected(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDetected();
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     * @return the event handler that is called when drag gesture has been
     * detected
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onDragDetectedProperty() {
        return getEventHandlerProperties().onDragDetectedProperty();
    }

    public final void setOnMouseDragOver(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragOver();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture progresses within this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragOverProperty() {
        return getEventHandlerProperties().onMouseDragOverProperty();
    }

    public final void setOnMouseDragReleased(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragReleased();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends (by releasing mouse button) within this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture ends (by releasing mouse button) within this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragReleasedProperty() {
        return getEventHandlerProperties().onMouseDragReleasedProperty();
    }

    public final void setOnMouseDragEntered(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragEntered();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture enters this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragEnteredProperty() {
        return getEventHandlerProperties().onMouseDragEnteredProperty();
    }

    public final void setOnMouseDragExited(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragExited();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * leaves this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture leaves this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragExitedProperty() {
        return getEventHandlerProperties().onMouseDragExitedProperty();
    }


    /* *************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    public final void setOnScrollStarted(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScrollStarted();
    }

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @return the event handler that is called when a scrolling gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollStartedProperty() {
        return getEventHandlerProperties().onScrollStartedProperty();
    }

    public final void setOnScroll(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScroll();
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     * @return the event handler that is called when user performs a scrolling
     * action
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollProperty() {
        return getEventHandlerProperties().onScrollProperty();
    }

    public final void setOnScrollFinished(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScrollFinished();
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @return the event handler that is called when a scrolling gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollFinishedProperty() {
        return getEventHandlerProperties().onScrollFinishedProperty();
    }

    public final void setOnRotationStarted(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotationStarted();
    }

    /**
     * Defines a function to be called when a rotation gesture is detected.
     * @return the event handler that is called when a rotation gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotationStartedProperty() {
        return getEventHandlerProperties().onRotationStartedProperty();
    }

    public final void setOnRotate(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotate();
    }

    /**
     * Defines a function to be called when user performs a rotation action.
     * @return the event handler that is called when user performs a rotation
     * action
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotateProperty() {
        return getEventHandlerProperties().onRotateProperty();
    }

    public final void setOnRotationFinished(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotationFinished();
    }

    /**
     * Defines a function to be called when a rotation gesture ends.
     * @return the event handler that is called when a rotation gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotationFinishedProperty() {
        return getEventHandlerProperties().onRotationFinishedProperty();
    }

    public final void setOnZoomStarted(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoomStarted();
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @return the event handler that is called when a zooming gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomStartedProperty() {
        return getEventHandlerProperties().onZoomStartedProperty();
    }

    public final void setOnZoom(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoom();
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @return the event handler that is called when user performs a zooming
     * action
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomProperty() {
        return getEventHandlerProperties().onZoomProperty();
    }

    public final void setOnZoomFinished(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoomFinished();
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @return the event handler that is called when a zooming gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomFinishedProperty() {
        return getEventHandlerProperties().onZoomFinishedProperty();
    }

    public final void setOnSwipeUp(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeUp();
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when an upward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeUpProperty() {
        return getEventHandlerProperties().onSwipeUpProperty();
    }

    public final void setOnSwipeDown(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeDown();
    }

    /**
     * Defines a function to be called when a downward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when a downward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeDownProperty() {
        return getEventHandlerProperties().onSwipeDownProperty();
    }

    public final void setOnSwipeLeft(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeLeft();
    }

    /**
     * Defines a function to be called when a leftward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when a leftward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeLeftProperty() {
        return getEventHandlerProperties().onSwipeLeftProperty();
    }

    public final void setOnSwipeRight(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeRight();
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when an rightward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeRightProperty() {
        return getEventHandlerProperties().onSwipeRightProperty();
    }


    /* *************************************************************************
     *                                                                         *
     *                             Touch Handling                              *
     *                                                                         *
     **************************************************************************/

    public final void setOnTouchPressed(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchPressed();
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @return the event handler that is called when a new touch point is pressed
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchPressedProperty() {
        return getEventHandlerProperties().onTouchPressedProperty();
    }

    public final void setOnTouchMoved(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchMoved();
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @return the event handler that is called when a touch point is moved
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchMovedProperty() {
        return getEventHandlerProperties().onTouchMovedProperty();
    }

    public final void setOnTouchReleased(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchReleased();
    }

    /**
     * Defines a function to be called when a touch point is released.
     * @return the event handler that is called when a touch point is released
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchReleasedProperty() {
        return getEventHandlerProperties().onTouchReleasedProperty();
    }

    public final void setOnTouchStationary(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchStationary();
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @return the event handler that is called when a touch point stays pressed
     * and still
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchStationaryProperty() {
        return getEventHandlerProperties().onTouchStationaryProperty();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    public final void setOnKeyPressed(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyPressed();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been pressed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyPressedProperty() {
        return getEventHandlerProperties().onKeyPressedProperty();
    }

    public final void setOnKeyReleased(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyReleased();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been released
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyReleasedProperty() {
        return getEventHandlerProperties().onKeyReleasedProperty();
    }

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyTyped();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been typed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyTypedProperty() {
        return getEventHandlerProperties().onKeyTypedProperty();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set(value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt;
            getOnInputMethodTextChanged() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnInputMethodTextChanged();
    }

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     * &lt;/p&gt;
     * @return the event handler that is called when this {@code Node} has input
     * focus and the input method text has changed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;
            onInputMethodTextChangedProperty() {
        return getEventHandlerProperties().onInputMethodTextChangedProperty();
    }

    public final void setInputMethodRequests(InputMethodRequests value) {
        inputMethodRequestsProperty().set(value);
    }

    public final InputMethodRequests getInputMethodRequests() {
        return (miscProperties == null)
                       ? DEFAULT_INPUT_METHOD_REQUESTS
                       : miscProperties.getInputMethodRequests();
    }

    /**
     * Property holding InputMethodRequests.
     *
     * @return InputMethodRequestsProperty
     */
    public final ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequestsProperty() {
        return getMiscProperties().inputMethodRequestsProperty();
    }

    /***************************************************************************
     *                                                                         *
     *                             Focus Traversal                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Special boolean property which allows for atomic focus change.
     * Focus change means defocusing the old focus owner and focusing a new
     * one. With a usual property, defocusing the old node fires the value
     * changed event and user code can react with something that breaks
     * focusability of the new node, or even remove the new node from the scene.
     * This leads to various error states. This property allows for setting
     * the state without firing the event. The focus change first sets both
     * properties and then fires both events. This makes the focus change look
     * like an atomic operation - when the old node is notified to loose focus,
     * the new node is already focused.
     */
    final class FocusedProperty extends ReadOnlyBooleanPropertyBase {
        private boolean value;
        private boolean valid = true;
        private boolean needsChangeEvent = false;

        public void store(final boolean value) {
            if (value != this.value) {
                this.value = value;
                markInvalid();
            }
        }

        public void notifyListeners() {
            if (needsChangeEvent) {
                fireValueChangedEvent();
                needsChangeEvent = false;
            }
        }

        private void markInvalid() {
            if (valid) {
                valid = false;

                pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());
                PlatformLogger logger = Logging.getFocusLogger();
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(this + &quot; focused=&quot; + get());
                }

                needsChangeEvent = true;

                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return value;
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;focused&quot;;
        }
    }

    /**
     * Indicates whether this {@code Node} currently has the input focus.
     * To have the input focus, a node must be the {@code Scene}'s focus
     * owner, and the scene must be in a {@code Stage} that is visible
     * and active. See {@link #requestFocus()} for more information.
     *
     * @see #requestFocus()
     * @defaultValue false
     */
    private FocusedProperty focused;

    protected final void setFocused(boolean value) {
        FocusedProperty fp = focusedPropertyImpl();
        if (fp.value != value) {
            fp.store(value);
            fp.notifyListeners();
        }
    }

    public final boolean isFocused() {
        return focused == null ? false : focused.get();
    }

    public final ReadOnlyBooleanProperty focusedProperty() {
        return focusedPropertyImpl();
    }

    private FocusedProperty focusedPropertyImpl() {
        if (focused == null) {
            focused = new FocusedProperty();
        }
        return focused;
    }

    /**
     * Specifies whether this {@code Node} should be a part of focus traversal
     * cycle. When this property is {@code true} focus can be moved to this
     * {@code Node} and from this {@code Node} using regular focus traversal
     * keys. On a desktop such keys are usually {@code TAB} for moving focus
     * forward and {@code SHIFT+TAB} for moving focus backward.
     *
     * When a {@code Scene} is created, the system gives focus to a
     * {@code Node} whose {@code focusTraversable} variable is true
     * and that is eligible to receive the focus,
     * unless the focus had been set explicitly via a call
     * to {@link #requestFocus()}.
     *
     * @see #requestFocus()
     * @defaultValue false
     */
    private BooleanProperty focusTraversable;

    public final void setFocusTraversable(boolean value) {
        focusTraversableProperty().set(value);
    }
    public final boolean isFocusTraversable() {
        return focusTraversable == null ? false : focusTraversable.get();
    }

    public final BooleanProperty focusTraversableProperty() {
        if (focusTraversable == null) {
            focusTraversable = new StyleableBooleanProperty(false) {

                @Override
                public void invalidated() {
                    Scene _scene = getScene();
                    if (_scene != null) {
                        if (get()) {
                            _scene.initializeInternalEventDispatcher();
                        }
                        focusSetDirty(_scene);
                    }
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.FOCUS_TRAVERSABLE;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;focusTraversable&quot;;
                }
            };
        }
        return focusTraversable;
    }

    /**
     * Called when something has changed on this node that *may* have made the
     * scene's focus dirty. This covers the cases where this node is the focus
     * owner and it may have lost eligibility, or it's traversable and it may
     * have gained eligibility. Note that we do not want to use disabled
     * or treeVisible here, as this function is called from their
     * &quot;on invalidate&quot; triggers, and using them will cause them to be
     * revalidated. The pulse will revalidate everything and make the final
     * determination.
     */
    private void focusSetDirty(Scene s) {
        if (s != null &amp;&amp;
            (this == s.getFocusOwner() || isFocusTraversable())) {
                s.setFocusDirty(true);
        }
    }

    /**
     * Requests that this {@code Node} get the input focus, and that this
     * {@code Node}'s top-level ancestor become the focused window. To be
     * eligible to receive the focus, the node must be part of a scene, it and
     * all of its ancestors must be visible, and it must not be disabled.
     * If this node is eligible, this function will cause it to become this
     * {@code Scene}'s &quot;focus owner&quot;. Each scene has at most one focus owner
     * node. The focus owner will not actually have the input focus, however,
     * unless the scene belongs to a {@code Stage} that is both visible
     * and active.
     */
    public void requestFocus() {
        if (getScene() != null) {
            getScene().requestFocus(this);
        }
    }

    /**
     * Traverses from this node in the direction indicated. Note that this
     * node need not actually have the focus, nor need it be focusTraversable.
     * However, the node must be part of a scene, otherwise this request
     * is ignored.
     */
    final boolean traverse(Direction dir) {
        if (getScene() == null) {
            return false;
        }
        return getScene().traverse(this, dir);
    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

     /**
      * Returns a string representation for the object.
      * @return a string representation for the object.
      */
    @Override
    public String toString() {
        String klassName = getClass().getName();
        String simpleName = klassName.substring(klassName.lastIndexOf('.')+1);
        StringBuilder sbuf = new StringBuilder(simpleName);
        boolean hasId = id != null &amp;&amp; !&quot;&quot;.equals(getId());
        boolean hasStyleClass = !getStyleClass().isEmpty();

        if (!hasId) {
            sbuf.append('@');
            sbuf.append(Integer.toHexString(hashCode()));
        } else {
            sbuf.append(&quot;[id=&quot;);
            sbuf.append(getId());
            if (!hasStyleClass) sbuf.append(&quot;]&quot;);
        }
        if (hasStyleClass) {
            if (!hasId) sbuf.append('[');
            else sbuf.append(&quot;, &quot;);
            sbuf.append(&quot;styleClass=&quot;);
            sbuf.append(getStyleClass());
            sbuf.append(&quot;]&quot;);
        }
        return sbuf.toString();
    }

    private void preprocessMouseEvent(MouseEvent e) {
        final EventType&lt;?&gt; eventType = e.getEventType();
        if (eventType == MouseEvent.MOUSE_PRESSED) {
            for (Node n = this; n != null; n = n.getParent()) {
                n.setPressed(e.isPrimaryButtonDown());
            }
            return;
        }
        if (eventType == MouseEvent.MOUSE_RELEASED) {
            for (Node n = this; n != null; n = n.getParent()) {
                n.setPressed(e.isPrimaryButtonDown());
            }
            return;
        }

        if (e.getTarget() == this) {
            // the mouse event types are translated only when the node uses
            // its internal event dispatcher, so both entered / exited variants
            // are possible here

            if ((eventType == MouseEvent.MOUSE_ENTERED)
                    || (eventType == MouseEvent.MOUSE_ENTERED_TARGET)) {
                setHover(true);
                return;
            }

            if ((eventType == MouseEvent.MOUSE_EXITED)
                    || (eventType == MouseEvent.MOUSE_EXITED_TARGET)) {
                setHover(false);
                return;
            }
        }
    }

    void markDirtyLayoutBranch() {
        Parent p = getParent();
        while (p != null &amp;&amp; p.layoutFlag == LayoutFlags.CLEAN) {
            p.setLayoutFlag(LayoutFlags.DIRTY_BRANCH);
            if (p.isSceneRoot()) {
                Toolkit.getToolkit().requestNextPulse();
                if (getSubScene() != null) {
                    getSubScene().setDirtyLayout(p);
                }
            }
            p = p.getParent();
        }

    }

    private boolean isWindowShowing() {
        Scene s = getScene();
        if (s == null) return false;
        Window w = s.getWindow();
        return w != null &amp;&amp; w.isShowing();
    }

    private void updateTreeShowing() {
        setTreeShowing(isTreeVisible() &amp;&amp; isWindowShowing());
    }

    private boolean treeShowing;
    private TreeShowingPropertyReadOnly treeShowingRO;

    final void setTreeShowing(boolean value) {
        if (treeShowing != value) {
            treeShowing = value;
            ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();
        }
    }

    final boolean isTreeShowing() {
        return treeShowingProperty().get();
    }

    final BooleanExpression treeShowingProperty() {
        if (treeShowingRO == null) {
            treeShowingRO = new TreeShowingPropertyReadOnly();
        }
        return treeShowingRO;
    }

    class TreeShowingPropertyReadOnly extends BooleanExpression {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return Node.this.treeShowing;
        }

    }

    private void updateTreeVisible(boolean parentChanged) {
        boolean isTreeVisible = isVisible();
        final Node parentNode = getParent() != null ? getParent() :
                    clipParent != null ? clipParent :
                    getSubScene() != null ? getSubScene() : null;
        if (isTreeVisible) {
            isTreeVisible = parentNode == null || parentNode.isTreeVisible();
        }
        // When the parent has changed to visible and we have unsynchronized visibility,
        // we have to synchronize, because the rendering will now pass through the newly-visible parent
        // Otherwise an invisible Node might get rendered
        if (parentChanged &amp;&amp; parentNode != null &amp;&amp; parentNode.isTreeVisible()
                &amp;&amp; isDirty(DirtyBits.NODE_VISIBLE)) {
            addToSceneDirtyList();
        }
        setTreeVisible(isTreeVisible);

        updateTreeShowing();
    }

    private boolean treeVisible;
    private TreeVisiblePropertyReadOnly treeVisibleRO;

    final void setTreeVisible(boolean value) {
        if (treeVisible != value) {
            treeVisible = value;
            updateCanReceiveFocus();
            focusSetDirty(getScene());
            if (getClip() != null) {
                getClip().updateTreeVisible(true);
            }
            if (treeVisible &amp;&amp; !isDirtyEmpty()) {
                addToSceneDirtyList();
            }
            ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();
            if (Node.this instanceof SubScene) {
                Node subSceneRoot = ((SubScene)Node.this).getRoot();
                if (subSceneRoot != null) {
                    // SubScene.getRoot() is only null if it's constructor
                    // has not finished.
                    subSceneRoot.setTreeVisible(value &amp;&amp; subSceneRoot.isVisible());
                }
            }
        }
    }

    final boolean isTreeVisible() {
        return treeVisibleProperty().get();
    }

    final BooleanExpression treeVisibleProperty() {
        if (treeVisibleRO == null) {
            treeVisibleRO = new TreeVisiblePropertyReadOnly();
        }
        return treeVisibleRO;
    }

    class TreeVisiblePropertyReadOnly extends BooleanExpression {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return Node.this.treeVisible;
        }

    }

    private boolean canReceiveFocus = false;

    private void setCanReceiveFocus(boolean value) {
        canReceiveFocus = value;
    }

    final boolean isCanReceiveFocus() {
        return canReceiveFocus;
    }

    private void updateCanReceiveFocus() {
        setCanReceiveFocus(getScene() != null
          &amp;&amp; !isDisabled()
          &amp;&amp; isTreeVisible());
    }

    // for indenting messages based on scene-graph depth
    String indent() {
        String indent = &quot;&quot;;
        Parent p = this.getParent();
        while (p != null) {
            indent += &quot;  &quot;;
            p = p.getParent();
        }
        return indent;
    }

    /*
     * Should we underline the mnemonic character?
     */
    private BooleanProperty showMnemonics;

    final void setShowMnemonics(boolean value) {
        showMnemonicsProperty().set(value);
    }

    final boolean isShowMnemonics() {
        return showMnemonics == null ? false : showMnemonics.get();
    }

    final BooleanProperty showMnemonicsProperty() {
        if (showMnemonics == null) {
            showMnemonics = new BooleanPropertyBase(false) {

                @Override
                protected void invalidated() {
                    pseudoClassStateChanged(SHOW_MNEMONICS_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;showMnemonics&quot;;
                }
            };
        }
        return showMnemonics;
    }


    /**
     * References a node that is a labelFor this node.
     * Accessible via a NodeAccessor. See Label.labelFor for details.
     */
    private Node labeledBy = null;


    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this node. The default event
     * dispatcher sends the received events to the registered event handlers and
     * filters. When replacing the value with a new {@code EventDispatcher},
     * the new dispatcher should forward events to the replaced dispatcher
     * to maintain the node's default event handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt; eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private NodeEventDispatcher internalEventDispatcher;

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this node. The handler is called when the
     * node receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this node. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .getEventHandlerManager()
                .removeEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this node. The filter is called when the
     * node receives an {@code Event} of the specified type during the capturing
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this node. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such handler
     * specified at a time. This handler is guaranteed to be called as the last, after
     * handlers added using {@link #addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}.
     * This is used for registering the user-defined onFoo event handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private NodeEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    private void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          Node.this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private NodeEventDispatcher createInternalEventDispatcher() {
        return new NodeEventDispatcher(this);
    }

    /**
     * Event dispatcher for invoking preprocessing of mouse events
     */
    private EventDispatcher preprocessMouseEventDispatcher;

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this node. The event dispatch chain
     * contains all event dispatchers from the stage to this node.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this node
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {

        if (preprocessMouseEventDispatcher == null) {
            preprocessMouseEventDispatcher = (event, tail1) -&gt; {
                event = tail1.dispatchEvent(event);
                if (event instanceof MouseEvent) {
                    preprocessMouseEvent((MouseEvent) event);
                }

                return event;
            };
        }

        tail = tail.prepend(preprocessMouseEventDispatcher);

        // prepend all event dispatchers from this node to the root
        Node curNode = this;
        do {
            if (curNode.eventDispatcher != null) {
                final EventDispatcher eventDispatcherValue =
                        curNode.eventDispatcher.get();
                if (eventDispatcherValue != null) {
                    tail = tail.prepend(eventDispatcherValue);
                }
            }
            final Node curParent = curNode.getParent();
            curNode = curParent != null ? curParent : curNode.getSubScene();
        } while (curNode != null);

        if (getScene() != null) {
            // prepend scene's dispatch chain
            tail = getScene().buildEventDispatchChain(tail);
        }

        return tail;
    }

    // PENDING_DOC_REVIEW
    /**
     * Fires the specified event. By default the event will travel through the
     * hierarchy from the stage to this node. Any event filter encountered will
     * be notified and can consume the event. If not consumed by the filters,
     * the event handlers on this node are notified. If these don't consume the
     * event either, the event will travel back the same path it arrived to
     * this node. All event handlers encountered are called and can consume the
     * event.
     * &lt;p&gt;
     * This method must be called on the FX user thread.
     *
     * @param event the event to fire
     */
    public final void fireEvent(Event event) {

        /* Log input events.  We do a coarse filter for at least the FINE
         * level and then granularize from there.
         */
        if (event instanceof InputEvent) {
            PlatformLogger logger = Logging.getInputLogger();
            if (logger.isLoggable(Level.FINE)) {
                EventType eventType = event.getEventType();
                if (eventType == MouseEvent.MOUSE_ENTERED ||
                    eventType == MouseEvent.MOUSE_EXITED) {
                    logger.finer(event.toString());
                } else if (eventType == MouseEvent.MOUSE_MOVED ||
                           eventType == MouseEvent.MOUSE_DRAGGED) {
                    logger.finest(event.toString());
                } else {
                    logger.fine(event.toString());
                }
            }
        }

        Event.fireEvent(this, event);
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/


    /**
     * {@inheritDoc}
     * @return {@code getClass().getName()} without the package name
     * @since JavaFX 8.0
     */
    @Override
    public String getTypeSelector() {

        final Class&lt;?&gt; clazz = getClass();
        final Package pkg = clazz.getPackage();

        // package could be null. not likely, but could be.
        int plen = 0;
        if (pkg != null) {
            plen = pkg.getName().length();
        }

        final int clen = clazz.getName().length();
        final int pos = (0 &lt; plen &amp;&amp; plen &lt; clen) ? plen + 1 : 0;

        return clazz.getName().substring(pos);
    }

    /**
     * {@inheritDoc}
     * @return {@code getParent()}
     * @since JavaFX 8.0
     */
    @Override
    public Styleable getStyleableParent() {
        return getParent();
    }


    /**
     * Returns the initial focus traversable state of this node, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * can be overridden by subclasses in instances where focus traversable should
     * initially be true (as the default implementation of this method is to return
     * false).
     *
     * @return the initial focus traversable state for this {@code Node}.
     * @since 9
     */
    protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }

    /**
     * Returns the initial cursor state of this node, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * can be overridden by subclasses in instances where the cursor should
     * initially be non-null (as the default implementation of this method is to return
     * null).
     *
     * @return the initial cursor state for this {@code Node}.
     * @since 9
     */
    protected Cursor getInitialCursor() {
        return null;
    }

     /**
      * Super-lazy instantiation pattern from Bill Pugh.
      */
     private static class StyleableProperties {

        private static final CssMetaData&lt;Node,Cursor&gt; CURSOR =
            new CssMetaData&lt;Node,Cursor&gt;(&quot;-fx-cursor&quot;, CursorConverter.getInstance()) {

                @Override
                public boolean isSettable(Node node) {
                    return node.miscProperties == null || node.miscProperties.canSetCursor();
                }

                @Override
                public StyleableProperty&lt;Cursor&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Cursor&gt;)node.cursorProperty();
                }

                @Override
                public Cursor getInitialValue(Node node) {
                    // Most controls default focusTraversable to true.
                    // Give a way to have them return the correct default value.
                    return node.getInitialCursor();
                }

            };
        private static final CssMetaData&lt;Node,Effect&gt; EFFECT =
            new CssMetaData&lt;Node,Effect&gt;(&quot;-fx-effect&quot;, EffectConverter.getInstance()) {

                @Override
                public boolean isSettable(Node node) {
                    return node.miscProperties == null || node.miscProperties.canSetEffect();
                }

                @Override
                public StyleableProperty&lt;Effect&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Effect&gt;)node.effectProperty();
                }
            };
        private static final CssMetaData&lt;Node,Boolean&gt; FOCUS_TRAVERSABLE =
            new CssMetaData&lt;Node,Boolean&gt;(&quot;-fx-focus-traversable&quot;,
                BooleanConverter.getInstance(), Boolean.FALSE) {

                @Override
                public boolean isSettable(Node node) {
                    return node.focusTraversable == null || !node.focusTraversable.isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Boolean&gt;)node.focusTraversableProperty();
                }

                @Override
                public Boolean getInitialValue(Node node) {
                    // Most controls default focusTraversable to true.
                    // Give a way to have them return the correct default value.
                    return node.getInitialFocusTraversable();
                }

            };
        private static final CssMetaData&lt;Node,Number&gt; OPACITY =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-opacity&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.opacity == null || !node.opacity.isBound();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.opacityProperty();
                }
            };
        private static final CssMetaData&lt;Node,BlendMode&gt; BLEND_MODE =
            new CssMetaData&lt;Node,BlendMode&gt;(&quot;-fx-blend-mode&quot;, new EnumConverter&lt;BlendMode&gt;(BlendMode.class)) {

                @Override
                public boolean isSettable(Node node) {
                    return node.blendMode == null || !node.blendMode.isBound();
                }

                @Override
                public StyleableProperty&lt;BlendMode&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;BlendMode&gt;)node.blendModeProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; ROTATE =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-rotate&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.rotate == null
                        || node.nodeTransformation.canSetRotate();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.rotateProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_X =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-x&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleX == null
                        || node.nodeTransformation.canSetScaleX();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleXProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_Y =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-y&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleY == null
                        || node.nodeTransformation.canSetScaleY();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleYProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_Z =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-z&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleZ == null
                        || node.nodeTransformation.canSetScaleZ();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleZProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_X =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-x&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateX == null
                        || node.nodeTransformation.canSetTranslateX();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateXProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Y =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-y&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateY == null
                        || node.nodeTransformation.canSetTranslateY();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateYProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Z =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-z&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateZ == null
                        || node.nodeTransformation.canSetTranslateZ();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateZProperty();
                }
            };
         private static final CssMetaData&lt;Node, Number&gt; VIEW_ORDER
                 = new CssMetaData&lt;Node, Number&gt;(&quot;-fx-view-order&quot;,
                         SizeConverter.getInstance(), 0.0) {

                     @Override
                     public boolean isSettable(Node node) {
                         return node.miscProperties == null
                         || node.miscProperties.viewOrder == null
                         || !node.miscProperties.viewOrder.isBound();
                     }

                     @Override
                     public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                         return (StyleableProperty&lt;Number&gt;) node.viewOrderProperty();
                     }
                 };
        private static final CssMetaData&lt;Node,Boolean&gt; VISIBILITY =
            new CssMetaData&lt;Node,Boolean&gt;(&quot;visibility&quot;,
                new StyleConverter&lt;String,Boolean&gt;() {

                    @Override
                    // [ visible | hidden | collapse | inherit ]
                    public Boolean convert(ParsedValue&lt;String, Boolean&gt; value, Font font) {
                        final String sval = value != null ? value.getValue() : null;
                        return &quot;visible&quot;.equalsIgnoreCase(sval);
                    }

                },
                Boolean.TRUE) {

                @Override
                public boolean isSettable(Node node) {
                    return node.visible == null || !node.visible.isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Boolean&gt;)node.visibleProperty();
                }
            };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

         static {

             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
             styleables.add(CURSOR);
             styleables.add(EFFECT);
             styleables.add(FOCUS_TRAVERSABLE);
             styleables.add(OPACITY);
             styleables.add(BLEND_MODE);
             styleables.add(ROTATE);
             styleables.add(SCALE_X);
             styleables.add(SCALE_Y);
             styleables.add(SCALE_Z);
             styleables.add(VIEW_ORDER);
             styleables.add(TRANSLATE_X);
             styleables.add(TRANSLATE_Y);
             styleables.add(TRANSLATE_Z);
             styleables.add(VISIBILITY);
             STYLEABLES = Collections.unmodifiableList(styleables);

         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        //
        // Super-lazy instantiation pattern from Bill Pugh. StyleableProperties
        // is referenced no earlier (and therefore loaded no earlier by the
        // class loader) than the moment that  getClassCssMetaData() is called.
        // This avoids loading the CssMetaData instances until the point at
        // which CSS needs the data.
        //
        return StyleableProperties.STYLEABLES;
    }

    /**
     * This method should delegate to {@link Node#getClassCssMetaData()} so that
     * a Node's CssMetaData can be accessed without the need for reflection.
     *
     * @return The CssMetaData associated with this node, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */

    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /*
     * @return  The Styles that match this CSS property for the given Node. The
     * list is sorted by descending specificity.
     */
    // SB-dependency: RT-21096 has been filed to track this
    static List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData, Styleable styleable) {
         return CssStyleHelper.getMatchingStyles(styleable, cssMetaData);
    }

    final ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getStyleMap() {
         ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map =
                 (ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;)getProperties().get(&quot;STYLEMAP&quot;);
         Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(map, this);
         if (ret != null) {
             if (ret instanceof ObservableMap) return (ObservableMap)ret;
             return FXCollections.observableMap(ret);
         }
         return FXCollections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyObservableMap();
     }

     /*
      * RT-17293
      */
     // SB-dependency: RT-21096 has been filed to track this
     final void setStyleMap(ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
         if (styleMap != null) getProperties().put(&quot;STYLEMAP&quot;, styleMap);
         else getProperties().remove(&quot;STYLEMAP&quot;);
     }

    /*
     * Find CSS styles that were used to style this Node in its current pseudo-class state. The map will contain the styles from this node and,
     * if the node is a Parent, its children. The node corresponding to an entry in the Map can be obtained by casting a StyleableProperty key to a
     * javafx.beans.property.Property and calling getBean(). The List contains only those styles used to style the property and will contain
     * styles used to resolve lookup values.
     *
     * @param styleMap A Map to be populated with the styles. If null, a new Map will be allocated.
     * @return The Map populated with matching styles.
     */
    // SB-dependency: RT-21096 has been filed to track this
    Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; findStyles(Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; styleMap) {

        Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(styleMap, this);
        return (ret != null) ? ret : Collections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyMap();
    }

    /**
     * Flags used to indicate in which way this node is dirty (or whether it
     * is clean) and what must happen during the next CSS cycle on the
     * scenegraph.
     */
    CssFlags cssFlag = CssFlags.CLEAN;

    /**
     * Needed for testing.
     */
    final CssFlags getCSSFlags() { return cssFlag; }

    /**
     * Called when a CSS pseudo-class change would cause styles to be reapplied.
     */
    private void requestCssStateTransition() {
        // If there is no scene, then we cannot make it dirty, so we'll leave
        // the flag alone
        if (getScene() == null) return;
        // Don't bother doing anything if the cssFlag is not CLEAN.
        // If the flag indicates a DIRTY_BRANCH, the flag needs to be changed
        // to UPDATE to ensure that NodeHelper.processCSS is called on the node.
        if (cssFlag == CssFlags.CLEAN || cssFlag == CssFlags.DIRTY_BRANCH) {
            cssFlag = CssFlags.UPDATE;
            notifyParentsOfInvalidatedCSS();
        }
    }

    /**
     * Used to specify that a pseudo-class of this Node has changed. If the
     * pseudo-class is used in a CSS selector that matches this Node, CSS will
     * be reapplied. Typically, this method is called from the {@code invalidated}
     * method of a property that is used as a pseudo-class. For example:
     * &lt;pre&gt;&lt;code&gt;
     *
     *     private static final PseudoClass MY_PSEUDO_CLASS_STATE = PseudoClass.getPseudoClass(&quot;my-state&quot;);
     *
     *     BooleanProperty myPseudoClassState = new BooleanPropertyBase(false) {
     *
     *           {@literal @}Override public void invalidated() {
     *                pseudoClassStateChanged(MY_PSEUDO_CLASS_STATE, get());
     *           }
     *
     *           {@literal @}Override public Object getBean() {
     *               return MyControl.this;
     *           }
     *
     *           {@literal @}Override public String getName() {
     *               return &quot;myPseudoClassState&quot;;
     *           }
     *       };
     * &lt;/code&gt;&lt;/pre&gt;
     * @param pseudoClass the pseudo-class that has changed state
     * @param active whether or not the state is active
     * @since JavaFX 8.0
     */
    public final void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active) {

        final boolean modified = active
                ? pseudoClassStates.add(pseudoClass)
                : pseudoClassStates.remove(pseudoClass);

        if (modified &amp;&amp; styleHelper != null) {
            final boolean isTransition = styleHelper.pseudoClassStateChanged(pseudoClass);
            if (isTransition) {
                requestCssStateTransition();
            }
        }
   }

    // package so that StyleHelper can get at it
    final ObservableSet&lt;PseudoClass&gt; pseudoClassStates = new PseudoClassState();
    /**
     * @return The active pseudo-class states of this Node, wrapped in an unmodifiable ObservableSet
     * @since JavaFX 8.0
     */
    public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {

        return FXCollections.unmodifiableObservableSet(pseudoClassStates);

    }

    // Walks up the tree telling each parent that the pseudo class state of
    // this node has changed.
    final void notifyParentsOfInvalidatedCSS() {
        SubScene subScene = getSubScene();
        Parent root = (subScene != null) ?
                subScene.getRoot() : getScene().getRoot();

        if (!root.isDirty(DirtyBits.NODE_CSS)) {
            // Ensure that Scene.root is marked as dirty. If the scene isn't
            // dirty, nothing will get repainted. This bit is cleared from
            // Scene in doCSSPass().
            NodeHelper.markDirty(root, DirtyBits.NODE_CSS);
            if (subScene != null) {
                // If the node is part of a subscene, then we must ensure that
                // the we not only mark subScene.root dirty, but continue and
                // call subScene.notifyParentsOfInvalidatedCSS() until
                // Scene.root gets marked dirty, via the recursive call:
                subScene.cssFlag = CssFlags.UPDATE;
                subScene.notifyParentsOfInvalidatedCSS();
            }
        }
        Parent _parent = getParent();
        while (_parent != null) {
            if (_parent.cssFlag == CssFlags.CLEAN) {
                _parent.cssFlag = CssFlags.DIRTY_BRANCH;
                _parent = _parent.getParent();
            } else {
                _parent = null;
            }
        }
    }

    final void reapplyCSS() {

        if (getScene() == null) return;

        if (cssFlag == CssFlags.REAPPLY) return;

        // RT-36838 - don't reapply CSS in the middle of an update
        if (cssFlag == CssFlags.UPDATE) {
            cssFlag = CssFlags.REAPPLY;
            notifyParentsOfInvalidatedCSS();
            return;
        }

        reapplyCss();

        //
        // One idiom employed by developers is to, during the layout pass,
        // add or remove nodes from the scene. For example, a ScrollPane
        // might add scroll bars to itself if it determines during layout
        // that it needs them, or a ListView might add cells to itself if
        // it determines that it needs to. In such situations we must
        // apply the CSS immediately and not add it to the scene's queue
        // for deferred action.
        //
        if (getParent() != null &amp;&amp; getParent().isPerformingLayout()) {
            NodeHelper.processCSS(this);
        } else {
            notifyParentsOfInvalidatedCSS();
        }

    }

    //
    // This method &quot;reapplies&quot; CSS to this node and all of its children. Reapplying CSS
    // means that new style maps are calculated for the node. The process of reapplying
    // CSS may reset the CSS properties of a node to their initial state, but the _new_
    // styles are not applied as part of this process.
    //
    // There is no check of the CSS state of a child since reapply takes precedence
    // over other CSS states.
    //
    private void reapplyCss() {

        // Hang on to current styleHelper so we can know whether
        // createStyleHelper returned the same styleHelper
        final CssStyleHelper oldStyleHelper = styleHelper;

        // CSS state is &quot;REAPPLY&quot;
        cssFlag = CssFlags.REAPPLY;

        styleHelper = CssStyleHelper.createStyleHelper(this);

        // REAPPLY to my children, too.
        if (this instanceof Parent) {

            // minor optimization to avoid calling createStyleHelper on children
            // when we know there will not be any change in the style maps.
            final boolean visitChildren =
                    // If we don't have a styleHelper, then we should visit the children of this parent
                    // since there might be styles that depend on being a child of this parent.
                    // In other words, we have .a &gt; .b { blah: blort; }, but no styles for &quot;.a&quot; itself.
                    styleHelper == null ||
                    // if the styleHelper changed, then we definitely need to visit the children
                    // since the new styles may have an effect on the children's styles calculated values.
                    (oldStyleHelper != styleHelper) ||
                    // If our parent is null, then we're the root of a scene or sub-scene, most likely,
                    // and we'll visit children because elsewhere the code depends on root.reapplyCSS()
                    // to force css to be reapplied (whether it needs to be or not).
                    (getParent() == null) ||
                    // If our parent's cssFlag is other than clean, then the parent may have just had
                    // CSS reapplied. If the parent just had CSS reapplied, then some of its styles
                    // may affect my children's styles.
                    (getParent().cssFlag != CssFlags.CLEAN);

            if (visitChildren) {

                List&lt;Node&gt; children = ((Parent) this).getChildren();
                for (int n = 0, nMax = children.size(); n &lt; nMax; n++) {
                    Node child = children.get(n);
                    child.reapplyCss();
                }
            }

        } else if (this instanceof SubScene) {

            // SubScene root is a Parent, but reapplyCss is a private method in Node
            final Node subSceneRoot = ((SubScene)this).getRoot();
            if (subSceneRoot != null) {
                subSceneRoot.reapplyCss();
            }

        } else if (styleHelper == null) {
            //
            // If this is not a Parent and there is no styleHelper, then the CSS state is &quot;CLEAN&quot;
            // since there are no styles to apply or children to update.
            //
            cssFlag = CssFlags.CLEAN;
            return;
        }

        cssFlag = CssFlags.UPDATE;

    }

    void processCSS() {
        switch (cssFlag) {
            case CLEAN:
                break;
            case DIRTY_BRANCH:
            {
                Parent me = (Parent)this;
                // clear the flag first in case the flag is set to something
                // other than clean by downstream processing.
                me.cssFlag = CssFlags.CLEAN;
                List&lt;Node&gt; children = me.getChildren();
                for (int i=0, max=children.size(); i&lt;max; i++) {
                    children.get(i).processCSS();
                }
                break;
            }
            case REAPPLY:
            case UPDATE:
            default:
                NodeHelper.processCSS(this);
        }
    }

    /**
     * If required, apply styles to this Node and its children, if any. This method does not normally need to
     * be invoked directly but may be used in conjunction with {@link Parent#layout()} to size a Node before the
     * next pulse, or if the {@link #getScene() Scene} is not in a {@link javafx.stage.Stage}.
     * &lt;p&gt;Provided that the Node&amp;#39;s {@link #getScene() Scene} is not null, CSS is applied to this Node regardless
     * of whether this Node&amp;#39;s CSS state is clean. CSS styles are applied from the top-most parent
     * of this Node whose CSS state is other than clean, which may affect the styling of other nodes.
     * This method is a no-op if the Node is not in a Scene. The Scene does not have to be in a Stage.&lt;/p&gt;
     * &lt;p&gt;This method does not invoke the {@link Parent#layout()} method. Typically, the caller will use the
     * following sequence of operations.&lt;/p&gt;
     * &lt;pre&gt;{@code
     *     parentNode.applyCss();
     *     parentNode.layout();
     * }&lt;/pre&gt;
     * &lt;p&gt;As a more complete example, the following code uses {@code applyCss()} and {@code layout()} to find
     * the width and height of the Button before the Stage has been shown. If either the call to {@code applyCss()}
     * or the call to {@code layout()} is commented out, the calls to {@code getWidth()} and {@code getHeight()}
     * will return zero (until some time after the Stage is shown). &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     * {@literal @}Override
     * public void start(Stage stage) throws Exception {
     *
     *    Group root = new Group();
     *    Scene scene = new Scene(root);
     *
     *    Button button = new Button(&quot;Hello World&quot;);
     *    root.getChildren().add(button);
     *
     *    root.applyCss();
     *    root.layout();
     *
     *    double width = button.getWidth();
     *    double height = button.getHeight();
     *
     *    System.out.println(width + &quot;, &quot; + height);
     *
     *    stage.setScene(scene);
     *    stage.show();
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * @since JavaFX 8.0
     */
    public final void applyCss() {

        if (getScene() == null) {
            return;
        }

        // update, unless reapply
        if (cssFlag != CssFlags.REAPPLY) cssFlag = CssFlags.UPDATE;

        //
        // RT-28394 - need to see if any ancestor has a flag UPDATE
        // If so, process css from the top-most CssFlags.UPDATE node
        // since my ancestor's styles may affect mine.
        //
        // If the scene-graph root isn't NODE_CSS dirty, then all my
        // ancestor flags should be CLEAN and I can skip this lookup.
        //
        Node topMost = this;

        final boolean dirtyRoot = getScene().getRoot().isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
        if (dirtyRoot) {

            Node _parent = getParent();
            while (_parent != null) {
                if (_parent.cssFlag == CssFlags.UPDATE || _parent.cssFlag == CssFlags.REAPPLY) {
                    topMost = _parent;
                }
                _parent = _parent.getParent();
            }

            // Note: this code used to mark the parent nodes with DIRTY_BRANCH,
            // but that isn't necessary since UPDATE will apply css to all of
            // a Parent's children.

            // If we're at the root of the scene-graph, make sure the NODE_CSS
            // dirty bit is cleared (see Scene#doCSSPass())
            if (topMost == getScene().getRoot()) {
                getScene().getRoot().clearDirty(DirtyBits.NODE_CSS);
            }
        }

        topMost.processCSS();

    }

    /*
     * If invoked, will update styles from here on down. This method should not be called directly. If
     * overridden, the overriding method must at some point call {@code super.processCSSImpl} to ensure that
     * this Node's CSS state is properly updated.
     *
     * Note that the difference between this method and {@link #applyCss()} is that this method
     * updates styles for this node on down; whereas, {@code applyCss()} looks for the top-most ancestor that needs
     * CSS update and apply styles from that node on down.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doProcessCSS() {

        // Nothing to do...
        if (cssFlag == CssFlags.CLEAN) return;

        // if REAPPLY was deferred, process it now...
        if (cssFlag == CssFlags.REAPPLY) {
            reapplyCss();
        }

        // Clear the flag first in case the flag is set to something
        // other than clean by downstream processing.
        cssFlag = CssFlags.CLEAN;

        // Transition to the new state and apply styles
        if (styleHelper != null &amp;&amp; getScene() != null) {
            styleHelper.transitionToState(this);
        }
    }


    /**
     * A StyleHelper for this node.
     * A StyleHelper contains all the css styles for this node
     * and knows how to apply them when our state changes.
     */
    CssStyleHelper styleHelper;

    private static final PseudoClass HOVER_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;hover&quot;);
    private static final PseudoClass PRESSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;pressed&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass FOCUSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;focused&quot;);
    private static final PseudoClass SHOW_MNEMONICS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;show-mnemonics&quot;);

    private static abstract class LazyTransformProperty
            extends ReadOnlyObjectProperty&lt;Transform&gt; {

        protected static final int VALID = 0;
        protected static final int INVALID = 1;
        protected static final int VALIDITY_UNKNOWN = 2;
        protected int valid = INVALID;

        private ExpressionHelper&lt;Transform&gt; helper;

        private Transform transform;
        private boolean canReuse = false;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected Transform getInternalValue() {
            if (valid == INVALID ||
                    (valid == VALIDITY_UNKNOWN &amp;&amp; computeValidity() == INVALID)) {
                transform = computeTransform(canReuse ? transform : null);
                canReuse = true;
                valid = validityKnown() ? VALID : VALIDITY_UNKNOWN;
            }

            return transform;
        }

        @Override
        public Transform get() {
            transform = getInternalValue();
            canReuse = false;
            return transform;
        }

        public void validityUnknown() {
            if (valid == VALID) {
                valid = VALIDITY_UNKNOWN;
            }
        }

        public void invalidate() {
            if (valid != INVALID) {
                valid = INVALID;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract boolean validityKnown();
        protected abstract int computeValidity();
        protected abstract Transform computeTransform(Transform reuse);
    }

    private static abstract class LazyBoundsProperty
            extends ReadOnlyObjectProperty&lt;Bounds&gt; {
        private ExpressionHelper&lt;Bounds&gt; helper;
        private boolean valid;

        private Bounds bounds;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Bounds&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Bounds&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public Bounds get() {
            if (!valid) {
                bounds = computeBounds();
                valid = true;
            }

            return bounds;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract Bounds computeBounds();
    }

    private static final BoundsAccessor boundsAccessor = (bounds, tx, node) -&gt; node.getGeomBounds(bounds, tx);

    /**
     * The accessible role for this {@code Node}.
     * &lt;p&gt;
     * The screen reader uses the role of a node to determine the
     * attributes and actions that are supported.
     *
     * @defaultValue {@link AccessibleRole#NODE}
     * @see AccessibleRole
     *
     * @since JavaFX 8u40
     */
    private ObjectProperty&lt;AccessibleRole&gt; accessibleRole;

    public final void setAccessibleRole(AccessibleRole value) {
        if (value == null) value = AccessibleRole.NODE;
        accessibleRoleProperty().set(value);
    }

    public final AccessibleRole getAccessibleRole() {
        if (accessibleRole == null) return AccessibleRole.NODE;
        return accessibleRoleProperty().get();
    }

    public final ObjectProperty&lt;AccessibleRole&gt; accessibleRoleProperty() {
        if (accessibleRole == null) {
            accessibleRole = new SimpleObjectProperty&lt;AccessibleRole&gt;(this, &quot;accessibleRole&quot;, AccessibleRole.NODE);
        }
        return accessibleRole;
    }

    public final void setAccessibleRoleDescription(String value) {
        accessibleRoleDescriptionProperty().set(value);
    }

    public final String getAccessibleRoleDescription() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleRoleDescription == null) return null;
        return accessibleRoleDescriptionProperty().get();
    }

    /**
     * The role description of this {@code Node}.
     * &lt;p&gt;
     * Normally, when a role is provided for a node, the screen reader
     * speaks the role as well as the contents of the node.  When this
     * value is set, it is possible to override the default.  This is
     * useful because the set of roles is predefined.  For example,
     * it is possible to set the role of a node to be a button, but
     * have the role description be arbitrary text.
     *
     * @return the role description of this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleRoleDescriptionProperty() {
        return getAccessibilityProperties().getAccessibleRoleDescription();
    }

    public final void setAccessibleText(String value) {
        accessibleTextProperty().set(value);
    }

    public final String getAccessibleText() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleText == null) return null;
        return accessibleTextProperty().get();
    }

    /**
     * The accessible text for this {@code Node}.
     * &lt;p&gt;
     * This property is used to set the text that the screen
     * reader will speak.  If a node normally speaks text,
     * that text is overriden.  For example, a button
     * usually speaks using the text in the control but will
     * no longer do this when this value is set.
     *
     * @return accessible text for this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleTextProperty() {
        return getAccessibilityProperties().getAccessibleText();
    }

    public final void setAccessibleHelp(String value) {
        accessibleHelpProperty().set(value);
    }

    public final String getAccessibleHelp() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleHelp == null) return null;
        return accessibleHelpProperty().get();
    }

    /**
     * The accessible help text for this {@code Node}.
     * &lt;p&gt;
     * The help text provides a more detailed description of the
     * accessible text for a node.  By default, if the node has
     * a tool tip, this text is used.
     *
     * @return the accessible help text for this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleHelpProperty() {
        return getAccessibilityProperties().getAccessibleHelp();
    }

    AccessibilityProperties accessibilityProperties;
    private AccessibilityProperties getAccessibilityProperties() {
        if (accessibilityProperties == null) {
            accessibilityProperties = new AccessibilityProperties();
        }
        return accessibilityProperties;
    }

    private class AccessibilityProperties {
        ObjectProperty&lt;String&gt; accessibleRoleDescription;
        ObjectProperty&lt;String&gt; getAccessibleRoleDescription() {
            if (accessibleRoleDescription == null) {
                accessibleRoleDescription = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleRoleDescription&quot;, null);
            }
            return accessibleRoleDescription;
        }
        ObjectProperty&lt;String&gt; accessibleText;
        ObjectProperty&lt;String&gt; getAccessibleText() {
            if (accessibleText == null) {
                accessibleText = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleText&quot;, null);
            }
            return accessibleText;
        }
        ObjectProperty&lt;String&gt; accessibleHelp;
        ObjectProperty&lt;String&gt; getAccessibleHelp() {
            if (accessibleHelp == null) {
                accessibleHelp = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleHelp&quot;, null);
            }
            return accessibleHelp;
        }
    }

    /**
     * This method is called by the assistive technology to request
     * the value for an attribute.
     * &lt;p&gt;
     * This method is commonly overridden by subclasses to implement
     * attributes that are required for a specific role.&lt;br&gt;
     * If a particular attribute is not handled, the superclass implementation
     * must be called.
     * &lt;/p&gt;
     *
     * @param attribute the requested attribute
     * @param parameters optional list of parameters
     * @return the value for the requested attribute
     *
     * @see AccessibleAttribute
     *
     * @since JavaFX 8u40
     */
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROLE: return getAccessibleRole();
            case ROLE_DESCRIPTION: return getAccessibleRoleDescription();
            case TEXT: return getAccessibleText();
            case HELP: return getAccessibleHelp();
            case PARENT: return getParent();
            case SCENE: return getScene();
            case BOUNDS: return localToScreen(getBoundsInLocal());
            case DISABLED: return isDisabled();
            case FOCUSED: return isFocused();
            case VISIBLE: return isVisible();
            case LABELED_BY: return labeledBy;
            default: return null;
        }
    }

    /**
     * This method is called by the assistive technology to request the action
     * indicated by the argument should be executed.
     * &lt;p&gt;
     * This method is commonly overridden by subclasses to implement
     * action that are required for a specific role.&lt;br&gt;
     * If a particular action is not handled, the superclass implementation
     * must be called.
     * &lt;/p&gt;
     *
     * @param action the action to execute
     * @param parameters optional list of parameters
     *
     * @see AccessibleAction
     *
     * @since JavaFX 8u40
     */
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS:
                if (isFocusTraversable()) {
                    requestFocus();
                }
                break;
            case SHOW_MENU: {
                Bounds b = getBoundsInLocal();
                Point2D pt = localToScreen(b.getMaxX(), b.getMaxY());
                ContextMenuEvent event =
                    new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    b.getMaxX(), b.getMaxY(), pt.getX(), pt.getY(),
                    false, new PickResult(this, b.getMaxX(), b.getMaxY()));
                Event.fireEvent(this, event);
                break;
            }
            default:
        }
    }

    /**
     * This method is called by the application to notify the assistive
     * technology that the value for an attribute has changed.
     *
     * @param attributes the attribute whose value has changed
     *
     * @see AccessibleAttribute
     *
     * @since JavaFX 8u40
     */
    public final void notifyAccessibleAttributeChanged(AccessibleAttribute attributes) {
        if (accessible == null) {
            Scene scene = getScene();
            if (scene != null) {
                accessible = scene.removeAccessible(this);
            }
        }
        if (accessible != null) {
            accessible.sendNotification(attributes);
        }
    }

    Accessible accessible;
    Accessible getAccessible() {
        if (accessible == null) {
            Scene scene = getScene();
            /* It is possible the node was reparented and getAccessible()
             * is called before the pulse. Try to recycle the accessible
             * before creating a new one.
             * Note: this code relies that an accessible can never be on
             * more than one Scene#accMap. Thus, the only way
             * scene#removeAccessible() returns non-null is if the node
             * old scene and new scene are the same object.
             */
            if (scene != null) {
                accessible = scene.removeAccessible(this);
            }
        }
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @SuppressWarnings(&quot;deprecation&quot;)
                @Override public AccessControlContext getAccessControlContext() {
                    Scene scene = getScene();
                    if (scene == null) {
                        /* This can happen during the release process of an accessible object. */
                        throw new RuntimeException(&quot;Accessbility requested for node not on a scene&quot;);
                    }
                    if (scene.getPeer() != null) {
                        return scene.getPeer().getAccessControlContext();
                    } else {
                        /* In some rare cases the accessible for a Node is needed
                         * before its scene is made visible. For example, the screen reader
                         * might ask a Menu for its ContextMenu before the ContextMenu
                         * is made visible. That is a problem because the Window for the
                         * ContextMenu is only created immediately before the first time
                         * it is shown.
                         */
                        return scene.acc;
                    }
                }
                @Override public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
                    return queryAccessibleAttribute(attribute, parameters);
                }
                @Override public void executeAction(AccessibleAction action, Object... parameters) {
                    executeAccessibleAction(action, parameters);
                }
                @Override public String toString() {
                    String klassName = Node.this.getClass().getName();
                    return klassName.substring(klassName.lastIndexOf('.')+1);
                }
            });
        }
        return accessible;
    }

    void releaseAccessible() {
        Accessible acc = this.accessible;
        if (acc != null) {
            accessible = null;
            acc.dispose();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Parent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.sun.javafx.util.TempState;
import com.sun.javafx.util.Utils;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.collections.VetoableListDecorator;
import javafx.css.Selector;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.sg.prism.NGGroup;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.stage.WindowHelper;
import java.util.Collections;
import javafx.stage.Window;

/**
 * The base class for all nodes that have children in the scene graph.
 * &lt;p&gt;
 * This class handles all hierarchical scene graph operations, including adding/removing
 * child nodes, marking branches dirty for layout and rendering, picking,
 * bounds calculations, and executing the layout pass on each pulse.
 * &lt;p&gt;
 * There are two direct concrete Parent subclasses
 * &lt;ul&gt;
 * &lt;li&gt;{@link Group} effects and transforms to be applied to a collection of child nodes.&lt;/li&gt;
 * &lt;li&gt;{@link javafx.scene.layout.Region} class for nodes that can be styled with CSS and layout children. &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @since JavaFX 2.0
 */
public abstract class Parent extends Node {
    // package private for testing
    static final int DIRTY_CHILDREN_THRESHOLD = 10;

    // If set to true, generate a warning message whenever adding a node to a
    // parent if it is currently a child of another parent.
    private static final boolean warnOnAutoMove = PropertyHelper.getBooleanProperty(&quot;javafx.sg.warn&quot;);

    /**
     * Threshold when it's worth to populate list of removed children.
     */
    private static final int REMOVED_CHILDREN_THRESHOLD = 20;

    /**
     * Do not populate list of removed children when its number exceeds threshold,
     * but mark whole parent dirty.
     */
    private boolean removedChildrenOptimizationDisabled = false;

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        ParentHelper.setParentAccessor(new ParentHelper.ParentAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Parent) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Parent) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Parent) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Parent) node).doComputeContains(localX, localY);
            }

            @Override
            public void doProcessCSS(Node node) {
                ((Parent) node).doProcessCSS();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                ((Parent) node).doPickNodeLocal(localPickRay, result);
            }

            @Override
            public boolean pickChildrenNode(Parent parent, PickRay pickRay, PickResultChooser result) {
                return parent.pickChildrenNode(pickRay, result);
            }

            @Override
            public void setTraversalEngine(Parent parent, ParentTraversalEngine value) {
                parent.setTraversalEngine(value);
            }

            @Override
            public ParentTraversalEngine getTraversalEngine(Parent parent) {
                return parent.getTraversalEngine();
            }

            @Override
            public List&lt;String&gt; doGetAllParentStylesheets(Parent parent) {
                return parent.doGetAllParentStylesheets();
            }
        });
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGGroup peer = getPeer();

        if (Utils.assertionEnabled()) {
            List&lt;NGNode&gt; pgnodes = peer.getChildren();
            if (pgnodes.size() != pgChildrenSize) {
                java.lang.System.err.println(&quot;*** pgnodes.size() [&quot; + pgnodes.size() + &quot;] != pgChildrenSize [&quot; + pgChildrenSize + &quot;]&quot;);
            }
        }

        if (isDirty(DirtyBits.PARENT_CHILDREN)) {
            // Whether a permutation, or children having been added or
            // removed, we'll want to clear out the PG side starting
            // from startIdx. We know that everything up to but not
            // including startIdx is identical between the FX and PG
            // sides, so we only need to update the remaining portion.
            peer.clearFrom(startIdx);
            for (int idx = startIdx; idx &lt; children.size(); idx++) {
                peer.add(idx, children.get(idx).getPeer());
            }
            if (removedChildrenOptimizationDisabled) {
                peer.markDirty();
                removedChildrenOptimizationDisabled = false;
            } else {
                if (removed != null &amp;&amp; !removed.isEmpty()) {
                    for(int i = 0; i &lt; removed.size(); i++) {
                        peer.addToRemoved(removed.get(i).getPeer());
                    }
                }
            }
            if (removed != null) {
                removed.clear();
            }
            pgChildrenSize = children.size();
            startIdx = pgChildrenSize;
        }

        if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
            computeViewOrderChidrenAndUpdatePeer();
        }

        if (Utils.assertionEnabled()) validatePG();
    }


    /***********************************************************************
     *                        Scenegraph Structure                         *
     *                                                                     *
     *  Functions and variables related to the scenegraph structure,       *
     *  modifying the structure, and walking the structure.                *
     *                                                                     *
     **********************************************************************/

    // Used to check for duplicate nodes
    private final Set&lt;Node&gt; childSet = new HashSet&lt;Node&gt;();

    // starting child index from which we need to send the children to the PGGroup
    private int startIdx = 0;

    // double of children in the PGGroup as of the last update
    private int pgChildrenSize = 0;

    void validatePG() {
        boolean assertionFailed = false;
        final NGGroup peer = getPeer();
        List&lt;NGNode&gt; pgnodes = peer.getChildren();
        if (pgnodes.size() != children.size()) {
            java.lang.System.err.println(&quot;*** pgnodes.size validatePG() [&quot; + pgnodes.size() + &quot;] != children.size() [&quot; + children.size() + &quot;]&quot;);
            assertionFailed = true;
        } else {
            for (int idx = 0; idx &lt; children.size(); idx++) {
                Node n = children.get(idx);
                if (n.getParent() != this) {
                    java.lang.System.err.println(&quot;*** this=&quot; + this + &quot; validatePG children[&quot; + idx + &quot;].parent= &quot; + n.getParent());
                    assertionFailed = true;
                }
                if (n.getPeer() != pgnodes.get(idx)) {
                    java.lang.System.err.println(&quot;*** pgnodes[&quot; + idx + &quot;] validatePG != children[&quot; + idx + &quot;]&quot;);
                    assertionFailed = true;
                }
            }
        }
        if (assertionFailed) {
            throw new java.lang.AssertionError(&quot;validation of PGGroup children failed&quot;);
        }

    }

    void printSeq(String prefix, List&lt;Node&gt; nodes) {
        String str = prefix;
        for (Node nn : nodes) {
            str += nn + &quot; &quot;;
        }
        System.out.println(str);
    }

    /**
     * The viewOrderChildren is a list children sorted in decreasing viewOrder
     * order if it is not empty. Its size should always be equal to
     * children.size(). If viewOrderChildren is empty it implies that the
     * rendering order of the children is the same as the order in the children
     * list.
     */
    private final List&lt;Node&gt; viewOrderChildren = new ArrayList(1);

    void markViewOrderChildrenDirty() {
        NodeHelper.markDirty(this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
    }

    private void computeViewOrderChidrenAndUpdatePeer() {
        boolean viewOrderSet = false;
        for (Node child : children) {
            double vo = child.getViewOrder();

            if (!viewOrderSet &amp;&amp; vo != 0) {
                viewOrderSet = true;
            }
        }

        viewOrderChildren.clear();
        if (viewOrderSet) {
            viewOrderChildren.addAll(children);

            // Sort in descending order (or big-to-small order)
            Collections.sort(viewOrderChildren, (Node a, Node b)
                    -&gt; a.getViewOrder() &lt; b.getViewOrder() ? 1
                            : a.getViewOrder() == b.getViewOrder() ? 0 : -1);
        }

        final NGGroup peer = getPeer();
        peer.setViewOrderChildren(viewOrderChildren);
    }

    // Call this method if children view order is needed for picking.
    // The returned list should be treated as read only.
    private List&lt;Node&gt; getOrderedChildren() {
        if (!viewOrderChildren.isEmpty()) {
            return viewOrderChildren;
        }
        return children;
    }

    // Variable used to indicate that the change to the children ObservableList is
    // a simple permutation as the result of a toFront or toBack operation.
    // We can avoid almost all of the processing of the on replace trigger in
    // this case.
    private boolean childrenTriggerPermutation = false;

    //accumulates all removed nodes between pulses, for dirty area calculation.
    private List&lt;Node&gt; removed;

    // set to true if either childRemoved or childAdded returns
    // true. These functions will indicate whether the geom
    // bounds for the parent have changed
    private boolean geomChanged;
    private boolean childSetModified;
    private final ObservableList&lt;Node&gt; children = new VetoableListDecorator&lt;Node&gt;(new TrackableObservableList&lt;Node&gt;() {


        protected void onChanged(Change&lt;Node&gt; c) {
            // proceed with updating the scene graph
            unmodifiableManagedChildren = null;
            boolean relayout = false;
            boolean viewOrderChildrenDirty = false;

            if (childSetModified) {
                while (c.next()) {
                    int from = c.getFrom();
                    int to = c.getTo();
                    for (int i = from; i &lt; to; ++i) {
                        Node n = children.get(i);
                        if (n.getParent() != null &amp;&amp; n.getParent() != Parent.this) {
                            if (warnOnAutoMove) {
                                java.lang.System.err.println(&quot;WARNING added to a new parent without first removing it from its current&quot;);
                                java.lang.System.err.println(&quot;    parent. It will be automatically removed from its current parent.&quot;);
                                java.lang.System.err.println(&quot;    node=&quot; + n + &quot; oldparent= &quot; + n.getParent() + &quot; newparent=&quot; + this);
                            }
                            n.getParent().children.remove(n);
                            if (warnOnAutoMove) {
                                Thread.dumpStack();
                            }
                        }
                    }

                    List&lt;Node&gt; removed = c.getRemoved();
                    int removedSize = removed.size();
                    for (int i = 0; i &lt; removedSize; ++i) {
                        final Node n = removed.get(i);
                        if (n.isManaged()) {
                            relayout = true;
                        }
                    }

                    // Mark viewOrderChildrenDirty if there is modification to children list
                    // and view order was set on one or more of the children prior to this change
                    if (((removedSize &gt; 0) || (to - from) &gt; 0) &amp;&amp; !viewOrderChildren.isEmpty()) {
                        viewOrderChildrenDirty = true;
<A NAME="70"></A>                    }
                    // update the parent and scene for each new node
                    for (int i = from; i &lt; to; ++i) {
                        Node node = <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#70',2,'match42-top.html#70',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>children.get(i);

                        // Newly added node has view order set.
                        if (node.getViewOrder() != 0) {
                            viewOrderChildrenDirty = true;
                        }
                        if (node.isManaged() || (node instanceof Parent &amp;&amp; ((Parent) node).layoutFlag != LayoutFlags.CLEAN)) {
                            relayout = true;
                        }</B></FONT>
                        node.setParent(Parent.this);
                        node.setScenes(getScene(), getSubScene());
                        // assert !node.boundsChanged;
                        if (node.isVisible()) {
                            geomChanged = true;
                            childIncluded(node);
                        }
                    }
                }

                // check to see if the number of children exceeds
                // DIRTY_CHILDREN_THRESHOLD and dirtyChildren is null.
                // If so, then we need to create dirtyChildren and
                // populate it.
                if (dirtyChildren == null &amp;&amp; children.size() &gt; DIRTY_CHILDREN_THRESHOLD) {
                    dirtyChildren
                            = new ArrayList&lt;Node&gt;(2 * DIRTY_CHILDREN_THRESHOLD);
                    // only bother populating children if geom has
                    // changed, otherwise there is no need
                    if (dirtyChildrenCount &gt; 0) {
                        int size = children.size();
                        for (int i = 0; i &lt; size; ++i) {
                            Node ch = children.get(i);
                            if (ch.isVisible() &amp;&amp; ch.boundsChanged) {
                                dirtyChildren.add(ch);
                            }
                        }
                    }
                }
            } else {
                // If childSet was not modified, we still need to check whether the permutation
                // did change the layout
                layout_loop:while (c.next()) {
                    List&lt;Node&gt; removed = c.getRemoved();
                    for (int i = 0, removedSize = removed.size(); i &lt; removedSize; ++i) {
                        if (removed.get(i).isManaged()) {
                            relayout = true;
                            break layout_loop;
                        }
                    }

                    for (int i = c.getFrom(), to = c.getTo(); i &lt; to; ++i) {
                        if (children.get(i).isManaged()) {
                            relayout = true;
                            break layout_loop;
                        }
                    }
                }
            }


            //
            // Note that the styles of a child do not affect the parent or
            // its siblings. Thus, it is only necessary to reapply css to
            // the Node just added and not to this parent and all of its
            // children. So the following call to reapplyCSS was moved
            // to Node.parentProperty. The original comment and code were
            // purposely left here as documentation should there be any
            // question about how the code used to work and why the change
            // was made.
            //
            // if children have changed then I need to reapply
            // CSS from this node on down
//                reapplyCSS();
            //

            // request layout if a Group subclass has overridden doLayout OR
            // if one of the new children needs layout, in which case need to ensure
            // the needsLayout flag is set all the way to the root so the next layout
            // pass will reach the child.
            if (relayout) {
                requestLayout();
            }

            if (geomChanged) {
                NodeHelper.geomChanged(Parent.this);
            }

            // Note the starting index at which we need to update the
            // PGGroup on the next update, and mark the children dirty
            c.reset();
            c.next();
            if (startIdx &gt; c.getFrom()) {
                startIdx = c.getFrom();
            }

            NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN);
            // Force synchronization to include the handling of invisible node
            // so that removed list will get cleanup to prevent memory leak.
            NodeHelper.markDirty(Parent.this, DirtyBits.NODE_FORCE_SYNC);

            if (viewOrderChildrenDirty) {
                NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
            }
        }

    }) {
        @Override
        protected void onProposedChange(final List&lt;Node&gt; newNodes, int[] toBeRemoved) {
            final Scene scene = getScene();
            if (scene != null) {
                Window w = scene.getWindow();
                if (w != null &amp;&amp; WindowHelper.getPeer(w) != null) {
                    Toolkit.getToolkit().checkFxUserThread();
                }
            }
            geomChanged = false;

            long newLength = children.size() + newNodes.size();
            int removedLength = 0;
            for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
                removedLength += toBeRemoved[i + 1] - toBeRemoved[i];
            }
            newLength -= removedLength;

            // If the childrenTriggerPermutation flag is set, then we know it
            // is a simple permutation and no further checking is needed.
            if (childrenTriggerPermutation) {
                childSetModified = false;
                return;
            }

            // If the childrenTriggerPermutation flag is not set, then we will
            // check to see whether any element in the ObservableList has changed,
            // or whether the new ObservableList is a permutation on the existing
            // ObservableList. Note that even if the childrenModified flag is false,
            // we still have to check for duplicates. If it is a simple
            // permutation, we can avoid checking for cycles or other parents.
            childSetModified = true;
            if (newLength == childSet.size()) {
                childSetModified = false;
                for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
                    Node n = newNodes.get(i);
                    if (!childSet.contains(n)) {
                        childSetModified = true;
                        break;
                    }
                }
            }

            // Enforce scene graph invariants, and check for structural errors.
            //
            // 1. If a child has been added to this parent more than once,
            // then it is an error
            //
            // 2. If a child is a target of a clip, then it is an error.
            //
            // 3. If a node would cause a cycle, then it is an error.
            //
            // 4. If a node is null
            //
            // Note that if a node is the child of another parent, we will
            // implicitly remove the node from its former Parent after first
            // checking for errors.

            // iterate over the nodes that were removed and remove them from
            // the hash set.
            for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
                for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
                    childSet.remove(children.get(j));
                }
            }

            try {
                if (childSetModified) {
                    // check individual children before duplication test
                    // if done in this order, the exception is more specific
                    for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
                        Node node = newNodes.get(i);
                        if (node == null) {
                            throw new NullPointerException(
                                    constructExceptionMessage(
                                        &quot;child node is null&quot;, null));
                        }
                        if (node.getClipParent() != null) {
                            throw new IllegalArgumentException(
                                    constructExceptionMessage(
                                        &quot;node already used as a clip&quot;, node));
                        }
                        if (wouldCreateCycle(Parent.this, node)) {
                            throw new IllegalArgumentException(
                                    constructExceptionMessage(
                                        &quot;cycle detected&quot;, node));
                        }
                    }
                }

                childSet.addAll(newNodes);
                if (childSet.size() != newLength) {
                    throw new IllegalArgumentException(
                            constructExceptionMessage(
                                &quot;duplicate children added&quot;, null));
                }
            } catch (RuntimeException e) {
                //Return children to it's original state
                childSet.clear();
                childSet.addAll(children);

                // rethrow
                throw e;
            }

            // Done with error checking

            if (!childSetModified) {
                return;
            }

            // iterate over the nodes that were removed and clear their
            // parent and scene. Add to them also to removed list for further
            // dirty regions calculation.
            if (removed == null) {
                removed = new ArrayList&lt;Node&gt;();
            }
            if (removed.size() + removedLength &gt; REMOVED_CHILDREN_THRESHOLD || !isTreeVisible()) {
                //do not populate too many children in removed list
                removedChildrenOptimizationDisabled = true;
            }
            for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
                for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
                    Node old = children.get(j);
                    final Scene oldScene = old.getScene();
                    if (oldScene != null) {
                        oldScene.generateMouseExited(old);
                    }
                    if (dirtyChildren != null) {
                        dirtyChildren.remove(old);
                    }
                    if (old.isVisible()) {
                        geomChanged = true;
                        childExcluded(old);
                    }
                    if (old.getParent() == Parent.this) {
                        old.setParent(null);
                        old.setScenes(null, null);
                    }
                    // Do not add node with null scene to the removed list.
                    // It will not be processed in the list and its memory
                    // will not be freed.
                    if (scene != null &amp;&amp; !removedChildrenOptimizationDisabled) {
                        removed.add(old);
                    }
                }
            }
        }

        private String constructExceptionMessage(
                String cause, Node offendingNode) {
            final StringBuilder sb = new StringBuilder(&quot;Children: &quot;);
            sb.append(cause);
            sb.append(&quot;: parent = &quot;).append(Parent.this);
            if (offendingNode != null) {
                sb.append(&quot;, node = &quot;).append(offendingNode);
            }

            return sb.toString();
        }
    };

    /**
     * A constant reference to an unmodifiable view of the children, such that every time
     * we ask for an unmodifiable list of children, we don't actually create a new
     * collection and return it. The memory overhead is pretty lightweight compared
     * to all the garbage we would otherwise generate.
     */
    private final ObservableList&lt;Node&gt; unmodifiableChildren =
            FXCollections.unmodifiableObservableList(children);

    /**
     * A cached reference to the unmodifiable managed children of this Parent. This is
     * created whenever first asked for, and thrown away whenever children are added
     * or removed or when their managed state changes. This could be written
     * differently, such that this list is essentially a filtered copy of the
     * main children, but that additional overhead might not be worth it.
     */
    private List&lt;Node&gt; unmodifiableManagedChildren = null;

    /**
     * Gets the list of children of this {@code Parent}.
     *
     * &lt;p&gt;
     * See the class documentation for {@link Node} for scene graph structure
     * restrictions on setting a {@link Parent}'s children list.
     * If these restrictions are violated by a change to the list of children,
     * the change is ignored and the previous value of the children list is
     * restored. An {@link IllegalArgumentException} is thrown in this case.
     *
     * &lt;p&gt;
     * If this {@link Parent} node is attached to a {@link Scene} attached to a {@link Window}
     * that is showning ({@link javafx.stage.Window#isShowing()}), then its
     * list of children must only be modified on the JavaFX Application Thread.
     * An {@link IllegalStateException} is thrown if this restriction is
     * violated.
     *
     * &lt;p&gt;
     * Note to subclasses: if you override this method, you must return from
     * your implementation the result of calling this super method. The actual
     * list instance returned from any getChildren() implementation must be
     * the list owned and managed by this Parent. The only typical purpose
     * for overriding this method is to promote the method to be public.
     *
     * @return the list of children of this {@code Parent}.
     */
    protected ObservableList&lt;Node&gt; getChildren() {
        return children;
    }

    /**
     * Gets the list of children of this {@code Parent} as a read-only
     * list.
     *
     * @return read-only access to this parent's children ObservableList
     */
    public ObservableList&lt;Node&gt; getChildrenUnmodifiable() {
        return unmodifiableChildren;
    }

    /**
     * Gets the list of all managed children of this {@code Parent}.
     *
     * @param &lt;E&gt; the type of the children nodes
     * @return list of all managed children in this parent
     */
    protected &lt;E extends Node&gt; List&lt;E&gt; getManagedChildren() {
        if (unmodifiableManagedChildren == null) {
            unmodifiableManagedChildren = new ArrayList&lt;Node&gt;();
            for (int i=0, max=children.size(); i&lt;max; i++) {
                Node e = children.get(i);
                if (e.isManaged()) {
                    unmodifiableManagedChildren.add(e);
                }
            }
        }
        return (List&lt;E&gt;)unmodifiableManagedChildren;
    }

    /**
     * Called by Node whenever its managed state may have changed, this
     * method will cause the view of managed children to be updated
     * such that it properly includes or excludes this child.
     */
    final void managedChildChanged() {
        requestLayout();
        unmodifiableManagedChildren = null;
    }

    // implementation of Node.toFront function
    final void toFront(Node node) {
        if (Utils.assertionEnabled()) {
            if (!childSet.contains(node)) {
                throw new java.lang.AssertionError(
                        &quot;specified node is not in the list of children&quot;);
            }
        }

        if (children.get(children.size() - 1) != node) {
            childrenTriggerPermutation = true;
            try {
                children.remove(node);
                children.add(node);
            } finally {
                childrenTriggerPermutation = false;
            }
        }
    }

    // implementation of Node.toBack function
    final void toBack(Node node) {
        if (Utils.assertionEnabled()) {
            if (!childSet.contains(node)) {
                throw new java.lang.AssertionError(
                        &quot;specified node is not in the list of children&quot;);
            }
        }

        if (children.get(0) != node) {
            childrenTriggerPermutation = true;
            try {
                children.remove(node);
                children.add(0, node);
            } finally {
                childrenTriggerPermutation = false;
            }
        }
    }

    @Override
    void scenesChanged(final Scene newScene, final SubScene newSubScene,
                       final Scene oldScene, final SubScene oldSubScene) {

        if (oldScene != null &amp;&amp; newScene == null) {
            // RT-34863 - clean up CSS cache when Parent is removed from scene-graph
            StyleManager.getInstance().forget(this);

            // Clear removed list on parent who is no longer in a scene
            if (removed != null) {
                removed.clear();
            }
        }

        for (int i=0; i&lt;children.size(); i++) {
            children.get(i).setScenes(newScene, newSubScene);
        }

        final boolean awaitingLayout = layoutFlag != LayoutFlags.CLEAN;

        sceneRoot = (newSubScene != null &amp;&amp; newSubScene.getRoot() == this) ||
                    (newScene != null &amp;&amp; newScene.getRoot() == this);
        layoutRoot = !isManaged() || sceneRoot;


        if (awaitingLayout) {
            // If this node is dirty and the new scene or subScene is not null
            // then add this node to the new scene's dirty list
            if (newScene != null &amp;&amp; layoutRoot) {
                if (newSubScene != null) {
                    newSubScene.setDirtyLayout(this);
                }
            }
        }
    }

    @Override
    void setDerivedDepthTest(boolean value) {
        super.setDerivedDepthTest(value);

        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            node.computeDerivedDepthTest();
        }
    }

    boolean pickChildrenNode(PickRay pickRay, PickResultChooser result) {
        List&lt;Node&gt; orderedChildren = getOrderedChildren();
        for (int i = orderedChildren.size() - 1; i &gt;= 0; i--) {
            orderedChildren.get(i).pickNode(pickRay, result);
            if (result.isClosed()) {
                return false;
            }
        }
        return true;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
         double boundsDistance = intersectsBounds(pickRay);

        if (!Double.isNaN(boundsDistance) &amp;&amp; pickChildrenNode(pickRay, result)) {
            if (isPickOnBounds()) {
                result.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
            }
        }
    }

    @Override boolean isConnected() {
        return super.isConnected() || sceneRoot;
    }

    @Override public Node lookup(String selector) {
        Node n = super.lookup(selector);
        if (n == null) {
            for (int i=0, max=children.size(); i&lt;max; i++) {
                final Node node = children.get(i);
                n = node.lookup(selector);
                if (n != null) return n;
            }
        }
        return n;
    }

    /**
     * Please Note: This method should never create the results set,
     * let the Node class implementation do this!
     */
    @Override List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
        results = super.lookupAll(selector, results);
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            results = node.lookupAll(selector, results);
        }
        return results;
    }

    private ParentTraversalEngine traversalEngine;

    private final void setTraversalEngine(ParentTraversalEngine value) {
        this.traversalEngine = value;
    }

    private final ParentTraversalEngine getTraversalEngine() {
        return traversalEngine;
    }

    /***********************************************************************
     *                               Layout                                *
     *                                                                     *
     *  Functions and variables related to the layout scheme used by       *
     *  JavaFX. Includes both public and private API.                      *
     *                                                                     *
     **********************************************************************/
    /**
     * Indicates that this Node and its subnodes requires a layout pass on
     * the next pulse.
     */
    private ReadOnlyBooleanWrapper needsLayout;
    LayoutFlags layoutFlag = LayoutFlags.CLEAN;

    protected final void setNeedsLayout(boolean value) {
        if (value) {
            markDirtyLayout(true, false);
        } else if (layoutFlag == LayoutFlags.NEEDS_LAYOUT) {
            boolean hasBranch = false;
            for (int i = 0, max = children.size(); i &lt; max; i++) {
                final Node child = children.get(i);
                if (child instanceof Parent) {
                    if (((Parent)child).layoutFlag != LayoutFlags.CLEAN) {
                        hasBranch = true;
                        break;
                    }

                }
            }
            setLayoutFlag(hasBranch ? LayoutFlags.DIRTY_BRANCH : LayoutFlags.CLEAN);
        }
    }

    public final boolean isNeedsLayout() {
        return layoutFlag == LayoutFlags.NEEDS_LAYOUT;
    }

    public final ReadOnlyBooleanProperty needsLayoutProperty() {
        if (needsLayout == null) {
            needsLayout = new ReadOnlyBooleanWrapper(this, &quot;needsLayout&quot;, layoutFlag == LayoutFlags.NEEDS_LAYOUT);
        }
        return needsLayout;
    }

    /**
     * This is used only by CCS in Node. It is set to true while
     * the layout() function is processing and set to false on the conclusion.
     * It is used by the Node to decide whether to perform CSS updates
     * synchronously or asynchronously.
     */
    private boolean performingLayout = false;

    boolean isPerformingLayout() {
        return performingLayout;
    }

    private boolean sizeCacheClear = true;
    private double prefWidthCache = -1;
    private double prefHeightCache = -1;
    private double minWidthCache = -1;
    private double minHeightCache = -1;

    void setLayoutFlag(LayoutFlags flag) {
        if (needsLayout != null) {
            needsLayout.set(flag == LayoutFlags.NEEDS_LAYOUT);
        }
        layoutFlag = flag;
    }

    private void markDirtyLayout(boolean local, boolean forceParentLayout) {
        setLayoutFlag(LayoutFlags.NEEDS_LAYOUT);
        if (local || layoutRoot) {
            if (sceneRoot) {
                Toolkit.getToolkit().requestNextPulse();
                if (getSubScene() != null) {
                    getSubScene().setDirtyLayout(this);
                }
            } else {
                markDirtyLayoutBranch();
            }
        } else {
            requestParentLayout(forceParentLayout);
        }
    }

    /**
     * Requests a layout pass to be performed before the next scene is
     * rendered. This is batched up asynchronously to happen once per
     * &quot;pulse&quot;, or frame of animation.
     * &lt;p&gt;
     * If this parent is either a layout root or unmanaged, then it will be
     * added directly to the scene's dirty layout list, otherwise requestParentLayout
     * will be invoked.
     * @since JavaFX 8.0
     */
    public void requestLayout() {
        clearSizeCache();
        markDirtyLayout(false, forceParentLayout);
    }

    private boolean forceParentLayout = false;
    /**
     * A package scope method used by Node and serves as a helper method for
     * requestLayout() (see above). If forceParentLayout is true it will
     * propagate this force layout flag to its parent.
     */
    void requestLayout(boolean forceParentLayout) {
        boolean savedForceParentLayout = this.forceParentLayout;
        this.forceParentLayout = forceParentLayout;
        requestLayout();
        this.forceParentLayout = savedForceParentLayout;
    }

    /**
     * Requests a layout pass of the parent to be performed before the next scene is
     * rendered. This is batched up asynchronously to happen once per
     * &quot;pulse&quot;, or frame of animation.
     * &lt;p&gt;
     * This may be used when the current parent have changed it's min/max/preferred width/height,
     * but doesn't know yet if the change will lead to it's actual size change. This will be determined
     * when it's parent recomputes the layout with the new hints.
     */
    protected final void requestParentLayout() {
       requestParentLayout(false);
    }

    /**
     * A package scope method used by Node and serves as a helper method for
     * requestParentLayout() (see above). If forceParentLayout is true it will
     * force a request layout call on its parent if its parent is not null.
     */
    void requestParentLayout(boolean forceParentLayout) {
        if (!layoutRoot) {
            final Parent p = getParent();
            if (p != null &amp;&amp; (!p.performingLayout || forceParentLayout)) {
                p.requestLayout();
            }
        }
    }

    void clearSizeCache() {
        if (sizeCacheClear) {
            return;
        }
        sizeCacheClear = true;
        prefWidthCache = -1;
        prefHeightCache = -1;
        minWidthCache = -1;
        minHeightCache = -1;
    }

    @Override public double prefWidth(double height) {
        if (height == -1) {
            if (prefWidthCache == -1) {
                prefWidthCache = computePrefWidth(-1);
                if (Double.isNaN(prefWidthCache) || prefWidthCache &lt; 0) prefWidthCache = 0;
                sizeCacheClear = false;
            }
            return prefWidthCache;
        } else {
            double result = computePrefWidth(height);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    @Override public double prefHeight(double width) {
        if (width == -1) {
            if (prefHeightCache == -1) {
                prefHeightCache = computePrefHeight(-1);
                if (Double.isNaN(prefHeightCache) || prefHeightCache &lt; 0) prefHeightCache = 0;
                sizeCacheClear = false;
            }
            return prefHeightCache;
        } else {
            double result = computePrefHeight(width);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    @Override public double minWidth(double height) {
        if (height == -1) {
            if (minWidthCache == -1) {
                minWidthCache = computeMinWidth(-1);
                if (Double.isNaN(minWidthCache) || minWidthCache &lt; 0) minWidthCache = 0;
                sizeCacheClear = false;
            }
            return minWidthCache;
        } else {
            double result = computeMinWidth(height);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    @Override public double minHeight(double width) {
        if (width == -1) {
            if (minHeightCache == -1) {
                minHeightCache = computeMinHeight(-1);
                if (Double.isNaN(minHeightCache) || minHeightCache &lt; 0) minHeightCache = 0;
                sizeCacheClear = false;
            }
            return minHeightCache;
        } else {
            double result = computeMinHeight(width);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    // PENDING_DOC_REVIEW
    /**
     * Calculates the preferred width of this {@code Parent}. The default
     * implementation calculates this width as the width of the area occupied
     * by its managed children when they are positioned at their
     * current positions at their preferred widths.
     *
     * @param height the height that should be used if preferred width depends
     *      on it
     * @return the calculated preferred width
     */
    protected double computePrefWidth(double height) {
        double minX = 0;
        double maxX = 0;
        for (int i=0, max=children.size(); i&lt;max; i++) {
            Node node = children.get(i);
            if (node.isManaged()) {
                final double x = node.getLayoutBounds().getMinX() + node.getLayoutX();
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x + boundedSize(node.prefWidth(-1), node.minWidth(-1), node.maxWidth(-1)));
            }
        }
        return maxX - minX;
    }

    // PENDING_DOC_REVIEW
    /**
     * Calculates the preferred height of this {@code Parent}. The default
     * implementation calculates this height as the height of the area occupied
     * by its managed children when they are positioned at their current
     * positions at their preferred heights.
     *
     * @param width the width that should be used if preferred height depends
     *      on it
     * @return the calculated preferred height
     */
    protected double computePrefHeight(double width) {
        double minY = 0;
        double maxY = 0;
        for (int i=0, max=children.size(); i&lt;max; i++) {
            Node node = children.get(i);
            if (node.isManaged()) {
                final double y = node.getLayoutBounds().getMinY() + node.getLayoutY();
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y + boundedSize(node.prefHeight(-1), node.minHeight(-1), node.maxHeight(-1)));
            }
        }
        return maxY - minY;
    }

    /**
     * Calculates the minimum width of this {@code Parent}. The default
     * implementation simply returns the pref width.
     *
     * @param height the height that should be used if min width depends
     *      on it
     * @return the calculated min width
     * @since JavaFX 2.1
     */
    protected double computeMinWidth(double height) {
        return prefWidth(height);
    }

    // PENDING_DOC_REVIEW
    /**
     * Calculates the min height of this {@code Parent}. The default
     * implementation simply returns the pref height;
     *
     * @param width the width that should be used if min height depends
     *      on it
     * @return the calculated min height
     * @since JavaFX 2.1
     */
    protected double computeMinHeight(double width) {
        return prefHeight(width);
    }

    /**
     * Calculates the baseline offset based on the first managed child. If there
     * is no such child, returns {@link Node#getBaselineOffset()}.
     *
     * @return baseline offset
     */
    @Override public double getBaselineOffset() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node child = children.get(i);
            if (child.isManaged()) {
                double offset = child.getBaselineOffset();
                if (offset == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                    continue;
                }
                return child.getLayoutBounds().getMinY() + child.getLayoutY() + offset;
            }
        }
        return super.getBaselineOffset();
    }

    /***
     * It stores the reference to the current child being laid out by its parent.
     * This reference is important to differentiate whether a layout is triggered
     * by its parent or other events.
     */
    private Node currentLayoutChild = null;

    boolean isCurrentLayoutChild(Node node) {
        return node == currentLayoutChild;
    }

    /**
     * Executes a top-down layout pass on the scene graph under this parent.
     *
     * Calling this method while the Parent is doing layout is a no-op.
     */
    public final void layout() {
        // layoutFlag can be accessed or changed during layout processing.
        // Hence we need to cache and reset it before performing layout.
        LayoutFlags flag = layoutFlag;
        setLayoutFlag(LayoutFlags.CLEAN);
        switch(flag) {
            case CLEAN:
                break;
            case NEEDS_LAYOUT:
                if (performingLayout) {
                    /* This code is here mainly to avoid infinite loops as layout() is public and the call might be (indirectly) invoked accidentally
                     * while doing the layout.
                     * One example might be an invocation from Group layout bounds recalculation
                     *  (e.g. during the localToScene/localToParent calculation).
                     * The layout bounds will thus return layout bounds that are &quot;old&quot; (i.e. before the layout changes, that are just being done),
                     * which is likely what the code would expect.
                     * The changes will invalidate the layout bounds again however, so the layout bounds query after layout pass will return correct answer.
                     */
                    break;
                }
                performingLayout = true;
                layoutChildren();
                // Intended fall-through
            case DIRTY_BRANCH:
                for (int i = 0, max = children.size(); i &lt; max; i++) {
                    final Node child = children.get(i);
                    currentLayoutChild = child;
                    if (child instanceof Parent) {
                        ((Parent)child).layout();
                    } else if (child instanceof SubScene) {
                        ((SubScene)child).layoutPass();
                    }
                }
                currentLayoutChild = null;
                performingLayout = false;
                break;
        }
    }

    /**
     * Invoked during the layout pass to layout the children in this
     * {@code Parent}. By default it will only set the size of managed,
     * resizable content to their preferred sizes and does not do any node
     * positioning.
     * &lt;p&gt;
     * Subclasses should override this function to layout content as needed.
     */
    protected void layoutChildren() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            currentLayoutChild = node;
            if (node.isResizable() &amp;&amp; node.isManaged()) {
                node.autosize();
            }
        }
        currentLayoutChild = null;
    }

    /**
     * This field is managed by the Scene, and set on any node which is the
     * root of a Scene.
     */
    private boolean sceneRoot = false;

    /**
     * Keeps track of whether this node is a layout root. This is updated
     * whenever the sceneRoot field changes, or whenever the managed
     * property changes.
     */
    boolean layoutRoot = false;
    @Override final void notifyManagedChanged() {
        layoutRoot = !isManaged() || sceneRoot;
    }

    final boolean isSceneRoot() {
        return sceneRoot;
    }

    /***********************************************************************
     *                                                                     *
     *                         Stylesheet Handling                         *
     *                                                                     *
     **********************************************************************/


    /**
     * A ObservableList of string URLs linking to the stylesheets to use with this scene's
     * contents. For additional information about using CSS with the
     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.
     */
    private final ObservableList&lt;String&gt; stylesheets = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            final Scene scene = getScene();
            if (scene != null) {

                // Notify the StyleManager if stylesheets change. This Parent's
                // styleManager will get recreated in NodeHelper.processCSS.
                StyleManager.getInstance().stylesheetsChanged(Parent.this, c);

                // RT-9784 - if stylesheet is removed, reset styled properties to
                // their initial value.
                c.reset();
                while(c.next()) {
                    if (c.wasRemoved() == false) {
                        continue;
                    }
                    break; // no point in resetting more than once...
                }

                reapplyCSS();
            }
        }
    };

    /**
     * Gets an observable list of string URLs linking to the stylesheets to use
     * with this Parent's contents. See {@link Scene#getStylesheets()} for details.
     * &lt;p&gt;For additional information about using CSS
     * with the scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.&lt;/p&gt;
     *
     * @return the list of stylesheets to use with this Parent
     * @since JavaFX 2.1
     */
    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }

    /*
     * This method recurses up the parent chain until parent is null. As the
     * stack unwinds, if the Parent has stylesheets, they are added to the
     * list.
     *
     * It is possible to override this method to stop the recursion. This allows
     * a Parent to have a set of stylesheets distinct from its Parent.
     *
     * Note: This method MUST only be called via its accessor method.
     */
     // SB-dependency: RT-21247 has been filed to track this
    private List&lt;String&gt; doGetAllParentStylesheets() {

        List&lt;String&gt; list = null;
        final Parent myParent = getParent();
        if (myParent != null) {

            //
            // recurse so that stylesheets of Parents closest to the root are
            // added to the list first. The ensures that declarations for
            // stylesheets further down the tree (closer to the leaf) have
            // a higer ordinal in the cascade.
            //
            list = ParentHelper.getAllParentStylesheets(myParent);
        }

        if (stylesheets != null &amp;&amp; stylesheets.isEmpty() == false) {
            if (list == null) {
                list = new ArrayList&lt;String&gt;(stylesheets.size());
            }
            for (int n=0,nMax=stylesheets.size(); n&lt;nMax; n++) {
                list.add(stylesheets.get(n));
            }
        }

        return list;

    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doProcessCSS() {

        // Nothing to do...
        if (cssFlag == CssFlags.CLEAN) return;

        // RT-29254 - If DIRTY_BRANCH, pass control to Node#processCSS. This avoids calling NodeHelper.processCSS on
        // this node and all of its children when css doesn't need updated, recalculated, or reapplied.
        if (cssFlag == CssFlags.DIRTY_BRANCH) {
            super.processCSS();
            return;
        }

        // Let the super implementation handle CSS for this node
        ParentHelper.superProcessCSS(this);

        // avoid the following call to children.toArray if there are no children
        if (children.isEmpty()) return;

        //
        // RT-33103
        //
        // It is possible for a child to be removed from children in the middle of
        // the following loop. Iterating over the children may result in an IndexOutOfBoundsException.
        // So a copy is made and the copy is iterated over.
        //
        // Note that we don't want the fail-fast feature of an iterator, not to mention the general iterator overhead.
        //
        final Node[] childArray = children.toArray(new Node[children.size()]);

        // For each child, process CSS
        for (int i=0; i&lt;childArray.length; i++) {

            final Node child = childArray[i];

            //  If a child no longer has this as its parent, then it is skipped.
            final Parent childParent = child.getParent();
            if (childParent == null || childParent != this) continue;

            // If the parent styles are being updated, recalculated or
            // reapplied, then make sure the children get the same treatment.
            // Unless the child is already more dirty than this parent (RT-29074).
            if(CssFlags.UPDATE.compareTo(child.cssFlag) &gt; 0) {
                child.cssFlag = CssFlags.UPDATE;
            }
            NodeHelper.processCSS(child);
        }
    }

    /***********************************************************************
     *                               Misc                                  *
     *                                                                     *
     *  Initialization and other functions                                 *
     *                                                                     *
     **********************************************************************/
    {
        // To initialize the class helper at the begining each constructor of this class
        ParentHelper.initHelper(this);
    }

    /**
     * Constructs a new {@code Parent}.
     */
    protected Parent() {
        layoutFlag = LayoutFlags.NEEDS_LAYOUT;
        setAccessibleRole(AccessibleRole.PARENT);
    }

    private NGNode doCreatePeer() {
        return new NGGroup();
    }

    @Override
    void nodeResolvedOrientationChanged() {
        for (int i = 0, max = children.size(); i &lt; max; ++i) {
            children.get(i).parentResolvedOrientationInvalidated();
        }
    }

    /***************************************************************************
     *                                                                         *
     *                         Bounds Computations                             *
     *                                                                         *
     *  This code originated in GroupBoundsHelper (part of javafx-sg-common)   *
     *  but has been ported here to the FX side since we cannot rely on the PG *
     *  side for computing the bounds (due to the decoupling of the two        *
     *  scenegraphs for threading and other purposes).                         *
     *                                                                         *
     *  Unfortunately, we cannot simply reuse GroupBoundsHelper without some  *
     *  major (and hacky) modification due to the fact that GroupBoundsHelper  *
     *  relies on PG state and we need to do similar things here that rely on  *
     *  core scenegraph state. Unfortunately, that means we made a port.       *
     *                                                                         *
     **************************************************************************/

    private BaseBounds tmp = new RectBounds();

    /**
     * The cached bounds for the Group. If the cachedBounds are invalid
     * then we have no history of what the bounds are, or were.
     */
    private BaseBounds cachedBounds = new RectBounds();

    /**
     * Indicates that the cachedBounds is invalid (or old) and need to be recomputed.
     * If cachedBoundsInvalid is true and dirtyChildrenCount is non-zero,
     * then when we recompute the cachedBounds we can consider the
     * values in cachedBounds to represent the last valid bounds for the group.
     * This is useful for several fast paths.
     */
    private boolean cachedBoundsInvalid;

    /**
     * The number of dirty children which bounds haven't been incorporated
     * into the cached bounds yet. Can be used even when dirtyChildren is null.
     */
    private int dirtyChildrenCount;

    /**
     * This set is used to track all of the children of this group which are
     * dirty. It is only used in cases where the number of children is &gt; some
     * value (currently 10). For very wide trees, this can provide a very
     * important speed boost. For the sake of memory consumption, this is
     * null unless the number of children ever crosses the threshold where
     * it will be activated.
     */
    private ArrayList&lt;Node&gt; dirtyChildren;

    private Node top;
    private Node left;
    private Node bottom;
    private Node right;
    private Node near;
    private Node far;

    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        // If we have no children, our bounds are invalid
        if (children.isEmpty()) {
            return bounds.makeEmpty();
        }

        if (tx.isTranslateOrIdentity()) {
            // this is a transform which is only doing translations, or nothing
            // at all (no scales, rotates, or shears)
            // so in this case we can easily use the cached bounds
            if (cachedBoundsInvalid) {
                recomputeBounds();

                if (dirtyChildren != null) {
                    dirtyChildren.clear();
                }
                cachedBoundsInvalid = false;
                dirtyChildrenCount = 0;
            }
            if (!tx.isIdentity()) {
                bounds = bounds.deriveWithNewBounds((float)(cachedBounds.getMinX() + tx.getMxt()),
                                 (float)(cachedBounds.getMinY() + tx.getMyt()),
                                 (float)(cachedBounds.getMinZ() + tx.getMzt()),
                                 (float)(cachedBounds.getMaxX() + tx.getMxt()),
                                 (float)(cachedBounds.getMaxY() + tx.getMyt()),
                                 (float)(cachedBounds.getMaxZ() + tx.getMzt()));
            } else {
                bounds = bounds.deriveWithNewBounds(cachedBounds);
            }

            return bounds;
        } else {
            // there is a scale, shear, or rotation happening, so need to
            // do the full transform!
            double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, minZ = Double.MAX_VALUE;
            double maxX = Double.MIN_VALUE, maxY = Double.MIN_VALUE, maxZ = Double.MIN_VALUE;
            boolean first = true;
            for (int i=0, max=children.size(); i&lt;max; i++) {
                final Node node = children.get(i);
                if (node.isVisible()) {
                    bounds = getChildTransformedBounds(node, tx, bounds);
                    // if the bounds of the child are invalid, we don't want
                    // to use those in the remaining computations.
                    if (bounds.isEmpty()) continue;
                    if (first) {
                        minX = bounds.getMinX();
                        minY = bounds.getMinY();
                        minZ = bounds.getMinZ();
                        maxX = bounds.getMaxX();
                        maxY = bounds.getMaxY();
                        maxZ = bounds.getMaxZ();
                        first = false;
                    } else {
                        minX = Math.min(bounds.getMinX(), minX);
                        minY = Math.min(bounds.getMinY(), minY);
                        minZ = Math.min(bounds.getMinZ(), minZ);
                        maxX = Math.max(bounds.getMaxX(), maxX);
                        maxY = Math.max(bounds.getMaxY(), maxY);
                        maxZ = Math.max(bounds.getMaxZ(), maxZ);
                    }
                }
            }
            // if &quot;first&quot; is still true, then we didn't have any children with
            // non-empty bounds and thus we must return an empty bounds,
            // otherwise we have non-empty bounds so go for it.
            if (first)
                bounds.makeEmpty();
            else
                bounds = bounds.deriveWithNewBounds((float)minX, (float)minY, (float)minZ,
                        (float)maxX, (float)maxY, (float)maxZ);

            return bounds;
        }
    }

    private void setChildDirty(final Node node, final boolean dirty) {
        if (node.boundsChanged == dirty) {
            return;
        }

        node.boundsChanged = dirty;
        if (dirty) {
            if (dirtyChildren != null) {
                dirtyChildren.add(node);
            }
            ++dirtyChildrenCount;
        } else {
            if (dirtyChildren != null) {
                dirtyChildren.remove(node);
            }
            --dirtyChildrenCount;
        }
    }

    private void childIncluded(final Node node) {
        // assert node.isVisible();
        cachedBoundsInvalid = true;
        setChildDirty(node, true);
    }

    // This is called when either the child is actually removed, OR IF IT IS
    // TOGGLED TO BE INVISIBLE. This is because in both cases it needs to be
    // cleared from the state which manages bounds.
    private void childExcluded(final Node node) {
        if (node == left) {
            left = null;
            cachedBoundsInvalid = true;
        }
        if (node == top) {
            top = null;
            cachedBoundsInvalid = true;
        }
        if (node == near) {
            near = null;
            cachedBoundsInvalid = true;
        }
        if (node == right) {
            right = null;
            cachedBoundsInvalid = true;
        }
        if (node == bottom) {
            bottom = null;
            cachedBoundsInvalid = true;
        }
        if (node == far) {
            far = null;
            cachedBoundsInvalid = true;
        }

        setChildDirty(node, false);
    }

    /**
     * Recomputes the bounds from scratch and saves the cached bounds.
     */
    private void recomputeBounds() {
        // fast path for case of no children
        if (children.isEmpty()) {
            cachedBounds.makeEmpty();
            return;
        }

        // fast path for case of 1 child
        if (children.size() == 1) {
            Node node = children.get(0);
            node.boundsChanged = false;
            if (node.isVisible()) {
                cachedBounds = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, cachedBounds);
                top = left = bottom = right = near = far = node;
            } else {
                cachedBounds.makeEmpty();
                // no need to null edge nodes here, it was done in childExcluded
                // top = left = bottom = right = near = far = null;
            }
            return;
        }

        if ((dirtyChildrenCount == 0) ||
                !updateCachedBounds(dirtyChildren != null
                                        ? dirtyChildren : children,
                                    dirtyChildrenCount)) {
            // failed to update cached bounds, recreate them
            createCachedBounds(children);
        }
    }

    private final int LEFT_INVALID = 1;
    private final int TOP_INVALID = 1 &lt;&lt; 1;
    private final int NEAR_INVALID = 1 &lt;&lt; 2;
    private final int RIGHT_INVALID = 1 &lt;&lt; 3;
    private final int BOTTOM_INVALID = 1 &lt;&lt; 4;
    private final int FAR_INVALID = 1 &lt;&lt; 5;

    private boolean updateCachedBounds(final List&lt;Node&gt; dirtyNodes,
                                       int remainingDirtyNodes) {
        // fast path for untransformed bounds calculation
        if (cachedBounds.isEmpty()) {
            createCachedBounds(dirtyNodes);
            return true;
        }

        int invalidEdges = 0;

        if ((left == null) || left.boundsChanged) {
            invalidEdges |= LEFT_INVALID;
        }
        if ((top == null) || top.boundsChanged) {
            invalidEdges |= TOP_INVALID;
        }
        if ((near == null) || near.boundsChanged) {
            invalidEdges |= NEAR_INVALID;
        }
        if ((right == null) || right.boundsChanged) {
            invalidEdges |= RIGHT_INVALID;
        }
        if ((bottom == null) || bottom.boundsChanged) {
            invalidEdges |= BOTTOM_INVALID;
        }
        if ((far == null) || far.boundsChanged) {
            invalidEdges |= FAR_INVALID;
        }

        // These indicate the bounds of the Group as computed by this
        // function
        float minX = cachedBounds.getMinX();
        float minY = cachedBounds.getMinY();
        float minZ = cachedBounds.getMinZ();
        float maxX = cachedBounds.getMaxX();
        float maxY = cachedBounds.getMaxY();
        float maxZ = cachedBounds.getMaxZ();

        // this checks the newly added nodes first, so if dirtyNodes is the
        // whole children list, we can end early
        for (int i = dirtyNodes.size() - 1; remainingDirtyNodes &gt; 0; --i) {
            final Node node = dirtyNodes.get(i);
            if (node.boundsChanged) {
                // assert node.isVisible();
                node.boundsChanged = false;
                --remainingDirtyNodes;
                tmp = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, tmp);
                if (!tmp.isEmpty()) {
                    float tmpx = tmp.getMinX();
                    float tmpy = tmp.getMinY();
                    float tmpz = tmp.getMinZ();
                    float tmpx2 = tmp.getMaxX();
                    float tmpy2 = tmp.getMaxY();
                    float tmpz2 = tmp.getMaxZ();

                    // If this node forms an edge, then we will set it to be the
                    // node for this edge and update the min/max values
                    if (tmpx &lt;= minX) {
                        minX = tmpx;
                        left = node;
                        invalidEdges &amp;= ~LEFT_INVALID;
                    }
                    if (tmpy &lt;= minY) {
                        minY = tmpy;
                        top = node;
                        invalidEdges &amp;= ~TOP_INVALID;
                    }
                    if (tmpz &lt;= minZ) {
                        minZ = tmpz;
                        near = node;
                        invalidEdges &amp;= ~NEAR_INVALID;
                    }
                    if (tmpx2 &gt;= maxX) {
                        maxX = tmpx2;
                        right = node;
                        invalidEdges &amp;= ~RIGHT_INVALID;
                    }
                    if (tmpy2 &gt;= maxY) {
                        maxY = tmpy2;
                        bottom = node;
                        invalidEdges &amp;= ~BOTTOM_INVALID;
                    }
                    if (tmpz2 &gt;= maxZ) {
                        maxZ = tmpz2;
                        far = node;
                        invalidEdges &amp;= ~FAR_INVALID;
                    }
                }
            }
        }

        if (invalidEdges != 0) {
            // failed to validate some edges
            return false;
        }

        cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
                                                        maxX, maxY, maxZ);
        return true;
    }

    private void createCachedBounds(final List&lt;Node&gt; fromNodes) {
        // These indicate the bounds of the Group as computed by this function
        float minX, minY, minZ;
        float maxX, maxY, maxZ;

        final int nodeCount = fromNodes.size();
        int i;

        // handle first visible non-empty node
        for (i = 0; i &lt; nodeCount; ++i) {
            final Node node = fromNodes.get(i);
            node.boundsChanged = false;
            if (node.isVisible()) {
                tmp = node.getTransformedBounds(
                               tmp, BaseTransform.IDENTITY_TRANSFORM);
                if (!tmp.isEmpty()) {
                    left = top = near = right = bottom = far = node;
                    break;
                }
            }
        }

        if (i == nodeCount) {
            left = top = near = right = bottom = far = null;
            cachedBounds.makeEmpty();
            return;
        }

        minX = tmp.getMinX();
        minY = tmp.getMinY();
        minZ = tmp.getMinZ();
        maxX = tmp.getMaxX();
        maxY = tmp.getMaxY();
        maxZ = tmp.getMaxZ();

        // handle remaining visible non-empty nodes
        for (++i; i &lt; nodeCount; ++i) {
            final Node node = fromNodes.get(i);
            node.boundsChanged = false;
            if (node.isVisible()) {
                tmp = node.getTransformedBounds(
                               tmp, BaseTransform.IDENTITY_TRANSFORM);
                if (!tmp.isEmpty()) {
                    final float tmpx = tmp.getMinX();
                    final float tmpy = tmp.getMinY();
                    final float tmpz = tmp.getMinZ();
                    final float tmpx2 = tmp.getMaxX();
                    final float tmpy2 = tmp.getMaxY();
                    final float tmpz2 = tmp.getMaxZ();

                    if (tmpx &lt; minX) { minX = tmpx; left = node; }
                    if (tmpy &lt; minY) { minY = tmpy; top = node; }
                    if (tmpz &lt; minZ) { minZ = tmpz; near = node; }
                    if (tmpx2 &gt; maxX) { maxX = tmpx2; right = node; }
                    if (tmpy2 &gt; maxY) { maxY = tmpy2; bottom = node; }
                    if (tmpz2 &gt; maxZ) { maxZ = tmpz2; far = node; }
                }
            }
        }

        cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
                                                        maxX, maxY, maxZ);
    }

    /**
     * Updates the bounds of this {@code Parent} and its children.
     */
    @Override protected void updateBounds() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            children.get(i).updateBounds();
        }
        super.updateBounds();
    }

    // Note: this marks the currently processed child in terms of transformed bounds. In rare situations like
    // in RT-37879, it might happen that the child bounds will be marked as invalid. Due to optimizations,
    // the invalidation must *always* be propagated to the parent, because the parent with some transformation
    // calls child's getTransformedBounds non-idenitity transform and the child's transformed bounds are thus not validated.
    // This does not apply to the call itself however, because the call will yield the correct result even if something
    // was invalidated during the computation. We can safely ignore such invalidations from that Node in this case
    private Node currentlyProcessedChild;

    private BaseBounds getChildTransformedBounds(Node node, BaseTransform tx, BaseBounds bounds) {
        currentlyProcessedChild = node;
        bounds = node.getTransformedBounds(bounds, tx);
        currentlyProcessedChild = null;
        return bounds;
    }

    /**
     * Called by Node whenever its bounds have changed.
     */
    void childBoundsChanged(Node node) {
        // See comment above at &quot;currentlyProcessedChild&quot; field
        if (node == currentlyProcessedChild) {
            return;
        }

        cachedBoundsInvalid = true;

        // mark the node such that the parent knows that the child's bounds
        // are not in sync with this parent. In this way, when the bounds
        // need to be computed, we'll come back and figure out the new bounds
        // for all the children which have boundsChanged set to true
        setChildDirty(node, true);

        // go ahead and indicate that the geom has changed for this parent,
        // even though once we figure it all out it may be that the bounds
        // have not changed
        NodeHelper.geomChanged(this);
    }

    /**
     * Called by node whenever the visibility of the node changes.
     */
    void childVisibilityChanged(Node node) {
        if (node.isVisible()) {
            childIncluded(node);
        } else {
            childExcluded(node);
        }

        NodeHelper.geomChanged(this);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        final Point2D tempPt = TempState.getInstance().point;
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            tempPt.x = (float)localX;
            tempPt.y = (float)localY;
            try {
                node.parentToLocal(tempPt);
            } catch (NoninvertibleTransformException e) {
                continue;
            }
            if (node.contains(tempPt.x, tempPt.y)) {
                return true;
            }
        }
        return false;
    }

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case CHILDREN: return getChildrenUnmodifiable();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    void releaseAccessible() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            node.releaseAccessible();
        }
        super.releaseAccessible();
    }

    /**
     * Note: The only user of this method is in unit test: Parent_structure_sync_Test.
     */
    List&lt;Node&gt; test_getRemoved() {
        return removed;
    }

    /**
     * Note: The only user of this method is in unit test:
     * Parent_viewOrderChildren_sync_Test.
     */
    List&lt;Node&gt; test_getViewOrderChildren() {
        return viewOrderChildren;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Scene.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Accessible;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.Utils;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.event.EventQueue;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.SceneEventDispatcher;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
import com.sun.javafx.scene.input.InputEventUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.SceneTraversalEngine;
import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.tk.*;
import com.sun.prism.impl.PrismSettings;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.NamedArg;
import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.css.CssMetaData;
import javafx.css.StyleableObjectProperty;
import javafx.event.*;
import javafx.geometry.*;
import javafx.scene.image.WritableImage;
import javafx.scene.input.*;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.PopupWindow;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.util.Callback;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import com.sun.javafx.logging.PulseLogger;

import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.scene.input.ClipboardHelper;
import com.sun.javafx.scene.input.TouchPointHelper;
import java.lang.ref.WeakReference;

/**
 * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 * The background of the scene is filled as specified by the {@code fill} property.
 * &lt;p&gt;
 * The application must specify the root {@code Node} for the scene graph by setting
 * the {@code root} property.   If a {@code Group} is used as the root, the
 * contents of the scene graph will be clipped by the scene's width and height and
 * changes to the scene's size (if user resizes the stage) will not alter the
 * layout of the scene graph.    If a resizable node (layout {@code Region} or
 * {@code Control} is set as the root, then the root's size will track the
 * scene's size, causing the contents to be relayed out as necessary.
 * &lt;p&gt;
 * The scene's size may be initialized by the application during construction.
 * If no size is specified, the scene will automatically compute its initial
 * size based on the preferred size of its content. If only one dimension is specified,
 * the other dimension is computed using the specified dimension, respecting content bias
 * of a root.
 * &lt;p&gt;
 * An application may request depth buffer support or scene anti-aliasing
 * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 * without any 3D transforms does not need a depth buffer nor scene
 * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 * transforms may use depth buffer support for proper depth sorted rendering; to
 * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 * shapes that have no 3D transforms. See
 * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 * &lt;p&gt;
 * The depthBuffer and antiAliasing flags are conditional features. With the
 * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 * for more information.
 * &lt;p&gt;
 * A default headlight will be added to a scene that contains one or more
 * {@code Shape3D} nodes, but no light nodes. This light source is a
 * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 *
 * &lt;p&gt;
 * A {@code Scene} may be created and modified on any thread until it is attached
 * to a {@link Window} that is {@link Window#isShowing() showing}.
 * After that, it must be modified only on the JavaFX Application Thread.
 * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 * multiple threads at the same time will lead to unpredictable results and
 * must be avoided.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;
import javafx.scene.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;

Group root = new Group();
Scene s = new Scene(root, 300, 300, Color.BLACK);

Rectangle r = new Rectangle(25,25,250,250);
r.setFill(Color.BLUE);

root.getChildren().add(r);
 * &lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;root&quot;)
public class Scene implements EventTarget {

    private double widthSetByUser = -1.0;
    private double heightSetByUser = -1.0;
    private boolean sizeInitialized = false;
    private final boolean depthBuffer;
    private final SceneAntialiasing antiAliasing;

    private int dirtyBits;

    final AccessControlContext acc = AccessController.getContext();

    private Camera defaultCamera;

    /**
     * A node that is temporarily responsible for the FOCUS_NODE
     * accessibility attribute. E.g. a currently active MenuBar.
     */
    private Node transientFocusContainer;

    //Neither width nor height are initialized and will be calculated according to content when this Scene
    //is shown for the first time.
//    public Scene() {
//        //this(-1, -1, (Parent) new Group());
//        this(-1, -1, (Parent)null);
//    }

    /**
     * Creates a Scene for a specific root Node.
     *
     * @param root The root node of the scene graph
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root) {
        this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

//Public constructor initializing public-init properties
//When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
//Unitialized dimension is calculated when Scene is shown for the first time.
//    public Scene(
//            @Default(&quot;-1&quot;) double width,
//            @Default(&quot;-1&quot;) double height) {
//        //this(width, height, (Parent)new Group());
//        this(width, height, (Parent)null);
//    }
//
//    public Scene(double width, double height, Paint fill) {
//        //this(width, height, (Parent) new Group());
//        this(width, height, (Parent)null);
//        setFill(fill);
//    }

    /**
     * Creates a Scene for a specific root Node with a specific size.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
        this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a fill.
     *
     * @param root The parent
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a specific size and fill.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
            @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, and specifies whether a depth buffer is created for this scene.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
     * transforms may use depth buffer support for proper depth sorted
     * rendering; to avoid depth fighting (also known as Z fighting), disable
     * depth testing on 2D shapes that have no 3D transforms. See
     * {@link Node#depthTestProperty() depthTest} for more information.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * &lt;p&gt;
     * The depthBuffer flag is a conditional feature and its default value is
     * false. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
        this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, specifies whether a depth buffer is created for this scene and
     * specifies whether scene anti-aliasing is requested.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer nor scene anti-aliasing support. A scene containing 3D
     * shapes or 2D shapes with 3D transforms may use depth buffer support for
     * proper depth sorted rendering; to avoid depth fighting (also known as Z
     * fighting), disable depth testing on 2D shapes that have no 3D transforms.
     * See {@link Node#depthTestProperty() depthTest} for more information. A
     * scene with 3D shapes may enable scene anti-aliasing to improve its
     * rendering quality.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * @param antiAliasing The scene anti-aliasing attribute. A value of
     * {@code null} is treated as DISABLED.
     * &lt;p&gt;
     * The depthBuffer and antiAliasing are conditional features. With the
     * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     * @since JavaFX 8.0
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
            @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
            @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
        this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);

        if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
                !Toolkit.getToolkit().isMSAASupported())
        {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                + &quot;antiAliasing&quot;);
        }
    }

    private Scene(Parent root, double width, double height, Paint fill,
            boolean depthBuffer, SceneAntialiasing antiAliasing) {
        this.depthBuffer = depthBuffer;
        this.antiAliasing = antiAliasing;
        if (root == null) {
            throw new NullPointerException(&quot;Root cannot be null&quot;);
        }

        if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;ConditionalFeature.SCENE3D&quot;);
        }

        init();
        setRoot(root);
        init(width, height);
        setFill(fill);
    }

    static {
            PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
                public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
                    synchronized (trackerMonitor) {
                        scene.tracker = tracker;
                    }
                }
                public PerformanceTracker getPerfTracker(Scene scene) {
                    synchronized (trackerMonitor) {
                        return scene.tracker;
                    }
                }
            });
            SceneHelper.setSceneAccessor(
                    new SceneHelper.SceneAccessor() {
                        @Override
                        public void enableInputMethodEvents(Scene scene, boolean enable) {
                            scene.enableInputMethodEvents(enable);
                        }

                        @Override
                        public void processKeyEvent(Scene scene, KeyEvent e) {
                            scene.processKeyEvent(e);
                        }

                        @Override
                        public void processMouseEvent(Scene scene, MouseEvent e) {
                            scene.processMouseEvent(e);
                        }

                        @Override
                        public void preferredSize(Scene scene) {
                            scene.preferredSize();
                        }

                        @Override
                        public void disposePeer(Scene scene) {
                            scene.disposePeer();
                        }

                        @Override
                        public void initPeer(Scene scene) {
                            scene.initPeer();
                        }

                        @Override
                        public void setWindow(Scene scene, Window window) {
                            scene.setWindow(window);
                        }

                        @Override
                        public TKScene getPeer(Scene scene) {
                            return scene.getPeer();
                        }

                        @Override
                        public void setAllowPGAccess(boolean flag) {
                            Scene.setAllowPGAccess(flag);
                        }

                        @Override
                        public void parentEffectiveOrientationInvalidated(
                                final Scene scene) {
                            scene.parentEffectiveOrientationInvalidated();
                        }

                        @Override
                        public Camera getEffectiveCamera(Scene scene) {
                            return scene.getEffectiveCamera();
                        }

                        @Override
                        public Scene createPopupScene(Parent root) {
                            return new Scene(root) {
                                       @Override
                                       void doLayoutPass() {
                                           resizeRootToPreferredSize(getRoot());
                                           super.doLayoutPass();
                                       }

                                       @Override
                                       void resizeRootOnSceneSizeChange(
                                               double newWidth,
                                               double newHeight) {
                                           // don't resize
                                       }
                                   };
                        }

                        @Override
                        public void setTransientFocusContainer(Scene scene, Node node) {
                            if (scene != null) {
                                scene.transientFocusContainer = node;
                            }
                        }

                        @Override
                        public Accessible getAccessible(Scene scene) {
                            return scene.getAccessible();
                        }
                    });
        }

        // Reserve space for 30 nodes in the dirtyNodes set.
        private static final int MIN_DIRTY_CAPACITY = 30;

        // For debugging
        private static boolean inSynchronizer = false;
        private static boolean inMousePick = false;
        private static boolean allowPGAccess = false;
        private static int pgAccessCount = 0;

        /**
         * Used for debugging purposes. Returns true if we are in either the
         * mouse event code (picking) or the synchronizer, or if the scene is
         * not yet initialized,
         *
         */
        static boolean isPGAccessAllowed() {
            return inSynchronizer || inMousePick || allowPGAccess;
        }

        static void setAllowPGAccess(boolean flag) {
            if (Utils.assertionEnabled()) {
                if (flag) {
                    pgAccessCount++;
                    allowPGAccess = true;
                }
                else {
                    if (pgAccessCount &lt;= 0) {
                        throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
                    }
                    if (--pgAccessCount == 0) {
                        allowPGAccess = false;
                    }
                }
            }
        }

        /**
         * If true, use the platform's drag gesture detection
         * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
         */
        private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;

    /**
     * Set of dirty nodes; processed once per frame by the synchronizer.
     * When a node's state changes such that it becomes &quot;dirty&quot; with respect
     * to the graphics stack and requires synchronization, then that node
     * is added to this list. Note that if state on the Node changes, but it
     * was already dirty, then the Node doesn't add itself again.
     * &lt;p&gt;
     * Because at initialization time every node in the scene graph is dirty,
     * we have a special state and special code path during initialization
     * that does not involve adding each node to the dirtyNodes list. When
     * dirtyNodes is null, that means this Scene has not yet been synchronized.
     * A good default size is then created for the dirtyNodes list.
     * &lt;p&gt;
     * We double-buffer the set so that we can add new nodes to the
     * set while processing the existing set. This avoids our having to
     * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
     */
    private Node[] dirtyNodes;
    private int dirtyNodesSize;

    /**
     * Add the specified node to this scene's dirty list. Called by the
     * markDirty method in Node or when the Node's scene changes.
     */
    void addToDirtyList(Node n) {
        if (dirtyNodes == null || dirtyNodesSize == 0) {
            if (peer != null) {
                Toolkit.getToolkit().requestNextPulse();
            }
        }

        if (dirtyNodes != null) {
            if (dirtyNodesSize == dirtyNodes.length) {
                Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
                System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
                dirtyNodes = tmp;
            }
            dirtyNodes[dirtyNodesSize++] = n;
        }
    }

    private void doCSSPass() {
        final Parent sceneRoot = getRoot();
        //
        // RT-17547: when the tree is synchronized, the dirty bits are
        // are cleared but the cssFlag might still be something other than
        // clean.
        //
        // Before RT-17547, the code checked the dirty bit. But this is
        // superfluous since the dirty bit will be set if the flag is not clean,
        // but the flag will never be anything other than clean if the dirty
        // bit is not set. The dirty bit is still needed, however, since setting
        // it ensures a pulse if no other dirty bits have been set.
        //
        // For the purpose of showing the change, the dirty bit
        // check code was commented out and not removed.
        //
//        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
        if (sceneRoot.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS
            sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
            sceneRoot.processCSS();
        }
    }

    void doLayoutPass() {
        final Parent r = getRoot();
        if (r != null) {
            r.layout();
        }
    }

    /**
     * The peer of this scene
     */
    private TKScene peer;

    /*
     * Get Scene's peer
     */
    TKScene getPeer() {
        return peer;
    }

    /**
     * The scene pulse listener that gets called on toolkit pulses
     */
    ScenePulseListener scenePulseListener = new ScenePulseListener();

    private List&lt;Runnable&gt; preLayoutPulseListeners;
    private List&lt;Runnable&gt; postLayoutPulseListeners;

    /**
     * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
     * any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening and also for modifying the scenegraph
     * (as it is called before CSS and layout, so any changes made will be properly
     * styled and positioned).
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (preLayoutPulseListeners == null) {
            preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        preLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene pre layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (preLayoutPulseListeners == null) {
            return;
        }
        preLayoutPulseListeners.remove(r);
    }

    /**
     * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening, but it is not suited to use cases related
     * to modifying the scenegraph (as it is called after CSS and layout, so
     * any changes will possibly be incorrect until the next pulse is run).
     * An alternative (and better) solution for situations where a scenegraph
     * modification is required to happen is to use either the
     * {@link #addPreLayoutPulseListener(Runnable)} API or the the
     * {@link javafx.animation.AnimationTimer} API.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (postLayoutPulseListeners == null) {
            postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        postLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene post layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (postLayoutPulseListeners == null) {
            return;
        }
        postLayoutPulseListeners.remove(r);
    }

    /**
     * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
     * for more information.
     * @return the SceneAntialiasing for this scene
     * @since JavaFX 8.0
     */
    public final SceneAntialiasing getAntiAliasing() {
        return antiAliasing;
    }

    private boolean getAntiAliasingInternal() {
        return (antiAliasing != null &amp;&amp;
                Toolkit.getToolkit().isMSAASupported() &amp;&amp;
                Platform.isSupported(ConditionalFeature.SCENE3D)) ?
                antiAliasing != SceneAntialiasing.DISABLED : false;
    }

    /**
     * The {@code Window} for this {@code Scene}
     */
    private ReadOnlyObjectWrapper&lt;Window&gt; window;

    void setWindow(Window value) {
        windowPropertyImpl().set(value);
    }

    public final Window getWindow() {
        return window == null ? null : window.get();
    }

    public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
        return windowPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
        if (window == null) {
            window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
                private Window oldWindow;

                @Override protected void invalidated() {
                    final Window newWindow = get();
                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
                    if (oldWindow != null) {
                        disposePeer();
                    }
                    if (newWindow != null) {
                        initPeer();
                    }
                    parentEffectiveOrientationInvalidated();

                    oldWindow = newWindow;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;window&quot;;
                }
            };
        }
        return window;
    }

    void initPeer() {
        assert peer == null;

        Window window = getWindow();
        // initPeer() is only called from Window, either when the window
        // is being shown, or the window scene is being changed. In any case
        // this scene's window cannot be null.
        assert window != null;

        TKStage windowPeer = WindowHelper.getPeer(window);
        if (windowPeer == null) {
            // This is fine, the window is not visible. initPeer() will
            // be called again later, when the window is being shown.
            return;
        }

        final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
        if (!isTransparentWindowsSupported) {
            PlatformImpl.addNoTransparencyStylesheetToScene(this);
        }

        PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);

        setAllowPGAccess(true);

        Toolkit tk = Toolkit.getToolkit();
        peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
        peer.setTKSceneListener(new ScenePeerListener());
        peer.setTKScenePaintListener(new ScenePeerPaintListener());
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
        peer.setRoot(getRoot().getPeer());
        peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
        NodeHelper.updatePeer(getEffectiveCamera());
        peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
        peer.markDirty();
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);

        setAllowPGAccess(false);

        tk.addSceneTkPulseListener(scenePulseListener);
        // listen to dnd gestures coming from the platform
        if (PLATFORM_DRAG_GESTURE_INITIATION) {
            if (dragGestureListener == null) {
                dragGestureListener = new DragGestureListener();
            }
            tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
        }
        tk.enableDrop(peer, new DropTargetListener());
        tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());

        PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
    }

    public void disposePeer() {
        if (peer == null) {
            // This is fine, the window is either not shown yet and there is no
            // need in disposing scene peer, or is hidden and disposePeer()
            // has already been called.
            return;
        }

        PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);

        Toolkit tk = Toolkit.getToolkit();
        tk.removeSceneTkPulseListener(scenePulseListener);
        if (accessible != null) {
            disposeAccessibles();
            Node root = getRoot();
            if (root != null) root.releaseAccessible();
            accessible.dispose();
            accessible = null;
        }
        peer.dispose();
        peer = null;

        PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
    }

    DnDGesture dndGesture = null;
    DragGestureListener dragGestureListener;
    /**
     * The horizontal location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper x;

    private final void setX(double value) {
        xPropertyImpl().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final ReadOnlyDoubleProperty xProperty() {
        return xPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper xPropertyImpl() {
        if (x == null) {
            x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
        }
        return x;
    }

    /**
     * The vertical location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper y;

    private final void setY(double value) {
        yPropertyImpl().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final ReadOnlyDoubleProperty yProperty() {
        return yPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper yPropertyImpl() {
        if (y == null) {
            y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
        }
        return y;
    }

    /**
     * The width of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper width;

    private final void setWidth(double value) {
        widthPropertyImpl().set(value);
    }

    public final double getWidth() {
        return width == null ? 0.0 : width.get();
    }

    public final ReadOnlyDoubleProperty widthProperty() {
        return widthPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper widthPropertyImpl() {
        if (width == null) {
            width = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    //TODO - use a better method to update mirroring
                    if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                        NodeHelper.transformsChanged(_root);
                    }
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
                    }

                    getEffectiveCamera().setViewWidth(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;width&quot;;
                }
            };
        }
        return width;
    }

    /**
     * The height of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper height;

    private final void setHeight(double value) {
        heightPropertyImpl().set(value);
    }

    public final double getHeight() {
        return height == null ? 0.0 : height.get();
    }

    public final ReadOnlyDoubleProperty heightProperty() {
        return heightPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper heightPropertyImpl() {
        if (height == null) {
            height = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
                    }

                    getEffectiveCamera().setViewHeight(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;height&quot;;
                }
            };
        }
        return height;
    }

    void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
        getRoot().resize(newWidth, newHeight);
    }

    // Reusable target wrapper (to avoid creating new one for each picking)
    private TargetWrapper tmpTargetWrapper = new TargetWrapper();

    /**
     * Specifies the type of camera use for rendering this {@code Scene}.
     * If {@code camera} is null, a parallel camera is used for rendering.
     * It is illegal to set a camera that belongs to other {@code Scene}
     * or {@code SubScene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Camera&gt; camera;

    public final void setCamera(Camera value) {
        cameraProperty().set(value);
    }

    public final Camera getCamera() {
        return camera == null ? null : camera.get();
    }

    public final ObjectProperty&lt;Camera&gt; cameraProperty() {
        if (camera == null) {
            camera = new ObjectPropertyBase&lt;Camera&gt;() {
                Camera oldCamera = null;

                @Override
                protected void invalidated() {
                    Camera _value = get();
                    if (_value != null) {
                        if (_value instanceof PerspectiveCamera
                                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
                            String logname = Scene.class.getName();
                            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                                    + &quot;ConditionalFeature.SCENE3D&quot;);
                        }
                        // Illegal value if it belongs to other scene or any subscene
                        if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
                                || _value.getSubScene() != null) {
                            throw new IllegalArgumentException(_value
                                    + &quot;is already part of other scene or subscene&quot;);
                        }
                        // throws exception if the camera already has a different owner
                        _value.setOwnerScene(Scene.this);
                        _value.setViewWidth(getWidth());
                        _value.setViewHeight(getHeight());
                    }
                    if (oldCamera != null &amp;&amp; oldCamera != _value) {
                        oldCamera.setOwnerScene(null);
                    }
                    oldCamera = _value;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;camera&quot;;
                }
            };
        }
        return camera;
    }

    Camera getEffectiveCamera() {
        final Camera cam = getCamera();
        if (cam == null
                || (cam instanceof PerspectiveCamera
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
            if (defaultCamera == null) {
                defaultCamera = new ParallelCamera();
                defaultCamera.setOwnerScene(this);
                defaultCamera.setViewWidth(getWidth());
                defaultCamera.setViewHeight(getHeight());
            }
            return defaultCamera;
        }

        return cam;
    }

    // Used by the camera
    void markCameraDirty() {
        markDirty(DirtyBits.CAMERA_DIRTY);
        setNeedsRepaint();
    }

    void markCursorDirty() {
        markDirty(DirtyBits.CURSOR_DIRTY);
    }

    /**
     * Defines the background fill of this {@code Scene}. Both a {@code null}
     * value meaning 'paint no background' and a {@link javafx.scene.paint.Paint}
     * with transparency are supported. The default fill of the Scene is
     * {@link Color#WHITE}, but it is more commonly the case that the initial
     * color shown to users is the background fill of the
     * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
     * stretched to take up all available space in the {@code Scene}. The
     * root node of the {@code Scene} is given the CSS style class 'root', and
     * the default user agent stylesheets that ship with JavaFX (presently
     * Caspian and Modena) apply styling on to this root style class. In the
     * case of Caspian this does not impact the background fill color of the
     * root node, but in the case of Modena the default fill is set to be a
     * light gray color.
     *
     * @defaultValue WHITE
     */
    private ObjectProperty&lt;Paint&gt; fill;

    public final void setFill(Paint value) {
        fillProperty().set(value);
    }

    public final Paint getFill() {
        return fill == null ? Color.WHITE : fill.get();
    }

    public final ObjectProperty&lt;Paint&gt; fillProperty() {
        if (fill == null) {
            fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {

                @Override
                protected void invalidated() {
                    markDirty(DirtyBits.FILL_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;fill&quot;;
                }
            };
        }
        return fill;
    }

    /**
     * Defines the root {@code Node} of the scene graph.
     * If a {@code Group} is used as the root, the
     * contents of the scene graph will be clipped by the scene's width and height and
     * changes to the scene's size (if user resizes the stage) will not alter the
     * layout of the scene graph.    If a resizable node (layout {@code Region} or
     * {@code Control}) is set as the root, then the root's size will track the
     * scene's size, causing the contents to be relayed out as necessary.
     *
     * Scene doesn't accept null root.
     *
     */
    private ObjectProperty&lt;Parent&gt; root;

    public final void setRoot(Parent value) {
        rootProperty().set(value);
    }

    public final Parent getRoot() {
        return root == null ? null : root.get();
    }

    Parent oldRoot;
    public final ObjectProperty&lt;Parent&gt; rootProperty() {
        if (root == null) {
            root = new ObjectPropertyBase&lt;Parent&gt;() {

                private void forceUnbind() {
                    System.err.println(&quot;Unbinding illegal root.&quot;);
                    unbind();
                }

                @Override
                protected void invalidated() {
                    Parent _value = get();

                    if (_value == null) {
                        if (isBound()) forceUnbind();
                        throw new NullPointerException(&quot;Scene's root cannot be null&quot;);
                    }

                    if (_value.getParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already inside a scene-graph and cannot be set as root&quot;);
                    }
                    if (_value.getClipParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is set as a clip on another node, so cannot be set as root&quot;);
                    }
                    if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already set as root of another scene&quot;);
                    }

                    if (oldRoot != null) {
                        oldRoot.setScenes(null, null);
                    }
                    oldRoot = _value;
                    _value.getStyleClass().add(0, &quot;root&quot;);
                    _value.setScenes(Scene.this, null);
                    markDirty(DirtyBits.ROOT_DIRTY);
                    _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
                    _value.requestLayout();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;root&quot;;
                }
            };
        }
        return root;
    }

    void setNeedsRepaint() {
        if (this.peer != null) {
            peer.entireSceneNeedsRepaint();
        }
    }

    // Process CSS and layout and sync the scene prior to the snapshot
    // operation of the given node for this scene (currently the node
    // is unused but could possibly be used in the future to optimize this)
    void doCSSLayoutSyncForSnapshot(Node node) {
        if (!sizeInitialized) {
            preferredSize();
        } else {
            doCSSPass();
        }

        // we do not need pulse in the snapshot code
        // because this scene can be stage-less
        doLayoutPass();

        getRoot().updateBounds();
        if (peer != null) {
            peer.waitForRenderingToComplete();
            peer.waitForSynchronization();
            try {
                // Run the synchronizer while holding the render lock
                scenePulseListener.synchronizeSceneNodes();
            } finally {
                peer.releaseSynchronization(false);
            }
        } else {
            scenePulseListener.synchronizeSceneNodes();
        }

    }

    // Shared method for Scene.snapshot and Node.snapshot. It is static because
    // we might be doing a Node snapshot with a null scene
    static WritableImage doSnapshot(Scene scene,
            double x, double y, double w, double h,
            Node root, BaseTransform transform, boolean depthBuffer,
            Paint fill, Camera camera, WritableImage wimg) {

        Toolkit tk = Toolkit.getToolkit();
        Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();

        int xMin = (int)Math.floor(x);
        int yMin = (int)Math.floor(y);
        int xMax = (int)Math.ceil(x + w);
        int yMax = (int)Math.ceil(y + h);
        int width = Math.max(xMax - xMin, 1);
        int height = Math.max(yMax - yMin, 1);
        if (wimg == null) {
            wimg = new WritableImage(width, height);
        } else {
            width = (int)wimg.getWidth();
            height = (int)wimg.getHeight();
        }

        setAllowPGAccess(true);
        context.x = xMin;
        context.y = yMin;
        context.width = width;
        context.height = height;
        context.transform = transform;
        context.depthBuffer = depthBuffer;
        context.root = root.getPeer();
        context.platformPaint = fill == null ? null : tk.getPaint(fill);
        double cameraViewWidth = 1.0;
        double cameraViewHeight = 1.0;
        if (camera != null) {
            // temporarily adjust camera viewport to the snapshot size
            cameraViewWidth = camera.getViewWidth();
            cameraViewHeight = camera.getViewHeight();
            camera.setViewWidth(width);
            camera.setViewHeight(height);
            NodeHelper.updatePeer(camera);
            context.camera = camera.getPeer();
        } else {
            context.camera = null;
        }

        // Grab the lights from the scene
        context.lights = null;
        if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
            context.lights = new NGLightBase[scene.lights.size()];
            for (int i = 0; i &lt; scene.lights.size(); i++) {
                context.lights[i] = scene.lights.get(i).getPeer();
            }
        }

        Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
        context.platformImage = accessor.getTkImageLoader(wimg);
        setAllowPGAccess(false);
        Object tkImage = tk.renderToImage(context);
        accessor.loadTkImage(wimg, tkImage);

        if (camera != null) {
            setAllowPGAccess(true);
            camera.setViewWidth(cameraViewWidth);
            camera.setViewHeight(cameraViewHeight);
            NodeHelper.updatePeer(camera);
            setAllowPGAccess(false);
        }

        // if this scene belongs to some stage
        // we need to mark the entire scene as dirty
        // because dirty logic is buggy
        if (scene != null &amp;&amp; scene.peer != null) {
            scene.setNeedsRepaint();
        }

        return wimg;
    }

    /**
     * Implementation method for snapshot
     */
    private WritableImage doSnapshot(WritableImage img) {
        // TODO: no need to do CSS, layout or sync in the deferred case,
        // if this scene is attached to a visible stage
        doCSSLayoutSyncForSnapshot(getRoot());

        double w = getWidth();
        double h = getHeight();
        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;

        return doSnapshot(this, 0, 0, w, h,
                getRoot(), transform, isDepthBufferInternal(),
                getFill(), getEffectiveCamera(), img);
    }

    // Pulse listener used to run all deferred (async) snapshot requests
    private static TKPulseListener snapshotPulseListener = null;

    private static List&lt;Runnable&gt; snapshotRunnableListA;
    private static List&lt;Runnable&gt; snapshotRunnableListB;
    private static List&lt;Runnable&gt; snapshotRunnableList;

    static void addSnapshotRunnable(final Runnable runnable) {
        Toolkit.getToolkit().checkFxUserThread();

        if (snapshotPulseListener == null) {
            snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableList = snapshotRunnableListA;

            snapshotPulseListener = () -&gt; {
                if (snapshotRunnableList.size() &gt; 0) {
                    List&lt;Runnable&gt; runnables = snapshotRunnableList;
                    if (snapshotRunnableList == snapshotRunnableListA) {
                        snapshotRunnableList = snapshotRunnableListB;
                    } else {
                        snapshotRunnableList = snapshotRunnableListA;
                    }
                    for (Runnable r : runnables) {
                        try {
                            r.run();
                        } catch (Throwable th) {
                            System.err.println(&quot;Exception in snapshot runnable&quot;);
                            th.printStackTrace(System.err);
                        }
                    }
                    runnables.clear();
                }
            };

            // Add listener that will be called after all of the scenes have
            // had layout and CSS processing, and have been synced
            Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
        }

        final AccessControlContext acc = AccessController.getContext();
        snapshotRunnableList.add(() -&gt; {
            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                runnable.run();
                return null;
            }, acc);
        });
        Toolkit.getToolkit().requestNextPulse();
    }

    /**
     * Takes a snapshot of this scene and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        return doSnapshot(image);
    }

    /**
     * Takes a snapshot of this scene at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the scene is rendered.
     * If any such events modify a node in the scene that modification will
     * be reflected in the rendered image (as it will also be reflected in
     * the frame rendered to the Stage).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image and the source scene
     * that was rendered. The callback parameter must not be null.
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theImage);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            SnapshotResult result = new SnapshotResult(img, Scene.this, null);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };
//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        addSnapshotRunnable(snapshotRunnable);
    }

    /**
     * Defines the mouse cursor for this {@code Scene}.
     */
    private ObjectProperty&lt;Cursor&gt; cursor;

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return cursor == null ? null : cursor.get();
    }

    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        if (cursor == null) {
            cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
                         @Override
                         protected void invalidated() {
                             markCursorDirty();
                         }

                         @Override
                         public Object getBean() {
                             return Scene.this;
                         }

                         @Override
                         public String getName() {
                             return &quot;cursor&quot;;
                         }
                     };
        }
        return cursor;
    }

    /**
     * Looks for any node within the scene graph based on the specified CSS selector.
     * If more than one node matches the specified selector, this function
     * returns the first of them.
     * If no nodes are found with this id, then null is returned.
     *
     * @param selector The css selector to look up
     * @return the {@code Node} in the scene which matches the CSS {@code selector},
     * or {@code null} if none is found.
     */
     public Node lookup(String selector) {
         return getRoot().lookup(selector);
     }
    /**
     * A ObservableList of string URLs linking to the stylesheets to use with this scene's
     * contents. For additional information about using CSS with the
     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.
     */
    private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
            // RT-9784 - if stylesheet is removed, reset styled properties to
            // their initial value.
            c.reset();
            while(c.next()) {
                if (c.wasRemoved() == false) {
                    continue;
                }
                break; // no point in resetting more than once...
            }
            getRoot().reapplyCSS();
        }
    };

    /**
     * Gets an observable list of string URLs linking to the stylesheets to use
     * with this scene's contents.
     * &lt;p&gt;
     * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     *
     * package com.example.javafx.app;
     *
     * import javafx.application.Application;
     * import javafx.scene.Group;
     * import javafx.scene.Scene;
     * import javafx.stage.Stage;
     *
     * public class MyApp extends Application {
     *
     *     {@literal @}Override public void start(Stage stage) {
     *         Scene scene = new Scene(new Group());
     *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
     *         stage.setScene(scene);
     *         stage.show();
     *     }
     *
     *     public static void main(String[] args) {
     *         launch(args);
     *     }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     *
     * @return the list of stylesheets to use with this scene
     */
    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }

    private ObjectProperty&lt;String&gt; userAgentStylesheet = null;

    /**
     * @return the userAgentStylesheet property.
     * @see #getUserAgentStylesheet()
     * @see #setUserAgentStylesheet(String)
     * @since  JavaFX 8u20
     */
    public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
        if (userAgentStylesheet == null) {
            userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
                @Override protected void invalidated() {
                    StyleManager.getInstance().forget(Scene.this);
                    getRoot().reapplyCSS();
                }
            };
        }
        return userAgentStylesheet;
    }

    /**
     * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @return The URL of the user-agent stylesheet that will be used by this Scene,
     * or null if has not been set.
     * @since  JavaFX 8u20
     */
    public final String getUserAgentStylesheet() {
        return userAgentStylesheet == null ? null : userAgentStylesheet.get();
    }

    /**
     * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
     * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * @since  JavaFX 8u20
     */
    public final void setUserAgentStylesheet(String url) {
        userAgentStylesheetProperty().set(url);
    }

    /**
     * Retrieves the depth buffer attribute for this scene.
     * @return the depth buffer attribute.
     */
    public final boolean isDepthBuffer() {
        return depthBuffer;
    }

    boolean isDepthBufferInternal() {
        if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
            return false;
        }
        return depthBuffer;
    }

    private void init(double width, double height) {
        if (width &gt;= 0) {
            widthSetByUser = width;
            setWidth((float)width);
        }
        if (height &gt;= 0) {
            heightSetByUser = height;
            setHeight((float)height);
        }
        sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
    }

    private void init() {
        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
        }
        mouseHandler = new MouseHandler();
        clickGenerator = new ClickGenerator();

        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
        }
    }

    void preferredSize() {
        final Parent root = getRoot();

        // one or the other isn't initialized, need to perform layout in
        // order to ensure we can properly measure the preferred size of the
        // scene
        doCSSPass();

        resizeRootToPreferredSize(root);
        doLayoutPass();

        if (widthSetByUser &lt; 0) {
            setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
                            root.getBoundsInParent().getMaxX());
        } else {
            setWidth(widthSetByUser);
        }

        if (heightSetByUser &lt; 0) {
            setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
                            root.getBoundsInParent().getMaxY());
        } else {
            setHeight(heightSetByUser);
        }

        sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);

        PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
    }

    final void resizeRootToPreferredSize(Parent root) {
        final double preferredWidth;
        final double preferredHeight;

        final Orientation contentBias = root.getContentBias();
        if (contentBias == null) {
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
        } else if (contentBias == Orientation.HORIZONTAL) {
            // height depends on width
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser,
                                                       preferredWidth);
        } else /* if (contentBias == Orientation.VERTICAL) */ {
            // width depends on height
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
            preferredWidth = getPreferredWidth(root, widthSetByUser,
                                                     preferredHeight);
        }

        root.resize(preferredWidth, preferredHeight);
    }

    private static double getPreferredWidth(Parent root,
                                            double forcedWidth,
                                            double height) {
        if (forcedWidth &gt;= 0) {
            return forcedWidth;
        }
        final double normalizedHeight = (height &gt;= 0) ? height : -1;
        return root.boundedSize(root.prefWidth(normalizedHeight),
                                root.minWidth(normalizedHeight),
                                root.maxWidth(normalizedHeight));
    }

    private static double getPreferredHeight(Parent root,
                                             double forcedHeight,
                                             double width) {
        if (forcedHeight &gt;= 0) {
            return forcedHeight;
        }
        final double normalizedWidth = (width &gt;= 0) ? width : -1;
        return root.boundedSize(root.prefHeight(normalizedWidth),
                                root.minHeight(normalizedWidth),
                                root.maxHeight(normalizedWidth));
    }

    private PerformanceTracker tracker;
    private static final Object trackerMonitor = new Object();

    // mouse events handling
    private MouseHandler mouseHandler;
    private ClickGenerator clickGenerator;

    // gesture events handling
    private Point2D cursorScreenPos;
    private Point2D cursorScenePos;

    private static class TouchGesture {
        WeakReference&lt;EventTarget&gt; target;
        Point2D sceneCoords;
        Point2D screenCoords;
        boolean finished;
    }

    private final TouchGesture scrollGesture = new TouchGesture();
    private final TouchGesture zoomGesture = new TouchGesture();
    private final TouchGesture rotateGesture = new TouchGesture();
    private final TouchGesture swipeGesture = new TouchGesture();

    // touch events handling
    private TouchMap touchMap = new TouchMap();
    private TouchEvent nextTouchEvent = null;
    private TouchPoint[] touchPoints = null;
    private int touchEventSetId = 0;
    private int touchPointIndex = 0;
    private Map&lt;Integer, EventTarget&gt; touchTargets =
            new HashMap&lt;Integer, EventTarget&gt;();

    void processMouseEvent(MouseEvent e) {
        mouseHandler.process(e, false);
    }

    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
        EventTarget eventTarget = null;
        Scene.inMousePick = true;
        if (isKeyboardTrigger) {
            Node sceneFocusOwner = getFocusOwner();

            // for keyboard triggers set coordinates inside focus owner
            final double xOffset = xAbs - x2;
            final double yOffset = yAbs - y2;
            if (sceneFocusOwner != null) {
                final Bounds bounds = sceneFocusOwner.localToScene(
                        sceneFocusOwner.getBoundsInLocal());
                x2 = bounds.getMinX() + bounds.getWidth() / 4;
                y2 = bounds.getMinY() + bounds.getHeight() / 2;
                eventTarget = sceneFocusOwner;
            } else {
                x2 = Scene.this.getWidth() / 4;
                y2 = Scene.this.getWidth() / 2;
                eventTarget = Scene.this;
            }

            xAbs = x2 + xOffset;
            yAbs = y2 + yOffset;
        }

        final PickResult res = pick(x2, y2);

        if (!isKeyboardTrigger) {
            eventTarget = res.getIntersectedNode();
            if (eventTarget == null) {
                eventTarget = this;
            }
        }

        if (eventTarget != null) {
            ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
            Event.fireEvent(eventTarget, context);
        }
        Scene.inMousePick = false;
    }

    private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
        EventTarget pickedTarget = null;

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = null;
            gesture.finished = false;
        }

        if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
            pickedTarget = gesture.target.get();
        } else {
            pickedTarget = e.getPickResult().getIntersectedNode();
            if (pickedTarget == null) {
                pickedTarget = this;
            }
        }

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = new WeakReference&lt;&gt;(pickedTarget);
        }
        if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
                e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
                e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
                !e.isInertia()) {
            gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
            gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
        }

        if (pickedTarget != null) {
            Event.fireEvent(pickedTarget, e);
        }

        if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
                e.getEventType() == RotateEvent.ROTATION_FINISHED ||
                e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
            gesture.finished = true;
        }
    }

    private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
        inMousePick = true;
        touchEventSetId++;

        List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);

        // fire all the events
        for (TouchPoint tp : touchPoints) {
            if (tp.getTarget() != null) {
                EventType&lt;TouchEvent&gt; type = null;
                switch (tp.getState()) {
                    case MOVED:
                        type = TouchEvent.TOUCH_MOVED;
                        break;
                    case PRESSED:
                        type = TouchEvent.TOUCH_PRESSED;
                        break;
                    case RELEASED:
                        type = TouchEvent.TOUCH_RELEASED;
                        break;
                    case STATIONARY:
                        type = TouchEvent.TOUCH_STATIONARY;
                        break;
                }

                for (TouchPoint t : touchPoints) {
                    TouchPointHelper.reset(t);
                }

                TouchEvent te = new TouchEvent(type, tp, touchList,
                        touchEventSetId, e.isShiftDown(), e.isControlDown(),
                        e.isAltDown(), e.isMetaDown());

                Event.fireEvent(tp.getTarget(), te);
            }
        }

        // process grabbing
        for (TouchPoint tp : touchPoints) {
            EventTarget grabbed = tp.getGrabbed();
            if (grabbed != null) {
                touchTargets.put(tp.getId(), grabbed);
            };

            if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
        }

        inMousePick = false;
    }

    /**
     * Note: The only user of this method is in unit test: PickAndContainTest.
     */
    Node test_pick(double x, double y) {
        inMousePick = true;
        PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
                Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
        inMousePick = false;
        if (result != null) {
            return result.getIntersectedNode();
        }
        return null;
    }

    private PickResult pick(final double x, final double y) {
        pick(tmpTargetWrapper, x, y);
        return tmpTargetWrapper.getResult();
    }

    private boolean isInScene(double x, double y) {
        if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
            return false;
        }

        Window w = getWindow();
        if (w instanceof Stage
                &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
                &amp;&amp; getFill() == null) {
            return false;
        }

        return true;
    }

    private void pick(TargetWrapper target, final double x, final double y) {
        final PickRay pickRay = getEffectiveCamera().computePickRay(
                x, y, null);

        final double mag = pickRay.getDirectionNoClone().length();
        pickRay.getDirectionNoClone().normalize();
        final PickResult res = mouseHandler.pickNode(pickRay);
        if (res != null) {
            target.setNodeResult(res);
        } else {
            //TODO: is this the intersection with projection plane?
            Vec3d o = pickRay.getOriginNoClone();
            Vec3d d = pickRay.getDirectionNoClone();
            target.setSceneResult(new PickResult(
                    null, new Point3D(
                    o.x + mag * d.x,
                    o.y + mag * d.y,
                    o.z + mag * d.z),
                    mag),
                    isInScene(x, y) ? this : null);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Key Events and Focus Traversal                                          *
     *                                                                         *
     **************************************************************************/

    /*
     * We cannot initialize keyHandler in init because some of the triggers
     * access it before the init block.
     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
     * does not compile.
     */
    private KeyHandler keyHandler = null;
    private KeyHandler getKeyHandler() {
        if (keyHandler == null) {
            keyHandler = new KeyHandler();
        }
        return keyHandler;
    }
    /**
     * Set to true if something has happened to the focused node that makes
     * it no longer eligible to have the focus.
     *
     */
    private boolean focusDirty = true;

    final void setFocusDirty(boolean value) {
        if (!focusDirty) {
            Toolkit.getToolkit().requestNextPulse();
        }
        focusDirty = value;
    }

    final boolean isFocusDirty() {
        return focusDirty;
    }

    private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);

    /**
     * Traverses focus from the given node in the given direction.
     */
    boolean traverse(Node node, Direction dir) {
        if (node.getSubScene() != null) {
            return node.getSubScene().traverse(node, dir);
        }
        return traversalEngine.trav(node, dir) != null;
    }

    /**
     * Moves the focus to a reasonable initial location. Called when a scene's
     * focus is dirty and there's no current owner, or if the owner has been
     * removed from the scene.
     */
    private void focusInitial() {
        traversalEngine.traverseToFirst();
    }

    /**
     * Moves the focus to a reasonble location &quot;near&quot; the given node.
     * Called when the focused node is no longer eligible to have
     * the focus because it has become invisible or disabled. This
     * function assumes that it is still a member of the same scene.
     */
    private void focusIneligible(Node node) {
        traverse(node, Direction.NEXT);
    }

    public void processKeyEvent(KeyEvent e) {
        if (dndGesture != null) {
            if (!dndGesture.processKey(e)) {
                dndGesture = null;
            }
        }

        getKeyHandler().process(e);
    }

    void requestFocus(Node node) {
        getKeyHandler().requestFocus(node);
    }

    private Node oldFocusOwner;

    /**
      * The scene's current focus owner node. This node's &quot;focused&quot;
      * variable might be false if this scene has no window, or if the
      * window is inactive (window.focused == false).
      * @since JavaFX 2.2
      */
    private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {

        @Override
        protected void invalidated() {
            if (oldFocusOwner != null) {
                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
            }
            Node value = get();
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
                if (value != oldFocusOwner) {
                    value.getScene().enableInputMethodEvents(
                            value.getInputMethodRequests() != null
                            &amp;&amp; value.getOnInputMethodTextChanged() != null);
                }
            }
            // for the rest of the method we need to update the oldFocusOwner
            // and use a local copy of it because the user handlers can cause
            // recurrent calls of requestFocus
            Node localOldOwner = oldFocusOwner;
            oldFocusOwner = value;
            if (localOldOwner != null) {
                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
            }
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
            }
            PlatformLogger logger = Logging.getFocusLogger();
            if (logger.isLoggable(Level.FINE)) {
                if (value == get()) {
                    logger.fine(&quot;Changed focus from &quot;
                            + localOldOwner + &quot; to &quot; + value);
                } else {
                    logger.fine(&quot;Changing focus from &quot;
                            + localOldOwner + &quot; to &quot; + value
                            + &quot; canceled by nested requestFocus&quot;);
                }
            }
            if (accessible != null) {
                accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
            }
        }
    };

    public final Node getFocusOwner() {
        return focusOwner.get();
    }

    public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
        return focusOwner.getReadOnlyProperty();
    }

    // For testing.
    void focusCleanup() {
        scenePulseListener.focusCleanup();
    }

    private void processInputMethodEvent(InputMethodEvent e) {
        Node node = getFocusOwner();
        if (node != null) {
            node.fireEvent(e);
        }
    }

    public void enableInputMethodEvents(boolean enable) {
       if (peer != null) {
           peer.enableInputMethodEvents(enable);
       }
    }

    /**
     * Returns true if this scene is quiescent, i.e. it has no activity
     * pending on it such as CSS processing or layout requests.
     *
     * Intended to be used for tests only
     *
     * @return boolean indicating whether the scene is quiescent
     */
    boolean isQuiescent() {
        final Parent r = getRoot();
        return !isFocusDirty()
               &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
                r.layoutFlag == LayoutFlags.CLEAN));
    }

    /**
     * A listener for pulses, used for testing. If non-null, this is called at
     * the very end of ScenePulseListener.pulse().
     *
     * Intended to be used for tests only
     */
    Runnable testPulseListener = null;

    /**
     * Set the specified dirty bit and mark the peer as dirty
     */
    private void markDirty(DirtyBits dirtyBit) {
        setDirty(dirtyBit);
        if (peer != null) {
            Toolkit.getToolkit().requestNextPulse();
        }
    }

    /**
     * Set the specified dirty bit
     */
    private void setDirty(DirtyBits dirtyBit) {
        dirtyBits |= dirtyBit.getMask();
    }

    /**
     * Test the specified dirty bit
     */
    private boolean isDirty(DirtyBits dirtyBit) {
        return ((dirtyBits &amp; dirtyBit.getMask()) != 0);
    }

    /**
     * Test whether the dirty bits are empty
     */
    private boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    private enum DirtyBits {
        FILL_DIRTY,
        ROOT_DIRTY,
        CAMERA_DIRTY,
        LIGHTS_DIRTY,
        CURSOR_DIRTY;

        private int mask;

        private DirtyBits() {
            mask = 1 &lt;&lt; ordinal();
        }

        public final int getMask() { return mask; }
    }

    private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();

    // @param light must not be null
    final void addLight(LightBase light) {
        if (!lights.contains(light)) {
            lights.add(light);
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    final void removeLight(LightBase light) {
        if (lights.remove(light)) {
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    /**
     * PG Light synchronizer.
     */
    private void syncLights() {
        if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
            return;
        }
        inSynchronizer = true;
        NGLightBase peerLights[] = peer.getLights();
        if (!lights.isEmpty() || (peerLights != null)) {
            if (lights.isEmpty()) {
                peer.setLights(null);
            } else {
                if (peerLights == null || peerLights.length &lt; lights.size()) {
                    peerLights = new NGLightBase[lights.size()];
                }
                int i = 0;
                for (; i &lt; lights.size(); i++) {
                    peerLights[i] = lights.get(i).getPeer();
                }
                // Clear the rest of the list
                while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
                    peerLights[i++] = null;
                }
                peer.setLights(peerLights);
            }
        }
        inSynchronizer = false;
    }

    //INNER CLASSES

    /*******************************************************************************
     *                                                                             *
     * Scene Pulse Listener                                                        *
     *                                                                             *
     ******************************************************************************/

    class ScenePulseListener implements TKPulseListener {

        private boolean firstPulse = true;

        /**
         * PG synchronizer. Called once per frame from the pulse listener.
         * This function calls the synchronizePGNode method on each node in
         * the dirty list.
         */
        private void synchronizeSceneNodes() {
            Toolkit.getToolkit().checkFxUserThread();

            Scene.inSynchronizer = true;

            // if dirtyNodes is null then that means this Scene has not yet been
            // synchronized, and so we will simply synchronize every node in the
            // scene and then create the dirty nodes array list
            if (Scene.this.dirtyNodes == null) {
                // must do this recursively
                syncAll(getRoot());
                dirtyNodes = new Node[MIN_DIRTY_CAPACITY];

            } else {
                // This is not the first time this scene has been synchronized,
                // so we will only synchronize those nodes that need it
                for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
                    Node node = dirtyNodes[i];
                    dirtyNodes[i] = null;
                    if (node.getScene() == Scene.this) {
                            node.syncPeer();
                        }
                    }
                dirtyNodesSize = 0;
            }

            Scene.inSynchronizer = false;
        }

        /**
         * Recursive function for synchronizing every node in the scenegraph.
         * The return value is the number of nodes in the graph.
         */
        private int syncAll(Node node) {
            node.syncPeer();
            int size = 1;
            if (node instanceof Parent) {
                Parent p = (Parent) node;
                final int childrenCount = p.getChildren().size();

                for (int i = 0; i &lt; childrenCount; i++) {
                    Node n = p.getChildren().get(i);
                    if (n != null) {
                        size += syncAll(n);
                    }
                }
            } else if (node instanceof SubScene) {
                SubScene subScene = (SubScene)node;
                size += syncAll(subScene.getRoot());
            }
            if (node.getClip() != null) {
                size += syncAll(node.getClip());
            }

            return size;
        }

        private void synchronizeSceneProperties() {
            inSynchronizer = true;
            if (isDirty(DirtyBits.ROOT_DIRTY)) {
                peer.setRoot(getRoot().getPeer());
            }

            if (isDirty(DirtyBits.FILL_DIRTY)) {
                Toolkit tk = Toolkit.getToolkit();
                peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
            }

            // new camera was set on the scene or old camera changed
            final Camera cam = getEffectiveCamera();
            if (isDirty(DirtyBits.CAMERA_DIRTY)) {
                NodeHelper.updatePeer(cam);
                peer.setCamera((NGCamera) cam.getPeer());
            }

            if (isDirty(DirtyBits.CURSOR_DIRTY)) {
                mouseHandler.updateCursor(getCursor());
                mouseHandler.updateCursorFrame();
            }

            clearDirty();
            inSynchronizer = false;
        }

        /**
         * The focus is considered dirty if something happened to
         * the scene graph that may require the focus to be moved.
         * This must handle cases where (a) the focus owner may have
         * become ineligible to have the focus, and (b) where the focus
         * owner is null and a node may have become traversable and eligible.
         */
        private void focusCleanup() {
            if (Scene.this.isFocusDirty()) {
                final Node oldOwner = Scene.this.getFocusOwner();
                if (oldOwner == null) {
                    Scene.this.focusInitial();
                } else if (oldOwner.getScene() != Scene.this) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusInitial();
                } else if (!oldOwner.isCanReceiveFocus()) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusIneligible(oldOwner);
                }
                Scene.this.setFocusDirty(false);
            }
        }

        @Override
        public void pulse() {
            if (Scene.this.tracker != null) {
                Scene.this.tracker.pulse();
            }
            if (firstPulse) {
                PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
            }

            focusCleanup();

            disposeAccessibles();

            // run any scene pre pulse listeners immediately _before_ css / layout,
            // and before scene synchronization
            if (preLayoutPulseListeners != null) {
                for (Runnable r : preLayoutPulseListeners) {
                    r.run();
                }
            }

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;CSS Pass&quot;);
            }
            Scene.this.doCSSPass();

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Layout Pass&quot;);
            }
            Scene.this.doLayoutPass();

            // run any scene post pulse listeners immediately _after_ css / layout,
            // and before scene synchronization
            if (postLayoutPulseListeners != null) {
                for (Runnable r : postLayoutPulseListeners) {
                    r.run();
                }
            }

            boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
            if (dirty) {
                if (PULSE_LOGGING_ENABLED) {
                    PulseLogger.newPhase(&quot;Update bounds&quot;);
                }
                getRoot().updateBounds();
                if (peer != null) {
                    try {
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
                        }
                        peer.waitForRenderingToComplete();
                        peer.waitForSynchronization();
                        // synchronize scene properties
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
                        }
                        syncLights();
                        synchronizeSceneProperties();
                        // Run the synchronizer
                        synchronizeSceneNodes();
                        Scene.this.mouseHandler.pulse();
                        // Tell the scene peer that it needs to repaint
                        peer.markDirty();
                    } finally {
                        peer.releaseSynchronization(true);
                    }
                } else {
                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
                    }
                    synchronizeSceneNodes();
                    Scene.this.mouseHandler.pulse();
                }

                if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
                    NodeHelper.markDirty(Scene.this.getRoot(),
                            com.sun.javafx.scene.DirtyBits.NODE_CSS);
                }
            }

            // required for image cursor created from animated image
            Scene.this.mouseHandler.updateCursorFrame();

            if (firstPulse) {
                if (PerformanceTracker.isLoggingEnabled()) {
                    PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
                    if (PrismSettings.perfLogFirstPaintFlush) {
                        PerformanceTracker.outputLog();
                    }
                    if (PrismSettings.perfLogFirstPaintExit) {
                        System.exit(0);
                    }
                }
                firstPulse = false;
            }

            if (testPulseListener != null) {
                testPulseListener.run();
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Scene Peer Listener                                                         *
     *                                                                             *
     ******************************************************************************/

    class ScenePeerListener implements TKSceneListener {
        @Override
        public void changedLocation(float x, float y) {
            if (x != Scene.this.getX()) {
                Scene.this.setX(x);
            }
            if (y != Scene.this.getY()) {
                Scene.this.setY(y);
            }
        }

        @Override
        public void changedSize(float w, float h) {
            if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
            if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
        }

        @Override
        public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
                               MouseButton button, boolean popupTrigger, boolean synthesized,
                               boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
                               boolean primaryDown, boolean middleDown, boolean secondaryDown)
        {
            MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
                    0, // click count will be adjusted by clickGenerator later anyway
                    shiftDown, controlDown, altDown, metaDown,
                    primaryDown, middleDown, secondaryDown, synthesized, popupTrigger, false, null);
            processMouseEvent(mouseEvent);
        }


        @Override
        public void keyEvent(KeyEvent keyEvent)
        {
            processKeyEvent(keyEvent);
        }

        @Override
        public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
                                     ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
                                     int caretPosition)
        {
            InputMethodEvent inputMethodEvent = new InputMethodEvent(
               type, composed, committed, caretPosition);
            processInputMethodEvent(inputMethodEvent);
        }

        public void menuEvent(double x, double y, double xAbs, double yAbs,
                boolean isKeyboardTrigger) {
            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
        }

        @Override
        public void scrollEvent(
                EventType&lt;ScrollEvent&gt; eventType,
                double scrollX, double scrollY,
                double totalScrollX, double totalScrollY,
                double xMultiplier, double yMultiplier,
                int touchCount,
                int scrollTextX, int scrollTextY,
                int defaultTextX, int defaultTextY,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
                    ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
                    ScrollEvent.HorizontalTextScrollUnits.NONE;

            double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;

            ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
                    ScrollEvent.VerticalTextScrollUnits.LINES :
                    (scrollTextY &lt; 0 ?
                        ScrollEvent.VerticalTextScrollUnits.PAGES :
                        ScrollEvent.VerticalTextScrollUnits.NONE);

            double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;

            xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
                    ? Math.round(xMultiplier * scrollTextX / defaultTextX)
                    : xMultiplier;

            yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
                    ? Math.round(yMultiplier * scrollTextY / defaultTextY)
                    : yMultiplier;

            if (eventType == ScrollEvent.SCROLL_FINISHED) {
                x = scrollGesture.sceneCoords.getX();
                y = scrollGesture.sceneCoords.getY();
                screenX = scrollGesture.screenCoords.getX();
                screenY = scrollGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ScrollEvent(
                    eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    scrollX * xMultiplier, scrollY * yMultiplier,
                    totalScrollX * xMultiplier, totalScrollY * yMultiplier,
                    xMultiplier, yMultiplier,
                    xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
                    scrollGesture);
            inMousePick = false;
        }

        @Override
        public void zoomEvent(
                EventType&lt;ZoomEvent&gt; eventType,
                double zoomFactor, double totalZoomFactor,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == ZoomEvent.ZOOM_FINISHED) {
                x = zoomGesture.sceneCoords.getX();
                y = zoomGesture.sceneCoords.getY();
                screenX = zoomGesture.screenCoords.getX();
                screenY = zoomGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ZoomEvent(eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    zoomFactor, totalZoomFactor, pick(x, y)),
                    zoomGesture);
            inMousePick = false;
        }

        @Override
        public void rotateEvent(
                EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == RotateEvent.ROTATION_FINISHED) {
                x = rotateGesture.sceneCoords.getX();
                y = rotateGesture.sceneCoords.getY();
                screenX = rotateGesture.screenCoords.getX();
                screenY = rotateGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new RotateEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia, angle, totalAngle, pick(x, y)),
                    rotateGesture);
            inMousePick = false;

        }

        @Override
        public void swipeEvent(
                EventType&lt;SwipeEvent&gt; eventType, int touchCount,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown, boolean _direct) {

            if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new SwipeEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown, _direct,
                    touchCount, pick(x, y)),
                    swipeGesture);
            inMousePick = false;
        }

        @Override
        public void touchEventBegin(
                long time, int touchCount, boolean isDirect,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown) {

            if (!isDirect) {
                nextTouchEvent = null;
                return;
            }
            nextTouchEvent = new TouchEvent(
                    TouchEvent.ANY, null, null, 0,
                    _shiftDown, _controlDown, _altDown, _metaDown);
            if (touchPoints == null || touchPoints.length != touchCount) {
                touchPoints = new TouchPoint[touchCount];
            }
            touchPointIndex = 0;
        }

        @Override
        public void touchEventNext(
                TouchPoint.State state, long touchId,
                double x, double y, double screenX, double screenY) {

            inMousePick = true;
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }
            touchPointIndex++;
            int id = (state == TouchPoint.State.PRESSED
                    ? touchMap.add(touchId) :  touchMap.get(touchId));
            if (state == TouchPoint.State.RELEASED) {
                touchMap.remove(touchId);
            }
            int order = touchMap.getOrder(id);

            if (order &gt;= touchPoints.length) {
                throw new RuntimeException(&quot;Too many touch points reported&quot;);
            }

            // pick target
            boolean isGrabbed = false;
            PickResult pickRes = pick(x, y);
            EventTarget pickedTarget = touchTargets.get(id);
            if (pickedTarget == null) {
                pickedTarget = pickRes.getIntersectedNode();
                if (pickedTarget == null) {
                    pickedTarget = Scene.this;
                }
            } else {
                isGrabbed = true;
            }

            TouchPoint tp = new TouchPoint(id, state,
                    x, y, screenX, screenY, pickedTarget, pickRes);

            touchPoints[order] = tp;

            if (isGrabbed) {
                tp.grab(pickedTarget);
            }
            if (tp.getState() == TouchPoint.State.PRESSED) {
                tp.grab(pickedTarget);
                touchTargets.put(tp.getId(), pickedTarget);
            } else if (tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
            inMousePick = false;
        }

        @Override
        public void touchEventEnd() {
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }

            if (touchPointIndex != touchPoints.length) {
                throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
            }

            Scene.this.processTouchEvent(nextTouchEvent, touchPoints);

            if (touchMap.cleanup()) {
                // gesture finished
                touchEventSetId = 0;
            }
        }

        @Override
        public Accessible getSceneAccessible() {
            return getAccessible();
        }
    }

    private class ScenePeerPaintListener implements TKScenePaintListener {
        @Override
        public void frameRendered() {
            // must use tracker with synchronization since this method is called on render thread
            synchronized (trackerMonitor) {
                if (Scene.this.tracker != null) {
                    Scene.this.tracker.frameRendered();
                }
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Drag and Drop                                                               *
     *                                                                             *
     ******************************************************************************/

    class DropTargetListener implements TKDropTargetListener {

        /*
         * This function is called when an drag operation enters a valid drop target.
         * This may be from either an internal or external dnd operation.
         */
        @Override
        public TransferMode dragEnter(double x, double y, double screenX, double screenY,
                                      TransferMode transferMode, TKClipboard dragboard)
        {
            if (dndGesture == null) {
                dndGesture = new DnDGesture();
            }
            Dragboard db = DragboardHelper.createDragboard(dragboard);
            dndGesture.dragboard = db;
            DragEvent dragEvent =
                    new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                            transferMode, null, null, pick(x, y));
            return dndGesture.processTargetEnterOver(dragEvent);
        }

        @Override
        public TransferMode dragOver(double x, double y, double screenX, double screenY,
                                     TransferMode transferMode)
        {
            if (Scene.this.dndGesture == null) {
                System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                return dndGesture.processTargetEnterOver(dragEvent);
            }
        }

        @Override
        public void dragExit(double x, double y, double screenX, double screenY) {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                null, null, null, pick(x, y));
                dndGesture.processTargetExit(dragEvent);
                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
            }
        }


        @Override
        public TransferMode drop(double x, double y, double screenX, double screenY,
                                  TransferMode transferMode)
        {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                // Data dropped to the app can be accessed without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);

                TransferMode tm;
                try {
                    tm = dndGesture.processTargetDrop(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(
                            dndGesture.dragboard, true);
                }

                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
                return tm;
            }
        }
    }

    class DragGestureListener implements TKDragGestureListener {

       @Override
       public void dragGestureRecognized(double x, double y, double screenX, double screenY,
                                         int button, TKClipboard dragboard)
       {
           Dragboard db = DragboardHelper.createDragboard(dragboard);
           dndGesture = new DnDGesture();
           dndGesture.dragboard = db;
           // TODO: support mouse buttons in DragEvent
           DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
                   null, null, null, pick(x, y));
           dndGesture.processRecognized(dragEvent);
           dndGesture = null;
        }
    }

    /**
     * A Drag and Drop gesture has a lifespan that lasts from mouse
     * PRESSED event to mouse RELEASED event.
     */
    class DnDGesture {
        private final double hysteresisSizeX =
                Toolkit.getToolkit().getMultiClickMaxX();
        private final double hysteresisSizeY =
                Toolkit.getToolkit().getMultiClickMaxY();

        private EventTarget source = null;
        private Set&lt;TransferMode&gt; sourceTransferModes = null;
        private TransferMode acceptedTransferMode = null;
        private Dragboard dragboard = null;
        private EventTarget potentialTarget = null;
        private EventTarget target = null;
        private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
        private double pressedX;
        private double pressedY;
        private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRSource = null;

        /**
         * Fires event on a given target or on scene if the node is null
         */
        private void fireEvent(EventTarget target, Event e) {
            if (target != null) {
                Event.fireEvent(target, e);
            }
        }

        /**
         * Called when DRAG_DETECTED event is going to be processed by
         * application
         */
        private void processingDragDetected() {
            dragDetected = DragDetectedState.PROCESSING;
        }

        /**
         * Called after DRAG_DETECTED event has been processed by application
         */
        private void dragDetectedProcessed() {
            dragDetected = DragDetectedState.DONE;
            final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
            if (hasContent) {
                /* start DnD */
                Toolkit.getToolkit().startDrag(Scene.this.peer,
                                                sourceTransferModes,
                                                new DragSourceListener(),
                                                dragboard);
            } else if (fullPDRSource != null) {
                /* start PDR */
                Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
            }

            fullPDRSource = null;
        }

        /**
         * Sets the default dragDetect value
         */
        private void processDragDetection(MouseEvent mouseEvent) {

            if (dragDetected != DragDetectedState.NOT_YET) {
                mouseEvent.setDragDetect(false);
                return;
            }

            if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
                pressedX = mouseEvent.getSceneX();
                pressedY = mouseEvent.getSceneY();

                mouseEvent.setDragDetect(false);

            } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {

                double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
                double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
                mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
                                         deltaY &gt; hysteresisSizeY);

            }
        }

        /**
         * This function is useful for drag gesture recognition from
         * within this Scene (as opposed to in the TK implementation... by the platform)
         */
        private boolean process(MouseEvent mouseEvent, EventTarget target) {
            boolean continueProcessing = true;
            if (!PLATFORM_DRAG_GESTURE_INITIATION) {

                if (dragDetected != DragDetectedState.DONE &amp;&amp;
                        (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
                        mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
                        mouseEvent.isDragDetect()) {

                    processingDragDetected();

                    if (target != null) {
                        final MouseEvent detectedEvent = mouseEvent.copyFor(
                                mouseEvent.getSource(), target,
                                MouseEvent.DRAG_DETECTED);

                        try {
                            fireEvent(target, detectedEvent);
                        } finally {
                            // Putting data to dragboard finished, restrict access to them
                            if (dragboard != null) {
                                DragboardHelper.setDataAccessRestriction(
                                        dragboard, true);
                            }
                        }
                    }

                    dragDetectedProcessed();
                }

                if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    continueProcessing = false;
                }
            }
            return continueProcessing;
        }

        /*
         * Called when a drag source is recognized. This occurs at the very start of
         * the publicly visible drag and drop API, as it is responsible for calling
         * the Node.onDragSourceRecognized function.
         */
        private boolean processRecognized(DragEvent de) {
            MouseEvent me = new MouseEvent(
                    MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
                    de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
                    false, false, false, false, false, true, false, false, false,
                    false, de.getPickResult());

            processingDragDetected();

            final EventTarget target = de.getPickResult().getIntersectedNode();
            try {
                fireEvent(target != null ? target : Scene.this, me);
            } finally {
                // Putting data to dragboard finished, restrict access to them
                if (dragboard != null) {
                    DragboardHelper.setDataAccessRestriction(
                            dragboard, true);
                }
            }

            dragDetectedProcessed();

            final boolean hasContent = dragboard != null
                    &amp;&amp; !dragboard.getContentTypes().isEmpty();
            return hasContent;
        }

        private void processDropEnd(DragEvent de) {
            if (source == null) {
                System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
                return;
            }
<A NAME="29"></A>
            de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#29',2,'match42-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, target, de.getPickResult());

            Event.fireEvent(source, de);

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            // at this point the drag and drop operation is completely over, so we
            // can tell the toolkit that it can clean up if needs be.
            Toolkit.getToolkit().stopDrag(dragboard);
        }

        private TransferMode processTargetEnterOver(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget</B></FONT>();

            if (dragboard == null) {
                dragboard = createDragboard(de, false);
            }

            de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
                    dragboard, de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            handleExitEnter(de, tmpTargetWrapper);

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            acceptedTransferMode = de.getAcceptedTransferMode();
            return acceptedTransferMode;
        }

        private void processTargetActionChanged(DragEvent de) {
            // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
//            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
//                de = DragEvent.copy(de.getSource(), pickedNode, source,
//                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
//
//                if (dragboard == null) {
//                    dragboard = createDragboard(de);
//                }
//                dragboard = de.getPlatformDragboard();
//
//                fireEvent(pickedNode, de);
//            }
        }

        private void processTargetExit(DragEvent de) {
            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
            }

            if (currentTargets.size() &gt; 0) {
                potentialTarget = null;
                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);
            }
        }

        private TransferMode processTargetDrop(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    acceptedTransferMode, source, potentialTarget, de.getPickResult());

            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
            }

            handleExitEnter(de, tmpTargetWrapper);

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            target = potentialTarget;

            TransferMode result = de.isDropCompleted() ?
                de.getAcceptedTransferMode() : null;

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            return result;
        }

        private void handleExitEnter(DragEvent e, TargetWrapper target) {
            EventTarget currentTarget =
                    currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;

            if (target.getEventTarget() != currentTarget) {

                target.fillHierarchy(newTargets);

                int i = currentTargets.size() - 1;
                int j = newTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    EventTarget t = currentTargets.get(i);
                    if (potentialTarget == t) {
                        potentialTarget = null;
                    }
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_EXITED_TARGET);
                    Event.fireEvent(t, e);
                }

                potentialTarget = null;
                for (; j &gt;= 0; j--) {
                    EventTarget t = newTargets.get(j);
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
                    Object acceptingObject = e.getAcceptingObject();
                    if (acceptingObject instanceof EventTarget) {
                        potentialTarget = (EventTarget) acceptingObject;
                    }
                    Event.fireEvent(t, e);
                }

                currentTargets.clear();
                currentTargets.addAll(newTargets);
                newTargets.clear();
            }
        }

//        function getIntendedTransferMode(e:MouseEvent):TransferMode {
//            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
//        }

        /*
         * Function that hooks into the key processing code in Scene to handle the
         * situation where a drag and drop event is taking place and the user presses
         * the escape key to cancel the drag and drop operation.
         */
        private boolean processKey(KeyEvent e) {
            //note: this seems not to be called, the DnD cancelation is provided by platform
            if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {

                // cancel drag and drop
                DragEvent de = new DragEvent(
                        source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
                        null, source, null, null);
                if (source != null) {
                    Event.fireEvent(source, de);
                }

                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);

                return false;
            }
            return true;
        }

        /*
         * This starts the drag gesture running, creating the dragboard used for
         * the remainder of this drag and drop operation.
         */
        private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
            if (dragDetected != DragDetectedState.PROCESSING) {
                throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
                        + &quot;outside of DRAG_DETECTED event handler&quot;);
            }

            if (t.isEmpty()) {
                dragboard = null;
            } else if (dragboard == null) {
                dragboard = createDragboard(null, true);
            }

            // The app can see what it puts to dragboard without restriction
            DragboardHelper.setDataAccessRestriction(dragboard, false);

            this.source = source;
            potentialTarget = source;
            sourceTransferModes = t;
            return dragboard;
        }

        /*
         * This starts the full PDR gesture.
         */
        private void startFullPDR(EventTarget source) {
            fullPDRSource = source;
        }

        private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
            Dragboard dragboard = null;
            if (de != null) {
                dragboard = de.getDragboard();
                if (dragboard != null) {
                    return dragboard;
                }
            }
            TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
            return DragboardHelper.createDragboard(dragboardPeer);
        }
    }

    /**
     * State of a drag gesture with regards to DRAG_DETECTED event.
     */
    private enum DragDetectedState {
        NOT_YET,
        PROCESSING,
        DONE
    }

    class DragSourceListener implements TKDragSourceListener {

        @Override
        public void dragDropEnd(double x, double y, double screenX, double screenY,
                                TransferMode transferMode)
        {
            if (dndGesture != null) {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                        transferMode, null, null, null);

                // DRAG_DONE event is delivered to gesture source, it can access
                // its own data without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
                try {
                    dndGesture.processDropEnd(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
                }
                dndGesture = null;
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Mouse Event Handling                                                        *
     *                                                                             *
     ******************************************************************************/

    static class ClickCounter {
        Toolkit toolkit = Toolkit.getToolkit();
        private int count;
        private boolean out;
        private boolean still;
        private Timeline timeout;
        private double pressedX, pressedY;

        private void inc() { count++; }
        private int get() { return count; }
        private boolean isStill() { return still; }

        private void clear() {
            count = 0;
            stopTimeout();
        }

        private void out() {
            out = true;
            stopTimeout();
        }

        private void applyOut() {
            if (out) clear();
            out = false;
        }

        private void moved(double x, double y) {
            if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
                    Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
                out();
                still = false;
            }
        }

        private void start(double x, double y) {
            pressedX = x;
            pressedY = y;
            out = false;

            if (timeout != null) {
                timeout.stop();
            }
            timeout = new Timeline();
            timeout.getKeyFrames().add(
                    new KeyFrame(new Duration(toolkit.getMultiClickTime()),
                            event -&gt; {
                                out = true;
                                timeout = null;
                            }
                    ));
            timeout.play();
            still = true;
        }

        private void stopTimeout() {
            if (timeout != null) {
                timeout.stop();
                timeout = null;
            }
        }
    }

    static class ClickGenerator {
        private ClickCounter lastPress = null;

        private Map&lt;MouseButton, ClickCounter&gt; counters =
                new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
        private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();

        public ClickGenerator() {
            for (MouseButton mb : MouseButton.values()) {
                if (mb != MouseButton.NONE) {
<A NAME="77"></A>                    counters.put(mb, new ClickCounter());
                }
            }
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#77',2,'match42-top.html#77',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        private MouseEvent preProcess(MouseEvent e) {
            for (ClickCounter cc : counters.values()) {
                cc.moved(e.getSceneX(), e.getSceneY());
            }</B></FONT>

            ClickCounter cc = counters.get(e.getButton());
            boolean still = lastPress != null ? lastPress.isStill() : false;

            if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {

                if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
                if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
                if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }

                cc.applyOut();
                cc.inc();
                cc.start(e.getSceneX(), e.getSceneY());
                lastPress = cc;
            }

            return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(),
                    cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
        }

        private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {

            if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                ClickCounter cc = counters.get(e.getButton());

                target.fillHierarchy(pressedTargets);
                pickedTarget.fillHierarchy(releasedTargets);
                int i = pressedTargets.size() - 1;
                int j = releasedTargets.size() - 1;

                EventTarget clickedTarget = null;
                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
                    clickedTarget = pressedTargets.get(i);
                    i--;
                    j--;
                }

                pressedTargets.clear();
                releasedTargets.clear();

                if (clickedTarget != null &amp;&amp; lastPress != null) {
                    MouseEvent click = new MouseEvent(null, clickedTarget,
                            MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
                            e.getScreenX(), e.getScreenY(), e.getButton(),
                            cc.get(),
                            e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                            e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                            e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
                    Event.fireEvent(clickedTarget, click);
                }
            }
        }
    }

    /**
     * Generates mouse exited event for a node which is going to be removed
     * and its children, where appropriate.
     * @param removing Node which is going to be removed
     */
    void generateMouseExited(Node removing) {
        mouseHandler.handleNodeRemoval(removing);
    }

    class MouseHandler {
        private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
        private boolean pdrInProgress = false;
        private boolean fullPDREntered = false;

        private EventTarget currentEventTarget = null;
        private MouseEvent lastEvent;
        private boolean hover = false;

        private boolean primaryButtonDown = false;
        private boolean secondaryButtonDown = false;
        private boolean middleButtonDown = false;

        private EventTarget fullPDRSource = null;
        private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();

        /* lists needed for enter/exit events generation */
        private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();

        private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRCurrentTarget = null;

        private Cursor currCursor;
        private CursorFrame currCursorFrame;
        private EventQueue queue = new EventQueue();

        private Runnable pickProcess = new Runnable() {

            @Override
            public void run() {
                // Make sure this is run only if the peer is still alive
                // and there is an event to deliver
                if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
                    process(lastEvent, true);
                }
            }
        };

        private void pulse() {
            if (hover &amp;&amp; lastEvent != null) {
                //Shouldn't run user code directly. User can call stage.showAndWait() and block the pulse.
                Platform.runLater(pickProcess);
            }
        }

        private void clearPDREventTargets() {
            pdrInProgress = false;
            currentEventTarget = currentEventTargets.size() &gt; 0
                    ? currentEventTargets.get(0) : null;
            pdrEventTarget.clear();
        }

        public void enterFullPDR(EventTarget gestureSource) {
            fullPDREntered = true;
            fullPDRSource = gestureSource;
            fullPDRCurrentTarget = null;
            fullPDRCurrentEventTargets.clear();
        }

        public void exitFullPDR(MouseEvent e) {
            if (!fullPDREntered) {
                return;
            }
            fullPDREntered = false;
            for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
                EventTarget entered = fullPDRCurrentEventTargets.get(i);
                Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
                        entered, entered,
                        MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                        fullPDRSource, e.getPickResult()));
            }
            fullPDRSource = null;
            fullPDRCurrentEventTargets.clear();
            fullPDRCurrentTarget = null;
        }

        private void handleNodeRemoval(Node removing) {
            if (lastEvent == null) {
                // this can happen only if everything has been exited anyway
                return;
            }


            if (currentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while(trg != removing) {
                    trg = currentEventTargets.get(i++);

                    queue.postEvent(lastEvent.copyFor(trg, trg,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }
                currentEventTargets.subList(0, i).clear();
            }

            if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = fullPDRCurrentEventTargets.get(i++);

                    queue.postEvent(
                            MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, lastEvent.getPickResult()));
                }

                fullPDRCurrentEventTargets.subList(0, i).clear();
            }

            queue.fire();

            if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = pdrEventTargets.get(i++);

                    // trg.setHover(false) - already taken care of
                    // by the code above which sent a mouse exited event
                    ((Node) trg).setPressed(false);
                }
                pdrEventTargets.subList(0, i).clear();

                trg = pdrEventTargets.get(0);
                final PickResult res = pdrEventTarget.getResult();
                if (trg instanceof Node) {
                    pdrEventTarget.setNodeResult(new PickResult((Node) trg,
                            res.getIntersectedPoint(), res.getIntersectedDistance()));
                } else {
                    pdrEventTarget.setSceneResult(new PickResult(null,
                            res.getIntersectedPoint(), res.getIntersectedDistance()),
                            (Scene) trg);
                }
            }
        }

        private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
            if (pickedTarget.getEventTarget() != currentEventTarget ||
                    e.getEventType() == MouseEvent.MOUSE_EXITED) {

                if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    newEventTargets.clear();
                } else {
                    pickedTarget.fillHierarchy(newEventTargets);
                }

                int newTargetsSize = newEventTargets.size();
                int i = currentEventTargets.size() - 1;
                int j = newTargetsSize - 1;
                int k = pdrEventTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
                    i--;
                    j--;
                    k--;
                }

                final int memk = k;
                for (; i &gt;= 0; i--, k--) {
                    final EventTarget exitedEventTarget = currentEventTargets.get(i);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
                         break;
                    }
                    queue.postEvent(e.copyFor(
                            exitedEventTarget, exitedEventTarget,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }

                k = memk;
                for (; j &gt;= 0; j--, k--) {
                    final EventTarget enteredEventTarget = newEventTargets.get(j);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
                        break;
                    }
                    queue.postEvent(e.copyFor(
                            enteredEventTarget, enteredEventTarget,
                            MouseEvent.MOUSE_ENTERED_TARGET));
                }

                currentEventTarget = pickedTarget.getEventTarget();
                currentEventTargets.clear();
                for (j++; j &lt; newTargetsSize; j++) {
                    currentEventTargets.add(newEventTargets.get(j));
                }
            }
            queue.fire();
        }

        private void process(MouseEvent e, boolean onPulse) {
            Toolkit.getToolkit().checkFxUserThread();
            Scene.inMousePick = true;

            cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
            cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());

            boolean gestureStarted = false;
            if (!onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
                    if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                        //old gesture ended and new one started
                        gestureStarted = true;
                        if (!PLATFORM_DRAG_GESTURE_INITIATION) {
                            Scene.this.dndGesture = new DnDGesture();
                        }
                        clearPDREventTargets();
                    }
                } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
                    // gesture ended
                    clearPDREventTargets();
                } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
                    hover = true;
                } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    hover = false;
                }

                primaryButtonDown = e.isPrimaryButtonDown();
                secondaryButtonDown = e.isSecondaryButtonDown();
                middleButtonDown = e.isMiddleButtonDown();
            }

            pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
            PickResult res = tmpTargetWrapper.getResult();
            if (res != null) {
                e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
            }

            if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                tmpTargetWrapper.clear();
            }

            TargetWrapper target;
            if (pdrInProgress) {
                target = pdrEventTarget;
            } else {
                target = tmpTargetWrapper;
            }

            if (gestureStarted) {
                pdrEventTarget.copy(target);
                pdrEventTarget.fillHierarchy(pdrEventTargets);
            }

            if (!onPulse) {
                e = clickGenerator.preProcess(e);
            }

            // enter/exit handling
            handleEnterExit(e, tmpTargetWrapper);

            //deliver event to the target node
            if (Scene.this.dndGesture != null) {
                Scene.this.dndGesture.processDragDetection(e);
            }

            if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (target.getEventTarget() != null) {
                if (e.getEventType() != MouseEvent.MOUSE_ENTERED
                        &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
                        &amp;&amp; !onPulse) {
                    Event.fireEvent(target.getEventTarget(), e);
                }
            }

            if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (!onPulse) {
                clickGenerator.postProcess(e, target, tmpTargetWrapper);
            }

            // handle drag and drop

            if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
                if (Scene.this.dndGesture != null) {
                    if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
                        dndGesture = null;
                    }
                }
            }

            Cursor cursor = target.getCursor();
            if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
                if (cursor == null &amp;&amp; hover) {
                    cursor = Scene.this.getCursor();
                }

                updateCursor(cursor);
                updateCursorFrame();
            }

            if (gestureStarted) {
                pdrInProgress = true;
            }

            if (pdrInProgress &amp;&amp;
                    !(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                clearPDREventTargets();
                exitFullPDR(e);
                // we need to do new picking in case the originally picked node
                // was moved or removed by the event handlers
                pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
                handleEnterExit(e, tmpTargetWrapper);
            }

            lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
            Scene.inMousePick = false;
        }

        private void processFullPDR(MouseEvent e, boolean onPulse) {

            pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
            final PickResult result = fullPDRTmpTargetWrapper.getResult();

            final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();

            // enter/exit handling
            if (eventTarget != fullPDRCurrentTarget) {

                fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);

                int newTargetsSize = fullPDRNewEventTargets.size();
                int i = fullPDRCurrentEventTargets.size() - 1;
                int j = newTargetsSize - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
                        fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
                    Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            exitedEventTarget, exitedEventTarget,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, result));
                }

                for (; j &gt;= 0; j--) {
                    final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
                    Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            enteredEventTarget, enteredEventTarget,
                            MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
                            fullPDRSource, result));
                }

                fullPDRCurrentTarget = eventTarget;
                fullPDRCurrentEventTargets.clear();
                fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
                fullPDRNewEventTargets.clear();
            }
            // done enter/exit handling

            // event delivery
            if (eventTarget != null &amp;&amp; !onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_OVER,
                            fullPDRSource, result));
                }
                if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_RELEASED,
                            fullPDRSource, result));
                }
            }
        }

        private void updateCursor(Cursor newCursor) {
            if (currCursor != newCursor) {
                if (currCursor != null) {
                    currCursor.deactivate();
                }

                if (newCursor != null) {
                    newCursor.activate();
                }

                currCursor = newCursor;
            }
        }

        public void updateCursorFrame() {
            final CursorFrame newCursorFrame =
                    (currCursor != null)
                           ? currCursor.getCurrentFrame()
                           : Cursor.DEFAULT.getCurrentFrame();
            if (currCursorFrame != newCursorFrame) {
                if (Scene.this.peer != null) {
                    Scene.this.peer.setCursor(newCursorFrame);
                }

                currCursorFrame = newCursorFrame;
            }
        }

        private PickResult pickNode(PickRay pickRay) {
            PickResultChooser r = new PickResultChooser();
            Scene.this.getRoot().pickNode(pickRay, r);
            return r.toPickResult();
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Key Event Handling                                                          *
     *                                                                             *
     ******************************************************************************/

    class KeyHandler {
        private void setFocusOwner(final Node value) {
            // Cancel IM composition if there is one in progress.
            // This needs to be done before the focus owner is switched as it
            // generates event that needs to be delivered to the old focus owner.
            if (oldFocusOwner != null) {
                final Scene s = oldFocusOwner.getScene();
                if (s != null) {
                    final TKScene peer = s.getPeer();
                    if (peer != null) {
                        peer.finishInputMethodComposition();
                    }
                }
            }
            focusOwner.set(value);
        }

        private boolean windowFocused;
        protected boolean isWindowFocused() { return windowFocused; }
        protected void setWindowFocused(boolean value) {
            windowFocused = value;
            if (getFocusOwner() != null) {
                getFocusOwner().setFocused(windowFocused);
            }
            if (windowFocused) {
                if (accessible != null) {
                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
                }
            }
        }

        private void windowForSceneChanged(Window oldWindow, Window window) {
            if (oldWindow != null) {
                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
            }

            if (window != null) {
                window.focusedProperty().addListener(sceneWindowFocusedListener);
                setWindowFocused(window.isFocused());
            } else {
                setWindowFocused(false);
            }
        }

        private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());

        private void process(KeyEvent e) {
            final Node sceneFocusOwner = getFocusOwner();
            final EventTarget eventTarget =
                    (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
                                              : Scene.this;

            // send the key event to the current focus owner or to scene if
            // the focus owner is not set
            Event.fireEvent(eventTarget, e);
        }

        private void requestFocus(Node node) {
            if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
                return;
            }
            setFocusOwner(node);
        }
    }
    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/
    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this scene. When replacing the value
     * with a new {@code EventDispatcher}, the new dispatcher should forward
     * events to the replaced dispatcher to keep the scene's default event
     * handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt;
            eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private SceneEventDispatcher internalEventDispatcher;

    // Delegates requests from platform input method to the focused
    // node's one, if any.
    class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
        @Override
        public Point2D getTextLocation(int offset) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getTextLocation(offset);
            } else {
                return new Point2D(0, 0);
            }
        }

        @Override
        public int getLocationOffset(int x, int y) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getLocationOffset(x, y);
            } else {
                return 0;
            }
        }

        @Override
        public void cancelLatestCommittedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                requests.cancelLatestCommittedText();
            }
        }

        @Override
        public String getSelectedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getSelectedText();
            }
            return null;
        }

        @Override
        public int getInsertPositionOffset() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
            }
            return 0;
        }

        @Override
        public String getCommittedText(int begin, int end) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
            }
            return null;
        }

        @Override
        public int getCommittedTextLength() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
            }
            return 0;
        }

        private InputMethodRequests getClientRequests() {
            Node focusOwner = getFocusOwner();
            if (focusOwner != null) {
                return focusOwner.getInputMethodRequests();
            }
            return null;
        }
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this scene. The handler is called when the
     * scene receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this scene. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventHandler(eventType,
                                                        eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this scene. The filter is called when the
     * scene receives an {@code Event} of the specified type during the
     * capturing phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this scene. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such
     * handler specified at a time. This handler is guaranteed to be called
     * first. This is used for registering the user-defined onFoo event
     * handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private SceneEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    final void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private SceneEventDispatcher createInternalEventDispatcher() {
        return new SceneEventDispatcher(this);
    }

    /**
     * Registers the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void addMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .addMnemonic(m);
    }


    /**
     * Unregisters the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void removeMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .removeMnemonic(m);
    }

    final void clearNodeMnemonics(Node node) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                .clearNodeMnemonics(node);
    }


    /**
     * Gets the list of mnemonics for this {@code Scene}.
     *
     * @return the list of mnemonics
     */
    public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getMnemonics();
    }

    /**
     * Gets the list of accelerators for this {@code Scene}.
     *
     * @return the list of accelerators
     */
    public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getAccelerators();
    }

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this scene. The event dispatch
     * chain contains all event dispatchers from the stage to this scene.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this scene
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {
        if (eventDispatcher != null) {
            final EventDispatcher eventDispatcherValue = eventDispatcher.get();
            if (eventDispatcherValue != null) {
                tail = tail.prepend(eventDispatcherValue);
            }
        }

        if (getWindow() != null) {
            tail = getWindow().buildEventDispatchChain(tail);
        }

        return tail;
    }

    /***************************************************************************
     *                                                                         *
     *                             Context Menus                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     * @since JavaFX 2.1
     */

    private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;

    public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return onContextMenuRequested == null ? null : onContextMenuRequested.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
        if (onContextMenuRequested == null) {
            onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onContextMenuRequested&quot;;
                }
            };
        }
        return onContextMenuRequested;
    }

    /***************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;

    public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return onMouseClicked == null ? null : onMouseClicked.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
        if (onMouseClicked == null) {
            onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_CLICKED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseClicked&quot;;
                }
            };
        }
        return onMouseClicked;
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Scene} and then dragged.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;

    public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return onMouseDragged == null ? null : onMouseDragged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
        if (onMouseDragged == null) {
            onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragged&quot;;
                }
            };
        }
        return onMouseDragged;
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;

    public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return onMouseEntered == null ? null : onMouseEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
        if (onMouseEntered == null) {
            onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseEntered&quot;;
                }
            };
        }
        return onMouseEntered;
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;

    public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return onMouseExited == null ? null : onMouseExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
        if (onMouseExited == null) {
            onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseExited&quot;;
                }
            };
        }
        return onMouseExited;
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Scene} but no buttons have been pushed.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;

    public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return onMouseMoved == null ? null : onMouseMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
        if (onMouseMoved == null) {
            onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseMoved&quot;;
                }
            };
        }
        return onMouseMoved;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;

    public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return onMousePressed == null ? null : onMousePressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
        if (onMousePressed == null) {
            onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMousePressed&quot;;
                }
            };
        }
        return onMousePressed;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;

    public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return onMouseReleased == null ? null : onMouseReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
        if (onMouseReleased == null) {
            onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseReleased&quot;;
                }
            };
        }
        return onMouseReleased;
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;

    public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return onDragDetected == null ? null : onDragDetected.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
        if (onDragDetected == null) {
            onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.DRAG_DETECTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDetected&quot;;
                }
            };
        }
        return onDragDetected;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;

    public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return onMouseDragOver == null ? null : onMouseDragOver.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
        if (onMouseDragOver == null) {
            onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragOver&quot;;
                }
            };
        }
        return onMouseDragOver;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;

    public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return onMouseDragReleased == null ? null : onMouseDragReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
        if (onMouseDragReleased == null) {
            onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragReleased&quot;;
                }
            };
        }
        return onMouseDragReleased;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;

    public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return onMouseDragEntered == null ? null : onMouseDragEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
        if (onMouseDragEntered == null) {
            onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragEntered&quot;;
                }
            };
        }
        return onMouseDragEntered;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * exits this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;

    public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return onMouseDragExited == null ? null : onMouseDragExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
        if (onMouseDragExited == null) {
            onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragExited&quot;;
                }
            };
        }
        return onMouseDragExited;
    }


    /***************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;

    public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return onScrollStarted == null ? null : onScrollStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
        if (onScrollStarted == null) {
            onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollStarted&quot;;
                }
            };
        }
        return onScrollStarted;
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;

    public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return onScroll == null ? null : onScroll.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
        if (onScroll == null) {
            onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScroll&quot;;
                }
            };
        }
        return onScroll;
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;

    public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return onScrollFinished == null ? null : onScrollFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
        if (onScrollFinished == null) {
            onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollFinished&quot;;
                }
            };
        }
        return onScrollFinished;
    }

    /**
     * Defines a function to be called when a rotating gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;

    public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return onRotationStarted == null ? null : onRotationStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
        if (onRotationStarted == null) {
            onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationStarted&quot;;
                }
            };
        }
        return onRotationStarted;
    }

    /**
     * Defines a function to be called when user performs a rotating action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;

    public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return onRotate == null ? null : onRotate.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
        if (onRotate == null) {
            onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotate&quot;;
                }
            };
        }
        return onRotate;
    }

    /**
     * Defines a function to be called when a rotating gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;

    public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return onRotationFinished == null ? null : onRotationFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
        if (onRotationFinished == null) {
            onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationFinished&quot;;
                }
            };
        }
        return onRotationFinished;
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;

    public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return onZoomStarted == null ? null : onZoomStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
        if (onZoomStarted == null) {
            onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomStarted&quot;;
                }
            };
        }
        return onZoomStarted;
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;

    public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return onZoom == null ? null : onZoom.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
        if (onZoom == null) {
            onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoom&quot;;
                }
            };
        }
        return onZoom;
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;

    public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return onZoomFinished == null ? null : onZoomFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
        if (onZoomFinished == null) {
            onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomFinished&quot;;
                }
            };
        }
        return onZoomFinished;
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;

    public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return onSwipeUp == null ? null : onSwipeUp.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
        if (onSwipeUp == null) {
            onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_UP, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeUp&quot;;
                }
            };
        }
        return onSwipeUp;
    }

    /**
     * Defines a function to be called when an downward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;

    public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return onSwipeDown == null ? null : onSwipeDown.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
        if (onSwipeDown == null) {
            onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_DOWN, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeDown&quot;;
                }
            };
        }
        return onSwipeDown;
    }

    /**
     * Defines a function to be called when an leftward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;

    public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return onSwipeLeft == null ? null : onSwipeLeft.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
        if (onSwipeLeft == null) {
            onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_LEFT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeLeft&quot;;
                }
            };
        }
        return onSwipeLeft;
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;

    public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return onSwipeRight == null ? null : onSwipeRight.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
        if (onSwipeRight == null) {
            onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeRight&quot;;
                }
            };
        }
        return onSwipeRight;
    }

    /***************************************************************************
     *                                                                         *
     *                            Touch Handling                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;

    public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return onTouchPressed == null ? null : onTouchPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
        if (onTouchPressed == null) {
            onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchPressed&quot;;
                }
            };
        }
        return onTouchPressed;
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;

    public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return onTouchMoved == null ? null : onTouchMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
        if (onTouchMoved == null) {
            onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchMoved&quot;;
                }
            };
        }
        return onTouchMoved;
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;

    public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return onTouchReleased == null ? null : onTouchReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
        if (onTouchReleased == null) {
            onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchReleased&quot;;
                }
            };
        }
        return onTouchReleased;
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;

    public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return onTouchStationary == null ? null : onTouchStationary.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
        if (onTouchStationary == null) {
            onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchStationary&quot;;
                }
            };
        }
        return onTouchStationary;
    }

    /*
     * This class provides reordering and ID mapping of particular touch points.
     * Platform may report arbitrary touch point IDs and they may be reused
     * during one gesture. This class keeps track of it and provides
     * sequentially sorted IDs, unique in scope of a gesture.
     *
     * Some platforms report always small numbers, these take fast paths through
     * the algorithm, directly indexing an array. Bigger numbers take a slow
     * path using a hash map.
     *
     * The algorithm performance was measured and it doesn't impose
     * any significant slowdown on the event delivery.
     */
    private static class TouchMap {
        private static final int FAST_THRESHOLD = 10;
        int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
        List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
        List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
        int counter = 0;
        int active = 0;

        public int add(long id) {
            counter++;
            active++;
            if (id &lt; FAST_THRESHOLD) {
                fastMap[(int) id] = counter;
            } else {
                slowMap.put(id, counter);
            }
            order.add(counter);
            return counter;
        }

        public void remove(long id) {
            // book the removal - it needs to be done after all touch points
            // of an event are processed - see cleanup()
            removed.add(id);
        }

        public int get(long id) {
            if (id &lt; FAST_THRESHOLD) {
                int result = fastMap[(int) id];
                if (result == 0) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
                return result;
            } else {
                try {
                    return slowMap.get(id);
                } catch (NullPointerException e) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
            }
        }

        public int getOrder(int id) {
            return order.indexOf(id);
        }

        // returns true if gesture finished (no finger is touched)
        public boolean cleanup() {
            for (long id : removed) {
                active--;
                order.remove(Integer.valueOf(get(id)));
                if (id &lt; FAST_THRESHOLD) {
                    fastMap[(int) id] = 0;
                } else {
                    slowMap.remove(id);
                }
                if (active == 0) {
                    // gesture finished
                    counter = 0;
                }
            }
            removed.clear();
            return active == 0;
        }
    }


    /***************************************************************************
     *                                                                         *
     *                         Drag and Drop Handling                          *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;

    public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return onDragEntered == null ? null : onDragEntered.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Scene}.
     * @return function to be called when drag gesture enters this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
        if (onDragEntered == null) {
            onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragEntered&quot;;
                }
            };
        }
        return onDragEntered;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;

    public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return onDragExited == null ? null : onDragExited.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Scene}.
     * @return the function to be called when drag gesture exits this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
        if (onDragExited == null) {
            onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragExited&quot;;
                }
            };
        }
        return onDragExited;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;

    public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return onDragOver == null ? null : onDragOver.get();
    }

    /**
     * Defines a function to be called when drag gesture progresses
     * within this {@code Scene}.
     * @return the function to be called when drag gesture progresses within
     * this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
        if (onDragOver == null) {
            onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragOver&quot;;
                }
            };
        }
        return onDragOver;
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
//
//    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
//    }
//
//    /**
//     * Defines a function to be called this {@code Scene} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
//        if (onDragTransferModeChanged == null) {
//            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
//
//                @Override
//                protected void invalidated() {
//                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
//                }
//            };
//        }
//        return onDragTransferModeChanged;
//    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;

    public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return onDragDropped == null ? null : onDragDropped.get();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Scene} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the function to be called when the mouse button is released on
     * this scene during drag and drop gesture
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
        if (onDragDropped == null) {
            onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DROPPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDropped&quot;;
                }
            };
        }
        return onDragDropped;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;

    public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return onDragDone == null ? null : onDragDone.get();
    }

    /**
     * Defines a function to be called when this {@code Scene} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * Positional data for the {@code DragEvent} is invalid.  Valid positional
     * data for the {@code DragEvent} is presented in the
     * {@link #onDragDroppedProperty() onDragDropped} event handler.
     * @return the function to be called when this scene is a drag and drop
     * gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
        if (onDragDone == null) {
            onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DONE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDone&quot;;
                }
            };
        }
        return onDragDone;
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Scene}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Scene}'s data on the
     * {@link Dragboard} also identifies this {@code Scene} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Scene}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        return startDragAndDrop(this, transferModes);
    }

    /**
     * Starts a full press-drag-release gesture with this scene as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        startFullDrag(this);
    }


    Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture == null ||
            (dndGesture.dragDetected != DragDetectedState.PROCESSING))
        {
            throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
        for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
            set.add(tm);
        }
        return dndGesture.startDrag(source, set);
    }

    void startFullDrag(EventTarget source) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
            throw new IllegalStateException(&quot;Cannot start full drag &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        if (dndGesture != null) {
            dndGesture.startFullPDR(source);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag when &quot;
                + &quot;mouse button is not pressed&quot;);
    }

    /***************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;

    public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return onKeyPressed == null ? null : onKeyPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
        if (onKeyPressed == null) {
            onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyPressed&quot;;
                }
            };
        }
        return onKeyPressed;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;

    public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return onKeyReleased == null ? null : onKeyReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
        if (onKeyReleased == null) {
            onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyReleased&quot;;
                }
            };
        }
        return onKeyReleased;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set( value);

    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
            ) {
        return onKeyTyped == null ? null : onKeyTyped.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
    ) {
        if (onKeyTyped == null) {
            onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_TYPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyTyped&quot;;
                }
            };
        }
        return onKeyTyped;
    }

    /***************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     */
    private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set( value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
        return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
        if (onInputMethodTextChanged == null) {
            onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onInputMethodTextChanged&quot;;
                }
            };
        }
        return onInputMethodTextChanged;
    }

    /*
     * This class represents a picked target - either node, or scne, or null.
     * It provides functionality needed for the targets and covers the fact
     * that they are different kinds of animals.
     */
    private static class TargetWrapper {
        private Scene scene;
        private Node node;
        private PickResult result;

        /**
         * Fills the list with the target and all its parents (including scene)
         */
        public void fillHierarchy(final List&lt;EventTarget&gt; list) {
            list.clear();
            Node n = node;
            while(n != null) {
                list.add(n);
                final Parent p = n.getParent();
                n = p != null ? p : n.getSubScene();
            }

            if (scene != null) {
                list.add(scene);
            }
        }

        public EventTarget getEventTarget() {
            return node != null ? node : scene;
        }

        public Cursor getCursor() {
            Cursor cursor = null;
            if (node != null) {
                cursor = node.getCursor();
                Node n = node.getParent();
                while (cursor == null &amp;&amp; n != null) {
                    cursor = n.getCursor();

                    final Parent p = n.getParent();
                    n = p != null ? p : n.getSubScene();
                }
            }
            return cursor;
        }

        public void clear() {
            set(null, null);
            result = null;
        }

        public void setNodeResult(PickResult result) {
            if (result != null) {
                this.result = result;
                final Node n = result.getIntersectedNode();
                set(n, n.getScene());
            }
        }

        // Pass null scene if the mouse is outside of the window content
        public void setSceneResult(PickResult result, Scene scene) {
            if (result != null) {
                this.result = result;
                set(null, scene);
            }
        }

        public PickResult getResult() {
            return result;
        }

        public void copy(TargetWrapper tw) {
            node = tw.node;
            scene = tw.scene;
            result = tw.result;
        }

        private void set(Node n, Scene s) {
            node = n;
            scene = s;
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this scene
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      *
      * @since JavaFX 8u40
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Scene has properties.
     * @return true if node has properties.
     *
     * @since JavaFX 8u40
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Scene#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Scene#getUserData()}.
     *
     * @since JavaFX 8u40
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     *
     * @since JavaFX 8u40
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private static final NodeOrientation defaultNodeOrientation =
        AccessController.doPrivileged(
                (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;



    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private NodeOrientation effectiveNodeOrientation;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
    }

    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
                @Override
                protected void invalidated() {
                    sceneEffectiveOrientationInvalidated();
                    getRoot().applyCss();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not yet supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }
            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        if (effectiveNodeOrientation == null) {
            effectiveNodeOrientation = calcEffectiveNodeOrientation();
        }

        return effectiveNodeOrientation;
    }

    /**
     * The effective node orientation of a scene resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the effective node orientation of this scene
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    private void parentEffectiveOrientationInvalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            sceneEffectiveOrientationInvalidated();
        }
    }

    private void sceneEffectiveOrientationInvalidated() {
        effectiveNodeOrientation = null;

        if (effectiveNodeOrientationProperty != null) {
            effectiveNodeOrientationProperty.invalidate();
        }

        getRoot().parentResolvedOrientationInvalidated();
    }

    private NodeOrientation calcEffectiveNodeOrientation() {
        NodeOrientation orientation = getNodeOrientation();
        if (orientation == NodeOrientation.INHERIT) {
            Window window = getWindow();
            if (window != null) {
                Window parent = null;
                if (window instanceof Stage) {
                    parent = ((Stage)window).getOwner();
                } else {
                    if (window instanceof PopupWindow) {
                        parent = ((PopupWindow)window).getOwnerWindow();
                    }
                }
                if (parent != null) {
                    Scene scene = parent.getScene();
                    if (scene != null) return scene.getEffectiveNodeOrientation();
                }
            }
            return NodeOrientation.LEFT_TO_RIGHT;
        }
        return orientation;
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Scene.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    private Map&lt;Node, Accessible&gt; accMap;
    Accessible removeAccessible(Node node) {
        if (accMap == null) return null;
        return accMap.remove(node);
    }

    void addAccessible(Node node, Accessible acc) {
        if (accMap == null) {
            accMap = new HashMap&lt;Node, Accessible&gt;();
        }
        accMap.put(node, acc);
    }

    private void disposeAccessibles() {
        if (accMap != null) {
            for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
                Node node = entry.getKey();
                Accessible acc = entry.getValue();
                if (node.accessible != null) {
                    /* This node has already been initialized to another scene.
                     * Note an accessible can be returned to the node before the
                     * pulse if getAccessible() is called. In which case it must
                     * already being removed from accMap.
                     */
                    if (node.accessible == acc) {
                        System.err.println(&quot;[A11y] 'node.accessible == acc' should never happen.&quot;);
                    }
                    if (node.getScene() == this) {
                        System.err.println(&quot;[A11y] 'node.getScene() == this' should never happen.&quot;);
                    }
                    acc.dispose();
                } else {
                    if (node.getScene() == this) {
                        node.accessible = acc;
                    } else {
                        acc.dispose();
                    }
                }
            }
            accMap.clear();
        }
    }

    private Accessible accessible;
    Accessible getAccessible() {
        /*
         * The accessible for the Scene should never be
         * requested when the peer is not set.
         * This can only happen in a error case where a
         * descender of this Scene was not disposed and
         * it still being used by the AT client and trying
         * to reach to the top level window.
         */
        if (peer == null) return null;
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @Override public AccessControlContext getAccessControlContext() {
                    return getPeer().getAccessControlContext();
                }

                @Override public Object getAttribute(AccessibleAttribute attribute,
                                                     Object... parameters) {
                    switch (attribute) {
                        case CHILDREN: {
                            Parent root = getRoot();
                            if (root != null) {
                                return FXCollections.observableArrayList(root);
                            }
                            break;
                        }
                        case TEXT: {
                            Window w = getWindow();
                            if (w instanceof Stage) {
                                return ((Stage)w).getTitle();
                            }
                            break;
                        }
                        case NODE_AT_POINT: {
                            Window window = getWindow();
                            /* is this screen to scene translation correct ? not considering camera ? */
                            Point2D pt = (Point2D)parameters[0];
                            PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
                            if (res != null) {
                                Node node = res.getIntersectedNode();
                                if (node != null) return node;
                            }
                            return getRoot();//not sure
                        }
                        case ROLE: return AccessibleRole.PARENT;
                        case SCENE: return Scene.this;
                        case FOCUS_NODE: {
                            if (transientFocusContainer != null) {
                                return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
                            }
                            return getFocusOwner();
                        }
                        default:
                    }
                    return super.getAttribute(attribute, parameters);
                }
            });
            PlatformImpl.accessibilityActiveProperty().set(true);
        }
        return accessible;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/SnapshotResult.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="4"></A> * questions.
 */

<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#4',2,'match42-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package javafx.scene;

import javafx.scene.image.WritableImage;

/**
 * This class holds the result of a snapshot operation.
 * @since JavaFX 2.2
 */
public class SnapshotResult {
    private WritableImage image;
    private Object source;
    private SnapshotParameters params;

    // Package scope constructor
    SnapshotResult(WritableImage image, Object source, SnapshotParameters params) {
        this.image = image;
        this.source = source;
        this.params = params;
    }

    /**
     * Gets the image generated by the snapshot operation.
     *
     * @return the generated image
     */
    public WritableImage getImage() {
        return image;
    }

    /**
     * Gets the source Node or Scene on which the snapshot was called.
     *
     * @return the source of the snapshot
     */
    public Object getSource() {
        return source;
    }

    /**
     * Gets a copy of the SnapshotParameters used to generate the snapshot.
     * This will be null in the case of snapshot being called on a Scene.
     *
     * @return a copy of the SnapshotParameters used to perform the snapshot,
     * or null
     */
    public SnapshotParameters getSnapshotParameters() {
        return params;
    }</B></FONT>

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/effect/ColorInput.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.effect;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;

import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.javafx.tk.Toolkit;


/**
 * An effect that renders a rectangular region that is filled (&quot;flooded&quot;)
 * with the given {@code Paint}.  This is equivalent to rendering a
 * filled rectangle into an image and using an {@code ImageInput} effect,
 * except that it is more convenient and potentially much more efficient.
 * @since JavaFX 2.0
 */
public class ColorInput extends Effect {
    /**
     * Creates a new instance of ColorInput with default parameters.
     */
    public ColorInput() {}

    /**
     * Creates a new instance of ColorInput with the specified x, y, width,
     * height, and paint.
     * @param x the x location of the region to be flooded
     * @param y the y location of the region to be flooded
     * @param width the width of the region to be flooded
     * @param height the height of the region to be flooded
     * @param paint the {@code Paint} used to flood the region
     * @since JavaFX 2.1
     */
    public ColorInput(double x,
                      double y,
                      double width,
                      double height,
                      Paint paint) {
        setX(x);
        setY(y);
        setWidth(width);
        setHeight(height);
        setPaint(paint);
    }

    @Override
    com.sun.scenario.effect.Flood createPeer() {
        return new com.sun.scenario.effect.Flood(
                Toolkit.getPaintAccessor().getPlatformPaint(Color.RED));
    };
    /**
     * The {@code Paint} used to flood the region.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: Color.RED
     *  Identity: n/a
     * &lt;/pre&gt;
     * @defaultValue RED
     */
    private ObjectProperty&lt;Paint&gt; paint;


    public final void setPaint(Paint value) {
        paintProperty().set(value);
    }

    public final Paint getPaint() {
        return paint == null ? Color.RED : paint.get();
    }

    public final ObjectProperty&lt;Paint&gt; paintProperty() {
        if (paint == null) {
            paint = new ObjectPropertyBase&lt;Paint&gt;(Color.RED) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return ColorInput.this;
                }

                @Override
                public String getName() {
                    return &quot;paint&quot;;
                }
            };
        }
        return paint;
    }

    /**
     * Sets the x location of the region to be flooded, relative to the
     * local coordinate space of the content {@code Node}.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: 0.0
     *  Identity: 0.0
     * &lt;/pre&gt;
     * @defaultValue 0.0
     */
    private DoubleProperty x;


    public final void setX(double value) {
        xProperty().set(value);
    }

    public final double getX() {
        return x == null ? 0 : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                    effectBoundsChanged();
                }

                @Override
                public Object getBean() {
                    return ColorInput.this;
                }

                @Override
                public String getName() {
                    return &quot;x&quot;;
                }
            };
        }
        return x;
    }

    /**
     * Sets the y location of the region to be flooded, relative to the
     * local coordinate space of the content {@code Node}.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: 0.0
     *  Identity: 0.0
     * &lt;/pre&gt;
     * @defaultValue 0.0
     */
    private DoubleProperty y;


    public final void setY(double value) {
        yProperty().set(value);
    }

    public final double getY() {
        return y == null ? 0 : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                    effectBoundsChanged();
                }

                @Override
                public Object getBean() {
                    return ColorInput.this;
                }

                @Override
                public String getName() {
                    return &quot;y&quot;;
                }
            };
        }
        return y;
    }

    /**
     * Sets the width of the region to be flooded, relative to the
     * local coordinate space of the content {@code Node}.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: 0.0
     *  Identity: 0.0
     * &lt;/pre&gt;
     * @defaultValue 0.0
     */
    private DoubleProperty width;


    public final void setWidth(double value) {
        widthProperty().set(value);
    }

    public final double getWidth() {
        return width == null ? 0 : width.get();
    }

    public final DoubleProperty widthProperty() {
        if (width == null) {
            width = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                    effectBoundsChanged();
                }

                @Override
                public Object getBean() {
                    return ColorInput.this;
                }

                @Override
                public String getName() {
                    return &quot;width&quot;;
                }
            };
        }
        return width;
    }

    /**
     * Sets the height of the region to be flooded, relative to the
     * local coordinate space of the content {@code Node}.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: 0.0
     *  Identity: 0.0
     * &lt;/pre&gt;
     * @defaultValue 0.0
     */
    private DoubleProperty height;


    public final void setHeight(double value) {
        heightProperty().set(value);
    }

    public final double getHeight() {
        return height == null ? 0 : height.get();
    }

    public final DoubleProperty heightProperty() {
        if (height == null) {
            height = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                    effectBoundsChanged();
                }

                @Override
                public Object getBean() {
                    return ColorInput.this;
                }

                @Override
                public String getName() {
                    return &quot;height&quot;;
                }
            };
        }
        return height;
    }

    private Paint getPaintInternal() {
        Paint p = getPaint();
        return p == null ? Color.RED : p;
    }
<A NAME="21"></A>
    @Override
    void update() {
        <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#21',2,'match42-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>com.sun.scenario.effect.Flood peer =
                (com.sun.scenario.effect.Flood) getPeer();
        peer.setPaint(Toolkit.getPaintAccessor().getPlatformPaint(getPaintInternal()));
        peer.setFloodBounds(new RectBounds(
                (float)getX(), (float)getY(),
                (float)(getX() + getWidth()),
                (float)(getY() + getHeight())));
    }</B></FONT>

    @Override
    boolean checkChainContains(Effect e) {
        return false;
    }

    @Override
    BaseBounds getBounds(BaseBounds bounds,
                         BaseTransform tx,
                         Node node,
                         BoundsAccessor boundsAccessor) {
        RectBounds ret = new RectBounds(
                (float)getX(), (float)getY(),
                (float)(getX() + getWidth()),
                (float)(getY() + getHeight()));
        return transformBounds(tx, ret);
    }

    @Override
    Effect copy() {
        return new ColorInput(this.getX(), this.getY(), this.getWidth(), this.getHeight(), this.getPaint());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/effect/Effect.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.effect;

import javafx.beans.Observable;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.scene.Node;

import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.scenario.effect.EffectHelper;

/**
 * The abstract base class for all effect implementations.
 * An effect is a graphical algorithm that produces an image, typically
 * as a modification of a source image.
 * An effect can be associated with a scene graph {@code Node} by setting
 * the {@link javafx.scene.Node#effectProperty Node.effect} attribute.
 * Some effects change the color properties of the source pixels
 * (such as {@link ColorAdjust}),
 * others combine multiple images together (such as {@link Blend}),
 * while still others warp or move the pixels of the source image around
 * (such as {@link DisplacementMap} or {@link PerspectiveTransform}).
 * All effects have at least one input defined and the input can be set
 * to another effect to chain the effects together and combine their
 * results, or it can be left unspecified in which case the effect will
 * operate on a graphical rendering of the node it is attached to.
 * &lt;p&gt;
 * Note: this is a conditional feature. See
 * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
 * for more information.
 * @since JavaFX 2.0
 */
public abstract class Effect {
    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        EffectHelper.setEffectAccessor(new EffectHelper.EffectAccessor() {

            @Override
            public com.sun.scenario.effect.Effect getPeer(Effect effect) {
                return effect.getPeer();
            }

            @Override
            public void sync(Effect effect) {
                effect.sync();
            }

            @Override
            public IntegerProperty effectDirtyProperty(Effect effect) {
                return effect.effectDirtyProperty();
            }

            @Override
            public boolean isEffectDirty(Effect effect) {
                return effect.isEffectDirty();
            }

            @Override
            public BaseBounds getBounds(Effect effect, BaseBounds bounds,
                    BaseTransform tx, Node node, BoundsAccessor boundsAccessor) {
                return effect.getBounds(bounds, tx, node, boundsAccessor);
            }

            @Override
            public Effect copy(Effect effect) {
                return effect.copy();
            }

            @Override
            public com.sun.scenario.effect.Blend.Mode getToolkitBlendMode(BlendMode mode) {
                return Blend.getToolkitMode(mode);
            }
        });
    }

    /**
     * Creates a new Effect.
     */
    protected Effect() {
       markDirty(EffectDirtyBits.EFFECT_DIRTY);
    }

    void effectBoundsChanged() {
        toggleDirty(EffectDirtyBits.BOUNDS_CHANGED);
    }

    private com.sun.scenario.effect.Effect peer;
    abstract com.sun.scenario.effect.Effect createPeer();

    com.sun.scenario.effect.Effect getPeer() {
        if (peer == null) {
            peer = createPeer();
        }
        return peer;
    }

    // effect is marked dirty in the constructor, so we don't need to be lazy here
    private IntegerProperty effectDirty =
            new SimpleIntegerProperty(this, &quot;effectDirty&quot;);

    private void setEffectDirty(int value) {
        effectDirtyProperty().set(value);
    }

    private final IntegerProperty effectDirtyProperty() {
        return effectDirty;
    }

    private final boolean isEffectDirty() {
        return isEffectDirty(EffectDirtyBits.EFFECT_DIRTY);
    }

    /**
     * Set the specified dirty bit
     */
    final void markDirty(EffectDirtyBits dirtyBit) {
        setEffectDirty(effectDirty.get() | dirtyBit.getMask());
    }

    /**
     * Toggle the specified dirty bit
     */
    private void toggleDirty(EffectDirtyBits dirtyBit) {
        setEffectDirty(effectDirty.get() ^ dirtyBit.getMask());
    }

    /**
     * Test the specified dirty bit
     */
    private boolean isEffectDirty(EffectDirtyBits dirtyBit) {
        return ((effectDirty.get() &amp; dirtyBit.getMask()) != 0);
    }

    /**
     * Clear the specified dirty bit
     */
    private void clearEffectDirty(EffectDirtyBits dirtyBit) {
        setEffectDirty(effectDirty.get() &amp; ~dirtyBit.getMask());
    }

    final void sync() {
        if (isEffectDirty(EffectDirtyBits.EFFECT_DIRTY)) {
            update();
            clearEffectDirty(EffectDirtyBits.EFFECT_DIRTY);
        }
    }

    abstract void update();

    abstract boolean checkChainContains(Effect e);

    boolean containsCycles(Effect value) {
        if (value != null
                &amp;&amp; (value == this || value.checkChainContains(this))) {
            return true;
        }
        return false;
    }

    class EffectInputChangeListener extends EffectChangeListener {
        private int oldBits;

        public void register(Effect value) {
            super.register(value == null? null: value.effectDirtyProperty());
            if (value != null) {
                oldBits = value.effectDirtyProperty().get();
            }
        }

        @Override
        public void invalidated(Observable valueModel) {
            int newBits = ((IntegerProperty)valueModel).get();
            int dirtyBits = newBits ^ oldBits;
            oldBits = newBits;
            if (EffectDirtyBits.isSet(dirtyBits, EffectDirtyBits.EFFECT_DIRTY)
                &amp;&amp; EffectDirtyBits.isSet(newBits, EffectDirtyBits.EFFECT_DIRTY)) {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
            }
            if (EffectDirtyBits.isSet(dirtyBits, EffectDirtyBits.BOUNDS_CHANGED)) {
                toggleDirty(EffectDirtyBits.BOUNDS_CHANGED);
            }
<A NAME="5"></A>        }
    }

    <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#5',2,'match42-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>class EffectInputProperty extends ObjectPropertyBase&lt;Effect&gt; {
        private final String propertyName;

        private Effect validInput = null;

        private final EffectInputChangeListener effectChangeListener =
                new EffectInputChangeListener();

        public EffectInputProperty(final String propertyName) {
            this.propertyName = propertyName;
        }

        @Override
        public void invalidated() {
            final Effect newInput = super.get()</B></FONT>;
            if (containsCycles(newInput)) {
                if (isBound()) {
                    unbind();
                    set(validInput);
                    throw new IllegalArgumentException(&quot;Cycle in effect chain &quot;
                            + &quot;detected, binding was set to incorrect value, &quot;
                            + &quot;unbinding the input property&quot;);
                } else {
                    set(validInput);
                    throw new IllegalArgumentException(&quot;Cycle in effect chain detected&quot;);
                }
            }
            validInput = newInput;
            effectChangeListener.register(newInput);
            markDirty(EffectDirtyBits.EFFECT_DIRTY);

            // we toggle dirty flag for bounds on this effect to notify
            // &quot;consumers&quot; of this effect that bounds have changed
            //
            // bounds of this effect might change
            // even if bounds of chained effect are not dirty
            effectBoundsChanged();
        }

        @Override
        public Object getBean() {
            return Effect.this;
        }

        @Override
        public String getName() {
            return propertyName;
        }
    }

   /**
    * Returns bounds of given node with applied effect.
    *
    * We *never* pass null in as a bounds. This method will
    * NOT take a null bounds object. The returned value may be
    * the same bounds object passed in, or it may be a new object.
    */
    abstract BaseBounds getBounds(BaseBounds bounds,
                                  BaseTransform tx,
                                  Node node,
                                  BoundsAccessor boundsAccessor);

    abstract Effect copy();

    static BaseBounds transformBounds(BaseTransform tx, BaseBounds r) {
        if (tx == null || tx.isIdentity()) {
            return r;
        }
        BaseBounds ret = new RectBounds();
        ret = tx.transform(r, ret);
        return ret;
    }

    // utility method used in calculation of bounds in BoxBlur and DropShadow effects
    static int getKernelSize(float fsize, int iterations) {
        int ksize = (int) Math.ceil(fsize);
        if (ksize &lt; 1) ksize = 1;
        ksize = (ksize-1) * iterations + 1;
        ksize |= 1;
        return ksize / 2;
    }

    // utility method used for calculation of bounds in Shadow and DropShadow effects
    static BaseBounds getShadowBounds(BaseBounds bounds,
                                      BaseTransform tx,
                                      float width,
                                      float height,
                                      BlurType blurType) {
        int hgrow = 0;
        int vgrow = 0;

        switch (blurType) {
            case GAUSSIAN:
                float hradius = width &lt; 1.0f ? 0.0f : ((width - 1.0f) / 2.0f);
                float vradius = height &lt; 1.0f ? 0.0f : ((height - 1.0f) / 2.0f);
                hgrow = (int) Math.ceil(hradius);
                vgrow = (int) Math.ceil(vradius);
                break;
            case ONE_PASS_BOX:
                hgrow = getKernelSize(Math.round(width/3.0f), 1);
                vgrow = getKernelSize(Math.round(height/3.0f), 1);
                break;
            case TWO_PASS_BOX:
                hgrow = getKernelSize(Math.round(width/3.0f), 2);
                vgrow = getKernelSize(Math.round(height/3.0f), 2);
                break;
            case THREE_PASS_BOX:
                hgrow = getKernelSize(Math.round(width/3.0f), 3);
                vgrow = getKernelSize(Math.round(height/3.0f), 3);
                break;
        }

        bounds = bounds.deriveWithPadding(hgrow, vgrow, 0);

        return transformBounds(tx, bounds);
    }

    // Returns input bounds for an effect. These are either bounds of input effect or
    // geometric bounds of the node on which the effect calling this method is applied.
    static BaseBounds getInputBounds(BaseBounds bounds,
                                     BaseTransform tx,
                                     Node node,
                                     BoundsAccessor boundsAccessor,
                                     Effect input) {
        if (input != null) {
            bounds = input.getBounds(bounds, tx, node, boundsAccessor);
        } else {
            bounds = boundsAccessor.getGeomBounds(bounds, tx, node);
        }

        return bounds;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/input/KeyEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.input;

import com.sun.javafx.tk.Toolkit;
import javafx.beans.NamedArg;
import javafx.event.EventTarget;
import javafx.event.EventType;

import com.sun.javafx.scene.input.KeyCodeMap;
import javafx.event.Event;
import javafx.scene.input.ScrollEvent.HorizontalTextScrollUnits;
import javafx.scene.input.ScrollEvent.VerticalTextScrollUnits;

/**
 * An event which indicates that a keystroke occurred in a {@link javafx.scene.Node}.
 * &lt;p&gt;
 * This event is generated when a key is pressed, released, or typed.
 * Depending on the type of the event it is passed
 * to {@link javafx.scene.Node#onKeyPressedProperty onKeyPressed}, {@link javafx.scene.Node#onKeyTypedProperty onKeyTyped}
 * or {@link javafx.scene.Node#onKeyReleasedProperty onKeyReleased} function.
 *
 * &lt;p&gt;
 * &lt;em&gt;&quot;Key typed&quot; events&lt;/em&gt; are higher-level and generally do not depend on
 * the platform or keyboard layout.  They are generated when a Unicode character
 * is entered, and are the preferred way to find out about character input.
 * In the simplest case, a key typed event is produced by a single key press
 * (e.g., 'a').  Often, however, characters are produced by series of key
 * presses (e.g., SHIFT + 'a'), and the mapping from key pressed events to
 * key typed events may be many-to-one or many-to-many.  Key releases are not
 * usually necessary to generate a key typed event, but there are some cases
 * where the key typed event is not generated until a key is released (e.g.,
 * entering ASCII sequences via the Alt-Numpad method in Windows).
 * No key typed events are generated for keys that don't generate Unicode
 * characters (e.g., action keys, modifier keys, etc.).
 *
 * &lt;p&gt;
 * The {@code character} variable always contains a valid Unicode character(s)
 * or CHAR_UNDEFINED. Character input is reported by key typed events;
 * key pressed and key released events are not necessarily associated
 * with character input. Therefore, the {@code character} variable
 * is guaranteed to be meaningful only for key typed events.
 *
 * &lt;p&gt;
 * For key pressed and key released events, the {@code code} variable contains
 * the event's key code.  For key typed events, the {@code code} variable
 * always contains {@code KeyCode.UNDEFINED}.
 *
 * &lt;p&gt;
 * &lt;em&gt;&quot;Key pressed&quot; and &quot;key released&quot; events&lt;/em&gt; are lower-level and depend
 * on the platform and keyboard layout. They are generated whenever a key is
 * pressed or released, and are the only way to find out about keys that don't
 * generate character input (e.g., action keys, modifier keys, etc.). The key
 * being pressed or released is indicated by the code variable, which contains
 * a virtual key code.
 *
 * &lt;p&gt;
 * For triggering context menus see the {@link ContextMenuEvent}.
 * @since JavaFX 2.0
 */
public final class KeyEvent extends InputEvent {

    private static final long serialVersionUID = 20121107L;

    /**
     * Common supertype for all key event types.
     */
    public static final EventType&lt;KeyEvent&gt; ANY =
            new EventType&lt;KeyEvent&gt;(InputEvent.ANY, &quot;KEY&quot;);

    /**
     * This event occurs when a key has been pressed.
     */
    public static final EventType&lt;KeyEvent&gt; KEY_PRESSED =
            new EventType&lt;KeyEvent&gt;(KeyEvent.ANY, &quot;KEY_PRESSED&quot;);

    /**
     * This event occurs when a key has been released.
     */
    public static final EventType&lt;KeyEvent&gt; KEY_RELEASED =
            new EventType&lt;KeyEvent&gt;(KeyEvent.ANY, &quot;KEY_RELEASED&quot;);

    /**
     * This event occurs when a character-generating key was typed
     * (pressed and released).  The event contains the {@code character}
     * field containing the typed string, the {@code code} and {@code text}
     * fields are not used.
     */
    public static final EventType&lt;KeyEvent&gt; KEY_TYPED =
            new EventType&lt;KeyEvent&gt;(KeyEvent.ANY, &quot;KEY_TYPED&quot;);

    /**
     * Constructs a new {@code KeyEvent} event from the specified parameters.
     * @param source the source of the event. Can be null.
     * @param target the target of the event. Can be null.
     * @param eventType The type of the event.
     * @param character The character or sequence of characters associated with the event
     * @param text A String describing the key code
     * @param code The integer key code
     * @param shiftDown true if shift modifier was pressed.
     * @param controlDown true if control modifier was pressed.
     * @param altDown true if alt modifier was pressed.
     * @param metaDown true if meta modifier was pressed.
     * @since JavaFX 8.0
     */
    public KeyEvent(@NamedArg(&quot;source&quot;) Object source, @NamedArg(&quot;target&quot;) EventTarget target, @NamedArg(&quot;eventType&quot;) EventType&lt;KeyEvent&gt; eventType, @NamedArg(&quot;character&quot;) String character,
            @NamedArg(&quot;text&quot;) String text, @NamedArg(&quot;code&quot;) KeyCode code, @NamedArg(&quot;shiftDown&quot;) boolean shiftDown, @NamedArg(&quot;controlDown&quot;) boolean controlDown,
            @NamedArg(&quot;altDown&quot;) boolean altDown, @NamedArg(&quot;metaDown&quot;) boolean metaDown) {
        super(source, target, eventType);
        boolean isKeyTyped = eventType == KEY_TYPED;

        this.character = isKeyTyped ? character : KeyEvent.CHAR_UNDEFINED;
        this.text = isKeyTyped ? &quot;&quot; : text;
        this.code = isKeyTyped ? KeyCode.UNDEFINED : code;
        this.shiftDown = shiftDown;
        this.controlDown = controlDown;
        this.altDown = altDown;
        this.metaDown = metaDown;
    }

    /**
     * Constructs a new {@code KeyEvent} event from the specified parameters,
     * with a {@code null} source and target.
     * @param eventType The type of the event.
     * @param character The character or sequence of characters associated with the event
     * @param text A String describing the key code
     * @param code The integer key code
     * @param shiftDown true if shift modifier was pressed.
     * @param controlDown true if control modifier was pressed.
     * @param altDown true if alt modifier was pressed.
     * @param metaDown true if meta modifier was pressed.
     * @since JavaFX 8.0
     */
    public KeyEvent(@NamedArg(&quot;eventType&quot;) EventType&lt;KeyEvent&gt; eventType, @NamedArg(&quot;character&quot;) String character,
            @NamedArg(&quot;text&quot;) String text, @NamedArg(&quot;code&quot;) KeyCode code, @NamedArg(&quot;shiftDown&quot;) boolean shiftDown, @NamedArg(&quot;controlDown&quot;) boolean controlDown,
            @NamedArg(&quot;altDown&quot;) boolean altDown, @NamedArg(&quot;metaDown&quot;) boolean metaDown) {
        super(eventType);
        boolean isKeyTyped = eventType == KEY_TYPED;

        this.character = isKeyTyped ? character : KeyEvent.CHAR_UNDEFINED;
        this.text = isKeyTyped ? &quot;&quot; : text;
        this.code = isKeyTyped ? KeyCode.UNDEFINED : code;
        this.shiftDown = shiftDown;
        this.controlDown = controlDown;
        this.altDown = altDown;
        this.metaDown = metaDown;
    }

    /**
     * KEY_PRESSED and KEY_RELEASED events which do not map to a valid Unicode
     * character use this for the keyChar value.
     */
    public static final String CHAR_UNDEFINED = KeyCode.UNDEFINED.ch;

    /**
     * The Unicode character or sequence of characters associated with the key
     * typed event. Contains multiple elements if the key produced a single
     * Unicode character from outside of the Basic Multilingual Plane which
     * needs to be encoded by the corresponding surrogate pair in Java or if
     * the key produced multiple Unicode characters itself.
     * &lt;p&gt;
     * For example, {@code character} will have the value &quot;A&quot; for a key typed
     * event generated by pressing SHIFT + 'a'.
     * For key pressed and key released events, {@code character} is always
     * {@code CHAR_UNDEFINED}.
     */
    private final String character;

    /**
     * The Unicode character or sequence of characters associated with the key
     * typed event. Contains multiple elements if the key produced a single
     * Unicode character from outside of the Basic Multilingual Plane which
     * needs to be encoded by the corresponding surrogate pair in Java or if
     * the key produced multiple Unicode characters itself.
     * &lt;p&gt;
     * For example, {@code character} will have the value &quot;A&quot; for a key typed
     * event generated by pressing SHIFT + 'a'.
     * For key pressed and key released events, {@code character} is always
     * {@code CHAR_UNDEFINED}.
     *
     * @return The Unicode character(s) associated with the key typed event
     */
    public final String getCharacter() {
        return character;
    }

    /**
     * A String describing the key code, such as &quot;HOME&quot;, &quot;F1&quot; or &quot;A&quot;,
     * for key pressed and key released events.
     * For key typed events, {@code text} is always the empty string.
     */
    private final String text;

    /**
     * A String describing the key code, such as &quot;HOME&quot;, &quot;F1&quot; or &quot;A&quot;,
     * for key pressed and key released events.
     * For key typed events, {@code text} is always the empty string.
     *
     * @return A String describing the key code
     */
    public final String getText() {
        return text;
    }

    /**
     * The integer key code associated with the key in this key
     * pressed or key released event.
     * For key typed events, {@code code} is always {@code KeyCode.UNDEFINED}.
     */
    private final KeyCode code;

    /**
     * The key code associated with the key in this key pressed or key released
     * event. For key typed events, {@code code} is always {@code KeyCode.UNDEFINED}.
     *
     * @return The key code associated with the key in this event,
     * {@code KeyCode.UNDEFINED} for key typed event
     */
    public final KeyCode getCode() {
        return code;
    }

    /**
     * Returns whether or not the Shift modifier is down on this event.
     */
    private final boolean shiftDown;

    /**
     * Returns whether or not the Shift modifier is down on this event.
     * @return whether or not the Shift modifier is down on this event.
     */
    public final boolean isShiftDown() {
        return shiftDown;
    }

    /**
     * Returns whether or not the Control modifier is down on this event.
     */
    private final boolean controlDown;

    /**
     * Returns whether or not the Control modifier is down on this event.
     * @return whether or not the Control modifier is down on this event.
     */
    public final boolean isControlDown() {
        return controlDown;
    }

    /**
     * Returns whether or not the Alt modifier is down on this event.
     */
    private final boolean altDown;

    /**
     * Returns whether or not the Alt modifier is down on this event.
     * @return whether or not the Alt modifier is down on this event.
     */
    public final boolean isAltDown() {
        return altDown;
    }

    /**
     * Returns whether or not the Meta modifier is down on this event.
     */
    private final boolean metaDown;

    /**
     * Returns whether or not the Meta modifier is down on this event.
     * @return whether or not the Meta modifier is down on this event.
     */
    public final boolean isMetaDown() {
        return metaDown;
    }


    /**
     * Returns whether or not the host platform common shortcut modifier is
     * down on this event. This common shortcut modifier is a modifier key which
     * is used commonly in shortcuts on the host platform. It is for example
     * {@code control} on Windows and {@code meta} (command key) on Mac.
     *
     * @return {@code true} if the shortcut modifier is down, {@code false}
     *      otherwise
     */
    public final boolean isShortcutDown() {
        switch (Toolkit.getToolkit().getPlatformShortcutKey()) {
            case SHIFT:
                return shiftDown;

            case CONTROL:
                return controlDown;

            case ALT:
                return altDown;

            case META:
                return metaDown;

            default:
                return false;
        }
    }

    /**
     * Returns a string representation of this {@code KeyEvent} object.
     * @return a string representation of this {@code KeyEvent} object.
     */
    @Override public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;KeyEvent [&quot;);

        sb.append(&quot;source = &quot;).append(getSource());
        sb.append(&quot;, target = &quot;).append(getTarget());
        sb.append(&quot;, eventType = &quot;).append(getEventType());
<A NAME="45"></A>        sb.append(&quot;, consumed = &quot;).append(isConsumed());

        sb.append(&quot;, character = &quot;).append(getCharacter());
        sb.append(&quot;, text = &quot;).append(<FONT color="#79d867"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#45',2,'match42-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getText());
        sb.append(&quot;, code = &quot;).append(getCode());

        if (isShiftDown()) {
            sb.append(&quot;, shiftDown&quot;);
        }
        if (isControlDown()) {
            sb.append(&quot;, controlDown&quot;);
        }
        if (isAltDown()) {
            sb.append(&quot;, altDown&quot;);
        }
        if</B></FONT> (isMetaDown()) {
            sb.append(&quot;, metaDown&quot;);
        }
        if (isShortcutDown()) {
            sb.append(&quot;, shortcutDown&quot;);
        }

        return sb.append(&quot;]&quot;).toString();
    }

    @Override
    public KeyEvent copyFor(Object newSource, EventTarget newTarget) {
        return (KeyEvent) super.copyFor(newSource, newTarget);
    }

    /**
     * Creates a copy of the given event with the given fields substituted.
     * @param source the new source of the copied event
     * @param target the new target of the copied event
     * @param type the new event type.
     * @return the event copy with the fields substituted
     * @since JavaFX 8.0
     */
    public KeyEvent copyFor(Object source, EventTarget target, EventType&lt;KeyEvent&gt; type) {
        KeyEvent e = copyFor(source, target);
        e.eventType = type;
        return e;
    }

    @Override
    public EventType&lt;KeyEvent&gt; getEventType() {
        return (EventType&lt;KeyEvent&gt;) super.getEventType();
    }



}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/TriangleMesh.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.scene.shape.ObservableFaceArrayImpl;
import com.sun.javafx.collections.FloatArraySyncer;
import com.sun.javafx.collections.IntegerArraySyncer;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.shape.TriangleMeshHelper;
import com.sun.javafx.sg.prism.NGTriangleMesh;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ArrayChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ObservableArray;
import javafx.collections.ObservableFloatArray;
import javafx.collections.ObservableIntegerArray;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.scene.Node;
import javafx.scene.input.PickResult;
import javafx.scene.transform.Affine;
import javafx.scene.transform.NonInvertibleTransformException;
import javafx.scene.transform.Rotate;
import com.sun.javafx.logging.PlatformLogger;

/**
 * Defines a 3D triangle mesh that consists of its associated {@code VertexFormat}
 * and a set of separate arrays of vertex components such as points, normals,
 * texture coordinates, and an array of faces that define the individual triangles
 * of the mesh.
 *&lt;p&gt;
 * Note that the term point, as used in the method names and method
 * descriptions, actually refers to a 3D point (x, y, z) in space
 * representing the position of a single vertex. The term points (plural) is
 * used to indicate sets of 3D points for multiple vertices.
 * Similarly, the term normal is used to indicate a 3D vector (nx, ny, nz) in space
 * representing the direction of a single vertex. The term normals (plural) is
 * used to indicate sets of 3D vectors for multiple vertices.
 * The term texCoord is used to indicate a single pair of 2D texture
 * coordinates (u, v) for a single vertex, while the term texCoords (plural) is used
 * to indicate sets of texture coordinates for multiple vertices.
 * Lastly, the term face is used to indicate 3 sets of interleaving points,
 * normals (optional, depending on the associated VertexFormat)
 * and texture coordinates that together represent the geometric topology of a
 * single triangle, while the term faces (plural) is used to indicate sets of
 * triangles (each represent by a face).
 * &lt;p&gt;
 * For example, the faces with {@code VertexFormat.POINT_TEXCOORD} that represent
 * a single textured rectangle, using 2 triangles, have the following data order: [
 * &lt;p&gt;
 * p0, t0, p1, t1, p3, t3,  // First triangle of a textured rectangle
 * &lt;p&gt;
 * p1, t1, p2, t2, p3, t3   // Second triangle of a textured rectangle
 * &lt;p&gt;
 * ]
 * &lt;p&gt;
 * whereas the faces with {@code VertexFormat.POINT_NORMAL_TEXCOORD} that represent
 * a single textured rectangle, using 2 triangles, have the following data order: [
 * &lt;p&gt;
 * p0, n0, t0, p1, n1, t1, p3, n3, t3,  // First triangle of a textured rectangle
 * &lt;p&gt;
 * p1, n1, t1, p2, n2, t2, p3, n3, t3   // Second triangle of a textured rectangle
 * &lt;p&gt;
 * ]
 * &lt;p&gt;
 * where p0, p1, p2 and p3 are indices into the points array, n0, n1, n2 and n3
 * are indices into the normals array, and t0, t1, t2 and t3 are indices into
 * the texCoords array.
 *
 * &lt;p&gt;
 * A triangle has a front and back face. The winding order of a triangle's vertices
 * determines which side is the front face. JavaFX chooses the counter-clockwise
 * (or right-hand rule) winding order as the front face. By default, only the
 * front face of a triangle is rendered. See {@code CullFace} for more
 * information.
 *
 * &lt;p&gt;
 * The length of {@code points}, {@code normals}, and {@code texCoords} must be
 * divisible by 3, 3, and 2 respectively. The length of {@code faces} must be
 * divisible by 6 if it is of {@code VertexFormat.POINT_TEXCOORD} else it must
 * be divisible by 9 if it is of {@code VertexFormat.POINT_NORMAL_TEXCOORD}.
 * The values in the faces array must be within the range of the number of vertices
 * in the points array (0 to points.length / 3 - 1) for the point indices, within
 * the range of the number of vertices in the normals array
 * (0 to normals.length / 3 - 1) for the normal indices, and within the range of
 * the number of the vertices in the texCoords array (0 to texCoords.length / 2 - 1)
 * for the texture coordinate indices.
 *
 * &lt;p&gt; A warning will be recorded to the logger and the mesh will not be rendered
 * (and will have an empty bounds) if any of the array lengths are invalid
 * or if any of the values in the faces array are out of range.
 *
 * @since JavaFX 8.0
 */
public class TriangleMesh extends Mesh {
    static {
        TriangleMeshHelper.setTriangleMeshAccessor(new TriangleMeshHelper.TriangleMeshAccessor() {
            @Override
            public boolean doComputeIntersects(Mesh mesh, PickRay pickRay,
                    PickResultChooser pickResult, Node candidate, CullFace cullFace,
                    boolean reportFace) {
                return ((TriangleMesh) mesh).doComputeIntersects(pickRay,
                        pickResult, candidate, cullFace, reportFace);
            }
        });
    }

    private final ObservableFloatArray points = FXCollections.observableFloatArray();
    private final ObservableFloatArray normals = FXCollections.observableFloatArray();
    private final ObservableFloatArray texCoords = FXCollections.observableFloatArray();
    private final ObservableFaceArray faces = new ObservableFaceArrayImpl();
    private final ObservableIntegerArray faceSmoothingGroups = FXCollections.observableIntegerArray();

    private final Listener pointsSyncer = new Listener(points);
    private final Listener normalsSyncer = new Listener(normals);
    private final Listener texCoordsSyncer = new Listener(texCoords);
    private final Listener facesSyncer = new Listener(faces);
    private final Listener faceSmoothingGroupsSyncer = new Listener(faceSmoothingGroups);
    private final boolean isPredefinedShape;
    private boolean isValidDirty = true;
    private boolean isPointsValid, isNormalsValid, isTexCoordsValid, isFacesValid, isFaceSmoothingGroupValid;
    private int refCount = 1;

    private BaseBounds cachedBounds;

    /**
     * Creates a new instance of {@code TriangleMesh} class with the default
     * {@code VertexFormat.POINT_TEXCOORD} format type.
     */
    public TriangleMesh() {
        this(false);
        TriangleMeshHelper.initHelper(this);
    }

    /**
     * Creates a new instance of {@code TriangleMesh} class with the specified
     * {@code VertexFormat}.
     *
     * @param vertexFormat specifies the vertex format type.
     *
     * @since JavaFX 8u40
     */
    public TriangleMesh(VertexFormat vertexFormat) {
        this(false);
        this.setVertexFormat(vertexFormat);
        TriangleMeshHelper.initHelper(this);
    }

    TriangleMesh(boolean isPredefinedShape) {
        this.isPredefinedShape = isPredefinedShape;
        if (isPredefinedShape) {
            isPointsValid = true;
            isNormalsValid = true;
            isTexCoordsValid = true;
            isFacesValid = true;
            isFaceSmoothingGroupValid = true;
        } else {
            isPointsValid = false;
            isNormalsValid = false;
            isTexCoordsValid = false;
            isFacesValid = false;
            isFaceSmoothingGroupValid = false;
        }
        TriangleMeshHelper.initHelper(this);
    }

    /**
     * Specifies the vertex format of this {@code TriangleMesh}, one of
     * {@code VertexFormat.POINT_TEXCOORD} or {@code VertexFormat.POINT_NORMAL_TEXCOORD}.
     *
     * @defaultValue VertexFormat.POINT_TEXCOORD
     *
     * @since JavaFX 8u40
     */
    private ObjectProperty&lt;VertexFormat&gt; vertexFormat;

    public final void setVertexFormat(VertexFormat value) {
        vertexFormatProperty().set(value);
    }

    public final VertexFormat getVertexFormat() {
        return vertexFormat == null ? VertexFormat.POINT_TEXCOORD : vertexFormat.get();
    }

    public final ObjectProperty&lt;VertexFormat&gt; vertexFormatProperty() {
        if (vertexFormat == null) {
            vertexFormat = new SimpleObjectProperty&lt;VertexFormat&gt;(TriangleMesh.this, &quot;vertexFormat&quot;) {

                @Override
                protected void invalidated() {
                    setDirty(true);
                    // Need to mark faces and faceSmoothingGroups dirty too.
                    facesSyncer.setDirty(true);
                    faceSmoothingGroupsSyncer.setDirty(true);
                }
            };
        }
        return vertexFormat;
    }

    /**
     * Returns the number of elements that represents a point.
     *
     * @return number of elements
     */
    public final int getPointElementSize() {
        return getVertexFormat().getPointElementSize();
    }

    /**
     * Returns the number of elements that represents a normal.
     *
     * @return number of elements
     *
     * @since JavaFX 8u40
     */
    public final int getNormalElementSize() {
        return getVertexFormat().getNormalElementSize();
    }

    /**
     * Returns the number of elements that represents a texture coordinates.
     *
     * @return number of elements
     */
    public final int getTexCoordElementSize() {
        return getVertexFormat().getTexCoordElementSize();
    }

    /**
     * Returns the number of elements that represents a face.
     *
     * @return number of elements
     */
    public final int getFaceElementSize() {
        return getVertexFormat().getVertexIndexSize() * 3;
    }

    /**
     * Gets the {@code points} array of this {@code TriangleMesh}.
     *
     * @return {@code points} array where each point is
     * represented by 3 float values x, y and z, in that order.
     */
    public final ObservableFloatArray getPoints() {
        return points;
    }

    /**
     * Gets the {@code normals} array of this {@code TriangleMesh}.
     *
     * @return {@code normals} array where each normal is
     * represented by 3 float values nx, ny and nz, in that order.
     *
     * @since JavaFX 8u40
     */
    public final ObservableFloatArray getNormals() {
        return normals;
    }

    /**
     * Gets the  {@code texCoords} array of this {@code TriangleMesh}.
     * The coordinates are proportional, so texture's top-left corner
     * is at [0, 0] and bottom-right corner is at [1, 1].
     *
     * @return {@code texCoord} array where each texture coordinate is represented
     * by 2 float values: u and v, in that order.
     */
    public final ObservableFloatArray getTexCoords() {
        return texCoords;
    }

    /**
     * Gets the {@code faces} array, indices into the {@code points},
     * {@code normals} (optional, if it is a {@code VertexFormat.POINT_NORMAL_TEXCOORD}
     * mesh) and {@code texCoords} arrays, of this  {@code TriangleMesh}. All
     * indices are in terms of elements in to the points, normals or texCoords
     * arrays not individual floats.
     *
     * @return {@code faces} array where each face is of
     * 3 * {@code VertexFormat.getVertexIndexSize()} integers.
     */
    public final ObservableFaceArray getFaces() {
        return faces;
    }

    /**
     * Gets the {@code faceSmoothingGroups} array of this {@code TriangleMesh}.
     * Smoothing affects how a mesh is rendered but it does not effect its
     * geometry. The face smoothing group value is used to control the smoothing
     * between adjacent faces.
     *
     * &lt;p&gt;
     * {@literal The face smoothing group value is represented by an array of bits and up to
     * 32 unique groups is possible; (1 &lt;&lt; 0) to (1 &lt;&lt; 31). The face smoothing
     * group value can range from 0 (no smoothing group) to all 32 groups. A face
     * can belong to zero or more smoothing groups. A face is a member of group
     * N if bit N is set, for example, groups |= (1 &lt;&lt; N). A value of 0 implies
     * no smoothing group or hard edges.}
     * Smoothing is applied when adjacent pair of faces shared a smoothing group.
     * Otherwise the faces are rendered with a hard edge between them.
     *
     * &lt;p&gt; An empty faceSmoothingGroups implies all faces in this mesh have a
     * smoothing group value of 1.
     *
     * &lt;p&gt; If faceSmoothingGroups is not empty, its size must
     * be equal to number of faces.
     *
     * &lt;p&gt; This faceSmoothingGroups has no effect on its {@code TriangleMesh} if
     * it is of {@code VertexFormat.POINT_NORMAL_TEXCOORD} format.
     * @return the {@code faceSmoothingGroups} array of this {@code TriangleMesh}
     */
    public final ObservableIntegerArray getFaceSmoothingGroups() {
        return faceSmoothingGroups;
    }

    @Override void setDirty(boolean value) {
        super.setDirty(value);
        if (!value) { // false
            pointsSyncer.setDirty(false);
            normalsSyncer.setDirty(false);
            texCoordsSyncer.setDirty(false);
            facesSyncer.setDirty(false);
            faceSmoothingGroupsSyncer.setDirty(false);
        }
    }

    int getRefCount() {
        return refCount;
    }

    synchronized void incRef() {
        this.refCount += 1;
    }

    synchronized void decRef() {
        this.refCount -= 1;
    }

    private NGTriangleMesh peer;

    /* The peer node created by the graphics Toolkit/Pipeline implementation */
    NGTriangleMesh getPGTriangleMesh() {
        if (peer == null) {
            peer = new NGTriangleMesh();
        }
        return peer;
    }

    @Override
    NGTriangleMesh getPGMesh() {
        return getPGTriangleMesh();
    }

    private boolean validatePoints() {
        if (points.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        if ((points.size() % getVertexFormat().getPointElementSize()) != 0) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;points.size() has &quot;
                    + &quot;to be divisible by getPointElementSize(). It is to&quot;
                    + &quot; store multiple x, y, and z coordinates of this mesh&quot;);
            return false;
        }
        return true;
    }

    private boolean validateNormals() {
        // Only validate normals if vertex format has normal component
        if (getVertexFormat() != VertexFormat.POINT_NORMAL_TEXCOORD) return true;

        if (normals.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        if ((normals.size() % getVertexFormat().getNormalElementSize()) != 0) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;normals.size() has &quot;
                    + &quot;to be divisible by getNormalElementSize(). It is to&quot;
                    + &quot; store multiple nx, ny, and nz coordinates of this mesh&quot;);
            return false;
        }
        return true;
    }

    private boolean validateTexCoords() {
        if (texCoords.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        if ((texCoords.size() % getVertexFormat().getTexCoordElementSize()) != 0) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;texCoords.size() &quot;
                    + &quot;has to be divisible by getTexCoordElementSize().&quot;
                    + &quot; It is to store multiple u and v texture coordinates&quot;
                    + &quot; of this mesh&quot;);
            return false;
        }
        return true;
    }

    private boolean validateFaces() {
        if (faces.size() == 0) { // Valid but meaningless for picking or rendering.
            return false;
        }

        String logname = TriangleMesh.class.getName();
        if ((faces.size() % getFaceElementSize()) != 0) {
            PlatformLogger.getLogger(logname).warning(&quot;faces.size() has &quot;
                    + &quot;to be divisible by getFaceElementSize().&quot;);
            return false;
        }

        if (getVertexFormat() == VertexFormat.POINT_TEXCOORD) {
            int nVerts = points.size() / getVertexFormat().getPointElementSize();
            int nTVerts = texCoords.size() / getVertexFormat().getTexCoordElementSize();
            for (int i = 0; i &lt; faces.size(); i++) {
                if (i % 2 == 0 &amp;&amp; (faces.get(i) &gt;= nVerts || faces.get(i) &lt; 0)
                        || (i % 2 != 0 &amp;&amp; (faces.get(i) &gt;= nTVerts || faces.get(i) &lt; 0))) {
                    PlatformLogger.getLogger(logname).warning(&quot;The values in the &quot;
                            + &quot;faces array must be within the range of the number &quot;
                            + &quot;of vertices in the points array (0 to points.length / 3 - 1) &quot;
                            + &quot;for the point indices and within the range of the &quot;
                            + &quot;number of the vertices in the texCoords array (0 to &quot;
                            + &quot;texCoords.length / 2 - 1) for the texture coordinate indices.&quot;);
                    return false;
                }
            }
        } else if (getVertexFormat() == VertexFormat.POINT_NORMAL_TEXCOORD) {
            int nVerts = points.size() / getVertexFormat().getPointElementSize();
            int nNVerts =  normals.size() / getVertexFormat().getNormalElementSize();
            int nTVerts = texCoords.size() / getVertexFormat().getTexCoordElementSize();
            for (int i = 0; i &lt; faces.size(); i+=3) {
                if ((faces.get(i) &gt;= nVerts || faces.get(i) &lt; 0)
                        || (faces.get(i + 1) &gt;= nNVerts || faces.get(i + 1) &lt; 0)
                        || (faces.get(i + 2) &gt;= nTVerts || faces.get(i + 2) &lt; 0)) {
                    PlatformLogger.getLogger(logname).warning(&quot;The values in the &quot;
                            + &quot;faces array must be within the range of the number &quot;
                            + &quot;of vertices in the points array (0 to points.length / 3 - 1) &quot;
                            + &quot;for the point indices, and within the range of the &quot;
                            + &quot;number of the vertices in the normals array (0 to &quot;
                            + &quot;normals.length / 3 - 1) for the normals indices, and &quot;
                            + &quot;number of the vertices in the texCoords array (0 to &quot;
                            + &quot;texCoords.length / 2 - 1) for the texture coordinate indices.&quot;);
                    return false;
                }
            }
        } else {
            PlatformLogger.getLogger(logname).warning(&quot;Unsupported VertexFormat: &quot; + getVertexFormat().toString());
            return false;
        }
        return true;
    }

    private boolean validateFaceSmoothingGroups() {
        if (faceSmoothingGroups.size() != 0
                &amp;&amp; faceSmoothingGroups.size() != (faces.size() / getFaceElementSize())) {
            String logname = TriangleMesh.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;faceSmoothingGroups.size()&quot;
                    + &quot; has to equal to number of faces.&quot;);
            return false;
        }
        return true;
    }

    private boolean validate() {
        if (isPredefinedShape) {
            return true;
        }

        if (isValidDirty) {
            if (pointsSyncer.dirtyInFull) {
                isPointsValid = validatePoints();
            }
            if (normalsSyncer.dirtyInFull) {
                isNormalsValid = validateNormals();
            }
            if (texCoordsSyncer.dirtyInFull) {
                isTexCoordsValid = validateTexCoords();
            }
            if (facesSyncer.dirty || pointsSyncer.dirtyInFull
                    || normalsSyncer.dirtyInFull || texCoordsSyncer.dirtyInFull) {
                isFacesValid = isPointsValid &amp;&amp; isNormalsValid
                        &amp;&amp; isTexCoordsValid &amp;&amp; validateFaces();
            }
            if (faceSmoothingGroupsSyncer.dirtyInFull || facesSyncer.dirtyInFull) {
                isFaceSmoothingGroupValid = isFacesValid &amp;&amp; validateFaceSmoothingGroups();
            }
            isValidDirty = false;
        }
        return isPointsValid &amp;&amp; isNormalsValid &amp;&amp; isTexCoordsValid
                &amp;&amp; isFaceSmoothingGroupValid &amp;&amp; isFacesValid;
    }

    @Override
    void updatePG() {
        if (!isDirty()) {
            return;
        }

        final NGTriangleMesh pgTriMesh = getPGTriangleMesh();
        if (validate()) {
            pgTriMesh.setUserDefinedNormals(getVertexFormat() == VertexFormat.POINT_NORMAL_TEXCOORD);
            pgTriMesh.syncPoints(pointsSyncer);
            pgTriMesh.syncNormals(normalsSyncer);
            pgTriMesh.syncTexCoords(texCoordsSyncer);
            pgTriMesh.syncFaces(facesSyncer);
            pgTriMesh.syncFaceSmoothingGroups(faceSmoothingGroupsSyncer);
        } else {
            pgTriMesh.setUserDefinedNormals(false);
            pgTriMesh.syncPoints(null);
            pgTriMesh.syncNormals(null);
            pgTriMesh.syncTexCoords(null);
            pgTriMesh.syncFaces(null);
            pgTriMesh.syncFaceSmoothingGroups(null);
        }
        setDirty(false);
    }

    @Override
    BaseBounds computeBounds(BaseBounds bounds) {
        if (isDirty() || cachedBounds == null) {
            cachedBounds = new BoxBounds();
            if (validate()) {
                final int len = points.size();
                final int pointElementSize = getVertexFormat().getPointElementSize();
                for (int i = 0; i &lt; len; i += pointElementSize) {
                    cachedBounds.add(points.get(i), points.get(i + 1), points.get(i + 2));
                }
            }
        }
        return bounds.deriveWithNewBounds(cachedBounds);
    }

    /**
     * Computes the centroid of the given triangle
     * @param v0x x coord of first vertex of the triangle
     * @param v0y y coord of first vertex of the triangle
     * @param v0z z coord of first vertex of the triangle
     * @param v1x x coord of second vertex of the triangle
     * @param v1y y coord of second vertex of the triangle
     * @param v1z z coord of second vertex of the triangle
     * @param v2x x coord of third vertex of the triangle
     * @param v2y y coord of third vertex of the triangle
     * @param v2z z coord of third vertex of the triangle
     * @return the triangle centroid
     */
    private Point3D computeCentroid(
            double v0x, double v0y, double v0z,
            double v1x, double v1y, double v1z,
            double v2x, double v2y, double v2z) {

//        Point3D center = v1.midpoint(v2);
//        Point3D vec = center.subtract(v0);
//        return v0.add(new Point3D(vec.getX() / 3.0, vec.getY() / 3.0, vec.getZ() / 3.0));

        return new Point3D(
            v0x + (v2x + (v1x - v2x) / 2.0 - v0x) / 3.0,
            v0y + (v2y + (v1y - v2y) / 2.0 - v0y) / 3.0,
            v0z + (v2z + (v1z - v2z) / 2.0 - v0z) / 3.0);
    }

    /**
     * Computes the centroid of the given triangle
     * @param v0 vertex of the triangle
     * @param v1 vertex of the triangle
     * @param v2 vertex of the triangle
     * @return the triangle centroid
     */
    private Point2D computeCentroid(Point2D v0, Point2D v1, Point2D v2) {
        Point2D center = v1.midpoint(v2);

        Point2D vec = center.subtract(v0);
        return v0.add(new Point2D(vec.getX() / 3.0, vec.getY() / 3.0));
    }

    /**
     * Computes intersection of a pick ray and a single triangle face.
     *
     * It takes pickRay, origin and dir. The latter two can be of course obtained
     * from the pickRay, but we need them to be converted to Point3D and don't
     * want to do that for all faces. Therefore the conversion is done just once
     * and passed to the method for all the faces.
     *
     * @param pickRay pick ray
     * @param origin pick ray's origin
     * @param dir pick ray's direction
     * @param faceIndex index of the face to test
     * @param cullFace cull face of the Node (and thus the tested face)
     * @param candidate the owner node (for the possible placement to the result)
     * @param reportFace whether or not to report he hit face
     * @param result the pick result to be updated if a closer intersection is found
     * @return true if the pick ray intersects with the face (regardless of whether
     *              the result has been updated)
     */
    private boolean computeIntersectsFace(
            PickRay pickRay, Vec3d origin, Vec3d dir, int faceIndex,
            CullFace cullFace, Node candidate, boolean reportFace, PickResultChooser result) {//, BoxBounds rayBounds) {

        // This computation was naturally done by Point3D and its operations,
        // but it needs a lot of points and there is often a lot of triangles
        // so it is vital for performance to use only primitive variables
        // and do the computing manually.

        int vertexIndexSize = getVertexFormat().getVertexIndexSize();
        int pointElementSize = getVertexFormat().getPointElementSize();
        final int v0Idx = faces.get(faceIndex) * pointElementSize;
        final int v1Idx = faces.get(faceIndex + vertexIndexSize) * pointElementSize;
        final int v2Idx = faces.get(faceIndex + (2 * vertexIndexSize)) * pointElementSize;

        final float v0x = points.get(v0Idx);
        final float v0y = points.get(v0Idx + 1);
        final float v0z = points.get(v0Idx + 2);
        final float v1x = points.get(v1Idx);
        final float v1y = points.get(v1Idx + 1);
        final float v1z = points.get(v1Idx + 2);
        final float v2x = points.get(v2Idx);
        final float v2y = points.get(v2Idx + 1);
        final float v2z = points.get(v2Idx + 2);

        // e1 = v1.subtract(v0)
        final float e1x = v1x - v0x;
        final float e1y = v1y - v0y;
        final float e1z = v1z - v0z;
        // e2 = v2.subtract(v0)
        final float e2x = v2x - v0x;
        final float e2y = v2y - v0y;
        final float e2z = v2z - v0z;

        // h = dir.crossProduct(e2)
        final double hx = dir.y * e2z - dir.z * e2y;
        final double hy = dir.z * e2x - dir.x * e2z;
        final double hz = dir.x * e2y - dir.y * e2x;

        // a = e1.dotProduct(h)
        final double a = e1x * hx + e1y * hy + e1z * hz;
        if (a == 0.0) {
            return false;
        }
        final double f = 1.0 / a;

        // s = origin.subtract(v0)
        final double sx = origin.x - v0x;
        final double sy = origin.y - v0y;
        final double sz = origin.z - v0z;

        // u = f * (s.dotProduct(h))
        final double u = f * (sx * hx + sy * hy + sz * hz);

        if (u &lt; 0.0 || u &gt; 1.0) {
            return false;
        }

        // q = s.crossProduct(e1)
        final double qx = sy * e1z - sz * e1y;
        final double qy = sz * e1x - sx * e1z;
        final double qz = sx * e1y - sy * e1x;

        // v = f * dir.dotProduct(q)
        double v = f * (dir.x * qx + dir.y * qy + dir.z * qz);

        if (v &lt; 0.0 || u + v &gt; 1.0) {
            return false;
        }

        // t = f * e2.dotProduct(q)
        final double t = f * (e2x * qx + e2y * qy + e2z * qz);

        if (t &gt;= pickRay.getNearClip() &amp;&amp; t &lt;= pickRay.getFarClip()) {
            // This branch is entered only for hit triangles (not so often),
            // so we can get smoothly back to the nice code using Point3Ds.

            if (cullFace != CullFace.NONE) {
                // normal = e1.crossProduct(e2)
                final Point3D normal = new Point3D(
                    e1y * e2z - e1z * e2y,
                    e1z * e2x - e1x * e2z,
                    e1x * e2y - e1y * e2x);

                final double nangle = normal.angle(
                        new Point3D(-dir.x, -dir.y, -dir.z));
                if ((nangle &gt;= 90 || cullFace != CullFace.BACK) &amp;&amp;
                        (nangle &lt;= 90 || cullFace != CullFace.FRONT)) {
                    // hit culled face
                    return false;
                }
            }

            if (Double.isInfinite(t) || Double.isNaN(t)) {
                // we've got a nonsense pick ray or triangle
                return false;
            }

            if (result == null || !result.isCloser(t)) {
                // it intersects, but we are not interested in the result
                // or we already have a better (closer) result
                // so we can omit the point and texture computation
                return true;
            }

            Point3D point = PickResultChooser.computePoint(pickRay, t);

            // Now compute texture mapping. First rotate the triangle
            // so that we can compute in 2D

            // centroid = computeCentroid(v0, v1, v2);
            final Point3D centroid = computeCentroid(
                    v0x, v0y, v0z,
                    v1x, v1y, v1z,
                    v2x, v2y, v2z);

            // cv0 = v0.subtract(centroid)
            final Point3D cv0 = new Point3D(
                    v0x - centroid.getX(),
                    v0y - centroid.getY(),
                    v0z - centroid.getZ());
            // cv1 = v1.subtract(centroid)
            final Point3D cv1 = new Point3D(
                    v1x - centroid.getX(),
                    v1y - centroid.getY(),
                    v1z - centroid.getZ());
            // cv2 = v2.subtract(centroid)
            final Point3D cv2 = new Point3D(
                    v2x - centroid.getX(),
                    v2y - centroid.getY(),
                    v2z - centroid.getZ());

            final Point3D ce1 = cv1.subtract(cv0);
            final Point3D ce2 = cv2.subtract(cv0);
            Point3D n = ce1.crossProduct(ce2);
<A NAME="30"></A>            if (n.getZ() &lt; 0) {
                n = new Point3D(-n.getX(), -n.getY(), -n.getZ());
            }
            final Point3D ax = <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#30',2,'match42-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>n.crossProduct(Rotate.Z_AXIS);
            final double angle = Math.atan2(ax.magnitude(), n.dotProduct(Rotate.Z_AXIS));

            Rotate r = new Rotate(Math.toDegrees(angle), ax);
            final Point3D crv0 = r.transform(cv0)</B></FONT>;
            final Point3D crv1 = r.transform(cv1);
            final Point3D crv2 = r.transform(cv2);
            final Point3D rPoint = r.transform(point.subtract(centroid));

            final Point2D flatV0 = new Point2D(crv0.getX(), crv0.getY());
            final Point2D flatV1 = new Point2D(crv1.getX(), crv1.getY());
            final Point2D flatV2 = new Point2D(crv2.getX(), crv2.getY());
            final Point2D flatPoint = new Point2D(rPoint.getX(), rPoint.getY());

            // Obtain the texture triangle
            int texCoordElementSize = getVertexFormat().getTexCoordElementSize();
            int texCoordOffset = getVertexFormat().getTexCoordIndexOffset();
            final int t0Idx = faces.get(faceIndex + texCoordOffset) * texCoordElementSize;
            final int t1Idx = faces.get(faceIndex + vertexIndexSize + texCoordOffset) * texCoordElementSize;
            final int t2Idx = faces.get(faceIndex + (vertexIndexSize * 2) + texCoordOffset) * texCoordElementSize;

            final Point2D u0 = new Point2D(texCoords.get(t0Idx), texCoords.get(t0Idx + 1));
            final Point2D u1 = new Point2D(texCoords.get(t1Idx), texCoords.get(t1Idx + 1));
            final Point2D u2 = new Point2D(texCoords.get(t2Idx), texCoords.get(t2Idx + 1));

            final Point2D txCentroid = computeCentroid(u0, u1, u2);

            final Point2D cu0 = u0.subtract(txCentroid);
            final Point2D cu1 = u1.subtract(txCentroid);
            final Point2D cu2 = u2.subtract(txCentroid);

            // Find the transform between the two triangles

            final Affine src = new Affine(
                    flatV0.getX(), flatV1.getX(), flatV2.getX(),
                    flatV0.getY(), flatV1.getY(), flatV2.getY());
            final Affine trg = new Affine(
                    cu0.getX(), cu1.getX(), cu2.getX(),
                    cu0.getY(), cu1.getY(), cu2.getY());

            Point2D txCoords = null;

            try {
                src.invert();
                trg.append(src);
                txCoords = txCentroid.add(trg.transform(flatPoint));
            } catch (NonInvertibleTransformException e) {
                // Can't compute texture mapping, probably the coordinates
                // don't make sense. Ignore it and return null tex coords.
            }

            result.offer(candidate, t,
                    reportFace ? faceIndex / getFaceElementSize() : PickResult.FACE_UNDEFINED,
                    point, txCoords);
            return true;
        }

        return false;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult,
            Node candidate, CullFace cullFace, boolean reportFace) {

        boolean found = false;
        if (validate()) {
            final int size = faces.size();

            final Vec3d o = pickRay.getOriginNoClone();

            final Vec3d d = pickRay.getDirectionNoClone();

            for (int i = 0; i &lt; size; i += getFaceElementSize()) {
                if (computeIntersectsFace(pickRay, o, d, i, cullFace, candidate,
                        reportFace, pickResult)) {
                    found = true;
                }
            }
        }
        return found;
    }

    private class Listener&lt;T extends ObservableArray&lt;T&gt;&gt; implements ArrayChangeListener&lt;T&gt;, FloatArraySyncer, IntegerArraySyncer {

        protected final T array;
        protected boolean dirty = true;
        /**
         * Array was replaced
         * @return true if array was replaced; false otherwise
         */
        protected boolean dirtyInFull = true;
        protected int dirtyRangeFrom;
        protected int dirtyRangeLength;

        public Listener(T array) {
            this.array = array;
            array.addListener(this);
        }

        /**
         * Adds a dirty range
         * @param from index of the first modified element
         * @param length length of the modified range
         */
        protected final void addDirtyRange(int from, int length) {
            if (length &gt; 0 &amp;&amp; !dirtyInFull) {
                markDirty();
                if (dirtyRangeLength == 0) {
                    dirtyRangeFrom = from;
                    dirtyRangeLength = length;
                } else {
                    int fromIndex = Math.min(dirtyRangeFrom, from);
                    int toIndex = Math.max(dirtyRangeFrom + dirtyRangeLength, from + length);
                    dirtyRangeFrom = fromIndex;
                    dirtyRangeLength = toIndex - fromIndex;
                }
            }
        }

        protected void markDirty() {
            dirty = true;
            TriangleMesh.this.setDirty(true);
        }

        @Override
        public void onChanged(T observableArray, boolean sizeChanged, int from, int to) {
            if (sizeChanged) {
                setDirty(true);
            } else {
                addDirtyRange(from, to - from);
            }
            isValidDirty = true;
        }

        /**
         * @param dirty if true, the whole collection is marked as dirty;
         * if false, the whole collection is marked as not-dirty
         */
        public final void setDirty(boolean dirty) {
            this.dirtyInFull = dirty;
            if (dirty) {
                markDirty();
                dirtyRangeFrom = 0;
                dirtyRangeLength = array.size();
            } else {
                this.dirty = false;
                dirtyRangeFrom = dirtyRangeLength = 0;
            }
        }

        @Override
        public float[] syncTo(float[] array, int[] fromAndLengthIndices) {
            assert ((fromAndLengthIndices != null) &amp;&amp; (fromAndLengthIndices.length == 2));
            ObservableFloatArray floatArray = (ObservableFloatArray) this.array;
            if (dirtyInFull || array == null || array.length != floatArray.size()) {
                // Always allocate a new array when size changes
                fromAndLengthIndices[0] = 0;
                fromAndLengthIndices[1] = floatArray.size();
                return floatArray.toArray(null);
            }
            fromAndLengthIndices[0] = dirtyRangeFrom;
            fromAndLengthIndices[1] = dirtyRangeLength;
            floatArray.copyTo(dirtyRangeFrom, array, dirtyRangeFrom, dirtyRangeLength);
            return array;
        }

        @Override
        public int[] syncTo(int[] array, int[] fromAndLengthIndices) {
            assert ((fromAndLengthIndices != null) &amp;&amp; (fromAndLengthIndices.length == 2));
            ObservableIntegerArray intArray = (ObservableIntegerArray) this.array;
            if (dirtyInFull || array == null || array.length != intArray.size()) {
                fromAndLengthIndices[0] = 0;
                fromAndLengthIndices[1] = intArray.size();
                // Always allocate a new array when size changes
                return intArray.toArray(null);
            }
            fromAndLengthIndices[0] = dirtyRangeFrom;
            fromAndLengthIndices[1] = dirtyRangeLength;
            intArray.copyTo(dirtyRangeFrom, array, dirtyRangeFrom, dirtyRangeLength);
            return array;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Rotate.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.geometry.Point3D;

import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.geometry.Point2D;


/**
 * This class represents an {@code Affine} object that rotates coordinates
 * around an anchor point. This operation is equivalent to translating the
 * coordinates so that the anchor point is at the origin (S1), then rotating them
 * about the new origin (S2), and finally translating so that the
 * intermediate origin is restored to the coordinates of the original
 * anchor point (S3).
 * &lt;p&gt;
 * The matrix representing the rotation transformation around an axis {@code (x,y,z)}
 * by an angle {@code t} is as follows:
 * &lt;pre&gt;
 *              [   cos(t)   -sin(t)   0   x-x*cos(t)+y*sin(t)   ]
 *              [   sin(t)    cos(t)   0   y-x*sin(t)-y*cos(t)   ]
 *              [     0         0      1           z             ]
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For example, to rotate a text 30 degrees around the Z-axis at
 * anchor point of (50,30):
 * &lt;pre&gt;{@code
 * Text text = new Text(&quot;This is a test&quot;);
 * text.setX(10);
 * text.setY(50);
 * text.setFont(new Font(20));
 *
 * text.getTransforms().add(new Rotate(30, 50, 30));
 * }&lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */

public class Rotate extends Transform {

    /**
     * Specifies the X-axis as the axis of rotation.
     */
    public static final Point3D X_AXIS = new Point3D(1,0,0);

    /**
     * Specifies the Y-axis as the axis of rotation.
     */
    public static final Point3D Y_AXIS = new Point3D(0,1,0);

    /**
     * Specifies the Z-axis as the axis of rotation.
     */
    public static final Point3D Z_AXIS = new Point3D(0,0,1);

    /**
     * Avoids lot of repeated computation.
     * @see #MatrixCache
     */
    private MatrixCache cache;

    /**
     * Avoids lot of repeated computation.
     * @see #MatrixCache
     */
    private MatrixCache inverseCache;

    /**
     * Creates a default Rotate transform (identity).
     */
    public Rotate() {
    }

    /**
     * Creates a two-dimensional Rotate transform.
     * The pivot point is set to (0,0)
     * @param angle the angle of rotation measured in degrees
     */
    public Rotate(double angle) {
        setAngle(angle);
    }

    /**
     * Creates a three-dimensional Rotate transform.
     * The pivot point is set to (0,0,0)
     * @param angle the angle of rotation measured in degrees
     * @param axis the axis of rotation
     */
    public Rotate(double angle, Point3D axis) {
        setAngle(angle);
        setAxis(axis);
    }

    /**
     * Creates a two-dimensional Rotate transform with pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     */
    public Rotate(double angle, double pivotX, double pivotY) {
        setAngle(angle);
        setPivotX(pivotX);
        setPivotY(pivotY);
    }

    /**
     * Creates a simple Rotate transform with three-dimensional pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     */
    public Rotate(double angle, double pivotX, double pivotY, double pivotZ) {
        this(angle, pivotX, pivotY);
        setPivotZ(pivotZ);
    }

    /**
     * Creates a three-dimensional Rotate transform with pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the axis of rotation
     */
    public Rotate(double angle, double pivotX, double pivotY, double pivotZ, Point3D axis) {
        this(angle, pivotX, pivotY);
        setPivotZ(pivotZ);
        setAxis(axis);
    }

    /**
     * Defines the angle of rotation measured in degrees.
     */
    private DoubleProperty angle;


    public final void setAngle(double value) {
        angleProperty().set(value);
    }

    public final double getAngle() {
        return angle == null ? 0.0 : angle.get();
    }

    public final DoubleProperty angleProperty() {
        if (angle == null) {
            angle = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;angle&quot;;
                }
            };
        }
        return angle;
    }

    /**
     * Defines the X coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotX;


    public final void setPivotX(double value) {
        pivotXProperty().set(value);
    }

    public final double getPivotX() {
        return pivotX == null ? 0.0 : pivotX.get();
    }

    public final DoubleProperty pivotXProperty() {
        if (pivotX == null) {
            pivotX = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotX&quot;;
                }
            };
        }
        return pivotX;
    }

    /**
     * Defines the Y coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotY;


    public final void setPivotY(double value) {
        pivotYProperty().set(value);
    }

    public final double getPivotY() {
        return pivotY == null ? 0.0 : pivotY.get();
    }

    public final DoubleProperty pivotYProperty() {
        if (pivotY == null) {
            pivotY = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotY&quot;;
                }
            };
        }
        return pivotY;
    }

    /**
     * Defines the Z coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotZ;


    public final void setPivotZ(double value) {
        pivotZProperty().set(value);
    }

    public final double getPivotZ() {
        return pivotZ == null ? 0.0 : pivotZ.get();
    }

    public final DoubleProperty pivotZProperty() {
        if (pivotZ == null) {
            pivotZ = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotZ&quot;;
                }
            };
        }
        return pivotZ;
    }

    /**
     * Defines the axis of rotation at the pivot point.
     */
    private ObjectProperty&lt;Point3D&gt; axis;


    public final void setAxis(Point3D value) {
        axisProperty().set(value);
    }

    public final Point3D getAxis() {
        return axis == null ? Z_AXIS : axis.get();
    }

    public final ObjectProperty&lt;Point3D&gt; axisProperty() {
        if (axis == null) {
            axis = new ObjectPropertyBase&lt;Point3D&gt;(Z_AXIS) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;axis&quot;;
                }
            };
        }
        return axis;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    public double getMxx() {
        updateCache();
        return cache.mxx;
    }

    @Override
    public double getMxy() {
        updateCache();
        return cache.mxy;
    }

    @Override
    public double getMxz() {
        updateCache();
        return cache.mxz;
    }

    @Override
    public double getTx() {
        updateCache();
        return cache.tx;
    }

    @Override
    public double getMyx() {
        updateCache();
        return cache.myx;
    }

    @Override
    public double getMyy() {
        updateCache();
        return cache.myy;
    }

    @Override
    public double getMyz() {
        updateCache();
        return cache.myz;
    }

    @Override
    public double getTy() {
        updateCache();
        return cache.ty;
    }

    @Override
    public double getMzx() {
        updateCache();
        return cache.mzx;
    }

    @Override
    public double getMzy() {
        updateCache();
        return cache.mzy;
    }

    @Override
    public double getMzz() {
        updateCache();
        return cache.mzz;
    }

    @Override
    public double getTz() {
        updateCache();
        return cache.tz;
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        final Point3D a = getAxis();
        return (a.getX() == 0.0 &amp;&amp; a.getY() == 0.0) || getAngle() == 0;
    }

    @Override
    boolean computeIsIdentity() {
        if (getAngle() == 0.0) {
            return true;
        }

        final Point3D a = getAxis();
        return a.getX() == 0 &amp;&amp; a.getY() == 0 &amp;&amp; a.getZ() == 0.0;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    void fill2DArray(double[] array) {
        updateCache();
        array[0] = cache.mxx;
        array[1] = cache.mxy;
        array[2] = cache.tx;
        array[3] = cache.myx;
        array[4] = cache.myy;
        array[5] = cache.ty;
    }

    @Override
    void fill3DArray(double[] array) {
        updateCache();
        array[0] = cache.mxx;
        array[1] = cache.mxy;
        array[2] = cache.mxz;
        array[3] = cache.tx;
        array[4] = cache.myx;
        array[5] = cache.myy;
        array[6] = cache.myz;
        array[7] = cache.ty;
        array[8] = cache.mzx;
        array[9] = cache.mzy;
        array[10] = cache.mzz;
        array[11] = cache.tz;
        return;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        if (transform instanceof Rotate) {
            Rotate r = (Rotate) transform;
            final double px = getPivotX();
            final double py = getPivotY();
            final double pz = getPivotZ();

            if ((r.getAxis() == getAxis() ||
                        r.getAxis().normalize().equals(getAxis().normalize())) &amp;&amp;
                    px == r.getPivotX() &amp;&amp;
                    py == r.getPivotY() &amp;&amp;
                    pz == r.getPivotZ()) {
                return new Rotate(getAngle() + r.getAngle(), px, py, pz, getAxis());
            }
        }

        if (transform instanceof Affine) {
            Affine a = (Affine) transform.clone();
            a.prepend(this);
            return a;
        }

        return super.createConcatenation(transform);
    }

    @Override
    public Transform createInverse() throws NonInvertibleTransformException {
        return new Rotate(-getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    @Override
    public Rotate clone() {
        return new Rotate(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        updateCache();

        return new Point2D(
            cache.mxx * x + cache.mxy * y + cache.tx,
            cache.myx * x + cache.myy * y + cache.ty);
    }

    @Override
    public Point3D transform(double x, double y, double z) {
        updateCache();

        return new Point3D(
            cache.mxx * x + cache.mxy * y + cache.mxz * z + cache.tx,
            cache.myx * x + cache.myy * y + cache.myz * z + cache.ty,
            cache.mzx * x + cache.mzy * y + cache.mzz * z + cache.tz);
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        updateCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = cache.mxx * x + cache.mxy * y + cache.tx;
            dstPts[dstOff++] = cache.myx * x + cache.myy * y + cache.ty;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        updateCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = cache.mxx * x + cache.mxy * y + cache.mxz * z + cache.tx;
            dstPts[dstOff++] = cache.myx * x + cache.myy * y + cache.myz * z + cache.ty;
            dstPts[dstOff++] = cache.mzx * x + cache.mzy * y + cache.mzz * z + cache.tz;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateCache();

        return new Point2D(
            cache.mxx * x + cache.mxy * y,
            cache.myx * x + cache.myy * y);
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        updateCache();

        return new Point3D(
            cache.mxx * x + cache.mxy * y + cache.mxz * z,
            cache.myx * x + cache.myy * y + cache.myz * z,
            cache.mzx * x + cache.mzy * y + cache.mzz * z);
    }

    @Override
    public Point2D inverseTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateInverseCache();

        return new Point2D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.tx,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.ty);
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z) {
        updateInverseCache();

        return new Point3D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.mxz * z
                + inverseCache.tx,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.myz * z
                + inverseCache.ty,
            inverseCache.mzx * x + inverseCache.mzy * y + inverseCache.mzz * z
                + inverseCache.tz);
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        updateInverseCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = inverseCache.mxx * x + inverseCache.mxy * y
                    + inverseCache.tx;
            dstPts[dstOff++] = inverseCache.myx * x + inverseCache.myy * y
                    + inverseCache.ty;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        updateInverseCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = inverseCache.mxx * x + inverseCache.mxy * y
                    + inverseCache.mxz * z + inverseCache.tx;
            dstPts[dstOff++] = inverseCache.myx * x + inverseCache.myy * y
                    + inverseCache.myz * z + inverseCache.ty;
            dstPts[dstOff++] = inverseCache.mzx * x + inverseCache.mzy * y
                    + inverseCache.mzz * z + inverseCache.tz;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateInverseCache();

        return new Point2D(
            inverseCache.mxx * x + inverseCache.mxy * y,
            inverseCache.myx * x + inverseCache.myy * y);
    }

    @Override
<A NAME="34"></A>    public Point3D inverseDeltaTransform(double x, double y, double z) {
        updateInverseCache();

        return <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#34',2,'match42-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Point3D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.mxz * z,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.myz * z,
            inverseCache.mzx * x + inverseCache.mzy * y + inverseCache.mzz * z);
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Rotate} object.
     * @return a string representation of this {@code Rotate} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Rotate [&quot;);

        sb.append(&quot;angle=&quot;).append(getAngle</B></FONT>());
        sb.append(&quot;, pivotX=&quot;).append(getPivotX());
        sb.append(&quot;, pivotY=&quot;).append(getPivotY());
        sb.append(&quot;, pivotZ=&quot;).append(getPivotZ());
        sb.append(&quot;, axis=&quot;).append(getAxis());

        return sb.append(&quot;]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    @Override
    void apply(final Affine3D trans) {
        double localPivotX = getPivotX();
        double localPivotY = getPivotY();
        double localPivotZ = getPivotZ();
        double localAngle = getAngle();

        if (localPivotX != 0 || localPivotY != 0 || localPivotZ != 0) {
            trans.translate(localPivotX, localPivotY, localPivotZ);
            trans.rotate(Math.toRadians(localAngle),
                         getAxis().getX(),getAxis().getY(), getAxis().getZ());
            trans.translate(-localPivotX, -localPivotY, -localPivotZ);
        } else {
            trans.rotate(Math.toRadians(localAngle),
                         getAxis().getX(), getAxis().getY(), getAxis().getZ());
        }
    }

    @Override
    BaseTransform derive(BaseTransform trans) {
        if (isIdentity()) {
            return trans;
        }

        double localPivotX = getPivotX();
        double localPivotY = getPivotY();
        double localPivotZ = getPivotZ();
        double localAngle = getAngle();

        if (localPivotX != 0 || localPivotY != 0 || localPivotZ != 0) {
            trans = trans.deriveWithTranslation(localPivotX, localPivotY, localPivotZ);
            trans = trans.deriveWithRotation(Math.toRadians(localAngle),
                         getAxis().getX(),getAxis().getY(), getAxis().getZ());
            return trans.deriveWithTranslation(-localPivotX, -localPivotY, -localPivotZ);
        } else {
            return trans.deriveWithRotation(Math.toRadians(localAngle),
                         getAxis().getX(), getAxis().getY(), getAxis().getZ());
        }
    }

    @Override
    void validate() {
        getAxis();
        getAngle();
        getPivotX();
        getPivotY();
        getPivotZ();
    }

    @Override
    protected void transformChanged() {
        if (cache != null) {
            cache.invalidate();
        }
        super.transformChanged();
    }

    @Override
    void appendTo(Affine a) {
        a.appendRotation(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    @Override
    void prependTo(Affine a) {
        a.prependRotation(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    /**
     * Updates the matrix cache
     */
    private void updateCache() {
        if (cache == null) {
            cache = new MatrixCache();
        }

        if (!cache.valid) {
            cache.update(getAngle(), getAxis(),
                    getPivotX(), getPivotY(), getPivotZ());
        }
    }

    /**
     * Updates the inverse matrix cache
     */
    private void updateInverseCache() {
        if (inverseCache == null) {
            inverseCache = new MatrixCache();
        }

        if (!inverseCache.valid) {
            inverseCache.update(-getAngle(), getAxis(),
                    getPivotX(), getPivotY(), getPivotZ());
        }
    }

    /**
     * Matrix cache. Computing single transformation matrix elements for
     * a general rotation is quite expensive. Also each of those partial
     * computations need some common operations to be made (compute sin
     * and cos, normalize axis). Therefore with the direct element computations
     * if all the getters for the elements are called to get the matrix,
     * the result is slow.
     *
     * If a matrix element is asked for, we can reasonably anticipate that
     * some other elements will be asked for as well. So when any element
     * needs to be computed, we compute the entire matrix, cache it,
     * and use the stored values until the transform changes.
     */
    private static class MatrixCache {
        boolean valid = false;
        boolean is3D = false;

        double mxx, mxy, mxz, tx,
               myx, myy, myz, ty,
               mzx, mzy, mzz, tz;

        public MatrixCache() {
            // to have the 3D part right when using 2D-only
            mzz = 1.0;
        }

        public void update(double angle, Point3D axis,
                double px, double py, double pz) {

            final double rads = Math.toRadians(angle);
            final double sin = Math.sin(rads);
            final double cos = Math.cos(rads);

            if (axis == Z_AXIS ||
                    (axis.getX() == 0.0 &amp;&amp;
                     axis.getY() == 0.0 &amp;&amp;
                     axis.getZ() &gt; 0.0)) {
                // 2D case
                mxx = cos;
                mxy = -sin;
                tx = px * (1 - cos) + py * sin;
                myx = sin;
                myy = cos;
                ty = py * (1 - cos) - px * sin;

                if (is3D) {
                    // Was 3D, needs to set the 3D values
                    mxz = 0.0;
                    myz = 0.0;
                    mzx = 0.0;
                    mzy = 0.0;
                    mzz = 1.0;
                    tz = 0.0;
                    is3D = false;
                }
                valid = true;
                return;
            }
            // 3D case
            is3D = true;

            double axisX, axisY, axisZ;

            if (axis == X_AXIS || axis == Y_AXIS || axis == Z_AXIS) {
                axisX = axis.getX();
                axisY = axis.getY();
                axisZ = axis.getZ();
            } else {
                // normalize
                final double mag = Math.sqrt(axis.getX() * axis.getX() +
                        axis.getY() * axis.getY() + axis.getZ() * axis.getZ());

                if (mag == 0.0) {
                    mxx = 1; mxy = 0; mxz = 0; tx = 0;
                    myx = 0; myy = 1; myz = 0; ty = 0;
                    mzx = 0; mzy = 0; mzz = 1; tz = 0;
                    valid = true;
                    return;
                } else {
                    axisX = axis.getX() / mag;
                    axisY = axis.getY() / mag;
                    axisZ = axis.getZ() / mag;
                }
            }

            mxx = cos + axisX * axisX * (1 - cos);
            mxy = axisX * axisY * (1 - cos) - axisZ * sin;
            mxz = axisX * axisZ * (1 - cos) + axisY * sin;
            tx = px * (1 - mxx) - py * mxy - pz * mxz;

            myx = axisY * axisX * (1 - cos) + axisZ * sin;
            myy = cos + axisY * axisY * (1 - cos);
            myz = axisY * axisZ * (1 - cos) - axisX * sin;
            ty = py * (1 - myy) - px * myx - pz * myz;

            mzx = axisZ * axisX * (1 - cos) - axisY * sin;
            mzy = axisZ * axisY * (1 - cos) + axisX * sin;
            mzz = cos + axisZ * axisZ * (1 - cos);
            tz = pz * (1 - mzz) - px * mzx - py * mzy;

            valid = true;
        }

        public void invalidate() {
            valid = false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/stage/Stage.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.stage;

import java.util.ArrayList;
import java.util.List;

import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCombination;

import com.sun.javafx.collections.VetoableListDecorator;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.stage.StageHelper;
import com.sun.javafx.stage.StagePeerListener;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.Toolkit;
import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;

/**
 * The JavaFX {@code Stage} class is the top level JavaFX container.
 * The primary Stage is constructed by the platform. Additional Stage
 * objects may be constructed by the application.
 *
 * &lt;p&gt;
 * Stage objects must be constructed and modified on the
 * JavaFX Application Thread.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Many of the {@code Stage} properties are read only because they can
 * be changed externally by the underlying platform and therefore must
 * not be bindable.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Style&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * A stage has one of the following styles:
 * &lt;ul&gt;
 * &lt;li&gt;{@link StageStyle#DECORATED} - a stage with a solid white background and
 * platform decorations.&lt;/li&gt;
 * &lt;li&gt;{@link StageStyle#UNDECORATED} - a stage with a solid white background
 * and no decorations.&lt;/li&gt;
 * &lt;li&gt;{@link StageStyle#TRANSPARENT} - a stage with a transparent background
 * and no decorations.&lt;/li&gt;
 * &lt;li&gt;{@link StageStyle#UTILITY} - a stage with a solid white background and
 * minimal platform decorations.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;The style must be initialized before the stage is made visible.&lt;/p&gt;
 * &lt;p&gt;On some platforms decorations might not be available. For example, on
 * some mobile or embedded devices. In these cases a request for a DECORATED or
 * UTILITY window will be accepted, but no decorations will be shown. &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Owner&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * A stage can optionally have an owner Window.
 * When a window is a stage's owner, it is said to be the parent of that stage.
 * &lt;p&gt;
 * Owned Stages are tied to the parent Window.
 * An owned stage will always be on top of its parent window.
 * When a parent window is closed or iconified, then all owned windows will be affected as well.
 * Owned Stages cannot be independantly iconified.
 * &lt;p&gt;
 * The owner must be initialized before the stage is made visible.
 *
 * &lt;p&gt;&lt;b&gt;Modality&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * A stage has one of the following modalities:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Modality#NONE} - a stage that does not block any other window.&lt;/li&gt;
 * &lt;li&gt;{@link Modality#WINDOW_MODAL} - a stage that blocks input events from
 * being delivered to all windows from its owner (parent) to its root.
 * Its root is the closest ancestor window without an owner.&lt;/li&gt;
 * &lt;li&gt;{@link Modality#APPLICATION_MODAL} - a stage that blocks input events from
 * being delivered to all windows from the same application, except for those
 * from its child hierarchy.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;When a window is blocked by a modal stage its Z-order relative to its ancestors
 * is preserved, and it receives no input events and no window activation events,
 * but continues to animate and render normally.
 * Note that showing a modal stage does not necessarily block the caller. The
 * {@link #show} method returns immediately regardless of the modality of the stage.
 * Use the {@link #showAndWait} method if you need to block the caller until
 * the modal stage is hidden (closed).
 * The modality must be initialized before the stage is made visible.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
 *
 *
&lt;pre&gt;&lt;code&gt;
import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class HelloWorld extends Application {

    {@literal @Override} public void start(Stage stage) {
        Text text = new Text(10, 40, &quot;Hello World!&quot;);
        text.setFont(new Font(40));
        Scene scene = new Scene(new Group(text));

        stage.setTitle(&quot;Welcome to JavaFX!&quot;);
        stage.setScene(scene);
        stage.sizeToScene();
        stage.show();
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}

 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;produces the following on Windows:&lt;/p&gt;
 * &lt;p&gt;&lt;img src=&quot;doc-files/Stage-win.png&quot; alt=&quot;A visual rendering
     * of a JavaFX Stage on Windows&quot;&gt;&lt;/p&gt;
 *
 * &lt;p&gt;produces the following on Mac OSX:&lt;/p&gt;
 * &lt;p&gt;&lt;img src=&quot;doc-files/Stage-mac.png&quot; alt=&quot;A visual rendering
     * of a JavaFX Stage on Mac OSX&quot;&gt;&lt;/p&gt;
 *
 * &lt;p&gt;produces the following on Linux:&lt;/p&gt;
 * &lt;p&gt;&lt;img src=&quot;doc-files/Stage-linux.png&quot; alt=&quot;A visual rendering
     * of a JavaFX Stage on Linux&quot;&gt;&lt;/p&gt;
 * @since JavaFX 2.0
 */
public class Stage extends Window {

    private boolean inNestedEventLoop = false;

    static {
        StageHelper.setStageAccessor(new StageHelper.StageAccessor() {
            @Override public void doVisibleChanging(Window window, boolean visible) {
                ((Stage) window).doVisibleChanging(visible);
            }

            @Override public void doVisibleChanged(Window window, boolean visible) {
                ((Stage) window).doVisibleChanged(visible);
            }

            @Override public void initSecurityDialog(Stage stage, boolean securityDialog) {
                stage.initSecurityDialog(securityDialog);
            }

            @Override
            public void setPrimary(Stage stage, boolean primary) {
                stage.setPrimary(primary);
            }

            @Override
            public void setImportant(Stage stage, boolean important) {
                stage.setImportant(important);
            }
        });
    }

    private static final StagePeerListener.StageAccessor STAGE_ACCESSOR = new StagePeerListener.StageAccessor() {

        @Override
        public void setIconified(Stage stage, boolean iconified) {
            stage.iconifiedPropertyImpl().set(iconified);
        }

        @Override
        public void setMaximized(Stage stage, boolean maximized) {
            stage.maximizedPropertyImpl().set(maximized);
        }

        @Override
        public void setResizable(Stage stage, boolean resizable) {
            ((ResizableProperty)stage.resizableProperty()).setNoInvalidate(resizable);
        }

        @Override
        public void setFullScreen(Stage stage, boolean fs) {
            stage.fullScreenPropertyImpl().set(fs);
        }

        @Override
        public void setAlwaysOnTop(Stage stage, boolean aot) {
            stage.alwaysOnTopPropertyImpl().set(aot);
        }
    };

    /**
     * Creates a new instance of decorated {@code Stage}.
     *
     * @throws IllegalStateException if this constructor is called on a thread
     * other than the JavaFX Application Thread.
     */
    public Stage() {
        this(StageStyle.DECORATED);
    }

    /**
     * Creates a new instance of {@code Stage}.
     *
     * @param style The style of the {@code Stage}
     *
     * @throws IllegalStateException if this constructor is called on a thread
     * other than the JavaFX Application Thread.
     */
    public Stage(@NamedArg(value=&quot;style&quot;, defaultValue=&quot;DECORATED&quot;) StageStyle style) {
        super();

        Toolkit.getToolkit().checkFxUserThread();

        // Set the style
        initStyle(style);
        StageHelper.initHelper(this);
    }

    /**
     * Specify the scene to be used on this stage.
     */
    @Override final public void setScene(Scene value) {
        Toolkit.getToolkit().checkFxUserThread();
        super.setScene(value);
    }

    /**
     * {@inheritDoc}
     */
    @Override public final void show() {
        super.show();
    }

    private boolean primary = false;

    ////////////////////////////////////////////////////////////////////

    // Flag indicating that this stage is being used to show a security dialog
    private boolean securityDialog = false;

    /**
     * Sets a flag indicating that this stage is used for a security dialog and
     * must always be on top. If set, this will cause the window to be always
     * on top, regardless of the setting of the alwaysOnTop property, and
     * whether or not permissions are granted when the dialog is shown.
     * NOTE: this flag must be set prior to showing the stage the first time.
     *
     * @param securityDialog flag indicating that this Stage is being used to
     * show a security dialog that should be always-on-top
     *
     * @throws IllegalStateException if this property is set after the stage
     * has ever been made visible.
     *
     * @defaultValue false
     */
    final void initSecurityDialog(boolean securityDialog) {
        if (hasBeenVisible) {
            throw new IllegalStateException(&quot;Cannot set securityDialog once stage has been set visible&quot;);
        }

        this.securityDialog = securityDialog;
    }

    /**
     * Returns the state of the securityDialog flag.
     *
     * @return a flag indicating whether or not this is a security dialog
     */
    final boolean isSecurityDialog() {
        return securityDialog;
    }

    /*
     * Sets this stage to be the primary stage.
     */
    void setPrimary(boolean primary) {
        this.primary = primary;
    }

    /*
     * Returns whether this stage is the primary stage.
     *
     * @return true if this stage is the primary stage for the application.
     */
    boolean isPrimary() {
        return primary;
    }

    private boolean important = true;

    /*
     * Sets a flag indicating whether this stage is an &quot;important&quot; window for
     * the purpose of determining whether the application is idle and should
     * exit. The application is considered finished when the last important
     * window is closed.
     */
    void setImportant(boolean important) {
        this.important = important;
    }

    private boolean isImportant() {
        return important;
    }

    /**
     * Shows this stage and waits for it to be hidden (closed) before returning
     * to the caller. This method temporarily blocks processing of the current
     * event, and starts a nested event loop to handle other events.
     * This method must be called on the FX Application thread.
     * &lt;p&gt;
     * A Stage is hidden (closed) by one of the following means:
     * &lt;ul&gt;
     * &lt;li&gt;the application calls the {@link #hide} or {@link #close} method on
     * this stage&lt;/li&gt;
     * &lt;li&gt;this stage has a non-null owner window, and its owner is closed&lt;/li&gt;
     * &lt;li&gt;the user closes the window via the window system (for example,
     * by pressing the close button in the window decoration)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * After the Stage is hidden, and the application has returned from the
     * event handler to the event loop, the nested event loop terminates
     * and this method returns to the caller.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For example, consider the following sequence of operations for different
     * event handlers, assumed to execute in the order shown below:
     * &lt;pre&gt;void evtHander1(...) {
     *     stage1.showAndWait();
     *     doSomethingAfterStage1Closed(...)
     * }
     *
     * void evtHander2(...) {
     *     stage1.hide();
     *     doSomethingElseHere(...)
     * }&lt;/pre&gt;
     * evtHandler1 will block at the call to showAndWait. It will resume execution
     * after stage1 is hidden and the current event handler, in this case evtHandler2,
     * returns to the event loop. This means that doSomethingElseHere will
     * execute before doSomethingAfterStage1Closed.
     *
     * &lt;p&gt;
     * More than one stage may be shown with showAndWait. Each call
     * will start a new nested event loop. The stages may be hidden in any order,
     * but a particular nested event loop (and thus the showAndWait method
     * for the associated stage) will only terminate after all inner event loops
     * have also terminated.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For example, consider the following sequence of operations for different
     * event handlers, assumed to execute in the order shown below:
     * &lt;pre&gt;void evtHander1() {
     *     stage1.showAndWait();
     *     doSomethingAfterStage1Closed(...)
     * }
     *
     * void evtHander2() {
     *     stage2.showAndWait();
     *     doSomethingAfterStage2Closed(...)
     * }
     *
     * void evtHander3() {
     *     stage1.hide();
     *     doSomethingElseHere(...)
     * }
     *
     * void evtHander4() {
     *     stage2.hide();
     *     doSomethingElseHereToo(...)
     * }&lt;/pre&gt;
     * evtHandler1 will block at the call to stage1.showAndWait, starting up
     * a nested event loop just like in the previous example. evtHandler2 will
     * then block at the call to stage2.showAndWait, starting up another (inner)
     * nested event loop. The first call to stage1.showAndWait will resume execution
     * after stage1 is hidden, but only after the inner nested event loop started
     * by stage2.showAndWait has terminated. This means that the call to
     * stage1.showAndWait won't return until after evtHandler2 has returned.
     * The order of execution is: stage1.showAndWait, stage2.showAndWait,
     * stage1.hide, doSomethingElseHere, stage2.hide, doSomethingElseHereToo,
     * doSomethingAfterStage2Closed, doSomethingAfterStage1Closed.
     *
     * &lt;p&gt;
     * This method must not be called on the primary stage or on a stage that
     * is already visible.
     * Additionally, it must either be called from an input event handler or
     * from the run method of a Runnable passed to
     * {@link javafx.application.Platform#runLater Platform.runLater}.
     * It must not be called during animation or layout processing.
     * &lt;/p&gt;
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     * @throws IllegalStateException if this method is called during
     *     animation or layout processing.
     * @throws IllegalStateException if this method is called on the
     *     primary stage.
     * @throws IllegalStateException if this stage is already showing.
     * @since JavaFX 2.2
     */
    public void showAndWait() {

        Toolkit.getToolkit().checkFxUserThread();

        if (isPrimary()) {
            throw new IllegalStateException(&quot;Cannot call this method on primary stage&quot;);
        }

        if (isShowing()) {
            throw new IllegalStateException(&quot;Stage already visible&quot;);
        }

        if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
            throw new IllegalStateException(&quot;showAndWait is not allowed during animation or layout processing&quot;);
        }

        // TODO: file a new bug; the following assertion can fail if this
        // method is called from an event handler that is listening to a
        // WindowEvent.WINDOW_HIDING event.
        assert !inNestedEventLoop;

        show();
        inNestedEventLoop = true;
        Toolkit.getToolkit().enterNestedEventLoop(this);
    }

    private StageStyle style; // default is set in constructor

    /**
     * Specifies the style for this stage. This must be done prior to making
     * the stage visible. The style is one of: StageStyle.DECORATED,
     * StageStyle.UNDECORATED, StageStyle.TRANSPARENT, or StageStyle.UTILITY.
     *
     * @param style the style for this stage.
     *
     * @throws IllegalStateException if this property is set after the stage
     * has ever been made visible.
     *
     * @defaultValue StageStyle.DECORATED
     */
    public final void initStyle(StageStyle style) {
        if (hasBeenVisible) {
            throw new IllegalStateException(&quot;Cannot set style once stage has been set visible&quot;);
        }
        this.style = style;
    }

    /**
     * Retrieves the style attribute for this stage.
     *
     * @return the stage style.
     */
    public final StageStyle getStyle() {
        return style;
    }

    private Modality modality = Modality.NONE;

    /**
     * Specifies the modality for this stage. This must be done prior to making
     * the stage visible. The modality is one of: Modality.NONE,
     * Modality.WINDOW_MODAL, or Modality.APPLICATION_MODAL.
     *
     * @param modality the modality for this stage.
     *
     * @throws IllegalStateException if this property is set after the stage
     * has ever been made visible.
     *
     * @throws IllegalStateException if this stage is the primary stage.
     *
     * @defaultValue Modality.NONE
     */
    public final void initModality(Modality modality) {
        if (hasBeenVisible) {
            throw new IllegalStateException(&quot;Cannot set modality once stage has been set visible&quot;);
        }

        if (isPrimary()) {
            throw new IllegalStateException(&quot;Cannot set modality for the primary stage&quot;);
        }

        this.modality = modality;
    }

    /**
     * Retrieves the modality attribute for this stage.
     *
     * @return the modality.
     */
    public final Modality getModality() {
        return modality;
    }

    private Window owner = null;

    /**
     * Specifies the owner Window for this stage, or null for a top-level,
     * unowned stage. This must be done prior to making the stage visible.
     *
     * @param owner the owner for this stage.
     *
     * @throws IllegalStateException if this property is set after the stage
     * has ever been made visible.
     *
     * @throws IllegalStateException if this stage is the primary stage.
     *
     * @defaultValue null
     */
    public final void initOwner(Window owner) {
        if (hasBeenVisible) {
            throw new IllegalStateException(&quot;Cannot set owner once stage has been set visible&quot;);
        }

        if (isPrimary()) {
            throw new IllegalStateException(&quot;Cannot set owner for the primary stage&quot;);
        }

        this.owner = owner;

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            SceneHelper.parentEffectiveOrientationInvalidated(sceneValue);
        }
    }

    /**
     * Retrieves the owner Window for this stage, or null for an unowned stage.
     *
     * @return the owner Window.
     */
    public final Window getOwner() {
        return owner;
    }

    /**
     * Specifies whether this {@code Stage} should be a full-screen,
     * undecorated window.
     * &lt;p&gt;
     * The implementation of full-screen mode is platform and profile-dependent.
     * &lt;/p&gt;
     * &lt;p&gt;
     * When set to {@code true}, the {@code Stage} will attempt to enter
     * full-screen mode when visible. Set to {@code false} to return {@code Stage}
     * to windowed mode.
     * An {@link IllegalStateException} is thrown if this property is set
     * on a thread other than the JavaFX Application Thread.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The full-screen mode will be exited (and the {@code fullScreen} attribute
     * will be set to {@code false}) if the full-screen
     * {@code Stage} loses focus or if another {@code Stage} enters
     * full-screen mode on the same {@link Screen}. Note that a {@code Stage}
     * in full-screen mode can become invisible without losing its
     * full-screen status and will again enter full-screen mode when the
     * {@code Stage} becomes visible.
     * &lt;/p&gt;
     * If the platform supports multiple screens an application can control
     * which {@code Screen} the Stage will enter full-screen mode on by
     * setting its position to be within the bounds of that {@code Screen}
     * prior to entering full-screen mode.
     * &lt;p&gt;
     * However once in full-screen mode, {@code Stage}'s {@code x}, {@code y},
     * {@code width}, and {@code height} variables will continue to represent
     * the non-full-screen position and size of the window; the same for
     * {@code iconified}, {@code resizable}, {@code style}, and {@code
     * opacity}. If changes are made to any of these attributes while in
     * full-screen mode, upon exiting full-screen mode the {@code Stage} will
     * assume those attributes.
     * &lt;/p&gt;
     * &lt;p&gt;
     * In case that more {@code Stage} modes are set simultaneously their order
     * of importance is {@code iconified}, fullScreen, {@code maximized} (from
     * strongest to weakest).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The property is read only because it can be changed externally
     * by the underlying platform and therefore must not be bindable.
     * &lt;/p&gt;
     *
     * The user can unconditionally exit full-screen mode
     * at any time by pressing {@code ESC}.
     * &lt;p&gt;
     * If a security manager is present, the application must have the
     * {@link javafx.util.FXPermission} &quot;unrestrictedFullScreen&quot; in order
     * to enter full-screen mode with no restrictions. Applications without
     * permission will have the following restrictions:
     * &lt;/p&gt;
     * &lt;ul&gt;
     *  &lt;li&gt;Applications can only enter full-screen mode in response
     *   to user input. More specifically, entering is allowed from mouse
     *   ({@code Node.mousePressed/mouseReleased/mouseClicked}) or keyboard
     *   ({@code Node.keyPressed/keyReleased/keyTyped}) event handlers. It is
     *   not allowed to enter full-screen mode in response to {@code ESC}
     *   key. Attempting to enter full-screen mode from any other context will
     *   be ignored.
     *   &lt;p&gt;
     *   If {@code Stage} was constructed as full-screen but not visible
     *   it will enter full-screen mode upon becoming visible, with the same
     *   limitations to when this is allowed to happen as when setting
     *   {@code fullScreen} to {@code true}.
     *   &lt;/p&gt;
     *  &lt;/li&gt;
     *  &lt;li&gt; If the application was allowed to enter full-screen mode
     *   it will have limited keyboard input. It will only receive KEY_PRESSED
     *   and KEY_RELEASED events from the following keys:
     *   {@code UP, DOWN, LEFT, RIGHT, SPACE, TAB, PAGE_UP, PAGE_DOWN, HOME, END, ENTER}
     *  &lt;/li&gt;
     * &lt;/ul&gt;
     * @defaultValue false
<A NAME="69"></A>     */
    private ReadOnlyBooleanWrapper fullScreen;

    public final void setFullScreen(<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#69',2,'match42-top.html#69',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>boolean value) {
        Toolkit.getToolkit().checkFxUserThread();
        fullScreenPropertyImpl().set(value);
        if (getPeer() != null)
            getPeer().setFullScreen(value);
    }</B></FONT>

    public final boolean isFullScreen() {
        return fullScreen == null ? false : fullScreen.get();
    }

    public final ReadOnlyBooleanProperty fullScreenProperty() {
        return fullScreenPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper fullScreenPropertyImpl () {
        if (fullScreen == null) {
            fullScreen = new ReadOnlyBooleanWrapper(Stage.this, &quot;fullScreen&quot;);
        }
        return fullScreen;
    }

    /**
     * Defines the icon images to be used in the window decorations and when
     * minimized. The images should be different sizes of the same image and
     * the best size will be chosen, eg. 16x16, 32,32.
     *
     * @defaultValue empty
     */
    private ObservableList&lt;Image&gt; icons = new VetoableListDecorator&lt;Image&gt;(new TrackableObservableList&lt;Image&gt;() {
        @Override protected void onChanged(Change&lt;Image&gt; c) {
            List&lt;Object&gt; platformImages = new ArrayList&lt;Object&gt;();
            for (Image icon : icons) {
                platformImages.add(Toolkit.getImageAccessor().getPlatformImage(icon));
            }
            if (getPeer() != null) {
                getPeer().setIcons(platformImages);
            }
        }
    }) {
        @Override protected void onProposedChange(
                final List&lt;Image&gt; toBeAddedIcons, int[] indices) {
            for (Image icon : toBeAddedIcons) {
                if (icon == null) {
                    throw new NullPointerException(&quot;icon can not be null.&quot;);
                }
            }
        }
    };

    /**
     * Gets the icon images to be used in the window decorations and when
     * minimized. The images should be different sizes of the same image and
     * the best size will be chosen, eg. 16x16, 32,32.
     * @return An observable list of icons of this window
     */
    public final ObservableList&lt;Image&gt; getIcons() {
        return icons;
    }

    /**
     * Defines the title of the {@code Stage}.
     *
     * @defaultValue empty string
     */
    private StringProperty title;

    public final void setTitle(String value) {
        titleProperty().set(value);
    }

    public final String getTitle() {
        return title == null ? null : title.get();
    }

    public final StringProperty titleProperty() {
        if (title == null) {
            title = new StringPropertyBase() {

                @Override
                protected void invalidated() {
                    if (getPeer() != null) {
                        getPeer().setTitle(get());
                    }
                }

                @Override
                public Object getBean() {
                    return Stage.this;
                }

                @Override
                public String getName() {
                    return &quot;title&quot;;
                }
            };
        }
        return title;
    }

    /**
     * Defines whether the {@code Stage} is iconified or not.
     * &lt;p&gt;
     * In case that more {@code Stage} modes are set simultaneously their order
     * of importance is iconified} {@code fullScreen}, {@code maximized} (from
     * strongest to weakest).
     * &lt;/p&gt;
     * &lt;p&gt;
     * On some mobile and embedded platforms setting this property to true will
     * hide the {@code Stage} but not show an icon for it.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The property is read only because it can be changed externally
     * by the underlying platform and therefore must not be bindable.
     * &lt;/p&gt;
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper iconified;

    public final void setIconified(boolean value) {
        iconifiedPropertyImpl().set(value);
        if (getPeer() != null)
            getPeer().setIconified(value);
    }

    public final boolean isIconified() {
        return iconified == null ? false : iconified.get();
    }

    public final ReadOnlyBooleanProperty iconifiedProperty() {
        return iconifiedPropertyImpl().getReadOnlyProperty();
    }

    private final ReadOnlyBooleanWrapper iconifiedPropertyImpl() {
        if (iconified == null) {
            iconified = new ReadOnlyBooleanWrapper(Stage.this, &quot;iconified&quot;);
        }
        return iconified;
    }

    /**
     * Defines whether the {@code Stage} is maximized or not.
     * &lt;p&gt;
     * In case that more {@code Stage} modes are set simultaneously their order
     * of importance is {@code iconified}, {@code fullScreen}, maximized (from
     * strongest to weakest).
     * &lt;/p&gt;
     * &lt;p&gt;
     * The property is read only because it can be changed externally
     * by the underlying platform and therefore must not be bindable.
     * &lt;/p&gt;
     *
     * @defaultValue false
     * @since JavaFX 8.0
     */
    private ReadOnlyBooleanWrapper maximized;

    public final void setMaximized(boolean value) {
        maximizedPropertyImpl().set(value);
        if (getPeer() != null) {
            getPeer().setMaximized(value);
        }
    }

    public final boolean isMaximized() {
        return maximized == null ? false : maximized.get();
    }

    public final ReadOnlyBooleanProperty maximizedProperty() {
        return maximizedPropertyImpl().getReadOnlyProperty();
    }

    private final ReadOnlyBooleanWrapper maximizedPropertyImpl() {
        if (maximized == null) {
            maximized = new ReadOnlyBooleanWrapper(Stage.this, &quot;maximized&quot;);
        }
        return maximized;
    }

    /**
     * Defines whether this {@code Stage} is kept on top of other windows.
     * &lt;p&gt;
     * If some other window is already always-on-top then the
     * relative order between these windows is unspecified (depends on
     * platform).
     * &lt;/p&gt;
     * &lt;p&gt;
     * If a security manager is present, the application must have the
     * {@link javafx.util.FXPermission} &quot;setWindowAlwaysOnTop&quot; in order for
     * this property to have any effect. If the application does not have
     * permission, attempting to set this property will be ignored
     * and the property value will be restored to {@code false}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The property is read only because it can be changed externally
     * by the underlying platform and therefore must not be bindable.
     * &lt;/p&gt;
     *
     * @defaultValue false
     * @since JavaFX 8u20
     */
    private ReadOnlyBooleanWrapper alwaysOnTop;

    public final void setAlwaysOnTop(boolean value) {
        alwaysOnTopPropertyImpl().set(value);
        if (getPeer() != null) {
            getPeer().setAlwaysOnTop(value);
        }
    }

    public final boolean isAlwaysOnTop() {
        return alwaysOnTop == null ? false : alwaysOnTop.get();
    }

    public final ReadOnlyBooleanProperty alwaysOnTopProperty() {
        return alwaysOnTopPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper alwaysOnTopPropertyImpl() {
        if (alwaysOnTop == null) {
            alwaysOnTop = new ReadOnlyBooleanWrapper(Stage.this, &quot;alwaysOnTop&quot;);
        }
        return alwaysOnTop;
    }

    /**
     * Defines whether the {@code Stage} is resizable or not by the user.
     * Programatically you may still change the size of the Stage. This is
     * a hint which allows the implementation to optionally make the Stage
     * resizable by the user.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; Since 8.0 the property cannot be bound and will throw
     * {@code RuntimeException} on an attempt to do so. This is because
     * the setting of resizable is asynchronous on some systems or generally
     * might be set by the system / window manager.
     * &lt;br&gt;
     * Bidirectional binds are still allowed, as they don't block setting of the
     * property by the system.
     *
     * @defaultValue true
     */
    private BooleanProperty resizable;

    public final void setResizable(boolean value) {
        resizableProperty().set(value);
    }

    public final boolean isResizable() {
        return resizable == null ? true : resizable.get();
    }

    public final BooleanProperty resizableProperty() {
        if (resizable == null) {
            resizable = new ResizableProperty();
        }
        return resizable;
    }

    //We cannot return ReadOnlyProperty in resizable, as this would be
    // backward incompatible. All we can do is to create this custom property
    // implementation that disallows binds
    private class ResizableProperty extends SimpleBooleanProperty {
        private boolean noInvalidate;

        public ResizableProperty() {
            super(Stage.this, &quot;resizable&quot;, true);
        }

        void setNoInvalidate(boolean value) {
            noInvalidate = true;
            set(value);
            noInvalidate = false;
        }

        @Override
        protected void invalidated() {
            if (noInvalidate) {
                return;
            }
            if (getPeer() != null) {
                applyBounds();
                getPeer().setResizable(get());
            }
        }

        @Override
        public void bind(ObservableValue&lt;? extends Boolean&gt; rawObservable) {
            throw new RuntimeException(&quot;Resizable property cannot be bound&quot;);
        }

    }

    /**
     * Defines the minimum width of this {@code Stage}.
     *
     * @defaultValue 0
     * @since JavaFX 2.1
     */
    private DoubleProperty minWidth;

    public final void setMinWidth(double value) {
        minWidthProperty().set(value);
    }

    public final double getMinWidth() {
        return minWidth == null ? 0 : minWidth.get();
    }

    public final DoubleProperty minWidthProperty() {
        if (minWidth == null) {
            minWidth = new DoublePropertyBase(0) {

                @Override
                protected void invalidated() {
                    if (getPeer() != null) {
                        getPeer().setMinimumSize((int) Math.ceil(get()),
                                (int) Math.ceil(getMinHeight()));
                    }
                    if (getWidth() &lt; getMinWidth()) {
                        setWidth(getMinWidth());
                    }
                }

                @Override
                public Object getBean() {
                    return Stage.this;
                }

                @Override
                public String getName() {
                    return &quot;minWidth&quot;;
                }
            };
        }
        return minWidth;
    }

    /**
     * Defines the minimum height of this {@code Stage}.
     *
     * @defaultValue 0
     * @since JavaFX 2.1
     */
    private DoubleProperty minHeight;

    public final void setMinHeight(double value) {
        minHeightProperty().set(value);
    }

    public final double getMinHeight() {
        return minHeight == null ? 0 : minHeight.get();
    }

    public final DoubleProperty minHeightProperty() {
        if (minHeight == null) {
            minHeight = new DoublePropertyBase(0) {

                @Override
                protected void invalidated() {
                    if (getPeer() != null) {
                        getPeer().setMinimumSize(
                                (int) Math.ceil(getMinWidth()),
                                (int) Math.ceil(get()));
                    }
                    if (getHeight() &lt; getMinHeight()) {
                        setHeight(getMinHeight());
                    }
                }

                @Override
                public Object getBean() {
                    return Stage.this;
                }

                @Override
                public String getName() {
                    return &quot;minHeight&quot;;
                }
            };
        }
        return minHeight;
    }

    /**
     * Defines the maximum width of this {@code Stage}.
     *
     * @defaultValue Double.MAX_VALUE
     * @since JavaFX 2.1
     */
    private DoubleProperty maxWidth;

    public final void setMaxWidth(double value) {
        maxWidthProperty().set(value);
    }

    public final double getMaxWidth() {
        return maxWidth == null ? Double.MAX_VALUE : maxWidth.get();
    }

    public final DoubleProperty maxWidthProperty() {
        if (maxWidth == null) {
            maxWidth = new DoublePropertyBase(Double.MAX_VALUE) {

                @Override
                protected void invalidated() {
                    if (getPeer() != null) {
                        getPeer().setMaximumSize((int) Math.floor(get()),
                                (int) Math.floor(getMaxHeight()));
                    }
                    if (getWidth() &gt; getMaxWidth()) {
                        setWidth(getMaxWidth());
                    }
                }

                @Override
                public Object getBean() {
                    return Stage.this;
                }

                @Override
                public String getName() {
                    return &quot;maxWidth&quot;;
                }
            };
        }
        return maxWidth;
    }

    /**
     * Defines the maximum height of this {@code Stage}.
     *
     * @defaultValue Double.MAX_VALUE
     * @since JavaFX 2.1
     */
    private DoubleProperty maxHeight;

    public final void setMaxHeight(double value) {
        maxHeightProperty().set(value);
    }

    public final double getMaxHeight() {
        return maxHeight == null ? Double.MAX_VALUE : maxHeight.get();
    }

    public final DoubleProperty maxHeightProperty() {
        if (maxHeight == null) {
            maxHeight = new DoublePropertyBase(Double.MAX_VALUE) {

                @Override
                protected void invalidated() {
                    if (getPeer() != null) {
                        getPeer().setMaximumSize(
                                (int) Math.floor(getMaxWidth()),
                                (int) Math.floor(get()));
                    }
                    if (getHeight() &gt; getMaxHeight()) {
                        setHeight(getMaxHeight());
                    }
                }

                @Override
                public Object getBean() {
                    return Stage.this;
                }

                @Override
                public String getName() {
                    return &quot;maxHeight&quot;;
                }
            };
        }
        return maxHeight;
    }

    /*
     * This can be replaced by listening for the onShowing/onHiding events
     * Note: This method MUST only be called via its accessor method.
     */
    private void doVisibleChanging(boolean value) {
        Toolkit toolkit = Toolkit.getToolkit();
        if (value &amp;&amp; (getPeer() == null)) {
            // Setup the peer
            Window window = getOwner();
            TKStage tkStage = (window == null ? null : window.getPeer());
            Scene scene = getScene();
            boolean rtl = scene != null &amp;&amp; scene.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;

            StageStyle stageStyle = getStyle();
            if (stageStyle == StageStyle.TRANSPARENT) {
                final SecurityManager securityManager =
                        System.getSecurityManager();
                if (securityManager != null) {
                    try {
                        securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);
                    } catch (final SecurityException e) {
                        stageStyle = StageStyle.UNDECORATED;
                    }
                }
            }
            setPeer(toolkit.createTKStage(this, isSecurityDialog(),
                    stageStyle, isPrimary(), getModality(), tkStage, rtl, acc));
            getPeer().setMinimumSize((int) Math.ceil(getMinWidth()),
                    (int) Math.ceil(getMinHeight()));
            getPeer().setMaximumSize((int) Math.floor(getMaxWidth()),
                    (int) Math.floor(getMaxHeight()));
            setPeerListener(new StagePeerListener(this, STAGE_ACCESSOR));
        }
    }


    /*
     * This can be replaced by listening for the onShown/onHidden events
     * Note: This method MUST only be called via its accessor method.
     */
    private void doVisibleChanged(boolean value) {
        if (value) {
            // Finish initialization
            TKStage peer = getPeer();
            peer.setImportant(isImportant());
            peer.setResizable(isResizable());
            peer.setFullScreen(isFullScreen());
            peer.setAlwaysOnTop(isAlwaysOnTop());
            peer.setIconified(isIconified());
            peer.setMaximized(isMaximized());
            peer.setTitle(getTitle());

            List&lt;Object&gt; platformImages = new ArrayList&lt;Object&gt;();
            for (Image icon : icons) {
                platformImages.add(Toolkit.getImageAccessor().getPlatformImage(icon));
            }
            if (peer != null) {
                peer.setIcons(platformImages);
            }
        }

        if (!value &amp;&amp; inNestedEventLoop) {
            inNestedEventLoop = false;
            Toolkit.getToolkit().exitNestedEventLoop(this, null);
        }
    }

    /**
     * Bring the {@code Window} to the foreground.  If the {@code Window} is
     * already in the foreground there is no visible difference.
     */
    public void toFront() {
        if (getPeer() != null) {
            getPeer().toFront();
        }
    }

    /**
     * Send the {@code Window} to the background.  If the {@code Window} is
     * already in the background there is no visible difference.  This action
     * places this {@code Window} at the bottom of the stacking order on
     * platforms that support stacking.
     */
    public void toBack() {
        if (getPeer() != null) {
            getPeer().toBack();
        }
    }

    /**
     * Closes this {@code Stage}.
     * This call is equivalent to {@code hide()}.
     */
    public void close() {
        hide();
    }

    @Override
    Window getWindowOwner() {
        return getOwner();
    }


    private final ObjectProperty&lt;KeyCombination&gt; fullScreenExitCombination =
            new SimpleObjectProperty&lt;KeyCombination&gt;(this, &quot;fullScreenExitCombination&quot;, null);

    /**
     * Specifies the KeyCombination that will allow the user to exit full screen
     * mode. A value of KeyCombination.NO_MATCH will not match any KeyEvent and
     * will make it so the user is not able to escape from Full Screen mode.
     * A value of null indicates that the default platform specific key combination
     * should be used.
     * &lt;p&gt;
     * An internal copy of this value is made when entering full-screen mode and will be
     * used to trigger the exit from the mode.
     * If a security manager is present, the application must have the
     * {@link javafx.util.FXPermission} &quot;unrestrictedFullScreen&quot; to modify the
     * exit key combination. If the application does not have permission, the
     * value of this property will be ignored, in which case the
     * default key combination will be used.
     * &lt;/p&gt;
     * @param keyCombination the key combination to exit on
     * @since JavaFX 8.0
     */
    public final void setFullScreenExitKeyCombination(KeyCombination keyCombination) {
        fullScreenExitCombination.set(keyCombination);
    }

    /**
     * Get the current sequence used to exit Full Screen mode.
     * @return the current setting (null for system default)
     * @since JavaFX 8.0
     */
    public final KeyCombination getFullScreenExitKeyCombination() {
        return fullScreenExitCombination.get();
    }

    /**
     * Get the property for the Full Screen exit key combination.
     * @return the property.
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;KeyCombination&gt; fullScreenExitKeyProperty() {
        return fullScreenExitCombination;
    }

    private final ObjectProperty&lt;String&gt; fullScreenExitHint =
            new SimpleObjectProperty&lt;String&gt;(this, &quot;fullScreenExitHint&quot;, null);

    /**
     * Specifies the text to show when a user enters full screen mode, usually
     * used to indicate the way a user should go about exiting out of full
     * screen mode. A value of null will result in the default per-locale
     * message being displayed.
     * If set to the empty string, then no message will be displayed.
     * &lt;p&gt;
     * If a security manager is present, the application must have the
     * {@link javafx.util.FXPermission} &quot;unrestrictedFullScreen&quot; to modify the
     * exit hint. If the application does not have permission, the
     * value of this property will be ignored, in which case the
     * default message will be displayed.
     * &lt;/p&gt;
     * @param value the string to be displayed.
     * @since JavaFX 8.0
     */
    public final void setFullScreenExitHint(String value) {
        fullScreenExitHint.set(value);
    }

    public final String getFullScreenExitHint() {
        return fullScreenExitHint.get();
    }

    public final ObjectProperty&lt;String&gt; fullScreenExitHintProperty() {
        return fullScreenExitHint;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmedia/locator/HLSConnectionHolder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.media.jfxmedia.locator;

import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmediaimpl.MediaUtils;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;

final class HLSConnectionHolder extends ConnectionHolder {

    private URLConnection urlConnection = null;
    private PlaylistThread playlistThread = new PlaylistThread();
    private VariantPlaylist variantPlaylist = null;
    private Playlist currentPlaylist = null;
    private int mediaFileIndex = -1;
    private CountDownLatch readySignal = new CountDownLatch(1);
    private Semaphore liveSemaphore = new Semaphore(0);
    private boolean isPlaylistClosed = false;
    private boolean isBitrateAdjustable = false;
    private long startTime = -1;
    private static final long HLS_VALUE_FLOAT_MULTIPLIER = 1000;
    private static final int HLS_PROP_GET_DURATION = 1;
    private static final int HLS_PROP_GET_HLS_MODE = 2;
    private static final int HLS_PROP_GET_MIMETYPE = 3;
    private static final int HLS_VALUE_MIMETYPE_MP2T = 1;
    private static final int HLS_VALUE_MIMETYPE_MP3 = 2;
    private static final String CHARSET_UTF_8 = &quot;UTF-8&quot;;
    private static final String CHARSET_US_ASCII = &quot;US-ASCII&quot;;

    HLSConnectionHolder(URI uri) throws IOException {
        playlistThread.setPlaylistURI(uri);
        init();
    }

    private void init() {
        playlistThread.putState(PlaylistThread.STATE_INIT);
        playlistThread.start();
    }

    @Override
    public int readNextBlock() throws IOException {
        if (isBitrateAdjustable &amp;&amp; startTime == -1) {
            startTime = System.currentTimeMillis();
        }

        int read = super.readNextBlock();
        if (isBitrateAdjustable &amp;&amp; read == -1) {
            long readTime = System.currentTimeMillis() - startTime;
            startTime = -1;
            adjustBitrate(readTime);
        }

        return read;
    }

    int readBlock(long position, int size) throws IOException {
        throw new IOException();
    }

    boolean needBuffer() {
        return true;
    }

    boolean isSeekable() {
        return true;
    }

    boolean isRandomAccess() {
        return false; // Only by segments
    }

    public long seek(long position) {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        return (long) (currentPlaylist.seek(position) * HLS_VALUE_FLOAT_MULTIPLIER);
    }

    @Override
    public void closeConnection() {
        currentPlaylist.close();
        super.closeConnection();
        resetConnection();
        playlistThread.putState(PlaylistThread.STATE_EXIT);
    }

    @Override
    int property(int prop, int value) {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        if (prop == HLS_PROP_GET_DURATION) {
            return (int) (currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);
        } else if (prop == HLS_PROP_GET_HLS_MODE) {
            return 1;
        } else if (prop == HLS_PROP_GET_MIMETYPE) {
            return currentPlaylist.getMimeType();
        }

        return -1;
    }

    @Override
    int getStreamSize() {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        return loadNextSegment();
    }

    private void resetConnection() {
        super.closeConnection();

        Locator.closeConnection(urlConnection);
        urlConnection = null;
    }

    // Returns -1 EOS or critical error
    // Returns positive size of segment if no isssues.
    // Returns negative size of segment if discontinuity.
    private int loadNextSegment() {
        resetConnection();

        String mediaFile = currentPlaylist.getNextMediaFile();
        if (mediaFile == null) {
            return -1;
        }

        try {
            URI uri = new URI(mediaFile);
            urlConnection = uri.toURL().openConnection();
            channel = openChannel();
        } catch (Exception e) {
            return -1;
        }

        if (currentPlaylist.isCurrentMediaFileDiscontinuity()) {
            return (-1 * urlConnection.getContentLength());
        } else {
            return urlConnection.getContentLength();
        }
    }

    private ReadableByteChannel openChannel() throws IOException {
        return Channels.newChannel(urlConnection.getInputStream());
    }

    private void adjustBitrate(long readTime) {
        int avgBitrate = (int)(((long) urlConnection.getContentLength() * 8 * 1000) / readTime);

        Playlist playlist = variantPlaylist.getPlaylistBasedOnBitrate(avgBitrate);
        if (playlist != null &amp;&amp; playlist != currentPlaylist) {
            if (currentPlaylist.isLive()) {
                playlist.update(currentPlaylist.getNextMediaFile());
                playlistThread.setReloadPlaylist(playlist);
            }

            playlist.setForceDiscontinuity(true);
            currentPlaylist = playlist;
        }
    }

    private static String stripParameters(String mediaFile) {
        int qp = mediaFile.indexOf('?');
        if (qp &gt; 0) {
            mediaFile = mediaFile.substring(0, qp); // Strip all possible http parameters.
        }
        return mediaFile;
    }

    private class PlaylistThread extends Thread {

        public static final int STATE_INIT = 0;
        public static final int STATE_EXIT = 1;
        public static final int STATE_RELOAD_PLAYLIST = 2;
        private BlockingQueue&lt;Integer&gt; stateQueue = new LinkedBlockingQueue&lt;Integer&gt;();
        private URI playlistURI = null;
        private Playlist reloadPlaylist = null;
        private final Object reloadLock = new Object();
        private volatile boolean stopped = false;

        private PlaylistThread() {
            setName(&quot;JFXMedia HLS Playlist Thread&quot;);
            setDaemon(true);
        }

        private void setPlaylistURI(URI playlistURI) {
            this.playlistURI = playlistURI;
        }

        private void setReloadPlaylist(Playlist playlist) {
            synchronized(reloadLock) {
                reloadPlaylist = playlist;
            }
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    int state = stateQueue.take();
                    switch (state) {
                        case STATE_INIT:
                            stateInit();
                            break;
                        case STATE_EXIT:
                            stopped = true;
                            break;
                        case STATE_RELOAD_PLAYLIST:
                            stateReloadPlaylist();
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                }
            }
        }

        private void putState(int state) {
            if (stateQueue != null) {
                try {
                    stateQueue.put(state);
                } catch (InterruptedException ex) {
                }
            }
        }

        private void stateInit() {
            if (playlistURI == null) {
                return;
            }

            PlaylistParser parser = new PlaylistParser();
            parser.load(playlistURI);

            if (parser.isVariantPlaylist()) {
                variantPlaylist = new VariantPlaylist(playlistURI);

                while (parser.hasNext()) {
                    variantPlaylist.addPlaylistInfo(parser.getString(), parser.getInteger());
                }
            } else {
                if (currentPlaylist == null) {
                    currentPlaylist = new Playlist(parser.isLivePlaylist(), parser.getTargetDuration());
                    currentPlaylist.setPlaylistURI(playlistURI);
                }

                if (currentPlaylist.setSequenceNumber(parser.getSequenceNumber())) {
                    while (parser.hasNext()) {
                        currentPlaylist.addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());
                    }
                }

                if (variantPlaylist != null) {
                    variantPlaylist.addPlaylist(currentPlaylist);
                }
            }

            // Update variant playlists
            if (variantPlaylist != null) {
                while (variantPlaylist.hasNext()) {
                    try {
                        currentPlaylist = new Playlist(variantPlaylist.getPlaylistURI());
                        currentPlaylist.update(null);
                        variantPlaylist.addPlaylist(currentPlaylist);
                    } catch (URISyntaxException e) {
                    } catch (MalformedURLException e) {
                    }
                }
            }

            // Always start with first data playlist
            if (variantPlaylist != null) {
                currentPlaylist = variantPlaylist.getPlaylist(0);
                isBitrateAdjustable = true;
            }

            // Start reloading live playlist
            if (currentPlaylist.isLive()) {
                setReloadPlaylist(currentPlaylist);
                putState(STATE_RELOAD_PLAYLIST);
            }

            readySignal.countDown();
        }

        private void stateReloadPlaylist() {
            try {
                long timeout;
                synchronized(reloadLock) {
                    timeout = reloadPlaylist.getTargetDuration() / 2;
                }
                Thread.sleep(timeout);
            } catch (InterruptedException ex) {
                return;
            }

            synchronized(reloadLock) {
                reloadPlaylist.update(null);
            }

            putState(STATE_RELOAD_PLAYLIST);
        }
    }

    private static class PlaylistParser {

        private boolean isFirstLine = true;
        private boolean isLineMediaFileURI = false;
        private boolean isEndList = false;
        private boolean isLinePlaylistURI = false;
        private boolean isVariantPlaylist = false;
        private boolean isDiscontinuity = false;
        private int targetDuration = 0;
        private int sequenceNumber = 0;
        private int dataListIndex = -1;
        private List&lt;String&gt; dataListString = new ArrayList&lt;String&gt;();
        private List&lt;Integer&gt; dataListInteger = new ArrayList&lt;Integer&gt;();
        private List&lt;Double&gt; dataListDouble = new ArrayList&lt;Double&gt;();
        private List&lt;Boolean&gt; dataListBoolean = new ArrayList&lt;Boolean&gt;();

        private void load(URI uri) {
            HttpURLConnection connection = null;
            BufferedReader reader = null;
            try {
                connection = (HttpURLConnection) uri.toURL().openConnection();
                connection.setRequestMethod(&quot;GET&quot;);

                if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                    MediaUtils.error(this, MediaError.ERROR_LOCATOR_CONNECTION_LOST.code(), &quot;HTTP responce code: &quot; + connection.getResponseCode(), null);
                }

                Charset charset = getCharset(uri.toURL().toExternalForm(), connection.getContentType());
                if (charset != null) {
                    reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), charset));
                }

                if (reader != null) {
                    boolean result;
                    do {
                        result = parseLine(reader.readLine());
                    } while (result);
                }
            } catch (MalformedURLException e) {
            } catch (IOException e) {
            } finally {
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e) {}

                    Locator.closeConnection(connection);
                }
            }
        }

        private boolean isVariantPlaylist() {
            return isVariantPlaylist;
        }

        private boolean isLivePlaylist() {
            return !isEndList;
        }

        private int getTargetDuration() {
            return targetDuration;
        }

        private int getSequenceNumber() {
            return sequenceNumber;
        }

        private boolean hasNext() {
            dataListIndex++;
            if (dataListString.size() &gt; dataListIndex || dataListInteger.size() &gt; dataListIndex || dataListDouble.size() &gt; dataListIndex || dataListBoolean.size() &gt; dataListIndex) {
                return true;
            } else {
                return false;
            }
        }

        private String getString() {
            return dataListString.get(dataListIndex);
        }

        private Integer getInteger() {
            return dataListInteger.get(dataListIndex);
        }

        private Double getDouble() {
            return dataListDouble.get(dataListIndex);
        }

        private Boolean getBoolean() {
            return dataListBoolean.get(dataListIndex);
        }

        private boolean parseLine(String line) {
            if (line == null) {
                return false;
            }

            // First line of playlist must be &quot;#EXTM3U&quot;
            if (isFirstLine) {
                if (line.compareTo(&quot;#EXTM3U&quot;) != 0) {
                    return false;
                }

                isFirstLine = false;
                return true;
            }

            // Ignore blank lines and comments
            if (line.isEmpty() || (line.startsWith(&quot;#&quot;) &amp;&amp; !line.startsWith(&quot;#EXT&quot;))) {
                return true;
            }

            if (line.startsWith(&quot;#EXTINF&quot;)) { // #EXTINF
                //#EXTINF:&lt;duration&gt;,&lt;title&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    String[] s2 = s1[1].split(&quot;,&quot;);
                    if (s2.length &gt;= 1) { // We have duration
                        dataListDouble.add(Double.parseDouble(s2[0]));
                    }
                }

                isLineMediaFileURI = true;
            } else if (line.startsWith(&quot;#EXT-X-TARGETDURATION&quot;)) {
                // #EXT-X-TARGETDURATION:&lt;s&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    targetDuration = Integer.parseInt(s1[1]);
                }
            } else if (line.startsWith(&quot;#EXT-X-MEDIA-SEQUENCE&quot;)) {
                // #EXT-X-MEDIA-SEQUENCE:&lt;number&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    sequenceNumber = Integer.parseInt(s1[1]);
                }
            } else if (line.startsWith(&quot;#EXT-X-STREAM-INF&quot;)) {
                // #EXT-X-STREAM-INF:&lt;attribute-list&gt;
                isVariantPlaylist = true;

                int bitrate = 0;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    String[] s2 = s1[1].split(&quot;,&quot;);
                    if (s2.length &gt; 0) {
                        for (int i = 0; i &lt; s2.length; i++) {
                            s2[i] = s2[i].trim();
                            if (s2[i].startsWith(&quot;BANDWIDTH&quot;)) {
                                String[] s3 = s2[i].split(&quot;=&quot;);
                                if (s3.length == 2 &amp;&amp; s3[1].length() &gt; 0) {
                                    bitrate = Integer.parseInt(s3[1]);
                                }
                            }
                        }
                    }
                }

                if (bitrate &lt; 1) {
                    return false;
                }

                dataListInteger.add(bitrate);

                isLinePlaylistURI = true; // Next line will be URI to playlist
            } else if (line.startsWith(&quot;#EXT-X-ENDLIST&quot;)) { // #EXT-X-ENDLIST
                isEndList = true;
            } else if (line.startsWith(&quot;#EXT-X-DISCONTINUITY&quot;)) { // #EXT-X-DISCONTINUITY
                isDiscontinuity = true;
            } else if (isLinePlaylistURI) {
                isLinePlaylistURI = false;
                dataListString.add(line);
            } else if (isLineMediaFileURI) {
                isLineMediaFileURI = false;
                dataListString.add(line);
                dataListBoolean.add(isDiscontinuity);
                isDiscontinuity = false;
            }

            return true;
        }

        private Charset getCharset(String url, String mimeType) {
            if ((url != null &amp;&amp; stripParameters(url).endsWith(&quot;.m3u8&quot;)) || (mimeType != null &amp;&amp; mimeType.equals(&quot;application/vnd.apple.mpegurl&quot;))) {
                if (Charset.isSupported(CHARSET_UTF_8)) {
                    return Charset.forName(CHARSET_UTF_8);
                }
            } else if ((url != null &amp;&amp; stripParameters(url).endsWith(&quot;.m3u&quot;)) || (mimeType != null &amp;&amp; mimeType.equals(&quot;audio/mpegurl&quot;))) {
                if (Charset.isSupported(CHARSET_US_ASCII)) {
                    return Charset.forName(CHARSET_US_ASCII);
                }
            }

            return null;
        }
    }

    private static class VariantPlaylist {

        private URI playlistURI = null;
        private int infoIndex = -1;
        private List&lt;String&gt; playlistsLocations = new ArrayList&lt;String&gt;();
        private List&lt;Integer&gt; playlistsBitrates = new ArrayList&lt;Integer&gt;();
        private List&lt;Playlist&gt; playlists = new ArrayList&lt;Playlist&gt;();
        private String mediaFileExtension = null; // Will be set to media file extension of first playlist

        private VariantPlaylist(URI uri) {
            playlistURI = uri;
        }

        private void addPlaylistInfo(String location, int bitrate) {
            playlistsLocations.add(location);
            playlistsBitrates.add(bitrate);
        }

        private void addPlaylist(Playlist playlist) {
            if (mediaFileExtension == null) {
                mediaFileExtension = playlist.getMediaFileExtension();
            } else {
                if (!mediaFileExtension.equals(playlist.getMediaFileExtension())) {
                    playlistsLocations.remove(infoIndex);
                    playlistsBitrates.remove(infoIndex);
                    infoIndex--;
                    return; // Ignore playlist with different media type
                }
            }
            playlists.add(playlist);
        }

        private Playlist getPlaylist(int index) {
            if (playlists.size() &gt; index) {
                return playlists.get(index);
            } else {
                return null;
            }
        }

        private boolean hasNext() {
            infoIndex++;
            if (playlistsLocations.size() &gt; infoIndex &amp;&amp; playlistsBitrates.size() &gt; infoIndex) {
                return true;
            } else {
                return false;
            }
        }

        private URI getPlaylistURI() throws URISyntaxException, MalformedURLException {
            String location = playlistsLocations.get(infoIndex);
            if (location.startsWith(&quot;http://&quot;) || location.startsWith(&quot;https://&quot;)) {
                return new URI(location);
<A NAME="83"></A>            } else {
                return new URI(playlistURI.toURL().toString().substring(0, playlistURI.toURL().toString().lastIndexOf(&quot;/&quot;) + 1) + location);
            }
        <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#83',2,'match42-top.html#83',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        private Playlist getPlaylistBasedOnBitrate(int bitrate) {
            int playlistIndex = -1;
            int playlistBitrate = 0;

            // Get bitrate that less then requested bitrate, but most closed to it
            for (int i = 0; i &lt; playlistsBitrates.size(); i++) {</B></FONT>
                int b = playlistsBitrates.get(i);
                if (b &lt; bitrate) {
                    if (playlistIndex != -1) {
                        if (b &gt; playlistBitrate) {
                            playlistBitrate = b;
                            playlistIndex = i;
                        }
                    } else {
                        playlistIndex = i;
                    }
                }
            }

            // If we did not find one (stall), then get the lowest bitrate possible
            if (playlistIndex == -1) {
                for (int i = 0; i &lt; playlistsBitrates.size(); i++) {
                    int b = playlistsBitrates.get(i);
                    if (b &lt; playlistBitrate || playlistIndex == -1) {
                        playlistBitrate = b;
                        playlistIndex = i;
                    }
                }
            }

            // Just in case
            if (playlistIndex &lt; 0 || playlistIndex &gt;= playlists.size()) {
                return null;
             } else {
                return playlists.get(playlistIndex);
            }
        }
    }

    private class Playlist {

        private boolean isLive = false;
        private volatile boolean isLiveWaiting = false;
        private volatile boolean isLiveStop = false;
        private long targetDuration = 0;
        private URI playlistURI = null;
        private final Object lock = new Object();
        private List&lt;String&gt; mediaFiles = new ArrayList&lt;String&gt;();
        private List&lt;Double&gt; mediaFilesStartTimes = new ArrayList&lt;Double&gt;();
        private List&lt;Boolean&gt; mediaFilesDiscontinuities = new ArrayList&lt;Boolean&gt;();
        private boolean needBaseURI = true;
        private String baseURI = null;
        private double duration = 0.0;
        private int sequenceNumber = -1;
        private int sequenceNumberStart = -1;
        private boolean sequenceNumberUpdated = false;
        private boolean forceDiscontinuity = false;

        private Playlist(boolean isLive, int targetDuration) {
            this.isLive = isLive;
            this.targetDuration = targetDuration * 1000;

            if (isLive) {
                duration = -1.0;
            }
        }

        private Playlist(URI uri) {
            playlistURI = uri;
        }

        private void update(String nextMediaFile) {
            PlaylistParser parser = new PlaylistParser();
            parser.load(playlistURI);

            isLive = parser.isLivePlaylist();
            targetDuration = parser.getTargetDuration() * 1000;

            if (isLive) {
                duration = -1.0;
            }

            if (setSequenceNumber(parser.getSequenceNumber())) {
                while (parser.hasNext()) {
                    addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());
                }
            }

            if (nextMediaFile != null) {
                synchronized (lock) {
                    for (int i = 0; i &lt; mediaFiles.size(); i++) {
                        String mediaFile = mediaFiles.get(i);
                        if (nextMediaFile.endsWith(mediaFile)) {
                            mediaFileIndex = i - 1;
                            break;
                        }
                    }
                }
            }
        }

        private boolean isLive() {
            return isLive;
        }

        private long getTargetDuration() {
            return targetDuration;
        }

        private void setPlaylistURI(URI uri) {
            playlistURI = uri;
        }

        private void addMediaFile(String URI, double duration, boolean isDiscontinuity) {
            synchronized (lock) {

                if (needBaseURI) {
                    setBaseURI(playlistURI.toString(), URI);
                }

                if (isLive) {
                    if (sequenceNumberUpdated) {
                        int index = mediaFiles.indexOf(URI);
                        if (index != -1) {
                            for (int i = 0; i &lt; index; i++) {
                                mediaFiles.remove(0);
                                mediaFilesDiscontinuities.remove(0);
                                if (mediaFileIndex == -1) {
                                    forceDiscontinuity = true;
                                }
                                if (mediaFileIndex &gt;= 0) {
                                    mediaFileIndex--;
                                }
                            }
                        }
                        sequenceNumberUpdated = false;
                    }

                    if (mediaFiles.contains(URI)) {
                        return; // Nothing to add
                    }
                }

                mediaFiles.add(URI);
                mediaFilesDiscontinuities.add(isDiscontinuity);

                if (isLive) {
                    if (isLiveWaiting) {
                        liveSemaphore.release();
                    }
                } else {
                    mediaFilesStartTimes.add(this.duration);
                    this.duration += duration;
                }
            }
        }

        private String getNextMediaFile() {
            if (isLive) {
                synchronized (lock) {
                    isLiveWaiting = ((mediaFileIndex + 1) &gt;= mediaFiles.size());
                }
                if (isLiveWaiting) {
                    try {
                        liveSemaphore.acquire();
                        isLiveWaiting = false;
                        if (isLiveStop) {
                            isLiveStop = false;
                            return null;
                        }
                    } catch (InterruptedException e) {
                        isLiveWaiting = false;
                        return null;
                    }
                }
                if (isPlaylistClosed) {
                    return null;
                }
            }

            synchronized (lock) {
                mediaFileIndex++;
                if ((mediaFileIndex) &lt; mediaFiles.size()) {
                    if (baseURI != null) {
                        return baseURI + mediaFiles.get(mediaFileIndex);
                    } else {
                        return mediaFiles.get(mediaFileIndex);
                    }
                } else {
                    return null;
                }
            }
        }

        private double getDuration() {
            return duration;
        }

        private void setForceDiscontinuity(boolean value) {
            forceDiscontinuity = value;
        }

        private boolean isCurrentMediaFileDiscontinuity() {
            if (forceDiscontinuity) {
                forceDiscontinuity = false;
                return true;
            } else {
                return mediaFilesDiscontinuities.get(mediaFileIndex);
            }
        }

        private double seek(long time) {
            synchronized (lock) {
                if (isLive) {
                    if (time == 0) {
                        mediaFileIndex = -1;
                        if (isLiveWaiting) {
                            isLiveStop = true;
                            liveSemaphore.release();
                        }
                        return 0;
                    }
                } else {
                    time += targetDuration / 2000;

                    int mediaFileStartTimeSize = mediaFilesStartTimes.size();

                    for (int index = 0; index &lt; mediaFileStartTimeSize; index++) {
                        if (time &gt;= mediaFilesStartTimes.get(index)) {
                            if (index + 1 &lt; mediaFileStartTimeSize) {
                                if (time &lt; mediaFilesStartTimes.get(index + 1)) {
                                    mediaFileIndex = index - 1; // Seek will load segment and increment mediaFileIndex
                                    return mediaFilesStartTimes.get(index);
                                }
                            } else {
                                if ((time - targetDuration / 2000) &lt; duration) {
                                    mediaFileIndex = index - 1; // Seek will load segment and increment mediaFileIndex
                                    return mediaFilesStartTimes.get(index);
                                } else if (Double.compare(time - targetDuration / 2000, duration) == 0) {
                                    return duration;
                                }
                            }
                        }
                    }
                }
            }

            return -1;
        }

        private int getMimeType() {
            synchronized (lock) {
                if (mediaFiles.size() &gt; 0) {
                    if (stripParameters(mediaFiles.get(0)).endsWith(&quot;.ts&quot;)) {
                        return HLS_VALUE_MIMETYPE_MP2T;
                    } else if (stripParameters(mediaFiles.get(0)).endsWith(&quot;.mp3&quot;)) {
                        return HLS_VALUE_MIMETYPE_MP3;
                    }
                }
            }

            return -1;
        }

        private String getMediaFileExtension() {
            synchronized (lock) {
                if (mediaFiles.size() &gt; 0) {
                    String mediaFile = stripParameters(mediaFiles.get(0));
                    int index = mediaFile.lastIndexOf(&quot;.&quot;);
                    if (index != -1) {
                        return mediaFile.substring(index);
                    }
                }
            }

            return null;
        }

        private boolean setSequenceNumber(int value) {
            if (sequenceNumberStart == -1) {
                sequenceNumberStart = value;
            } else if (sequenceNumber != value) {
                sequenceNumberUpdated = true;
                sequenceNumber = value;
            } else {
                return false;
            }

            return true;
        }

        private void close() {
            if (isLive) {
                isPlaylistClosed = true;
                liveSemaphore.release();
            }
        }

        private void setBaseURI(String playlistURI, String URI) {
            if (!URI.startsWith(&quot;http://&quot;) &amp;&amp; !URI.startsWith(&quot;https://&quot;)) {
                baseURI = playlistURI.substring(0, playlistURI.lastIndexOf(&quot;/&quot;) + 1);
            }
            needBaseURI = false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/NativeMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl;

import java.lang.annotation.Native;
import com.sun.media.jfxmedia.Media;
import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmedia.MediaException;
import com.sun.media.jfxmedia.MediaPlayer;
import com.sun.media.jfxmedia.control.VideoRenderControl;
import com.sun.media.jfxmedia.effects.AudioEqualizer;
import com.sun.media.jfxmedia.effects.AudioSpectrum;
import com.sun.media.jfxmedia.events.AudioSpectrumEvent;
import com.sun.media.jfxmedia.events.AudioSpectrumListener;
import com.sun.media.jfxmedia.events.BufferListener;
import com.sun.media.jfxmedia.events.BufferProgressEvent;
import com.sun.media.jfxmedia.events.MarkerEvent;
<A NAME="14"></A>import com.sun.media.jfxmedia.events.MarkerListener;
import com.sun.media.jfxmedia.events.MediaErrorListener;
import com.sun.media.jfxmedia.events.NewFrameEvent;
<FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#14',2,'match42-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.media.jfxmedia.events.PlayerEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent.PlayerState;
import com.sun.media.jfxmedia.events.PlayerStateListener;
import com.sun.media.jfxmedia.events.PlayerTimeListener;
import com.sun.media.jfxmedia.events.VideoFrameRateListener;
import com.sun.media.jfxmedia.events.VideoRendererListener;
import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
import com.sun.media.jfxmedia.logging.Logger;
import com.sun.media.jfxmedia.track.AudioTrack;
import com.sun.media.jfxmedia.track.SubtitleTrack;
import com.sun.media.jfxmedia.track.Track;
import com.sun.media.jfxmedia.track.Track.Encoding;
import com.sun.media.jfxmedia.track.VideoResolution;
import com.sun.media.jfxmedia.track.VideoTrack;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Base implementation of a
 * &lt;code&gt;MediaPlayer&lt;/code&gt;.
 */
public abstract class NativeMediaPlayer implements MediaPlayer, MarkerStateListener {
    //***** Event IDs for PlayerStateEvent.  IDs sent from native JNI layer.

    @Native public final static int eventPlayerUnknown = 100;
    @Native public final static int eventPlayerReady = 101;
    @Native public final static int eventPlayerPlaying = 102;
    @Native public final static int eventPlayerPaused = 103;
    @Native public final static int eventPlayerStopped = 104;
    @Native public final static int eventPlayerStalled = 105;
    @Native public final static int eventPlayerFinished = 106;
    @Native public final static int eventPlayerError = 107</B></FONT>;
    // Nominal video frames per second.
    @Native private static final int NOMINAL_VIDEO_FPS = 30;
    // Nanoseconds per second.
    @Native public static final long ONE_SECOND = 1000000000L;

    /**
     * The
     * &lt;code&gt;Media&lt;/code&gt; corresponding to the media source.
     */
    private NativeMedia media;
    private VideoRenderControl videoRenderControl;
    private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerStateListener&gt;&gt; playerStateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; playerTimeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; videoTrackSizeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoRendererListener&gt;&gt; videoUpdateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; videoFrameRateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;MarkerListener&gt;&gt; markerListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;BufferListener&gt;&gt; bufferListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; audioSpectrumListeners = new ArrayList&lt;&gt;();
    private final List&lt;PlayerStateEvent&gt; cachedStateEvents = new ArrayList&lt;&gt;();
    private final List&lt;PlayerTimeEvent&gt; cachedTimeEvents = new ArrayList&lt;&gt;();
    private final List&lt;BufferProgressEvent&gt; cachedBufferEvents = new ArrayList&lt;&gt;();
    private final List&lt;MediaErrorEvent&gt; cachedErrorEvents = new ArrayList&lt;&gt;();
    private boolean isFirstFrame = true;
    private NewFrameEvent firstFrameEvent = null;
    private double firstFrameTime;
    private final Object firstFrameLock = new Object();
    private EventQueueThread eventLoop = new EventQueueThread();
    private int frameWidth = -1;
    private int frameHeight = -1;
    private final AtomicBoolean isMediaPulseEnabled = new AtomicBoolean(false);
    private final Lock mediaPulseLock = new ReentrantLock();
    private Timer mediaPulseTimer;
    private final Lock markerLock = new ReentrantLock();
    private boolean checkSeek = false;
    private double timeBeforeSeek = 0.0;
    private double timeAfterSeek = 0.0;
    private double previousTime = 0.0;
    private double firedMarkerTime = -1.0;
    private double startTime = 0.0;
    private double stopTime = Double.POSITIVE_INFINITY;
    private boolean isStartTimeUpdated = false;
    private boolean isStopTimeSet = false;

    // --- Begin decoded frame rate fields
    private double encodedFrameRate = 0.0;
    private boolean recomputeFrameRate = true;
    private double previousFrameTime;
    private long numFramesSincePlaying;
    private double meanFrameDuration;
    private double decodedFrameRate;
    // --- End decoded frame rate fields
    private PlayerState playerState = PlayerState.UNKNOWN;
    private final Lock disposeLock = new ReentrantLock();
    private boolean isDisposed = false;
    private Runnable onDispose;

    //**************************************************************************
    //***** Constructors
    //**************************************************************************
    /**
     * Construct a NativeMediaPlayer for the referenced clip.
     *
     * @param clip Media object
     * @throws IllegalArgumentException if
     * &lt;code&gt;clip&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    protected NativeMediaPlayer(NativeMedia clip) {
        if (clip == null) {
            throw new IllegalArgumentException(&quot;clip == null!&quot;);
        }
        media = clip;
        videoRenderControl = new VideoRenderer();
    }

    /**
     * Initialization method which must be called after construction to
     * initialize the internal state of the player. This method should be
     * invoked directly after the player is constructed.
     */
    protected void init() {
        media.addMarkerStateListener(this);
        eventLoop.start();
    }

    /**
     * Set a callback to invoke when the player is disposed.
     *
     * @param onDispose object on which to invoke {@link Runnable#run()} in
     * {@link #dispose()}.
     */
    void setOnDispose(Runnable onDispose) {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                this.onDispose = onDispose;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    /**
     * Event to be posted to any registered {@link MediaErrorListener}s.
     */
    private static class WarningEvent extends PlayerEvent {

        private final Object source;
        private final String message;

        WarningEvent(Object source, String message) {
            this.source = source;
            this.message = message;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return message;
        }
    }

    /**
     * Event to be posted to any registered (@link MediaErrorListener)s
     */
    public static class MediaErrorEvent extends PlayerEvent {

        private final Object source;
        private final MediaError error;

        public MediaErrorEvent(Object source, MediaError error) {
            this.source = source;
            this.error = error;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return error.description();
        }

        public int getErrorCode() {
            return error.code();
        }
    }

    private static class PlayerTimeEvent extends PlayerEvent {

        private final double time;

        public PlayerTimeEvent(double time) {
            this.time = time;
        }

        public double getTime() {
            return time;
        }
    }

    /**
     * Event to be posted to any registered {@link PlayerStateListener}s.
     */
    private static class TrackEvent extends PlayerEvent {

        private final Track track;

        TrackEvent(Track track) {
            this.track = track;
        }

        public Track getTrack() {
            return this.track;
        }
    }

    /**
     * Event to be posted to any registered {@link VideoTrackSizeListener}s.
     */
    private static class FrameSizeChangedEvent extends PlayerEvent {

        private final int width;
        private final int height;

        public FrameSizeChangedEvent(int width, int height) {
            if (width &gt; 0) {
                this.width = width;
            } else {
                this.width = 0;
            }

            if (height &gt; 0) {
                this.height = height;
            } else {
                this.height = 0;
            }
        }

        public int getWidth() {
            return width;
        }

        public int getHeight() {
            return height;
        }
    }

    /**
     * Helper class which managers {@link VideoRendererListener}s. This allows
     * any registered listeners, specifically AWT and Prism, to receive video
     * frames.
     */
    private class VideoRenderer implements VideoRenderControl {

        /**
         * adds the listener to the player's videoUpdate. The listener will be
         * called whenever a new frame of video is ready to be painted or
         * fetched by getData()
         *
         * @param listener the object which provides the VideoUpdateListener
         * callback interface
         */
        @Override
        public void addVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                synchronized (firstFrameLock) {
                    // If the first frame is cached, post it to the listener
                    // directly. The lock is obtained first so the cached
                    // frame is not cleared between the non-null test and
                    // posting the event.
                    if (firstFrameEvent != null) {
                        listener.videoFrameUpdated(firstFrameEvent);
                    }
                }
                videoUpdateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        /**
         * removes the listener from the player.
         *
         * @param listener to be removed from the player
         */
        @Override
        public void removeVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                    VideoRendererListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public void addVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                videoFrameRateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        @Override
        public void removeVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                    VideoFrameRateListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public int getFrameWidth() {
            return frameWidth;
        }

        @Override
        public int getFrameHeight() {
            return frameHeight;
        }
    }

    //***** EventQueueThread Helper Class -- Provides event handling.
    /**
     * Thread for media player event processing. The thread maintains an
     * internal queue of
     * &lt;code&gt;PlayerEvent&lt;/code&gt;s to which callers post using
     * &lt;code&gt;postEvent()&lt;/code&gt;. The thread blocks until an event becomes
     * available on the queue, and then removes the event from the queue and
     * posts it to any registered listeners appropriate to the type of event.
     */
    private class EventQueueThread extends Thread {

        private final BlockingQueue&lt;PlayerEvent&gt; eventQueue =
                new LinkedBlockingQueue&lt;&gt;();
        private volatile boolean stopped = false;

        EventQueueThread() {
            setName(&quot;JFXMedia Player EventQueueThread&quot;);
            setDaemon(true);
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    // trying to take an event from the queue.
                    // this method will block until an event becomes available.
                    PlayerEvent evt = eventQueue.take();

                    if (!stopped) {
                        if (evt instanceof NewFrameEvent) {
                            try {
                                HandleRendererEvents((NewFrameEvent) evt);
                            } catch (Throwable t) {
                                if (Logger.canLog(Logger.ERROR)) {
                                    Logger.logMsg(Logger.ERROR, &quot;Caught exception in HandleRendererEvents: &quot; + t.toString());
                                }
                            }
                        } else if (evt instanceof PlayerStateEvent) {
                            HandleStateEvents((PlayerStateEvent) evt);
                        } else if (evt instanceof FrameSizeChangedEvent) {
                            HandleFrameSizeChangedEvents((FrameSizeChangedEvent) evt);
                        } else if (evt instanceof TrackEvent) {
                            HandleTrackEvents((TrackEvent) evt);
                        } else if (evt instanceof MarkerEvent) {
                            HandleMarkerEvents((MarkerEvent) evt);
                        } else if (evt instanceof WarningEvent) {
                            HandleWarningEvents((WarningEvent) evt);
                        } else if (evt instanceof PlayerTimeEvent) {
                            HandlePlayerTimeEvents((PlayerTimeEvent) evt);
                        } else if (evt instanceof BufferProgressEvent) {
                            HandleBufferEvents((BufferProgressEvent) evt);
                        } else if (evt instanceof AudioSpectrumEvent) {
                            HandleAudioSpectrumEvents((AudioSpectrumEvent) evt);
                        } else if (evt instanceof MediaErrorEvent) {
                            HandleErrorEvents((MediaErrorEvent) evt);
                        }
                    }
                } catch (Exception e) {
                    // eventQueue.take() can throw InterruptedException,
                    // also in rare case it can throw wrong
                    // IllegalMonitorStateException
                    // so we catch Exception
                    // nothing to do, restart the loop unless it was properly stopped.
                }
            }

            eventQueue.clear();
        }

        private void HandleRendererEvents(NewFrameEvent evt) {
            if (isFirstFrame) {
                // Cache first frame. Frames are delivered time-sequentially
                // so there should be no thread contention problem here.
                isFirstFrame = false;
                synchronized (firstFrameLock) {
                    firstFrameEvent = evt;
                    firstFrameTime = firstFrameEvent.getFrameData().getTimestamp();
                    firstFrameEvent.getFrameData().holdFrame(); // hold as long as we cache it, else we'll crash
                }
            } else if (firstFrameEvent != null
                    &amp;&amp; firstFrameTime != evt.getFrameData().getTimestamp()) {
                // If this branch is entered then it cannot be the first frame.
                // This means that the player must be in the PLAYING state as
                // the first frame will arrive upon completion of prerolling.
                // When playing, listeners should receive the current frame,
                // not the first frame in the stream.

                // Clear the cached first frame. Obtain the lock first to avoid
                // a race condition with a listener newly being added.
                synchronized (firstFrameLock) {
                    firstFrameEvent.getFrameData().releaseFrame();
                    firstFrameEvent = null;
                }
            }

            // notify videoUpdateListeners
            for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                VideoRendererListener l = it.next().get();
                if (l != null) {
                    l.videoFrameUpdated(evt);
                } else {
                    it.remove();
                }
            }
            // done with the frame, we can release our hold now
            evt.getFrameData().releaseFrame();

            if (!videoFrameRateListeners.isEmpty()) {
                // Decoded frame rate calculations.
                double currentFrameTime = System.nanoTime() / (double) ONE_SECOND;

                if (recomputeFrameRate) {
                    // First frame in new computation sequence.
                    recomputeFrameRate = false;
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying = 1;
                } else {
                    boolean fireFrameRateEvent = false;

                    if (numFramesSincePlaying == 1) {
                        // Second frame. Estimate the initial frame rate and
                        // set event flag.
                        meanFrameDuration = currentFrameTime - previousFrameTime;
                        if (meanFrameDuration &gt; 0.0) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    } else {
                        // Update decoded frame rate estimate using a moving
                        // average over encodedFrameRate frames.
                        double previousMeanFrameDuration = meanFrameDuration;

                        // Determine moving average length.
                        int movingAverageLength = encodedFrameRate != 0.0
                                ? ((int) (encodedFrameRate + 0.5)) : NOMINAL_VIDEO_FPS;

                        // Claculate number of frames in current average.
                        long numFrames = numFramesSincePlaying &lt; movingAverageLength
                                ? numFramesSincePlaying : movingAverageLength;

                        // Update the mean frame duration.
                        meanFrameDuration = ((numFrames - 1) * previousMeanFrameDuration
                                + currentFrameTime - previousFrameTime) / numFrames;

                        // If mean frame duration changed by more than 0.5 set
                        // event flag.
                        if (meanFrameDuration &gt; 0.0
                                &amp;&amp; Math.abs(decodedFrameRate - 1.0 / meanFrameDuration) &gt; 0.5) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    }

                    if (fireFrameRateEvent) {
                        // Fire event.
                        for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                            VideoFrameRateListener l = it.next().get();
                            if (l != null) {
                                l.onFrameRateChanged(decodedFrameRate);
                            } else {
                                it.remove();
                            }
                        }
                    }

                    // Update running values.
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying++;
                }
            }
        }

        private void HandleStateEvents(PlayerStateEvent evt) {
            playerState = evt.getState();

            recomputeFrameRate = PlayerState.PLAYING == evt.getState();

            switch (playerState) {
                case READY:
                    onNativeInit();
                    sendFakeBufferProgressEvent();
                    break;
                case PLAYING:
                    isMediaPulseEnabled.set(true);
                    break;
                case STOPPED:
                case FINISHED:
                    // Force a time update here to catch the time going to
                    // zero for STOPPED and any trailing markers for FINISHED.
                    doMediaPulseTask();
                case PAUSED:
                case STALLED:
                case HALTED:
                    isMediaPulseEnabled.set(false);
                    break;
                default:
                    break;
            }

            synchronized (cachedStateEvents) {
                if (playerStateListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedStateEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener listener = it.next().get();
                if (listener != null) {
                    switch (playerState) {
                        case READY:
                            onNativeInit();
                            sendFakeBufferProgressEvent();
                            listener.onReady(evt);
                            break;

                        case PLAYING:
                            listener.onPlaying(evt);
                            break;

                        case PAUSED:
                            listener.onPause(evt);
                            break;

                        case STOPPED:
                            listener.onStop(evt);
                            break;

                        case STALLED:
                            listener.onStall(evt);
                            break;

                        case FINISHED:
                            listener.onFinish(evt);
                            break;

                        case HALTED:
                            listener.onHalt(evt);
                            break;

                        default:
                            break;
                    }
                } else {
                    it.remove();
                }
            }
        }

        private void HandlePlayerTimeEvents(PlayerTimeEvent evt) {
            synchronized (cachedTimeEvents) {
                if (playerTimeListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedTimeEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener listener = it.next().get();
                if (listener != null) {
                    listener.onDurationChanged(evt.getTime());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleFrameSizeChangedEvents(FrameSizeChangedEvent evt) {
            frameWidth = evt.getWidth();
            frameHeight = evt.getHeight();
            Logger.logMsg(Logger.DEBUG, &quot;** Frame size changed (&quot; + frameWidth + &quot;, &quot; + frameHeight + &quot;)&quot;);
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener listener = it.next().get();
                if (listener != null) {
                    listener.onSizeChanged(frameWidth, frameHeight);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleTrackEvents(TrackEvent evt) {
            media.addTrack(evt.getTrack());

            if (evt.getTrack() instanceof VideoTrack) {
                encodedFrameRate = ((VideoTrack) evt.getTrack()).getEncodedFrameRate();
            }
        }

        private void HandleMarkerEvents(MarkerEvent evt) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener listener = it.next().get();
                if (listener != null) {
                    listener.onMarker(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleWarningEvents(WarningEvent evt) {
            Logger.logMsg(Logger.WARNING, evt.getSource() + evt.getMessage());
        }

        private void HandleErrorEvents(MediaErrorEvent evt) {
            Logger.logMsg(Logger.ERROR, evt.getMessage());

            synchronized (cachedErrorEvents) {
                if (errorListeners.isEmpty()) {
                    // cache error events until at least one listener is added
                    cachedErrorEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l != null) {
                    l.onError(evt.getSource(), evt.getErrorCode(), evt.getMessage());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleBufferEvents(BufferProgressEvent evt) {
            synchronized (cachedBufferEvents) {
                if (bufferListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedBufferEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener listener = it.next().get();
                if (listener != null) {
                    listener.onBufferProgress(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleAudioSpectrumEvents(AudioSpectrumEvent evt) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener listener = it.next().get();
                if (listener != null) {
                    listener.onAudioSpectrumEvent(evt);
                } else {
                    it.remove();
                }
            }
        }

        /**
         * Puts an event to the EventQuery.
         */
        public void postEvent(PlayerEvent event) {
            if (eventQueue != null) {
                eventQueue.offer(event);
            }
        }

        /**
         * Signals the thread to terminate.
         */
        public void terminateLoop() {
            stopped = true;
            // put an event to unblock eventQueue.take()
            try {
                eventQueue.put(new PlayerEvent());
            } catch(InterruptedException ex) {}
        }

        private void sendFakeBufferProgressEvent() {
            // Send fake 100% buffer progress event for HLS or !http protcol
            String contentType = media.getLocator().getContentType();
            String protocol = media.getLocator().getProtocol();
            if ((contentType != null &amp;&amp; (contentType.equals(MediaUtils.CONTENT_TYPE_M3U) || contentType.equals(MediaUtils.CONTENT_TYPE_M3U8)))
                    || (protocol != null &amp;&amp; !protocol.equals(&quot;http&quot;) &amp;&amp; !protocol.equals(&quot;https&quot;))) {
                HandleBufferEvents(new BufferProgressEvent(getDuration(), 0, 1, 1));
            }
        }
    }

    /**
     * Internal function to get called when the native player is ready.
     */
    private synchronized void onNativeInit() {
        try {
            playerInit();
        } catch (MediaException me) {
            sendPlayerMediaErrorEvent(me.getMediaError().code());
        }
    }

    //**************************************************************************
    //***** MediaPlayer implementation
    //**************************************************************************
    //***** Listener (un)registration.
    @Override
    public void addMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            this.errorListeners.add(new WeakReference&lt;&gt;(listener));

            synchronized (cachedErrorEvents) {
                if (!cachedErrorEvents.isEmpty() &amp;&amp; !errorListeners.isEmpty()) {
                    cachedErrorEvents.stream().forEach((evt) -&gt; {
                        sendPlayerEvent(evt);
                    });
                    cachedErrorEvents.clear();
                }
            }
        }
    }

    @Override
    public void removeMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            synchronized (cachedStateEvents) {
                if (!cachedStateEvents.isEmpty() &amp;&amp; playerStateListeners.isEmpty()) {
                    // Forward all cached state events to first listener to register.
                    Iterator&lt;PlayerStateEvent&gt; events = cachedStateEvents.iterator();
                    while (events.hasNext()) {
                        PlayerStateEvent evt = events.next();
                        switch (evt.getState()) {
                            case READY:
                                listener.onReady(evt);
                                break;
                            case PLAYING:
                                listener.onPlaying(evt);
                                break;
                            case PAUSED:
                                listener.onPause(evt);
                                break;
                            case STOPPED:
                                listener.onStop(evt);
                                break;
                            case STALLED:
                                listener.onStall(evt);
                                break;
                            case FINISHED:
                                listener.onFinish(evt);
                                break;
                            case HALTED:
                                listener.onHalt(evt);
                                break;
                            default:
                                break;
                        }
                    }

                    // Clear state event cache.
                    cachedStateEvents.clear();
                }

                playerStateListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            synchronized (cachedTimeEvents) {
                if (!cachedTimeEvents.isEmpty() &amp;&amp; playerTimeListeners.isEmpty()) {
                    // Forward all cached time events to first listener to register.
                    Iterator&lt;PlayerTimeEvent&gt; events = cachedTimeEvents.iterator();
                    while (events.hasNext()) {
                        PlayerTimeEvent evt = events.next();
                        listener.onDurationChanged(evt.getTime());
                    }

                    // Clear time event cache.
                    cachedTimeEvents.clear();
                } else {
                    // Let listener to know about duration
                    double duration = getDuration();
                    if (duration != Double.POSITIVE_INFINITY) {
                        listener.onDurationChanged(duration);
                    }
                }

                playerTimeListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            if (frameWidth != -1 &amp;&amp; frameHeight != -1) {
                listener.onSizeChanged(frameWidth, frameHeight);
            }
            videoTrackSizeListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMarkerListener(MarkerListener listener) {
        if (listener != null) {
            markerListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeMarkerListener(MarkerListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addBufferListener(BufferListener listener) {
        if (listener != null) {
            synchronized (cachedBufferEvents) {
                if (!cachedBufferEvents.isEmpty() &amp;&amp; bufferListeners.isEmpty()) {
                    cachedBufferEvents.stream().forEach((evt) -&gt; {
                        listener.onBufferProgress(evt);
                    });
                    // Clear buffer event cache.
                    cachedBufferEvents.clear();
                }

                bufferListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeBufferListener(BufferListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            audioSpectrumListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    //***** Control functions
    @Override
    public VideoRenderControl getVideoRenderControl() {
        return videoRenderControl;
    }

    @Override
    public Media getMedia() {
        return media;
    }

    @Override
    public void setAudioSyncDelay(long delay) {
        try {
            playerSetAudioSyncDelay(delay);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public long getAudioSyncDelay() {
        try {
            return playerGetAudioSyncDelay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void play() {
        try {
            if (isStartTimeUpdated) {
                playerSeek(startTime);
            }
            isMediaPulseEnabled.set(true);
            playerPlay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public void stop() {
        try {
            playerStop();
            playerSeek(startTime);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;stop() failed!&quot;);
        }
    }

    @Override
    public void pause() {
        try {
            playerPause();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getRate() {
        try {
            return playerGetRate();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    //***** Public properties
    @Override
    public void setRate(float rate) {
        try {
            playerSetRate(rate);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;setRate(&quot; + rate + &quot;) failed!&quot;);
        }
    }

    @Override
    public double getPresentationTime() {
        try {
            return playerGetPresentationTime();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return -1.0;
    }

    @Override
    public float getVolume() {
        try {
            return playerGetVolume();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setVolume(float vol) {
        if (vol &lt; 0.0F) {
            vol = 0.0F;
        } else if (vol &gt; 1.0F) {
            vol = 1.0F;
        }

        try {
            playerSetVolume(vol);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public boolean getMute() {
        try {
            return playerGetMute();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return false;
    }

    /**
     * Enables/disable mute. If mute is enabled then disabled, the previous
     * volume goes into effect.
     */
    @Override
    public void setMute(boolean enable) {
        try {
            playerSetMute(enable);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getBalance() {
        try {
            return playerGetBalance();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setBalance(float bal) {
        if (bal &lt; -1.0F) {
            bal = -1.0F;
        } else if (bal &gt; 1.0F) {
            bal = 1.0F;
        }

        try {
            playerSetBalance(bal);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public abstract AudioEqualizer getEqualizer();

    @Override
    public abstract AudioSpectrum getAudioSpectrum();

    @Override
    public double getDuration() {
        try {
            return playerGetDuration();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return Double.POSITIVE_INFINITY;
    }

    /**
     * Gets the time within the duration of the media to start playing.
     */
    @Override
    public double getStartTime() {
        return startTime;
    }

    /**
     * Sets the start time within the media to play.
     */
    @Override
    public void setStartTime(double startTime) {
        try {
            markerLock.lock();
            this.startTime = startTime;
            if (playerState != PlayerState.PLAYING &amp;&amp; playerState != PlayerState.FINISHED &amp;&amp; playerState != PlayerState.STOPPED) {
                playerSeek(startTime);
            } else if (playerState == PlayerState.STOPPED) {
                isStartTimeUpdated = true;
            }
        } finally {
            markerLock.unlock();
        }
    }

    /**
     * Gets the time within the duration of the media to stop playing.
     */
    @Override
    public double getStopTime() {
        return stopTime;
    }

    /**
     * Sets the stop time within the media to stop playback.
     */
    @Override
    public void setStopTime(double stopTime) {
        try {
            markerLock.lock();
            this.stopTime = stopTime;
            isStopTimeSet = true;
            createMediaPulse();
        } finally {
            markerLock.unlock();
        }
    }

    @Override
    public void seek(double streamTime) {
        if (playerState == PlayerState.STOPPED) {
            return; // No seek in stopped state
        }

        if (streamTime &lt; 0.0) {
            streamTime = 0.0;
        } else {
            double duration = getDuration();
            if (duration &gt;= 0.0 &amp;&amp; streamTime &gt; duration) {
                streamTime = duration;
            }
        }

        if (!isMediaPulseEnabled.get()) {
            if ((playerState == PlayerState.PLAYING
                    || playerState == PlayerState.PAUSED
                    || playerState == PlayerState.FINISHED)
                    &amp;&amp; getStartTime() &lt;= streamTime &amp;&amp; streamTime &lt;= getStopTime()) {
                isMediaPulseEnabled.set(true);
            }
        }

        markerLock.lock();
        try {
            timeBeforeSeek = getPresentationTime();
            timeAfterSeek = streamTime;
            checkSeek = timeBeforeSeek != timeAfterSeek;
            previousTime = streamTime;
            firedMarkerTime = -1.0;
//            System.out.println(&quot;seek @ &quot;+System.currentTimeMillis());
//            System.out.println(&quot;seek to &quot;+streamTime+&quot; previousTime &quot;+previousTime);

            try {
                playerSeek(streamTime);
            } catch (MediaException me) {
                //sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
                MediaUtils.warning(this, &quot;seek(&quot; + streamTime + &quot;) failed!&quot;);
            }
        } finally {
            markerLock.unlock();
        }
    }

    protected abstract long playerGetAudioSyncDelay() throws MediaException;

    protected abstract void playerSetAudioSyncDelay(long delay) throws MediaException;

    protected abstract void playerPlay() throws MediaException;

    protected abstract void playerStop() throws MediaException;

    protected abstract void playerPause() throws MediaException;

    protected abstract void playerFinish() throws MediaException;

    protected abstract float playerGetRate() throws MediaException;

    protected abstract void playerSetRate(float rate) throws MediaException;

    protected abstract double playerGetPresentationTime() throws MediaException;

    protected abstract boolean playerGetMute() throws MediaException;

    protected abstract void playerSetMute(boolean state) throws MediaException;

    protected abstract float playerGetVolume() throws MediaException;

    protected abstract void playerSetVolume(float volume) throws MediaException;

    protected abstract float playerGetBalance() throws MediaException;

    protected abstract void playerSetBalance(float balance) throws MediaException;

    protected abstract double playerGetDuration() throws MediaException;

    protected abstract void playerSeek(double streamTime) throws MediaException;

    protected abstract void playerInit() throws MediaException;

    protected abstract void playerDispose();

    /**
     * Retrieves the current {@link PlayerState state} of the player.
     *
     * @return the current player state.
     */
    @Override
    public PlayerState getState() {
        return playerState;
    }

    @Override
    final public void dispose() {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                // Terminate event firing
                destroyMediaPulse();

                if (eventLoop != null) {
                    eventLoop.terminateLoop();
                    eventLoop = null;
                }

                synchronized (firstFrameLock) {
                    if (firstFrameEvent != null) {
                        firstFrameEvent.getFrameData().releaseFrame();
                        firstFrameEvent = null;
                    }
                }

                // Terminate native layer
                playerDispose();

                // Dispose media object and clear reference
                if (media != null) {
                    media.dispose();
                    media = null;
                }

                if (videoUpdateListeners != null) {
                    for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                        VideoRendererListener l = it.next().get();
                        if (l != null) {
                            l.releaseVideoFrames();
                        } else {
                            it.remove();
                        }
                    }

                    videoUpdateListeners.clear();
                }

                if (playerStateListeners != null) {
                    playerStateListeners.clear();
                }

                if (videoTrackSizeListeners != null) {
                    videoTrackSizeListeners.clear();
                }

                if (videoFrameRateListeners != null) {
                    videoFrameRateListeners.clear();
                }

                if (cachedStateEvents != null) {
                    cachedStateEvents.clear();
                }

                if (cachedTimeEvents != null) {
                    cachedTimeEvents.clear();
                }

                if (cachedBufferEvents != null) {
                    cachedBufferEvents.clear();
                }

                if (errorListeners != null) {
                    errorListeners.clear();
                }

                if (playerTimeListeners != null) {
                    playerTimeListeners.clear();
                }

                if (markerListeners != null) {
                    markerListeners.clear();
                }

                if (bufferListeners != null) {
                    bufferListeners.clear();
                }

                if (audioSpectrumListeners != null) {
                    audioSpectrumListeners.clear();
                }

                if (videoRenderControl != null) {
                    videoRenderControl = null;
                }

                if (onDispose != null) {
                    onDispose.run();
                }

                isDisposed = true;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    //**************************************************************************
    //***** Non-JNI methods called by the native layer. These methods are called
    //***** from the native layer via the invocation API. Their purpose is to
    //***** dispatch certain events to the Java layer. Each of these methods
    //***** posts an event on the &lt;code&gt;EventQueueThread&lt;/code&gt; which in turn
    //***** forwards the event to any registered listeners.
    //**************************************************************************
    protected void sendWarning(int warningCode, String warningMessage) {
        if (eventLoop != null) {
            String message = String.format(MediaUtils.NATIVE_MEDIA_WARNING_FORMAT,
                    warningCode);
            if (warningMessage != null) {
                message += &quot;: &quot; + warningMessage;
            }
            eventLoop.postEvent(new WarningEvent(this, message));
        }
    }

    protected void sendPlayerEvent(PlayerEvent evt) {
        if (eventLoop != null) {
            eventLoop.postEvent(evt);
        }
    }

    protected void sendPlayerHaltEvent(String message, double time) {
        // Log the error.  Since these are most likely playback engine message (e.g. GStreamer or PacketVideo),
        // it makes no sense to propogate it above.
        Logger.logMsg(Logger.ERROR, message);

        if (eventLoop != null) {
            eventLoop.postEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.HALTED, time, message));
        }
    }

    protected void sendPlayerMediaErrorEvent(int errorCode) {
        sendPlayerEvent(new MediaErrorEvent(this, MediaError.getFromCode(errorCode)));
    }

    protected void sendPlayerStateEvent(int eventID, double time) {
        switch (eventID) {
            case eventPlayerReady:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.READY, time));
                break;
            case eventPlayerPlaying:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PLAYING, time));
                break;
            case eventPlayerPaused:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PAUSED, time));
                break;
            case eventPlayerStopped:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STOPPED, time));
                break;
            case eventPlayerStalled:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STALLED, time));
                break;
            case eventPlayerFinished:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.FINISHED, time));
                break;
            default:
                break;
        }
    }

    protected void sendNewFrameEvent(long nativeRef) {
        NativeVideoBuffer newFrameData = NativeVideoBuffer.createVideoBuffer(nativeRef);
        // createVideoBuffer puts a hold on the frame
        // we need to keep that hold until the event thread can process this event
        sendPlayerEvent(new NewFrameEvent(newFrameData));
    }

    protected void sendFrameSizeChangedEvent(int width, int height) {
        sendPlayerEvent(new FrameSizeChangedEvent(width, height));
    }

    protected void sendAudioTrack(boolean enabled, long trackID, String name, int encoding,
            String language, int numChannels,
            int channelMask, float sampleRate) {
        Locale locale = null;
        if (!language.equals(&quot;und&quot;)) {
            locale = new Locale(language);
        }

        Track track = new AudioTrack(enabled, trackID, name,
                locale, Encoding.toEncoding(encoding),
                numChannels, channelMask, sampleRate);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendVideoTrack(boolean enabled, long trackID, String name, int encoding,
            int width, int height, float frameRate,
            boolean hasAlphaChannel) {
        // No locale (currently) for video, so pass null
        Track track = new VideoTrack(enabled, trackID, name, null,
                Encoding.toEncoding(encoding),
                new VideoResolution(width, height), frameRate, hasAlphaChannel);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendSubtitleTrack(boolean enabled, long trackID, String name,
            int encoding, String language)
    {
        Locale locale = null;
        if (null != language) {
            locale = new Locale(language);
        }
        Track track = new SubtitleTrack(enabled, trackID, name, locale,
                Encoding.toEncoding(encoding));

        sendPlayerEvent(new TrackEvent(track));
    }

    protected void sendMarkerEvent(String name, double time) {
        sendPlayerEvent(new MarkerEvent(name, time));
    }

    protected void sendDurationUpdateEvent(double duration) {
        sendPlayerEvent(new PlayerTimeEvent(duration));
    }

    protected void sendBufferProgressEvent(double clipDuration, long bufferStart, long bufferStop, long bufferPosition) {
        sendPlayerEvent(new BufferProgressEvent(clipDuration, bufferStart, bufferStop, bufferPosition));
    }

    protected void sendAudioSpectrumEvent(double timestamp, double duration) {
        sendPlayerEvent(new AudioSpectrumEvent(getAudioSpectrum(), timestamp, duration));
    }

    @Override
    public void markerStateChanged(boolean hasMarkers) {
        if (hasMarkers) {
            markerLock.lock();
            try {
                previousTime = getPresentationTime();
            } finally {
                markerLock.unlock();
            }
            createMediaPulse();
        } else {
            if (!isStopTimeSet) {
                destroyMediaPulse();
            }
        }
    }

    private void createMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer == null) {
                mediaPulseTimer = new Timer(true);
                mediaPulseTimer.scheduleAtFixedRate(new MediaPulseTask(this), 0, 40 /*
                         * period ms
                         */);
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    private void destroyMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer != null) {
                mediaPulseTimer.cancel();
                mediaPulseTimer = null;
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    boolean doMediaPulseTask() {
        if (this.isMediaPulseEnabled.get()) {
            disposeLock.lock();

            if (isDisposed) {
                disposeLock.unlock();
                return false;
            }

            double thisTime = getPresentationTime();

            markerLock.lock();

            try {
                //System.out.println(&quot;Media pulse @ pts &quot;+thisTime+&quot; previous &quot;+previousTime);

                if (checkSeek) {
                    if (timeAfterSeek &gt; timeBeforeSeek) {
                        // Forward seek
                        if (thisTime &gt;= timeAfterSeek) {
//                        System.out.println(&quot;bail 1&quot;);
                            checkSeek = false;
                        } else {
                            return true;
                        }
                    } else if (timeAfterSeek &lt; timeBeforeSeek) {
                        // Backward seek
                        if (thisTime &gt;= timeBeforeSeek) {
//                        System.out.println(&quot;bail 2&quot;);
                            return true;
                        } else {
                            checkSeek = false;
                        }
                    }
                }

                Map.Entry&lt;Double, String&gt; marker = media.getNextMarker(previousTime, true);
//                System.out.println(&quot;marker &quot;+marker);
//                System.out.println(&quot;Checking: &quot; + previousTime + &quot; &quot; + thisTime + &quot; &quot;
//                        + getStartTime() + &quot; &quot; + getStopTime() + &quot; &quot;
//                        + marker.getKey());

                while (marker != null) {
                    double nextMarkerTime = marker.getKey();
                    if (nextMarkerTime &gt; thisTime) {
                        break;
                    } else if (nextMarkerTime != firedMarkerTime
                            &amp;&amp; nextMarkerTime &gt;= previousTime
                            &amp;&amp; nextMarkerTime &gt;= getStartTime()
                            &amp;&amp; nextMarkerTime &lt;= getStopTime()) {
//                            System.out.println(&quot;Firing: &quot;+previousTime+&quot; &quot;+thisTime+&quot; &quot;+
//                                    getStartTime()+&quot; &quot;+getStopTime()+&quot; &quot;+
//                                    nextMarkerTime);
                        MarkerEvent evt = new MarkerEvent(marker.getValue(), nextMarkerTime);
                        for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                            MarkerListener listener = it.next().get();
                            if (listener != null) {
                                listener.onMarker(evt);
                            } else {
                                it.remove();
                            }
                        }
                        firedMarkerTime = nextMarkerTime;
                    }
                    marker = media.getNextMarker(nextMarkerTime, false);
                }

                previousTime = thisTime;

                // Do stopTime
                if (isStopTimeSet &amp;&amp; thisTime &gt;= stopTime) {
                    playerFinish();
                }
            } finally {
                disposeLock.unlock();
                markerLock.unlock();
            }
        }

        return true;
    }

    /* Audio EQ and spectrum creation, used by sub-classes */
    protected AudioEqualizer createNativeAudioEqualizer(long nativeRef) {
        return new NativeAudioEqualizer(nativeRef);
    }

    protected AudioSpectrum createNativeAudioSpectrum(long nativeRef) {
        return new NativeAudioSpectrum(nativeRef);
    }
}

class MediaPulseTask extends TimerTask {

    WeakReference&lt;NativeMediaPlayer&gt; playerRef;

    MediaPulseTask(NativeMediaPlayer player) {
        playerRef = new WeakReference&lt;&gt;(player);
    }

    @Override
    public void run() {
        final NativeMediaPlayer player = playerRef.get();
        if (player != null) {
            if (!player.doMediaPulseTask()) {
                cancel(); // Stop if doMediaPulseTask() returns false. False means doMediaPulseTask() cannot continue (like after dispose).cy
            }
        } else {
            cancel();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/platform/ios/IOSMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl.platform.ios;

import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmedia.MediaException;
import com.sun.media.jfxmedia.effects.AudioEqualizer;
import com.sun.media.jfxmedia.effects.AudioSpectrum;
import com.sun.media.jfxmedia.effects.EqualizerBand;
import com.sun.media.jfxmedia.locator.Locator;
import com.sun.media.jfxmedia.control.MediaPlayerOverlay;
import com.sun.media.jfxmediaimpl.NativeMediaPlayer;

import java.util.Map;
import java.util.HashMap;

/**
 * iOS MediaPlayer implementation.
 */
public final class IOSMediaPlayer extends NativeMediaPlayer {

    private IOSMedia iosMedia;

    private final NullAudioEQ audioEqualizer;
    private final NullAudioSpectrum audioSpectrum;
    private final MediaPlayerOverlay mediaPlayerOverlay;

    private float mutedVolume = 1.0f;  // last volume before mute
    private boolean muteEnabled; // false by default

    private IOSMediaPlayer(final IOSMedia sourceMedia) {
        super(sourceMedia);
        iosMedia = sourceMedia;

        // run event loop
        init();

        handleError(iosInitPlayer(iosMedia.getNativeMediaRef()));

        audioEqualizer = new NullAudioEQ();
        audioSpectrum = new NullAudioSpectrum();
        mediaPlayerOverlay = new MediaPlayerOverlayImpl();
    }

    IOSMediaPlayer(final Locator source) {
        this(new IOSMedia(source));
    }

    @Override
    public AudioEqualizer getEqualizer() {
        return audioEqualizer;
    }

    @Override
    public AudioSpectrum getAudioSpectrum() {
        return audioSpectrum;
    }

    @Override
    public MediaPlayerOverlay getMediaPlayerOverlay() {
        return mediaPlayerOverlay;
    }

    private void handleError(final int err) throws MediaException {
        if (0 != err) {
            final MediaError me = MediaError.getFromCode(err);
            throw new MediaException(&quot;Media error occurred&quot;, null, me);
        }
    }

    @Override
    protected long playerGetAudioSyncDelay() throws MediaException {
        final long[] audioSyncDelay = new long[1];
        handleError(iosGetAudioSyncDelay(iosMedia.getNativeMediaRef(), audioSyncDelay));
        return audioSyncDelay[0];
    }
<A NAME="48"></A>
    @Override
    protected void playerSetAudioSyncDelay(final long delay) throws MediaException {
        <FONT color="#c57726"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#48',2,'match42-top.html#48',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>handleError(iosSetAudioSyncDelay(iosMedia.getNativeMediaRef(), delay));
    }

    @Override
    protected void playerPlay() throws MediaException {
        handleError(iosPlay(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected void playerStop() throws MediaException {
        handleError(iosStop(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected void playerPause() throws MediaException {
        handleError(iosPause(iosMedia.getNativeMediaRef()));
    }

    @Override</B></FONT>
    protected float playerGetRate() throws MediaException {
        final float[] rate = new float[1];
        handleError(iosGetRate(iosMedia.getNativeMediaRef(), rate));
        return rate[0];
    }

    @Override
    protected void playerSetRate(final float rate) throws MediaException {
        handleError(iosSetRate(iosMedia.getNativeMediaRef(), rate));
    }

    @Override
    protected double playerGetPresentationTime() throws MediaException {
        double[] presentationTime = new double[1];
        handleError(iosGetPresentationTime(iosMedia.getNativeMediaRef(), presentationTime));
        return presentationTime[0];
    }

    @Override
    protected boolean playerGetMute() throws MediaException {
        return muteEnabled;
    }

    @Override
    protected synchronized void playerSetMute(final boolean enable) throws MediaException {
        if (enable != muteEnabled) {
            if (enable) {
                final float currentVolume = getVolume();
                playerSetVolume(0);
                muteEnabled = true;
                mutedVolume = currentVolume;
            }
            else {
                muteEnabled = false;
                playerSetVolume(mutedVolume);
            }
        }
    }

    @Override
    protected float playerGetVolume() throws MediaException {
        synchronized(this) {
            if (muteEnabled) {
                return mutedVolume;
            }
        }
        final float[] volume = new float[1];
        handleError(iosGetVolume(iosMedia.getNativeMediaRef(), volume));
        return volume[0];
    }

    @Override
    protected synchronized void playerSetVolume(final float volume) throws MediaException {
        if (!muteEnabled) {
            final int err = iosSetVolume(iosMedia.getNativeMediaRef(), volume);
            if (0 != err) {
                handleError(err);
            } else {
                mutedVolume = volume;
            }
        } else {
            mutedVolume = volume;
        }
    }

    @Override
    protected float playerGetBalance() throws MediaException {
        final float[] balance = new float[1];
        handleError(iosGetBalance(iosMedia.getNativeMediaRef(), balance));
        return balance[0];
    }

    @Override
    protected void playerSetBalance(final float balance) throws MediaException {
        handleError(iosSetBalance(iosMedia.getNativeMediaRef(), balance));
    }

    @Override
    protected double playerGetDuration() throws MediaException {
        final double[] durationArr = new double[1];
        handleError(iosGetDuration(iosMedia.getNativeMediaRef(), durationArr));
        double duration;
        if (durationArr[0] == -1.0) {
            duration = Double.POSITIVE_INFINITY;
        } else {
            duration = durationArr[0];
        }
        return duration;
    }

    @Override
    protected void playerSeek(final double streamTime) throws MediaException {
        handleError(iosSeek(iosMedia.getNativeMediaRef(), streamTime));
    }

    @Override
    protected void playerInit() throws MediaException {
    }

    @Override
    protected void playerFinish() throws MediaException {
        handleError(iosFinish(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected void playerDispose() {
        iosDispose(iosMedia.getNativeMediaRef());
        iosMedia = null;
    }

    // Native methods
    private native int iosInitPlayer(long refNativeMedia);
    private native int iosGetAudioSyncDelay(long refNativeMedia, long[] syncDelay);
    private native int iosSetAudioSyncDelay(long refNativeMedia, long delay);
    private native int iosPlay(long refNativeMedia);
    private native int iosPause(long refNativeMedia);
    private native int iosStop(long refNativeMedia);
    private native int iosGetRate(long refNativeMedia, float[] rate);
    private native int iosSetRate(long refNativeMedia, float rate);
    private native int iosGetPresentationTime(long refNativeMedia, double[] time);
    private native int iosGetVolume(long refNativeMedia, float[] volume);
    private native int iosSetVolume(long refNativeMedia, float volume);
    private native int iosGetBalance(long refNativeMedia, float[] balance);
    private native int iosSetBalance(long refNativeMedia, float balance);
    private native int iosGetDuration(long refNativeMedia, double[] duration);
    private native int iosSeek(long refNativeMedia, double streamTime);
    private native void iosDispose(long refNativeMedia);
    private native int iosFinish(long refNativeMedia);

    // Overlay native methods
    private native int iosSetOverlayX(long mediaRef, double x);
    private native int iosSetOverlayY(long mediaRef, double y);
    private native int iosSetOverlayVisible(long mediaRef, boolean visible);
    private native int iosSetOverlayWidth(long mediaRef, double width);
    private native int iosSetOverlayHeight(long mediaRef, double height);
    private native int iosSetOverlayPreserveRatio(long mediaRef, boolean preserveRatio);
    private native int iosSetOverlayOpacity(long mediaRef, double opacity);
    private native int iosSetOverlayTransform(long mediaRef,
            double mxx, double mxy, double mxz, double mxt,
            double myx, double myy, double myz, double myt,
            double mzx, double mzy, double mzz, double mzt);

    private static final class NullAudioEQ implements AudioEqualizer {
        private boolean enabled = false;
        private Map&lt;Double, EqualizerBand&gt; bands
                = new HashMap&lt;Double,EqualizerBand&gt;();

        public boolean getEnabled() {
            return enabled;
        }

        public void setEnabled(boolean bEnable) {
            enabled = bEnable;
        }

        public EqualizerBand addBand(double centerFrequency, double bandwidth, double gain) {
            Double key = new Double(centerFrequency);
            if (bands.containsKey(key)) {
                removeBand(centerFrequency);
            }

            EqualizerBand newBand = new NullEQBand(centerFrequency, bandwidth, gain);
            bands.put(key, newBand);
            return newBand;
        }

        public boolean removeBand(double centerFrequency) {
            Double key = new Double(centerFrequency);
            if (bands.containsKey(key)) {
                bands.remove(key);
                return true;
            }
            return false;
        }
    }

    private static final class NullAudioSpectrum implements AudioSpectrum {
        private boolean enabled = false;
        private int bandCount = 128;
        private double interval = 0.1;
        private int threshold = 60;
        private float[] fakeData;

        public boolean getEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public int getBandCount() {
            return bandCount;
        }

        public void setBandCount(int bands) {
            bandCount = bands;
            fakeData = new float[bandCount];
        }

        public double getInterval() {
            return interval;
        }

        public void setInterval(double interval) {
            this.interval = interval;
        }

        public int getSensitivityThreshold() {
            return threshold;
        }

        public void setSensitivityThreshold(int threshold) {
            this.threshold = threshold;
        }

        public float[] getMagnitudes(float[] mag) {
            int size = fakeData.length;
            if (mag == null || mag.length &lt; size) {
                mag = new float[size];
            }
            System.arraycopy(fakeData, 0, mag, 0, size);
            return mag;
        }

        public float[] getPhases(float[] phs) {
            int size = fakeData.length;
            if (phs == null || phs.length &lt; size) {
                phs = new float[size];
            }
            System.arraycopy(fakeData, 0, phs, 0, size);
            return phs;
        }
    }

    private static final class NullEQBand implements EqualizerBand {
        private double center;
        private double bandwidth;
        private double gain;

        NullEQBand(double center, double bandwidth, double gain) {
            this.center = center;
            this.bandwidth = bandwidth;
            this.gain = gain;
        }

        public double getCenterFrequency() {
            return center;
        }

        public void setCenterFrequency(double centerFrequency) {
            center = centerFrequency;
        }

        public double getBandwidth() {
            return bandwidth;
        }

        public void setBandwidth(double bandwidth) {
            this.bandwidth = bandwidth;
        }

        public double getGain() {
            return gain;
        }

        public void setGain(double gain) {
            this.gain = gain;
        }
    }

    private final class MediaPlayerOverlayImpl implements MediaPlayerOverlay {

        @Override
        public void setOverlayX(final double x) {
            handleError(iosSetOverlayX(iosMedia.getNativeMediaRef(), x));
        }

        @Override
        public void setOverlayY(final double y) {
            handleError(iosSetOverlayY(iosMedia.getNativeMediaRef(), y));
        }

        @Override
        public void setOverlayVisible(final boolean visible) {
            handleError(iosSetOverlayVisible(iosMedia.getNativeMediaRef(), visible));
        }

        @Override
        public void setOverlayWidth(final double width) {
            handleError(iosSetOverlayWidth(iosMedia.getNativeMediaRef(), width));
        }

        @Override
        public void setOverlayHeight(final double height) {
            handleError(iosSetOverlayHeight(iosMedia.getNativeMediaRef(), height));
        }

        @Override
        public void setOverlayPreserveRatio(final boolean preserveRatio) {
            handleError(iosSetOverlayPreserveRatio(iosMedia.getNativeMediaRef(), preserveRatio));
        }

        @Override
        public void setOverlayOpacity(final double opacity) {
            handleError(iosSetOverlayOpacity(iosMedia.getNativeMediaRef(), opacity));
        }

        @Override
        public void setOverlayTransform(
                final double mxx, final double mxy, final double mxz, final double mxt,
                final double myx, final double myy, final double myz, final double myt,
                final double mzx, final double mzy, final double mzz, final double mzt) {
            handleError(iosSetOverlayTransform(
                    iosMedia.getNativeMediaRef(),
                    mxx, mxy, mxz, mxt,
                    myx, myy, myz, myt,
                    mzx, mzy, mzz, mzt));
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/javafx/embed/swing/SwingFXUtils.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.embed.swing;

import java.awt.AlphaComposite;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.awt.image.SampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.nio.IntBuffer;
import javafx.scene.image.Image;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.PixelReader;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.scene.image.WritablePixelFormat;
import javafx.scene.paint.Color;

/**
 * This class provides utility methods for converting data types between
 * Swing/AWT and JavaFX formats.
 * @since JavaFX 2.2
 */
public class SwingFXUtils {
    private SwingFXUtils() {} // no instances

    /**
     * Snapshots the specified {@link BufferedImage} and stores a copy of
     * its pixels into a JavaFX {@link Image} object, creating a new
     * object if needed.
     * The returned {@code Image} will be a static snapshot of the state
     * of the pixels in the {@code BufferedImage} at the time the method
     * completes.  Further changes to the {@code BufferedImage} will not
     * be reflected in the {@code Image}.
     * &lt;p&gt;
     * The optional JavaFX {@link WritableImage} parameter may be reused
     * to store the copy of the pixels.
     * A new {@code Image} will be created if the supplied object is null,
     * is too small or of a type which the image pixels cannot be easily
     * converted into.
     *
     * @param bimg the {@code BufferedImage} object to be converted
     * @param wimg an optional {@code WritableImage} object that can be
     *        used to store the returned pixel data
     * @return an {@code Image} object representing a snapshot of the
     *         current pixels in the {@code BufferedImage}.
     * @since JavaFX 2.2
     */
    public static WritableImage toFXImage(BufferedImage bimg, WritableImage wimg) {
        int bw = bimg.getWidth();
        int bh = bimg.getHeight();
        switch (bimg.getType()) {
            case BufferedImage.TYPE_INT_ARGB:
            case BufferedImage.TYPE_INT_ARGB_PRE:
                break;
            default:
                BufferedImage converted =
                    new BufferedImage(bw, bh, BufferedImage.TYPE_INT_ARGB_PRE);
                Graphics2D g2d = converted.createGraphics();
                g2d.drawImage(bimg, 0, 0, null);
                g2d.dispose();
                bimg = converted;
                break;
        }
        // assert(bimg.getType == TYPE_INT_ARGB[_PRE]);
        if (wimg != null) {
            int iw = (int) wimg.getWidth();
            int ih = (int) wimg.getHeight();
            if (iw &lt; bw || ih &lt; bh) {
                wimg = null;
            } else if (bw &lt; iw || bh &lt; ih) {
                int empty[] = new int[iw];
                PixelWriter pw = wimg.getPixelWriter();
                PixelFormat&lt;IntBuffer&gt; pf = PixelFormat.getIntArgbPreInstance();
                if (bw &lt; iw) {
                    pw.setPixels(bw, 0, iw-bw, bh, pf, empty, 0, 0);
                }
                if (bh &lt; ih) {
                    pw.setPixels(0, bh, iw, ih-bh, pf, empty, 0, 0);
                }
            }
        }
        if (wimg == null) {
            wimg = new WritableImage(bw, bh);
        }
        PixelWriter pw = wimg.getPixelWriter();
        DataBufferInt db = (DataBufferInt)bimg.getRaster().getDataBuffer();
        int data[] = db.getData();
        int offset = bimg.getRaster().getDataBuffer().getOffset();
        int scan =  0;
        SampleModel sm = bimg.getRaster().getSampleModel();
        if (sm instanceof SinglePixelPackedSampleModel) {
            scan = ((SinglePixelPackedSampleModel)sm).getScanlineStride();
        }

        PixelFormat&lt;IntBuffer&gt; pf = (bimg.isAlphaPremultiplied() ?
                                     PixelFormat.getIntArgbPreInstance() :
                                     PixelFormat.getIntArgbInstance());
        pw.setPixels(0, 0, bw, bh, pf, data, offset, scan);
        return wimg;
    }

    /**
     * Determine the optimal BufferedImage type to use for the specified
     * {@code fxFormat} allowing for the specified {@code bimg} to be used
     * as a potential default storage space if it is not null and is compatible.
     *
     * @param fxFormat the PixelFormat of the source FX Image
     * @param bimg an optional existing {@code BufferedImage} to be used
     *             for storage if it is compatible, or null
     * @return
     */
    static int
            getBestBufferedImageType(PixelFormat&lt;?&gt; fxFormat, BufferedImage bimg,
                                     boolean isOpaque)
    {
        if (bimg != null) {
            int bimgType = bimg.getType();
            if (bimgType == BufferedImage.TYPE_INT_ARGB ||
                bimgType == BufferedImage.TYPE_INT_ARGB_PRE ||
                (isOpaque &amp;&amp;
                     (bimgType == BufferedImage.TYPE_INT_BGR ||
                      bimgType == BufferedImage.TYPE_INT_RGB)))
            {
                // We will allow the caller to give us a BufferedImage
                // that has an alpha channel, but we might not otherwise
                // construct one ourselves.
                // We will also allow them to choose their own premultiply
                // type which may not match the image.
                // If left to our own devices we might choose a more specific
                // format as indicated by the choices below.
                return bimgType;
            }
        }
        switch (fxFormat.getType()) {
            default:
            case BYTE_BGRA_PRE:
            case INT_ARGB_PRE:
                return BufferedImage.TYPE_INT_ARGB_PRE;
            case BYTE_BGRA:
            case INT_ARGB:
                return BufferedImage.TYPE_INT_ARGB;
            case BYTE_RGB:
                return BufferedImage.TYPE_INT_RGB;
            case BYTE_INDEXED:
                return (fxFormat.isPremultiplied()
                        ? BufferedImage.TYPE_INT_ARGB_PRE
                        : BufferedImage.TYPE_INT_ARGB);
        }
    }

    /**
     * Determine the appropriate {@link WritablePixelFormat} type that can
     * be used to transfer data into the indicated BufferedImage.
     *
     * @param bimg the BufferedImage that will be used as a destination for
     *             a {@code PixelReader&lt;IntBuffer&gt;#getPixels()} operation.
     * @return
     */
    private static WritablePixelFormat&lt;IntBuffer&gt;
        getAssociatedPixelFormat(BufferedImage bimg)
    {
        switch (bimg.getType()) {
            // We lie here for xRGB, but we vetted that the src data was opaque
            // so we can ignore the alpha.  We use ArgbPre instead of Argb
            // just to get a loop that does not have divides in it if the
            // PixelReader happens to not know the data is opaque.
            case BufferedImage.TYPE_INT_RGB:
            case BufferedImage.TYPE_INT_ARGB_PRE:
                return PixelFormat.getIntArgbPreInstance();
            case BufferedImage.TYPE_INT_ARGB:
                return PixelFormat.getIntArgbInstance();
            default:
                // Should not happen...
                throw new InternalError(&quot;Failed to validate BufferedImage type&quot;);
        }
    }

    private static boolean checkFXImageOpaque(PixelReader pr, int iw, int ih) {
        for (int x = 0; x &lt; iw; x++) {
            for (int y = 0; y &lt; ih; y++) {
                Color color = pr.getColor(x,y);
                if (color.getOpacity() != 1.0) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Snapshots the specified JavaFX {@link Image} object and stores a
     * copy of its pixels into a {@link BufferedImage} object, creating
     * a new object if needed.
     * The method will only convert a JavaFX {@code Image} that is readable
     * as per the conditions on the
     * {@link Image#getPixelReader() Image.getPixelReader()}
     * method.
     * If the {@code Image} is not readable, as determined by its
     * {@code getPixelReader()} method, then this method will return null.
     * If the {@code Image} is a writable, or other dynamic image, then
     * the {@code BufferedImage} will only be set to the current state of
     * the pixels in the image as determined by its {@link PixelReader}.
     * Further changes to the pixels of the {@code Image} will not be
     * reflected in the returned {@code BufferedImage}.
     * &lt;p&gt;
     * The optional {@code BufferedImage} parameter may be reused to store
     * the copy of the pixels.
     * A new {@code BufferedImage} will be created if the supplied object
     * is null, is too small or of a type which the image pixels cannot
     * be easily converted into.
     *
     * @param img the JavaFX {@code Image} to be converted
     * @param bimg an optional {@code BufferedImage} object that may be
     *        used to store the returned pixel data
     * @return a {@code BufferedImage} containing a snapshot of the JavaFX
     *         {@code Image}, or null if the {@code Image} is not readable.
     * @since JavaFX 2.2
     */
    public static BufferedImage fromFXImage(Image img, BufferedImage bimg) {
        PixelReader pr = img.getPixelReader();
        if (pr == null) {
            return null;
        }
        int iw = (int) img.getWidth();
        int ih = (int) img.getHeight();
        PixelFormat&lt;?&gt; fxFormat = pr.getPixelFormat();
        boolean srcPixelsAreOpaque = false;
        switch (fxFormat.getType()) {
            case INT_ARGB_PRE:
            case INT_ARGB:
            case BYTE_BGRA_PRE:
            case BYTE_BGRA:
                // Check fx image opacity only if
                // supplied BufferedImage is without alpha channel
                if (bimg != null &amp;&amp;
                        (bimg.getType() == BufferedImage.TYPE_INT_BGR ||
                         bimg.getType() == BufferedImage.TYPE_INT_RGB)) {
                    srcPixelsAreOpaque = checkFXImageOpaque(pr, iw, ih);
                }
                break;
            case BYTE_RGB:
                srcPixelsAreOpaque = true;
                break;
        }
        int prefBimgType = getBestBufferedImageType(pr.getPixelFormat(), bimg, srcPixelsAreOpaque);
        if (bimg != null) {
            int bw = bimg.getWidth();
            int bh = bimg.getHeight();
<A NAME="76"></A>            if (bw &lt; iw || bh &lt; ih || bimg.getType() != prefBimgType) {
                bimg = null;
            } else if (iw &lt; bw || ih &lt; bh) {
                <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#76',2,'match42-top.html#76',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Graphics2D g2d = bimg.createGraphics();
                g2d.setComposite(AlphaComposite.Clear);
                g2d.fillRect(0, 0, bw, bh);
                g2d.dispose();
            }
        }</B></FONT>
        if (bimg == null) {
            bimg = new BufferedImage(iw, ih, prefBimgType);
        }
        DataBufferInt db = (DataBufferInt)bimg.getRaster().getDataBuffer();
        int data[] = db.getData();
        int offset = bimg.getRaster().getDataBuffer().getOffset();
        int scan =  0;
        SampleModel sm = bimg.getRaster().getSampleModel();
        if (sm instanceof SinglePixelPackedSampleModel) {
            scan = ((SinglePixelPackedSampleModel)sm).getScanlineStride();
        }

        WritablePixelFormat&lt;IntBuffer&gt; pf = getAssociatedPixelFormat(bimg);
        pr.getPixels(0, 0, iw, ih, pf, data, offset, scan);
        return bimg;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/javafx/embed/swing/SwingNode.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.embed.swing;

import javax.swing.JComponent;
import javax.swing.Timer;
import java.awt.AWTEvent;
import java.awt.EventQueue;
import java.awt.Toolkit;
import java.awt.event.InputEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.WindowEvent;
import java.awt.event.WindowFocusListener;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.stage.Window;
import java.lang.ref.WeakReference;
import java.nio.IntBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.embed.swing.Disposer;
import com.sun.javafx.embed.swing.DisposerRecord;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.sg.prism.NGExternalNode;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.stage.FocusUngrabEvent;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.scene.NodeHelper;
import static javafx.stage.WindowEvent.WINDOW_HIDDEN;

import com.sun.javafx.embed.swing.SwingNodeHelper;
import com.sun.javafx.embed.swing.SwingEvents;
import com.sun.javafx.embed.swing.InteropFactory;
import com.sun.javafx.embed.swing.SwingNodeInterop;

/**
 * This class is used to embed a Swing content into a JavaFX application.
 * The content to be displayed is specified with the {@link #setContent} method
 * that accepts an instance of Swing {@code JComponent}. The hierarchy of components
 * contained in the {@code JComponent} instance should not contain any heavyweight
 * components, otherwise {@code SwingNode} may fail to paint it. The content gets
 * repainted automatically. All the input and focus events are forwarded to the
 * {@code JComponent} instance transparently to the developer.
 * &lt;p&gt;
 * Here is a typical pattern which demonstrates how {@code SwingNode} can be used:
 * &lt;pre&gt;
 *     public class SwingFx extends Application {
 *
 *         &amp;#064;Override
 *         public void start(Stage stage) {
 *             final SwingNode swingNode = new SwingNode();
 *             createAndSetSwingContent(swingNode);
 *
 *             StackPane pane = new StackPane();
 *             pane.getChildren().add(swingNode);
 *
 *             stage.setScene(new Scene(pane, 100, 50));
 *             stage.show();
 *         }
 *
 *         private void createAndSetSwingContent(final SwingNode swingNode) {
 *             SwingUtilities.invokeLater(new Runnable() {
 *                 &amp;#064;Override
 *                 public void run() {
 *                     swingNode.setContent(new JButton(&quot;Click me!&quot;));
 *                 }
 *             });
 *         }
 *
 *         public static void main(String[] args) {
 *             launch(args);
 *         }
 *     }
 * &lt;/pre&gt;
 * @since JavaFX 8.0
 */
public class SwingNode extends Node {
    private static boolean isThreadMerged;
    private SwingNodeInterop swNodeIOP;
    private static InteropFactory iopFactoryInstance = null;

    static {
        try {
            iopFactoryInstance = InteropFactory.getInstance();
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }

        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
            public Object run() {
                isThreadMerged = Boolean.valueOf(
                        System.getProperty(&quot;javafx.embed.singleThread&quot;));
                return null;
            }
        });


         // This is used by classes in different packages to get access to
         // private and package private methods.
        SwingNodeHelper.setSwingNodeAccessor(new SwingNodeHelper.SwingNodeAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((SwingNode) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((SwingNode) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((SwingNode) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((SwingNode) node).doComputeContains(localX, localY);
            }

            @Override
            public Object getLightweightFrame(SwingNode node) {
                return node.getLightweightFrame();
            }

            @Override
            public ReentrantLock getPaintLock(SwingNode node) {
                return node.getPaintLock();
            }

            @Override
            public void setImageBuffer(SwingNode node, final int[] data,
                               final int x, final int y,
                               final int w, final int h, final int linestride,
                               final double scaleX, final double scaleY) {
                node.setImageBuffer(data, x, y, w, h, linestride, scaleX, scaleY);
            }

            @Override
            public void setImageBounds(SwingNode node, final int x, final int y,
                               final int w, final int h) {
                node.setImageBounds(x, y, w, h);
            }

            @Override
            public void repaintDirtyRegion(SwingNode node, final int dirtyX, final int dirtyY,
                               final int dirtyWidth, final int dirtyHeight) {
                node.repaintDirtyRegion(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            }

            @Override
            public void ungrabFocus(SwingNode node, boolean postUngrabEvent) {
                node.ungrabFocus(postUngrabEvent);
            }

            @Override
            public void setSwingPrefWidth(SwingNode node, int swingPrefWidth) {
                node.swingPrefWidth = swingPrefWidth;
            }

            @Override
            public void setSwingPrefHeight(SwingNode node, int swingPrefHeight) {
                node.swingPrefHeight = swingPrefHeight;
            }

            @Override
            public void setSwingMaxWidth(SwingNode node, int swingMaxWidth) {
                node.swingMaxWidth = swingMaxWidth;
            }

            @Override
            public void setSwingMaxHeight(SwingNode node, int swingMaxHeight) {
                node.swingMaxHeight = swingMaxHeight;
            }

            @Override
            public void setSwingMinWidth(SwingNode node, int swingMinWidth) {
                node.swingMinWidth = swingMinWidth;
            }

            @Override
            public void setSwingMinHeight(SwingNode node, int swingMinHeight) {
                node.swingMinHeight = swingMinHeight;
            }

            @Override
            public void setGrabbed(SwingNode node, boolean grab) {
                node.grabbed = grab;
            }
        });
    }

    private double fxWidth;
    private double fxHeight;
    private int swingPrefWidth;
    private int swingPrefHeight;
    private int swingMaxWidth;
    private int swingMaxHeight;
    private int swingMinWidth;
    private int swingMinHeight;

    private volatile JComponent content;
    private volatile Object lwFrame;
    private final Object getLightweightFrame() { return lwFrame; }

    private NGExternalNode peer;

    private final ReentrantLock paintLock = new ReentrantLock();

    private ReentrantLock getPaintLock() {
        return paintLock;
    }

    private boolean skipBackwardUnrgabNotification;
    private boolean grabbed; // lwframe initiated grab
    private Timer deactivate; // lwFrame deactivate delay for Linux

    {
        // To initialize the class helper at the begining each constructor of this class
        SwingNodeHelper.initHelper(this);
    }

    /**
     * Constructs a new instance of {@code SwingNode}.
     */
    public SwingNode() {
        swNodeIOP = iopFactoryInstance.createSwingNodeImpl();
        setFocusTraversable(true);
        setEventHandler(MouseEvent.ANY, new SwingMouseEventHandler());
        setEventHandler(KeyEvent.ANY, new SwingKeyEventHandler());
        setEventHandler(ScrollEvent.SCROLL, new SwingScrollEventHandler());

        focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
             activateLwFrame(newValue);
        });

        //Workaround for RT-34170
        javafx.scene.text.Font.getFamilies();
    }


    private EventHandler windowHiddenHandler = (Event event) -&gt; {
        if (lwFrame != null &amp;&amp;  event.getTarget() instanceof Window) {
            final Window w = (Window) event.getTarget();
            TKStage tk = WindowHelper.getPeer(w);
            if (tk != null) {
                if (isThreadMerged) {
                    swNodeIOP.overrideNativeWindowHandle(lwFrame, 0L, null);
                } else {
                    // Postpone actual window closing to ensure that
                    // a native window handler is valid on a Swing side
                    tk.postponeClose();
                    SwingNodeHelper.runOnEDT(() -&gt; {
                        swNodeIOP.overrideNativeWindowHandle(lwFrame, 0L,
                            (Runnable) () -&gt; SwingNodeHelper.runOnFxThread(
                                        () -&gt; tk.closePostponed()));
                    });
                }
            }
        }

    };

    private Window hWindow = null;
    private void notifyNativeHandle(Window window) {
        if (hWindow != window) {
            if (hWindow != null) {
                hWindow.removeEventHandler(WINDOW_HIDDEN, windowHiddenHandler);
            }
            if (window != null) {
                window.addEventHandler(WINDOW_HIDDEN, windowHiddenHandler);
            }
            hWindow = window;
        }

        if (lwFrame != null) {
            long rawHandle = 0L;
            if (window != null) {
                TKStage tkStage = WindowHelper.getPeer(window);
                if (tkStage != null) {
                    rawHandle = tkStage.getRawHandle();
                }
            }
            swNodeIOP.overrideNativeWindowHandle(lwFrame, rawHandle, null);
        }
    }

    /**
     * Attaches a {@code JComponent} instance to display in this {@code SwingNode}.
     * &lt;p&gt;
     * The method can be called either on the JavaFX Application thread or the Event Dispatch thread.
     * Note however, that access to a Swing component must occur from the Event Dispatch thread
     * according to the Swing threading restrictions.
     *
     * @param content a Swing component to display in this {@code SwingNode}
     *
     * @see java.awt.EventQueue#isDispatchThread()
     * @see javafx.application.Platform#isFxApplicationThread()
     */
    public void setContent(final JComponent content) {
        this.content = content;

        SwingNodeHelper.runOnEDT(() -&gt; setContentImpl(content));
    }

    /**
     * Returns the {@code JComponent} instance attached to this {@code SwingNode}.
     * &lt;p&gt;
     * The method can be called either on the JavaFX Application thread or the Event Dispatch thread.
     * Note however, that access to a Swing component must occur from the Event Dispatch thread
     * according to the Swing threading restrictions.
     *
     * @see java.awt.EventQueue#isDispatchThread()
     * @see javafx.application.Platform#isFxApplicationThread()
     *
     * @return the Swing component attached to this {@code SwingNode}
     */
    public JComponent getContent() {
        return content;
    }

    /*
     * Called on EDT
     */
    private void setContentImpl(JComponent content) {
        if (lwFrame != null) {
            swNodeIOP.disposeFrame(lwFrame);
            lwFrame = null;
        }
        if (content != null) {
            lwFrame = swNodeIOP.createLightweightFrame();

            SwingNodeWindowFocusListener snfListener =
                                 new SwingNodeWindowFocusListener(this);
            swNodeIOP.addWindowFocusListener(lwFrame, snfListener);

            if (getScene() != null) {
                Window window = getScene().getWindow();
                if (window != null) {
                    swNodeIOP.notifyDisplayChanged(lwFrame, window.getRenderScaleX(),
                                               window.getRenderScaleY());
                }
            }
            swNodeIOP.setContent(lwFrame, swNodeIOP.createSwingNodeContent(content, this));
            swNodeIOP.setVisible(lwFrame, true);

            Disposer.addRecord(this, swNodeIOP.createSwingNodeDisposer(lwFrame));

            if (getScene() != null) {
                notifyNativeHandle(getScene().getWindow());
            }

            SwingNodeHelper.runOnFxThread(() -&gt; {
                locateLwFrame();// initialize location

                if (focusedProperty().get()) {
                    activateLwFrame(true);
                }
            });
        }
    }

    private List&lt;Runnable&gt; peerRequests = new ArrayList&lt;&gt;();

    /*
     * Called on EDT
     */
    void setImageBuffer(final int[] data,
                        final int x, final int y,
                        final int w, final int h,
                        final int linestride,
                        final double scaleX,
                        final double scaleY)
    {
        Runnable r = () -&gt; peer.setImageBuffer(IntBuffer.wrap(data), x, y, w, h,
                                w, h, linestride, scaleX, scaleY);
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if (peer != null) {
                r.run();
            } else {
                peerRequests.clear();
                peerRequests.add(r);
            }
        });
    }

    /*
     * Called on EDT
     */
    void setImageBounds(final int x, final int y, final int w, final int h) {
        Runnable r = () -&gt; peer.setImageBounds(x, y, w, h, w, h);
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if (peer != null) {
                r.run();
            } else {
                peerRequests.add(r);
            }
        });
    }

    /*
     * Called on EDT
     */
    void repaintDirtyRegion(final int dirtyX, final int dirtyY, final int dirtyWidth, final int dirtyHeight) {
        Runnable r = () -&gt; {
            peer.repaintDirtyRegion(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
        };
        SwingNodeHelper.runOnFxThread(() -&gt; {
            if (peer != null) {
                r.run();
            } else {
                peerRequests.add(r);
            }
        });
    }

    @Override public boolean isResizable() {
        return true;
    }

    /**
     * Invoked by the {@code SwingNode}'s parent during layout to set the {@code SwingNode}'s
     * width and height. &lt;b&gt;Applications should not invoke this method directly&lt;/b&gt;.
     * If an application needs to directly set the size of the {@code SwingNode}, it should
     * set the Swing component's minimum/preferred/maximum size constraints which will
     * be propagated correspondingly to the {@code SwingNode} and it's parent will honor those
     * settings during layout.
     *
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     */
    @Override public void resize(final double width, final double height) {
        super.resize(width, height);
        if (width != this.fxWidth || height != this.fxHeight) {
            this.fxWidth = width;
            this.fxHeight = height;
            NodeHelper.geomChanged(this);
            NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
            SwingNodeHelper.runOnEDT(() -&gt; {
                if (lwFrame != null) {
                    locateLwFrame();
                }
            });
        }
    }

    /**
     * Returns the {@code SwingNode}'s preferred width for use in layout calculations.
     * This value corresponds to the preferred width of the Swing component.
     *
     * @return the preferred width that the node should be resized to during layout
     */
    @Override
    public double prefWidth(double height) {
        return swingPrefWidth;
    }

    /**
     * Returns the {@code SwingNode}'s preferred height for use in layout calculations.
     * This value corresponds to the preferred height of the Swing component.
     *
     * @return the preferred height that the node should be resized to during layout
     */
    @Override
    public double prefHeight(double width) {
        return swingPrefHeight;
    }

    /**
     * Returns the {@code SwingNode}'s maximum width for use in layout calculations.
     * This value corresponds to the maximum width of the Swing component.
     *
     * @return the maximum width that the node should be resized to during layout
     */
    @Override public double maxWidth(double height) {
        return swingMaxWidth;
    }

    /**
     * Returns the {@code SwingNode}'s maximum height for use in layout calculations.
     * This value corresponds to the maximum height of the Swing component.
     *
     * @return the maximum height that the node should be resized to during layout
     */
    @Override public double maxHeight(double width) {
        return swingMaxHeight;
    }

    /**
     * Returns the {@code SwingNode}'s minimum width for use in layout calculations.
     * This value corresponds to the minimum width of the Swing component.
     *
     * @return the minimum width that the node should be resized to during layout
     */
    @Override public double minWidth(double height) {
        return swingMinWidth;
    }

    /**
     * Returns the {@code SwingNode}'s minimum height for use in layout calculations.
     * This value corresponds to the minimum height of the Swing component.
     *
     * @return the minimum height that the node should be resized to during layout
     */
    @Override public double minHeight(double width) {
        return swingMinHeight;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        return true;
    }

    private final InvalidationListener locationListener = observable -&gt; {
        locateLwFrame();
    };

    private final EventHandler&lt;FocusUngrabEvent&gt; ungrabHandler = event -&gt; {
        if (!skipBackwardUnrgabNotification) {
            if (lwFrame != null) {
                AccessController.doPrivileged(new PostEventAction(
                    swNodeIOP.createUngrabEvent(lwFrame)));
            }
        }
    };

    private final ChangeListener&lt;Boolean&gt; windowVisibleListener = (observable, oldValue, newValue) -&gt; {
        if (!newValue) {
            disposeLwFrame();
        } else {
            setContent(content);
        }
    };

    private final ChangeListener&lt;Window&gt; sceneWindowListener = (observable, oldValue, newValue) -&gt; {
        if (oldValue != null) {
            removeWindowListeners(oldValue);
        }

        notifyNativeHandle(newValue);

        if (newValue != null) {
            addWindowListeners(newValue);
        }
    };

    private void removeSceneListeners(Scene scene) {
        Window window = scene.getWindow();
        if (window != null) {
            removeWindowListeners(window);
        }
        scene.windowProperty().removeListener(sceneWindowListener);
    }

    private void addSceneListeners(final Scene scene) {
        Window window = scene.getWindow();
        if (window != null) {
            addWindowListeners(window);
            notifyNativeHandle(window);
        }
        scene.windowProperty().addListener(sceneWindowListener);
    }

    private void addWindowListeners(final Window window) {
        window.xProperty().addListener(locationListener);
        window.yProperty().addListener(locationListener);
        window.widthProperty().addListener(locationListener);
        window.heightProperty().addListener(locationListener);
        window.renderScaleXProperty().addListener(locationListener);
        window.addEventHandler(FocusUngrabEvent.FOCUS_UNGRAB, ungrabHandler);
        window.showingProperty().addListener(windowVisibleListener);
        setLwFrameScale(window.getRenderScaleX(), window.getRenderScaleY());
    }

    private void removeWindowListeners(final Window window) {
        window.xProperty().removeListener(locationListener);
<A NAME="39"></A>        window.yProperty().removeListener(locationListener);
        window.widthProperty().removeListener(locationListener);
        window.heightProperty().removeListener(locationListener);
        <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#39',2,'match42-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>window.renderScaleXProperty().removeListener(locationListener);
        window.removeEventHandler(FocusUngrabEvent.FOCUS_UNGRAB, ungrabHandler);
        window.showingProperty().removeListener(windowVisibleListener);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        peer = new</B></FONT> NGExternalNode();
        peer.setLock(paintLock);
        for (Runnable request : peerRequests) {
            request.run();
        }
        peerRequests = null;

        if (getScene() != null) {
            addSceneListeners(getScene());
        }

        sceneProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != null) {
                // Removed from scene
                removeSceneListeners(oldValue);
                disposeLwFrame();
            }
            if (newValue != null) {
                // Added to another scene
                if (content != null &amp;&amp; lwFrame == null) {
                    setContent(content);
                }
                addSceneListeners(newValue);
            }
        });

        NodeHelper.treeVisibleProperty(this).addListener((observable, oldValue, newValue) -&gt; {
            setLwFrameVisible(newValue);
        });

        return peer;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        if (NodeHelper.isDirty(this, DirtyBits.NODE_VISIBLE)
                || NodeHelper.isDirty(this, DirtyBits.NODE_BOUNDS)) {
            locateLwFrame(); // initialize location
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.markContentDirty();
        }
    }

    private void locateLwFrame() {
        if (getScene() == null
                || lwFrame == null
                || getScene().getWindow() == null
                || !getScene().getWindow().isShowing()) {
            // Not initialized yet. Skip the update to set the real values later
            return;
        }
        Window w = getScene().getWindow();
        double renderScaleX = w.getRenderScaleX();
        double renderScaleY = w.getRenderScaleY();
        final Point2D loc = localToScene(0, 0);
        final int windowX = (int) (w.getX());
        final int windowY = (int) (w.getY());
        final int windowW = (int) (w.getWidth());
        final int windowH = (int) (w.getHeight());
        final int frameX = (int) Math.round(w.getX() + getScene().getX() + loc.getX());
        final int frameY = (int) Math.round(w.getY() + getScene().getY() + loc.getY());
        final int frameW = (int) (fxWidth);
        final int frameH = (int) (fxHeight);

        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.notifyDisplayChanged(lwFrame, renderScaleX, renderScaleY);
                swNodeIOP.setBounds(lwFrame, frameX, frameY, frameW, frameH);
                swNodeIOP.setHostBounds(lwFrame, windowX, windowY, windowW, windowH);
            }
        });
    }

    private void activateLwFrame(final boolean activate) {
        if (lwFrame == null) {
            return;
        }
        if (PlatformUtil.isLinux()) {
            // Workaround to block FocusOut/FocusIn notifications from Unity
            // focus grabbing upon Alt press
            if (deactivate == null || !deactivate.isRunning()) {
                if (!activate) {
                    deactivate = new Timer(50, (e) -&gt; {
                        {
                            if (lwFrame != null) {
                                swNodeIOP.emulateActivation(lwFrame, false);
                            }
                        }
                    });
                    deactivate.start();
                    return;
                }
            } else {
                deactivate.stop();
            }
        }

        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.emulateActivation(lwFrame, activate);
            }
        });
    }

    private void disposeLwFrame() {
        if (lwFrame == null) {
            return;
        }
        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.disposeFrame(lwFrame);
                lwFrame = null;
            }
        });
    }

    private void setLwFrameVisible(final boolean visible) {
        if (lwFrame == null) {
            return;
        }
        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.setVisible(lwFrame, visible);
            }
        });
    }

    private void setLwFrameScale(final double scaleX, final double scaleY) {
        if (lwFrame == null) {
            return;
        }
        SwingNodeHelper.runOnEDT(() -&gt; {
            if (lwFrame != null) {
                swNodeIOP.notifyDisplayChanged(lwFrame, scaleX, scaleY);
        }
    });
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        bounds.deriveWithNewBounds(0, 0, 0, (float)fxWidth, (float)fxHeight, 0);
        tx.transform(bounds, bounds);
        return bounds;
    }


    private static class SwingNodeWindowFocusListener implements WindowFocusListener {
        private WeakReference&lt;SwingNode&gt; swingNodeRef;

        SwingNodeWindowFocusListener(SwingNode swingNode) {
            this.swingNodeRef = new WeakReference&lt;SwingNode&gt;(swingNode);
        }

        @Override
        public void windowGainedFocus(WindowEvent e) {
            SwingNodeHelper.runOnFxThread(() -&gt; {
                SwingNode swingNode = swingNodeRef.get();
                if (swingNode != null) {
                    swingNode.requestFocus();
                }
            });
        }

        @Override
        public void windowLostFocus(WindowEvent e) {
            SwingNodeHelper.runOnFxThread(() -&gt; {
                SwingNode swingNode = swingNodeRef.get();
                if (swingNode != null) {
                    swingNode.ungrabFocus(true);
                }
            });
        }
    }

    private void ungrabFocus(boolean postUngrabEvent) {
        // On X11 grab is limited to a single XDisplay connection,
        // so we can't delegate it to another GUI toolkit.
        if (PlatformUtil.isLinux()) return;

        if (grabbed &amp;&amp;
            getScene() != null &amp;&amp;
            getScene().getWindow() != null &amp;&amp;
            WindowHelper.getPeer(getScene().getWindow()) != null)
        {
            skipBackwardUnrgabNotification = !postUngrabEvent;
            WindowHelper.getPeer(getScene().getWindow()).ungrabFocus();
            skipBackwardUnrgabNotification = false;
            grabbed = false;
        }
    }

    private class PostEventAction implements PrivilegedAction&lt;Void&gt; {
        private AWTEvent event;
        PostEventAction(AWTEvent event) {
            this.event = event;
        }
        @Override
        public Void run() {
            EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue();
            eq.postEvent(event);
            return null;
        }
    }

    private class SwingMouseEventHandler implements EventHandler&lt;MouseEvent&gt; {
        private final Set&lt;MouseButton&gt; mouseClickedAllowed = new HashSet&lt;&gt;();

        @Override
        public void handle(MouseEvent event) {
            Object frame = swNodeIOP.getLightweightFrame();
            if (frame == null) {
                return;
            }
            int swingID = SwingEvents.fxMouseEventTypeToMouseID(event);
            if (swingID &lt; 0) {
                return;
            }

            // Prevent ancestors of the SwingNode from stealing the focus
            event.consume();

            final EventType&lt;?&gt; type = event.getEventType();
            if (type == MouseEvent.MOUSE_PRESSED) {
                mouseClickedAllowed.add(event.getButton());
            } else if (type == MouseEvent.MOUSE_RELEASED) {
                // RELEASED comes before CLICKED, so we don't remove the button from the set
                //mouseClickedAllowed.remove(event.getButton());
            } else if (type == MouseEvent.MOUSE_DRAGGED) {
                // This is what AWT/Swing do
                mouseClickedAllowed.clear();
            } else if (type == MouseEvent.MOUSE_CLICKED) {
                if (event.getClickCount() == 1 &amp;&amp; !mouseClickedAllowed.contains(event.getButton())) {
                    // RT-34610: In FX, CLICKED events are generated even after dragging the mouse pointer
                    // Note that this is only relevant for single clicks. Double clicks use a smudge factor.
                    return;
                }
                mouseClickedAllowed.remove(event.getButton());
            }
            int swingModifiers = SwingEvents.fxMouseModsToMouseMods(event);
            boolean swingPopupTrigger = event.isPopupTrigger();
            int swingButton = SwingEvents.fxMouseButtonToMouseButton(event);
            long swingWhen = System.currentTimeMillis();
            int relX = (int) Math.round(event.getX());
            int relY = (int) Math.round(event.getY());
            int absX = (int) Math.round(event.getScreenX());
            int absY = (int) Math.round(event.getScreenY());
            java.awt.event.MouseEvent mouseEvent =
                    swNodeIOP.createMouseEvent(
                        frame, swingID, swingWhen, swingModifiers,
                        relX, relY, absX, absY,
                        event.getClickCount(), swingPopupTrigger, swingButton);
            AccessController.doPrivileged(new PostEventAction(mouseEvent));
        }
    }

    private class SwingScrollEventHandler implements EventHandler&lt;ScrollEvent&gt; {
        @Override
        public void handle(ScrollEvent event) {
            Object frame = swNodeIOP.getLightweightFrame();
            if (frame == null) {
                return;
            }

            int swingModifiers = SwingEvents.fxScrollModsToMouseWheelMods(event);
            final boolean isShift = (swingModifiers &amp; InputEvent.SHIFT_DOWN_MASK) != 0;

            // Vertical scroll.
            if (!isShift &amp;&amp; event.getDeltaY() != 0.0) {
                sendMouseWheelEvent(frame, event.getX(), event.getY(),
                        swingModifiers, event.getDeltaY() / event.getMultiplierY());
            }
            // Horizontal scroll or shirt+vertical scroll.
            final double delta = isShift &amp;&amp; event.getDeltaY() != 0.0
                                  ? event.getDeltaY() / event.getMultiplierY()
                                  : event.getDeltaX() / event.getMultiplierX();
            if (delta != 0.0) {
                swingModifiers |= InputEvent.SHIFT_DOWN_MASK;
                sendMouseWheelEvent(frame, event.getX(), event.getY(),
                        swingModifiers, delta);
            }
        }

        private void sendMouseWheelEvent(Object source, double fxX, double fxY, int swingModifiers, double delta) {
            int wheelRotation = (int) delta;
            int signum = (int) Math.signum(delta);
            if (signum * delta &lt; 1) {
                wheelRotation = signum;
            }
            int x = (int) Math.round(fxX);
            int y = (int) Math.round(fxY);
            MouseWheelEvent mouseWheelEvent =
                swNodeIOP.createMouseWheelEvent(source, swingModifiers, x, y, -wheelRotation);
            AccessController.doPrivileged(new PostEventAction(mouseWheelEvent));
        }
    }

    private class SwingKeyEventHandler implements EventHandler&lt;KeyEvent&gt; {
        @Override
        public void handle(KeyEvent event) {
            Object frame = swNodeIOP.getLightweightFrame();
            if (frame == null) {
                return;
            }
            if (event.getCharacter().isEmpty()) {
                // TODO: should we post an &quot;empty&quot; character?
                return;
            }
            // Don't let Arrows, Tab, Shift+Tab traverse focus out.
            if (event.getCode() == KeyCode.LEFT  ||
                event.getCode() == KeyCode.RIGHT ||
                event.getCode() == KeyCode.UP ||
                event.getCode() == KeyCode.DOWN ||
                event.getCode() == KeyCode.TAB)
            {
                event.consume();
            }

            int swingID = SwingEvents.fxKeyEventTypeToKeyID(event);
            if (swingID &lt; 0) {
                return;
            }
            int swingModifiers = SwingEvents.fxKeyModsToKeyMods(event);
            int swingKeyCode = event.getCode().getCode();
            char swingChar = event.getCharacter().charAt(0);

            // A workaround. Some swing L&amp;F's process mnemonics on KEY_PRESSED,
            // for which swing provides a keychar. Extracting it from the text.
            if (event.getEventType() == javafx.scene.input.KeyEvent.KEY_PRESSED) {
                String text = event.getText();
                if (text.length() == 1) {
                    swingChar = text.charAt(0);
                }
            }
            long swingWhen = System.currentTimeMillis();
            java.awt.event.KeyEvent keyEvent = swNodeIOP.createKeyEvent(frame,
                swingID, swingWhen, swingModifiers, swingKeyCode,
                swingChar);
            AccessController.doPrivileged(new PostEventAction(keyEvent));
        }
    }
}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/CursorManagerImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="0"></A> * questions.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#0',2,'match42-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.webkit;

import com.sun.javafx.tk.Toolkit;
import com.sun.webkit.CursorManager;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.graphics.WCImage;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javafx.scene.Cursor;
import javafx.scene.ImageCursor;
import javafx.scene.image.Image;

public final class CursorManagerImpl extends CursorManager&lt;Cursor&gt; {

    private final Map&lt;String, Cursor&gt; map = new HashMap&lt;String, Cursor&gt;();
    private ResourceBundle bundle;

    @Override protected Cursor getCustomCursor(WCImage image</B></FONT>, int hotspotX, int hotspotY) {
        return new ImageCursor(
                Toolkit.getImageAccessor().fromPlatformImage(
                    WCGraphicsManager.getGraphicsManager().toPlatformImage(image)),
                hotspotX, hotspotY);
    }

    @Override protected Cursor getPredefinedCursor(int type) {
        switch (type) {
            default:
            case POINTER:                      return                                   Cursor.DEFAULT;
            case CROSS:                        return                                   Cursor.CROSSHAIR;
            case HAND:                         return                                   Cursor.HAND;
            case MOVE:                         return                                   Cursor.MOVE;
            case TEXT:                         return                                   Cursor.TEXT;
            case WAIT:                         return                                   Cursor.WAIT;
            case HELP:                         return getCustomCursor(&quot;help&quot;,           Cursor.DEFAULT);
            case EAST_RESIZE:                  return                                   Cursor.E_RESIZE;
            case NORTH_RESIZE:                 return                                   Cursor.N_RESIZE;
            case NORTH_EAST_RESIZE:            return                                   Cursor.NE_RESIZE;
            case NORTH_WEST_RESIZE:            return                                   Cursor.NW_RESIZE;
            case SOUTH_RESIZE:                 return                                   Cursor.S_RESIZE;
            case SOUTH_EAST_RESIZE:            return                                   Cursor.SE_RESIZE;
            case SOUTH_WEST_RESIZE:            return                                   Cursor.SW_RESIZE;
            case WEST_RESIZE:                  return                                   Cursor.W_RESIZE;
            case NORTH_SOUTH_RESIZE:           return                                   Cursor.V_RESIZE;
            case EAST_WEST_RESIZE:             return                                   Cursor.H_RESIZE;
            case NORTH_EAST_SOUTH_WEST_RESIZE: return getCustomCursor(&quot;resize.nesw&quot;,    Cursor.DEFAULT);
            case NORTH_WEST_SOUTH_EAST_RESIZE: return getCustomCursor(&quot;resize.nwse&quot;,    Cursor.DEFAULT);
            case COLUMN_RESIZE:                return getCustomCursor(&quot;resize.column&quot;,  Cursor.H_RESIZE);
            case ROW_RESIZE:                   return getCustomCursor(&quot;resize.row&quot;,     Cursor.V_RESIZE);
            case MIDDLE_PANNING:               return getCustomCursor(&quot;panning.middle&quot;, Cursor.DEFAULT);
            case EAST_PANNING:                 return getCustomCursor(&quot;panning.east&quot;,   Cursor.DEFAULT);
            case NORTH_PANNING:                return getCustomCursor(&quot;panning.north&quot;,  Cursor.DEFAULT);
            case NORTH_EAST_PANNING:           return getCustomCursor(&quot;panning.ne&quot;,     Cursor.DEFAULT);
            case NORTH_WEST_PANNING:           return getCustomCursor(&quot;panning.nw&quot;,     Cursor.DEFAULT);
            case SOUTH_PANNING:                return getCustomCursor(&quot;panning.south&quot;,  Cursor.DEFAULT);
            case SOUTH_EAST_PANNING:           return getCustomCursor(&quot;panning.se&quot;,     Cursor.DEFAULT);
            case SOUTH_WEST_PANNING:           return getCustomCursor(&quot;panning.sw&quot;,     Cursor.DEFAULT);
            case WEST_PANNING:                 return getCustomCursor(&quot;panning.west&quot;,   Cursor.DEFAULT);
            case VERTICAL_TEXT:                return getCustomCursor(&quot;vertical.text&quot;,  Cursor.DEFAULT);
            case CELL:                         return getCustomCursor(&quot;cell&quot;,           Cursor.DEFAULT);
            case CONTEXT_MENU:                 return getCustomCursor(&quot;context.menu&quot;,   Cursor.DEFAULT);
            case NO_DROP:                      return getCustomCursor(&quot;no.drop&quot;,        Cursor.DEFAULT);
            case NOT_ALLOWED:                  return getCustomCursor(&quot;not.allowed&quot;,    Cursor.DEFAULT);
            case PROGRESS:                     return getCustomCursor(&quot;progress&quot;,       Cursor.WAIT);
            case ALIAS:                        return getCustomCursor(&quot;alias&quot;,          Cursor.DEFAULT);
            case ZOOM_IN:                      return getCustomCursor(&quot;zoom.in&quot;,        Cursor.DEFAULT);
            case ZOOM_OUT:                     return getCustomCursor(&quot;zoom.out&quot;,       Cursor.DEFAULT);
            case COPY:                         return getCustomCursor(&quot;copy&quot;,           Cursor.DEFAULT);
            case NONE:                         return                                   Cursor.NONE;
            case GRAB:                         return getCustomCursor(&quot;grab&quot;,           Cursor.OPEN_HAND);
            case GRABBING:                     return getCustomCursor(&quot;grabbing&quot;,       Cursor.CLOSED_HAND);
        }
    }

    private Cursor getCustomCursor(String name, Cursor predefined) {
        Cursor cursor = this.map.get(name);
        if (cursor == null) {
            try {
                if (bundle == null) {
                    bundle = ResourceBundle.getBundle(&quot;com.sun.javafx.webkit.Cursors&quot;, Locale.getDefault());
                }
                if (bundle != null) {
                    String resource = bundle.getString(name + &quot;.file&quot;);
                    Image image = new Image(CursorManagerImpl.class.getResourceAsStream(resource));

                    resource = bundle.getString(name + &quot;.hotspotX&quot;);
                    int hotspotX = Integer.parseInt(resource);

                    resource = bundle.getString(name + &quot;.hotspotY&quot;);
                    int hotspotY = Integer.parseInt(resource);

                    cursor = new ImageCursor(image, hotspotX, hotspotY);
                }
            } catch (MissingResourceException e) {
                // ignore, treat cursor as missing, use predefined instead
            }
            if (cursor == null) {
                cursor = predefined;
            }
            this.map.put(name, cursor);
        }
        return cursor;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/network/Cookie.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.network;

import com.sun.javafx.logging.PlatformLogger;

import java.net.URI;
import java.text.ParseException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * An RFC 6265-compliant cookie.
 */
final class Cookie {

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(Cookie.class.getName());
    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(
            &quot;(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})&quot;);


    private final String name;
    private final String value;
    private final long expiryTime;
    private String domain;
    private String path;
    private ExtendedTime creationTime;
    private long lastAccessTime;
    private final boolean persistent;
    private boolean hostOnly;
    private final boolean secureOnly;
    private final boolean httpOnly;


    /**
     * Creates a new {@code Cookie}.
     */
    private Cookie(String name, String value, long expiryTime, String domain,
            String path, ExtendedTime creationTime, long lastAccessTime,
            boolean persistent, boolean hostOnly, boolean secureOnly,
            boolean httpOnly)
    {
        this.name = name;
        this.value = value;
        this.expiryTime = expiryTime;
        this.domain = domain;
        this.path = path;
        this.creationTime = creationTime;
        this.lastAccessTime = lastAccessTime;
        this.persistent = persistent;
        this.hostOnly = hostOnly;
        this.secureOnly = secureOnly;
        this.httpOnly = httpOnly;
    }


    /**
     * Parses a {@code Set-Cookie} header string into a {@code Cookie}
     * object.
     */
    static Cookie parse(String setCookieString, ExtendedTime currentTime) {
        logger.finest(&quot;setCookieString: [{0}]&quot;, setCookieString);

        String[] items = setCookieString.split(&quot;;&quot;, -1);

        String[] nameValuePair = items[0].split(&quot;=&quot;, 2);
        if (nameValuePair.length != 2) {
            logger.finest(&quot;Name-value pair string lacks '=', &quot;
                    + &quot;ignoring cookie&quot;);
            return null;
        }
        String name = nameValuePair[0].trim();
        String value = nameValuePair[1].trim();
        if (name.length() == 0) {
            logger.finest(&quot;Name string is empty, ignoring cookie&quot;);
            return null;
        }

        Long expires = null;
        Long maxAge = null;
        String domain = null;
        String path = null;
        boolean secure = false;
        boolean httpOnly = false;

        for (int i = 1; i &lt; items.length; i++) {
            String[] terms = items[i].split(&quot;=&quot;, 2);
            String attrName = terms[0].trim();
            String attrValue = (terms.length &gt; 1 ? terms[1] : &quot;&quot;).trim();

            try {
                if (&quot;Expires&quot;.equalsIgnoreCase(attrName)) {
                    expires = parseExpires(attrValue);
                } else if (&quot;Max-Age&quot;.equalsIgnoreCase(attrName)) {
                    maxAge = parseMaxAge(attrValue, currentTime.baseTime());
                } else if (&quot;Domain&quot;.equalsIgnoreCase(attrName)) {
                    domain = parseDomain(attrValue);
                } else if (&quot;Path&quot;.equalsIgnoreCase(attrName)) {
                    path = parsePath(attrValue);
                } else if (&quot;Secure&quot;.equalsIgnoreCase(attrName)) {
                    secure = true;
                } else if (&quot;HttpOnly&quot;.equalsIgnoreCase(attrName)) {
                    httpOnly = true;
                } else {
                    logger.finest(&quot;Unknown attribute: [{0}], &quot;
                            + &quot;ignoring&quot;, attrName);
                }
            } catch (ParseException ex) {
                logger.finest(&quot;{0}, ignoring&quot;, ex.getMessage());
            }
        }

        long expiryTime;
        boolean persistent;
        if (maxAge != null) {
            persistent = true;
            expiryTime = maxAge;
        } else if (expires != null) {
            persistent = true;
            expiryTime = expires;
        } else {
            persistent = false;
            expiryTime = Long.MAX_VALUE;
        }

        if (domain == null) {
            domain = &quot;&quot;;
        }

        Cookie result = new Cookie(name, value, expiryTime, domain, path,
                currentTime, currentTime.baseTime(), persistent, false,
                secure, httpOnly);
        logger.finest(&quot;result: {0}&quot;, result);
        return result;
    }

    /**
     * Parses the value of the {@code Expires} attribute.
     */
    private static long parseExpires(String attributeValue)
        throws ParseException
    {
        try {
            return Math.max(DateParser.parse(attributeValue), 0);
        } catch (ParseException ex) {
            throw new ParseException(&quot;Error parsing Expires attribute&quot;, 0);
        }
    }

    /**
     * Parses the value of the {@code Max-Age} attribute.
     */
    private static long parseMaxAge(String attributeValue, long currentTime)
        throws ParseException
    {
        try {
            long maxAge = Long.parseLong(attributeValue);
            if (maxAge &lt;= 0) {
                return 0;
            } else {
                return maxAge &gt; (Long.MAX_VALUE - currentTime) / 1000
                        ? Long.MAX_VALUE : currentTime + maxAge * 1000;
            }
        } catch (NumberFormatException ex) {
            throw new ParseException(&quot;Error parsing Max-Age attribute&quot;, 0);
        }
    }

    /**
     * Parses the value of the {@code Domain} attribute.
     */
    private static String parseDomain(String attributeValue)
        throws ParseException
    {
        if (attributeValue.length() == 0) {
            throw new ParseException(&quot;Domain attribute is empty&quot;, 0);
        }
        if (attributeValue.startsWith(&quot;.&quot;)) {
            attributeValue = attributeValue.substring(1);
        }
        return attributeValue.toLowerCase();
    }

    /**
     * Parses the value of the {@code Path} attribute.
     */
    private static String parsePath(String attributeValue) {
        return attributeValue.startsWith(&quot;/&quot;) ? attributeValue : null;
    }


    /**
     * Returns the name of this cookie.
     */
    String getName() {
        return name;
    }

    /**
     * Returns the value of this cookie.
     */
    String getValue() {
        return value;
    }

    /**
     * Returns the expiry time of this cookie.
     */
    long getExpiryTime() {
        return expiryTime;
    }

    /**
     * Returns the domain of this cookie.
     */
    String getDomain() {
        return domain;
    }

    /**
     * Sets the domain of this cookie.
     */
    void setDomain(String domain) {
        this.domain = domain;
    }

    /**
     * Returns the path of this cookie.
     */
    String getPath() {
        return path;
    }

    /**
     * Sets the path of this cookie.
     */
    void setPath(String path) {
        this.path = path;
    }

    /**
     * Returns the creation time of this cookie.
     */
    ExtendedTime getCreationTime() {
        return creationTime;
    }

    /**
     * Sets the creation time of this cookie.
<A NAME="12"></A>     */
    void setCreationTime(ExtendedTime creationTime) {
        this.creationTime = creationTime;
    <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#12',2,'match42-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Returns the last access time of this cookie.
     */
    long getLastAccessTime() {
        return lastAccessTime;
    }

    /**
     * Sets the last access time of this cookie.
     */
    void setLastAccessTime(long lastAccessTime) {
        this.lastAccessTime = lastAccessTime;
    }

    /**
     * Returns the persistent property of this cookie.
     */
    boolean getPersistent() {
        return persistent;
    }

    /**
     * Returns the host-only property of this cookie.
     */
    boolean getHostOnly() {
        return hostOnly;
    }

    /**
     * Sets the host-only property of this cookie.
     */
    void setHostOnly(boolean hostOnly) {
        this.hostOnly = hostOnly;
    }

    /**
     * Returns the secure-only property of this cookie.
     */
    boolean getSecureOnly() {
        return secureOnly;
    }

    /**
     * Returns the http-only property of this cookie.
     */
    boolean getHttpOnly() {
        return httpOnly;
    }

    /**
     * Determines if this cookie has expired.
     */
    boolean hasExpired() {
        return</B></FONT> System.currentTimeMillis() &gt; expiryTime;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Cookie) {
            Cookie cookie = (Cookie) obj;
            return equal(name, cookie.name)
                    &amp;&amp; equal(domain, cookie.domain)
                    &amp;&amp; equal(path, cookie.path);
        } else {
            return false;
        }
    }

    /**
     * Determines, in null-safe manner, if two objects are equal.
     */
    private static boolean equal(Object obj1, Object obj2) {
        return (obj1 == null &amp;&amp; obj2 == null)
                || (obj1 != null &amp;&amp; obj1.equals(obj2));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        int hashCode = 7;
        hashCode = 53 * hashCode + hashCode(name);
        hashCode = 53 * hashCode + hashCode(domain);
        hashCode = 53 * hashCode + hashCode(path);
        return hashCode;
    }

    /**
     * Computes the hash code of an object in null safe-manner.
     */
    private static int hashCode(Object obj) {
        return obj != null ? obj.hashCode() : 0;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
        return &quot;[name=&quot; + name + &quot;, value=&quot; + value + &quot;, &quot;
                + &quot;expiryTime=&quot; + expiryTime + &quot;, domain=&quot; + domain + &quot;, &quot;
                + &quot;path=&quot; + path + &quot;, creationTime=&quot; + creationTime + &quot;, &quot;
                + &quot;lastAccessTime=&quot; + lastAccessTime + &quot;, &quot;
                + &quot;persistent=&quot; + persistent + &quot;, hostOnly=&quot; + hostOnly + &quot;, &quot;
                + &quot;secureOnly=&quot; + secureOnly + &quot;, httpOnly=&quot; + httpOnly + &quot;]&quot;;
    }

    /**
     * Determines if a domain matches another domain.
     */
    static boolean domainMatches(String domain, String cookieDomain) {
        return domain.endsWith(cookieDomain) &amp;&amp; (
                domain.length() == cookieDomain.length()
                || domain.charAt(domain.length()
                        - cookieDomain.length() - 1) == '.'
                &amp;&amp; !isIpAddress(domain));
    }

    /**
     * Determines if a hostname is an IP address.
     */
    private static boolean isIpAddress(String hostname) {
        Matcher matcher = IP_ADDRESS_PATTERN.matcher(hostname);
        if (!matcher.matches()) {
            return false;
        }
        for (int i = 1; i &lt;= matcher.groupCount(); i++) {
            if (Integer.parseInt(matcher.group(i)) &gt; 255) {
                return false;
            }
        }
        return true;
    }

    /**
     * Computes the default path for a given URI.
     */
    static String defaultPath(URI uri) {
        String path = uri.getPath();
        if (path == null || !path.startsWith(&quot;/&quot;)) {
            return &quot;/&quot;;
        }
        path = path.substring(0, path.lastIndexOf(&quot;/&quot;));
        if (path.length() == 0) {
            return &quot;/&quot;;
        }
        return path;
    }

    /**
     * Determines if a path matches another path.
     */
    static boolean pathMatches(String path, String cookiePath) {
        return path != null &amp;&amp; path.startsWith(cookiePath) &amp;&amp; (
                path.length() == cookiePath.length()
                || cookiePath.endsWith(&quot;/&quot;)
                || path.charAt(cookiePath.length()) == '/');
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/network/URLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.network;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.webkit.Invoker;
import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.WebPage;
import static com.sun.webkit.network.URLs.newURL;
import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.lang.annotation.Native;
import java.net.ConnectException;
import java.net.HttpRetryException;
<A NAME="41"></A>import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.NoRouteToHostException;
<FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#41',2,'match42-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.security.AccessControlException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.zip.GZIPInputStream;
import java.util.zip.InflaterInputStream;
import javax.net.ssl.SSLHandshakeException;

/**
 * A runnable that loads a resource specified by a URL.
 */
final class URLLoader implements Runnable {

    @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;

    private static final PlatformLogger logger =</B></FONT>
            PlatformLogger.getLogger(URLLoader.class.getName());
    private static final int MAX_REDIRECTS = 10;
    private static final int MAX_BUF_COUNT = 3;
    private static final String GET = &quot;GET&quot;;
    private static final String HEAD = &quot;HEAD&quot;;
    private static final String DELETE = &quot;DELETE&quot;;


    private final WebPage webPage;
    private final ByteBufferPool byteBufferPool;
    private final boolean asynchronous;
    private String url;
    private String method;
    private final String headers;
    private FormDataElement[] formDataElements;
    private final long data;
    private volatile boolean canceled = false;


    /**
     * Creates a new {@code URLLoader}.
     */
    URLLoader(WebPage webPage,
              ByteBufferPool byteBufferPool,
              boolean asynchronous,
              String url,
              String method,
              String headers,
              FormDataElement[] formDataElements,
              long data)
    {
        this.webPage = webPage;
        this.byteBufferPool = byteBufferPool;
        this.asynchronous = asynchronous;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.formDataElements = formDataElements;
        this.data = data;
    }


    /**
     * Cancels this loader.
     */
    private void fwkCancel() {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
        }
        canceled = true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void run() {
        // Run the loader in the page's access control context
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            doRun();
            return null;
        }, webPage.getAccessControlContext());
    }

    /**
     * Executes this loader.
     */
    private void doRun() {
        Throwable error = null;
        int errorCode = 0;
        try {
            int redirectCount = 0;
            boolean streaming = true;
            boolean connectionResetRetry = true;
            while (true) {
                // RT-14438
                String actualUrl = url;
                if (url.startsWith(&quot;file:&quot;)) {
                    int questionMarkPosition = url.indexOf('?');
                    if (questionMarkPosition != -1) {
                        actualUrl = url.substring(0, questionMarkPosition);
                    }
                }

                URL urlObject = newURL(actualUrl);

                // RT-22458
                workaround7177996(urlObject);

                URLConnection c = urlObject.openConnection();
                prepareConnection(c);

                Redirect redirect = null;
                try {
                    sendRequest(c, streaming);
                    redirect = receiveResponse(c);
                } catch (HttpRetryException ex) {
                    // RT-19914
                    if (streaming) {
                        streaming = false;
                        continue; // retry without streaming
                    } else {
                        throw ex;
                    }
                } catch (SocketException ex) {
                    // SocketException: Connection reset, Retry once
                    if (&quot;Connection reset&quot;.equals(ex.getMessage()) &amp;&amp; connectionResetRetry) {
                        connectionResetRetry = false;
                        continue;
                    } else {
                        throw ex;
                    }
                } finally {
                    close(c);
                }

                if (redirect != null) {
                    if (redirectCount++ &gt;= MAX_REDIRECTS) {
                        throw new TooManyRedirectsException();
                    }
                    boolean resetRequest = !redirect.preserveRequest
                            &amp;&amp; !method.equals(GET) &amp;&amp; !method.equals(HEAD);
                    String newMethod = resetRequest ? GET : method;
                    willSendRequest(redirect.url, newMethod, c);
                    // willSendRequest() may cancel this loader
                    if (canceled) {
                        break;
                    }
                    url = redirect.url;
                    method = newMethod;
                    formDataElements = resetRequest ? null : formDataElements;
                } else {
                    break;
                }
            }
        } catch (MalformedURLException ex) {
            error = ex;
            errorCode = LoadListenerClient.MALFORMED_URL;
        } catch (AccessControlException ex) {
            error = ex;
            errorCode = LoadListenerClient.PERMISSION_DENIED;
        } catch (UnknownHostException ex) {
            error = ex;
            errorCode = LoadListenerClient.UNKNOWN_HOST;
        } catch (NoRouteToHostException ex) {
            error = ex;
            errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;
        } catch (ConnectException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_REFUSED;
        } catch (SocketException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_RESET;
        } catch (SSLHandshakeException ex) {
            error = ex;
            errorCode = LoadListenerClient.SSL_HANDSHAKE;
        } catch (SocketTimeoutException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_TIMED_OUT;
        } catch (InvalidResponseException ex) {
            error = ex;
            errorCode = LoadListenerClient.INVALID_RESPONSE;
        } catch (TooManyRedirectsException ex) {
            error = ex;
            errorCode = LoadListenerClient.TOO_MANY_REDIRECTS;
        } catch (FileNotFoundException ex) {
            error = ex;
            errorCode = LoadListenerClient.FILE_NOT_FOUND;
        } catch (Throwable th) {
            error = th;
            errorCode = LoadListenerClient.UNKNOWN_ERROR;
        }

        if (error != null) {
            if (errorCode == LoadListenerClient.UNKNOWN_ERROR) {
                logger.warning(&quot;Unexpected error&quot;, error);
            } else {
                logger.finest(&quot;Load error&quot;, error);
            }
            didFail(errorCode, error.getMessage());
        }
    }

    private static void workaround7177996(URL url)
        throws FileNotFoundException
    {
        if (!url.getProtocol().equals(&quot;file&quot;)) {
            return;
        }

        String host = url.getHost();
        if (host == null || host.equals(&quot;&quot;) || host.equals(&quot;~&quot;)
                || host.equalsIgnoreCase(&quot;localhost&quot;) )
        {
           return;
        }

        if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
            String path = null;
            try {
                path = URLDecoder.decode(url.getPath(), &quot;UTF-8&quot;);
            } catch (UnsupportedEncodingException e) {
                // The system should always have the platform default
            }
            path = path.replace('/', '\\');
            path = path.replace('|', ':');
            File file = new File(&quot;\\\\&quot; + host + path);
            if (!file.exists()) {
                throw new FileNotFoundException(&quot;File not found: &quot; + url);
            }
        } else {
            throw new FileNotFoundException(&quot;File not found: &quot; + url);
        }
    }

    /**
     * Prepares a connection.
     */
    private void prepareConnection(URLConnection c) throws IOException {
        // The following two timeouts are quite arbitrary and should
        // probably be configurable via an API
        c.setConnectTimeout(30000);   // 30 seconds
        c.setReadTimeout(60000 * 60); // 60 minutes

        // Given that WebKit has its own cache, do not use
        // any URLConnection caches, even if someone installs them.
        // As a side effect, this fixes the problem of WebPane not
        // working well with the plug-in cache, which was one of
        // the causes for RT-11880.
        c.setUseCaches(false);

        Locale loc = Locale.getDefault();
        String lang = &quot;&quot;;
        if (!loc.equals(Locale.US) &amp;&amp; !loc.equals(Locale.ENGLISH)) {
            lang = loc.getCountry().isEmpty() ?
                loc.getLanguage() + &quot;,&quot;:
                loc.getLanguage() + &quot;-&quot; + loc.getCountry() + &quot;,&quot;;
        }
        c.setRequestProperty(&quot;Accept-Language&quot;, lang.toLowerCase() + &quot;en-us;q=0.8,en;q=0.7&quot;);
        c.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);
        c.setRequestProperty(&quot;Accept-Charset&quot;, &quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;);

        if (headers != null &amp;&amp; headers.length() &gt; 0) {
            for (String h : headers.split(&quot;\n&quot;)) {
                int i = h.indexOf(':');
                if (i &gt; 0) {
                    c.addRequestProperty(h.substring(0, i), h.substring(i + 2));
                }
            }
        }

        if (c instanceof HttpURLConnection) {
            HttpURLConnection httpConnection = (HttpURLConnection) c;
            httpConnection.setRequestMethod(method);
            // There are too many bugs in the way HttpURLConnection handles
            // redirects, so we will deal with them ourselves
            httpConnection.setInstanceFollowRedirects(false);
        }
    }

    /**
     * Sends request to the server.
     */
    private void sendRequest(URLConnection c, boolean streaming)
        throws IOException
    {
        OutputStream out = null;
        try {
            long bytesToBeSent = 0;
            boolean sendFormData = formDataElements != null
                    &amp;&amp; c instanceof HttpURLConnection
                    &amp;&amp; !method.equals(DELETE);
            boolean isGetOrHead = method.equals(GET) || method.equals(HEAD);
            if (sendFormData) {
                c.setDoOutput(true);

                for (FormDataElement formDataElement : formDataElements) {
                    formDataElement.open();
                    bytesToBeSent += formDataElement.getSize();
                }

                if (streaming) {
                    HttpURLConnection http = (HttpURLConnection) c;
                    if (bytesToBeSent &lt;= Integer.MAX_VALUE) {
                        http.setFixedLengthStreamingMode((int) bytesToBeSent);
                    } else {
                        http.setChunkedStreamingMode(0);
                    }
                }
            } else if (!isGetOrHead &amp;&amp; (c instanceof HttpURLConnection)) {
                c.setRequestProperty(&quot;Content-Length&quot;, &quot;0&quot;);
            }

            int maxTryCount = isGetOrHead ? 3 : 1;
            c.setConnectTimeout(c.getConnectTimeout() / maxTryCount);
            int tryCount = 0;
            while (!canceled) {
                try {
                    c.connect();
                    break;
                } catch (SocketTimeoutException ex) {
                    if (++tryCount &gt;= maxTryCount) {
                        throw ex;
                    }
                } catch (IllegalArgumentException ex) {
                    // Happens with some malformed URLs
                    throw new MalformedURLException(url);
                }
            }

            if (sendFormData) {
                out = c.getOutputStream();
                byte[] buffer = new byte[4096];
                long bytesSent = 0;
                for (FormDataElement formDataElement : formDataElements) {
                    InputStream in = formDataElement.getInputStream();
                    int count;
                    while ((count = in.read(buffer)) &gt; 0) {
                        out.write(buffer, 0, count);
                        bytesSent += count;
                        didSendData(bytesSent, bytesToBeSent);
                    }
                    formDataElement.close();
                }
                out.flush();
                out.close();
                out = null;
            }
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ignore) {}
            }
            if (formDataElements != null &amp;&amp; c instanceof HttpURLConnection) {
                for (FormDataElement formDataElement : formDataElements) {
                    try {
                        formDataElement.close();
                    } catch (IOException ignore) {}
                }
            }
        }
    }

    /**
     * Receives response from the server.
     */
    private Redirect receiveResponse(URLConnection c)
        throws IOException, InterruptedException
    {
        if (canceled) {
            return null;
        }

        InputStream errorStream = null;

        if (c instanceof HttpURLConnection) {
            HttpURLConnection http = (HttpURLConnection) c;

            int code = http.getResponseCode();
            if (code == -1) {
                throw new InvalidResponseException();
            }

            if (canceled) {
                return null;
            }

            // See RT-17435
            switch (code) {
                case 301: // Moved Permanently
                case 302: // Found
                case 303: // See Other
                case 307: // Temporary Redirect
                    String newLoc = http.getHeaderField(&quot;Location&quot;);
                    if (newLoc != null) {
                        URL newUrl;
                        try {
                            newUrl = newURL(newLoc);
                        } catch (MalformedURLException mue) {
                            // Try to treat newLoc as a relative URI to conform
                            // to popular browsers
                            newUrl = newURL(c.getURL(), newLoc);
                        }
                        return new Redirect(newUrl.toExternalForm(),
                                            code == 307);
                    }
                    break;

                case 304: // Not Modified
                    didReceiveResponse(c);
                    didFinishLoading();
                    return null;
            }

            if (code &gt;= 400 &amp;&amp; !method.equals(HEAD)) {
                errorStream = http.getErrorStream();
            }
        }

        // Let's see if it's an ftp (or ftps) URL and we need to transform
        // a directory listing into HTML
        if (url.startsWith(&quot;ftp:&quot;) || url.startsWith(&quot;ftps:&quot;)) {
            boolean dir = false;
            boolean notsure = false;
            // Unfortunately, there is no clear way to determine if we are
            // accessing a directory, so a bit of guessing is in order
            String path = c.getURL().getPath();
            if (path == null || path.isEmpty() || path.endsWith(&quot;/&quot;)
                    || path.contains(&quot;;type=d&quot;))
            {
                dir = true;
            } else {
                String type = c.getContentType();
                if (&quot;text/plain&quot;.equalsIgnoreCase(type)
                        || &quot;text/html&quot;.equalsIgnoreCase(type))
                {
                    dir = true;
                    notsure = true;
                }
            }
            if (dir) {
                c = new DirectoryURLConnection(c, notsure);
            }
        }

        // Same is true for FileURLConnection
        if (url.startsWith(&quot;file:&quot;)) {
            if(&quot;text/plain&quot;.equals(c.getContentType())
                    &amp;&amp; c.getHeaderField(&quot;content-length&quot;) == null)
            {
                // It is a directory
                c = new DirectoryURLConnection(c);
            }
        }

        didReceiveResponse(c);

        if (method.equals(HEAD)) {
            didFinishLoading();
            return null;
        }

        InputStream inputStream = null;
        try {
            inputStream = errorStream == null
                ? c.getInputStream() : errorStream;
        } catch (HttpRetryException ex) {
            // HttpRetryException is handled from doRun() method.
            // Hence rethrowing the exception to caller(doRun() method)
            throw ex;
        } catch (IOException e) {
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
                    e.getClass().getSimpleName(),
                    e.getMessage()));
            }
        }

        String encoding = c.getContentEncoding();
        if (inputStream != null) {
            try {
                if (&quot;gzip&quot;.equalsIgnoreCase(encoding)) {
                    inputStream = new GZIPInputStream(inputStream);
                } else if (&quot;deflate&quot;.equalsIgnoreCase(encoding)) {
                    inputStream = new InflaterInputStream(inputStream);
                }
            } catch (IOException e) {
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
                        e.getClass().getSimpleName(),
                        e.getMessage()));
                }
            }
        }

        ByteBufferAllocator allocator =
                byteBufferPool.newAllocator(MAX_BUF_COUNT);
        ByteBuffer byteBuffer = null;
        try {
            if (inputStream != null) {
                // 8192 is the default size of a BufferedInputStream used in
                // most URLConnections, by using the same size, we avoid quite
                // a few System.arrayCopy() calls
                byte[] buffer = new byte[8192];
                while (!canceled) {
                    int count;
                    try {
                        count = inputStream.read(buffer);
                    } catch (EOFException ex) {
                        // can be thrown by GZIPInputStream signaling
                        // the end of the stream
                        count = -1;
                    }

                    if (count == -1) {
                        break;
                    }

                    if (byteBuffer == null) {
                        byteBuffer = allocator.allocate();
                    }

                    int remaining = byteBuffer.remaining();
                    if (count &lt; remaining) {
                        byteBuffer.put(buffer, 0, count);
                    } else {
                        byteBuffer.put(buffer, 0, remaining);

                        byteBuffer.flip();
                        didReceiveData(byteBuffer, allocator);
                        byteBuffer = null;

                        int outstanding = count - remaining;
                        if (outstanding &gt; 0) {
                            byteBuffer = allocator.allocate();
                            byteBuffer.put(buffer, remaining, outstanding);
                        }
                    }
                }
            }
            if (!canceled) {
                if (byteBuffer != null &amp;&amp; byteBuffer.position() &gt; 0) {
                    byteBuffer.flip();
                    didReceiveData(byteBuffer, allocator);
                    byteBuffer = null;
                }
                didFinishLoading();
            }
        } finally {
            if (byteBuffer != null) {
                byteBuffer.clear();
                allocator.release(byteBuffer);
            }
        }
        return null;
    }

    /**
     * Releases the resources that may be associated with a connection.
     */
    private static void close(URLConnection c) {
        if (c instanceof HttpURLConnection) {
            InputStream errorStream = ((HttpURLConnection) c).getErrorStream();
            if (errorStream != null) {
                try {
                    errorStream.close();
                } catch (IOException ignore) {}
            }
        }
        try {
            c.getInputStream().close();
        } catch (IOException ignore) {}
    }


    /**
     * A holder for redirect information.
     */
    private static final class Redirect {
        private final String url;
        private final boolean preserveRequest;

        private Redirect(String url, boolean preserveRequest) {
            this.url = url;
            this.preserveRequest = preserveRequest;
        }
    }

    /**
     * Signals an invalid response from the server.
     */
    private static final class InvalidResponseException extends IOException {
        private InvalidResponseException() {
            super(&quot;Invalid server response&quot;);
        }
    }

    /**
     * Signals that too many redirects have been encountered
     * while processing the request.
     */
    private static final class TooManyRedirectsException extends IOException {
        private TooManyRedirectsException() {
            super(&quot;Too many redirects&quot;);
        }
    }

    private void didSendData(final long totalBytesSent,
                             final long totalBytesToBeSent)
    {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidSendData(totalBytesSent, totalBytesToBeSent);
            }
        });
    }

    private void notifyDidSendData(long totalBytesSent,
                                   long totalBytesToBeSent)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;totalBytesSent: [%d], &quot;
                    + &quot;totalBytesToBeSent: [%d], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    totalBytesSent,
                    totalBytesToBeSent,
                    data));
        }
        twkDidSendData(totalBytesSent, totalBytesToBeSent, data);
    }

    private void willSendRequest(String newUrl,
                                 final String newMethod,
                                 URLConnection c) throws InterruptedException
    {
        final String adjustedNewUrl = adjustUrlForWebKit(newUrl);
        final int status = extractStatus(c);
        final String contentType = c.getContentType();
        final String contentEncoding = extractContentEncoding(c);
        final long contentLength = extractContentLength(c);
        final String responseHeaders = extractHeaders(c);
        final String adjustedUrl = adjustUrlForWebKit(url);
        final CountDownLatch latch =
                asynchronous ? new CountDownLatch(1) : null;
        callBack(() -&gt; {
            try {
                if (!canceled) {
                    boolean keepGoing = notifyWillSendRequest(
                            adjustedNewUrl,
                            newMethod,
                            status,
                            contentType,
                            contentEncoding,
                            contentLength,
                            responseHeaders,
                            adjustedUrl);
                    if (!keepGoing) {
                        fwkCancel();
                    }
                }
            } finally {
                if (latch != null) {
                    latch.countDown();
                }
            }
        });
        if (latch != null) {
            latch.await();
        }
    }

    private boolean notifyWillSendRequest(String newUrl,
                                          String newMethod,
                                          int status,
                                          String contentType,
                                          String contentEncoding,
                                          long contentLength,
                                          String headers,
                                          String url)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;newUrl: [%s], &quot;
                    + &quot;newMethod: [%s], &quot;
                    + &quot;status: [%d], &quot;
                    + &quot;contentType: [%s], &quot;
                    + &quot;contentEncoding: [%s], &quot;
                    + &quot;contentLength: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;data: [0x%016X], &quot;
                    + &quot;headers:%n%s&quot;,
                    newUrl,
                    newMethod,
                    status,
                    contentType,
                    contentEncoding,
                    contentLength,
                    url,
                    data,
                    Util.formatHeaders(headers)));
        }
        boolean result = twkWillSendRequest(
                newUrl,
                newMethod,
                status,
                contentType,
                contentEncoding,
                contentLength,
                headers,
                url,
                data);
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;result: [%s]&quot;, result));
        }
        return result;
    }

    private void didReceiveResponse(URLConnection c) {
        final int status = extractStatus(c);
        final String contentType = c.getContentType();
        final String contentEncoding = extractContentEncoding(c);
        final long contentLength = extractContentLength(c);
        final String responseHeaders = extractHeaders(c);
        final String adjustedUrl = adjustUrlForWebKit(url);
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidReceiveResponse(
                        status,
                        contentType,
                        contentEncoding,
                        contentLength,
                        responseHeaders,
                        adjustedUrl);
            }
        });
    }

    private void notifyDidReceiveResponse(int status,
                                          String contentType,
                                          String contentEncoding,
                                          long contentLength,
                                          String headers,
                                          String url)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;status: [%d], &quot;
                    + &quot;contentType: [%s], &quot;
                    + &quot;contentEncoding: [%s], &quot;
                    + &quot;contentLength: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;data: [0x%016X], &quot;
                    + &quot;headers:%n%s&quot;,
                    status,
                    contentType,
                    contentEncoding,
                    contentLength,
                    url,
                    data,
                    Util.formatHeaders(headers)));
        }
        twkDidReceiveResponse(
                status,
                contentType,
                contentEncoding,
                contentLength,
                headers,
                url,
                data);
    }

    private void didReceiveData(final ByteBuffer byteBuffer,
                                final ByteBufferAllocator allocator)
    {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidReceiveData(
                        byteBuffer,
                        byteBuffer.position(),
                        byteBuffer.remaining());
            }
            byteBuffer.clear();
            allocator.release(byteBuffer);
        });
    }

    private void notifyDidReceiveData(ByteBuffer byteBuffer,
                                      int position,
                                      int remaining)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;byteBuffer: [%s], &quot;
                    + &quot;position: [%s], &quot;
                    + &quot;remaining: [%s], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    byteBuffer,
                    position,
                    remaining,
                    data));
        }
        twkDidReceiveData(byteBuffer, position, remaining, data);
    }

    private void didFinishLoading() {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidFinishLoading();
            }
        });
    }

    private void notifyDidFinishLoading() {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
        }
        twkDidFinishLoading(data);
    }

    private void didFail(final int errorCode, final String message) {
        final String adjustedUrl = adjustUrlForWebKit(url);
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidFail(errorCode, adjustedUrl, message);
            }
        });
    }

    private void notifyDidFail(int errorCode, String url, String message) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;errorCode: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;message: [%s], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    errorCode,
                    url,
                    message,
                    data));
        }
        twkDidFail(errorCode, url, message, data);
    }

    private void callBack(Runnable runnable) {
        if (asynchronous) {
            Invoker.getInvoker().invokeOnEventThread(runnable);
        } else {
            runnable.run();
        }
    }

    private static native void twkDidSendData(long totalBytesSent,
                                              long totalBytesToBeSent,
                                              long data);

    private static native boolean twkWillSendRequest(String newUrl,
                                                     String newMethod,
                                                     int status,
                                                     String contentType,
                                                     String contentEncoding,
                                                     long contentLength,
                                                     String headers,
                                                     String url,
                                                     long data);

    private static native void twkDidReceiveResponse(int status,
                                                     String contentType,
                                                     String contentEncoding,
                                                     long contentLength,
                                                     String headers,
                                                     String url,
                                                     long data);

    private static native void twkDidReceiveData(ByteBuffer byteBuffer,
                                                 int position,
                                                 int remaining,
                                                 long data);

    private static native void twkDidFinishLoading(long data);

    private static native void twkDidFail(int errorCode,
                                          String url,
                                          String message,
                                          long data);

    /**
     * Given a {@link URLConnection}, returns the connection status
     * for passing into native callbacks.
     */
    private static int extractStatus(URLConnection c) {
        int status = 0;
        if (c instanceof HttpURLConnection) {
            try {
                status = ((HttpURLConnection) c).getResponseCode();
            } catch (java.io.IOException ignore) {}
        }
        return status;
    }

    /**
     * Given a {@link URLConnection}, returns the content encoding
     * for passing into native callbacks.
     */
    private static String extractContentEncoding(URLConnection c) {
        String contentEncoding = c.getContentEncoding();
        // For compressed streams, the encoding is in Content-Type
        if (&quot;gzip&quot;.equalsIgnoreCase(contentEncoding) ||
            &quot;deflate&quot;.equalsIgnoreCase(contentEncoding))
        {
            contentEncoding = null;
            String contentType  = c.getContentType();
            if (contentType != null) {
                int i = contentType.indexOf(&quot;charset=&quot;);
                if (i &gt;= 0) {
                    contentEncoding = contentType.substring(i + 8);
                    i = contentEncoding.indexOf(&quot;;&quot;);
                    if (i &gt; 0) {
                        contentEncoding = contentEncoding.substring(0, i);
                    }
                }
            }
        }
        return contentEncoding;
    }

    /**
     * Given a {@link URLConnection}, returns the content length
     * for passing into native callbacks.
     */
    private static long extractContentLength(URLConnection c) {
        // Cannot use URLConnection.getContentLength()
        // as it only returns an int
        try {
            return Long.parseLong(c.getHeaderField(&quot;content-length&quot;));
        } catch (Exception ex) {
            return -1;
        }
    }

    /**
     * Given a {@link URLConnection}, returns the headers string
     * for passing into native callbacks.
     */
    private static String extractHeaders(URLConnection c) {
        StringBuilder sb = new StringBuilder();
        Map&lt;String, List&lt;String&gt;&gt; headers = c.getHeaderFields();
        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: headers.entrySet()) {
            String key = entry.getKey();
            List&lt;String&gt; values = entry.getValue();
            for (String value : values) {
                sb.append(key != null ? key : &quot;&quot;);
                sb.append(':').append(value).append('\n');
            }
        }
        return sb.toString();
    }

    /**
     * Adjust a URL string for passing into WebKit.
     */
    private static String adjustUrlForWebKit(String url) {
        try {
            url = Util.adjustUrlForWebKit(url);
        } catch (Exception ignore) {
        }
        return url;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/StartView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;


public class StartView extends VBox {
    private Button btLevel1;
    private Button btLevel2;
    private Button btLevel3;
    private Button btSoundPlay;
    private Button btSoundPause;
    private Label message;
    private Label message1;

    public StartView() {
        // Create a vBox
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        // Set name for buttons and message label
        setBtLevel1(new Button(&quot;Level 1&quot;));
        setBtLevel2(new Button(&quot;Level 2&quot;));
        setBtLevel3(new Button(&quot;Level 3&quot;));
        setBtSoundPlay(new Button(&quot;Music On&quot;));
        setBtSoundPause(new Button(&quot;Music Pause&quot;));
        setMessage(new Label(&quot;Hello, QUOC DAI ! &quot;));
        setMessage1(new Label(&quot;PLEASE CHOOSE THE LEVEL TO START !&quot;));
        //Set Front, Size, Color for Message
        getMessage().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage().setTextFill(Color.WHITE);
        //Set Front, Size, Color for Message1
        getMessage1().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage1().setTextFill(Color.WHITE);
        // add 4 buttons to hBox
        hBox.getChildren().addAll(getBtLevel1(), getBtLevel2(), getBtLevel3(), getBtSoundPlay(), getBtSoundPause());

        setAlignment(Pos.CENTER);
        setSpacing(10);

        // add hBox and label to vBox
        getChildren().addAll(getMessage(), getMessage1(),hBox);
    }

    public Button getBtLevel1() {
        return btLevel1;
    }

    public Button getBtLevel2() {
        return btLevel2;
    }

    public Button getBtLevel3() {
        return btLevel3;
    }

    private void setBtLevel1(Button btLevel1) {
        this.btLevel1 = btLevel1;
    }

    private void setBtLevel2(Button btLevel2) {
        this.btLevel2 = btLevel2;
    }

    private void setBtLevel3(Button btLevel3) {
<A NAME="7"></A>        this.btLevel3 = btLevel3;
    }

    <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42-0.html#7',2,'match42-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private Label getMessage() {
        return message;
    }

    private void setMessage(Label message) {
        this.message = message;
    }

    private Label getMessage1() {
        return message1;
    }

    private void setMessage1(Label message1) {
        this.message1 = message1;
    }

    public Button getBtSoundPlay() {
        return btSoundPlay;
    }

    private void setBtSoundPlay(Button btSoundPlay) {
        this.btSoundPlay = btSoundPlay;
    }

    public Button getBtSoundPause() {</B></FONT>
        return btSoundPause;
    }

    private void setBtSoundPause(Button btSoundPause) {
        this.btSoundPause = btSoundPause;
    }
}
</PRE>

</BODY>
</HTML>
