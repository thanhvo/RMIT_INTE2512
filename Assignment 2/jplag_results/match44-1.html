<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/GlobalMenuAdapter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="13"></A> * questions.
 */

<FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#13',2,'match44-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.scene.control;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.ListChangeListener;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SeparatorMenuItem;

import java.util.List;

import com.sun.javafx.menu.CheckMenuItemBase;
import com.sun.javafx.menu.CustomMenuItemBase;
import com.sun.javafx.menu.MenuBase;
import com.sun.javafx.menu.MenuItemBase;
import com.sun.javafx.menu.RadioMenuItemBase;
import com.sun.javafx.menu.SeparatorMenuItemBase;

import com.sun.javafx.collections.TrackableObservableList;

publi</B></FONT>c class GlobalMenuAdapter extends Menu implements MenuBase {
    private Menu menu;

    public static MenuBase adapt(Menu menu) {
        return new GlobalMenuAdapter(menu);
    }

    private final ObservableList&lt;MenuItemBase&gt; items = new TrackableObservableList&lt;MenuItemBase&gt;() {
        @Override protected void onChanged(Change&lt;MenuItemBase&gt; c) {
        }
    };

    private GlobalMenuAdapter(final Menu menu) {
        super(menu.getText());

        this.menu = menu;

        bindMenuItemProperties(this, menu);

        menu.showingProperty().addListener(property -&gt; {
            if (menu.isShowing() &amp;&amp; !isShowing()) {
                show();
            } else if (!menu.isShowing() &amp;&amp; isShowing()) {
                hide();
            }
        });
        showingProperty().addListener(property -&gt; {
            if (isShowing() &amp;&amp; !menu.isShowing()) {
                menu.show();
            } else if (!isShowing() &amp;&amp; menu.isShowing()) {
                menu.hide();
            }
        });

//        EventHandler&lt;Event&gt; showHideHandler = new EventHandler&lt;Event&gt;() {
//            public void handle(Event ev) {
//                Event.fireEvent(menu, new Event(ev.getEventType()));
//            }
//        };

        menu.getItems().addListener(new ListChangeListener&lt;MenuItem&gt;() {
            @Override public void onChanged(Change&lt;? extends MenuItem&gt; change) {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends MenuItem&gt; removed = change.getRemoved();
                    for (int i = from + removed.size() - 1; i &gt;= from ; i--) {
                        items.remove(i);
                        getItems().remove(i);
                    }
                    for (int i = from; i &lt; to; i++) {
                        MenuItem item = change.getList().get(i);
                        insertItem(item, i);
                    }
                }
            }
        });

        for (MenuItem menuItem : menu.getItems()) {
            insertItem(menuItem, items.size());
        }
    }

    private void insertItem(MenuItem menuItem, int pos) {
        MenuItemBase mib;

        if (menuItem instanceof Menu) {
            mib = new GlobalMenuAdapter((Menu)menuItem);
        } else if (menuItem instanceof CheckMenuItem) {
            mib = new CheckMenuItemAdapter((CheckMenuItem)menuItem);
        } else if (menuItem instanceof RadioMenuItem) {
            mib = new RadioMenuItemAdapter((RadioMenuItem)menuItem);
        } else if (menuItem instanceof SeparatorMenuItem) {
            mib = new SeparatorMenuItemAdapter((SeparatorMenuItem)menuItem);
        } else if (menuItem instanceof CustomMenuItem) {
            mib = new CustomMenuItemAdapter((CustomMenuItem)menuItem);
        } else {
            mib = new MenuItemAdapter(menuItem);
        }

        items.add(pos, mib);
        getItems().add(pos, (MenuItem)mib);
    }

    public final ObservableList&lt;MenuItemBase&gt; getItemsBase() {
        return items;
<A NAME="51"></A>    }


    private static void bindMenuItemProperties(<FONT color="#b38481"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#51',2,'match44-top.html#51',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MenuItem adapter, final MenuItem menuItem) {
        adapter.idProperty().bind(menuItem.idProperty());
        adapter.textProperty().bind(menuItem.textProperty());
        adapter.graphicProperty().bind(menuItem.graphicProperty());
        adapter.disableProperty().bind(menuItem.disableProperty</B></FONT>());
        adapter.visibleProperty().bind(menuItem.visibleProperty());
        adapter.acceleratorProperty().bind(menuItem.acceleratorProperty());
        adapter.mnemonicParsingProperty().bind(menuItem.mnemonicParsingProperty());

        adapter.setOnAction(ev -&gt; {
            menuItem.fire();
        });
    }

    @Override
    public void fireValidation() {
        if (menu.getOnMenuValidation() != null) {
            Event.fireEvent(menu, new Event(GlobalMenuAdapter.MENU_VALIDATION_EVENT));
        }
        Menu target = (Menu)menu.getParentMenu();
        if(target != null &amp;&amp; target.getOnMenuValidation() != null) {
            Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
        }
    }


    private static class MenuItemAdapter extends MenuItem implements MenuItemBase {
        private MenuItem menuItem;

        private MenuItemAdapter(final MenuItem menuItem) {
            super(menuItem.getText());

            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (menuItem.getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class CheckMenuItemAdapter extends CheckMenuItem implements CheckMenuItemBase {
        private CheckMenuItem menuItem;

        private CheckMenuItemAdapter(final CheckMenuItem menuItem) {
            super(menuItem.getText());
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);

            selectedProperty().bindBidirectional(menuItem.selectedProperty());
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(CheckMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class RadioMenuItemAdapter extends RadioMenuItem implements RadioMenuItemBase {
        private RadioMenuItem menuItem;

        private RadioMenuItemAdapter(final RadioMenuItem menuItem) {
            super(menuItem.getText());

            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);

            selectedProperty().bindBidirectional(menuItem.selectedProperty());
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(RadioMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class SeparatorMenuItemAdapter extends SeparatorMenuItem implements SeparatorMenuItemBase {
        private SeparatorMenuItem menuItem;

        private SeparatorMenuItemAdapter(final SeparatorMenuItem menuItem) {
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(SeparatorMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class CustomMenuItemAdapter extends CustomMenuItem implements CustomMenuItemBase {
        private CustomMenuItem menuItem;

        private CustomMenuItemAdapter(final CustomMenuItem menuItem) {
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(CustomMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ListViewBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.event.EventHandler;
import javafx.geometry.Orientation;
import javafx.scene.control.FocusModel;
import javafx.scene.control.ListView;
import javafx.scene.control.MultipleSelectionModel;
import javafx.scene.control.SelectionMode;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.util.Callback;

import java.util.ArrayList;
import java.util.List;

import static com.sun.javafx.scene.control.inputmap.InputMap.*;
import static javafx.scene.input.KeyCode.*;

public class ListViewBehavior&lt;T&gt; extends BehaviorBase&lt;ListView&lt;T&gt;&gt; {
    private final InputMap&lt;ListView&lt;T&gt;&gt; listViewInputMap;

    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        if (!e.isConsumed()) {
            // RT-12751: we want to keep an eye on the user holding down the shift key,
            // so that we know when they enter/leave multiple selection mode. This
            // changes what happens when certain key combinations are pressed.
            isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
            isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public ListViewBehavior(ListView&lt;T&gt; control) {
        super(control);

        // create a map for listView-specific mappings
        listViewInputMap = createInputMap();

        // add focus traversal mappings
        addDefaultMapping(listViewInputMap, FocusTraversalInputMap.getFocusTraversalMappings());
        addDefaultMapping(listViewInputMap,
            new KeyMapping(HOME, e -&gt; selectFirstRow()),
            new KeyMapping(END, e -&gt; selectLastRow()),
            new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
            new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
            new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
            new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),

            new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
            new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),

            new KeyMapping(PAGE_UP, e -&gt; scrollPageUp()),
            new KeyMapping(PAGE_DOWN, e -&gt; scrollPageDown()),

            new KeyMapping(ENTER, e -&gt; activate()),
            new KeyMapping(SPACE, e -&gt; activate()),
            new KeyMapping(F2, e -&gt; activate()),
            new KeyMapping(ESCAPE, e -&gt; cancelEdit()),

            new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll()),
            new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
            new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
            new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
            new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),

            new KeyMapping(new KeyBinding(BACK_SLASH).shortcut(), e -&gt; clearSelection()),

            new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
        );

        // create OS-specific child mappings
        // --- mac OS
        InputMap&lt;ListView&lt;T&gt;&gt; macInputMap = new InputMap&lt;&gt;(control);
        macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
        addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(listViewInputMap, macInputMap);

        // --- all other platforms
        InputMap&lt;ListView&lt;T&gt;&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
        otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
        addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(listViewInputMap, otherOsInputMap);

        // create two more child maps, one for vertical listview and one for horizontal listview
        // --- vertical listview
        InputMap&lt;ListView&lt;T&gt;&gt; verticalListInputMap = new InputMap&lt;&gt;(control);
        verticalListInputMap.setInterceptor(event -&gt; control.getOrientation() != Orientation.VERTICAL);

        addDefaultMapping(verticalListInputMap,
            new KeyMapping(UP, e -&gt; selectPreviousRow()),
            new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
            new KeyMapping(DOWN, e -&gt; selectNextRow()),
            new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),

            new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNextRow()),
            new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNextRow()),

            new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
            new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),

            new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
            new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
            new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
            new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown()),
            new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
            new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow())
        );

        addDefaultChildMap(listViewInputMap, verticalListInputMap);

        // --- horizontal listview
        InputMap&lt;ListView&lt;T&gt;&gt; horizontalListInputMap = new InputMap&lt;&gt;(control);
        horizontalListInputMap.setInterceptor(event -&gt; control.getOrientation() != Orientation.HORIZONTAL);

        addDefaultMapping(horizontalListInputMap,
            new KeyMapping(LEFT, e -&gt; selectPreviousRow()),
            new KeyMapping(KP_LEFT, e -&gt; selectPreviousRow()),
            new KeyMapping(RIGHT, e -&gt; selectNextRow()),
            new KeyMapping(KP_RIGHT, e -&gt; selectNextRow()),

            new KeyMapping(new KeyBinding(LEFT).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(KP_LEFT).shift(), e -&gt; alsoSelectPreviousRow()),
            new KeyMapping(new KeyBinding(RIGHT).shift(), e -&gt; alsoSelectNextRow()),
            new KeyMapping(new KeyBinding(KP_RIGHT).shift(), e -&gt; alsoSelectNextRow()),

            new KeyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; focusPreviousRow()),
            new KeyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; focusNextRow()),

            new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
            new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; discontinuousSelectNextRow())
        );

        addDefaultChildMap(listViewInputMap, horizontalListInputMap);

        // set up other listeners
        // We make this an event _filter_ so that we can determine the state
        // of the shift key before the event handlers get a shot at the event.
        control.addEventFilter(KeyEvent.ANY, keyEventListener);

        control.itemsProperty().addListener(weakItemsListener);
        if (control.getItems() != null) {
            control.getItems().addListener(weakItemsListListener);
        }

        // Fix for RT-16565
        control.selectionModelProperty().addListener(weakSelectionModelListener);
        if (control.getSelectionModel() != null) {
            control.getSelectionModel().getSelectedIndices().addListener(weakSelectedIndicesListener);
        }

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusListBehavior(control); // needs to be last.
        }
    }



    /***************************************************************************
     *                                                                         *
     * Implementation of BehaviorBase API                                      *
     *                                                                         *
     **************************************************************************/

    @Override public InputMap&lt;ListView&lt;T&gt;&gt; getInputMap() {
        return listViewInputMap;
    }

    @Override public void dispose() {
        ListView&lt;T&gt; control = getNode();

        ListCellBehavior.removeAnchor(control);
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();

        control.removeEventHandler(KeyEvent.ANY, keyEventListener);
    }





    /**************************************************************************
     *                         State and Functions                            *
     *************************************************************************/

    private boolean isShiftDown = false;
    private boolean isShortcutDown = false;

    private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
    private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
    private Runnable onFocusPreviousRow;
    private Runnable onFocusNextRow;
    private Runnable onSelectPreviousRow;
    private Runnable onSelectNextRow;
    private Runnable onMoveToFirstCell;
    private Runnable onMoveToLastCell;

    public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }
    public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }
    public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }
    public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }
    public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }
    public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }
    public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }
    public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }

    private boolean selectionChanging = false;

    private final ListChangeListener&lt;Integer&gt; selectedIndicesListener = c -&gt; {
        int newAnchor = getAnchor();

        while (c.next()) {
            if (c.wasReplaced()) {
                if (ListCellBehavior.hasDefaultAnchor(getNode())) {
                    ListCellBehavior.removeAnchor(getNode());
                    continue;
                }
            }

            final int shift = c.wasPermutated() ? c.getTo() - c.getFrom() : 0;

            MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();

            // there are no selected items, so lets clear out the anchor
            if (! selectionChanging) {
                if (sm.isEmpty()) {
                    newAnchor = -1;
                } else if (hasAnchor() &amp;&amp; ! sm.isSelected(getAnchor() + shift)) {
                    newAnchor = -1;
                }
            }

            // we care about the situation where the selection changes, and there is no anchor. In this
            // case, we set a new anchor to be the selected index
            if (newAnchor == -1) {
                int addedSize = c.getAddedSize();
                newAnchor = addedSize &gt; 0 ? c.getAddedSubList().get(addedSize - 1) : newAnchor;
            }
        }

        if (newAnchor &gt; -1) {
            setAnchor(newAnchor);
        }
    };

    private final ListChangeListener&lt;T&gt; itemsListListener = c -&gt; {
        while (c.next()) {
            if (!hasAnchor()) continue;

            int newAnchor = (hasAnchor() ? getAnchor() : 0);

            if (c.wasAdded() &amp;&amp; c.getFrom() &lt;= newAnchor) {
                newAnchor += c.getAddedSize();
            } else if (c.wasRemoved() &amp;&amp; c.getFrom() &lt;= newAnchor) {
                newAnchor -= c.getRemovedSize();
            }

            setAnchor(newAnchor &lt; 0 ? 0 : newAnchor);
        }
    };

    private final ChangeListener&lt;ObservableList&lt;T&gt;&gt; itemsListener = new ChangeListener&lt;ObservableList&lt;T&gt;&gt;() {
        @Override
        public void changed(
                ObservableValue&lt;? extends ObservableList&lt;T&gt;&gt; observable,
                ObservableList&lt;T&gt; oldValue, ObservableList&lt;T&gt; newValue) {
            if (oldValue != null) {
                oldValue.removeListener(weakItemsListListener);
            } if (newValue != null) {
                newValue.addListener(weakItemsListListener);
            }
        }
    };

    private final ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelListener = new ChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;() {
        @Override public void changed(
                ObservableValue&lt;? extends MultipleSelectionModel&lt;T&gt;&gt; observable,
                MultipleSelectionModel&lt;T&gt; oldValue,
                MultipleSelectionModel&lt;T&gt; newValue) {
            if (oldValue != null) {
                oldValue.getSelectedIndices().removeListener(weakSelectedIndicesListener);
            }
            if (newValue != null) {
                newValue.getSelectedIndices().addListener(weakSelectedIndicesListener);
            }
        }
    };

    private final WeakChangeListener&lt;ObservableList&lt;T&gt;&gt; weakItemsListener =
            new WeakChangeListener&lt;ObservableList&lt;T&gt;&gt;(itemsListener);
    private final WeakListChangeListener&lt;Integer&gt; weakSelectedIndicesListener =
            new WeakListChangeListener&lt;Integer&gt;(selectedIndicesListener);
    private final WeakListChangeListener&lt;T&gt; weakItemsListListener =
            new WeakListChangeListener&lt;&gt;(itemsListListener);
    private final WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt; weakSelectionModelListener =
            new WeakChangeListener&lt;MultipleSelectionModel&lt;T&gt;&gt;(selectionModelListener);

    private TwoLevelFocusListBehavior tlFocus;

    private void setAnchor(int anchor) {
        ListCellBehavior.setAnchor(getNode(), anchor &lt; 0 ? null : anchor, false);
    }

    private int getAnchor() {
        return ListCellBehavior.getAnchor(getNode(), getNode().getFocusModel().getFocusedIndex());
    }

    private boolean hasAnchor() {
        return ListCellBehavior.hasNonDefaultAnchor(getNode());
    }

    private void mousePressed(MouseEvent e) {
        if (! e.isShiftDown() &amp;&amp; ! e.isSynthesized()) {
            int index = getNode().getSelectionModel().getSelectedIndex();
            setAnchor(index);
        }

        if (! getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
            getNode().requestFocus();
        }
    }

    private int getRowCount() {
        return getNode().getItems() == null ? 0 : getNode().getItems().size();
    }

    private void clearSelection() {
        getNode().getSelectionModel().clearSelection();
    }

    private void scrollPageUp() {
        int newSelectedIndex = -1;
        if (onScrollPageUp != null) {
            newSelectedIndex = onScrollPageUp.call(false);
        }
        if (newSelectedIndex == -1) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;
        sm.clearAndSelect(newSelectedIndex);
    }

    private void scrollPageDown() {
        int newSelectedIndex = -1;
        if (onScrollPageDown != null) {
            newSelectedIndex = onScrollPageDown.call(false);
        }
        if (newSelectedIndex == -1) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;
        sm.clearAndSelect(newSelectedIndex);
    }

    private void focusFirstRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(0);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    private void focusLastRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(getRowCount() - 1);

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    private void focusPreviousRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        fm.focusPrevious();

        if (! isShortcutDown || getAnchor() == -1) {
            setAnchor(fm.getFocusedIndex());
        }

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    private void focusNextRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        fm.focusNext();

        if (! isShortcutDown || getAnchor() == -1) {
            setAnchor(fm.getFocusedIndex());
        }

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    private void focusPageUp() {
        int newFocusIndex = onScrollPageUp.call(true);

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(newFocusIndex);
    }

    private void focusPageDown() {
        int newFocusIndex = onScrollPageDown.call(true);

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;
        fm.focus(newFocusIndex);
    }

    private void alsoSelectPreviousRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (isShiftDown &amp;&amp; getAnchor() != -1) {
            int newRow = fm.getFocusedIndex() - 1;
            if (newRow &lt; 0) return;

            int anchor = getAnchor();

            if (! hasAnchor()) {
                setAnchor(fm.getFocusedIndex());
            }

            if (sm.getSelectedIndices().size() &gt; 1) {
                clearSelectionOutsideRange(anchor, newRow);
            }

            if (anchor &gt; newRow) {
                sm.selectRange(anchor, newRow - 1);
            } else {
                sm.selectRange(anchor, newRow + 1);
            }
        } else {
            sm.selectPrevious();
        }

        onSelectPreviousRow.run();
    }

    private void alsoSelectNextRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (isShiftDown &amp;&amp; getAnchor() != -1) {
            int newRow = fm.getFocusedIndex() + 1;
            int anchor = getAnchor();

            if (! hasAnchor()) {
                setAnchor(fm.getFocusedIndex());
            }

            if (sm.getSelectedIndices().size() &gt; 1) {
                clearSelectionOutsideRange(anchor, newRow);
            }

            if (anchor &gt; newRow) {
                sm.selectRange(anchor, newRow - 1);
            } else {
                sm.selectRange(anchor, newRow + 1);
            }
        } else {
            sm.selectNext();
        }

        onSelectNextRow.run();
    }

    private void clearSelectionOutsideRange(int start, int end) {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        int min = Math.min(start, end);
        int max = Math.max(start, end);

        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;(sm.getSelectedIndices());

        selectionChanging = true;
        for (int i = 0; i &lt; indices.size(); i++) {
            int index = indices.get(i);
            if (index &lt; min || index &gt; max) {
                sm.clearSelection(index);
            }
        }
        selectionChanging = false;
    }

    private void selectPreviousRow() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        if (focusIndex &lt;= 0) {
            return;
        }

        setAnchor(focusIndex - 1);
        getNode().getSelectionModel().clearAndSelect(focusIndex - 1);
        onSelectPreviousRow.run();
    }

    private void selectNextRow() {
        ListView&lt;T&gt; listView = getNode();
        FocusModel&lt;T&gt; fm = listView.getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        if (focusIndex == getRowCount() - 1) {
            return;
        }

        MultipleSelectionModel&lt;T&gt; sm = listView.getSelectionModel();
        if (sm == null) return;

        setAnchor(focusIndex + 1);
        sm.clearAndSelect(focusIndex + 1);
        if (onSelectNextRow != null) onSelectNextRow.run();
    }

    private void selectFirstRow() {
        if (getRowCount() &gt; 0) {
            getNode().getSelectionModel().clearAndSelect(0);
            if (onMoveToFirstCell != null) onMoveToFirstCell.run();
        }
    }

    private void selectLastRow() {
        getNode().getSelectionModel().clearAndSelect(getRowCount() - 1);
        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    private void selectAllPageUp() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        if (isShiftDown) {
            leadIndex = getAnchor() == -1 ? leadIndex : getAnchor();
            setAnchor(leadIndex);
        }

        int leadSelectedIndex = onScrollPageUp.call(false);

        // fix for RT-34407
        int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        selectionChanging = true;
        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            sm.select(leadSelectedIndex);
        } else {
            sm.clearSelection();
            sm.selectRange(leadIndex, leadSelectedIndex + adjust);
        }
        selectionChanging = false;
    }

    private void selectAllPageDown() {
        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        if (isShiftDown) {
            leadIndex = getAnchor() == -1 ? leadIndex : getAnchor();
            setAnchor(leadIndex);
        }

        int leadSelectedIndex = onScrollPageDown.call(false);

        // fix for RT-34407
        int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;

        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        selectionChanging = true;
        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            sm.select(leadSelectedIndex);
        } else {
            sm.clearSelection();
            sm.selectRange(leadIndex, leadSelectedIndex + adjust);
        }
        selectionChanging = false;
    }

    private void selectAllToFirstRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();

        if (isShiftDown) {
            leadIndex = hasAnchor() ? getAnchor() : leadIndex;
        }

        sm.clearSelection();
        sm.selectRange(leadIndex, -1);

        // RT-18413: Focus must go to first row
        fm.focus(0);

        if (isShiftDown) {
            setAnchor(leadIndex);
        }

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    private void selectAllToLastRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();

        if (isShiftDown) {
            leadIndex = hasAnchor() ? getAnchor() : leadIndex;
        }

        sm.clearSelection();
        sm.selectRange(leadIndex, getRowCount());

        if (isShiftDown) {
            setAnchor(leadIndex);
        }

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    private void selectAll() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;
        sm.selectAll();
    }

    private void selectAllToFocus(boolean setAnchorToFocusIndex) {
        // Fix for RT-31241
        final ListView&lt;T&gt; listView = getNode();
        if (listView.getEditingIndex() &gt;= 0) return;

        MultipleSelectionModel&lt;T&gt; sm = listView.getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = listView.getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        int anchor = getAnchor();

        sm.clearSelection();
        int startPos = anchor;
        int endPos = anchor &gt; focusIndex ? focusIndex - 1 : focusIndex + 1;
        sm.selectRange(startPos, endPos);
<A NAME="16"></A>        setAnchor(setAnchorToFocusIndex ? focusIndex : anchor);
    }

    private void cancelEdit() <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#16',2,'match44-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        getNode().edit(-1);
    }

    private void activate() {
        int focusedIndex = getNode().getFocusModel().getFocusedIndex();
        getNode().getSelectionModel</B></FONT>().select(focusedIndex);
        setAnchor(focusedIndex);

        // edit this row also
        if (focusedIndex &gt;= 0) {
            getNode().edit(focusedIndex);
        }
    }

    private void toggleFocusOwnerSelection() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusedIndex = fm.getFocusedIndex();

        if (sm.isSelected(focusedIndex)) {
            sm.clearSelection(focusedIndex);
            fm.focus(focusedIndex);
        } else {
            sm.select(focusedIndex);
        }

        setAnchor(focusedIndex);
    }

    /**************************************************************************
     * Discontinuous Selection                                                *
     *************************************************************************/

    private void discontinuousSelectPreviousRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectPreviousRow();
            return;
        }

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex - 1;
        if (newFocusIndex &lt; 0) return;

        int startIndex = focusIndex;
        if (isShiftDown) {
            startIndex = getAnchor() == -1 ? focusIndex : getAnchor();
        }

        sm.selectRange(newFocusIndex, startIndex + 1);
        fm.focus(newFocusIndex);

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    private void discontinuousSelectNextRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectNextRow();
            return;
        }

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex + 1;
        if (newFocusIndex &gt;= getRowCount()) return;

        int startIndex = focusIndex;
        if (isShiftDown) {
            startIndex = getAnchor() == -1 ? focusIndex : getAnchor();
        }

        sm.selectRange(startIndex, newFocusIndex + 1);
        fm.focus(newFocusIndex);

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    private void discontinuousSelectPageUp() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int anchor = getAnchor();
        int leadSelectedIndex = onScrollPageUp.call(false);
        sm.selectRange(anchor, leadSelectedIndex - 1);
    }

    private void discontinuousSelectPageDown() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int anchor = getAnchor();
        int leadSelectedIndex = onScrollPageDown.call(false);
        sm.selectRange(anchor, leadSelectedIndex + 1);
    }

    private void discontinuousSelectAllToFirstRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex();
        sm.selectRange(0, index);
        fm.focus(0);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    private void discontinuousSelectAllToLastRow() {
        MultipleSelectionModel&lt;T&gt; sm = getNode().getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;T&gt; fm = getNode().getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex() + 1;
        sm.selectRange(index, getRowCount());

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TableRowBehaviorBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import javafx.collections.ObservableList;
import javafx.scene.control.Cell;
import javafx.scene.control.Control;
import javafx.scene.control.TableColumnBase;
import javafx.scene.control.TablePositionBase;
import javafx.scene.control.TableSelectionModel;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;

import java.util.List;

public abstract class TableRowBehaviorBase&lt;T extends Cell&gt; extends CellBehaviorBase&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TableRowBehaviorBase(T control) {
        super(control);
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
<A NAME="36"></A>     *                                                                         *
     **************************************************************************/

    @Override public void mousePressed(<FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#36',2,'match44-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MouseEvent e) {
        // we only care about clicks to the right of the right-most column
        if (! isClickPositionValid(e.getX(), e.getY())) return;

        super.mousePressed</B></FONT>(e);
    }

    @Override protected abstract TableSelectionModel&lt;?&gt; getSelectionModel();

    protected abstract TablePositionBase&lt;?&gt; getFocusedCell();

    protected abstract ObservableList getVisibleLeafColumns();



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    @Override protected void doSelect(final double x, final double y, final MouseButton button,
                   final int clickCount, final boolean shiftDown, final boolean shortcutDown) {
        final Control table = getCellContainer();
        if (table == null) return;

        // if the user has clicked on the disclosure node, we do nothing other
        // than expand/collapse the tree item (if applicable). We do not do editing!
        if (handleDisclosureNode(x,y)) {
            return;
        }

        final TableSelectionModel&lt;?&gt; sm = getSelectionModel();
        if (sm == null || sm.isCellSelectionEnabled()) return;

        final int index = getIndex();
        final boolean isAlreadySelected = sm.isSelected(index);
        if (clickCount == 1) {
            // we only care about clicks to the right of the right-most column
            if (! isClickPositionValid(x, y)) return;

            // In the case of clicking to the right of the rightmost
            // TreeTableCell, we should still support selection, so that
            // is what we are doing here.
            if (isAlreadySelected &amp;&amp; shortcutDown) {
                sm.clearSelection(index);
            } else {
                if (shortcutDown) {
                    sm.select(getIndex());
                } else if (shiftDown) {
                    // we add all rows between the current focus and
                    // this row (inclusive) to the current selection.
                    TablePositionBase&lt;?&gt; anchor = getAnchor(table, getFocusedCell());
                    final int anchorRow = anchor.getRow();
                    selectRows(anchorRow, index);
                } else {
                    simpleSelect(button, clickCount, shortcutDown);
                }
            }
        } else {
            simpleSelect(button, clickCount, shortcutDown);
        }
    }

    @Override protected boolean isClickPositionValid(final double x, final double y) {
        // get width of all visible columns (we only care about clicks to the
        // right of the right-most column)
        List&lt;TableColumnBase&lt;T, ?&gt;&gt; columns = getVisibleLeafColumns();
        double width = 0.0;
        for (int i = 0; i &lt; columns.size(); i++) {
            width += columns.get(i).getWidth();
        }

        return x &gt; width;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextInputControlBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.FXVK;

import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.skin.TextInputControlSkin;
import javafx.application.ConditionalFeature;
import javafx.beans.InvalidationListener;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.IndexRange;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PasswordField;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextInputControl;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.Clipboard;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import java.text.Bidi;
import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isLinux;
import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;
import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;
import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public abstract class TextInputControlBehavior&lt;T extends TextInputControl&gt; extends BehaviorBase&lt;T&gt; {

    /**
     * Specifies whether we ought to show handles. We should do it on touch platforms, but not
     * iOS (and maybe not Android either?)
     */
    static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED &amp;&amp; !PlatformUtil.isIOS();

    public static final String DISABLE_FORWARD_TO_PARENT = &quot;TextInputControlBehavior.disableForwardToParent&quot;;

    /**************************************************************************
     * Fields                                                                 *
     *************************************************************************/

    final T textInputControl;

    protected ContextMenu contextMenu;

    private InvalidationListener textListener = observable -&gt; invalidateBidi();

    private final InputMap&lt;T&gt; inputMap;




    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TextInputControlBehavior(T c) {
        super(c);

        this.textInputControl = c;

        textInputControl.textProperty().addListener(textListener);

        // create a map for text input-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();
        final Predicate&lt;KeyEvent&gt; validOnWindows = e -&gt; !PlatformUtil.isWindows();
        final Predicate&lt;KeyEvent&gt; validOnLinux = e -&gt; !PlatformUtil.isLinux();

        KeyMapping cancelEditMapping;
        KeyMapping consumeMostPressedEventsMapping;

        // create a child input map for mappings which are applicable on all
        // platforms, and regardless of editing state
        addDefaultMapping(inputMap,
                // caret movement
                keyMapping(RIGHT, e -&gt; nextCharacterVisually(true)),
                keyMapping(LEFT, e -&gt; nextCharacterVisually(false)),
                keyMapping(UP, e -&gt; c.home()),
                keyMapping(HOME, e -&gt; c.home()),
                keyMapping(DOWN, e -&gt; c.end()),
                keyMapping(END, e -&gt; c.end()),
                keyMapping(ENTER, this::fire),

                keyMapping(new KeyBinding(HOME).shortcut(), e -&gt; c.home()),
                keyMapping(new KeyBinding(END).shortcut(), e -&gt; c.end()),

                // deletion (only applies when control is editable)
                keyMapping(new KeyBinding(BACK_SPACE), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(DELETE), e -&gt; deleteNextChar(), validWhenEditable),

                // cut (only applies when control is editable)
                keyMapping(new KeyBinding(X).shortcut(), e -&gt; cut(), validWhenEditable),
                keyMapping(new KeyBinding(CUT), e -&gt; cut(), validWhenEditable),

                // copy
                keyMapping(new KeyBinding(C).shortcut(), e -&gt; c.copy()),
                keyMapping(new KeyBinding(INSERT).shortcut(), e -&gt; c.copy()),
                keyMapping(COPY, e -&gt; c.copy()),

                // paste (only applies when control is editable)
                keyMapping(new KeyBinding(V).shortcut(), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(PASTE), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(INSERT).shift(), e -&gt; paste(), validWhenEditable),

                // selection
                keyMapping(new KeyBinding(RIGHT).shift(), e -&gt; selectRight()),
                keyMapping(new KeyBinding(LEFT).shift(), e -&gt; selectLeft()),
                keyMapping(new KeyBinding(UP).shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(DOWN).shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(A).shortcut(), e -&gt; c.selectAll()),

                // Traversal Bindings
                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),

                // The following keys are forwarded to the parent container
                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                keyMapping(new KeyBinding(Z).shortcut(), e -&gt; undo()),

                // character input.
                // Any other key press first goes to normal text input
                // Note this is KEY_TYPED because otherwise the character is not available in the event.
                keyMapping(new KeyBinding(null, KEY_TYPED)
                                    .alt(OptionalBoolean.ANY)
                                    .shift(OptionalBoolean.ANY)
                                    .ctrl(OptionalBoolean.ANY)
                                    .meta(OptionalBoolean.ANY),
                           this::defaultKeyTyped),

                // However, we want to consume other key press / release events too, for
                // things that would have been handled by the InputCharacter normally
                consumeMostPressedEventsMapping =
                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),
                               e -&gt; { if (!e.getCode().isFunctionKey()) e.consume(); }),

                // VK
                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -&gt; {
                    FXVK.toggleUseVK(textInputControl);
                }, p -&gt; !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),

                // mouse and context menu mappings
                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),
                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
                new InputMap.Mapping&lt;ContextMenuEvent&gt;(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {
                    @Override public int getSpecificity(Event event) {
                        return 1;
                    }
                }
        );

        cancelEditMapping.setAutoConsume(false);
        consumeMostPressedEventsMapping.setAutoConsume(false);

        // mac os specific mappings
        InputMap&lt;T&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEndExtend()),
            keyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; c.home()),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; c.end()),
            keyMapping(new KeyBinding(LEFT).alt(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).alt(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(DELETE).alt(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -&gt; deleteFromLineStart()),
            keyMapping(new KeyBinding(Z).shortcut().shift(), e -&gt; redo()),
            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; selectEndExtend()),

            // Mac OS specific selection mappings
            keyMapping(new KeyBinding(LEFT).shift().alt(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;T&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHome()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEnd()),
            keyMapping(new KeyBinding(LEFT).ctrl(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(H).ctrl(), e -&gt; deletePreviousChar()),
            keyMapping(new KeyBinding(DELETE).ctrl(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -&gt; c.deselect()),
            keyMapping(new KeyBinding(Y).ctrl(), e -&gt; redo(), validOnWindows),
            keyMapping(new KeyBinding(Z).ctrl().shift(), e -&gt; redo(), validOnLinux),
            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, nonMacOsInputMap);

        addKeyPadMappings(inputMap);

        textInputControl.textProperty().addListener(textListener);

        contextMenu = new ContextMenu();
}

    @Override public InputMap&lt;T&gt; getInputMap() {
        return inputMap;
    }

    /**
     * Bind keypad arrow keys to the same as the regular arrow keys.
     */
    protected void addKeyPadMappings(InputMap&lt;T&gt; map) {
        // First create a temporary map for the keypad mappings
        InputMap&lt;T&gt; tmpMap = new InputMap&lt;&gt;(getNode());
        for (Object o : map.getMappings()) {
            if (o instanceof KeyMapping) {
                KeyMapping mapping = (KeyMapping)o;
                KeyBinding kb = (KeyBinding)mapping.getMappingKey();
                if (kb.getCode() != null) {
                    KeyCode newCode = null;
                    switch (kb.getCode()) {
                        case LEFT:  newCode = KP_LEFT;  break;
                        case RIGHT: newCode = KP_RIGHT; break;
                        case UP:    newCode = KP_UP;    break;
                        case DOWN:  newCode = KP_DOWN;  break;
                        default:
                    }
                    if (newCode != null) {
                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())
                                                                  .ctrl(kb.getCtrl())
                                                                  .alt(kb.getAlt())
                                                                  .meta(kb.getMeta());
                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));
                    }
                }
            }
        }
        // Install mappings
        for (Object o : tmpMap.getMappings()) {
            map.getMappings().add((KeyMapping)o);
        }

        // Recursive call for child maps
        for (Object o : map.getChildInputMaps()) {
            addKeyPadMappings((InputMap&lt;T&gt;)o);
        }
    }


    /**
     * Wraps the event handler to pause caret blinking when
     * processing the key event.
     */
    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(new KeyBinding(keyCode), eventHandler);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(keyBinding, eventHandler, null);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler,
                                    Predicate&lt;KeyEvent&gt; interceptor) {
        return new KeyMapping(keyBinding,
                              e -&gt; {
                                  setCaretAnimating(false);
                                  eventHandler.handle(e);
                                  setCaretAnimating(true);
                              },
                              interceptor);
    }





    /**************************************************************************
     * Disposal methods                                                       *
     *************************************************************************/

    @Override public void dispose() {
        textInputControl.textProperty().removeListener(textListener);
        super.dispose();
    }

    /**************************************************************************
     * Abstract methods                                                       *
     *************************************************************************/

    protected abstract void deleteChar(boolean previous);
    protected abstract void replaceText(int start, int end, String txt);
    protected abstract void setCaretAnimating(boolean play);
    protected abstract void deleteFromLineStart();

    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void contextMenuRequested(ContextMenuEvent e);

    /**************************************************************************
     * Key handling implementation                                            *
     *************************************************************************/

    /**
     * The default handler for a key typed event, which is called when none of
     * the other key bindings match. This is the method which handles basic
     * text entry.
     * @param event not null
     */
    private void defaultKeyTyped(KeyEvent event) {
        final TextInputControl textInput = getNode();
        // I'm not sure this case can actually ever happen, maybe this
        // should be an assert instead?
        if (!textInput.isEditable() || textInput.isDisabled()) return;

        // Sometimes we get events with no key character, in which case
        // we need to bail.
        String character = event.getCharacter();
        if (character.length() == 0) return;

        // Filter out control keys except control+Alt on PC or Alt on Mac
        if (event.isControlDown() || event.isAltDown() || (isMac() &amp;&amp; event.isMetaDown())) {
            if (!((event.isControlDown() || isMac()) &amp;&amp; event.isAltDown())) return;
        }

        setEditing(true);

        // Ignore characters in the control range and the ASCII delete
        // character as well as meta key presses
        if (character.charAt(0) &gt; 0x1F
                &amp;&amp; character.charAt(0) != 0x7F
                &amp;&amp; !event.isMetaDown()) { // Not sure about this one
            final IndexRange selection = textInput.getSelection();
            final int start = selection.getStart();
            final int end = selection.getEnd();

            replaceText(start, end, character);
        }

        setEditing(false);
    }

    private Bidi bidi = null;
    private Boolean mixed = null;
    private Boolean rtlText = null;

    private void invalidateBidi() {
        bidi = null;
        mixed = null;
        rtlText = null;
    }

    private Bidi getBidi() {
        if (bidi == null) {
            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),
                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)
                            ? Bidi.DIRECTION_RIGHT_TO_LEFT
                            : Bidi.DIRECTION_LEFT_TO_RIGHT);
        }
        return bidi;
    }

    protected boolean isMixed() {
        if (mixed == null) {
            mixed = getBidi().isMixed();
        }
        return mixed;
    }

    protected boolean isRTLText() {
        if (rtlText == null) {
            Bidi bidi = getBidi();
            rtlText =
                    (bidi.isRightToLeft() ||
                            (isMixed() &amp;&amp;
                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));
        }
        return rtlText;
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isMixed()) {
            TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;)textInputControl.getSkin();
            skin.moveCaret(TextUnit.CHARACTER, moveRight ? Direction.RIGHT : Direction.LEFT, false);
        } else if (moveRight != isRTLText()) {
            textInputControl.forward();
        } else {
            textInputControl.backward();
        }
    }

    private void selectLeft() {
        if (isRTLText()) {
            textInputControl.selectForward();
        } else {
            textInputControl.selectBackward();
        }
    }

    private void selectRight() {
        if (isRTLText()) {
            textInputControl.selectBackward();
        } else {
            textInputControl.selectForward();
        }
    }

    private void deletePreviousChar() {
        setEditing(true);
        deleteChar(true);
        setEditing(false);
    }

    private void deleteNextChar() {
        setEditing(true);
        deleteChar(false);
        setEditing(false);
    }

    protected void deletePreviousWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int end = textInputControl.getCaretPosition();

        if (end &gt; 0) {
            textInputControl.previousWord();
            int start = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    protected void deleteNextWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int start = textInputControl.getCaretPosition();

        if (start &lt; textInputControl.getLength()) {
            nextWord();
            int end = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    public void deleteSelection() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        IndexRange selection = textInputControl.getSelection();

        if (selection.getLength() &gt; 0) {
            deleteChar(false);
        }
        setEditing(false);
    }

    public void cut() {
        setEditing(true);
        getNode().cut();
        setEditing(false);
    }

    public void paste() {
        setEditing(true);
        getNode().paste();
        setEditing(false);
    }

    public void undo() {
        setEditing(true);
        getNode().undo();
        setEditing(false);
    }

    public void redo() {
        setEditing(true);
        getNode().redo();
        setEditing(false);
    }

    protected void selectPreviousWord() {
        getNode().selectPreviousWord();
<A NAME="44"></A>    }

    public void selectNextWord() {
        <FONT color="#e57ded"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#44',2,'match44-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.selectEndOfNextWord();
        } else {
            textInputControl.selectNextWord();
        }
    }</B></FONT>

    private void selectLeftWord() {
        if (isRTLText()) {
            selectNextWord();
        } else {
            selectPreviousWord();
        }
    }

    private void selectRightWord() {
        if (isRTLText()) {
            selectPreviousWord();
        } else {
            selectNextWord();
        }
    }

    protected void selectWord() {
        final TextInputControl textInputControl = getNode();
        textInputControl.previousWord();
        if (isWindows()) {
            textInputControl.selectNextWord();
        } else {
            textInputControl.selectEndOfNextWord();
        }
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void selectAll() {
        getNode().selectAll();
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void previousWord() {
        getNode().previousWord();
    }

    protected void nextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.endOfNextWord();
        } else {
            textInputControl.nextWord();
        }
    }

    private void leftWord() {
        if (isRTLText()) {
            nextWord();
        } else {
            previousWord();
        }
    }

    private void rightWord() {
        if (isRTLText()) {
            previousWord();
        } else {
            nextWord();
        }
    }

    protected void fire(KeyEvent event) { } // TODO move to TextFieldBehavior
    protected void cancelEdit(KeyEvent event) { forwardToParent(event);} // not autoconsumed

    protected void forwardToParent(KeyEvent event) {
        // fix for JDK-8145515
        if (getNode().getProperties().containsKey(DISABLE_FORWARD_TO_PARENT)) {
            return;
        }

        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }

    protected void selectHome() {
        getNode().selectHome();
    }

    protected void selectEnd() {
        getNode().selectEnd();
    }

    protected void selectHomeExtend() {
        getNode().extendSelection(0);
    }

    protected void selectEndExtend() {
        TextInputControl textInputControl = getNode();
        textInputControl.extendSelection(textInputControl.getLength());
    }

    private boolean editing = false;
    protected void setEditing(boolean b) {
        editing = b;
    }
    public boolean isEditing() {
        return editing;
    }

    protected void populateContextMenu() {
        TextInputControl textInputControl = getNode();
        boolean editable = textInputControl.isEditable();
        boolean hasText = (textInputControl.getLength() &gt; 0);
        boolean hasSelection = (textInputControl.getSelection().getLength() &gt; 0);
        boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength());
        boolean maskText = (textInputControl instanceof PasswordField); // (maskText(&quot;A&quot;) != &quot;A&quot;);
        ObservableList&lt;MenuItem&gt; items = contextMenu.getItems();

        if (SHOW_HANDLES) {
            items.clear();
            if (!maskText &amp;&amp; hasSelection) {
                if (editable) {
                    items.add(cutMI);
                }
                items.add(copyMI);
            }
            if (editable &amp;&amp; Clipboard.getSystemClipboard().hasString()) {
                items.add(pasteMI);
            }
            if (hasText &amp;&amp; !allSelected) {
                if (!hasSelection &amp;&amp; !(textInputControl instanceof PasswordField)) {
                    items.add(selectWordMI);
                }
                items.add(selectAllMI);
            }
            selectWordMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
            selectAllMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
        } else {
            if (editable) {
                items.setAll(undoMI, redoMI, cutMI, copyMI, pasteMI, deleteMI,
                        separatorMI, selectAllMI);
            } else {
                items.setAll(copyMI, separatorMI, selectAllMI);
            }
            undoMI.setDisable(!getNode().isUndoable());
            redoMI.setDisable(!getNode().isRedoable());
            cutMI.setDisable(maskText || !hasSelection);
            copyMI.setDisable(maskText || !hasSelection);
            pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString());
            deleteMI.setDisable(!hasSelection);
        }
    }

    private static class ContextMenuItem extends MenuItem {
        ContextMenuItem(final String action, EventHandler&lt;ActionEvent&gt; onAction) {
            super(getString(&quot;TextInputControl.menu.&quot; + action));
            setOnAction(onAction);
        }
    }

    private final MenuItem undoMI   = new ContextMenuItem(&quot;Undo&quot;, e -&gt; undo());
    private final MenuItem redoMI   = new ContextMenuItem(&quot;Redo&quot;, e -&gt; redo());
    private final MenuItem cutMI    = new ContextMenuItem(&quot;Cut&quot;, e -&gt; cut());
    private final MenuItem copyMI   = new ContextMenuItem(&quot;Copy&quot;, e -&gt; getNode().copy());
    private final MenuItem pasteMI  = new ContextMenuItem(&quot;Paste&quot;, e -&gt; paste());
    private final MenuItem deleteMI = new ContextMenuItem(&quot;DeleteSelection&quot;, e -&gt; deleteSelection());
    private final MenuItem selectWordMI = new ContextMenuItem(&quot;SelectWord&quot;, e -&gt; selectWord());
    private final MenuItem selectAllMI = new ContextMenuItem(&quot;SelectAll&quot;, e -&gt; selectAll());
    private final MenuItem separatorMI = new SeparatorMenuItem();

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/PieChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
<A NAME="22"></A>import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
<FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#22',2,'match44-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Side;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcTo;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.ClosePath;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.text.Text;
import javafx.scene.transform.Scale;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend;
import com.sun.javafx.charts.Legend.LegendItem;
import com.sun.javafx.collections.NonIterableChange;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.SizeConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Displays a PieChart. The chart content is populated by pie slices based on
 * data set on the PieChart.
 * &lt;p&gt; The clockwise property is set to true by default, which means slices are
 * placed in the clockwise order. The labelsVisible property is used to either display
 * pie slice labels or not.
 *
 * @since JavaFX 2.0
 */
public class PieChart extends Chart {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------
    private static final int MIN_PIE_RADIUS = 25;
    private static final double LABEL_TICK_GAP = 6;
    private static final double LABEL_BALL_RADIUS = 2;
    private BitSet colorBits = new BitSet(8);
    private double pieRadius</B></FONT>;
    private Data begin = null;
    private final Path labelLinePath = new Path() {
        @Override public boolean usesMirroring() {
            return false;
        }
    };
    private List&lt;LabelLayoutInfo&gt; labelLayoutInfos = null;
    private Legend legend = new Legend();
    private Data dataItemBeingRemoved = null;
    private Timeline dataRemoveTimeline = null;
    private final ListChangeListener&lt;Data&gt; dataChangeListener = c -&gt; {
        while (c.next()) {
            // RT-28090 Probably a sort happened, just reorder the pointers.
            if (c.wasPermutated()) {
                Data ptr = begin;
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                    if (i == 0) {
                        begin = item;
                        ptr = begin;
                        begin.next = null;
                    } else {
                        ptr.next = item;
                        item.next = null;
                        ptr = item;
                    }
                }
                updateLegend();
                requestChartLayout();
                return;
            }
            // recreate linked list &amp; set chart on new data
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                item.setChart(PieChart.this);
                if (begin == null) {
                    begin = item;
                    begin.next = null;
                } else {
                    if (i == 0) {
                        item.next = begin;
                        begin = item;
                    } else {
                        Data ptr = begin;
                        for (int j = 0; j &lt; i -1 ; j++) {
                            ptr = ptr.next;
                        }
                        item.next = ptr.next;
                        ptr.next = item;
                    }
                }
            }
            // call data added/removed methods
            for (Data item : c.getRemoved()) {
                dataItemRemoved(item);
            }
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                // assign default color to the added slice
                // TODO: check nearby colors
                item.defaultColorIndex = colorBits.nextClearBit(0);
                colorBits.set(item.defaultColorIndex);
                dataItemAdded(item, i);
            }
            if (c.wasRemoved() || c.wasAdded()) {
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                }
                updateLegend();
            }
        }
        // re-layout everything
        requestChartLayout();
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** PieCharts data */
    private ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; data = new ObjectPropertyBase&lt;ObservableList&lt;Data&gt;&gt;() {
        private ObservableList&lt;Data&gt; old;
        @Override protected void invalidated() {
            final ObservableList&lt;Data&gt; current = getValue();
            // add remove listeners
            if(old != null) old.removeListener(dataChangeListener);
            if(current != null) current.addListener(dataChangeListener);
            // fire data change event if series are added or removed
            if(old != null || current != null) {
                final List&lt;Data&gt; removed = (old != null) ? old : Collections.&lt;Data&gt;emptyList();
                final int toIndex = (current != null) ? current.size() : 0;
                // let data listener know all old data have been removed and new data that has been added
                if (toIndex &gt; 0 || !removed.isEmpty()) {
                    dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, toIndex, current){
                        @Override public List&lt;Data&gt; getRemoved() { return removed; }
                        @Override public boolean wasPermutated() { return false; }
                        @Override protected int[] getPermutation() {
                            return new int[0];
                        }
                    });
                }
            } else if (old != null &amp;&amp; old.size() &gt; 0) {
                // let series listener know all old series have been removed
                dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, 0, current){
                    @Override public List&lt;Data&gt; getRemoved() { return old; }
                    @Override public boolean wasPermutated() { return false; }
                    @Override protected int[] getPermutation() {
                        return new int[0];
                    }
                });
            }
            old = current;
        }

        public Object getBean() {
            return PieChart.this;
        }

        public String getName() {
            return &quot;data&quot;;
        }
    };
    public final ObservableList&lt;Data&gt; getData() { return data.getValue(); }
    public final void setData(ObservableList&lt;Data&gt; value) { data.setValue(value); }
    public final ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; dataProperty() { return data; }

    /** The angle to start the first pie slice at */
    private DoubleProperty startAngle = new StyleableDoubleProperty(0) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;startAngle&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.START_ANGLE;
        }
    };
    public final double getStartAngle() { return startAngle.getValue(); }
    public final void setStartAngle(double value) { startAngle.setValue(value); }
    public final DoubleProperty startAngleProperty() { return startAngle; }

    /** When true we start placing slices clockwise from the startAngle */
    private BooleanProperty clockwise = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;clockwise&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CLOCKWISE;
        }
    };
    public final void setClockwise(boolean value) { clockwise.setValue(value);}
    public final boolean isClockwise() { return clockwise.getValue(); }
    public final BooleanProperty clockwiseProperty() { return clockwise; }


    /** The length of the line from the outside of the pie to the slice labels. */
    private DoubleProperty labelLineLength = new StyleableDoubleProperty(20d) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelLineLength&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.LABEL_LINE_LENGTH;
        }
    };
    public final double getLabelLineLength() { return labelLineLength.getValue(); }
    public final void setLabelLineLength(double value) { labelLineLength.setValue(value); }
    public final DoubleProperty labelLineLengthProperty() { return labelLineLength; }

    /** When true pie slice labels are drawn */
    private BooleanProperty labelsVisible = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelsVisible&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LABELS_VISIBLE;
        }
    };
    public final void setLabelsVisible(boolean value) { labelsVisible.setValue(value);}

    /**
     * Indicates whether pie slice labels are drawn or not
     * @return true if pie slice labels are visible and false otherwise.
     */
    public final boolean getLabelsVisible() { return labelsVisible.getValue(); }
    public final BooleanProperty labelsVisibleProperty() { return labelsVisible; }

    // -------------- CONSTRUCTOR ----------------------------------------------

    /**
     * Construct a new empty PieChart.
     */
    public PieChart() {
        this(FXCollections.&lt;Data&gt;observableArrayList());
    }

    /**
     * Construct a new PieChart with the given data
     *
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public PieChart(ObservableList&lt;PieChart.Data&gt; data) {
        getChartChildren().add(labelLinePath);
        labelLinePath.getStyleClass().add(&quot;chart-pie-label-line&quot;);
        setLegend(legend);
        setData(data);
        // set chart content mirroring to be always false i.e. chartContent mirrorring is not done
        // when  node orientation is right-to-left for PieChart.
        useChartContentMirroring = false;
    }

    // -------------- METHODS --------------------------------------------------

    private void dataNameChanged(Data item) {
        item.textNode.setText(item.getName());
        requestChartLayout();
        updateLegend();
    }

    private void dataPieValueChanged(Data item) {
        if (shouldAnimate()) {
            animate(
                new KeyFrame(Duration.ZERO, new KeyValue(item.currentPieValueProperty(),
                        item.getCurrentPieValue())),
                new KeyFrame(Duration.millis(500),new KeyValue(item.currentPieValueProperty(),
                        item.getPieValue(), Interpolator.EASE_BOTH))
            );
        } else {
            item.setCurrentPieValue(item.getPieValue());
            requestChartLayout(); // RT-23091
        }
    }

    private Node createArcRegion(Data item) {
        Node arcRegion = item.getNode();
        // check if symbol has already been created
        if (arcRegion == null) {
            arcRegion = new Region();
            arcRegion.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
            arcRegion.setPickOnBounds(false);
            item.setNode(arcRegion);
        }
        return arcRegion;
    }

    private Text createPieLabel(Data item) {
        Text text = item.textNode;
        text.setText(item.getName());
        return text;
    }

    private void updateDataItemStyleClass(final Data item, int index) {
        Node node = item.getNode();
        if (node != null) {
            // Note: not sure if we want to add or check, ie be more careful and efficient here
            node.getStyleClass().setAll(&quot;chart-pie&quot;, &quot;data&quot; + index,
                    &quot;default-color&quot; + item.defaultColorIndex % 8);
            if (item.getPieValue() &lt; 0) {
                node.getStyleClass().add(&quot;negative&quot;);
            }
        }
    }

    private void dataItemAdded(final Data item, int index) {
        // create shape
        Node shape = createArcRegion(item);
        final Text text = createPieLabel(item);
        item.getChart().getChartChildren().add(shape);
        if (shouldAnimate()) {
            // if the same data item is being removed, first stop the remove animation,
            // remove the item and then start the add animation.
            if (dataRemoveTimeline != null &amp;&amp; dataRemoveTimeline.getStatus().equals(Animation.Status.RUNNING)) {
                if (dataItemBeingRemoved == item) {
                    dataRemoveTimeline.stop();
                    dataRemoveTimeline = null;
                    getChartChildren().remove(item.textNode);
                    getChartChildren().remove(shape);
                    removeDataItemRef(item);
                }
            }
            animate(
                new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            text.setOpacity(0);
                            // RT-23597 : item's chart might have been set to null if
                            // this item is added and removed before its add animation finishes.
                            if (item.getChart() == null) item.setChart(PieChart.this);
                            item.getChart().getChartChildren().add(text);
                            FadeTransition ft = new FadeTransition(Duration.millis(150),text);
                            ft.setToValue(1);
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), item.getPieValue(), Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 1, Interpolator.EASE_BOTH))
            );
        } else {
            getChartChildren().add(text);
            item.setRadiusMultiplier(1);
            item.setCurrentPieValue(item.getPieValue());
        }

        // we sort the text nodes to always be at the end of the children list, so they have a higher z-order
        // (Fix for RT-34564)
        for (int i = 0; i &lt; getChartChildren().size(); i++) {
            Node n = getChartChildren().get(i);
            if (n instanceof Text) {
                n.toFront();
            }
        }
    }

    private void removeDataItemRef(Data item) {
        if (begin == item) {
            begin = item.next;
        } else {
            Data ptr = begin;
            while(ptr != null &amp;&amp; ptr.next != item) {
                ptr = ptr.next;
            }
            if(ptr != null) ptr.next = item.next;
        }
    }

    private Timeline createDataRemoveTimeline(final Data item) {
        final Node shape = item.getNode();
        Timeline t = new Timeline();
        t.getKeyFrames().addAll(new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            // removing item
                            colorBits.clear(item.defaultColorIndex);
                            getChartChildren().remove(shape);
                            // fade out label
                            FadeTransition ft = new FadeTransition(Duration.millis(150),item.textNode);
                            ft.setFromValue(1);
                            ft.setToValue(0);
                            ft.setOnFinished(new EventHandler&lt;ActionEvent&gt;() {
                                 @Override public void handle(ActionEvent actionEvent) {
                                     getChartChildren().remove(item.textNode);
                                     // remove chart references from old data - RT-22553
                                     item.setChart(null);
                                     removeDataItemRef(item);
                                     item.textNode.setOpacity(1.0);
                                 }
                            });
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), 0, Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 0))
                );
        return t;
    }

    private void dataItemRemoved(final Data item) {
        final Node shape = item.getNode();
        if (shouldAnimate()) {
            dataRemoveTimeline = createDataRemoveTimeline(item);
            dataItemBeingRemoved = item;
            animate(dataRemoveTimeline);
        } else {
            colorBits.clear(item.defaultColorIndex);
            getChartChildren().remove(item.textNode);
            getChartChildren().remove(shape);
            // remove chart references from old data
            item.setChart(null);
            removeDataItemRef(item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChartChildren(double top, double left, double contentWidth, double contentHeight) {
        double total = 0.0;
        for (Data item = begin; item != null; item = item.next) {
            total+= Math.abs(item.getCurrentPieValue());
        }
        double scale = (total != 0) ? 360 / total : 0;

         // calculate combined bounds of all labels &amp; pie radius
        double[] labelsX = null;
        double[] labelsY = null;
        double[] labelAngles = null;
        double labelScale = 1;
        List&lt;LabelLayoutInfo&gt; fullPie = null;
        boolean shouldShowLabels = getLabelsVisible();
        if (shouldShowLabels) {
            double xPad = 0d;
            double yPad = 0d;

            labelsX = new double[getDataSize()];
            labelsY = new double[getDataSize()];
            labelAngles = new double[getDataSize()];
            fullPie = new ArrayList&lt;&gt;();
            int index = 0;
            double start = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                // remove any scale on the text node
                item.textNode.getTransforms().clear();

                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                labelAngles[index] = normalizeAngle(start + (size / 2));
                final double sproutX = calcX(labelAngles[index], getLabelLineLength(), 0);
                final double sproutY = calcY(labelAngles[index], getLabelLineLength(), 0);
                labelsX[index] = sproutX;
                labelsY[index] = sproutY;
                xPad = Math.max(xPad, 2 * (item.textNode.getLayoutBounds().getWidth() + LABEL_TICK_GAP + Math.abs(sproutX)));
                if (sproutY &gt; 0) { // on bottom
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY+item.textNode.getLayoutBounds().getMaxY()));
                } else { // on top
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY + item.textNode.getLayoutBounds().getMinY()));
                }
                start+= size;
                index++;
            }
            pieRadius = Math.min(contentWidth - xPad, contentHeight - yPad) / 2;
            // check if this makes the pie too small
            if (pieRadius &lt; MIN_PIE_RADIUS ) {
                // calculate scale for text to fit labels in
                final double roomX = contentWidth-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                final double roomY = contentHeight-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                labelScale = Math.min(
                        roomX/xPad,
                        roomY/yPad
                );
                // hide labels if pie radius is less than minimum
                if ((begin == null &amp;&amp; labelScale &lt; 0.7) || ((begin.textNode.getFont().getSize()*labelScale) &lt; 9)) {
                    shouldShowLabels = false;
                    labelScale = 1;
                } else {
                    // set pieRadius to minimum
                    pieRadius = MIN_PIE_RADIUS;
                    // apply scale to all label positions
                    for(int i=0; i&lt; labelsX.length; i++) {
                        labelsX[i] =  labelsX[i] * labelScale;
                        labelsY[i] =  labelsY[i] * labelScale;
                    }
                }
            }
        }

        if (!shouldShowLabels) {
            pieRadius = Math.min(contentWidth,contentHeight) / 2;
            labelLinePath.getElements().clear();
        }

        if (getChartChildren().size() &gt; 0) {
            double centerX = contentWidth / 2 + left;
            double centerY = contentHeight / 2 + top;
            int index = 0;
            for (Data item = begin; item != null; item = item.next) {
                // layout labels for pie slice
                item.textNode.setVisible(shouldShowLabels);
                if (shouldShowLabels) {
                    double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                    final boolean isLeftSide = !(labelAngles[index] &gt; -90 &amp;&amp; labelAngles[index] &lt; 90);

                    double sliceCenterEdgeX = calcX(labelAngles[index], pieRadius, centerX);
                    double sliceCenterEdgeY = calcY(labelAngles[index], pieRadius, centerY);
                    double xval = isLeftSide ?
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMaxX() - LABEL_TICK_GAP) :
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMinX() + LABEL_TICK_GAP);
                    double yval = labelsY[index] + sliceCenterEdgeY - (item.textNode.getLayoutBounds().getMinY()/2) -2;

                    // do the line (Path)for labels
                    double lineEndX = sliceCenterEdgeX +labelsX[index];
                    double lineEndY = sliceCenterEdgeY +labelsY[index];
                    LabelLayoutInfo info = new LabelLayoutInfo(sliceCenterEdgeX,
                            sliceCenterEdgeY,lineEndX, lineEndY, xval, yval, item.textNode, Math.abs(size));
                    fullPie.add(info);

                    // set label scales
                    if (labelScale &lt; 1) {
                        item.textNode.getTransforms().add(
                            new Scale(
                                    labelScale, labelScale,
                                    isLeftSide ? item.textNode.getLayoutBounds().getWidth() : 0, 0
                            )
                        );
                    }
                }
                index++;
            }

            // update/draw pie slices
            double sAngle = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                Node node = item.getNode();
                Arc arc = null;
                if (node != null) {
                    if (node instanceof Region) {
                        Region arcRegion = (Region)node;
                        if (arcRegion.getShape() == null) {
                            arc = new Arc();
                            arcRegion.setShape(arc);
                        } else {
                            arc = (Arc)arcRegion.getShape();
                        }
                        arcRegion.setScaleShape(false);
                        arcRegion.setCenterShape(false);
                        arcRegion.setCacheShape(false);
                    }
                }
                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                // update slice arc size
                arc.setStartAngle(sAngle);
                arc.setLength(size);
                arc.setType(ArcType.ROUND);
                arc.setRadiusX(pieRadius * item.getRadiusMultiplier());
                arc.setRadiusY(pieRadius * item.getRadiusMultiplier());
                node.setLayoutX(centerX);
                node.setLayoutY(centerY);
                sAngle += size;
            }
            // finally draw the text and line
            if (fullPie != null) {
                // Check for collision and resolve by hiding the label of the smaller pie slice
                resolveCollision(fullPie);

                if (!fullPie.equals(labelLayoutInfos)) {
                    labelLinePath.getElements().clear();
                    for (LabelLayoutInfo info : fullPie) {
                        if (info.text.isVisible()) drawLabelLinePath(info);
                    }
                    labelLayoutInfos = fullPie;
                }
            }
        }
    }

    // We check for pie slice label collision and if collision is detected, we then
    // compare the size of the slices, and hide the label of the smaller slice.
    private void resolveCollision(List&lt;LabelLayoutInfo&gt; list) {
        int boxH = (begin != null) ? (int)begin.textNode.getLayoutBounds().getHeight() : 0;
        for (int i = 0; i &lt; list.size(); i++ ) {
            for (int j = i+1; j &lt; list.size(); j++ ) {
                LabelLayoutInfo box1 = list.get(i);
                LabelLayoutInfo box2 = list.get(j);
                if ((box1.text.isVisible() &amp;&amp; box2.text.isVisible()) &amp;&amp;
                        (fuzzyGT(box2.textY, box1.textY) ? fuzzyLT((box2.textY - boxH - box1.textY), 2) :
                                fuzzyLT((box1.textY - boxH - box2.textY), 2)) &amp;&amp;
                        (fuzzyGT(box1.textX, box2.textX) ? fuzzyLT((box1.textX - box2.textX), box2.text.prefWidth(-1)) :
                                fuzzyLT((box2.textX - box1.textX), box1.text.prefWidth(-1)))) {
                    if (fuzzyLT(box1.size, box2.size)) {
                        box1.text.setVisible(false);
                    } else {
                        box2.text.setVisible(false);
                    }
                }
            }
        }
    }

    private int fuzzyCompare(double o1, double o2) {
       double fuzz = 0.00001;
       return (((Math.abs(o1 - o2)) &lt; fuzz) ? 0 : ((o1 &lt; o2) ? -1 : 1));
    }

    private boolean fuzzyGT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == 1;
    }

    private boolean fuzzyLT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == -1;
    }

    private void drawLabelLinePath(LabelLayoutInfo info) {
        info.text.setLayoutX(info.textX);
        info.text.setLayoutY(info.textY);
        labelLinePath.getElements().add(new MoveTo(info.startX, info.startY));
        labelLinePath.getElements().add(new LineTo(info.endX, info.endY));

        labelLinePath.getElements().add(new MoveTo(info.endX-LABEL_BALL_RADIUS,info.endY));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY-LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX+LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY+LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX-LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ClosePath());
    }
    /**
     * This is called whenever a series is added or removed and the legend needs to be updated
     */
    private void updateLegend() {
        Node legendNode = getLegend();
        if (legendNode != null &amp;&amp; legendNode != legend) return; // RT-23596 dont update when user has set legend.
        legend.setVertical(getLegendSide().equals(Side.LEFT) || getLegendSide().equals(Side.RIGHT));
        List&lt;Legend.LegendItem&gt; legendList = new ArrayList&lt;&gt;();
        if (getData() != null) {
            for (Data item : getData()) {
                LegendItem legenditem = new LegendItem(item.getName());
                legenditem.getSymbol().getStyleClass().addAll(item.getNode().getStyleClass());
                legenditem.getSymbol().getStyleClass().add(&quot;pie-legend-symbol&quot;);
                legendList.add(legenditem);
            }
        }
        legend.getItems().setAll(legendList);
        if (legendList.size() &gt; 0) {
            if (legendNode == null) {
                setLegend(legend);
            }
        } else {
            setLegend(null);
        }
    }

    private int getDataSize() {
        int count = 0;
        for (Data d = begin; d != null; d = d.next) {
            count++;
        }
        return count;
    }

    private static double calcX(double angle, double radius, double centerX) {
        return (double)(centerX + radius * Math.cos(Math.toRadians(-angle)));
    }

    private static double calcY(double angle, double radius, double centerY) {
        return (double)(centerY + radius * Math.sin(Math.toRadians(-angle)));
    }

     /** Normalize any angle into -180 to 180 deg range */
    private static double normalizeAngle(double angle) {
        double a = angle % 360;
        if (a &lt;= -180) a += 360;
        if (a &gt; 180) a -= 360;
        return a;
    }

    // -------------- INNER CLASSES --------------------------------------------

    // Class holding label line layout info for collision detection and removal
    private final static class LabelLayoutInfo {
        double startX;
        double startY;
        double endX;
        double endY;
        double textX;
        double textY;
        Text text;
        double size;

        LabelLayoutInfo(double startX, double startY, double endX, double endY,
                double textX, double textY, Text text, double size) {
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
            this.textX = textX;
            this.textY = textY;
            this.text = text;
            this.size = size;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            LabelLayoutInfo that = (LabelLayoutInfo) o;
            return Double.compare(that.startX, startX) == 0 &amp;&amp;
                    Double.compare(that.startY, startY) == 0 &amp;&amp;
                    Double.compare(that.endX, endX) == 0 &amp;&amp;
                    Double.compare(that.endY, endY) == 0 &amp;&amp;
                    Double.compare(that.textX, textX) == 0 &amp;&amp;
                    Double.compare(that.textY, textY) == 0 &amp;&amp;
                    Double.compare(that.size, size) == 0;
        }

        @Override
        public int hashCode() {
            return Objects.hash(startX, startY, endX, endY, textX, textY, size);
        }
    }

    /**
     * PieChart Data Item, represents one slice in the PieChart
     *
     * @since JavaFX 2.0
     */
    public final static class Data {

        private Text textNode = new Text();
        /**
         * Next pointer for the next data item : so we can do animation on data delete.
         */
        private Data next = null;

        /**
         * Default color index for this slice.
         */
        private int defaultColorIndex;

        // -------------- PUBLIC PROPERTIES ------------------------------------

        /**
         * The chart which this data belongs to.
         */
        private ReadOnlyObjectWrapper&lt;PieChart&gt; chart = new ReadOnlyObjectWrapper&lt;PieChart&gt;(this, &quot;chart&quot;);

        public final PieChart getChart() {
            return chart.getValue();
        }

        private void setChart(PieChart value) {
            chart.setValue(value);
        }

        public final ReadOnlyObjectProperty&lt;PieChart&gt; chartProperty() {
            return chart.getReadOnlyProperty();
        }

        /**
         * The name of the pie slice
         */
        private StringProperty name = new StringPropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataNameChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;name&quot;;
            }
        };

        public final void setName(java.lang.String value) {
            name.setValue(value);
        }

        public final java.lang.String getName() {
            return name.getValue();
        }

        public final StringProperty nameProperty() {
            return name;
        }

        /**
         * The value of the pie slice
         */
        private DoubleProperty pieValue = new DoublePropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataPieValueChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;pieValue&quot;;
            }
        };

        public final double getPieValue() {
            return pieValue.getValue();
        }

        public final void setPieValue(double value) {
            pieValue.setValue(value);
        }

        public final DoubleProperty pieValueProperty() {
            return pieValue;
        }

        /**
         * The current pie value, used during animation. This will be the last data value, new data value or
         * anywhere in between
         */
        private DoubleProperty currentPieValue = new SimpleDoubleProperty(this, &quot;currentPieValue&quot;);

        private double getCurrentPieValue() {
            return currentPieValue.getValue();
        }

        private void setCurrentPieValue(double value) {
            currentPieValue.setValue(value);
        }

        private DoubleProperty currentPieValueProperty() {
            return currentPieValue;
        }

        /**
         * Multiplier that is used to animate the radius of the pie slice
         */
        private DoubleProperty radiusMultiplier = new SimpleDoubleProperty(this, &quot;radiusMultiplier&quot;);

        private double getRadiusMultiplier() {
            return radiusMultiplier.getValue();
        }

        private void setRadiusMultiplier(double value) {
            radiusMultiplier.setValue(value);
        }

        private DoubleProperty radiusMultiplierProperty() {
            return radiusMultiplier;
        }

        /**
         * Readonly access to the node that represents the pie slice. You can use this to add mouse event listeners etc.
         */
        private ReadOnlyObjectWrapper&lt;Node&gt; node = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;node&quot;);

        /**
         * Returns the node that represents the pie slice. You can use this to
         * add mouse event listeners etc.
         * @return the node that represents the pie slice
         */
        public Node getNode() {
            return node.getValue();
        }

        private void setNode(Node value) {
            node.setValue(value);
        }

        public ReadOnlyObjectProperty&lt;Node&gt; nodeProperty() {
            return node.getReadOnlyProperty();
        }

        // -------------- CONSTRUCTOR -------------------------------------------------

        /**
         * Constructs a PieChart.Data object with the given name and value.
         *
         * @param name  name for Pie
         * @param value pie value
         */
        public Data(java.lang.String name, double value) {
            setName(name);
            setPieValue(value);
            textNode.getStyleClass().addAll(&quot;text&quot;, &quot;chart-pie-label&quot;);
            textNode.setAccessibleRole(AccessibleRole.TEXT);
            textNode.setAccessibleRoleDescription(&quot;slice&quot;);
            textNode.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            textNode.accessibleTextProperty().bind( new StringBinding() {
                {bind(nameProperty(), currentPieValueProperty());}
                @Override protected String computeValue() {
                    return getName() + &quot; represents &quot; + getCurrentPieValue() + &quot; percent&quot;;
                }
            });
        }

        // -------------- PUBLIC METHODS ----------------------------------------------

        /**
         * Returns a string representation of this {@code Data} object.
         *
         * @return a string representation of this {@code Data} object.
         */
        @Override
        public java.lang.String toString() {
            return &quot;Data[&quot; + getName() + &quot;,&quot; + getPieValue() + &quot;]&quot;;
        }
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;PieChart,Boolean&gt; CLOCKWISE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-clockwise&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.clockwise == null || !node.clockwise.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.clockwiseProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Boolean&gt; LABELS_VISIBLE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-pie-label-visible&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelsVisible == null || !node.labelsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.labelsVisibleProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; LABEL_LINE_LENGTH =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-label-line-length&quot;,
                 SizeConverter.getInstance(), 20d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelLineLength == null || !node.labelLineLength.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.labelLineLengthProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; START_ANGLE =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-start-angle&quot;,
                 SizeConverter.getInstance(), 0d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.startAngle == null || !node.startAngle.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.startAngleProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Chart.getClassCssMetaData());
            styleables.add(CLOCKWISE);
            styleables.add(LABELS_VISIBLE);
            styleables.add(LABEL_LINE_LENGTH);
            styleables.add(START_ANGLE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TableView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;

import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.control.Logging;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.SelectedCellsMap;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import com.sun.javafx.scene.control.behavior.TableCellBehavior;
import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
import javafx.beans.*;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.Property;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.collections.transformation.SortedList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.util.Callback;

import com.sun.javafx.collections.MappingChange;
import com.sun.javafx.collections.NonIterableChange;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;
import javafx.scene.control.skin.TableViewSkin;

/**
 * The TableView control is designed to visualize an unlimited number of rows
 * of data, broken out into columns. A TableView is therefore very similar to the
 * {@link ListView} control, with the addition of support for columns. For an
 * example on how to create a TableView, refer to the 'Creating a TableView'
 * control section below.
 *
 * &lt;p&gt;The TableView control has a number of features, including:
 * &lt;ul&gt;
 * &lt;li&gt;Powerful {@link TableColumn} API:
 *   &lt;ul&gt;
 *   &lt;li&gt;Support for {@link TableColumn#cellFactoryProperty() cell factories} to
 *      easily customize {@link Cell cell} contents in both rendering and editing
 *      states.
 *   &lt;li&gt;Specification of {@link TableColumn#minWidthProperty() minWidth}/
 *      {@link TableColumn#prefWidthProperty() prefWidth}/
 *      {@link TableColumn#maxWidthProperty() maxWidth},
 *      and also {@link TableColumn#resizableProperty() fixed width columns}.
 *   &lt;li&gt;Width resizing by the user at runtime.
 *   &lt;li&gt;Column reordering by the user at runtime.
 *   &lt;li&gt;Built-in support for {@link TableColumn#getColumns() column nesting}
 *   &lt;/ul&gt;
 * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 *      dictate what happens when the user resizes columns.
 * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 *      the column header (hold down Shift keyboard key whilst clicking on a
 *      header to sort by multiple columns).
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note that TableView is intended to be used to visualize data - it is not
 * intended to be used for laying out your user interface. If you want to lay
 * your user interface out in a grid-like fashion, consider the
 * {@link javafx.scene.layout.GridPane} layout instead.&lt;/p&gt;
 *
 * &lt;h2&gt;Creating a TableView&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Creating a TableView is a multi-step process, and also depends on the
 * underlying data model needing to be represented. For this example we'll use
 * an {@literal ObservableList&lt;Person&gt;}, as it is the simplest way of showing data in a
 * TableView. The {@code Person} class will consist of a first
 * name and last name properties. That is:
 *
 * &lt;pre&gt;
 * {@code
 * public class Person {
 *     private StringProperty firstName;
 *     public void setFirstName(String value) { firstNameProperty().set(value); }
 *     public String getFirstName() { return firstNameProperty().get(); }
 *     public StringProperty firstNameProperty() {
 *         if (firstName == null) firstName = new SimpleStringProperty(this, &quot;firstName&quot;);
 *         return firstName;
 *     }
 *
 *     private StringProperty lastName;
 *     public void setLastName(String value) { lastNameProperty().set(value); }
 *     public String getLastName() { return lastNameProperty().get(); }
 *     public StringProperty lastNameProperty() {
 *         if (lastName == null) lastName = new SimpleStringProperty(this, &quot;lastName&quot;);
 *         return lastName;
 *     }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;Firstly, a TableView instance needs to be defined, as such:
 *
 * &lt;pre&gt;
 * {@code
 * TableView&lt;Person&gt; table = new TableView&lt;&gt;();}&lt;/pre&gt;
 *
 * &lt;p&gt;With the basic table defined, we next focus on the data model. As mentioned,
 * for this example, we'll be using an {@literal ObservableList&lt;Person&gt;}. We can immediately
 * set such a list directly in to the TableView, as such:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = getTeamMembers();
 * table.setItems(teamMembers);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the items set as such, TableView will automatically update whenever
 * the &lt;code&gt;teamMembers&lt;/code&gt; list changes. If the items list is available
 * before the TableView is instantiated, it is possible to pass it directly into
 * the constructor.
 *
 * &lt;p&gt;At this point we now have a TableView hooked up to observe the
 * &lt;code&gt;teamMembers&lt;/code&gt; observableList. The missing ingredient
 * now is the means of splitting out the data contained within the model and
 * representing it in one or more {@link TableColumn TableColumn} instances. To
 * create a two-column TableView to show the firstName and lastName properties,
 * we extend the last code sample as follows:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = ...;
 * table.setItems(teamMembers);
 *
 * TableColumn&lt;Person,String&gt; firstNameCol = new TableColumn&lt;&gt;(&quot;First Name&quot;);
 * firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
 * TableColumn&lt;Person,String&gt; lastNameCol = new TableColumn&lt;&gt;(&quot;Last Name&quot;);
 * lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;lastName&quot;));
 *
 * table.getColumns().setAll(firstNameCol, lastNameCol);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the code shown above we have fully defined the minimum properties
 * required to create a TableView instance. Running this code (assuming the
 * people ObservableList is appropriately created) will result in a TableView being
 * shown with two columns for firstName and lastName. Any other properties of the
 * Person class will not be shown, as no TableColumns are defined.
 *
 * &lt;h3&gt;TableView support for classes that don't contain properties&lt;/h3&gt;
 *
 * &lt;p&gt;The code shown above is the shortest possible code for creating a TableView
 * when the domain objects are designed with JavaFX properties in mind
 * (additionally, {@link javafx.scene.control.cell.PropertyValueFactory} supports
 * normal JavaBean properties too, although there is a caveat to this, so refer
 * to the class documentation for more information). When this is not the case,
 * it is necessary to provide a custom cell value factory. More information
 * about cell value factories can be found in the {@link TableColumn} API
 * documentation, but briefly, here is how a TableColumn could be specified:
 *
 * &lt;pre&gt;
 * {@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the Person instance for a particular TableView row
 *         return p.getValue().firstNameProperty();
 *     }
 * });
 *
 * // or with a lambda expression:
 * firstNameCol.setCellValueFactory(p -&gt; p.getValue().firstNameProperty());
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;TableView Selection / Focus APIs&lt;/h3&gt;
 * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 * {@link SelectionModel} and {@link FocusModel} classes. A TableView has at most
 * one instance of each of these classes, available from
 * {@link #selectionModelProperty() selectionModel} and
 * {@link #focusModelProperty() focusModel} properties respectively.
 * Whilst it is possible to use this API to set a new selection model, in
 * most circumstances this is not necessary - the default selection and focus
 * models should work in most circumstances.
 *
 * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TableView is
 * an implementation of the {@link MultipleSelectionModel} abstract class.
 * However, as noted in the API documentation for
 * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property, the default value is {@link SelectionMode#SINGLE}. To enable
 * multiple selection in a default TableView instance, it is therefore necessary
 * to do the following:
 *
 * &lt;pre&gt;
 * {@code
 * tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 *
 * &lt;h3&gt;Customizing TableView Visuals&lt;/h3&gt;
 * &lt;p&gt;The visuals of the TableView can be entirely customized by replacing the
 * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 * generate {@link TableRow} instances, which are used to represent an entire
 * row in the TableView.
 *
 * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 * the case that cells be customized on a per-column basis, not a per-row basis.
 * It is therefore important to note that a {@link TableRow} is not a
 * {@link TableCell}. A  {@link TableRow} is simply a container for zero or more
 * {@link TableCell}, and in most circumstances it is more likely that you'll
 * want to create custom TableCells, rather than TableRows. The primary use case
 * for creating custom TableRow instances would most probably be to introduce
 * some form of column spanning support.
 *
 * &lt;p&gt;You can create custom {@link TableCell} instances per column by assigning
 * the appropriate function to the TableColumn
 * {@link TableColumn#cellFactoryProperty() cell factory} property.
 *
 * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 * description of how to write custom Cells.
 *
 * &lt;h3&gt;Sorting&lt;/h3&gt;
 * &lt;p&gt;Prior to JavaFX 8.0, the TableView control would treat the
 * {@link #getItems() items} list as the view model, meaning that any changes to
 * the list would be immediately reflected visually. TableView would also modify
 * the order of this list directly when a user initiated a sort. This meant that
 * (again, prior to JavaFX 8.0) it was not possible to have the TableView return
 * to an unsorted state (after iterating through ascending and descending
 * orders).&lt;/p&gt;
 *
 * &lt;p&gt;Starting with JavaFX 8.0 (and the introduction of {@link SortedList}), it
 * is now possible to have the collection return to the unsorted state when
 * there are no columns as part of the TableView
 * {@link #getSortOrder() sort order}. To do this, you must create a SortedList
 * instance, and bind its
 * {@link javafx.collections.transformation.SortedList#comparatorProperty() comparator}
 * property to the TableView {@link #comparatorProperty() comparator} property,
 * list so:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code
 * // create a SortedList based on the provided ObservableList
 * SortedList sortedList = new SortedList(FXCollections.observableArrayList(2, 1, 3));
 *
 * // create a TableView with the sorted list set as the items it will show
 * final TableView&lt;Integer&gt; tableView = new TableView&lt;&gt;(sortedList);
 *
 * // bind the sortedList comparator to the TableView comparator
 * sortedList.comparatorProperty().bind(tableView.comparatorProperty());
 *
 * // Don't forget to define columns!
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 *
 * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 * than when a cell is not being edited. This is the responsibility of the
 * {@link Cell} implementation being used. For TableView, it is highly
 * recommended that editing be
 * {@link javafx.scene.control.TableColumn#cellFactoryProperty() per-TableColumn},
 * rather than {@link #rowFactoryProperty() per row}, as more often than not
 * you want users to edit each column value differently, and this approach allows
 * for editors specific to each column. It is your choice whether the cell is
 * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 * or to switch to a different UI when editing begins (e.g. when a double-click
 * is received on a cell).&lt;/p&gt;
 *
 * &lt;p&gt;To know when editing has been requested on a cell,
 * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 * appropriate (e.g. set the text to null and set the graphic to be a
 * {@link TextField}). Additionally, you should also override
 * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 * when the editing concludes. In both cases it is important that you also
 * ensure that you call the super method to have the cell perform all duties it
 * must do to enter or exit its editing mode.&lt;/p&gt;
 *
 * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 * interested in is how to commit or cancel the editing that is taking place. This is your
 * responsibility as the cell factory provider. Your cell implementation will know
 * when the editing is over, based on the user input (e.g. when the user presses
 * the Enter or ESC keys on their keyboard). When this happens, it is your
 * responsibility to call {@link Cell#commitEdit(Object)} or
 * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 *
 * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 * TableView, which you can observe by adding an {@link EventHandler} via
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 * you can also observe edit events for
 * {@link TableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 * and {@link TableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 *
 * &lt;p&gt;By default the TableColumn edit commit handler is non-null, with a default
 * handler that attempts to overwrite the property value for the
 * item in the currently-being-edited row. It is able to do this as the
 * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 * is passed along to the edit commit handler via the
 * {@link javafx.scene.control.TableColumn.CellEditEvent CellEditEvent} that is
 * fired. It is simply a matter of calling
 * {@link javafx.scene.control.TableColumn.CellEditEvent#getNewValue()} to
 * retrieve this value.
 *
 * &lt;p&gt;It is very important to note that if you call
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 * {@link EventHandler}, then you will be removing the default handler. Unless
 * you then handle the writeback to the property (or the relevant data source),
 * nothing will happen. You can work around this by using the
 * {@link TableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 * method to add a {@link TableColumn#editCommitEvent()} {@link EventType} with
 * your desired {@link EventHandler} as the second argument. Using this method,
 * you will not replace the default implementation, but you will be notified when
 * an edit commit has occurred.&lt;/p&gt;
 *
 * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 * Fortunately, JavaFX ships with a number of pre-built cell factories that
 * handle all the editing requirements on your behalf. You can find these
 * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 *
 * @see TableColumn
 * @see TablePosition
 * @param &lt;S&gt; The type of the objects contained within the TableView items list.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;items&quot;)
public class TableView&lt;S&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    // strings used to communicate via the TableView properties map between
    // the control and the skin. Because they are private here, the strings
    // are also duplicated in the TableViewSkin class - so any changes to these
    // strings must also be duplicated there
    static final String SET_CONTENT_WIDTH = &quot;TableView.contentWidth&quot;;

    /**
     * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
     * provided delta and shifts all other columns (to the right of the given column)
     * further to the right (when the delta is positive) or to the left (when the
     * delta is negative).
     *
     * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
     * or subtracting the removed space, evenly between all immediate children columns.
     * Of course, the immediate children may themselves be nested, and they would
     * then use this policy on their children.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {
        @Override public String toString() {
            return &quot;unconstrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
            return Double.compare(result, 0.0) == 0;
        }
    };

    /**
     * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
     * this table sum up to equal the width of the table itself.
     *
     * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
     * adjusts the width of the right hand side columns. When the user increases a
     * column width, the table decreases the width of the rightmost column until it
     * reaches its minimum width. Then it decreases the width of the second
     * rightmost column until it reaches minimum width and so on. When all right
     * hand side columns reach minimum size, the user cannot increase the size of
     * resized column any more.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {

        private boolean isFirstRun = true;

        @Override public String toString() {
            return &quot;constrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            TableView&lt;?&gt; table = prop.getTable();
            List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
            Boolean result = TableUtil.constrainedResize(prop,
                                               isFirstRun,
                                               table.contentWidth,
                                               visibleLeafColumns);
            isFirstRun = ! isFirstRun ? false : ! result;
            return result;
        }
    };

    /**
     * The default {@link #sortPolicyProperty() sort policy} that this TableView
     * will use if no other policy is specified. The sort policy is a simple
     * {@link Callback} that accepts a TableView as the sole argument and expects
     * a Boolean response representing whether the sort succeeded or not. A Boolean
     * response of true represents success, and a response of false (or null) will
     * be considered to represent failure.
     * @since JavaFX 8.0
     */
    public static final Callback&lt;TableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TableView, Boolean&gt;() {
        @Override public Boolean call(TableView table) {
            try {
                ObservableList&lt;?&gt; itemsList = table.getItems();
                if (itemsList instanceof SortedList) {
                    // it is the responsibility of the SortedList to bind to the
                    // comparator provided by the TableView. However, we don't
                    // want to fail the sort (which would put the UI in an
                    // inconsistent state), so we return true here, but only if
                    // the SortedList has its comparator bound to the TableView
                    // comparator property.
                    SortedList sortedList = (SortedList) itemsList;
                    boolean comparatorsBound = sortedList.comparatorProperty().
                            isEqualTo(table.comparatorProperty()).get();

                    if (! comparatorsBound) {
                        // this isn't a good situation to be in, so lets log it
                        // out in case the developer is unaware
                        if (Logging.getControlsLogger().isLoggable(Level.INFO)) {
                            String s = &quot;TableView items list is a SortedList, but the SortedList &quot; +
                                    &quot;comparator should be bound to the TableView comparator for &quot; +
                                    &quot;sorting to be enabled (e.g. &quot; +
                                    &quot;sortedList.comparatorProperty().bind(tableView.comparatorProperty());).&quot;;
                            Logging.getControlsLogger().info(s);
                        }
                    }
                    return comparatorsBound;
                } else {
                    if (itemsList == null || itemsList.isEmpty()) {
                        // sorting is not supported on null or empty lists
                        return true;
                    }

                    Comparator comparator = table.getComparator();
                    if (comparator == null) {
                        return true;
                    }

                    // otherwise we attempt to do a manual sort, and if successful
                    // we return true
                    FXCollections.sort(itemsList, comparator);
                    return true;
                }
            } catch (UnsupportedOperationException e) {
                // TODO might need to support other exception types including:
                // ClassCastException - if the class of the specified element prevents it from being added to this list
                // NullPointerException - if the specified element is null and this list does not permit null elements
                // IllegalArgumentException - if some property of this element prevents it from being added to this list

                // If we are here the list does not support sorting, so we gracefully
                // fail the sort request and ensure the UI is put back to its previous
                // state. This is handled in the code that calls the sort policy.

                return false;
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TableView control with no content.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     */
    public TableView() {
        this(FXCollections.&lt;S&gt;observableArrayList());
    }

    /**
     * Creates a TableView with the content provided in the items ObservableList.
     * This also sets up an observer such that any changes to the items list
     * will be immediately reflected in the TableView itself.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     *
     * @param items The items to insert into the TableView, and the list to watch
     *          for changes (to automatically show in the TableView).
     */
    public TableView(ObservableList&lt;S&gt; items) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TABLE_VIEW);

        // we quite happily accept items to be null here
        setItems(items);

        // install default selection and focus models
        // it's unlikely this will be changed by many users.
        setSelectionModel(new TableViewArrayListSelectionModel&lt;S&gt;(this));
        setFocusModel(new TableViewFocusModel&lt;S&gt;(this));

        // we watch the columns list, such that when it changes we can update
        // the leaf columns and visible leaf columns lists (which are read-only).
        getColumns().addListener(weakColumnsObserver);

        // watch for changes to the sort order list - and when it changes run
        // the sort method.
        getSortOrder().addListener((ListChangeListener&lt;TableColumn&lt;S, ?&gt;&gt;) c -&gt; {
            doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
        });

        // We're watching for changes to the content width such
        // that the resize policy can be run if necessary. This comes from
        // TreeViewSkin.
        getProperties().addListener(new MapChangeListener&lt;Object, Object&gt;() {
            @Override
            public void onChanged(Change&lt;? extends Object, ? extends Object&gt; c) {
                if (c.wasAdded() &amp;&amp; SET_CONTENT_WIDTH.equals(c.getKey())) {
                    if (c.getValueAdded() instanceof Number) {
                        setContentWidth((Double) c.getValueAdded());
                    }
                    getProperties().remove(SET_CONTENT_WIDTH);
                }
            }
        });

        isInited = true;
    }



    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // this is the only publicly writable list for columns. This represents the
    // columns as they are given initially by the developer.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();

    // Finally, as convenience, we also have an observable list that contains
    // only the leaf columns that are currently visible.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);


    // Allows for multiple column sorting based on the order of the TableColumns
    // in this observableArrayList. Each TableColumn is responsible for whether it is
    // sorted using ascending or descending order.
    private ObservableList&lt;TableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();

    // width of VirtualFlow minus the vbar width
    private double contentWidth;

    // Used to minimise the amount of work performed prior to the table being
    // completely initialised. In particular it reduces the amount of column
    // resize operations that occur, which slightly improves startup time.
    private boolean isInited = false;



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;() {
        @Override public void onChanged(Change&lt;? extends TableColumn&lt;S,?&gt;&gt; c) {
            final List&lt;TableColumn&lt;S,?&gt;&gt; columns = getColumns();

            // Fix for RT-39822 - don't allow the same column to be installed twice
            while (c.next()) {
                if (c.wasAdded()) {
                    List&lt;TableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
                    for (TableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
                        if (addedColumn == null) continue;

                        int count = 0;
                        for (TableColumn&lt;S,?&gt; column : columns) {
                            if (addedColumn == column) {
                                count++;
                            }
                        }

                        if (count &gt; 1) {
                            duplicates.add(addedColumn);
                        }
                    }

                    if (!duplicates.isEmpty()) {
                        String titleList = &quot;&quot;;
                        for (TableColumn&lt;S,?&gt; dupe : duplicates) {
                            titleList += &quot;'&quot; + dupe.getText() + &quot;', &quot;;
                        }
                        throw new IllegalStateException(&quot;Duplicate TableColumns detected in TableView columns list with titles &quot; + titleList);
                    }
                }
            }
            c.reset();

            // Fix for RT-15194: Need to remove removed columns from the
            // sortOrder list.
            List&lt;TableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;&gt;();
            while (c.next()) {
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();

                if (c.wasRemoved()) {
                    toRemove.addAll(removed);
                    for (TableColumn&lt;S,?&gt; tc : removed) {
                        tc.setTableView(null);
                    }
                }

                if (c.wasAdded()) {
                    toRemove.removeAll(added);
                    for (TableColumn&lt;S,?&gt; tc : added) {
                        tc.setTableView(TableView.this);
                    }
                }

                // set up listeners
                TableUtil.removeColumnsListener(removed, weakColumnsObserver);
                TableUtil.addColumnsListener(added, weakColumnsObserver);

                TableUtil.removeTableColumnListener(c.getRemoved(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
                TableUtil.addTableColumnListener(c.getAddedSubList(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
            }

            // We don't maintain a bind for leafColumns, we simply call this update
            // function behind the scenes in the appropriate places.
            updateVisibleLeafColumns();

            sortOrder.removeAll(toRemove);

            // Fix for RT-38892.
            final TableViewFocusModel&lt;S&gt; fm = getFocusModel();
            final TableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
            c.reset();

            // we need to collect together all removed and all added columns, because
            // the code below works on the actually removed columns. If we perform
            // the code within this while loop, we'll be deselecting columns that
            // should be deselected (because they have just moved place, for example).
            List&lt;TableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
            List&lt;TableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
            while (c.next()) {
                if (c.wasRemoved()) {
                    removed.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    added.addAll(c.getAddedSubList());
                }
            }
            removed.removeAll(added);

            // Fix for focus - we simply move focus to a cell to the left
            // of the focused cell if the focused cell was located within
            // a column that has been removed.
            if (fm != null) {
                TablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
                boolean match = false;
                for (TableColumn&lt;S, ?&gt; tc : removed) {
                    match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
                    if (match) {
                        break;
                    }
                }

                if (match) {
                    int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
                    int newFocusColumnIndex =
                            matchingColumnIndex == 0 ? 0 :
                            Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
                    fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
                }
            }

            // Fix for selection - we remove selection from all cells that
            // were within the removed column.
            if (sm != null) {
                List&lt;TablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
                for (TablePosition selectedCell : selectedCells) {
                    boolean match = false;
                    for (TableColumn&lt;S, ?&gt; tc : removed) {
                        match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
                        if (match) break;
                    }

                    if (match) {
                        // we can't just use the selectedCell.getTableColumn(), as that
                        // column no longer exists and therefore its index is not correct.
                        int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
                        if (matchingColumnIndex == -1) continue;

                        if (sm instanceof TableViewArrayListSelectionModel) {
                            // Also, because the table column no longer exists in the columns
                            // list at this point, we can't just call:
                            // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                            // as the tableColumn would map to an index of -1, which means that
                            // selection will not be cleared. Instead, we have to create
                            // a new TablePosition with a fixed column index and use that.
                            TablePosition&lt;S,?&gt; fixedTablePosition =
                                    new TablePosition&lt;&gt;(TableView.this,
                                            selectedCell.getRow(),
                                            selectedCell.getTableColumn());
                            fixedTablePosition.fixedColumnIndex = matchingColumnIndex;

                            ((TableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
                        } else {
                            sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                        }
                    }
                }
            }


            // update the lastKnownColumnIndex map
            lastKnownColumnIndex.clear();
            for (TableColumn&lt;S,?&gt; tc : getColumns()) {
                int index = getVisibleLeafIndex(tc);
                if (index &gt; -1) {
                    lastKnownColumnIndex.put(tc, index);
                }
            }
        }
    };

    private final WeakHashMap&lt;TableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();

    private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
        updateVisibleLeafColumns();
    };

    private final InvalidationListener columnSortableObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
    };

    private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
    };

    private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
    };

    /* proxy pseudo-class state change from selectionModel's cellSelectionEnabledProperty */
    private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
        final boolean isCellSelection = ((BooleanProperty)o).get();
        pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
        pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
    };


    private final WeakInvalidationListener weakColumnVisibleObserver =
            new WeakInvalidationListener(columnVisibleObserver);

    private final WeakInvalidationListener weakColumnSortableObserver =
            new WeakInvalidationListener(columnSortableObserver);

    private final WeakInvalidationListener weakColumnSortTypeObserver =
            new WeakInvalidationListener(columnSortTypeObserver);

    private final WeakInvalidationListener weakColumnComparatorObserver =
            new WeakInvalidationListener(columnComparatorObserver);

    private final WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
            new WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;(columnsObserver);

    private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
            new WeakInvalidationListener(cellSelectionModelInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/


    // --- Items
    /**
     * The underlying data model for the TableView. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return the items property
     */
    public final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty() { return items; }
    private ObjectProperty&lt;ObservableList&lt;S&gt;&gt; items =
        new SimpleObjectProperty&lt;ObservableList&lt;S&gt;&gt;(this, &quot;items&quot;) {
            WeakReference&lt;ObservableList&lt;S&gt;&gt; oldItemsRef;

            @Override protected void invalidated() {
                final ObservableList&lt;S&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
                final ObservableList&lt;S&gt; newItems = getItems();

                // Fix for RT-36425
                if (newItems != null &amp;&amp; newItems == oldItems) {
                    return;
                }

                // Fix for RT-35763
                if (! (newItems instanceof SortedList)) {
                    getSortOrder().clear();
                }

                oldItemsRef = new WeakReference&lt;&gt;(newItems);
            }
        };
    public final void setItems(ObservableList&lt;S&gt; value) { itemsProperty().set(value); }
    public final ObservableList&lt;S&gt; getItems() {return items.get(); }


    // --- Table menu button visible
    private BooleanProperty tableMenuButtonVisible;
    /**
     * This controls whether a menu button is available when the user clicks
     * in a designated space within the TableView, within which is a radio menu
     * item for each TableColumn in this table. This menu allows for the user to
     * show and hide all TableColumns easily.
     * @return the tableMenuButtonVisible property
     */
    public final BooleanProperty tableMenuButtonVisibleProperty() {
        if (tableMenuButtonVisible == null) {
            tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
        }
        return tableMenuButtonVisible;
    }
    public final void setTableMenuButtonVisible (boolean value) {
        tableMenuButtonVisibleProperty().set(value);
    }
    public final boolean isTableMenuButtonVisible() {
        return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
    }


    // --- Column Resize Policy
    private ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
    public final void setColumnResizePolicy(Callback&lt;ResizeFeatures, Boolean&gt; callback) {
        columnResizePolicyProperty().set(callback);
    }
    public final Callback&lt;ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
        return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
    }

    /**
     * This is the function called when the user completes a column-resize
     * operation. The two most common policies are available as static functions
     * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
     * {@link #CONSTRAINED_RESIZE_POLICY}.
     * @return columnResizePolicy property
     */
    public final ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
        if (columnResizePolicy == null) {
            columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
                private Callback&lt;ResizeFeatures, Boolean&gt; oldPolicy;

                @Override protected void invalidated() {
                    if (isInited) {
                        get().call(new ResizeFeatures(TableView.this, null, 0.0));

                        if (oldPolicy != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
                            pseudoClassStateChanged(state, false);
                        }
                        if (get() != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(get().toString());
                            pseudoClassStateChanged(state, true);
                        }
                        oldPolicy = get();
                    }
                }
            };
        }
        return columnResizePolicy;
    }


    // --- Row Factory
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactory;

    /**
     * A function which produces a TableRow. The system is responsible for
     * reusing TableRows. Return from this function a TableRow which
     * might be usable for representing a single row in a TableView.
     * &lt;p&gt;
     * Note that a TableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TableRow is
     * simply a container for a TableCell, and in most circumstances it is more
     * likely that you'll want to create custom TableCells, rather than
     * TableRows. The primary use case for creating custom TableRow
     * instances would most probably be to introduce some form of column
     * spanning support.
     * &lt;p&gt;
     * You can create custom TableCell instances per column by assigning the
     * appropriate function to the cellFactory property in the TableColumn class.
     * @return rowFactory property
     */
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
        if (rowFactory == null) {
            rowFactory = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
        }
        return rowFactory;
    }
    public final void setRowFactory(Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; value) {
        rowFactoryProperty().set(value);
    }
    public final Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; getRowFactory() {
        return rowFactory == null ? null : rowFactory.get();
    }


    // --- Placeholder Node
    private ObjectProperty&lt;Node&gt; placeholder;
    /**
     * This Node is shown to the user when the table has no content to show.
     * This may be the case because the table model has no data in the first
     * place, that a filter has been applied to the table model, resulting
     * in there being nothing to show the user, or that there are no currently
     * visible columns.
     * @return placeholder property
     */
    public final ObjectProperty&lt;Node&gt; placeholderProperty() {
        if (placeholder == null) {
            placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
        }
        return placeholder;
    }
    public final void setPlaceholder(Node value) {
        placeholderProperty().set(value);
    }
    public final Node getPlaceholder() {
        return placeholder == null ? null : placeholder.get();
    }


    // --- Selection Model
    private ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModel
            = new SimpleObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {

        TableViewSelectionModel&lt;S&gt; oldValue = null;

        @Override protected void invalidated() {

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);

                if (oldValue instanceof TableViewArrayListSelectionModel) {
                    ((TableViewArrayListSelectionModel)oldValue).dispose();
                }
            }

            oldValue = get();

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
                // fake an invalidation to ensure updated pseudo-class state
                weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
            }
        }
    };

    /**
     * The SelectionModel provides the API through which it is possible
     * to select single or multiple items within a TableView, as  well as inspect
     * which items have been selected by the user. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return selectionModel property
     */
    public final ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
        return selectionModel;
    }
    public final void setSelectionModel(TableViewSelectionModel&lt;S&gt; value) {
        selectionModelProperty().set(value);
    }

    public final TableViewSelectionModel&lt;S&gt; getSelectionModel() {
        return selectionModel.get();
    }


    // --- Focus Model
    private ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModel;
    public final void setFocusModel(TableViewFocusModel&lt;S&gt; value) {
        focusModelProperty().set(value);
    }
    public final TableViewFocusModel&lt;S&gt; getFocusModel() {
        return focusModel == null ? null : focusModel.get();
    }
    /**
     * Represents the currently-installed {@link TableViewFocusModel} for this
     * TableView. Under almost all circumstances leaving this as the default
     * focus model will suffice.
     * @return focusModel property
     */
    public final ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
        if (focusModel == null) {
            focusModel = new SimpleObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
        }
        return focusModel;
    }


//    // --- Span Model
//    private ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModel
//            = new SimpleObjectProperty&lt;SpanModel&lt;S&gt;&gt;(this, &quot;spanModel&quot;) {
//
//        @Override protected void invalidated() {
//            ObservableList&lt;String&gt; styleClass = getStyleClass();
//            if (getSpanModel() == null) {
//                styleClass.remove(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            } else if (! styleClass.contains(CELL_SPAN_TABLE_VIEW_STYLE_CLASS)) {
//                styleClass.add(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            }
//        }
//    };
//
//    public final ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModelProperty() {
//        return spanModel;
//    }
//    public final void setSpanModel(SpanModel&lt;S&gt; value) {
//        spanModelProperty().set(value);
//    }
//
//    public final SpanModel&lt;S&gt; getSpanModel() {
//        return spanModel.get();
//    }

    // --- Editable
    private BooleanProperty editable;
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }
    public final boolean isEditable() {
        return editable == null ? false : editable.get();
    }
    /**
     * Specifies whether this TableView is editable - only if the TableView, the
     * TableColumn (if applicable) and the TableCells within it are both
     * editable will a TableCell be able to go into their editing state.
     * @return the editable property
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
        }
        return editable;
    }


    // --- Fixed cell size
    private DoubleProperty fixedCellSize;

    /**
     * Sets the new fixed cell size for this control. Any value greater than
     * zero will enable fixed cell size mode, whereas a zero or negative value
     * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
     * mode.
     *
     * @param value The new fixed cell size value, or a value less than or equal
     *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
     * @since JavaFX 8.0
     */
    public final void setFixedCellSize(double value) {
        fixedCellSizeProperty().set(value);
    }

    /**
     * Returns the fixed cell size value. A value less than or equal to zero is
     * used to represent that fixed cell size mode is disabled, and a value
     * greater than zero represents the size of all cells in this control.
     *
     * @return A double representing the fixed cell size of this control, or a
     *      value less than or equal to zero if fixed cell size mode is disabled.
     * @since JavaFX 8.0
     */
    public final double getFixedCellSize() {
        return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
    }
    /**
     * Specifies whether this control has cells that are a fixed height (of the
     * specified value). If this value is less than or equal to zero,
     * then all cells are individually sized and positioned. This is a slow
     * operation. Therefore, when performance matters and developers are not
     * dependent on variable cell sizes it is a good idea to set the fixed cell
     * size value. Generally cells are around 24px, so setting a fixed cell size
     * of 24 is likely to result in very little difference in visuals, but a
     * improvement to performance.
     *
     * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
     * This should not be confused with the -fx-cell-size property. The difference
     * between these two CSS properties is that -fx-cell-size will size all
     * cells to the specified size, but it will not enforce that this is the
     * only size (thus allowing for variable cell sizes, and preventing the
     * performance gains from being possible). Therefore, when performance matters
     * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
     * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
     *
     * @return fixedCellSize property
     * @since JavaFX 8.0
     */
    public final DoubleProperty fixedCellSizeProperty() {
        if (fixedCellSize == null) {
            fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
                @Override public CssMetaData&lt;TableView&lt;?&gt;,Number&gt; getCssMetaData() {
                    return StyleableProperties.FIXED_CELL_SIZE;
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;fixedCellSize&quot;;
                }
            };
        }
        return fixedCellSize;
    }


    // --- Editing Cell
    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCell;
    private void setEditingCell(TablePosition&lt;S,?&gt; value) {
        editingCellPropertyImpl().set(value);
    }
    public final TablePosition&lt;S,?&gt; getEditingCell() {
        return editingCell == null ? null : editingCell.get();
    }

    /**
     * Represents the current cell being edited, or null if
     * there is no cell being edited.
     * @return the editingCell property
     */
    public final ReadOnlyObjectProperty&lt;TablePosition&lt;S,?&gt;&gt; editingCellProperty() {
        return editingCellPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
        if (editingCell == null) {
            editingCell = new ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
        }
        return editingCell;
    }


    // --- Comparator (built via sortOrder list, so read-only)
    /**
     * The comparator property is a read-only property that is representative of the
     * current state of the {@link #getSortOrder() sort order} list. The sort
     * order list contains the columns that have been added to it either programmatically
     * or via a user clicking on the headers themselves.
     * @since JavaFX 8.0
     */
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparator;
    private void setComparator(Comparator&lt;S&gt; value) {
        comparatorPropertyImpl().set(value);
    }
    public final Comparator&lt;S&gt; getComparator() {
        return comparator == null ? null : comparator.get();
    }
    public final ReadOnlyObjectProperty&lt;Comparator&lt;S&gt;&gt; comparatorProperty() {
        return comparatorPropertyImpl().getReadOnlyProperty();
    }
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparatorPropertyImpl() {
        if (comparator == null) {
            comparator = new ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt;(this, &quot;comparator&quot;);
        }
        return comparator;
    }


    // --- sortPolicy
    /**
     * The sort policy specifies how sorting in this TableView should be performed.
     * For example, a basic sort policy may just call
     * {@code FXCollections.sort(tableView.getItems())}, whereas a more advanced
     * sort policy may call to a database to perform the necessary sorting on the
     * server-side.
     *
     * &lt;p&gt;TableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
     * sort policy} that does precisely as mentioned above: it simply attempts
     * to sort the items list in-place.
     *
     * &lt;p&gt;It is recommended that rather than override the {@link TableView#sort() sort}
     * method that a different sort policy be provided instead.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
    public final void setSortPolicy(Callback&lt;TableView&lt;S&gt;, Boolean&gt; callback) {
        sortPolicyProperty().set(callback);
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Callback&lt;TableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
        return sortPolicy == null ?
                (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
                sortPolicy.get();
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
        if (sortPolicy == null) {
            sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt;(
                    this, &quot;sortPolicy&quot;, (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
                @Override protected void invalidated() {
                    sort();
                }
            };
        }
        return sortPolicy;
    }


    // onSort
    /**
     * Called when there's a request to sort the control.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSort;

    public void setOnSort(EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; value) {
        onSortProperty().set(value);
    }

    public EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; getOnSort() {
        if( onSort != null ) {
            return onSort.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
        if( onSort == null ) {
            onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
                    EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventHandler = get();
                    setEventHandler(eventType, eventHandler);
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onSort&quot;;
                }
            };
        }
        return onSort;
    }


    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/
    /**
     * The TableColumns that are part of this TableView. As the user reorders
     * the TableView columns, this list will be updated to reflect the current
     * visual ordering.
     *
     * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
     * TableColumn in this ObservableList.&lt;/p&gt;
     * @return the columns
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getColumns() {
        return columns;
    }

    /**
     * The sortOrder list defines the order in which {@link TableColumn} instances
     * are sorted. An empty sortOrder list means that no sorting is being applied
     * on the TableView. If the sortOrder list has one TableColumn within it,
     * the TableView will be sorted using the
     * {@link TableColumn#sortTypeProperty() sortType} and
     * {@link TableColumn#comparatorProperty() comparator} properties of this
     * TableColumn (assuming
     * {@link TableColumn#sortableProperty() TableColumn.sortable} is true).
     * If the sortOrder list contains multiple TableColumn instances, then
     * the TableView is firstly sorted based on the properties of the first
     * TableColumn. If two elements are considered equal, then the second
     * TableColumn in the list is used to determine ordering. This repeats until
     * the results from all TableColumn comparators are considered, if necessary.
     *
     * @return An ObservableList containing zero or more TableColumn instances.
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getSortOrder() {
        return sortOrder;
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param index The index of an item that should be visible to the user.
     */
    public void scrollTo(int index) {
       ControlUtils.scrollToIndex(this, index);
    }

    /**
     * Scrolls the TableView so that the given object is visible within the viewport.
     * @param object The object that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollTo(S object) {
        if( getItems() != null ) {
            int idx = getItems().indexOf(object);
            if( idx &gt;= 0 ) {
                ControlUtils.scrollToIndex(this, idx);
            }
        }
    }

    /**
     * Called when there's a request to scroll an index into view using {@link #scrollTo(int)}
     * or {@link #scrollTo(Object)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;

    public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
        onScrollToProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
        if( onScrollTo != null ) {
            return onScrollTo.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
        if( onScrollTo == null ) {
            onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
                @Override
                protected void invalidated() {
                    setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
                }
                @Override
                public Object getBean() {
                    return TableView.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollTo&quot;;
                }
            };
        }
        return onScrollTo;
    }

    /**
     * Scrolls the TableView so that the given column is visible within the viewport.
     * @param column The column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumn(TableColumn&lt;S, ?&gt; column) {
        ControlUtils.scrollToColumn(this, column);
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param columnIndex The index of a column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumnIndex(int columnIndex) {
        if( getColumns() != null ) {
            ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
        }
    }

    /**
     * Called when there's a request to scroll a column into view using {@link #scrollToColumn(TableColumn)}
     * or {@link #scrollToColumnIndex(int)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;

    public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; value) {
        onScrollToColumnProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
        if( onScrollToColumn != null ) {
            return onScrollToColumn.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
        if( onScrollToColumn == null ) {
            onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
                    setEventHandler(type, get());
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onScrollToColumn&quot;;
                }
            };
        }
        return onScrollToColumn;
    }

    /**
     * Applies the currently installed resize policy against the given column,
     * resizing it based on the delta value provided.
     * @param column the column
     * @param delta the delta
     * @return true if column resize is allowed
     */
    public boolean resizeColumn(TableColumn&lt;S,?&gt; column, double delta) {
        if (column == null || Double.compare(delta, 0.0) == 0) return false;

        boolean allowed = getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, column, delta));
        if (!allowed) return false;

        return true;
    }

    /**
     * Causes the cell at the given row/column view indexes to switch into
     * its editing state, if it is not already in it, and assuming that the
     * TableView and column are also editable.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method will cancel editing if the given row
     * value is less than zero and the given column is null.&lt;/p&gt;
     * @param row the row
     * @param column the column
     */
    public void edit(int row, TableColumn&lt;S,?&gt; column) {
        if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
            return;
        }

        if (row &lt; 0 &amp;&amp; column == null) {
            setEditingCell(null);
        } else {
            setEditingCell(new TablePosition&lt;&gt;(this, row, column));
        }
    }

    /**
     * Returns an unmodifiable list containing the currently visible leaf columns.
     * @return an unmodifiable list containing the currently visible leaf columns
     */
    public ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
        return unmodifiableVisibleLeafColumns;
    }

    /**
     * Returns the position of the given column, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the position of the given column, relative to all other
     * visible leaf columns
     */
    public int getVisibleLeafIndex(TableColumn&lt;S,?&gt; column) {
        return visibleLeafColumns.indexOf(column);
    }

    /**
     * Returns the TableColumn in the given column index, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the TableColumn in the given column index, relative to all other
     * visible leaf columns
     */
    public TableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
        if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
        return visibleLeafColumns.get(column);
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TableViewSkin&lt;S&gt;(this);
    }

    /**
     * The sort method forces the TableView to re-run its sorting algorithm. More
     * often than not it is not necessary to call this method directly, as it is
     * automatically called when the {@link #getSortOrder() sort order},
     * {@link #sortPolicyProperty() sort policy}, or the state of the
     * TableColumn {@link TableColumn#sortTypeProperty() sort type} properties
     * change. In other words, this method should only be called directly when
     * something external changes and a sort is required.
     * @since JavaFX 8.0
     */
    public void sort() {
        final ObservableList&lt;? extends TableColumnBase&lt;S,?&gt;&gt; sortOrder = getSortOrder();

        // update the Comparator property
        final Comparator&lt;S&gt; oldComparator = getComparator();
        setComparator(sortOrder.isEmpty() ? null : new TableColumnComparator(sortOrder));

        // fire the onSort event and check if it is consumed, if
        // so, don't run the sort
        SortEvent&lt;TableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TableView.this, TableView.this);
        fireEvent(sortEvent);
        if (sortEvent.isConsumed()) {
            // if the sort is consumed we could back out the last action (the code
            // is commented out right below), but we don't as we take it as a
            // sign that the developer has decided to handle the event themselves.

            // sortLock = true;
            // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            // sortLock = false;
            return;
        }

        final List&lt;TablePosition&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
        final int itemCount = prevState.size();

        // we set makeAtomic to true here, so that we don't fire intermediate
        // sort events - instead we send a single permutation event at the end
        // of this method.
        getSelectionModel().startAtomic();

        // get the sort policy and run it
        Callback&lt;TableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
        if (sortPolicy == null) return;
        Boolean success = sortPolicy.call(this);

        getSelectionModel().stopAtomic();

        if (success == null || ! success) {
            // the sort was a failure. Need to backout if possible
            sortLock = true;
            TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            setComparator(oldComparator);
            sortLock = false;
        } else {
            // sorting was a success, now we possibly fire an event on the
            // selection model that the items list has 'permutated' to a new ordering

            // FIXME we should support alternative selection model implementations!
            if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {
                final TableViewArrayListSelectionModel&lt;S&gt; sm = (TableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
                final ObservableList&lt;TablePosition&lt;S,?&gt;&gt; newState = (ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)sm.getSelectedCells();

                List&lt;TablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; itemCount; i++) {
                    TablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
                    if (!newState.contains(prevItem)) {
                        removed.add(prevItem);
                    }
                }

                if (!removed.isEmpty()) {
                    // the sort operation effectively permutates the selectedCells list,
                    // but we cannot fire a permutation event as we are talking about
                    // TablePosition's changing (which may reside in the same list
                    // position before and after the sort). Therefore, we need to fire
                    // a single add/remove event to cover the added and removed positions.
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
                    sm.fireCustomSelectedCellsListChangeEvent(c);
                }
            }
        }
    }

    /**
     * Calling {@code refresh()} forces the TableView control to recreate and
     * repopulate the cells necessary to populate the visual bounds of the control.
     * In other words, this forces the TableView to update what it is showing to
     * the user. This is useful in cases where the underlying data source has
     * changed in a way that is not observed by the TableView itself.
     *
     * @since JavaFX 8u60
     */
    public void refresh() {
        getProperties().put(Properties.RECREATE, Boolean.TRUE);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean sortLock = false;
    private TableUtil.SortEventType lastSortEventType = null;
    private Object[] lastSortEventSupportInfo = null;

    private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
        if (sortLock) {
            return;
        }

        this.lastSortEventType = sortEventType;
        this.lastSortEventSupportInfo = supportInfo;
        sort();
        this.lastSortEventType = null;
        this.lastSortEventSupportInfo = null;
    }


    // --- Content width
    private void setContentWidth(double contentWidth) {
        this.contentWidth = contentWidth;
        if (isInited) {
            // sometimes the current column resize policy will have to modify the
            // column width of all columns in the table if the table width changes,
            // so we short-circuit the resize function and just go straight there
            // with a null TableColumn, which indicates to the resize policy function
            // that it shouldn't actually do anything specific to one column.
            getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
        }
    }

    /**
     * Recomputes the currently visible leaf columns in this TableView.
     */
<A NAME="7"></A>    private void updateVisibleLeafColumns() {
        // update visible leaf columns list
        List&lt;TableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TableColumn&lt;S,?&gt;&gt;();
        buildVisibleLeafColumns(<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#7',2,'match44-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getColumns(), cols);
        visibleLeafColumns.setAll(cols);

        // sometimes the current column resize policy will have to modify the
        // column width of all columns in the table if the table width changes,
        // so we short-circuit the resize function and just go straight there
        // with a null TableColumn, which indicates to the resize policy function
        // that it shouldn't actually do anything specific to one column.
        getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
    }

    private void buildVisibleLeafColumns(List&lt;TableColumn&lt;S,?&gt;&gt; cols, List&lt;TableColumn&lt;S,?&gt;&gt; vlc) {</B></FONT>
        for (TableColumn&lt;S,?&gt; c : cols) {
            if (c == null) continue;

            boolean hasChildren = ! c.getColumns().isEmpty();

            if (hasChildren) {
                buildVisibleLeafColumns(c.getColumns(), vlc);
            } else if (c.isVisible()) {
                vlc.add(c);
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;table-view&quot;;

    private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
            PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
    private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
            PseudoClass.getPseudoClass(&quot;row-selection&quot;);

    private static class StyleableProperties {
        private static final CssMetaData&lt;TableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
                new CssMetaData&lt;TableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
                                                    SizeConverter.getInstance(),
                                                    Region.USE_COMPUTED_SIZE) {

                    @Override public Double getInitialValue(TableView&lt;?&gt; node) {
                        return node.getFixedCellSize();
                    }

                    @Override public boolean isSettable(TableView&lt;?&gt; n) {
                        return n.fixedCellSize == null || !n.fixedCellSize.isBound();
                    }

                    @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TableView&lt;?&gt; n) {
                        return (StyleableProperty&lt;Number&gt;) n.fixedCellSizeProperty();
                    }
                };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FIXED_CELL_SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case COLUMN_COUNT: return getVisibleLeafColumns().size();
            case ROW_COUNT: return getItems().size();
            case SELECTED_ITEMS: {
                // TableViewSkin returns TableRows back to TableView.
                // TableRowSkin returns TableCells back to TableRow.
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;TableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                for (TableRow&lt;S&gt; row : rows) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
                    if (cells != null) selection.addAll(cells);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: {
                Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
                if (row == null) return null;
                Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
                /* cell equals to null means the row is a placeholder node */
                return cell != null ?  cell : row;
            }
            case CELL_AT_ROW_COLUMN: {
                @SuppressWarnings(&quot;unchecked&quot;)
                TableRow&lt;S&gt; row = (TableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
                return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
            }
            case MULTIPLE_SELECTION: {
                MultipleSelectionModel&lt;S&gt; sm = getSelectionModel();
                return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Support Interfaces                                                      *
     *                                                                         *
     **************************************************************************/

     /**
      * An immutable wrapper class for use in the TableView
     * {@link TableView#columnResizePolicyProperty() column resize} functionality.
      * @since JavaFX 2.0
      */
     public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;S&gt; {
        private TableView&lt;S&gt; table;

        /**
         * Creates an instance of this class, with the provided TableView,
         * TableColumn and delta values being set and stored in this immutable
         * instance.
         *
         * @param table The TableView upon which the resize operation is occurring.
         * @param column The column upon which the resize is occurring, or null
         *      if this ResizeFeatures instance is being created as a result of a
         *      TableView resize operation.
         * @param delta The amount of horizontal space added or removed in the
         *      resize operation.
         */
        public ResizeFeatures(TableView&lt;S&gt; table, TableColumn&lt;S,?&gt; column, Double delta) {
            super(column, delta);
            this.table = table;
        }

        /**
         * Returns the column upon which the resize is occurring, or null
         * if this ResizeFeatures instance was created as a result of a
         * TableView resize operation.
         */
        @Override public TableColumn&lt;S,?&gt; getColumn() {
            return (TableColumn&lt;S,?&gt;) super.getColumn();
        }

        /**
         * Returns the TableView upon which the resize operation is occurring.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTable() {
            return table;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/


    /**
     * A simple extension of the {@link SelectionModel} abstract class to
     * allow for special support for TableView controls.
     * @since JavaFX 2.0
     */
    public static abstract class TableViewSelectionModel&lt;S&gt; extends TableSelectionModel&lt;S&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/

        private final TableView&lt;S&gt; tableView;

        boolean blockFocusCall = false;



        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Builds a default TableViewSelectionModel instance with the provided
         * TableView.
         * @param tableView The TableView upon which this selection model should
         *      operate.
         * @throws NullPointerException TableView can not be null.
         */
        public TableViewSelectionModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
        }



        /***********************************************************************
         *                                                                     *
         * Abstract API                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * A read-only ObservableList representing the currently selected cells
         * in this TableView. Rather than directly modify this list, please
         * use the other methods provided in the TableViewSelectionModel.
         * @return a read-only ObservableList representing the currently
         * selected cells in this TableView
         */
        public abstract ObservableList&lt;TablePosition&gt; getSelectedCells();


        /***********************************************************************
         *                                                                     *
         * Generic (type erasure) bridging                                     *
         *                                                                     *
         **********************************************************************/

        // --- isSelected
        /** {@inheritDoc} */
        @Override public boolean isSelected(int row, TableColumnBase&lt;S, ?&gt; column) {
            return isSelected(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Convenience function which tests whether the given row and column index
         * is currently selected in this table instance.
         * @param row the row
         * @param column the column
         * @return true if row and column index is currently selected
         */
        public abstract boolean isSelected(int row, TableColumn&lt;S, ?&gt; column);


        // --- select
        /** {@inheritDoc} */
        @Override public void select(int row, TableColumnBase&lt;S, ?&gt; column) {
            select(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Selects the cell at the given row/column intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void select(int row, TableColumn&lt;S, ?&gt; column);


        // --- clearAndSelect
        /** {@inheritDoc} */
        @Override public void clearAndSelect(int row, TableColumnBase&lt;S,?&gt; column) {
            clearAndSelect(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Clears all selection, and then selects the cell at the given row/column
         * intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void clearAndSelect(int row, TableColumn&lt;S,?&gt; column);


        // --- clearSelection
        /** {@inheritDoc} */
        @Override public void clearSelection(int row, TableColumnBase&lt;S,?&gt; column) {
            clearSelection(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Removes selection from the specified row/column position (in view indexes).
         * If this particular cell (or row if the column value is -1) is not selected,
         * nothing happens.
         * @param row the row
         * @param column the column
         */
        public abstract void clearSelection(int row, TableColumn&lt;S, ?&gt; column);

        /** {@inheritDoc} */
        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            for (int _row = minRow; _row &lt;= maxRow; _row++) {
                for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
                    select(_row, tableView.getVisibleLeafColumn(_col));
                }
            }
        }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Returns the TableView instance that this selection model is installed in.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTableView() {
            return tableView;
        }

        /**
         * Convenience method that returns getTableView().getItems().
         * @return The items list of the current TableView.
         */
        protected List&lt;S&gt; getTableModel()  {
            return tableView.getItems();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) return null;
            return tableView.getItems().get(index);
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return getTableModel().size();
        }

        /** {@inheritDoc} */
        @Override public void focus(int row) {
            focus(row, null);
        }

        /** {@inheritDoc} */
        @Override public int getFocusedIndex() {
            return getFocusedCell().getRow();
        }



        /***********************************************************************
         *                                                                     *
         * Private implementation                                              *
         *                                                                     *
         **********************************************************************/

        void focus(int row, TableColumn&lt;S,?&gt; column) {
            focus(new TablePosition&lt;&gt;(getTableView(), row, column));
            getTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        void focus(TablePosition&lt;S,?&gt; pos) {
            if (blockFocusCall) return;
            if (getTableView().getFocusModel() == null) return;

            getTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
        }

        TablePosition&lt;S,?&gt; getFocusedCell() {
            if (getTableView().getFocusModel() == null) {
                return new TablePosition&lt;&gt;(getTableView(), -1, null);
            }
            return getTableView().getFocusModel().getFocusedCell();
        }
    }



    /**
     * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
     * selected indices.
     */
    // package for testing
    static class TableViewArrayListSelectionModel&lt;S&gt; extends TableViewSelectionModel&lt;S&gt; {

        private int itemCount = 0;

        private final MappingChange.Map&lt;TablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        public TableViewArrayListSelectionModel(final TableView&lt;S&gt; tableView) {
            super(tableView);
            this.tableView = tableView;

            this.itemsPropertyListener = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());

                    ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(itemsPropertyListener);

            selectedCellsMap = new SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
                @Override public boolean isCellSelectionEnabled() {
                    return TableViewArrayListSelectionModel.this.isCellSelectionEnabled();
                }
            };

            selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt;() {
                @Override public TablePosition&lt;S,?&gt; get(int i) {
                    return selectedCellsMap.get(i);
                }

                @Override public int size() {
                    return selectedCellsMap.size();
                }
            };
//            selectedCellsSeq.addListener((ListChangeListener&lt;? super TablePosition&lt;S,?&gt;&gt;) c -&gt; {
//                ControlUtils.updateSelectedIndices(this, c);
//            });


            /*
             * The following listener is used in conjunction with
             * SelectionModel.select(T obj) to allow for a developer to select
             * an item that is not actually in the data model. When this occurs,
             * we actively try to find an index that matches this object, going
             * so far as to actually watch for all changes to the items list,
             * rechecking each time.
             */

            // watching for changes to the items list content
            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(items);
                items.addListener(weakItemsContentListener);
            }


            updateItemCount();

            updateDefaultSelection();

            cellSelectionEnabledProperty().addListener(o -&gt; {
                updateDefaultSelection();
                TableCellBehaviorBase.setAnchor(tableView, getFocusedCell(), true);
            });
        }

        private void dispose() {
            this.tableView.itemsProperty().removeListener(itemsPropertyListener);

            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                items.removeListener(weakItemsContentListener);
            }
        }

        private final TableView&lt;S&gt; tableView;

        final InvalidationListener itemsPropertyListener;

        final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            updateItemCount();

            List&lt;S&gt; items1 = getTableModel();
            boolean doSelectionUpdate = true;

            while (c.next()) {
                if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                    this.selectedItemChange = c;
                    updateDefaultSelection();
                    this.selectedItemChange = null;
                    return;
                }

                final S selectedItem = getSelectedItem();
                final int selectedIndex = getSelectedIndex();

                if (items1 == null || items1.isEmpty()) {
                    clearSelection();
                } else if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() != null) {
                    int newIndex = items1.indexOf(getSelectedItem());
                    if (newIndex != -1) {
                        setSelectedIndex(newIndex);
                        doSelectionUpdate = false;
                    }
                } else if (c.wasRemoved() &amp;&amp;
                        c.getRemovedSize() == 1 &amp;&amp;
                        ! c.wasAdded() &amp;&amp;
                        selectedItem != null &amp;&amp;
                        selectedItem.equals(c.getRemoved().get(0))) {
                    // Bug fix for RT-28637
                    if (getSelectedIndex() &lt; getItemCount()) {
                        final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
                        S newSelectedItem = getModelItem(previousRow);
                        if (! selectedItem.equals(newSelectedItem)) {
                            clearAndSelect(previousRow);
                        }
                    }
                }
            }

            if (doSelectionUpdate) {
                updateSelection(c);
            }
        };

        final WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);



        /***********************************************************************
         *                                                                     *
         * Observable properties (and getters/setters)                         *
         *                                                                     *
         **********************************************************************/

        // the only 'proper' internal data structure, selectedItems and selectedIndices
        // are both 'read-only and unbacked'.
        private final SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsMap;

        // we create a ReadOnlyUnbackedObservableList of selectedCells here so
        // that we can fire custom list change events.
        private final ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
        @Override public ObservableList&lt;TablePosition&gt; getSelectedCells() {
            return (ObservableList&lt;TablePosition&gt;)(Object)selectedCellsSeq;
        }



        /***********************************************************************
         *                                                                     *
         * Internal properties                                                 *
         *                                                                     *
         **********************************************************************/

        private int previousModelSize = 0;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the selected indices list to refer to the
        // new indices.
        private void updateSelection(ListChangeListener.Change&lt;? extends S&gt; c) {
            c.reset();

            int shift = 0;
            int startRow = -1;
            while (c.next()) {
                if (c.wasReplaced()) {
                    if (c.getList().isEmpty()) {
                        // the entire items list was emptied - clear selection
                        clearSelection();
                    } else {
                        int index = getSelectedIndex();

                        if (previousModelSize == c.getRemovedSize()) {
                            // all items were removed from the model
                            clearSelection();
                        } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
                            // Fix for RT-18969: the list had setAll called on it
                            // Use of makeAtomic is a fix for RT-20945
                            startAtomic();
                            clearSelection(index);
                            stopAtomic();
                            select(index);
                        } else {
                            // Fix for RT-22079
                            clearSelection();
                        }
                    }
                } else if (c.wasAdded() || c.wasRemoved()) {
                    startRow = c.getFrom();
                    shift += c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
                } else if (c.wasPermutated()) {
                    // General approach:
                    //   -- detected a sort has happened
                    //   -- Create a permutation lookup map (1)
                    //   -- dump all the selected indices into a list (2)
                    //   -- create a list containing the new indices (3)
                    //   -- for each previously-selected index (4)
                    //     -- if index is in the permutation lookup map
                    //       -- add the new index to the new indices list
                    //   -- Perform batch selection (5)

                    startAtomic();

                    final int oldSelectedIndex = getSelectedIndex();

                    // (1)
                    int length = c.getTo() - c.getFrom();
                    HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);
                    for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                        pMap.put(i, c.getPermutation(i));
                    }

                    // (2)
                    List&lt;TablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;((ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)getSelectedCells());

                    // (3)
                    List&lt;TablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());

                    // (4)
                    boolean selectionIndicesChanged = false;
                    for (int i = 0; i &lt; selectedIndices.size(); i++) {
                        final TablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);
                        final int oldRow = oldIndex.getRow();

                        if (pMap.containsKey(oldRow)) {
                            int newIndex = pMap.get(oldRow);

                            selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;

                            newIndices.add(new TablePosition&lt;&gt;(oldIndex.getTableView(), newIndex, oldIndex.getTableColumn()));
                        }
                    }

                    if (selectionIndicesChanged) {
                        // (5)
                        quietClearSelection();
                        stopAtomic();

                        selectedCellsMap.setAll(newIndices);

                        if (oldSelectedIndex &gt;= 0 &amp;&amp; oldSelectedIndex &lt; itemCount) {
                            int newIndex = c.getPermutation(oldSelectedIndex);
                            setSelectedIndex(newIndex);
                            focus(newIndex);
                        }
                    } else {
                        stopAtomic();
                    }
                }
            }

            TablePosition&lt;S,?&gt; anchor = TableCellBehavior.getAnchor(tableView, null);
            if (shift != 0 &amp;&amp; startRow &gt;= 0 &amp;&amp; anchor != null &amp;&amp; (c.wasRemoved() || c.wasAdded())) {
                if (isSelected(anchor.getRow(), anchor.getTableColumn())) {
                    TablePosition&lt;S,?&gt; newAnchor = new TablePosition&lt;&gt;(tableView, anchor.getRow() + shift, anchor.getTableColumn());
                    TableCellBehavior.setAnchor(tableView, newAnchor, false);
                }
            }

            shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
                @Override public Void call(ShiftParams param) {

                    // we make the shifts atomic, as otherwise listeners to
                    // the items / indices lists get a lot of intermediate
                    // noise. They eventually get the summary event fired
                    // from within shiftSelection, so this is ok.
                    startAtomic();

                    final int clearIndex = param.getClearIndex();
                    final int setIndex = param.getSetIndex();
                    TablePosition&lt;S,?&gt; oldTP = null;
                    if (clearIndex &gt; -1) {
                        for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
                            TablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
                            if (tp.getRow() == clearIndex) {
                                oldTP = tp;
                                selectedCellsMap.remove(tp);
                            } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
                                selectedCellsMap.remove(tp);
                            }
                        }
                    }

                    if (oldTP != null &amp;&amp; param.isSelected()) {
                        TablePosition&lt;S,?&gt; newTP = new TablePosition&lt;&gt;(
                                tableView, param.getSetIndex(), oldTP.getTableColumn());

                        selectedCellsMap.add(newTP);
                    }

                    stopAtomic();

                    return null;
                }
            });

            previousModelSize = getItemCount();
        }

        /***********************************************************************
         *                                                                     *
         * Public selection API                                                *
         *                                                                     *
         **********************************************************************/

        @Override public void clearAndSelect(int row) {
            clearAndSelect(row, null);
        }

        @Override public void clearAndSelect(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            final TablePosition&lt;S,?&gt; newTablePosition = new TablePosition&lt;&gt;(getTableView(), row, column);
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            // replace the anchor
            TableCellBehavior.setAnchor(tableView, newTablePosition, false);

            // firstly we make a copy of the selection, so that we can send out
            // the correct details in the selection change event.
            List&lt;TablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());

            // secondly we check if we can short-circuit out of here because the new selection
            // equals the current selection
            final boolean wasSelected = isSelected(row, column);
            if (wasSelected &amp;&amp; previousSelection.size() == 1) {
                // before we return, we double-check that the selected item
                // is equal to the item in the given index
                TablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
                if (getSelectedItem() == getModelItem(row)) {
                    if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
                        return;
                    }
                }
            }

            // RT-32411 We used to call quietClearSelection() here, but this
            // resulted in the selectedItems and selectedIndices lists never
            // reporting that they were empty.
            // makeAtomic toggle added to resolve RT-32618
            startAtomic();

            // then clear the current selection
            clearSelection();

            // and select the new cell
            select(row, column);

            stopAtomic();


            // We remove the new selection from the list seeing as it is not removed.
            if (isCellSelectionEnabled) {
                previousSelection.remove(newTablePosition);
            } else {
                for (TablePosition&lt;S,?&gt; tp : previousSelection) {
                    if (tp.getRow() == row) {
                        previousSelection.remove(tp);
                        break;
                    }
                }
            }

            // fire off a single add/remove/replace notification (rather than
            // individual remove and add notifications) - see RT-33324
            ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; change;

            /*
             * getFrom() documentation:
             *   If wasAdded is true, the interval contains all the values that were added.
             *   If wasPermutated is true, the interval marks the values that were permutated.
             *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
             *   return the same number - the place where the removed elements were positioned in the list.
             */
            if (wasSelected) {
                change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
            } else {
                final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
                final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
                change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                        changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
//                selectedCellsSeq._beginChange();
//                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
//                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
//                selectedCellsSeq._endChange();
            }
            fireCustomSelectedCellsListChangeEvent(change);
        }

        @Override public void select(int row) {
            select(row, null);
        }

        @Override
        public void select(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            // if I'm in cell selection mode but the column is null, select each
            // of the contained cells individually
            if (isCellSelectionEnabled() &amp;&amp; column == null) {
                List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                for (int i = 0; i &lt; columns.size(); i++) {
                    select(row, columns.get(i));
                }
                return;
            }

            if (TableCellBehavior.hasDefaultAnchor(tableView)) {
                TableCellBehavior.removeAnchor(tableView);
            }

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }
            selectedCellsMap.add(new TablePosition&lt;&gt;(getTableView(), row, column));

            updateSelectedIndex(row);
            focus(row, column);
        }

        @Override public void select(S obj) {
            if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
                clearSelection();
                return;
            }

            // We have no option but to iterate through the model and select the
            // first occurrence of the given object. Once we find the first one, we
            // don't proceed to select any others.
            S rowObj = null;
            for (int i = 0; i &lt; getItemCount(); i++) {
                rowObj = getModelItem(i);
                if (rowObj == null) continue;

                if (rowObj.equals(obj)) {
                    if (isSelected(i)) {
                        return;
                    }

                    if (getSelectionMode() == SelectionMode.SINGLE) {
                        quietClearSelection();
                    }

                    select(i);
                    return;
                }
            }

            // if we are here, we did not find the item in the entire data model.
            // Even still, we allow for this item to be set to the give object.
            // We expect that in concrete subclasses of this class we observe the
            // data model such that we check to see if the given item exists in it,
            // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
            setSelectedIndex(-1);
            setSelectedItem(obj);
        }

        @Override public void selectIndices(int row, int... rows) {
            if (rows == null) {
                select(row);
                return;
            }

            /*
             * Performance optimisation - if multiple selection is disabled, only
             * process the end-most row index.
             */
            int rowCount = getItemCount();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();

                for (int i = rows.length - 1; i &gt;= 0; i--) {
                    int index = rows[i];
                    if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                        select(index);
                        break;
                    }
                }

                if (selectedCellsMap.isEmpty()) {
                    if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                        select(row);
                    }
                }
            } else {
                int lastIndex = -1;
                Set&lt;TablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();

                // --- firstly, we special-case the non-varargs 'row' argument
                if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
                    // if I'm in cell selection mode, we want to select each
                    // of the contained cells individually
                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(row, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), row, columns.get(column)));
                                lastIndex = row;
                            }
                        }
                    } else {
                        boolean match = selectedCellsMap.isSelected(row, -1);
                        if (!match) {
                            positions.add(new TablePosition&lt;&gt;(getTableView(), row, null));
                        }
                    }

                    lastIndex = row;
                }

                // --- now we iterate through all varargs values
                for (int i = 0; i &lt; rows.length; i++) {
                    int index = rows[i];
                    if (index &lt; 0 || index &gt;= rowCount) continue;
                    lastIndex = index;

                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(index, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), index, columns.get(column)));
                                lastIndex = index;
                            }
                        }
                    } else {
                        if (! selectedCellsMap.isSelected(index, -1)) {
                            // if we are here then we have successfully gotten through the for-loop above
                            positions.add(new TablePosition&lt;&gt;(getTableView(), index, null));
                        }
                    }
                }

                selectedCellsMap.addAll(positions);

                if (lastIndex != -1) {
                    select(lastIndex);
                }
            }
        }

        @Override public void selectAll() {
            if (getSelectionMode() == SelectionMode.SINGLE) return;

            if (isCellSelectionEnabled()) {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                TableColumn&lt;S,?&gt; column;
                TablePosition&lt;S,?&gt; tp = null;
                for (int col = 0; col &lt; getTableView().getVisibleLeafColumns().size(); col++) {
                    column = getTableView().getVisibleLeafColumns().get(col);
                    for (int row = 0; row &lt; getItemCount(); row++) {
                        tp = new TablePosition&lt;&gt;(getTableView(), row, column);
                        indices.add(tp);
                    }
                }
                selectedCellsMap.setAll(indices);

                if (tp != null) {
                    select(tp.getRow(), tp.getTableColumn());
                    focus(tp.getRow(), tp.getTableColumn());
                }
            } else {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; getItemCount(); i++) {
                    indices.add(new TablePosition&lt;&gt;(getTableView(), i, null));
                }
                selectedCellsMap.setAll(indices);

                int focusedIndex = getFocusedIndex();
                if (focusedIndex == -1) {
                    final int itemCount = getItemCount();
                    if (itemCount &gt; 0) {
                        select(itemCount - 1);
                        focus(indices.get(indices.size() - 1));
                    }
                } else {
                    select(focusedIndex);
                    focus(focusedIndex);
                }
            }
        }

        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
                select(maxRow, maxColumn);
                return;
            }

            startAtomic();

            final int itemCount = getItemCount();
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
            final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);

            final int _minRow = Math.min(minRow, maxRow);
            final int _maxRow = Math.max(minRow, maxRow);

            List&lt;TablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();

            for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
                // begin copy/paste of select(int, column) method (with some
                // slight modifications)
                if (_row &lt; 0 || _row &gt;= itemCount) continue;

                if (! isCellSelectionEnabled) {
                    cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, (TableColumn&lt;S,?&gt;)minColumn));
                } else {
                    for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
                        final TableColumn&lt;S, ?&gt; column = tableView.getVisibleLeafColumn(_col);

                        // if I'm in cell selection mode but the column is null, I don't want
                        // to select the whole row instead...
                        if (column == null &amp;&amp; isCellSelectionEnabled) continue;

                        cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, column));
                        // end copy/paste
                    }
                }
            }

            // to prevent duplication we remove all currently selected cells from
            // our list of cells to select.
            cellsToSelect.removeAll(getSelectedCells());

            selectedCellsMap.addAll(cellsToSelect);
            stopAtomic();

            // fire off events.
            // Note that focus and selection always goes to maxRow, not _maxRow.
            updateSelectedIndex(maxRow);
            focus(maxRow, (TableColumn&lt;S,?&gt;)maxColumn);

            final TableColumn&lt;S,?&gt; startColumn = (TableColumn&lt;S,?&gt;)minColumn;
            final TableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TableColumn&lt;S,?&gt;)maxColumn : startColumn;
            final int startChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, minRow, startColumn));
            final int endChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, maxRow, endColumn));

            if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
                final int startIndex = Math.min(startChangeIndex, endChangeIndex);
                final int endIndex = Math.max(startChangeIndex, endChangeIndex);

                ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
                fireCustomSelectedCellsListChangeEvent(c);
//                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
            }
        }

        @Override public void clearSelection(int index) {
            clearSelection(index, null);
        }

        @Override
        public void clearSelection(int row, TableColumn&lt;S,?&gt; column) {
            clearSelection(new TablePosition&lt;&gt;(getTableView(), row, column));
        }

        private void clearSelection(TablePosition&lt;S,?&gt; tp) {
            final boolean csMode = isCellSelectionEnabled();
            final int row = tp.getRow();
            final boolean columnIsNull = tp.getTableColumn() == null;

            List&lt;TablePosition&gt; toRemove = new ArrayList&lt;&gt;();
            for (TablePosition pos : getSelectedCells()) {
                if (!csMode) {
                    if (pos.getRow() == row) {
                        toRemove.add(pos);
                        break;
                    }
                } else {
                    if (columnIsNull &amp;&amp; pos.getRow() == row) {
                        // if we are in cell selection mode and the column is null,
                        // we remove all items in the row
                        toRemove.add(pos);
                    } else if (pos.equals(tp)) {
                        toRemove.add(tp);
                        break;
                    }
                }
            }
            toRemove.stream().forEach(selectedCellsMap::remove);

            if (isEmpty() &amp;&amp; ! isAtomic()) {
                updateSelectedIndex(-1);
                selectedCellsMap.clear();
            }
        }

        @Override public void clearSelection() {
            final List&lt;TablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());

            quietClearSelection();

            if (! isAtomic()) {
                updateSelectedIndex(-1);
                focus(-1);

                if (!removed.isEmpty()) {
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
                        @Override public List&lt;TablePosition&lt;S, ?&gt;&gt; getRemoved() {
                            return removed;
                        }
                    };
                    fireCustomSelectedCellsListChangeEvent(c);
//                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
                }
            }
        }

        private void quietClearSelection() {
            startAtomic();
            selectedCellsMap.clear();
            stopAtomic();
        }

        @Override public boolean isSelected(int index) {
            return isSelected(index, null);
        }

        @Override
        public boolean isSelected(int row, TableColumn&lt;S,?&gt; column) {
            // When in cell selection mode, if the column is null, then we interpret
            // the users query to be asking if _all_ of the cells in the row are selected,
            // rather than if _any_ of the cells in the row are selected.
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();
            if (isCellSelectionEnabled &amp;&amp; column == null) {
                int columnCount = tableView.getVisibleLeafColumns().size();
                for (int col = 0; col &lt; columnCount; col++) {
                    if (!selectedCellsMap.isSelected(row, col)) {
                        return false;
                    }
                }
                return true;
            } else {
                int columnIndex = !isCellSelectionEnabled || column == null ? -1 : tableView.getVisibleLeafIndex(column);
                return selectedCellsMap.isSelected(row, columnIndex);
            }
        }

        @Override public boolean isEmpty() {
            return selectedCellsMap.isEmpty();
        }

        @Override public void selectPrevious() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // right-to-left, and then wrapping to the end of the previous line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() - 1 &gt;= 0) {
                    // go to previous row
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to end of previous row
                    select(pos.getRow() - 1, getTableColumn(getTableView().getVisibleLeafColumns().size() - 1));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(getItemCount() - 1);
                } else if (focusIndex &gt; 0) {
                    select(focusIndex - 1);
                }
            }
        }

        @Override public void selectNext() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // left-to-right, and then wrapping to the start of the next line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                    // go to next column
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to start of next row
                    select(pos.getRow() + 1, getTableColumn(0));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(0);
                } else if (focusIndex &lt; getItemCount() -1) {
                    select(focusIndex + 1);
                }
            }
        }

        @Override public void selectAboveCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getRow() == -1) {
                select(getItemCount() - 1);
            } else if (pos.getRow() &gt; 0) {
                select(pos.getRow() - 1, pos.getTableColumn());
            }
        }

        @Override public void selectBelowCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();

            if (pos.getRow() == -1) {
                select(0);
            } else if (pos.getRow() &lt; getItemCount() -1) {
                select(pos.getRow() + 1, pos.getTableColumn());
            }
        }

        @Override public void selectFirst() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            if (getItemCount() &gt; 0) {
                if (isCellSelectionEnabled()) {
                    select(0, focusedCell.getTableColumn());
                } else {
                    select(0);
                }
            }
        }

        @Override public void selectLast() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            int numItems = getItemCount();
            if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
                if (isCellSelectionEnabled()) {
                    select(numItems - 1, focusedCell.getTableColumn());
                } else {
                    select(numItems - 1);
                }
            }
        }

        @Override
        public void selectLeftCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() - 1 &gt;= 0) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
            }
        }

        @Override
        public void selectRightCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
            }
        }



        /***********************************************************************
         *                                                                     *
         * Support code                                                        *
         *                                                                     *
         **********************************************************************/

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) {
                oldList.removeListener(weakItemsContentListener);
            }
            if (newList != null) {
                newList.addListener(weakItemsContentListener);
            }

            updateItemCount();
            updateDefaultSelection();
        }

        private void updateDefaultSelection() {
            // when the items list totally changes, we should clear out
            // the selection
            int newSelectionIndex = -1;
            if (tableView.getItems() != null) {
                S selectedItem = getSelectedItem();
                if (selectedItem != null) {
                    newSelectionIndex = tableView.getItems().indexOf(selectedItem);
                }
            }

            clearSelection();
            select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
        }

        private TableColumn&lt;S,?&gt; getTableColumn(int pos) {
            return getTableView().getVisibleLeafColumn(pos);
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = getTableView().getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return getTableView().getVisibleLeafColumn(newColumnIndex);
        }

        private void updateSelectedIndex(int row) {
            setSelectedIndex(row);
            setSelectedItem(getModelItem(row));
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return itemCount;
        }

        private void updateItemCount() {
            if (tableView == null) {
                itemCount = -1;
            } else {
                List&lt;S&gt; items = getTableModel();
                itemCount = items == null ? -1 : items.size();
            }
        }

        private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TablePosition&lt;S,?&gt;&gt; c) {
            ControlUtils.updateSelectedIndices(this, c);

            if (isAtomic()) {
                return;
            }

            selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
        }
    }




    /**
     * A {@link FocusModel} with additional functionality to support the requirements
     * of a TableView control.
     *
     * @see TableView
     * @since JavaFX 2.0
     */
    public static class TableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;S, TableColumn&lt;S, ?&gt;&gt; {

        private final TableView&lt;S&gt; tableView;

        private final TablePosition&lt;S,?&gt; EMPTY_CELL;

        /**
         * Creates a default TableViewFocusModel instance that will be used to
         * manage focus of the provided TableView control.
         *
         * @param tableView The tableView upon which this focus model operates.
         * @throws NullPointerException The TableView argument can not be null.
         */
        public TableViewFocusModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
            this.EMPTY_CELL = new TablePosition&lt;&gt;(tableView, -1, null);

            itemsObserver = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
            if (tableView.getItems() != null) {
                this.tableView.getItems().addListener(weakItemsContentListener);
            }

            updateDefaultFocus();

            focusedCellProperty().addListener(o -&gt; {
                tableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
            });
        }

        private final InvalidationListener itemsObserver;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the focused index to refer to the new indices.
        private final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            c.next();

            if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                updateDefaultFocus();
                return;
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            final int focusedIndex = focusedCell.getRow();
            if (focusedIndex == -1 || c.getFrom() &gt; focusedIndex) {
                return;
            }

            c.reset();
            boolean added = false;
            boolean removed = false;
            int addedSize = 0;
            int removedSize = 0;
            while (c.next()) {
                added |= c.wasAdded();
                removed |= c.wasRemoved();
                addedSize += c.getAddedSize();
                removedSize += c.getRemovedSize();
            }

            if (added &amp;&amp; ! removed) {
                if (addedSize &lt; c.getList().size()) {
                    final int newFocusIndex = Math.min(getItemCount() - 1, getFocusedIndex() + addedSize);
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            } else if (!added &amp;&amp; removed) {
                final int newFocusIndex = Math.max(0, getFocusedIndex() - removedSize);
                if (newFocusIndex &lt; 0) {
                    focus(0, focusedCell.getTableColumn());
                } else {
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            }
        };

        private WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the tableview items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) oldList.removeListener(weakItemsContentListener);
            if (newList != null) newList.addListener(weakItemsContentListener);

            updateDefaultFocus();
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            if (tableView.getItems() == null) return -1;
            return tableView.getItems().size();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (tableView.getItems() == null) return null;

            if (index &lt; 0 || index &gt;= getItemCount()) return null;

            return tableView.getItems().get(index);
        }

        /**
         * The position of the current item in the TableView which has the focus.
         */
        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCell;
        public final ReadOnlyObjectProperty&lt;TablePosition&gt; focusedCellProperty() {
            return focusedCellPropertyImpl().getReadOnlyProperty();
        }
        private void setFocusedCell(TablePosition value) { focusedCellPropertyImpl().set(value);  }
        public final TablePosition getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }

        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCellPropertyImpl() {
            if (focusedCell == null) {
                focusedCell = new ReadOnlyObjectWrapper&lt;TablePosition&gt;(EMPTY_CELL) {
                    private TablePosition old;
                    @Override protected void invalidated() {
                        if (get() == null) return;

                        if (old == null || !old.equals(get())) {
                            setFocusedIndex(get().getRow());
                            setFocusedItem(getModelItem(getValue().getRow()));

                            old = get();
                        }
                    }

                    @Override
                    public Object getBean() {
                        return TableViewFocusModel.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;focusedCell&quot;;
                    }
                };
            }
            return focusedCell;
        }


        /**
         * Causes the item at the given index to receive the focus.
         *
         * @param row The row index of the item to give focus to.
         * @param column The column of the item to give focus to. Can be null.
         */
        @Override public void focus(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                TablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
                TablePosition&lt;S,?&gt; newFocusCell = new TablePosition&lt;&gt;(tableView, row, column);
                setFocusedCell(newFocusCell);

                if (newFocusCell.equals(oldFocusCell)) {
                    // manually update the focus properties to ensure consistency
                    setFocusedIndex(row);
                    setFocusedItem(getModelItem(row));
                }
            }
        }

        /**
         * Convenience method for setting focus on a particular row or cell
         * using a {@link TablePosition}.
         *
         * @param pos The table position where focus should be set.
         */
        public void focus(TablePosition pos) {
            if (pos == null) return;
            focus(pos.getRow(), pos.getTableColumn());
        }


        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Tests whether the row / cell at the given location currently has the
         * focus within the TableView.
         */
        @Override public boolean isFocused(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return false;

            TablePosition cell = getFocusedCell();
            boolean columnMatch = column == null || column.equals(cell.getTableColumn());

            return cell.getRow() == row &amp;&amp; columnMatch;
        }

        /**
         * Causes the item at the given index to receive the focus. This does not
         * cause the current selection to change. Updates the focusedItem and
         * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
         * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
         *
         * @param index The index of the item to get focus.
         */
        @Override public void focus(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                setFocusedCell(new TablePosition&lt;&gt;(tableView, index, null));
            }
        }

        /**
         * Attempts to move focus to the cell above the currently focused cell.
         */
        @Override public void focusAboveCell() {
            TablePosition cell = getFocusedCell();

            if (getFocusedIndex() == -1) {
                focus(getItemCount() - 1, cell.getTableColumn());
            } else if (getFocusedIndex() &gt; 0) {
                focus(getFocusedIndex() - 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell below the currently focused cell.
         */
        @Override public void focusBelowCell() {
            TablePosition cell = getFocusedCell();
            if (getFocusedIndex() == -1) {
                focus(0, cell.getTableColumn());
            } else if (getFocusedIndex() != getItemCount() -1) {
                focus(getFocusedIndex() + 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell to the left of the currently focused cell.
         */
        @Override public void focusLeftCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() &lt;= 0) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
        }

        /**
         * Attempts to move focus to the cell to the right of the the currently focused cell.
         */
        @Override public void focusRightCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() == getColumnCount() - 1) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
        }

        /** {@inheritDoc} */
        @Override public void focusPrevious() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() &gt; 0) {
                focusAboveCell();
            }
        }

        /** {@inheritDoc} */
        @Override public void focusNext() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() != getItemCount() -1) {
                focusBelowCell();
            }
        }

        /***********************************************************************
         *                                                                     *
         * Private Implementation                                              *
         *                                                                     *
         **********************************************************************/

        private void updateDefaultFocus() {
            // when the items list totally changes, we should clear out
            // the focus
            int newValueIndex = -1;
            if (tableView.getItems() != null) {
                S focusedItem = getFocusedItem();
                if (focusedItem != null) {
                    newValueIndex = tableView.getItems().indexOf(focusedItem);
                }

                // we put focus onto the first item, if there is at least
                // one item in the list
                if (newValueIndex == -1) {
                    newValueIndex = tableView.getItems().size() &gt; 0 ? 0 : -1;
                }
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            TableColumn&lt;S,?&gt; focusColumn = focusedCell != null &amp;&amp; !EMPTY_CELL.equals(focusedCell) ?
               focusedCell.getTableColumn() : tableView.getVisibleLeafColumn(0);

            focus(newValueIndex, focusColumn);
        }

        private int getColumnCount() {
            return tableView.getVisibleLeafColumns().size();
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = tableView.getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return tableView.getVisibleLeafColumn(newColumnIndex);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ColorPalette.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.CustomColorDialog;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.ColorPicker;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Hyperlink;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PopupControl;
import javafx.scene.control.Separator;
import javafx.scene.control.Tooltip;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.StrokeType;

import java.util.List;

import static com.sun.javafx.scene.control.Properties.getColorPickerString;

// Not public API - this is (presently) an implementation detail only
class ColorPalette extends Region {

    private static final int SQUARE_SIZE = 15;

    // package protected for testing purposes
    ColorPickerGrid colorPickerGrid;
    final Hyperlink customColorLink = new Hyperlink(getColorPickerString(&quot;customColorLink&quot;));
    CustomColorDialog customColorDialog = null;

    private ColorPicker colorPicker;
    private final GridPane standardColorGrid = new GridPane();
    private final GridPane customColorGrid = new GridPane();
    private final Separator separator = new Separator();
    private final Label customColorLabel = new Label(getColorPickerString(&quot;customColorLabel&quot;));

    private PopupControl popupControl;
    private ColorSquare focusedSquare;
    private ContextMenu contextMenu = null;

    private Color mouseDragColor = null;
    private boolean dragDetected = false;

    // Metrics for custom colors
    private int customColorNumber = 0;
    private int customColorRows = 0;
    private int customColorLastRowLength = 0;

    private final ColorSquare hoverSquare = new ColorSquare();

    public ColorPalette(final ColorPicker colorPicker) {
        getStyleClass().add(&quot;color-palette-region&quot;);
        this.colorPicker = colorPicker;
        colorPickerGrid = new ColorPickerGrid();
        colorPickerGrid.getChildren().get(0).requestFocus();
        customColorLabel.setAlignment(Pos.CENTER_LEFT);
        customColorLink.setPrefWidth(colorPickerGrid.prefWidth(-1));
        customColorLink.setAlignment(Pos.CENTER);
        customColorLink.setFocusTraversable(true);
        customColorLink.setVisited(true); // so that it always appears blue
        customColorLink.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override public void handle(ActionEvent t) {
                if (customColorDialog == null) {
                    customColorDialog = new CustomColorDialog(popupControl);
                    customColorDialog.customColorProperty().addListener((ov, t1, t2) -&gt; {
                        colorPicker.setValue(customColorDialog.customColorProperty().get());
                    });
                    customColorDialog.setOnSave(() -&gt; {
                        Color customColor = customColorDialog.customColorProperty().get();
                        buildCustomColors();
                        colorPicker.getCustomColors().add(customColor);
                        updateSelection(customColor);
                        Event.fireEvent(colorPicker, new ActionEvent());
                        colorPicker.hide();
                    });
                    customColorDialog.setOnUse(() -&gt; {
                        Event.fireEvent(colorPicker, new ActionEvent());
                        colorPicker.hide();
                    });
                }
                customColorDialog.setCurrentColor(colorPicker.valueProperty().get());
                if (popupControl != null) popupControl.setAutoHide(false);
                customColorDialog.show();
                 customColorDialog.setOnHidden(event -&gt; {
                    if (popupControl != null) popupControl.setAutoHide(true);
                 });
            }
        });

        initNavigation();

        buildStandardColors();
        standardColorGrid.getStyleClass().add(&quot;color-picker-grid&quot;);
        standardColorGrid.setVisible(true);
        customColorGrid.getStyleClass().add(&quot;color-picker-grid&quot;);
        customColorGrid.setVisible(false);
        buildCustomColors();
        colorPicker.getCustomColors().addListener(new ListChangeListener&lt;Color&gt;() {
            @Override public void onChanged(Change&lt;? extends Color&gt; change) {
                buildCustomColors();
            }
        });

        VBox paletteBox = new VBox();
        paletteBox.getStyleClass().add(&quot;color-palette&quot;);
        paletteBox.getChildren().addAll(standardColorGrid, colorPickerGrid, customColorLabel, customColorGrid, separator, customColorLink);

        hoverSquare.setMouseTransparent(true);
        hoverSquare.getStyleClass().addAll(&quot;hover-square&quot;);
        setFocusedSquare(null);

        getChildren().addAll(paletteBox, hoverSquare);
    }

    private void setFocusedSquare(ColorSquare square) {
        if (square == focusedSquare) {
            return;
        }
        focusedSquare = square;

        hoverSquare.setVisible(focusedSquare != null);
        if (focusedSquare == null) {
            return;
        }

        if (!focusedSquare.isFocused()) {
            focusedSquare.requestFocus();
        }

        hoverSquare.rectangle.setFill(focusedSquare.rectangle.getFill());

        Bounds b = square.localToScene(square.getLayoutBounds());

        double x = b.getMinX();
        double y = b.getMinY();

        double xAdjust;
        double scaleAdjust = hoverSquare.getScaleX() == 1.0 ? 0 : hoverSquare.getWidth() / 4.0;

        if (colorPicker.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
            x = focusedSquare.getLayoutX();
            xAdjust = -focusedSquare.getWidth() + scaleAdjust;
        } else {
            xAdjust = focusedSquare.getWidth() / 2.0 + scaleAdjust;
        }

        hoverSquare.setLayoutX(snapPositionX(x) - xAdjust);
        hoverSquare.setLayoutY(snapPositionY(y) - focusedSquare.getHeight() / 2.0 + (hoverSquare.getScaleY() == 1.0 ? 0 : focusedSquare.getHeight() / 4.0));
    }

    private void buildStandardColors() {
        // WARNING:
        // Make sure that the number of standard colors is equal to NUM_OF_COLUMNS
        // Currently, 12 standard colors are supported in a single row
        // Note : Creation &amp; access logic of standardColorGrid needs to be updated
        // in case more colors are added as separate row(s) in future.

        final Color[] STANDARD_COLORS = {
            Color.AQUA,
            Color.TEAL,
            Color.BLUE,
            Color.NAVY,
            Color.FUCHSIA,
            Color.PURPLE,
            Color.RED,
            Color.MAROON,
            Color.YELLOW,
            Color.OLIVE,
            Color.GREEN,
            Color.LIME
        };

        standardColorGrid.getChildren().clear();

        for (int i = 0; i &lt; NUM_OF_COLUMNS; i++) {
            standardColorGrid.add(new ColorSquare(STANDARD_COLORS[i], i, ColorType.STANDARD), i, 0);
        }
    }

    private void buildCustomColors() {
        final ObservableList&lt;Color&gt; customColors = colorPicker.getCustomColors();
        customColorNumber = customColors.size();

        customColorGrid.getChildren().clear();
        if (customColors.isEmpty()) {
            customColorLabel.setVisible(false);
            customColorLabel.setManaged(false);
            customColorGrid.setVisible(false);
            customColorGrid.setManaged(false);
            return;
        } else {
            customColorLabel.setVisible(true);
            customColorLabel.setManaged(true);
            customColorGrid.setVisible(true);
            customColorGrid.setManaged(true);
            if (contextMenu == null) {
                MenuItem item = new MenuItem(getColorPickerString(&quot;removeColor&quot;));
                item.setOnAction(e -&gt; {
                    ColorSquare square = (ColorSquare)contextMenu.getOwnerNode();
                    customColors.remove(square.rectangle.getFill());
                    buildCustomColors();
                });
                contextMenu = new ContextMenu(item);
            }
        }

        int customColumnIndex = 0;
        int customRowIndex = 0;
        int remainingSquares = customColors.size() % NUM_OF_COLUMNS;
        int numEmpty = (remainingSquares == 0) ? 0 : NUM_OF_COLUMNS - remainingSquares;
        customColorLastRowLength = remainingSquares == 0 ? 12 : remainingSquares;

        for (int i = 0; i &lt; customColors.size(); i++) {
            Color c = customColors.get(i);
            ColorSquare square = new ColorSquare(c, i, ColorType.CUSTOM);
            square.addEventHandler(KeyEvent.KEY_PRESSED, e -&gt; {
                if (e.getCode() == KeyCode.DELETE) {
                    customColors.remove(square.rectangle.getFill());
                    buildCustomColors();
                }
            });
            customColorGrid.add(square, customColumnIndex, customRowIndex);
            customColumnIndex++;
            if (customColumnIndex == NUM_OF_COLUMNS) {
                customColumnIndex = 0;
                customRowIndex++;
            }
        }
        for (int i = 0; i &lt; numEmpty; i++) {
            ColorSquare emptySquare = new ColorSquare();
            emptySquare.setDisable(true);
            customColorGrid.add(emptySquare, customColumnIndex, customRowIndex);
            customColumnIndex++;
        }
        customColorRows = customRowIndex + 1;
        requestLayout();

    }

    private void initNavigation() {
        setOnKeyPressed(ke -&gt; {
            switch (ke.getCode()) {
                case SPACE:
                case ENTER:
                    processSelectKey(ke);
                    ke.consume();
                    break;
                default: // no-op
            }
        });

        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {
            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                final Node subsequentNode = context.selectInSubtree(context.getRoot(), owner, dir);
                switch (dir) {
                    case NEXT:
                    case NEXT_IN_LINE:
                    case PREVIOUS:
                        return subsequentNode;
                    // Here, we need to intercept the standard algorithm in a few cases to get the desired traversal
                    // For right or left direction we want to continue on the next or previous row respectively
                    // For up and down, the custom color panel might be skipped by the standard algorithm (if not wide enough
                    // to be between the current color and custom color button), so we need to include it in the path explicitly.
                    case LEFT:
                    case RIGHT:
                    case UP:
                    case DOWN:
                        if (owner instanceof ColorSquare) {
                            Node result =  processArrow((ColorSquare)owner, dir);
                            return result != null ? result : subsequentNode;
                        } else {
                            return subsequentNode;
                        }
                }
                return null;
            }

            private Node processArrow(ColorSquare owner, Direction dir) {
                int row = 0;
                int column = 0;

                if (owner.colorType == ColorType.STANDARD) {
                    row = 0;
                    column = owner.index;
                } else {
                    row = owner.index / NUM_OF_COLUMNS;
                    column = owner.index % NUM_OF_COLUMNS;
                }

                // Adjust the direction according to color picker orientation
                dir = dir.getDirectionForNodeOrientation(colorPicker.getEffectiveNodeOrientation());
                // This returns true for all the cases which we need to override
                if (isAtBorder(dir, row, column, (owner.colorType == ColorType.CUSTOM))) {
                    // There's no other node in the direction from the square, so we need to continue on some other row
                    // or cycle
                    int subsequentRow = row;
                    int subsequentColumn = column;
                    boolean subSequentSquareCustom = (owner.colorType == ColorType.CUSTOM);
                    boolean subSequentSquareStandard = (owner.colorType == ColorType.STANDARD);
                    switch (dir) {
                        case LEFT:
                        case RIGHT:
                            // The next row is either the first or the last, except when cycling in custom colors, the last row
                            // might have different number of columns
                            if (owner.colorType == ColorType.STANDARD) {
                                subsequentRow = 0;
                                subsequentColumn = (dir == Direction.LEFT)? NUM_OF_COLUMNS - 1 : 0;
                            }
                            else if (owner.colorType == ColorType.CUSTOM) {
                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, customColorRows);
                                subsequentColumn = dir == Direction.LEFT ? subsequentRow == customColorRows - 1 ?
                                        customColorLastRowLength - 1 : NUM_OF_COLUMNS - 1 : 0;
                            } else {
                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, NUM_OF_ROWS);
                                subsequentColumn = dir == Direction.LEFT ? NUM_OF_COLUMNS - 1 : 0;
                            }
                            break;
                        case UP: // custom color are not handled here
                            if (owner.colorType == ColorType.NORMAL &amp;&amp; row == 0) {
                                subSequentSquareStandard = true;
                            }
                            break;
                        case DOWN: // custom color are not handled here
                            if (customColorNumber &gt; 0) {
                                subSequentSquareCustom = true;
                                subsequentRow = 0;
                                subsequentColumn = customColorRows &gt; 1 ? column : Math.min(customColorLastRowLength - 1, column);
                                break;
                            } else {
                                return null; // Let the default algorithm handle this
                            }

                    }
                    if (subSequentSquareCustom) {
                        return customColorGrid.getChildren().get(subsequentRow * NUM_OF_COLUMNS + subsequentColumn);
                    } else if (subSequentSquareStandard) {
                        return standardColorGrid.getChildren().get(subsequentColumn);
                    } else {
                        return colorPickerGrid.getChildren().get(subsequentRow * NUM_OF_COLUMNS + subsequentColumn);
                    }
                }
                return null;
            }

            private boolean isAtBorder(Direction dir, int row, int column, boolean custom) {
                switch (dir) {
                    case LEFT:
                        return column == 0;
                    case RIGHT:
                        return custom &amp;&amp; row == customColorRows - 1 ?
                                column == customColorLastRowLength - 1 : column == NUM_OF_COLUMNS - 1;
                    case UP:
                        return !custom &amp;&amp; row == 0;
                    case DOWN:
                        return !custom &amp;&amp; row == NUM_OF_ROWS - 1;
                }
                return false;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                return standardColorGrid.getChildren().get(0);
            }

            @Override
            public Node selectLast(TraversalContext context) {
                return customColorLink;
            }
        }));
    }

    private void processSelectKey(KeyEvent ke) {
        if (focusedSquare != null) focusedSquare.selectColor(ke);
    }

    public void setPopupControl(PopupControl pc) {
        this.popupControl = pc;
    }

    public ColorPickerGrid getColorGrid() {
        return colorPickerGrid;
    }

    public boolean isCustomColorDialogShowing() {
        if (customColorDialog != null) return customColorDialog.isVisible();
        return false;
    }


    enum ColorType {
        NORMAL,
        STANDARD,
        CUSTOM
    };

    class ColorSquare extends StackPane {
        Rectangle rectangle;
        int index;
        boolean isEmpty;
        ColorType colorType = ColorType.NORMAL;

        public ColorSquare() {
            this(null, -1, ColorType.NORMAL);
        }

        public ColorSquare(Color color, int index) {
            this(color, index, ColorType.NORMAL);
        }

        public ColorSquare(Color color, int index, ColorType type) {
            // Add style class to handle selected color square
            getStyleClass().add(&quot;color-square&quot;);
            if (color != null) {
                setFocusTraversable(true);

                focusedProperty().addListener((s, ov, nv) -&gt; {
                    setFocusedSquare(nv ? this : null);
                });

                addEventHandler(MouseEvent.MOUSE_ENTERED, event -&gt; {
                    setFocusedSquare(ColorSquare.this);
                });
                addEventHandler(MouseEvent.MOUSE_EXITED, event -&gt; {
                    setFocusedSquare(null);
                });

                addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                    if (!dragDetected &amp;&amp; event.getButton() == MouseButton.PRIMARY &amp;&amp; event.getClickCount() == 1) {
                        if (!isEmpty) {
                            Color fill = (Color) rectangle.getFill();
                            colorPicker.setValue(fill);
                            colorPicker.fireEvent(new ActionEvent());
                            updateSelection(fill);
                            event.consume();
                        }
                        colorPicker.hide();
                    } else if (event.getButton() == MouseButton.SECONDARY ||
                            event.getButton() == MouseButton.MIDDLE) {
                        if ((colorType == ColorType.CUSTOM) &amp;&amp; contextMenu != null) {
                            if (!contextMenu.isShowing()) {
                                contextMenu.show(ColorSquare.this, Side.RIGHT, 0, 0);
                                Utils.addMnemonics(contextMenu, ColorSquare.this.getScene(), NodeHelper.isShowMnemonics(colorPicker));
                            } else {
                                contextMenu.hide();
                                Utils.removeMnemonics(contextMenu, ColorSquare.this.getScene());
                            }
                        }
                    }
                });
            }
            this.index = index;
            this.colorType = type;
            rectangle = new Rectangle(SQUARE_SIZE, SQUARE_SIZE);
            if (color == null) {
                rectangle.setFill(Color.WHITE);
                isEmpty = true;
            } else {
                rectangle.setFill(color);
            }

            rectangle.setStrokeType(StrokeType.INSIDE);

            String tooltipStr = ColorPickerSkin.tooltipString(color);
            Tooltip.install(this, new Tooltip((tooltipStr == null) ? &quot;&quot; : tooltipStr));

            rectangle.getStyleClass().add(&quot;color-rect&quot;);

            getChildren().add(rectangle);
        }

        public void selectColor(KeyEvent event) {
            if (rectangle.getFill() != null) {
                if (rectangle.getFill() instanceof Color) {
                    colorPicker.setValue((Color) rectangle.getFill());
                    colorPicker.fireEvent(new ActionEvent());
                }
                event.consume();
            }
            colorPicker.hide();
        }
    }

    // The skin can update selection if colorpicker value changes..
    public void updateSelection(Color color) {
        setFocusedSquare(null);

        // Check all color grids to find ColorSquare that matches color
        // if found, set focus to it

        List&lt;GridPane&gt; gridList = List.of(standardColorGrid, colorPickerGrid,
                                          customColorGrid);

        for (GridPane grid : gridList) {
            ColorSquare sq = findColorSquare(grid, color);
            if (sq != null) {
                setFocusedSquare(sq);
                return;
            }
        }
    }

    private ColorSquare findColorSquare(GridPane colorGrid, Color color) {
        for (Node n : colorGrid.getChildren()) {
            ColorSquare c = (ColorSquare) n;
            if (c.rectangle.getFill().equals(color)) {
                return c;
            }
        }
        return null;
    }

    class ColorPickerGrid extends GridPane {

        private final List&lt;ColorSquare&gt; squares;

        public ColorPickerGrid() {
            getStyleClass().add(&quot;color-picker-grid&quot;);
            setId(&quot;ColorCustomizerColorGrid&quot;);
            int columnIndex = 0, rowIndex = 0;
            squares = FXCollections.observableArrayList();
            final int numColors = RAW_VALUES.length / 3;
            Color[] colors = new Color[numColors];
            for (int i = 0; i &lt; numColors; i++) {
                colors[i] = new Color(RAW_VALUES[(i * 3)] / 255,
                        RAW_VALUES[(i * 3) + 1] / 255, RAW_VALUES[(i * 3) + 2] / 255,
                        1.0);
                ColorSquare cs = new ColorSquare(colors[i], i);
                squares.add(cs);
            }

            for (ColorSquare square : squares) {
                add(square, columnIndex, rowIndex);
                columnIndex++;
                if (columnIndex == NUM_OF_COLUMNS) {
                    columnIndex = 0;
                    rowIndex++;
                }
            }
            setOnMouseDragged(t -&gt; {
                if (!dragDetected) {
                    dragDetected = true;
                    mouseDragColor = colorPicker.getValue();
                }
                int xIndex = com.sun.javafx.util.Utils.clamp(0,
                        (int)t.getX()/(SQUARE_SIZE + 1), NUM_OF_COLUMNS - 1);
                int yIndex = com.sun.javafx.util.Utils.clamp(0,
                        (int)t.getY()/(SQUARE_SIZE + 1), NUM_OF_ROWS - 1);
                int index = xIndex + yIndex*NUM_OF_COLUMNS;
<A NAME="37"></A>                colorPicker.setValue((Color) squares.get(index).rectangle.getFill());
                updateSelection(colorPicker.getValue());
            });
            <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#37',2,'match44-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>addEventHandler(MouseEvent.MOUSE_RELEASED, t -&gt; {
                if(colorPickerGrid.getBoundsInLocal().contains(t.getX(), t.getY())) {
                    updateSelection(colorPicker.getValue());
                    colorPicker.fireEvent</B></FONT>(new ActionEvent());
                    colorPicker.hide();
                } else {
                    // restore color as mouse release happened outside the grid.
                    if (mouseDragColor != null) {
                        colorPicker.setValue(mouseDragColor);
                        updateSelection(mouseDragColor);
                    }
                }
                dragDetected = false;
            });
        }

        public List&lt;ColorSquare&gt; getSquares() {
            return squares;
        }

        @Override protected double computePrefWidth(double height) {
            return (SQUARE_SIZE + 1)*NUM_OF_COLUMNS;
        }

        @Override protected double computePrefHeight(double width) {
            return (SQUARE_SIZE + 1)*NUM_OF_ROWS;
        }
    }

    private static final int NUM_OF_COLUMNS = 12;
    private static double[] RAW_VALUES = {
            // WARNING: always make sure the number of colors is a divisable by NUM_OF_COLUMNS
            255, 255, 255, // first row
            242, 242, 242,
            230, 230, 230,
            204, 204, 204,
            179, 179, 179,
            153, 153, 153,
            128, 128, 128,
            102, 102, 102,
            77, 77, 77,
            51, 51, 51,
            26, 26, 26,
            0, 0, 0,
            0, 51, 51, // second row
            0, 26, 128,
            26, 0, 104,
            51, 0, 51,
            77, 0, 26,
            153, 0, 0,
            153, 51, 0,
            153, 77, 0,
            153, 102, 0,
            153, 153, 0,
            102, 102, 0,
            0, 51, 0,
            26, 77, 77, // third row
            26, 51, 153,
            51, 26, 128,
            77, 26, 77,
            102, 26, 51,
            179, 26, 26,
            179, 77, 26,
            179, 102, 26,
            179, 128, 26,
            179, 179, 26,
            128, 128, 26,
            26, 77, 26,
            51, 102, 102, // fourth row
            51, 77, 179,
            77, 51, 153,
            102, 51, 102,
            128, 51, 77,
            204, 51, 51,
            204, 102, 51,
            204, 128, 51,
            204, 153, 51,
            204, 204, 51,
            153, 153, 51,
            51, 102, 51,
            77, 128, 128, // fifth row
            77, 102, 204,
            102, 77, 179,
            128, 77, 128,
            153, 77, 102,
            230, 77, 77,
            230, 128, 77,
            230, 153, 77,
            230, 179, 77,
            230, 230, 77,
            179, 179, 77,
            77, 128, 77,
            102, 153, 153, // sixth row
            102, 128, 230,
            128, 102, 204,
            153, 102, 153,
            179, 102, 128,
            255, 102, 102,
            255, 153, 102,
            255, 179, 102,
            255, 204, 102,
            255, 255, 77,
            204, 204, 102,
            102, 153, 102,
            128, 179, 179, // seventh row
            128, 153, 255,
            153, 128, 230,
            179, 128, 179,
            204, 128, 153,
            255, 128, 128,
            255, 153, 128,
            255, 204, 128,
            255, 230, 102,
            255, 255, 102,
            230, 230, 128,
            128, 179, 128,
            153, 204, 204, // eigth row
            153, 179, 255,
            179, 153, 255,
            204, 153, 204,
            230, 153, 179,
            255, 153, 153,
            255, 179, 128,
            255, 204, 153,
            255, 230, 128,
            255, 255, 128,
            230, 230, 153,
            153, 204, 153,
            179, 230, 230, // ninth row
            179, 204, 255,
            204, 179, 255,
            230, 179, 230,
            230, 179, 204,
            255, 179, 179,
            255, 179, 153,
            255, 230, 179,
            255, 230, 153,
            255, 255, 153,
            230, 230, 179,
            179, 230, 179,
            204, 255, 255, // tenth row
            204, 230, 255,
            230, 204, 255,
            255, 204, 255,
            255, 204, 230,
            255, 204, 204,
            255, 204, 179,
            255, 230, 204,
            255, 255, 179,
            255, 255, 204,
            230, 230, 204,
            204, 255, 204
    };

    private static final int NUM_OF_COLORS = RAW_VALUES.length / 3;
    private static final int NUM_OF_ROWS = NUM_OF_COLORS / NUM_OF_COLUMNS;
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ComboBoxListViewSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.ComboBoxBaseBehavior;
import com.sun.javafx.scene.control.behavior.ComboBoxListViewBehavior;

import java.util.List;

import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.PseudoClass;
import javafx.event.ActionEvent;
import javafx.event.EventTarget;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Control;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SelectionMode;
import javafx.scene.control.SelectionModel;
import javafx.scene.control.TextField;
import javafx.scene.input.*;
import javafx.util.Callback;
import javafx.util.StringConverter;

/**
 * Default skin implementation for the {@link ComboBox} control.
 *
 * @see ComboBox
 * @since 9
 */
public class ComboBoxListViewSkin&lt;T&gt; extends ComboBoxPopupControl&lt;T&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    // By default we measure the width of all cells in the ListView. If this
    // is too burdensome, the developer may set a property in the ComboBox
    // properties map with this key to specify the number of rows to measure.
    // This may one day become a property on the ComboBox itself.
    private static final String COMBO_BOX_ROWS_TO_MEASURE_WIDTH_KEY = &quot;comboBoxRowsToMeasureWidth&quot;;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final ComboBox&lt;T&gt; comboBox;
    private ObservableList&lt;T&gt; comboBoxItems;

    private ListCell&lt;T&gt; buttonCell;
    private Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; cellFactory;

    private final ListView&lt;T&gt; listView;
    private ObservableList&lt;T&gt; listViewItems;

    private boolean listSelectionLock = false;
    private boolean listViewSelectionDirty = false;

    private final ComboBoxListViewBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private boolean itemCountDirty;
    private final ListChangeListener&lt;T&gt; listViewItemsListener = new ListChangeListener&lt;T&gt;() {
        @Override public void onChanged(ListChangeListener.Change&lt;? extends T&gt; c) {
            itemCountDirty = true;
            getSkinnable().requestLayout();
        }
    };

    private final InvalidationListener itemsObserver;

    private final WeakListChangeListener&lt;T&gt; weakListViewItemsListener =
            new WeakListChangeListener&lt;T&gt;(listViewItemsListener);


    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ComboBoxListViewSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ComboBoxListViewSkin(final ComboBox&lt;T&gt; control) {
        super(control);

        // install default input map for the control
        this.behavior = new ComboBoxListViewBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        this.comboBox = control;
        updateComboBoxItems();

        itemsObserver = observable -&gt; {
            updateComboBoxItems();
            updateListViewItems();
        };
        control.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));

        // listview for popup
        this.listView = createListView();

        // Fix for RT-21207. Additional code related to this bug is further below.
        this.listView.setManaged(false);
        getChildren().add(listView);
        // -- end of fix

        updateListViewItems();
        updateCellFactory();

        updateButtonCell();

        // Fix for RT-19431 (also tested via ComboBoxListViewSkinTest)
        updateValue();

        registerChangeListener(control.itemsProperty(), e -&gt; {
            updateComboBoxItems();
            updateListViewItems();
        });
        registerChangeListener(control.promptTextProperty(), e -&gt; updateDisplayNode());
        registerChangeListener(control.cellFactoryProperty(), e -&gt; updateCellFactory());
        registerChangeListener(control.visibleRowCountProperty(), e -&gt; {
            if (listView == null) return;
            listView.requestLayout();
        });
        registerChangeListener(control.converterProperty(), e -&gt; updateListViewItems());
        registerChangeListener(control.buttonCellProperty(), e -&gt; {
            updateButtonCell();
            updateDisplayArea();
        });
        registerChangeListener(control.valueProperty(), e -&gt; {
            updateValue();
            control.fireEvent(new ActionEvent());
        });
        registerChangeListener(control.editableProperty(), e -&gt; updateEditable());

        // Refer to JDK-8095306
        if (comboBox.isShowing()) {
            show();
        }
        comboBox.sceneProperty().addListener(o -&gt; {
            if (((ObservableValue)o).getValue() == null) {
                comboBox.hide();
            }
        });
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * By default this skin hides the popup whenever the ListView is clicked in.
     * By setting hideOnClick to false, the popup will not be hidden when the
     * ListView is clicked in. This is beneficial in some scenarios (for example,
     * when the ListView cells have checkboxes).
     */
    // --- hide on click
    private final BooleanProperty hideOnClick = new SimpleBooleanProperty(this, &quot;hideOnClick&quot;, true);
    public final BooleanProperty hideOnClickProperty() {
        return hideOnClick;
    }
    public final boolean isHideOnClick() {
        return hideOnClick.get();
    }
    public final void setHideOnClick(boolean value) {
        hideOnClick.set(value);
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected TextField getEditor() {
        // Return null if editable is false, even if the ComboBox has an editor set.
        // Use getSkinnable() here because this method is called from the super
        // constructor before comboBox is initialized.
        return getSkinnable().isEditable() ? ((ComboBox)getSkinnable()).getEditor() : null;
    }

    /** {@inheritDoc} */
    @Override protected StringConverter&lt;T&gt; getConverter() {
        return ((ComboBox)getSkinnable()).getConverter();
    }

    /** {@inheritDoc} */
    @Override public Node getDisplayNode() {
        Node displayNode;
        if (comboBox.isEditable()) {
            displayNode = getEditableInputNode();
        } else {
            displayNode = buttonCell;
        }

        updateDisplayNode();

        return displayNode;
    }

    /** {@inheritDoc} */
    @Override public Node getPopupContent() {
        return listView;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        reconfigurePopup();
        return 50;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double superPrefWidth = super.computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);
        double listViewWidth = listView.prefWidth(height);
        double pw = Math.max(superPrefWidth, listViewWidth);

        reconfigurePopup();

        return pw;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        reconfigurePopup();
        return super.computeMaxWidth(height, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        reconfigurePopup();
        return super.computeMinHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        reconfigurePopup();
        return super.computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        reconfigurePopup();
        return super.computeMaxHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
            final double w, final double h) {
        if (listViewSelectionDirty) {
            try {
                listSelectionLock = true;
                T item = comboBox.getSelectionModel().getSelectedItem();
                listView.getSelectionModel().clearSelection();
                listView.getSelectionModel().select(item);
            } finally {
                listSelectionLock = false;
                listViewSelectionDirty = false;
            }
        }

        super.layoutChildren(x, y, w, h);
    }



    /***************************************************************************
     *                                                                         *
     * Private methods                                                         *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void updateDisplayNode() {
        if (getEditor() != null) {
            super.updateDisplayNode();
        } else {
<A NAME="18"></A>            T value = comboBox.getValue();
            int index = getIndexOfComboBoxValueInItemsList();
            if (index &gt; -1) {
                <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#18',2,'match44-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>buttonCell.setItem(null);
                buttonCell.updateIndex(index);
            } else {
                // RT-21336 Show the ComboBox value even though it doesn't
                // exist in the ComboBox items list (part two of fix)
                buttonCell.updateIndex(-1);
                boolean empty = updateDisplayText(buttonCell, value, false);

                // Note that empty boolean collected above. This is used to resolve
                // RT-27834, where we were getting different styling based on whether
                // the cell was updated via the updateIndex method above, or just
                // by directly updating the text. We fake the pseudoclass state
                // for empty, filled, and selected here.
                buttonCell.pseudoClassStateChanged(PSEUDO_CLASS_EMPTY,    empty);
                buttonCell.pseudoClassStateChanged(PSEUDO_CLASS_FILLED,   !empty);
                buttonCell.pseudoClassStateChanged(PSEUDO_CLASS_SELECTED, true);
            }</B></FONT>
        }
    }

    /** {@inheritDoc} */
    @Override ComboBoxBaseBehavior getBehavior() {
        return behavior;
    }

    private void updateComboBoxItems() {
        comboBoxItems = comboBox.getItems();
        comboBoxItems = comboBoxItems == null ? FXCollections.&lt;T&gt;emptyObservableList() : comboBoxItems;
    }

    private void updateListViewItems() {
        if (listViewItems != null) {
            listViewItems.removeListener(weakListViewItemsListener);
        }

        this.listViewItems = comboBoxItems;
        listView.setItems(listViewItems);

        if (listViewItems != null) {
            listViewItems.addListener(weakListViewItemsListener);
        }

        itemCountDirty = true;
        getSkinnable().requestLayout();
    }

    private void updateValue() {
        T newValue = comboBox.getValue();

        SelectionModel&lt;T&gt; listViewSM = listView.getSelectionModel();

        // RT-22386: We need to test to see if the value is in the comboBox
        // items list. If it isn't, then we should clear the listview
        // selection
        final int indexOfNewValue = getIndexOfComboBoxValueInItemsList();

        if (newValue == null &amp;&amp; indexOfNewValue == -1) {
            listViewSM.clearSelection();
        } else {
            if (indexOfNewValue == -1) {
                listSelectionLock = true;
                listViewSM.clearSelection();
                listSelectionLock = false;
            } else {
                int index = comboBox.getSelectionModel().getSelectedIndex();
                if (index &gt;= 0 &amp;&amp; index &lt; comboBoxItems.size()) {
                    T itemsObj = comboBoxItems.get(index);
                    if ((itemsObj != null &amp;&amp; itemsObj.equals(newValue)) || (itemsObj == null &amp;&amp; newValue == null)) {
                        listViewSM.select(index);
                    } else {
                        listViewSM.select(newValue);
                    }
                } else {
                    // just select the first instance of newValue in the list
                    int listViewIndex = comboBoxItems.indexOf(newValue);
                    if (listViewIndex == -1) {
                        // RT-21336 Show the ComboBox value even though it doesn't
                        // exist in the ComboBox items list (part one of fix)
                        updateDisplayNode();
                    } else {
                        listViewSM.select(listViewIndex);
                    }
                }
            }
        }
    }

    // return a boolean to indicate that the cell is empty (and therefore not filled)
    private boolean updateDisplayText(ListCell&lt;T&gt; cell, T item, boolean empty) {
        if (empty) {
            if (cell == null) return true;
            cell.setGraphic(null);
            cell.setText(null);
            return true;
        } else if (item instanceof Node) {
            Node currentNode = cell.getGraphic();
            Node newNode = (Node) item;
            if (currentNode == null || ! currentNode.equals(newNode)) {
                cell.setText(null);
                cell.setGraphic(newNode);
            }
            return newNode == null;
        } else {
            // run item through StringConverter if it isn't null
            final StringConverter&lt;T&gt; c = comboBox.getConverter();
            final String promptText = comboBox.getPromptText();
            String s = item == null &amp;&amp; promptText != null ? promptText :
                       c == null ? (item == null ? null : item.toString()) : c.toString(item);
            cell.setText(s);
            cell.setGraphic(null);
            return s == null || s.isEmpty();
        }
    }

    private int getIndexOfComboBoxValueInItemsList() {
        T value = comboBox.getValue();
        int index = comboBoxItems.indexOf(value);
        return index;
    }

    private void updateButtonCell() {
        buttonCell = comboBox.getButtonCell() != null ?
                comboBox.getButtonCell() : getDefaultCellFactory().call(listView);
        buttonCell.setMouseTransparent(true);
        buttonCell.updateListView(listView);

        // As long as the screen-reader is concerned this node is not a list item.
        // This matters because the screen-reader counts the number of list item
        // within combo and speaks it to the user.
        buttonCell.setAccessibleRole(AccessibleRole.NODE);
    }

    private void updateCellFactory() {
        Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; cf = comboBox.getCellFactory();
        cellFactory = cf != null ? cf : getDefaultCellFactory();
        listView.setCellFactory(cellFactory);
    }

    private Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; getDefaultCellFactory() {
        return new Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;() {
            @Override public ListCell&lt;T&gt; call(ListView&lt;T&gt; listView) {
                return new ListCell&lt;T&gt;() {
                    @Override public void updateItem(T item, boolean empty) {
                        super.updateItem(item, empty);
                        updateDisplayText(this, item, empty);
                    }
                };
            }
        };
    }

    private ListView&lt;T&gt; createListView() {
        final ListView&lt;T&gt; _listView = new ListView&lt;T&gt;() {

            {
                getProperties().put(&quot;selectFirstRowByDefault&quot;, false);
            }

            @Override protected double computeMinHeight(double width) {
                return 30;
            }

            @Override protected double computePrefWidth(double height) {
                double pw;
                if (getSkin() instanceof ListViewSkin) {
                    ListViewSkin&lt;?&gt; skin = (ListViewSkin&lt;?&gt;)getSkin();
                    if (itemCountDirty) {
                        skin.updateItemCount();
                        itemCountDirty = false;
                    }

                    int rowsToMeasure = -1;
                    if (comboBox.getProperties().containsKey(COMBO_BOX_ROWS_TO_MEASURE_WIDTH_KEY)) {
                        rowsToMeasure = (Integer) comboBox.getProperties().get(COMBO_BOX_ROWS_TO_MEASURE_WIDTH_KEY);
                    }

                    pw = Math.max(comboBox.getWidth(), skin.getMaxCellWidth(rowsToMeasure) + 30);
                } else {
                    pw = Math.max(100, comboBox.getWidth());
                }

                // need to check the ListView pref height in the case that the
                // placeholder node is showing
                if (getItems().isEmpty() &amp;&amp; getPlaceholder() != null) {
                    pw = Math.max(super.computePrefWidth(height), pw);
                }

                return Math.max(50, pw);
            }

            @Override protected double computePrefHeight(double width) {
                return getListViewPrefHeight();
            }
        };

        _listView.setId(&quot;list-view&quot;);
        _listView.placeholderProperty().bind(comboBox.placeholderProperty());
        _listView.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
        _listView.setFocusTraversable(false);

        _listView.getSelectionModel().selectedIndexProperty().addListener(o -&gt; {
            if (listSelectionLock) return;
            int index = listView.getSelectionModel().getSelectedIndex();
            comboBox.getSelectionModel().select(index);
            updateDisplayNode();
            comboBox.notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        });

        comboBox.getSelectionModel().selectedItemProperty().addListener(o -&gt; {
            listViewSelectionDirty = true;
        });

        _listView.addEventFilter(MouseEvent.MOUSE_RELEASED, t -&gt; {
            // RT-18672: Without checking if the user is clicking in the
            // scrollbar area of the ListView, the comboBox will hide. Therefore,
            // we add the check below to prevent this from happening.
            EventTarget target = t.getTarget();
            if (target instanceof Parent) {
                List&lt;String&gt; s = ((Parent) target).getStyleClass();
                if (s.contains(&quot;thumb&quot;)
                        || s.contains(&quot;track&quot;)
                        || s.contains(&quot;decrement-arrow&quot;)
                        || s.contains(&quot;increment-arrow&quot;)) {
                    return;
                }
            }

            if (isHideOnClick()) {
                comboBox.hide();
            }
        });

        _listView.setOnKeyPressed(t -&gt; {
            // TODO move to behavior, when (or if) this class becomes a SkinBase
            if (t.getCode() == KeyCode.ENTER ||
                    t.getCode() == KeyCode.SPACE ||
                    t.getCode() == KeyCode.ESCAPE) {
                comboBox.hide();
            }
        });

        return _listView;
    }

    private double getListViewPrefHeight() {
        double ph;
        if (listView.getSkin() instanceof VirtualContainerBase) {
            int maxRows = comboBox.getVisibleRowCount();
            VirtualContainerBase&lt;?,?&gt; skin = (VirtualContainerBase&lt;?,?&gt;)listView.getSkin();
            ph = skin.getVirtualFlowPreferredHeight(maxRows);
        } else {
            double ch = comboBoxItems.size() * 25;
            ph = Math.min(ch, 200);
        }

        return ph;
    }



    /**************************************************************************
     *
     * API for testing
     *
     *************************************************************************/

    ListView&lt;T&gt; getListView() {
        return listView;
    }




    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    // These three pseudo class states are duplicated from Cell
    private static final PseudoClass PSEUDO_CLASS_SELECTED =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass PSEUDO_CLASS_EMPTY =
            PseudoClass.getPseudoClass(&quot;empty&quot;);
    private static final PseudoClass PSEUDO_CLASS_FILLED =
            PseudoClass.getPseudoClass(&quot;filled&quot;);


    /** {@inheritDoc} */
    @Override public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: {
                if (comboBox.isShowing()) {
                    /* On Mac, for some reason, changing the selection on the list is not
                     * reported by VoiceOver the first time it shows.
                     * Note that this fix returns a child of the PopupWindow back to the main
                     * Stage, which doesn't seem to cause problems.
                     */
                    return listView.queryAccessibleAttribute(attribute, parameters);
                }
                return null;
            }
            case TEXT: {
                String accText = comboBox.getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
                String title = comboBox.isEditable() ? getEditor().getText() : buttonCell.getText();
                if (title == null || title.isEmpty()) {
                    title = comboBox.getPromptText();
                }
                return title;
            }
            case SELECTION_START:
                return (getEditor() != null) ? getEditor().getSelection().getStart() : null;
            case SELECTION_END:
                return (getEditor() != null) ? getEditor().getSelection().getEnd() : null;
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/NestedTableColumnHeader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.skin.Utils;
import javafx.beans.property.ObjectProperty;
import javafx.collections.WeakListChangeListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Callback;

/**
 * &lt;p&gt;This class is used to construct the header of a TableView. We take the approach
 * that every TableView header is nested - even if it isn't. This allows for us
 * to use the same code for building a single row of TableColumns as we would
 * with a heavily nested sequences of TableColumns. Because of this, the
 * TableHeaderRow class consists of just one instance of a NestedTableColumnHeader.
 *
 * @since 9
 * @see TableColumnHeader
 * @see TableHeaderRow
 * @see TableColumnBase
 */
public class NestedTableColumnHeader extends TableColumnHeader {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/

    static final String DEFAULT_STYLE_CLASS = &quot;nested-column-header&quot;;

    private static final int DRAG_RECT_WIDTH = 4;

    private static final String TABLE_COLUMN_KEY = &quot;TableColumn&quot;;
    private static final String TABLE_COLUMN_HEADER_KEY = &quot;TableColumnHeader&quot;;



    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    /**
     * Represents the actual columns directly contained in this nested column.
     * It does NOT include ANY of the children of these columns, if any exist.
     */
    private ObservableList&lt;? extends TableColumnBase&gt; columns;

    private TableColumnHeader label;

    private ObservableList&lt;TableColumnHeader&gt; columnHeaders;
    private ObservableList&lt;TableColumnHeader&gt; unmodifiableColumnHeaders;

    // used for column resizing
    private double lastX = 0.0F;
    private double dragAnchorX = 0.0;

    // drag rectangle overlays
    private Map&lt;TableColumnBase&lt;?,?&gt;, Rectangle&gt; dragRects = new WeakHashMap&lt;&gt;();

    boolean updateColumns = true;



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new NestedTableColumnHeader instance to visually represent the given
     * {@link TableColumnBase} instance.
     *
     * @param tc The table column to be visually represented by this instance.
     */
    public NestedTableColumnHeader(final TableColumnBase tc) {
        super(tc);

        setFocusTraversable(false);

        // init UI
        label = createTableColumnHeader(getTableColumn());
        label.setTableHeaderRow(getTableHeaderRow());
        label.setParentHeader(getParentHeader());
        label.setNestedColumnHeader(this);

        if (getTableColumn() != null) {
            changeListenerHandler.registerChangeListener(getTableColumn().textProperty(), e -&gt;
                    label.setVisible(getTableColumn().getText() != null &amp;&amp; ! getTableColumn().getText().isEmpty()));
        }
    }



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;TableColumnBase&gt; columnsListener = c -&gt; {
        setHeadersNeedUpdate();
    };

    private final WeakListChangeListener weakColumnsListener =
            new WeakListChangeListener(columnsListener);

    private static final EventHandler&lt;MouseEvent&gt; rectMousePressed = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        if (! header.isColumnResizingEnabled()) return;

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (me.isConsumed()) return;
        me.consume();

        if (me.getClickCount() == 2 &amp;&amp; me.isPrimaryButtonDown()) {
            // the user wants to resize the column such that its
            // width is equal to the widest element in the column
            TableSkinUtils.resizeColumnToFitContent(header.getTableSkin(), column, -1);
        } else {
            // rather than refer to the rect variable, we just grab
            // it from the source to prevent a small memory leak.
            Rectangle innerRect = (Rectangle) me.getSource();
            double startX = header.getTableHeaderRow().sceneToLocal(innerRect.localToScene(innerRect.getBoundsInLocal())).getMinX() + 2;
            header.dragAnchorX = me.getSceneX();
            header.columnResizingStarted(startX);
        }
    };

    private static final EventHandler&lt;MouseEvent&gt; rectMouseDragged = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        if (! header.isColumnResizingEnabled()) return;

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (me.isConsumed()) return;
        me.consume();

        header.columnResizing(column, me);
    };

    private static final EventHandler&lt;MouseEvent&gt; rectMouseReleased = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        if (! header.isColumnResizingEnabled()) return;

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (me.isConsumed()) return;
        me.consume();

        header.columnResizingComplete(column, me);
    };

    private static final EventHandler&lt;MouseEvent&gt; rectCursorChangeListener = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (header.getCursor() == null) { // If there's a cursor for the whole header, don't override it
            rect.setCursor(header.isColumnResizingEnabled() &amp;&amp; rect.isHover() &amp;&amp;
                    column.isResizable() ? Cursor.H_RESIZE : null);
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public Methods                                                          *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void dispose() {
        super.dispose();

        if (label != null) {
            label.dispose();
        }

        if (getColumns() != null) {
            getColumns().removeListener(weakColumnsListener);
        }

        for (int i = 0; i &lt; getColumnHeaders().size(); i++) {
            TableColumnHeader header = getColumnHeaders().get(i);
            header.dispose();
        }

        for (Rectangle rect : dragRects.values()) {
            if (rect != null) {
                rect.visibleProperty().unbind();
            }
        }
        dragRects.clear();
        getChildren().clear();

        changeListenerHandler.dispose();
    }

    /**
     * Returns an unmodifiable list of the {@link TableColumnHeader} instances
     * that are children of this NestedTableColumnHeader.
     * @return the unmodifiable list of TableColumnHeader of this NestedTableColumnHeader
     */
    public final ObservableList&lt;TableColumnHeader&gt; getColumnHeaders() {
        if (columnHeaders == null) {
            columnHeaders = FXCollections.&lt;TableColumnHeader&gt;observableArrayList();
            unmodifiableColumnHeaders = FXCollections.unmodifiableObservableList(columnHeaders);
        }
        return unmodifiableColumnHeaders;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        double w = getWidth() - snappedLeftInset() - snappedRightInset();
        double h = getHeight() - snappedTopInset() - snappedBottomInset();

        int labelHeight = 0;

        if (label.isVisible() &amp;&amp; getTableColumn() != null) {
            labelHeight = (int) label.prefHeight(-1);
            // label gets to span whole width and sits at top
            label.resize(w, labelHeight);
            label.relocate(snappedLeftInset(), snappedTopInset());
        }

        // children columns need to share the total available width
        double x = snappedLeftInset();
        final double height = snapSizeY(h - labelHeight);
        for (int i = 0, max = getColumnHeaders().size(); i &lt; max; i++) {
            TableColumnHeader n = getColumnHeaders().get(i);
            if (! n.isVisible()) continue;

            double prefWidth = n.prefWidth(height);

            // position the column header in the default location...
            n.resize(prefWidth, height);
            n.relocate(x, labelHeight + snappedTopInset());

//            // ...but, if there are no children of this column, we should ensure
//            // that it is resized vertically such that it goes to the very
//            // bottom of the table header row.
//            if (getTableHeaderRow() != null &amp;&amp; n.getCol().getColumns().isEmpty()) {
//                Bounds bounds = getTableHeaderRow().sceneToLocal(n.localToScene(n.getBoundsInLocal()));
//                prefHeight = getTableHeaderRow().getHeight() - bounds.getMinY();
//                n.resize(prefWidth, prefHeight);
//            }

            // shuffle along the x-axis appropriately
            x += prefWidth;

            // position drag overlay to intercept column resize requests
            Rectangle dragRect = dragRects.get(n.getTableColumn());
            if (dragRect != null) {
                dragRect.setHeight(n.getDragRectHeight());
                dragRect.relocate(x - DRAG_RECT_WIDTH / 2, snappedTopInset() + labelHeight);
            }
        }
    }

    // sum up all children columns
    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        checkState();

        double width = 0.0F;

        if (getColumns() != null) {
            for (TableColumnHeader c : getColumnHeaders()) {
                if (c.isVisible()) {
                    width += c.computePrefWidth(height);
                }
            }
        }

        return width;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        checkState();

        double height = 0.0F;

        if (getColumnHeaders() != null) {
            for (TableColumnHeader n : getColumnHeaders()) {
                height = Math.max(height, n.prefHeight(-1));
            }
        }

        double labelHeight = 0.0;
        if (label.isVisible() &amp;&amp; getTableColumn() != null) {
            labelHeight = label.prefHeight(-1);
        }

        return height + labelHeight + snappedTopInset() + snappedBottomInset();
    }

    /**
     * Creates a new TableColumnHeader instance for the given TableColumnBase instance. The general pattern for
     * implementing this method is as follows:
     *
     * &lt;ul&gt;
     *     &lt;li&gt;If the given TableColumnBase instance is null, has no child columns, or if the given TableColumnBase
     *         instance equals the TableColumnBase instance returned by calling {@link #getTableColumn()}, then it is
     *         suggested to return a {@link TableColumnHeader} instance comprised of the given column.&lt;/li&gt;
     *     &lt;li&gt;Otherwise, we can presume that the given TableColumnBase instance has child columns, and in this case
     *         it is suggested to return a {@link NestedTableColumnHeader} instance instead.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;strong&gt;Note: &lt;/strong&gt;In most circumstances this method should not be overridden, but in some circumstances it
     * makes sense (e.g. testing, or when extreme customization is desired).
     *
     * @param col the table column
     * @return A new TableColumnHeader instance.
     */
    protected TableColumnHeader createTableColumnHeader(TableColumnBase col) {
        return col == null || col.getColumns().isEmpty() || col == getTableColumn() ?
                new TableColumnHeader(col) :
                new NestedTableColumnHeader(col);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    @Override void initStyleClasses() {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        installTableColumnStyleClassListener();
    }

    @Override void setTableHeaderRow(TableHeaderRow header) {
        super.setTableHeaderRow(header);

        // it's only now that a skin might be available
        if (getTableSkin() != null) {
            changeListenerHandler.registerChangeListener(TableSkinUtils.columnResizePolicyProperty(getTableSkin()), e -&gt; updateContent());
        }

        label.setTableHeaderRow(header);

        // tell all children columns what TableHeader they belong to
        for (TableColumnHeader c : getColumnHeaders()) {
            c.setTableHeaderRow(header);
        }
    }

    @Override void setParentHeader(NestedTableColumnHeader parentHeader) {
        super.setParentHeader(parentHeader);
        label.setParentHeader(parentHeader);
    }

    ObservableList&lt;? extends TableColumnBase&gt; getColumns() {
        return columns;
    }

    void setColumns(ObservableList&lt;? extends TableColumnBase&gt; newColumns) {
        if (this.columns != null) {
            this.columns.removeListener(weakColumnsListener);
        }

        this.columns = newColumns;

        if (this.columns != null) {
            this.columns.addListener(weakColumnsListener);
        }
    }

    void updateTableColumnHeaders() {
        // watching for changes to the view columns in either table or tableColumn.
        if (getTableColumn() == null &amp;&amp; getTableSkin() != null) {
            setColumns(TableSkinUtils.getColumns(getTableSkin()));
        } else if (getTableColumn() != null) {
            setColumns(getTableColumn().getColumns());
        }

        // update the column headers...

        // iterate through all columns, unless we've got no child columns
        // any longer, in which case we should switch to a TableColumnHeader
        // instead
        if (getColumns().isEmpty()) {
            // iterate through all current headers, telling them to clean up
            for (int i = 0; i &lt; getColumnHeaders().size(); i++) {
                TableColumnHeader header = getColumnHeaders().get(i);
                header.dispose();
            }

            // switch out to be a TableColumn instead, if we have a parent header
            NestedTableColumnHeader parentHeader = getParentHeader();
            if (parentHeader != null) {
                List&lt;TableColumnHeader&gt; parentColumnHeaders = parentHeader.getColumnHeaders();
                int index = parentColumnHeaders.indexOf(this);
                if (index &gt;= 0 &amp;&amp; index &lt; parentColumnHeaders.size()) {
                    parentColumnHeaders.set(index, createColumnHeader(getTableColumn()));
                }
            } else {
                // otherwise just remove all the columns
                columnHeaders.clear();
            }
        } else {
            List&lt;TableColumnHeader&gt; oldHeaders = new ArrayList&lt;&gt;(getColumnHeaders());
            List&lt;TableColumnHeader&gt; newHeaders = new ArrayList&lt;&gt;();

            for (int i = 0; i &lt; getColumns().size(); i++) {
                TableColumnBase&lt;?,?&gt; column = getColumns().get(i);
                if (column == null || ! column.isVisible()) continue;

                // check if the header already exists and reuse it
                boolean found = false;
                for (int j = 0; j &lt; oldHeaders.size(); j++) {
                    TableColumnHeader oldColumn = oldHeaders.get(j);
                    if (oldColumn.represents(column)) {
                        newHeaders.add(oldColumn);
                        found = true;
                        break;
                    }
                }

                // otherwise create a new table column header
                if (!found) {
                    newHeaders.add(createColumnHeader(column));
                }
            }

            columnHeaders.setAll(newHeaders);

            // dispose all old headers
            oldHeaders.removeAll(newHeaders);
            for (int i = 0; i &lt; oldHeaders.size(); i++) {
                oldHeaders.get(i).dispose();
            }
        }

        // update the content
        updateContent();

        // RT-33596: Do CSS now, as we are in the middle of layout pass and the headers are new Nodes w/o CSS done
        for (TableColumnHeader header : getColumnHeaders()) {
            header.applyCss();
        }
    }

    // Used to test whether this column header properly represents the given column.
    // In particular, whether it has child column headers for all child columns
    boolean represents(TableColumnBase&lt;?, ?&gt; column) {
        if (column.getColumns().isEmpty()) {
            // this column has no children, but we are in a NestedTableColumnHeader instance,
            // so the match is bad.
            return false;
        }

        if (column != getTableColumn()) {
            return false;
        }

        final int columnCount = column.getColumns().size();
        final int headerCount = getColumnHeaders().size();
        if (columnCount != headerCount) {
            return false;
        }

        for (int i = 0; i &lt; columnCount; i++) {
            // we expect the order of all children to match the order of the headers
            TableColumnBase&lt;?,?&gt; childColumn = column.getColumns().get(i);
            TableColumnHeader childHeader = getColumnHeaders().get(i);
            if (!childHeader.represents(childColumn)) {
                return false;
            }
        }
        return true;
    }

    /** {@inheritDoc} */
    @Override double getDragRectHeight() {
        return label.prefHeight(-1);
    }

    void setHeadersNeedUpdate() {
        updateColumns = true;

        // go through children columns - they should update too
        for (int i = 0; i &lt; getColumnHeaders().size(); i++) {
            TableColumnHeader header = getColumnHeaders().get(i);
            if (header instanceof NestedTableColumnHeader) {
                ((NestedTableColumnHeader)header).setHeadersNeedUpdate();
            }
        }
        requestLayout();
    }

    private void updateContent() {
        // create a temporary list so we only do addAll into the main content
        // observableArrayList once.
        final List&lt;Node&gt; content = new ArrayList&lt;Node&gt;();

        // the label is the region that sits above the children columns
        content.add(label);

        // all children columns
        content.addAll(getColumnHeaders());

        // Small transparent overlays that sit at the start and end of each
        // column to intercept user drag gestures to enable column resizing.
        if (isColumnResizingEnabled()) {
            rebuildDragRects();
            content.addAll(dragRects.values());
        }

        getChildren().setAll(content);
    }

    private void rebuildDragRects() {
        if (! isColumnResizingEnabled()) return;

        getChildren().removeAll(dragRects.values());

        for (Rectangle rect : dragRects.values()) {
            rect.visibleProperty().unbind();
        }
        dragRects.clear();

        List&lt;? extends TableColumnBase&gt; columns = getColumns();

        if (columns == null) {
            return;
        }

        boolean isConstrainedResize = false;
        TableViewSkinBase tableSkin = getTableSkin();
        Callback&lt;ResizeFeaturesBase,Boolean&gt; columnResizePolicy = TableSkinUtils.columnResizePolicyProperty(tableSkin).get();
        if (columnResizePolicy != null) {
            isConstrainedResize =
                    tableSkin instanceof TableViewSkin ? TableView.CONSTRAINED_RESIZE_POLICY.equals(columnResizePolicy) :
                    tableSkin instanceof TreeTableViewSkin ? TreeTableView.CONSTRAINED_RESIZE_POLICY.equals(columnResizePolicy) :
                    false;
        }

        // RT-32547 - don't show resize cursor when in constrained resize mode
        // and there is only one column
        if (isConstrainedResize &amp;&amp; TableSkinUtils.getVisibleLeafColumns(tableSkin).size() == 1) {
            return;
        }

        for (int col = 0; col &lt; columns.size(); col++) {
            if (isConstrainedResize &amp;&amp; col == getColumns().size() - 1) {
                break;
            }

            final TableColumnBase c = columns.get(col);
            final Rectangle rect = new Rectangle();
<A NAME="52"></A>            rect.getProperties().put(TABLE_COLUMN_KEY, c);
            rect.getProperties().put(TABLE_COLUMN_HEADER_KEY, this);
            rect.setWidth(DRAG_RECT_WIDTH);
            rect.setHeight(<FONT color="#2b60de"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#52',2,'match44-top.html#52',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getHeight() - label.getHeight());
            rect.setFill(Color.TRANSPARENT);
            rect.visibleProperty().bind(c.visibleProperty().and(c.resizableProperty()));
            rect.setOnMousePressed(rectMousePressed);
            rect.setOnMouseDragged(rectMouseDragged);
            rect.setOnMouseReleased(rectMouseReleased);
            rect.setOnMouseEntered(rectCursorChangeListener);
            rect.setOnMouseExited(rectCursorChangeListener);

            dragRects.put(c, rect);
        }
    }

    private vo</B></FONT>id checkState() {
        if (updateColumns) {
            updateTableColumnHeaders();
            updateColumns = false;
        }
    }

    private TableColumnHeader createColumnHeader(TableColumnBase col) {
        TableColumnHeader newCol = createTableColumnHeader(col);
        newCol.setTableHeaderRow(getTableHeaderRow());
        newCol.setParentHeader(this);
        return newCol;
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation: Column Resizing                                 *
     *                                                                         *
     **************************************************************************/

    private boolean isColumnResizingEnabled() {
        // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
        // to always return true (for now), as we want to support column resizing
        // everywhere
        return true;
    }

    private void columnResizingStarted(double startX) {
        setCursor(Cursor.H_RESIZE);
        columnReorderLine.setLayoutX(startX);
    }

    private void columnResizing(TableColumnBase col, MouseEvent me) {
        double draggedX = me.getSceneX() - dragAnchorX;
        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
            draggedX = -draggedX;
        }
        double delta = draggedX - lastX;
        boolean allowed = TableSkinUtils.resizeColumn(getTableSkin(), col, delta);
        if (allowed) {
            lastX = draggedX;
        }
    }

    private void columnResizingComplete(TableColumnBase col, MouseEvent me) {
        setCursor(null);
        columnReorderLine.setTranslateX(0.0F);
        columnReorderLine.setLayoutX(0.0F);
        lastX = 0.0F;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ProgressIndicatorSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.skin.Utils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.ProgressIndicator;
import javafx.scene.control.SkinBase;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.Circle;
import javafx.scene.text.Text;
import javafx.scene.text.TextBoundsType;
import javafx.scene.transform.Scale;
import javafx.util.Duration;
import javafx.css.CssMetaData;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableIntegerProperty;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.PaintConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.skin.resources.ControlResources;
import javafx.css.Styleable;

/**
 * Default skin implementation for the {@link ProgressIndicator} control.
 *
 * @see ProgressIndicator
 * @since 9
 */
public class ProgressIndicatorSkin extends SkinBase&lt;ProgressIndicator&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    // JDK-8149818: This constant should not be static, because the
    // Locale may change between instances.

    /** DONE string is just used to know the size of Done as that is the biggest text we need to allow for */
    private final String DONE = ControlResources.getString(&quot;ProgressIndicator.doneString&quot;);

    final Duration CLIPPED_DELAY = new Duration(300);
    final Duration UNCLIPPED_DELAY = new Duration(0);

    private IndeterminateSpinner spinner;
    private DeterminateIndicator determinateIndicator;
    private ProgressIndicator control;

    Animation indeterminateTransition;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ProgressIndicatorSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ProgressIndicatorSkin(ProgressIndicator control) {
        super(control);

        this.control = control;

        // register listeners
        registerChangeListener(control.indeterminateProperty(), e -&gt; initialize());
        registerChangeListener(control.progressProperty(), e -&gt; updateProgress());
        registerChangeListener(NodeHelper.treeShowingProperty(control), e -&gt; updateAnimation());
        registerChangeListener(control.sceneProperty(), e-&gt;updateAnimation());

        initialize();
        updateAnimation();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The colour of the progress segment.
     */
    private ObjectProperty&lt;Paint&gt; progressColor = new StyleableObjectProperty&lt;Paint&gt;(null) {
        @Override protected void invalidated() {
            final Paint value = get();
            if (value != null &amp;&amp; !(value instanceof Color)) {
                if (isBound()) {
                    unbind();
                }
                set(null);
                throw new IllegalArgumentException(&quot;Only Color objects are supported&quot;);
            }
            if (spinner!=null) spinner.setFillOverride(value);
            if (determinateIndicator!=null) determinateIndicator.setFillOverride(value);
        }

        @Override public Object getBean() {
            return ProgressIndicatorSkin.this;
        }

        @Override public String getName() {
            return &quot;progressColorProperty&quot;;
        }

        @Override public CssMetaData&lt;ProgressIndicator,Paint&gt; getCssMetaData() {
            return PROGRESS_COLOR;
        }
    };

    Paint getProgressColor() {
        return progressColor.get();
    }

    /**
     * The number of segments in the spinner.
     */
    private IntegerProperty indeterminateSegmentCount = new StyleableIntegerProperty(8) {
        @Override protected void invalidated() {
            if (spinner!=null) spinner.rebuild();
        }

        @Override public Object getBean() {
            return ProgressIndicatorSkin.this;
        }

        @Override public String getName() {
            return &quot;indeterminateSegmentCount&quot;;
        }

        @Override public CssMetaData&lt;ProgressIndicator,Number&gt; getCssMetaData() {
            return INDETERMINATE_SEGMENT_COUNT;
        }
    };

    /**
     * True if the progress indicator should rotate as well as animate opacity.
     */
    private final BooleanProperty spinEnabled = new StyleableBooleanProperty(false) {
        @Override protected void invalidated() {
            if (spinner!=null) spinner.setSpinEnabled(get());
        }

        @Override public CssMetaData&lt;ProgressIndicator,Boolean&gt; getCssMetaData() {
            return SPIN_ENABLED;
        }

        @Override public Object getBean() {
            return ProgressIndicatorSkin.this;
        }

        @Override public String getName() {
            return &quot;spinEnabled&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (indeterminateTransition != null) {
            indeterminateTransition.stop();
            indeterminateTransition = null;
        }

        if (spinner != null) {
            spinner = null;
        }

        control = null;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            spinner.layoutChildren();
            spinner.resizeRelocate(0, 0, w, h);
        } else if (determinateIndicator != null) {
            determinateIndicator.layoutChildren();
            determinateIndicator.resizeRelocate(0, 0, w, h);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double minWidth = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            minWidth = spinner.minWidth(-1);
        } else if (determinateIndicator != null) {
            minWidth = determinateIndicator.minWidth(-1);
        }
        return minWidth;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double minHeight = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            minHeight = spinner.minHeight(-1);
        } else if (determinateIndicator != null) {
            minHeight = determinateIndicator.minHeight(-1);
        }
        return minHeight;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefWidth = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            prefWidth = spinner.prefWidth(height);
        } else if (determinateIndicator != null) {
            prefWidth = determinateIndicator.prefWidth(height);
        }
        return prefWidth;
    }

   /** {@inheritDoc} */
   @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefHeight = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            prefHeight = spinner.prefHeight(width);
        } else if (determinateIndicator != null) {
            prefHeight = determinateIndicator.prefHeight(width);
        }
        return prefHeight;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
    }


    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    void initialize() {
        boolean isIndeterminate = control.isIndeterminate();
        if (isIndeterminate) {
            // clean up determinateIndicator
            determinateIndicator = null;

            // create spinner
            spinner = new IndeterminateSpinner(spinEnabled.get(), progressColor.get());
            getChildren().setAll(spinner);
            if (NodeHelper.isTreeShowing(control)) {
                if (indeterminateTransition != null) {
                    indeterminateTransition.play();
                }
            }
        } else {
            // clean up after spinner
            if (spinner != null) {
                if (indeterminateTransition != null) {
                    indeterminateTransition.stop();
                }
                spinner = null;
            }

            // create determinateIndicator
            determinateIndicator = new DeterminateIndicator(control, this, progressColor.get());
            getChildren().setAll(determinateIndicator);
        }
    }

    void updateProgress() {
        if (determinateIndicator != null) {
            determinateIndicator.updateProgress(control.getProgress());
        }
    }

    void createIndeterminateTimeline() {
        if (spinner != null) {
            spinner.rebuildTimeline();
        }
    }

    void pauseTimeline(boolean pause) {
        if (getSkinnable().isIndeterminate()) {
            if (indeterminateTransition == null) {
                createIndeterminateTimeline();
            }
            if (pause) {
                indeterminateTransition.pause();
            } else {
                indeterminateTransition.play();
            }
        }
    }

    void updateAnimation() {
        ProgressIndicator control = getSkinnable();
        final boolean isTreeShowing = NodeHelper.isTreeShowing(control) &amp;&amp;
                                      control.getScene() != null;
        if (indeterminateTransition != null) {
            pauseTimeline(!isTreeShowing);
        } else if (isTreeShowing) {
            createIndeterminateTimeline();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final CssMetaData&lt;ProgressIndicator,Paint&gt; PROGRESS_COLOR =
            new CssMetaData&lt;ProgressIndicator,Paint&gt;(&quot;-fx-progress-color&quot;,
                    PaintConverter.getInstance(), null) {

                @Override
                public boolean isSettable(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return skin.progressColor == null ||
                            !skin.progressColor.isBound();
                }

                @Override
                public StyleableProperty&lt;Paint&gt; getStyleableProperty(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)skin.progressColor;
                }
            };
    private static final CssMetaData&lt;ProgressIndicator,Number&gt; INDETERMINATE_SEGMENT_COUNT =
            new CssMetaData&lt;ProgressIndicator,Number&gt;(&quot;-fx-indeterminate-segment-count&quot;,
                    SizeConverter.getInstance(), 8) {

                @Override public boolean isSettable(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return skin.indeterminateSegmentCount == null ||
                            !skin.indeterminateSegmentCount.isBound();
                }

                @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.indeterminateSegmentCount;
                }
            };
    private static final CssMetaData&lt;ProgressIndicator,Boolean&gt; SPIN_ENABLED =
            new CssMetaData&lt;ProgressIndicator,Boolean&gt;(&quot;-fx-spin-enabled&quot;, BooleanConverter.getInstance(), Boolean.FALSE) {

                @Override public boolean isSettable(ProgressIndicator node) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
                    return skin.spinEnabled == null || !skin.spinEnabled.isBound();
                }

                @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(ProgressIndicator node) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
                    return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.spinEnabled;
                }
            };

    private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
    static {
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
        styleables.add(PROGRESS_COLOR);
        styleables.add(INDETERMINATE_SEGMENT_COUNT);
        styleables.add(SPIN_ENABLED);
        STYLEABLES = Collections.unmodifiableList(styleables);
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    private final class DeterminateIndicator extends Region {
        private double textGap = 2.0F;

        // only update progress text on whole percentages
        private int intProgress;

        // only update pie arc to nearest degree
        private int degProgress;
        private Text text;
        private StackPane indicator;
        private StackPane progress;
        private StackPane tick;
        private Arc arcShape;
        private Circle indicatorCircle;
        private double doneTextWidth;
        private double doneTextHeight;

        public DeterminateIndicator(ProgressIndicator control, ProgressIndicatorSkin s, Paint fillOverride) {

            getStyleClass().add(&quot;determinate-indicator&quot;);

            intProgress = (int) Math.round(control.getProgress() * 100.0) ;
            degProgress = (int) (360 * control.getProgress());

            getChildren().clear();

            text = new Text((control.getProgress() &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
            text.setTextOrigin(VPos.TOP);
            text.getStyleClass().setAll(&quot;text&quot;, &quot;percentage&quot;);

            registerChangeListener(text.fontProperty(), o -&gt; {
                doneTextWidth = Utils.computeTextWidth(text.getFont(), DONE, 0);
                doneTextHeight = Utils.computeTextHeight(text.getFont(), DONE, 0, TextBoundsType.LOGICAL_VERTICAL_CENTER);
            });

            // The circular background for the progress pie piece
            indicator = new StackPane();
            indicator.setScaleShape(false);
            indicator.setCenterShape(false);
            indicator.getStyleClass().setAll(&quot;indicator&quot;);
            indicatorCircle = new Circle();
            indicator.setShape(indicatorCircle);

            // The shape for our progress pie piece
            arcShape = new Arc();
            arcShape.setType(ArcType.ROUND);
            arcShape.setStartAngle(90.0F);

            // Our progress pie piece
            progress = new StackPane();
            progress.getStyleClass().setAll(&quot;progress&quot;);
            progress.setScaleShape(false);
            progress.setCenterShape(false);
            progress.setShape(arcShape);
            progress.getChildren().clear();
            setFillOverride(fillOverride);

            // The check mark that's drawn at 100%
            tick = new StackPane();
            tick.getStyleClass().setAll(&quot;tick&quot;);

            getChildren().setAll(indicator, progress, text, tick);
            updateProgress(control.getProgress());
        }

        private void setFillOverride(Paint fillOverride) {
            if (fillOverride instanceof Color) {
                Color c = (Color)fillOverride;
                progress.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
            } else {
                progress.setStyle(null);
            }
        }

        @Override public boolean usesMirroring() {
            // This is used instead of setting NodeOrientation,
            // allowing the Text node to inherit the current
            // orientation.
            return false;
        }

        private void updateProgress(double progress) {
            intProgress = (int) Math.round(progress * 100.0) ;
            text.setText((progress &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));

            degProgress = (int) (360 * progress);
            arcShape.setLength(-degProgress);
            requestLayout();
        }

        @Override protected void layoutChildren() {
            // Position and size the circular background
            final double left = control.snappedLeftInset();
            final double right = control.snappedRightInset();
            final double top = control.snappedTopInset();
            final double bottom = control.snappedBottomInset();

            /*
            ** use the min of width, or height, keep it a circle
            */
            final double areaW = control.getWidth() - left - right;
            final double areaH = control.getHeight() - top - bottom - textGap - doneTextHeight;
            final double radiusW = areaW / 2;
            final double radiusH = areaH / 2;
            final double radius = Math.floor(Math.min(radiusW, radiusH));
            final double centerX = snapPosition(left + radiusW);
            final double centerY = snapPosition(top + radius);

            // find radius that fits inside radius - insetsPadding
            final double iLeft = indicator.snappedLeftInset();
            final double iRight = indicator.snappedRightInset();
            final double iTop = indicator.snappedTopInset();
            final double iBottom = indicator.snappedBottomInset();
            final double progressRadius = snapSize(Math.min(
                    Math.min(radius - iLeft, radius - iRight),
                    Math.min(radius - iTop, radius - iBottom)));

            indicatorCircle.setRadius(radius);
            indicator.setLayoutX(centerX);
            indicator.setLayoutY(centerY);

            arcShape.setRadiusX(progressRadius);
            arcShape.setRadiusY(progressRadius);
            progress.setLayoutX(centerX);
            progress.setLayoutY(centerY);

            // find radius that fits inside progressRadius - progressInsets
            final double pLeft = progress.snappedLeftInset();
            final double pRight = progress.snappedRightInset();
            final double pTop = progress.snappedTopInset();
            final double pBottom = progress.snappedBottomInset();
            final double indicatorRadius = snapSize(Math.min(
                    Math.min(progressRadius - pLeft, progressRadius - pRight),
                    Math.min(progressRadius - pTop, progressRadius - pBottom)));

            // find size of spare box that fits inside indicator radius
            double squareBoxHalfWidth = Math.ceil(Math.sqrt((indicatorRadius * indicatorRadius) / 2));

            tick.setLayoutX(centerX - squareBoxHalfWidth);
            tick.setLayoutY(centerY - squareBoxHalfWidth);
            tick.resize(squareBoxHalfWidth + squareBoxHalfWidth, squareBoxHalfWidth + squareBoxHalfWidth);
            tick.setVisible(control.getProgress() &gt;= 1);

            // if the % text can't fit anywhere in the bounds then don't display it
            double textWidth = text.getLayoutBounds().getWidth();
            double textHeight = text.getLayoutBounds().getHeight();
            if (control.getWidth() &gt;= textWidth &amp;&amp; control.getHeight() &gt;= textHeight) {
                if (!text.isVisible()) text.setVisible(true);
                text.setLayoutY(snapPosition(centerY + radius + textGap));
                text.setLayoutX(snapPosition(centerX - (textWidth/2)));
            } else {
                if (text.isVisible()) text.setVisible(false);
            }
        }

        @Override protected double computePrefWidth(double height) {
            final double left = control.snappedLeftInset();
            final double right = control.snappedRightInset();
            final double iLeft = indicator.snappedLeftInset();
            final double iRight = indicator.snappedRightInset();
            final double iTop = indicator.snappedTopInset();
            final double iBottom = indicator.snappedBottomInset();
            final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
            final double pLeft = progress.snappedLeftInset();
            final double pRight = progress.snappedRightInset();
<A NAME="35"></A>            final double pTop = progress.snappedTopInset();
            final double pBottom = progress.snappedBottomInset();
            final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
            <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#35',2,'match44-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final double tLeft = tick.snappedLeftInset();
            final double tRight = tick.snappedRightInset();
            final double indicatorWidth = indicatorMax + progressMax + tLeft + tRight + progressMax + indicatorMax;
            return left + Math.max(indicatorWidth, doneTextWidth) + right;
        }

        @Override protect</B></FONT>ed double computePrefHeight(double width) {
            final double top = control.snappedTopInset();
            final double bottom = control.snappedBottomInset();
            final double iLeft = indicator.snappedLeftInset();
            final double iRight = indicator.snappedRightInset();
            final double iTop = indicator.snappedTopInset();
            final double iBottom = indicator.snappedBottomInset();
            final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
            final double pLeft = progress.snappedLeftInset();
            final double pRight = progress.snappedRightInset();
            final double pTop = progress.snappedTopInset();
            final double pBottom = progress.snappedBottomInset();
            final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
            final double tTop = tick.snappedTopInset();
            final double tBottom = tick.snappedBottomInset();
            final double indicatorHeight = indicatorMax + progressMax + tTop + tBottom + progressMax + indicatorMax;
            return top + indicatorHeight + textGap + doneTextHeight + bottom;
        }

        @Override protected double computeMaxWidth(double height) {
            return computePrefWidth(height);
        }

        @Override protected double computeMaxHeight(double width) {
            return computePrefHeight(width);
        }
    }


    private final class IndeterminateSpinner extends Region {
        private IndicatorPaths pathsG;
        private final List&lt;Double&gt; opacities = new ArrayList&lt;&gt;();
        private boolean spinEnabled = false;
        private Paint fillOverride = null;

        private IndeterminateSpinner(boolean spinEnabled, Paint fillOverride) {
            this.spinEnabled = spinEnabled;
            this.fillOverride = fillOverride;

            setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
            getStyleClass().setAll(&quot;spinner&quot;);

            pathsG = new IndicatorPaths();
            getChildren().add(pathsG);
            rebuild();

            rebuildTimeline();

        }

        public void setFillOverride(Paint fillOverride) {
            this.fillOverride = fillOverride;
            rebuild();
        }

        public void setSpinEnabled(boolean spinEnabled) {
            this.spinEnabled = spinEnabled;
            rebuildTimeline();
        }

        private void rebuildTimeline() {
            if (spinEnabled) {
                if (indeterminateTransition == null) {
                    indeterminateTransition = new Timeline();
                    indeterminateTransition.setCycleCount(Timeline.INDEFINITE);
                    indeterminateTransition.setDelay(UNCLIPPED_DELAY);
                } else {
                    indeterminateTransition.stop();
                    ((Timeline)indeterminateTransition).getKeyFrames().clear();
                }
                final ObservableList&lt;KeyFrame&gt; keyFrames = FXCollections.&lt;KeyFrame&gt;observableArrayList();

                keyFrames.add(new KeyFrame(Duration.millis(1), new KeyValue(pathsG.rotateProperty(), 360)));
                keyFrames.add(new KeyFrame(Duration.millis(3900), new KeyValue(pathsG.rotateProperty(), 0)));

                for (int i = 100; i &lt;= 3900; i += 100) {
                    keyFrames.add(new KeyFrame(Duration.millis(i), event -&gt; shiftColors()));
                }

                ((Timeline)indeterminateTransition).getKeyFrames().setAll(keyFrames);
                indeterminateTransition.playFromStart();
            } else {
                if (indeterminateTransition != null) {
                    indeterminateTransition.stop();
                    ((Timeline)indeterminateTransition).getKeyFrames().clear();
                    indeterminateTransition = null;
                }
            }
        }

        private class IndicatorPaths extends Pane {
            @Override protected double computePrefWidth(double height) {
                double w = 0;
                for(Node child: getChildren()) {
                    if (child instanceof Region) {
                        Region region = (Region)child;
                        if (region.getShape() != null) {
                            w = Math.max(w,region.getShape().getLayoutBounds().getMaxX());
                        } else {
                            w = Math.max(w,region.prefWidth(height));
                        }
                    }
                }
                return w;
            }

            @Override protected double computePrefHeight(double width) {
                double h = 0;
                for(Node child: getChildren()) {
                    if (child instanceof Region) {
                        Region region = (Region)child;
                        if (region.getShape() != null) {
                            h = Math.max(h,region.getShape().getLayoutBounds().getMaxY());
                        } else {
                            h = Math.max(h,region.prefHeight(width));
                        }
                    }
                }
                return h;
            }

            @Override protected void layoutChildren() {
                // calculate scale
                double scale = getWidth() / computePrefWidth(-1);
                for(Node child: getChildren()) {
                    if (child instanceof Region) {
                        Region region = (Region)child;
                        if (region.getShape() != null) {
                            region.resize(
                                    region.getShape().getLayoutBounds().getMaxX(),
                                    region.getShape().getLayoutBounds().getMaxY()
                            );
                            region.getTransforms().setAll(new Scale(scale,scale,0,0));
                        } else {
                            region.autosize();
                        }
                    }
                }
            }
        }

        @Override protected void layoutChildren() {
            final double w = control.getWidth() - control.snappedLeftInset() - control.snappedRightInset();
            final double h = control.getHeight() - control.snappedTopInset() - control.snappedBottomInset();
            final double prefW = pathsG.prefWidth(-1);
            final double prefH = pathsG.prefHeight(-1);
            double scaleX = w / prefW;
            double scale = scaleX;
            if ((scaleX * prefH) &gt; h) {
                scale = h / prefH;
            }
            double indicatorW = prefW * scale;
            double indicatorH = prefH * scale;
            pathsG.resizeRelocate((w - indicatorW) / 2, (h - indicatorH) / 2, indicatorW, indicatorH);
        }

        private void rebuild() {
            // update indeterminate indicator
            final int segments = indeterminateSegmentCount.get();
            opacities.clear();
            pathsG.getChildren().clear();
            final double step = 0.8/(segments-1);
            for (int i = 0; i &lt; segments; i++) {
                Region region = new Region();
                region.setScaleShape(false);
                region.setCenterShape(false);
                region.getStyleClass().addAll(&quot;segment&quot;, &quot;segment&quot; + i);
                if (fillOverride instanceof Color) {
                    Color c = (Color)fillOverride;
                    region.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
                } else {
                    region.setStyle(null);
                }
                pathsG.getChildren().add(region);
                opacities.add(Math.max(0.1, (1.0 - (step*i))));
            }
        }

        private void shiftColors() {
            if (opacities.size() &lt;= 0) return;
            final int segments = indeterminateSegmentCount.get();
            Collections.rotate(opacities, -1);
            for (int i = 0; i &lt; segments; i++) {
                pathsG.getChildren().get(i).setOpacity(opacities.get(i));
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/SliderSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import javafx.animation.Transition;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Side;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.chart.NumberAxis;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Slider;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;
import javafx.util.StringConverter;

import com.sun.javafx.scene.control.behavior.SliderBehavior;

/**
 * Default skin implementation for the {@link Slider} control.
 *
 * @see Slider
 * @since 9
 */
public class SliderSkin extends SkinBase&lt;Slider&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    /** Track if slider is vertical/horizontal and cause re layout */
//    private boolean horizontal;
    private NumberAxis tickLine = null;
    private double trackToTickGap = 2;

    private boolean showTickMarks;
    private double thumbWidth;
    private double thumbHeight;

    private double trackStart;
    private double trackLength;
    private double thumbTop;
    private double thumbLeft;
    private double preDragThumbPos;
    private Point2D dragStart; // in skin coordinates

    private StackPane thumb;
    private StackPane track;
    private boolean trackClicked = false;
//    private double visibleAmount = 16;

    private final SliderBehavior behavior;

    StringConverter&lt;Number&gt; stringConverterWrapper = new StringConverter&lt;Number&gt;() {
        Slider slider = getSkinnable();
        @Override public String toString(Number object) {
            return(object != null) ? slider.getLabelFormatter().toString(object.doubleValue()) : &quot;&quot;;
        }
        @Override public Number fromString(String string) {
            return slider.getLabelFormatter().fromString(string);
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new SliderSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public SliderSkin(Slider control) {
        super(control);

        behavior = new SliderBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        initialize();
        control.requestLayout();
        registerChangeListener(control.minProperty(), e -&gt; {
            if (showTickMarks &amp;&amp; tickLine != null) {
                tickLine.setLowerBound(control.getMin());
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.maxProperty(), e -&gt; {
            if (showTickMarks &amp;&amp; tickLine != null) {
                tickLine.setUpperBound(control.getMax());
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.valueProperty(), e -&gt; {
            // only animate thumb if the track was clicked - not if the thumb is dragged
            positionThumb(trackClicked);
        });
        registerChangeListener(control.orientationProperty(), e -&gt; {
            if (showTickMarks &amp;&amp; tickLine != null) {
                tickLine.setSide(control.getOrientation() == Orientation.VERTICAL ? Side.RIGHT : (control.getOrientation() == null) ? Side.RIGHT: Side.BOTTOM);
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.showTickMarksProperty(), e -&gt; setShowTickMarks(control.isShowTickMarks(), control.isShowTickLabels()));
        registerChangeListener(control.showTickLabelsProperty(), e -&gt; setShowTickMarks(control.isShowTickMarks(), control.isShowTickLabels()));
        registerChangeListener(control.majorTickUnitProperty(), e -&gt; {
            if (tickLine != null) {
                tickLine.setTickUnit(control.getMajorTickUnit());
                getSkinnable().requestLayout();
            }
        });
        registerChangeListener(control.minorTickCountProperty(), e -&gt; {
            if (tickLine != null) {
                tickLine.setMinorTickCount(Math.max(control.getMinorTickCount(), 0) + 1);
                getSkinnable().requestLayout();
            }
        });
        registerChangeListener(control.labelFormatterProperty(), e -&gt; {
            if (tickLine != null) {
                if (control.getLabelFormatter() == null) {
                    tickLine.setTickLabelFormatter(null);
                } else {
                    tickLine.setTickLabelFormatter(stringConverterWrapper);
                    tickLine.requestAxisLayout();
                }
            }
        });
        registerChangeListener(control.snapToTicksProperty(), e -&gt; {
            control.adjustValue(control.getValue());
        });
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        // calculate the available space
        // resize thumb to preferred size
        thumbWidth = snapSizeX(thumb.prefWidth(-1));
        thumbHeight = snapSizeY(thumb.prefHeight(-1));
        thumb.resize(thumbWidth, thumbHeight);
        // we are assuming the is common radius's for all corners on the track
        double trackRadius = track.getBackground() == null ? 0 : track.getBackground().getFills().size() &gt; 0 ?
                track.getBackground().getFills().get(0).getRadii().getTopLeftHorizontalRadius() : 0;

        if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
            double tickLineHeight =  (showTickMarks) ? tickLine.prefHeight(-1) : 0;
            double trackHeight = snapSizeY(track.prefHeight(-1));
            double trackAreaHeight = Math.max(trackHeight,thumbHeight);
            double totalHeightNeeded = trackAreaHeight  + ((showTickMarks) ? trackToTickGap+tickLineHeight : 0);
            double startY = y + ((h - totalHeightNeeded)/2); // center slider in available height vertically
            trackLength = snapSizeX(w - thumbWidth);
            trackStart = snapPositionX(x + (thumbWidth/2));
            double trackTop = (int)(startY + ((trackAreaHeight-trackHeight)/2));
            thumbTop = (int)(startY + ((trackAreaHeight-thumbHeight)/2));

            positionThumb(false);
            // layout track
            track.resizeRelocate((int)(trackStart - trackRadius),
                    trackTop ,
                    (int)(trackLength + trackRadius + trackRadius),
                    trackHeight);
            // layout tick line
            if (showTickMarks) {
                tickLine.setLayoutX(trackStart);
                tickLine.setLayoutY(trackTop+trackHeight+trackToTickGap);
                tickLine.resize(trackLength, tickLineHeight);
                tickLine.requestAxisLayout();
            } else {
                if (tickLine != null) {
                    tickLine.resize(0,0);
                    tickLine.requestAxisLayout();
                }
                tickLine = null;
            }
        } else {
            double tickLineWidth = (showTickMarks) ? tickLine.prefWidth(-1) : 0;
            double trackWidth = snapSizeX(track.prefWidth(-1));
            double trackAreaWidth = Math.max(trackWidth,thumbWidth);
            double totalWidthNeeded = trackAreaWidth  + ((showTickMarks) ? trackToTickGap+tickLineWidth : 0) ;
            double startX = x + ((w - totalWidthNeeded)/2); // center slider in available width horizontally
            trackLength = snapSizeY(h - thumbHeight);
            trackStart = snapPositionY(y + (thumbHeight/2));
            double trackLeft = (int)(startX + ((trackAreaWidth-trackWidth)/2));
            thumbLeft = (int)(startX + ((trackAreaWidth-thumbWidth)/2));

            positionThumb(false);
            // layout track
            track.resizeRelocate(trackLeft,
                    (int)(trackStart - trackRadius),
                    trackWidth,
                    (int)(trackLength + trackRadius + trackRadius));
            // layout tick line
            if (showTickMarks) {
                tickLine.setLayoutX(trackLeft+trackWidth+trackToTickGap);
                tickLine.setLayoutY(trackStart);
                tickLine.resize(tickLineWidth, trackLength);
                tickLine.requestAxisLayout();
            } else {
                if (tickLine != null) {
                    tickLine.resize(0,0);
                    tickLine.requestAxisLayout();
                }
                tickLine = null;
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            return (leftInset + minTrackLength() + thumb.minWidth(-1) + rightInset);
        } else {
            return(leftInset + thumb.prefWidth(-1) + rightInset);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            double axisHeight = showTickMarks ? (tickLine.prefHeight(-1) + trackToTickGap) : 0;
            return topInset + thumb.prefHeight(-1) + axisHeight + bottomInset;
        } else {
            return topInset + minTrackLength() + thumb.prefHeight(-1) + bottomInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            if(showTickMarks) {
                return Math.max(140, tickLine.prefWidth(-1));
            } else {
                return 140;
            }
        } else {
            double axisWidth = showTickMarks ? (tickLine.prefWidth(-1) + trackToTickGap) : 0;
            return leftInset + Math.max(thumb.prefWidth(-1), track.prefWidth(-1)) + axisWidth + rightInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            return topInset + Math.max(thumb.prefHeight(-1), track.prefHeight(-1)) +
                    ((showTickMarks) ? (trackToTickGap+tickLine.prefHeight(-1)) : 0)  + bottomInset;
        } else {
            if(showTickMarks) {
                return Math.max(140, tickLine.prefHeight(-1));
            } else {
                return 140;
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
            return Double.MAX_VALUE;
        } else {
            return getSkinnable().prefWidth(-1);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
            return getSkinnable().prefHeight(width);
        } else {
            return Double.MAX_VALUE;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void initialize() {
        thumb = new StackPane() {
            @Override
            public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
                switch (attribute) {
                    case VALUE: return getSkinnable().getValue();
                    default: return super.queryAccessibleAttribute(attribute, parameters);
                }
            }
        };
        thumb.getStyleClass().setAll(&quot;thumb&quot;);
        thumb.setAccessibleRole(AccessibleRole.THUMB);
        track = new StackPane();
        track.getStyleClass().setAll(&quot;track&quot;);
//        horizontal = getSkinnable().isVertical();

        getChildren().clear();
        getChildren().addAll(track, thumb);
        setShowTickMarks(getSkinnable().isShowTickMarks(), getSkinnable().isShowTickLabels());
        track.setOnMousePressed(me -&gt; {
            if (!thumb.isPressed()) {
                trackClicked = true;
                if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
                    behavior.trackPress(me, (me.getX() / trackLength));
                } else {
                    behavior.trackPress(me, (me.getY() / trackLength));
                }
                trackClicked = false;
            }
        });

        track.setOnMouseDragged(me -&gt; {
            if (!thumb.isPressed()) {
                if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
                    behavior.trackPress(me, (me.getX() / trackLength));
                } else {
                    behavior.trackPress(me, (me.getY() / trackLength));
                }
            }
        });

        thumb.setOnMousePressed(me -&gt; {
            behavior.thumbPressed(me, 0.0f);
            dragStart = thumb.localToParent(me.getX(), me.getY());
            preDragThumbPos = (getSkinnable().getValue() - getSkinnable().getMin()) /
                    (getSkinnable().getMax() - getSkinnable().getMin());
        });

        thumb.setOnMouseReleased(me -&gt; {
            behavior.thumbReleased(me);
        });

        thumb.setOnMouseDragged(me -&gt; {
            Point2D cur = thumb.localToParent(me.getX(), me.getY());
            double dragPos = (getSkinnable().getOrientation() == Orientation.HORIZONTAL) ?
                    cur.getX() - dragStart.getX() : -(cur.getY() - dragStart.getY());
            behavior.thumbDragged(me, preDragThumbPos + dragPos / trackLength);
        });
    }

    private void setShowTickMarks(boolean ticksVisible, boolean labelsVisible) {
        showTickMarks = (ticksVisible || labelsVisible);
        Slider slider = getSkinnable();
        if (showTickMarks) {
            if (tickLine == null) {
                tickLine = new NumberAxis();
                tickLine.setAutoRanging(false);
                tickLine.setSide(slider.getOrientation() == Orientation.VERTICAL ? Side.RIGHT : (slider.getOrientation() == null) ? Side.RIGHT: Side.BOTTOM);
                tickLine.setUpperBound(slider.getMax());
                tickLine.setLowerBound(slider.getMin());
                tickLine.setTickUnit(slider.getMajorTickUnit());
                tickLine.setTickMarkVisible(ticksVisible);
                tickLine.setTickLabelsVisible(labelsVisible);
                tickLine.setMinorTickVisible(ticksVisible);
                // add 1 to the slider minor tick count since the axis draws one
                // less minor ticks than the number given.
                tickLine.setMinorTickCount(Math.max(slider.getMinorTickCount(),0) + 1);
                if (slider.getLabelFormatter() != null) {
                    tickLine.setTickLabelFormatter(stringConverterWrapper);
                }
                getChildren().clear();
                getChildren().addAll(tickLine, track, thumb);
            } else {
                tickLine.setTickLabelsVisible(labelsVisible);
                tickLine.setTickMarkVisible(ticksVisible);
                tickLine.setMinorTickVisible(ticksVisible);
            }
        }
        else  {
            getChildren().clear();
            getChildren().addAll(track, thumb);
//            tickLine = null;
        }

        getSkinnable().requestLayout();
    }

    /**
     * Called when ever either min, max or value changes, so thumb's layoutX, Y is recomputed.
     */
    void positionThumb(final boolean animate) {
        Slider s = getSkinnable();
        if (s.getValue() &gt; s.getMax()) return;// this can happen if we are bound to something
        boolean horizontal = s.getOrientation() == Orientation.HORIZONTAL;
        final double endX = (horizontal) ? trackStart + (((trackLength * ((s.getValue() - s.getMin()) /
                (s.getMax() - s.getMin()))) - thumbWidth/2)) : thumbLeft;
        final double endY = (horizontal) ? thumbTop :
            snappedTopInset() + trackLength - (trackLength * ((s.getValue() - s.getMin()) /
                (s.getMax() - s.getMin()))); //  - thumbHeight/2

        if (animate) {
<A NAME="26"></A>            // lets animate the thumb transition
            final double startX = thumb.getLayoutX();
            final double startY = thumb.getLayoutY();
            Transition transition = <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#26',2,'match44-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Transition() {
                {
                    setCycleDuration(Duration.millis(200));
                }

                @Override protected void interpolate(double frac) {</B></FONT>
                    if (!Double.isNaN(startX)) {
                        thumb.setLayoutX(startX + frac * (endX - startX));
                    }
                    if (!Double.isNaN(startY)) {
                        thumb.setLayoutY(startY + frac * (endY - startY));
                    }
                }
            };
            transition.play();
        } else {
            thumb.setLayoutX(endX);
            thumb.setLayoutY(endY);
        }
    }

    double minTrackLength() {
        return 2*thumb.prefWidth(-1);
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
<A NAME="27"></A>            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#27',2,'match44-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }</B></FONT>
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
<A NAME="46"></A>                requestLayout();
                getSkinnable().requestLayout();
            });
            <FONT color="#92c7c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#46',2,'match44-top.html#46',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested</B></FONT>((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableHeaderRow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import java.util.*;

import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.ListChangeListener;
import javafx.collections.WeakListChangeListener;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumnBase;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;

import com.sun.javafx.scene.control.skin.resources.ControlResources;

/**
 * Region responsible for painting the entire row of column headers.
 *
 * @since 9
 * @see javafx.scene.control.TableView
 * @see TableViewSkin
 * @see javafx.scene.control.TreeTableView
 * @see TreeTableViewSkin
 */
public class TableHeaderRow extends StackPane {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/


    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    // JDK-8090129: This constant should not be static, because the
    // Locale may change between instances.
    private final String MENU_SEPARATOR =
            ControlResources.getString(&quot;TableView.nestedColumnControlMenuSeparator&quot;);

    private final VirtualFlow flow;
    final TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin;
    private Map&lt;TableColumnBase, CheckMenuItem&gt; columnMenuItems = new HashMap&lt;TableColumnBase, CheckMenuItem&gt;();
    private double scrollX;
    private double tableWidth;
    private Rectangle clip;
    private TableColumnHeader reorderingRegion;

    /**
     * This is the ghosted region representing the table column that is being
     * dragged. It moves along the x-axis but is fixed in the y-axis.
     */
    private StackPane dragHeader;
    private final Label dragHeaderLabel = new Label();

    private Region filler;

    /**
     * This is the region where the user can interact with to show/hide columns.
     * It is positioned in the top-right hand corner of the TableHeaderRow, and
     * when clicked shows a PopupMenu consisting of all leaf columns.
     */
    private Pane cornerRegion;

    /**
     * PopupMenu shown to users to allow for them to hide/show columns in the
     * table.
     */
    private ContextMenu columnPopupMenu;

    /**
     * There are two different mouse dragged event handlers in the header code.
     * Firstly, the column reordering functionality, and secondly, the column
     * resizing functionality. Because these are handled in separate classes and
     * with separate event handlers, we occasionally run into the issue where
     * both event handlers were being called, resulting in bad UX. To remove this
     * issue, we lock when the column dragging happens, and prevent resize operations
     * from taking place.
     */
    boolean columnDragLock = false;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private InvalidationListener tableWidthListener = o -&gt; updateTableWidth();

    private InvalidationListener tablePaddingListener = o -&gt; updateTableWidth();

    // This is necessary for RT-20300 (but was updated for RT-20840)
    private ListChangeListener visibleLeafColumnsListener = c -&gt; getRootHeader().setHeadersNeedUpdate();

    private final ListChangeListener tableColumnsListener = c -&gt; {
        while (c.next()) {
            updateTableColumnListeners(c.getAddedSubList(), c.getRemoved());
        }
    };

    private final InvalidationListener columnTextListener = observable -&gt; {
        TableColumnBase&lt;?,?&gt; column = (TableColumnBase&lt;?,?&gt;) ((StringProperty)observable).getBean();
        CheckMenuItem menuItem = columnMenuItems.get(column);
        if (menuItem != null) {
            menuItem.setText(getText(column.getText(), column));
        }
    };

    private final WeakInvalidationListener weakTableWidthListener =
            new WeakInvalidationListener(tableWidthListener);

    private final WeakInvalidationListener weakTablePaddingListener =
            new WeakInvalidationListener(tablePaddingListener);

    private final WeakListChangeListener weakVisibleLeafColumnsListener =
            new WeakListChangeListener(visibleLeafColumnsListener);

    private final WeakListChangeListener weakTableColumnsListener =
            new WeakListChangeListener(tableColumnsListener);

    private final WeakInvalidationListener weakColumnTextListener =
            new WeakInvalidationListener(columnTextListener);



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TableHeaderRow instance to visually represent the column
     * header area of controls such as {@link javafx.scene.control.TableView} and
     * {@link javafx.scene.control.TreeTableView}.
     *
     * @param skin The skin used by the UI control.
     */
    public TableHeaderRow(final TableViewSkinBase skin) {
        this.tableSkin = skin;
        this.flow = skin.flow;

        getStyleClass().setAll(&quot;column-header-background&quot;);

        // clip the header so it doesn't show outside of the table bounds
        clip = new Rectangle();
        clip.setSmooth(false);
        clip.heightProperty().bind(heightProperty());
        setClip(clip);

        // listen to table width to keep header in sync
        updateTableWidth();
        tableSkin.getSkinnable().widthProperty().addListener(weakTableWidthListener);
        tableSkin.getSkinnable().paddingProperty().addListener(weakTablePaddingListener);
        TableSkinUtils.getVisibleLeafColumns(skin).addListener(weakVisibleLeafColumnsListener);

        // popup menu for hiding/showing columns
        columnPopupMenu = new ContextMenu();
        updateTableColumnListeners(TableSkinUtils.getColumns(tableSkin), Collections.&lt;TableColumnBase&lt;?,?&gt;&gt;emptyList());
        TableSkinUtils.getVisibleLeafColumns(skin).addListener(weakTableColumnsListener);
        TableSkinUtils.getColumns(tableSkin).addListener(weakTableColumnsListener);

        // drag header region. Used to indicate the current column being reordered
        dragHeader = new StackPane();
        dragHeader.setVisible(false);
<A NAME="28"></A>        dragHeader.getStyleClass().setAll(&quot;column-drag-header&quot;);
        dragHeader.setManaged(false);
        dragHeader.setMouseTransparent(true);
        <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#28',2,'match44-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>dragHeader.getChildren().add(dragHeaderLabel);

        // the header lives inside a NestedTableColumnHeader
        NestedTableColumnHeader rootHeader = createRootHeader();
        setRootHeader(rootHeader);
        rootHeader.setFocusTraversable(false);
        rootHeader.setTableHeaderRow(this);

        // The 'filler' area that extends from the right-most column to the edge
        // of the tableview, or up to the 'column control' button
        filler = new Region();
        filler.getStyleClass().setAll(&quot;filler&quot;);

        // Give focus to the table when an empty area of the header row is clicked.
        // This ensures the user knows that the table has focus.
        setOnMousePressed</B></FONT>(e -&gt; {
            skin.getSkinnable().requestFocus();
        });

        // build the corner region button for showing the popup menu
        final StackPane image = new StackPane();
        image.setSnapToPixel(false);
        image.getStyleClass().setAll(&quot;show-hide-column-image&quot;);
        cornerRegion = new StackPane() {
            @Override protected void layoutChildren() {
                double imageWidth = image.snappedLeftInset() + image.snappedRightInset();
                double imageHeight = image.snappedTopInset() + image.snappedBottomInset();

                image.resize(imageWidth, imageHeight);
                positionInArea(image, 0, 0, getWidth(), getHeight() - 3,
                        0, HPos.CENTER, VPos.CENTER);
            }
        };
        cornerRegion.getStyleClass().setAll(&quot;show-hide-columns-button&quot;);
        cornerRegion.getChildren().addAll(image);

        BooleanProperty tableMenuButtonVisibleProperty = TableSkinUtils.tableMenuButtonVisibleProperty(skin);
        if (tableMenuButtonVisibleProperty != null) {
            cornerRegion.visibleProperty().bind(tableMenuButtonVisibleProperty);
        };

        cornerRegion.setOnMousePressed(me -&gt; {
            // show a popupMenu which lists all columns
            columnPopupMenu.show(cornerRegion, Side.BOTTOM, 0, 0);
            me.consume();
        });

        // the actual header
        // the region that is anchored above the vertical scrollbar
        // a 'ghost' of the header being dragged by the user to force column
        // reordering
        getChildren().addAll(filler, rootHeader, cornerRegion, dragHeader);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- reordering
    private BooleanProperty reordering = new SimpleBooleanProperty(this, &quot;reordering&quot;, false) {
        @Override protected void invalidated() {
            TableColumnHeader r = getReorderingRegion();
            if (r != null) {
                double dragHeaderHeight = r.getNestedColumnHeader() != null ?
                        r.getNestedColumnHeader().getHeight() :
                        getReorderingRegion().getHeight();

                dragHeader.resize(dragHeader.getWidth(), dragHeaderHeight);
                dragHeader.setTranslateY(getHeight() - dragHeaderHeight);
            }
            dragHeader.setVisible(isReordering());
        }
    };
    final void setReordering(boolean value) {
        this.reordering.set(value);
    }
    final boolean isReordering() {
        return reordering.get();
    }
    final BooleanProperty reorderingProperty() {
        return reordering;
    }

    // --- root header
    /*
     * The header row is actually just one NestedTableColumnHeader that spans
     * the entire width. Nested within this is the TableColumnHeader's and
     * NestedTableColumnHeader's, as necessary. This makes it nice and clean
     * to handle column reordering - we basically enforce the rule that column
     * reordering only occurs within a single NestedTableColumnHeader, and only
     * at that level.
     */
    private ReadOnlyObjectWrapper&lt;NestedTableColumnHeader&gt; rootHeader = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;rootHeader&quot;);
    private final ReadOnlyObjectProperty&lt;NestedTableColumnHeader&gt; rootHeaderProperty() {
        return rootHeader.getReadOnlyProperty();
    }
    final NestedTableColumnHeader getRootHeader() {
        return rootHeader.get();
    }
    private final void setRootHeader(NestedTableColumnHeader value) {
        rootHeader.set(value);
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        double x = scrollX;
        double headerWidth = snapSizeX(getRootHeader().prefWidth(-1));
        double prefHeight = getHeight() - snappedTopInset() - snappedBottomInset();
        double cornerWidth = snapSizeX(flow.getVbar().prefWidth(-1));

        // position the main nested header
        getRootHeader().resizeRelocate(x, snappedTopInset(), headerWidth, prefHeight);

        // position the filler region
        final Control control = tableSkin.getSkinnable();
        if (control == null) {
            return;
        }

        final BooleanProperty tableMenuButtonVisibleProperty = TableSkinUtils.tableMenuButtonVisibleProperty(tableSkin);

        final double controlInsets = control.snappedLeftInset() + control.snappedRightInset();
        double fillerWidth = tableWidth - headerWidth + filler.getInsets().getLeft() - controlInsets;
        fillerWidth -= tableMenuButtonVisibleProperty != null &amp;&amp; tableMenuButtonVisibleProperty.get() ? cornerWidth : 0;
        filler.setVisible(fillerWidth &gt; 0);
        if (fillerWidth &gt; 0) {
            filler.resizeRelocate(x + headerWidth, snappedTopInset(), fillerWidth, prefHeight);
        }

        // position the top-right rectangle (which sits above the scrollbar)
        cornerRegion.resizeRelocate(tableWidth - cornerWidth, snappedTopInset(), cornerWidth, prefHeight);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        return getRootHeader().prefWidth(height);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width) {
        return computePrefHeight(width);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        // we hardcode 24.0 here to avoid RT-37616, where the
        // entire header row would disappear when all columns were hidden.
        double headerPrefHeight = getRootHeader().prefHeight(width);
        headerPrefHeight = headerPrefHeight == 0.0 ? 24.0 : headerPrefHeight;
        return snappedTopInset() + headerPrefHeight + snappedBottomInset();
    }

    // used to be protected to allow subclasses to modify the horizontal scrolling,
    // but made private again for JDK 9
    void updateScrollX() {
        scrollX = flow.getHbar().isVisible() ? -flow.getHbar().getValue() : 0.0F;
        requestLayout();

        // Fix for RT-36392: without this call even though we call requestLayout()
        // we don't seem to ever see the layoutChildren() method above called,
        // which means the layout is not always updated to use the latest scrollX.
        layout();
    }

    // used to be protected to allow subclass to customise the width, to allow for features
    // such as row headers, but made private again for JDK 9
    private void updateTableWidth() {
        // snapping added for RT-19428
        final Control c = tableSkin.getSkinnable();
        if (c == null) {
            this.tableWidth = 0;
        } else {
            Insets insets = c.getInsets() == null ? Insets.EMPTY : c.getInsets();
            double padding = snapSizeX(insets.getLeft()) + snapSizeX(insets.getRight());
            this.tableWidth = snapSizeX(c.getWidth()) - padding;
        }

        clip.setWidth(tableWidth);
    }

    /**
     * Creates a new NestedTableColumnHeader instance. By default this method should not be overridden, but in some
     * circumstances it makes sense (e.g. testing, or when extreme customization is desired).
     *
     * @return A new NestedTableColumnHeader instance.
     */
    protected NestedTableColumnHeader createRootHeader() {
        return new NestedTableColumnHeader(null);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    TableColumnHeader getReorderingRegion() {
        return reorderingRegion;
    }

    void setReorderingColumn(TableColumnBase rc) {
        dragHeaderLabel.setText(rc == null ? &quot;&quot; : rc.getText());
    }

    void setReorderingRegion(TableColumnHeader reorderingRegion) {
        this.reorderingRegion = reorderingRegion;

        if (reorderingRegion != null) {
            dragHeader.resize(reorderingRegion.getWidth(), dragHeader.getHeight());
        }
    }

    void setDragHeaderX(double dragHeaderX) {
        dragHeader.setTranslateX(dragHeaderX);
    }

    TableColumnHeader getColumnHeaderFor(final TableColumnBase&lt;?,?&gt; col) {
        if (col == null) return null;
        List&lt;TableColumnBase&lt;?,?&gt;&gt; columnChain = new ArrayList&lt;&gt;();
        columnChain.add(col);

        TableColumnBase&lt;?,?&gt; parent = col.getParentColumn();
        while (parent != null) {
            columnChain.add(0, parent);
            parent = parent.getParentColumn();
        }

        // we now have a list from top to bottom of a nested column hierarchy,
        // and we can now navigate down to retrieve the header with ease
        TableColumnHeader currentHeader = getRootHeader();
        for (int depth = 0; depth &lt; columnChain.size(); depth++) {
            // this is the column we are looking for at this depth
            TableColumnBase&lt;?,?&gt; column = columnChain.get(depth);

            // and now we iterate through the nested table column header at this
            // level to get the header
            currentHeader = getColumnHeaderFor(column, currentHeader);
        }
        return currentHeader;
    }

    private TableColumnHeader getColumnHeaderFor(final TableColumnBase&lt;?,?&gt; col, TableColumnHeader currentHeader) {
        if (currentHeader instanceof NestedTableColumnHeader) {
            List&lt;TableColumnHeader&gt; headers = ((NestedTableColumnHeader)currentHeader).getColumnHeaders();

            for (int i = 0; i &lt; headers.size(); i++) {
                TableColumnHeader header = headers.get(i);
                if (header.getTableColumn() == col) {
                    return header;
                }
            }
        }

        return null;
    }

    private void updateTableColumnListeners(List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; added, List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; removed) {
        // remove binding from all removed items
        for (TableColumnBase tc : removed) {
            remove(tc);
        }

        rebuildColumnMenu();
    }

    private void remove(TableColumnBase&lt;?,?&gt; col) {
        if (col == null) return;

        CheckMenuItem item = columnMenuItems.remove(col);
        if (item != null) {
            col.textProperty().removeListener(weakColumnTextListener);
            item.selectedProperty().unbindBidirectional(col.visibleProperty());

            columnPopupMenu.getItems().remove(item);
        }

        if (! col.getColumns().isEmpty()) {
            for (TableColumnBase tc : col.getColumns()) {
                remove(tc);
            }
        }
    }

    private void rebuildColumnMenu() {
        columnPopupMenu.getItems().clear();

        for (TableColumnBase&lt;?,?&gt; col : TableSkinUtils.getColumns(tableSkin)) {
            // we only create menu items for leaf columns, visible or not
            if (col.getColumns().isEmpty()) {
                createMenuItem(col);
            } else {
                List&lt;TableColumnBase&lt;?,?&gt;&gt; leafColumns = getLeafColumns(col);
                for (TableColumnBase&lt;?,?&gt; _col : leafColumns) {
                    createMenuItem(_col);
                }
            }
        }
    }

    private List&lt;TableColumnBase&lt;?,?&gt;&gt; getLeafColumns(TableColumnBase&lt;?,?&gt; col) {
        List&lt;TableColumnBase&lt;?,?&gt;&gt; leafColumns = new ArrayList&lt;&gt;();

        for (TableColumnBase&lt;?,?&gt; _col : col.getColumns()) {
            if (_col.getColumns().isEmpty()) {
                leafColumns.add(_col);
            } else {
                leafColumns.addAll(getLeafColumns(_col));
            }
        }

        return leafColumns;
    }

    private void createMenuItem(TableColumnBase&lt;?,?&gt; col) {
        CheckMenuItem item = columnMenuItems.get(col);
        if (item == null) {
            item = new CheckMenuItem();
            columnMenuItems.put(col, item);
        }

        // bind column text and isVisible so that the menu item is always correct
        item.setText(getText(col.getText(), col));
        col.textProperty().addListener(weakColumnTextListener);

        // ideally we would have API to observe the binding status of a property,
        // but for now that doesn't exist, so we set this once and then forget
        item.setDisable(col.visibleProperty().isBound());

        // fake bidrectional binding (a real one was used here but resulted in JBS-8136468)
        item.setSelected(col.isVisible());
        final CheckMenuItem _item = item;
        item.selectedProperty().addListener(o -&gt; {
            if (col.visibleProperty().isBound()) return;
            col.setVisible(_item.isSelected());
        });
        col.visibleProperty().addListener(o -&gt; _item.setSelected(col.isVisible()));

        columnPopupMenu.getItems().add(item);
    }

    /*
     * Function used for building the strings in the popup menu
     */
    private String getText(String text, TableColumnBase col) {
        String s = text;
        TableColumnBase parentCol = col.getParentColumn();
        while (parentCol != null) {
            if (isColumnVisibleInHeader(parentCol, TableSkinUtils.getColumns(tableSkin))) {
                s = parentCol.getText() + MENU_SEPARATOR + s;
            }
            parentCol = parentCol.getParentColumn();
        }
        return s;
    }

    // We need to show strings properly. If a column has a parent column which is
    // not inserted into the TableView columns list, it effectively doesn't have
    // a parent column from the users perspective. As such, we shouldn't include
    // the parent column text in the menu. Fixes RT-14482.
    private boolean isColumnVisibleInHeader(TableColumnBase col, List columns) {
        if (col == null) return false;

        for (int i = 0; i &lt; columns.size(); i++) {
            TableColumnBase column = (TableColumnBase) columns.get(i);
            if (col.equals(column)) return true;

            if (! column.getColumns().isEmpty()) {
                boolean isVisible = isColumnVisibleInHeader(col, column.getColumns());
                if (isVisible) return true;
            }
        }

        return false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextAreaSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.geometry.VerticalDirection;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import javafx.util.Duration;

import java.util.List;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;

/**
 * Default skin implementation for the {@link TextArea} control.
 *
 * @see TextArea
 * @since 9
 */
public class TextAreaSkin extends TextInputControlSkin&lt;TextArea&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /** A shared helper object, used only by downLines(). */
    private static final Path tmpCaretPath = new Path();



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    final private TextArea textArea;

    // *** NOTE: Multiple node mode is not yet fully implemented *** //
    private static final boolean USE_MULTIPLE_NODES = false;

    private final TextAreaBehavior behavior;

    private double computedMinWidth = Double.NEGATIVE_INFINITY;
    private double computedMinHeight = Double.NEGATIVE_INFINITY;
    private double computedPrefWidth = Double.NEGATIVE_INFINITY;
    private double computedPrefHeight = Double.NEGATIVE_INFINITY;
    private double widthForComputedPrefHeight = Double.NEGATIVE_INFINITY;
    private double characterWidth;
    private double lineHeight;

    private ContentView contentView = new ContentView();
    private Group paragraphNodes = new Group();

    private Text promptNode;
    private ObservableBooleanValue usePromptText;

    private ObservableIntegerValue caretPosition;
    private Group selectionHighlightGroup = new Group();

    private ScrollPane scrollPane;
    private Bounds oldViewportBounds;

    private VerticalDirection scrollDirection = null;

    private Path characterBoundingPath = new Path();

    private Timeline scrollSelectionTimeline = new Timeline();
    private EventHandler&lt;ActionEvent&gt; scrollSelectionHandler = event -&gt; {
        switch (scrollDirection) {
            case UP: {
                // TODO Get previous offset
                break;
            }

            case DOWN: {
                // TODO Get next offset
                break;
            }
        }
    };

    private double pressX, pressY; // For dragging handles on embedded
    private boolean handlePressed;

    /**
     * Remembers horizontal position when traversing up / down.
     */
    double targetCaretX = -1;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextAreaSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextAreaSkin(final TextArea control) {
        super(control);

        // install default input map for the text area control
        this.behavior = new TextAreaBehavior(control);
        this.behavior.setTextAreaSkin(this);
//        control.setInputMap(behavior.getInputMap());

        this.textArea = control;

        caretPosition = new IntegerBinding() {
            { bind(control.caretPositionProperty()); }
            @Override protected int computeValue() {
                return control.getCaretPosition();
            }
        };
        caretPosition.addListener((observable, oldValue, newValue) -&gt; {
            targetCaretX = -1;
            if (control.getWidth() &gt; 0) {
                setForwardBias(true);
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
            }
        });

//        setManaged(false);

        // Initialize content
        scrollPane = new ScrollPane();
        scrollPane.setFitToWidth(control.isWrapText());
        scrollPane.setContent(contentView);
        getChildren().add(scrollPane);

        getSkinnable().addEventFilter(ScrollEvent.ANY, event -&gt; {
            if (event.isDirect() &amp;&amp; handlePressed) {
                event.consume();
            }
        });

        // Add selection
        selectionHighlightGroup.setManaged(false);
        selectionHighlightGroup.setVisible(false);
        contentView.getChildren().add(selectionHighlightGroup);

        // Add content view
        paragraphNodes.setManaged(false);
        contentView.getChildren().add(paragraphNodes);

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());
        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        contentView.getChildren().add(caretPath);

        if (SHOW_HANDLES) {
            contentView.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
        }

        scrollPane.hvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollLeft(newValue.doubleValue() * getScrollLeftMax());
        });

        scrollPane.vvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollTop(newValue.doubleValue() * getScrollTopMax());
        });

        // Initialize the scroll selection timeline
        scrollSelectionTimeline.setCycleCount(Timeline.INDEFINITE);
        List&lt;KeyFrame&gt; scrollSelectionFrames = scrollSelectionTimeline.getKeyFrames();
        scrollSelectionFrames.clear();
        scrollSelectionFrames.add(new KeyFrame(Duration.millis(350), scrollSelectionHandler));

        // Add initial text content
        for (int i = 0, n = USE_MULTIPLE_NODES ? control.getParagraphs().size() : 1; i &lt; n; i++) {
            CharSequence paragraph = (n == 1) ? control.textProperty().getValueSafe() : control.getParagraphs().get(i);
            addParagraphNode(i, paragraph.toString());
        }

        control.selectionProperty().addListener((observable, oldValue, newValue) -&gt; {
            // TODO Why do we need two calls here?
            control.requestLayout();
            contentView.requestLayout();
        });

        control.wrapTextProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            scrollPane.setFitToWidth(newValue);
        });

        control.prefColumnCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportWidth();
        });

        control.prefRowCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportHeight();
        });

        updateFontMetrics();
        fontMetrics.addListener(valueModel -&gt; {
            updateFontMetrics();
        });

        contentView.paddingProperty().addListener(valueModel -&gt; {
            updatePrefViewportWidth();
            updatePrefViewportHeight();
        });

        scrollPane.viewportBoundsProperty().addListener(valueModel -&gt; {
            if (scrollPane.getViewportBounds() != null) {
                // ScrollPane creates a new Bounds instance for each
                // layout pass, so we need to check if the width/height
                // have really changed to avoid infinite layout requests.
                Bounds newViewportBounds = scrollPane.getViewportBounds();
                if (oldViewportBounds == null ||
                    oldViewportBounds.getWidth() != newViewportBounds.getWidth() ||
                    oldViewportBounds.getHeight() != newViewportBounds.getHeight()) {

                    invalidateMetrics();
                    oldViewportBounds = newViewportBounds;
                    contentView.requestLayout();
                }
            }
        });

        control.scrollTopProperty().addListener((observable, oldValue, newValue) -&gt; {
            double vValue = (newValue.doubleValue() &lt; getScrollTopMax())
                               ? (newValue.doubleValue() / getScrollTopMax()) : 1.0;
            scrollPane.setVvalue(vValue);
        });

        control.scrollLeftProperty().addListener((observable, oldValue, newValue) -&gt; {
            double hValue = (newValue.doubleValue() &lt; getScrollLeftMax())
                               ? (newValue.doubleValue() / getScrollLeftMax()) : 1.0;
            scrollPane.setHvalue(hValue);
        });

        if (USE_MULTIPLE_NODES) {
            control.getParagraphs().addListener((ListChangeListener.Change&lt;? extends CharSequence&gt; change) -&gt; {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends CharSequence&gt; removed = change.getRemoved();
                    if (from &lt; to) {

                        if (removed.isEmpty()) {
                            // This is an add
                            for (int i = from, n = to; i &lt; n; i++) {
                                addParagraphNode(i, change.getList().get(i).toString());
                            }
                        } else {
                            // This is an update
                            for (int i = from, n = to; i &lt; n; i++) {
                                Node node = paragraphNodes.getChildren().get(i);
                                Text paragraphNode = (Text) node;
                                paragraphNode.setText(change.getList().get(i).toString());
                            }
                        }
                    } else {
                        // This is a remove
                        paragraphNodes.getChildren().subList(from, from + removed.size()).clear();
                    }
                }
            });
        } else {
            control.textProperty().addListener(observable -&gt; {
                invalidateMetrics();
                ((Text)paragraphNodes.getChildren().get(0)).setText(control.textProperty().getValueSafe());
                contentView.requestLayout();
            });
        }

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(), control.promptTextProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty());
            }
        };

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        updateHighlightFill();
        updatePrefViewportWidth();
        updatePrefViewportHeight();
        if (control.isFocused()) setCaretAnimating(true);

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                handlePressed = true;
                e.consume();
            };

            EventHandler&lt;MouseEvent&gt; handleReleaseHandler = event -&gt; {
                handlePressed = false;
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseReleased(handleReleaseHandler);
            selectionHandle1.setOnMouseReleased(handleReleaseHandler);
            selectionHandle2.setOnMouseReleased(handleReleaseHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + caretHandle.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle1.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY + selectionHandle1.getHeight() + 5);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &lt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &gt;= control1.getAnchor()) {
                        pos = control1.getAnchor();
                    }
                }
                positionCaret(hit, true);
                e.consume();
            });

            selectionHandle2.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle2.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &gt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &lt;= control1.getAnchor() + 1) {
                        pos = Math.min(control1.getAnchor() + 2, control1.getLength());
                    }
                    positionCaret(hit, true);
                }
                e.consume();
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void invalidateMetrics() {
        computedMinWidth = Double.NEGATIVE_INFINITY;
        computedMinHeight = Double.NEGATIVE_INFINITY;
        computedPrefWidth = Double.NEGATIVE_INFINITY;
        computedPrefHeight = Double.NEGATIVE_INFINITY;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        scrollPane.resizeRelocate(contentX, contentY, contentWidth, contentHeight);
    }

    /** {@inheritDoc} */
    @Override protected void updateHighlightFill() {
        for (Node node : selectionHighlightGroup.getChildren()) {
            Path selectionHighlightPath = (Path)node;
            selectionHighlightPath.setFill(highlightFillProperty().get());
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Text textNode = getTextNode();
        Point2D p = new Point2D(x - textNode.getLayoutX(), y - getTextTranslateY());
        HitInfo hit = textNode.hitTest(translateCaretPosition(p));
        return hit;
    };

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case LINE:
                switch (dir) {
                    case UP:
                        previousLine(select);
                        break;
                    case DOWN:
                        nextLine(select);
                        break;
                    case BEGINNING:
                        lineStart(select, select &amp;&amp; isMac());
                        break;
                    case END:
                        lineEnd(select, select &amp;&amp; isMac());
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PAGE:
                switch (dir) {
                    case UP:
                        previousPage(select);
                        break;
                    case DOWN:
                        nextPage(select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PARAGRAPH:
                switch (dir) {
                    case UP:
                        paragraphStart(true, select);
                        break;
                    case DOWN:
                        paragraphEnd(true, select);
                        break;
                    case BEGINNING:
                        paragraphStart(false, select);
                        break;
                    case END:
                        paragraphEnd(false, select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
            positionCaret(hit.getInsertionIndex(), leading, false, false);
        } else {
            // We're at beginning or end of line. Try moving up / down.
            int dot = textArea.getCaretPosition();
            targetCaretX = moveRight ? 0 : Double.MAX_VALUE;
            // TODO: Use Bidi sniffing instead of assuming right means forward here?
            downLines(moveRight ? 1 : -1, false, false);
            targetCaretX = -1;
            if (dot == textArea.getCaretPosition()) {
                if (moveRight) {
                    textArea.forward();
                } else {
                    textArea.backward();
                }
            }
        }
    }

    private void downLines(int nLines, boolean select, boolean extendSelection) {
        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();

        // The middle y coordinate of the the line we want to go to.
        double targetLineMidY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2 + nLines * lineHeight;
        if (targetLineMidY &lt; 0) {
            targetLineMidY = 0;
        }

        // The target x for the caret. This may have been set during a
        // previous call.
        double x = (targetCaretX &gt;= 0) ? targetCaretX : (caretBounds.getMaxX());

        // Find a text position for the target x,y.
        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));
        int pos = hit.getCharIndex();

        // Save the old pos temporarily while testing the new one.
        int oldPos = textNode.getCaretPosition();
        boolean oldBias = textNode.isCaretBias();
        textNode.setCaretBias(hit.isLeading());
        textNode.setCaretPosition(pos);
        tmpCaretPath.getElements().clear();
        tmpCaretPath.getElements().addAll(textNode.getCaretShape());
        tmpCaretPath.setLayoutX(textNode.getLayoutX());
        tmpCaretPath.setLayoutY(textNode.getLayoutY());
        Bounds tmpCaretBounds = tmpCaretPath.getLayoutBounds();
        // The y for the middle of the row we found.
        double foundLineMidY = (tmpCaretBounds.getMinY() + tmpCaretBounds.getMaxY()) / 2;
        textNode.setCaretBias(oldBias);
        textNode.setCaretPosition(oldPos);

        // Test if the found line is in the correct direction and move
        // the caret.
        if (nLines == 0 ||
                (nLines &gt; 0 &amp;&amp; foundLineMidY &gt; caretBounds.getMaxY()) ||
                (nLines &lt; 0 &amp;&amp; foundLineMidY &lt; caretBounds.getMinY())) {

            positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, extendSelection);
            targetCaretX = x;
        }
    }

    private void previousLine(boolean select) {
        downLines(-1, select, false);
    }

    private void nextLine(boolean select) {
        downLines(1, select, false);
    }

    private void previousPage(boolean select) {
        downLines(-(int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void nextPage(boolean select) {
        downLines((int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void lineStart(boolean select, boolean extendSelection) {
        targetCaretX = 0;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }

    private void lineEnd(boolean select, boolean extendSelection) {
        targetCaretX = Double.MAX_VALUE;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }


    private void paragraphStart(boolean previousIfAtStart, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();

        if (pos &gt; 0) {
            if (previousIfAtStart &amp;&amp; text.codePointAt(pos-1) == 0x0a) {
                // We are at the beginning of a paragraph.
                // Back up to the previous paragraph.
                pos--;
            }
            // Back up to the beginning of this paragraph
            while (pos &gt; 0 &amp;&amp; text.codePointAt(pos-1) != 0x0a) {
                pos--;
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
                setForwardBias(true);
            }
        }
    }

    private void paragraphEnd(boolean goPastInitialNewline, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();
        int len = text.length();
        boolean wentPastInitialNewline = false;
        boolean goPastTrailingNewline = isWindows();

        if (pos &lt; len) {
            if (goPastInitialNewline &amp;&amp; text.codePointAt(pos) == 0x0a) {
                // We are at the end of a paragraph, start by moving to the
                // next paragraph.
                pos++;
                wentPastInitialNewline = true;
            }
            if (!(goPastTrailingNewline &amp;&amp; wentPastInitialNewline)) {
                // Go to the end of this paragraph
                while (pos &lt; len &amp;&amp; text.codePointAt(pos) != 0x0a) {
                    pos++;
                }
                if (goPastTrailingNewline &amp;&amp; pos &lt; len) {
                    // We are at the end of a paragraph, finish by moving to
                    // the beginning of the next paragraph (Windows behavior).
                    pos++;
                }
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.underlineShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.rangeShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        int pStart = 0;
        Text paragraphNode = null;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                paragraphNode = p;
                break;
            }
            pStart = pEnd + 1;
        }

        if (paragraphNode != null) {
            for (Node node : nodes) {
                node.setLayoutX(paragraphNode.getLayoutX());
                node.setLayoutY(paragraphNode.getLayoutY());
            }
        }
        contentView.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        contentView.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        contentView.layoutChildren();
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - contentView.snappedLeftInset() - getSkinnable().getScrollLeft()),
                    Math.max(0, p.getY() - contentView.snappedTopInset() - getSkinnable().getScrollTop()));
        }
        return p;
    }

    // Public for FXVKSkin
    /**
     * Gets the {@code Bounds} of the caret of the skinned {@code TextArea}.
     * @return the {@code Bounds} of the caret shape, relative to the {@code TextArea}.
     */
    public Bounds getCaretBounds() {
        return getSkinnable().sceneToLocal(caretPath.localToScene(caretPath.getBoundsInLocal()));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case LINE_FOR_OFFSET:
            case LINE_START:
            case LINE_END:
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                Text text = getTextNode();
                return text.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }

        // TODO Unregister listeners on text editor, paragraph list
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Text firstParagraph = (Text) paragraphNodes.getChildren().get(0);
        return Utils.getAscent(getSkinnable().getFont(), firstParagraph.getBoundsType())
                + contentView.snappedTopInset() + textArea.snappedTopInset();
    }

    private char getCharacter(int index) {
        int n = paragraphNodes.getChildren().size();

        int paragraphIndex = 0;
        int offset = index;

        String paragraph = null;
        while (paragraphIndex &lt; n) {
            Text paragraphNode = (Text)paragraphNodes.getChildren().get(paragraphIndex);
            paragraph = paragraphNode.getText();
            int count = paragraph.length() + 1;

            if (offset &lt; count) {
                break;
            }

            offset -= count;
            paragraphIndex++;
        }

        return offset == paragraph.length() ? '\n' : paragraph.charAt(offset);
    }

    /** {@inheritDoc} */
    @Override protected int getInsertionPoint(double x, double y) {
        TextArea textArea = getSkinnable();

        int n = paragraphNodes.getChildren().size();
        int index = -1;

        if (n &gt; 0) {
            if (y &lt; contentView.snappedTopInset()) {
                // Select the character at x in the first row
                Text paragraphNode = (Text)paragraphNodes.getChildren().get(0);
                index = getNextInsertionPoint(paragraphNode, x, -1, VerticalDirection.DOWN);
            } else if (y &gt; contentView.snappedTopInset() + contentView.getHeight()) {
                // Select the character at x in the last row
                int lastParagraphIndex = n - 1;
                Text lastParagraphView = (Text)paragraphNodes.getChildren().get(lastParagraphIndex);

                index = getNextInsertionPoint(lastParagraphView, x, -1, VerticalDirection.UP)
                        + (textArea.getLength() - lastParagraphView.getText().length());
            } else {
                // Select the character at x in the row at y
                int paragraphOffset = 0;
                for (int i = 0; i &lt; n; i++) {
                    Text paragraphNode = (Text)paragraphNodes.getChildren().get(i);

                    Bounds bounds = paragraphNode.getBoundsInLocal();
                    double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();
                    if (y &gt;= paragraphViewY
                            &amp;&amp; y &lt; paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {
                        index = getInsertionPoint(paragraphNode,
                                x - paragraphNode.getLayoutX(),
                                y - paragraphNode.getLayoutY()) + paragraphOffset;
                        break;
                    }

                    paragraphOffset += paragraphNode.getText().length() + 1;
                }
            }
        }

        return index;
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, false);
    }

    private void positionCaret(int pos, boolean leading, boolean select, boolean extendSelection) {
        boolean isNewLine =
                (pos &gt; 0 &amp;&amp;
                        pos &lt;= getSkinnable().getLength() &amp;&amp;
                        getSkinnable().getText().codePointAt(pos-1) == 0x0a);

        // special handling for a new line
        if (!leading &amp;&amp; isNewLine) {
            leading = true;
            pos -= 1;
        }

        if (select) {
            if (extendSelection) {
                getSkinnable().extendSelection(pos);
            } else {
                getSkinnable().selectPositionCaret(pos);
            }
        } else {
            getSkinnable().positionCaret(pos);
        }

        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        TextArea textArea = getSkinnable();

        int paragraphIndex = paragraphNodes.getChildren().size();
        int paragraphOffset = textArea.getLength() + 1;

        Text paragraphNode = null;
        do {
            paragraphNode = (Text)paragraphNodes.getChildren().get(--paragraphIndex);
            paragraphOffset -= paragraphNode.getText().length() + 1;
        } while (index &lt; paragraphOffset);

        int characterIndex = index - paragraphOffset;
        boolean terminator = false;

        if (characterIndex == paragraphNode.getText().length()) {
            characterIndex--;
            terminator = true;
        }

        characterBoundingPath.getElements().clear();
        characterBoundingPath.getElements().addAll(paragraphNode.rangeShape(characterIndex, characterIndex + 1));
        characterBoundingPath.setLayoutX(paragraphNode.getLayoutX());
        characterBoundingPath.setLayoutY(paragraphNode.getLayoutY());

        Bounds bounds = characterBoundingPath.getBoundsInLocal();

        double x = bounds.getMinX() + paragraphNode.getLayoutX() - textArea.getScrollLeft();
        double y = bounds.getMinY() + paragraphNode.getLayoutY() - textArea.getScrollTop();

        // Sometimes the bounds is empty, in which case we must ignore the width/height
        double width = bounds.isEmpty() ? 0 : bounds.getWidth();
        double height = bounds.isEmpty() ? 0 : bounds.getHeight();

        if (terminator) {
            x += width;
            width = 0;
        }

        return new Rectangle2D(x, y, width, height);
    }

    /** {@inheritDoc} */
    @Override protected void scrollCharacterToVisible(final int index) {
        // TODO We queue a callback because when characters are added or
        // removed the bounds are not immediately updated; is this really
        // necessary?

        Platform.runLater(() -&gt; {
            if (getSkinnable().getLength() == 0) {
                return;
            }
            Rectangle2D characterBounds = getCharacterBounds(index);
            scrollBoundsToVisible(characterBounds);
        });
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextAreaBehavior getBehavior() {
        return behavior;
    }

    private void createPromptNode() {
        if (promptNode == null &amp;&amp; usePromptText.get()) {
            promptNode = new Text();
            contentView.getChildren().add(0, promptNode);
            promptNode.setManaged(false);
            promptNode.getStyleClass().add(&quot;text&quot;);
            promptNode.visibleProperty().bind(usePromptText);
            promptNode.fontProperty().bind(getSkinnable().fontProperty());
            promptNode.textProperty().bind(getSkinnable().promptTextProperty());
            promptNode.fillProperty().bind(promptTextFillProperty());
        }
    }

    private void addParagraphNode(int i, String string) {
        final TextArea textArea = getSkinnable();
        Text paragraphNode = new Text(string);
        paragraphNode.setTextOrigin(VPos.TOP);
        paragraphNode.setManaged(false);
        paragraphNode.getStyleClass().add(&quot;text&quot;);
        paragraphNode.boundsTypeProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updateFontMetrics();
        });
        paragraphNodes.getChildren().add(i, paragraphNode);

        paragraphNode.fontProperty().bind(textArea.fontProperty());
        paragraphNode.fillProperty().bind(textFillProperty());
        paragraphNode.selectionFillProperty().bind(highlightTextFillProperty());
    }

    private double getScrollTopMax() {
        return Math.max(0, contentView.getHeight() - scrollPane.getViewportBounds().getHeight());
    }

    private double getScrollLeftMax() {
        return Math.max(0, contentView.getWidth() - scrollPane.getViewportBounds().getWidth());
    }

    private int getInsertionPoint(Text paragraphNode, double x, double y) {
        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));
        return hitInfo.getInsertionIndex();
    }

    private int getNextInsertionPoint(Text paragraphNode, double x, int from,
        VerticalDirection scrollDirection) {
        // TODO
        return 0;
    }

    private void scrollCaretToVisible() {
        TextArea textArea = getSkinnable();
        Bounds bounds = caretPath.getLayoutBounds();
        double x = bounds.getMinX() - textArea.getScrollLeft();
        double y = bounds.getMinY() - textArea.getScrollTop();
        double w = bounds.getWidth();
        double h = bounds.getHeight();

        if (SHOW_HANDLES) {
            if (caretHandle.isVisible()) {
                h += caretHandle.getHeight();
            } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
                x -= selectionHandle1.getWidth() / 2;
                y -= selectionHandle1.getHeight();
                w += selectionHandle1.getWidth() / 2 + selectionHandle2.getWidth() / 2;
                h += selectionHandle1.getHeight() + selectionHandle2.getHeight();
            }
        }

        if (w &gt; 0 &amp;&amp; h &gt; 0) {
            scrollBoundsToVisible(new Rectangle2D(x, y, w, h));
        }
    }

    private void scrollBoundsToVisible(Rectangle2D bounds) {
        TextArea textArea = getSkinnable();
        Bounds viewportBounds = scrollPane.getViewportBounds();

        double viewportWidth = viewportBounds.getWidth();
        double viewportHeight = viewportBounds.getHeight();
        double scrollTop = textArea.getScrollTop();
        double scrollLeft = textArea.getScrollLeft();
        double slop = 6.0;

        if (bounds.getMinY() &lt; 0) {
            double y = scrollTop + bounds.getMinY();
            if (y &lt;= contentView.snappedTopInset()) {
                y = 0;
            }
            textArea.setScrollTop(y);
        } else if (contentView.snappedTopInset() + bounds.getMaxY() &gt; viewportHeight) {
            double y = scrollTop + contentView.snappedTopInset() + bounds.getMaxY() - viewportHeight;
            if (y &gt;= getScrollTopMax() - contentView.snappedBottomInset()) {
                y = getScrollTopMax();
            }
            textArea.setScrollTop(y);
        }


        if (bounds.getMinX() &lt; 0) {
            double x = scrollLeft + bounds.getMinX() - slop;
            if (x &lt;= contentView.snappedLeftInset() + slop) {
                x = 0;
            }
            textArea.setScrollLeft(x);
        } else if (contentView.snappedLeftInset() + bounds.getMaxX() &gt; viewportWidth) {
            double x = scrollLeft + contentView.snappedLeftInset() + bounds.getMaxX() - viewportWidth + slop;
            if (x &gt;= getScrollLeftMax() - contentView.snappedRightInset() - slop) {
                x = getScrollLeftMax();
            }
            textArea.setScrollLeft(x);
        }
    }

    private void updatePrefViewportWidth() {
        int columnCount = getSkinnable().getPrefColumnCount();
        scrollPane.setPrefViewportWidth(columnCount * characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
        scrollPane.setMinViewportWidth(characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
    }

    private void updatePrefViewportHeight() {
        int rowCount = getSkinnable().getPrefRowCount();
        scrollPane.setPrefViewportHeight(rowCount * lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
        scrollPane.setMinViewportHeight(lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
    }

    private void updateFontMetrics() {
        Text firstParagraph = (Text)paragraphNodes.getChildren().get(0);
        lineHeight = Utils.getLineHeight(getSkinnable().getFont(), firstParagraph.getBoundsType());
        characterWidth = fontMetrics.get().getCharWidth('W');
    }

    private double getTextTranslateX() {
        return contentView.snappedLeftInset();
    }

    private double getTextTranslateY() {
        return contentView.snappedTopInset();
    }

    private double getTextLeft() {
        return 0;
    }

    private Point2D translateCaretPosition(Point2D p) {
        return p;
    }

    private Text getTextNode() {
        if (USE_MULTIPLE_NODES) {
            throw new IllegalArgumentException(&quot;Multiple node traversal is not yet implemented.&quot;);
        }
        return (Text)paragraphNodes.getChildren().get(0);
    }

    private void updateTextNodeCaretPos(int pos) {
        Text textNode = getTextNode();
        if (isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }



    /**************************************************************************
     *
     * Support classes
     *
     **************************************************************************/

    private class ContentView extends Region {
        {
<A NAME="17"></A>            getStyleClass().add(&quot;content&quot;);

            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#17',2,'match44-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>behavior.mousePressed(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                behavior.mouseReleased(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_DRAGGED, event -&gt; {
                behavior.mouseDragged(event);
                event.consume();
            });
        }</B></FONT>

        @Override protected ObservableList&lt;Node&gt; getChildren() {
            return super.getChildren();
        }

        @Override public Orientation getContentBias() {
            return Orientation.HORIZONTAL;
        }

        @Override protected double computePrefWidth(double height) {
            if (computedPrefWidth &lt; 0) {
                double prefWidth = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefWidth = Math.max(prefWidth,
                            Utils.computeTextWidth(paragraphNode.getFont(),
                                    paragraphNode.getText(), 0));
                }

                prefWidth += snappedLeftInset() + snappedRightInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefWidth = Math.max(prefWidth, (viewPortBounds != null) ? viewPortBounds.getWidth() : 0);
            }
            return computedPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            if (width != widthForComputedPrefHeight) {
                invalidateMetrics();
                widthForComputedPrefHeight = width;
            }

            if (computedPrefHeight &lt; 0) {
                double wrappingWidth;
                if (width == -1) {
                    wrappingWidth = 0;
                } else {
                    wrappingWidth = Math.max(width - (snappedLeftInset() + snappedRightInset()), 0);
                }

                double prefHeight = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefHeight += Utils.computeTextHeight(
                            paragraphNode.getFont(),
                            paragraphNode.getText(),
                            wrappingWidth,
                            paragraphNode.getBoundsType());
                }

                prefHeight += snappedTopInset() + snappedBottomInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefHeight = Math.max(prefHeight, (viewPortBounds != null) ? viewPortBounds.getHeight() : 0);
            }
            return computedPrefHeight;
        }

        @Override protected double computeMinWidth(double height) {
            if (computedMinWidth &lt; 0) {
                double hInsets = snappedLeftInset() + snappedRightInset();
                computedMinWidth = Math.min(characterWidth + hInsets, computePrefWidth(height));
            }
            return computedMinWidth;
        }

        @Override protected double computeMinHeight(double width) {
            if (computedMinHeight &lt; 0) {
                double vInsets = snappedTopInset() + snappedBottomInset();
                computedMinHeight = Math.min(lineHeight + vInsets, computePrefHeight(width));
            }
            return computedMinHeight;
        }

        @Override public void layoutChildren() {
            TextArea textArea = getSkinnable();
            double width = getWidth();

            // Lay out paragraphs
            final double topPadding = snappedTopInset();
            final double leftPadding = snappedLeftInset();

            double wrappingWidth = Math.max(width - (leftPadding + snappedRightInset()), 0);

            double y = topPadding;

            final List&lt;Node&gt; paragraphNodesChildren = paragraphNodes.getChildren();

            for (int i = 0; i &lt; paragraphNodesChildren.size(); i++) {
                Node node = paragraphNodesChildren.get(i);
                Text paragraphNode = (Text)node;
                paragraphNode.setWrappingWidth(wrappingWidth);

                Bounds bounds = paragraphNode.getBoundsInLocal();
                paragraphNode.setLayoutX(leftPadding);
                paragraphNode.setLayoutY(y);

                y += bounds.getHeight();
            }

            if (promptNode != null) {
                promptNode.setLayoutX(leftPadding);
                promptNode.setLayoutY(topPadding + promptNode.getBaselineOffset());
                promptNode.setWrappingWidth(wrappingWidth);
            }

            // Update the selection
            IndexRange selection = textArea.getSelection();
            Bounds oldCaretBounds = caretPath.getBoundsInParent();

            selectionHighlightGroup.getChildren().clear();

            int caretPos = textArea.getCaretPosition();
            int anchorPos = textArea.getAnchor();

            if (SHOW_HANDLES) {
                // Install and resize the handles for caret and anchor.
                if (selection.getLength() &gt; 0) {
                    selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                            selectionHandle1.prefHeight(-1));
                    selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                            selectionHandle2.prefHeight(-1));
                } else {
                    caretHandle.resize(caretHandle.prefWidth(-1),
                            caretHandle.prefHeight(-1));
                }

                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the actual caret.
                if (selection.getLength() &gt; 0) {
                    int paragraphIndex = paragraphNodesChildren.size();
                    int paragraphOffset = textArea.getLength() + 1;
                    Text paragraphNode = null;
                    do {
                        paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                        paragraphOffset -= paragraphNode.getText().length() + 1;
                    } while (anchorPos &lt; paragraphOffset);

                    updateTextNodeCaretPos(anchorPos - paragraphOffset);
                    caretPath.getElements().clear();
                    caretPath.getElements().addAll(paragraphNode.getCaretShape());
                    caretPath.setLayoutX(paragraphNode.getLayoutX());
                    caretPath.setLayoutY(paragraphNode.getLayoutY());

                    Bounds b = caretPath.getBoundsInParent();
                    if (caretPos &lt; anchorPos) {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    } else {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    }
                }
            }

            {
                // Position caret
                int paragraphIndex = paragraphNodesChildren.size();
                int paragraphOffset = textArea.getLength() + 1;

                Text paragraphNode = null;
                do {
                    paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                    paragraphOffset -= paragraphNode.getText().length() + 1;
                } while (caretPos &lt; paragraphOffset);

                updateTextNodeCaretPos(caretPos - paragraphOffset);

                caretPath.getElements().clear();
                caretPath.getElements().addAll(paragraphNode.getCaretShape());

                caretPath.setLayoutX(paragraphNode.getLayoutX());

                // TODO: Remove this temporary workaround for RT-27533
                paragraphNode.setLayoutX(2 * paragraphNode.getLayoutX() - paragraphNode.getBoundsInParent().getMinX());

                caretPath.setLayoutY(paragraphNode.getLayoutY());
                if (oldCaretBounds == null || !oldCaretBounds.equals(caretPath.getBoundsInParent())) {
                    scrollCaretToVisible();
                }
            }

            // Update selection fg and bg
            int start = selection.getStart();
            int end = selection.getEnd();
            for (int i = 0, max = paragraphNodesChildren.size(); i &lt; max; i++) {
                Node paragraphNode = paragraphNodesChildren.get(i);
                Text textNode = (Text)paragraphNode;
                int paragraphLength = textNode.getText().length() + 1;
                if (end &gt; start &amp;&amp; start &lt; paragraphLength) {
                    textNode.setSelectionStart(start);
                    textNode.setSelectionEnd(Math.min(end, paragraphLength));

                    Path selectionHighlightPath = new Path();
                    selectionHighlightPath.setManaged(false);
                    selectionHighlightPath.setStroke(null);
                    PathElement[] selectionShape = textNode.getSelectionShape();
                    if (selectionShape != null) {
                        selectionHighlightPath.getElements().addAll(selectionShape);
                    }
                    selectionHighlightGroup.getChildren().add(selectionHighlightPath);
                    selectionHighlightGroup.setVisible(true);
                    selectionHighlightPath.setLayoutX(textNode.getLayoutX());
                    selectionHighlightPath.setLayoutY(textNode.getLayoutY());
                    updateHighlightFill();
                } else {
                    textNode.setSelectionStart(-1);
                    textNode.setSelectionEnd(-1);
                    selectionHighlightGroup.setVisible(false);
                }
                start = Math.max(0, start - paragraphLength);
                end   = Math.max(0, end   - paragraphLength);
            }

            if (SHOW_HANDLES) {
                // Position handle for the caret. This could be handle1 or handle2 when
                // a selection is active.
                Bounds b = caretPath.getBoundsInParent();
                if (selection.getLength() &gt; 0) {
                    if (caretPos &lt; anchorPos) {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    } else {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    }
                } else {
                    caretHandle.setLayoutX(b.getMinX() - caretHandle.getWidth() / 2 + 1);
                    caretHandle.setLayoutY(b.getMaxY());
                }
            }

            if (scrollPane.getPrefViewportWidth() == 0
                    || scrollPane.getPrefViewportHeight() == 0) {
                updatePrefViewportWidth();
                updatePrefViewportHeight();
                if (getParent() != null &amp;&amp; scrollPane.getPrefViewportWidth() &gt; 0
                        || scrollPane.getPrefViewportHeight() &gt; 0) {
                    // Force layout of viewRect in ScrollPaneSkin
                    getParent().requestLayout();
                }
            }

            // RT-36454: Fit to width/height only if smaller than viewport.
            // That is, grow to fit but don't shrink to fit.
            Bounds viewportBounds = scrollPane.getViewportBounds();
            boolean wasFitToWidth = scrollPane.isFitToWidth();
            boolean wasFitToHeight = scrollPane.isFitToHeight();
            boolean setFitToWidth = textArea.isWrapText() || computePrefWidth(-1) &lt;= viewportBounds.getWidth();
            boolean setFitToHeight = computePrefHeight(width) &lt;= viewportBounds.getHeight();
            if (wasFitToWidth != setFitToWidth || wasFitToHeight != setFitToHeight) {
                Platform.runLater(() -&gt; {
                    scrollPane.setFitToWidth(setFitToWidth);
                    scrollPane.setFitToHeight(setFitToHeight);
                });
                getParent().requestLayout();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TreeTableRowSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.scene.control.Control;
import javafx.scene.control.TableColumnBase;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeTableCell;
import javafx.scene.control.TreeTableColumn;
import javafx.scene.control.TreeTablePosition;
import javafx.scene.control.TreeTableRow;
import javafx.scene.control.TreeTableView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.beans.property.DoubleProperty;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.behavior.TreeTableRowBehavior;

import javafx.beans.property.ObjectProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.ObservableList;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.scene.control.TreeView;

/**
 * Default skin implementation for the {@link TreeTableRow} control.
 *
 * @see TreeTableRow
 * @since 9
 */
public class TreeTableRowSkin&lt;T&gt; extends TableRowSkinBase&lt;TreeItem&lt;T&gt;, TreeTableRow&lt;T&gt;, TreeTableCell&lt;T,?&gt;&gt; {

    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    // maps into the TreeTableViewSkin items property via
    // TreeTableViewSkin.treeItemToListMap
    private TreeItem&lt;?&gt; treeItem;
    private boolean disclosureNodeDirty = true;
    private Node graphic;
    private final BehaviorBase&lt;TreeTableRow&lt;T&gt;&gt; behavior;

    private TreeTableViewSkin treeTableViewSkin;

    private boolean childrenDirty = false;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TreeTableRowSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TreeTableRowSkin(TreeTableRow&lt;T&gt; control) {
        super(control);

        // install default input map for the TreeTableRow control
        behavior = new TreeTableRowBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        updateTreeItem();
        updateTableViewSkin();
<A NAME="25"></A>
        registerChangeListener(control.treeTableViewProperty(), e -&gt; updateTableViewSkin());
        registerChangeListener(control.indexProperty(), e -&gt; updateCells = true);
        <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#25',2,'match44-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>registerChangeListener(control.treeItemProperty(), e -&gt; {
            updateTreeItem();
            // There used to be an isDirty = true statement here, but this was
            // determined to be unnecessary and led to performance issues such as
            // those detailed in JDK-8143266
        });

        setupTreeTableViewListeners();
    }

    private void setupTreeTableViewListeners() {</B></FONT>
        TreeTableView&lt;T&gt; treeTableView = getSkinnable().getTreeTableView();
        if (treeTableView == null) {
            getSkinnable().treeTableViewProperty().addListener(new InvalidationListener() {
                @Override public void invalidated(Observable observable) {
                    getSkinnable().treeTableViewProperty().removeListener(this);
                    setupTreeTableViewListeners();
                }
            });
        } else {
            registerChangeListener(treeTableView.treeColumnProperty(), e -&gt; {
                // Fix for RT-27782: Need to set isDirty to true, rather than the
                // cheaper updateCells, as otherwise the text indentation will not
                // be recalculated in TreeTableCellSkin.leftLabelPadding()
                isDirty = true;
                getSkinnable().requestLayout();
            });

            DoubleProperty fixedCellSizeProperty = getTreeTableView().fixedCellSizeProperty();
            if (fixedCellSizeProperty != null) {
                registerChangeListener(fixedCellSizeProperty, e -&gt; {
                    fixedCellSize = fixedCellSizeProperty.get();
                    fixedCellSizeEnabled = fixedCellSize &gt; 0;
                });
                fixedCellSize = fixedCellSizeProperty.get();
                fixedCellSizeEnabled = fixedCellSize &gt; 0;

                // JDK-8144500:
                // When in fixed cell size mode, we must listen to the width of the virtual flow, so
                // that when it changes, we can appropriately add / remove cells that may or may not
                // be required (because we remove all cells that are not visible).
                registerChangeListener(getVirtualFlow().widthProperty(), e -&gt; treeTableView.requestLayout());
            }
        }
    }


    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private final InvalidationListener graphicListener = o -&gt; {
        disclosureNodeDirty = true;
        getSkinnable().requestLayout();
    };


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The amount of space to multiply by the treeItem.level to get the left
     * margin for this tree cell. This is settable from CSS
     */
    private DoubleProperty indent = null;
    public final void setIndent(double value) { indentProperty().set(value); }
    public final double getIndent() { return indent == null ? 10.0 : indent.get(); }
    public final DoubleProperty indentProperty() {
        if (indent == null) {
            indent = new StyleableDoubleProperty(10.0) {
                @Override public Object getBean() {
                    return TreeTableRowSkin.this;
                }

                @Override public String getName() {
                    return &quot;indent&quot;;
                }

                @Override public CssMetaData&lt;TreeTableRow&lt;?&gt;,Number&gt; getCssMetaData() {
                    return TreeTableRowSkin.StyleableProperties.INDENT;
                }
            };
        }
        return indent;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateChildren() {
        super.updateChildren();

        updateDisclosureNodeAndGraphic();

        if (childrenDirty) {
            childrenDirty = false;
            if (cells.isEmpty()) {
                getChildren().clear();
            } else {
                // TODO we can optimise this by only showing cells that are
                // visible based on the table width and the amount of horizontal
                // scrolling.
                getChildren().addAll(cells);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double x, double y, double w, double h) {
        if (disclosureNodeDirty) {
            updateDisclosureNodeAndGraphic();
            disclosureNodeDirty = false;
        }

        Node disclosureNode = getDisclosureNode();
        if (disclosureNode != null &amp;&amp; disclosureNode.getScene() == null) {
            updateDisclosureNodeAndGraphic();
        }

        super.layoutChildren(x, y, w, h);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected TreeTableCell&lt;T, ?&gt; createCell(TableColumnBase tcb) {
        TreeTableColumn tableColumn = (TreeTableColumn&lt;T,?&gt;) tcb;
        TreeTableCell cell = (TreeTableCell) tableColumn.getCellFactory().call(tableColumn);

        cell.updateTreeTableColumn(tableColumn);
        cell.updateTreeTableView(tableColumn.getTreeTableView());

        return cell;
    }

    /** {@inheritDoc} */
    @Override void updateCells(boolean resetChildren) {
        super.updateCells(resetChildren);

        if (resetChildren) {
            childrenDirty = true;
            updateChildren();
        }
    }

    /** {@inheritDoc} */
    @Override boolean isIndentationRequired() {
        return true;
    }

    /** {@inheritDoc} */
    @Override TableColumnBase getTreeColumn() {
        return getTreeTableView().getTreeColumn();
    }

    /** {@inheritDoc} */
    @Override int getIndentationLevel(TreeTableRow&lt;T&gt; control) {
        return getTreeTableView().getTreeItemLevel(control.getTreeItem());
    }

    /** {@inheritDoc} */
    @Override double getIndentationPerLevel() {
        return getIndent();
    }

    /** {@inheritDoc} */
    @Override Node getDisclosureNode() {
        return getSkinnable().getDisclosureNode();
    }

    @Override boolean isDisclosureNodeVisible() {
        return getDisclosureNode() != null &amp;&amp; treeItem != null &amp;&amp; ! treeItem.isLeaf();
    }

    @Override boolean isShowRoot() {
        return getTreeTableView().isShowRoot();
    }

    /** {@inheritDoc} */
    @Override protected ObservableList&lt;TreeTableColumn&lt;T, ?&gt;&gt; getVisibleLeafColumns() {
        return getTreeTableView() == null ? FXCollections.emptyObservableList() : getTreeTableView().getVisibleLeafColumns();
    }

    /** {@inheritDoc} */
    @Override protected void updateCell(TreeTableCell&lt;T, ?&gt; cell, TreeTableRow&lt;T&gt; row) {
        cell.updateTreeTableRow(row);
    }

    /** {@inheritDoc} */
    @Override protected TreeTableColumn&lt;T, ?&gt; getTableColumn(TreeTableCell cell) {
        return cell.getTableColumn();
    }

    /** {@inheritDoc} */
    @Override protected ObjectProperty&lt;Node&gt; graphicProperty() {
        TreeTableRow&lt;T&gt; treeTableRow = getSkinnable();
        if (treeTableRow == null) return null;
        if (treeItem == null) return null;

        return treeItem.graphicProperty();
    }

    private void updateTreeItem() {
        if (treeItem != null) {
            treeItem.graphicProperty().removeListener(graphicListener);
        }
        treeItem = getSkinnable().getTreeItem();
        if (treeItem != null) {
            treeItem.graphicProperty().addListener(graphicListener);
        }
    }

    private TreeTableView&lt;T&gt; getTreeTableView() {
        return getSkinnable().getTreeTableView();
    }

    private void updateDisclosureNodeAndGraphic() {
        if (getSkinnable().isEmpty()) {
            getChildren().remove(graphic);
            return;
        }

        // check for graphic missing
        ObjectProperty&lt;Node&gt; graphicProperty = graphicProperty();
        Node newGraphic = graphicProperty == null ? null : graphicProperty.get();
        if (newGraphic != null) {
            // RT-30466: remove the old graphic
            if (newGraphic != graphic) {
                getChildren().remove(graphic);
            }

            if (! getChildren().contains(newGraphic)) {
                getChildren().add(newGraphic);
                graphic = newGraphic;
            }
        }

        // check disclosure node
        Node disclosureNode = getSkinnable().getDisclosureNode();
        if (disclosureNode != null) {
            boolean disclosureVisible = treeItem != null &amp;&amp; ! treeItem.isLeaf();
            disclosureNode.setVisible(disclosureVisible);

            if (! disclosureVisible) {
                getChildren().remove(disclosureNode);
            } else if (disclosureNode.getParent() == null) {
                getChildren().add(disclosureNode);
                disclosureNode.toFront();
            } else {
                disclosureNode.toBack();
            }

            // RT-26625: [TreeView, TreeTableView] can lose arrows while scrolling
            // RT-28668: Ensemble tree arrow disappears
            if (disclosureNode.getScene() != null) {
                disclosureNode.applyCss();
            }
        }
    }

    private void updateTableViewSkin() {
        TreeTableView&lt;T&gt; tableView = getSkinnable().getTreeTableView();
        if (tableView != null &amp;&amp; tableView.getSkin() instanceof TreeTableViewSkin) {
            treeTableViewSkin = (TreeTableViewSkin)tableView.getSkin();
        }
    }


    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    private static class StyleableProperties {

        private static final CssMetaData&lt;TreeTableRow&lt;?&gt;,Number&gt; INDENT =
            new CssMetaData&lt;TreeTableRow&lt;?&gt;,Number&gt;(&quot;-fx-indent&quot;,
                SizeConverter.getInstance(), 10.0) {

            @Override public boolean isSettable(TreeTableRow&lt;?&gt; n) {
                DoubleProperty p = ((TreeTableRowSkin&lt;?&gt;) n.getSkin()).indentProperty();
                return p == null || !p.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeTableRow&lt;?&gt; n) {
                final TreeTableRowSkin&lt;?&gt; skin = (TreeTableRowSkin&lt;?&gt;) n.getSkin();
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.indentProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(CellSkinBase.getClassCssMetaData());
            styleables.add(INDENT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }


    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        final TreeTableView&lt;T&gt; treeTableView = getSkinnable().getTreeTableView();
        switch (attribute) {
            case SELECTED_ITEMS: {
                // FIXME this could be optimised to iterate over cellsMap only
                // (selectedCells could be big, cellsMap is much smaller)
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                int index = getSkinnable().getIndex();
                for (TreeTablePosition&lt;T,?&gt; pos : treeTableView.getSelectionModel().getSelectedCells()) {
                    if (pos.getRow() == index) {
                        TreeTableColumn&lt;T,?&gt; column = pos.getTableColumn();
                        if (column == null) {
                            /* This is the row-based case */
                            column = treeTableView.getVisibleLeafColumn(0);
                        }
                        TreeTableCell&lt;T,?&gt; cell = cellsMap.get(column).get();
                        if (cell != null) selection.add(cell);
                    }
                    return FXCollections.observableArrayList(selection);
                }
            }
            case CELL_AT_ROW_COLUMN: {
                int colIndex = (Integer)parameters[1];
                TreeTableColumn&lt;T,?&gt; column = treeTableView.getVisibleLeafColumn(colIndex);
                if (cellsMap.containsKey(column)) {
                    return cellsMap.get(column).get();
                }
                return null;
            }
            case FOCUS_ITEM: {
                TreeTableView.TreeTableViewFocusModel&lt;T&gt; fm = treeTableView.getFocusModel();
                TreeTablePosition&lt;T,?&gt; focusedCell = fm.getFocusedCell();
                TreeTableColumn&lt;T,?&gt; column = focusedCell.getTableColumn();
                if (column == null) {
                    /* This is the row-based case */
                    column = treeTableView.getVisibleLeafColumn(0);
                }
                if (cellsMap.containsKey(column)) {
                    return cellsMap.get(column).get();
                }
                return null;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TreeViewSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.Properties;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.collections.FXCollections;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.event.WeakEventHandler;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.TreeItem.TreeModificationEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import com.sun.javafx.scene.control.behavior.TreeViewBehavior;

/**
 * Default skin implementation for the {@link TreeView} control.
 *
 * @see TreeView
 * @since 9
 */
public class TreeViewSkin&lt;T&gt; extends VirtualContainerBase&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    // RT-34744 : IS_PANNABLE will be false unless
    // javafx.scene.control.skin.TreeViewSkin.pannable
    // is set to true. This is done in order to make TreeView functional
    // on embedded systems with touch screens which do not generate scroll
    // events for touch drag gestures.
    private static final boolean IS_PANNABLE =
            AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.control.skin.TreeViewSkin.pannable&quot;));



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final VirtualFlow&lt;TreeCell&lt;T&gt;&gt; flow;
    private WeakReference&lt;TreeItem&lt;T&gt;&gt; weakRoot;
    private final TreeViewBehavior&lt;T&gt; behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private MapChangeListener&lt;Object, Object&gt; propertiesMapListener = c -&gt; {
        if (! c.wasAdded()) return;
        if (Properties.RECREATE.equals(c.getKey())) {
            requestRebuildCells();
            getSkinnable().getProperties().remove(Properties.RECREATE);
        }
    };

    private EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; rootListener = e -&gt; {
        if (e.wasAdded() &amp;&amp; e.wasRemoved() &amp;&amp; e.getAddedSize() == e.getRemovedSize()) {
            // Fix for RT-14842, where the children of a TreeItem were changing,
            // but because the overall item count was staying the same, there was
            // no event being fired to the skin to be informed that the items
            // had changed. So, here we just watch for the case where the number
            // of items being added is equal to the number of items being removed.
            markItemCountDirty();
            getSkinnable().requestLayout();
        } else if (e.getEventType().equals(TreeItem.valueChangedEvent())) {
            // Fix for RT-14971 and RT-15338.
            requestRebuildCells();
        } else {
            // Fix for RT-20090. We are checking to see if the event coming
            // from the TreeItem root is an event where the count has changed.
            EventType&lt;?&gt; eventType = e.getEventType();
            while (eventType != null) {
                if (eventType.equals(TreeItem.&lt;T&gt;expandedItemCountChangeEvent())) {
                    markItemCountDirty();
                    getSkinnable().requestLayout();
                    break;
                }
                eventType = eventType.getSuperType();
            }
        }

        // fix for RT-37853
        getSkinnable().edit(null);
    };

    private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakRootListener;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TreeViewSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TreeViewSkin(final TreeView control) {
        super(control);

        // install default input map for the TreeView control
        behavior = new TreeViewBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        // init the VirtualFlow
        flow = getVirtualFlow();
        flow.setPannable(IS_PANNABLE);
        flow.setCellFactory(this::createCell);
        flow.setFixedCellSize(control.getFixedCellSize());
        getChildren().add(flow);

        setRoot(getSkinnable().getRoot());

        EventHandler&lt;MouseEvent&gt; ml = event -&gt; {
            // RT-15127: cancel editing on scroll. This is a bit extreme
            // (we are cancelling editing on touching the scrollbars).
            // This can be improved at a later date.
            if (control.getEditingItem() != null) {
                control.edit(null);
            }

            // This ensures that the tree maintains the focus, even when the vbar
            // and hbar controls inside the flow are clicked. Without this, the
            // focus border will not be shown when the user interacts with the
            // scrollbars, and more importantly, keyboard navigation won't be
            // available to the user.
            if (control.isFocusTraversable()) {
                control.requestFocus();
            }
        };
        flow.getVbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
        flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);

        final ObservableMap&lt;Object, Object&gt; properties = control.getProperties();
        properties.remove(Properties.RECREATE);
        properties.addListener(propertiesMapListener);

        // init the behavior 'closures'
        behavior.setOnFocusPreviousRow(() -&gt; { onFocusPreviousCell(); });
        behavior.setOnFocusNextRow(() -&gt; { onFocusNextCell(); });
        behavior.setOnMoveToFirstCell(() -&gt; { onMoveToFirstCell(); });
        behavior.setOnMoveToLastCell(() -&gt; { onMoveToLastCell(); });
        behavior.setOnScrollPageDown(this::onScrollPageDown);
        behavior.setOnScrollPageUp(this::onScrollPageUp);
        behavior.setOnSelectPreviousRow(() -&gt; { onSelectPreviousCell(); });
        behavior.setOnSelectNextRow(() -&gt; { onSelectNextCell(); });

        registerChangeListener(control.rootProperty(), e -&gt; setRoot(getSkinnable().getRoot()));
        registerChangeListener(control.showRootProperty(), e -&gt; {
            // if we turn off showing the root, then we must ensure the root
            // is expanded - otherwise we end up with no visible items in
            // the tree.
            if (! getSkinnable().isShowRoot() &amp;&amp; getRoot() != null) {
                getRoot().setExpanded(true);
            }
            // update the item count in the flow and behavior instances
            updateItemCount();
        });
        registerChangeListener(control.cellFactoryProperty(), e -&gt; flow.recreateCells());
        registerChangeListener(control.fixedCellSizeProperty(), e -&gt; flow.setFixedCellSize(getSkinnable().getFixedCellSize()));

        updateItemCount();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset) * 0.618033987;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return 400;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y, final double w, final double h) {
        super.layoutChildren(x, y, w, h);
        flow.resizeRelocate(x, y, w, h);
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: {
                FocusModel&lt;?&gt; fm = getSkinnable().getFocusModel();
                int focusedIndex = fm.getFocusedIndex();
                if (focusedIndex == -1) {
                    if (getItemCount() &gt; 0) {
                        focusedIndex = 0;
                    } else {
                        return null;
                    }
                }
                return flow.getPrivateCell(focusedIndex);
            }
            case ROW_AT_INDEX: {
                final int rowIndex = (Integer)parameters[0];
                return rowIndex &lt; 0 ? null : flow.getPrivateCell(rowIndex);
            }
            case SELECTED_ITEMS: {
                MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
                ObservableList&lt;Integer&gt; indices = sm.getSelectedIndices();
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;(indices.size());
                for (int i : indices) {
                    TreeCell&lt;T&gt; row = flow.getPrivateCell(i);
                    if (row != null) selection.add(row);
                }
                return FXCollections.observableArrayList(selection);
            }
            case VERTICAL_SCROLLBAR: return flow.getVbar();
            case HORIZONTAL_SCROLLBAR: return flow.getHbar();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SHOW_ITEM: {
                Node item = (Node)parameters[0];
                if (item instanceof TreeCell) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    TreeCell&lt;T&gt; cell = (TreeCell&lt;T&gt;)item;
                    flow.scrollTo(cell.getIndex());
                }
                break;
            }
            case SET_SELECTED_ITEMS: {
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;Node&gt; items = (ObservableList&lt;Node&gt;)parameters[0];
                if (items != null) {
                    MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
                    if (sm != null) {
                        sm.clearSelection();
                        for (Node item : items) {
                            if (item instanceof TreeCell) {
                                @SuppressWarnings(&quot;unchecked&quot;)
                                TreeCell&lt;T&gt; cell = (TreeCell&lt;T&gt;)item;
                                sm.select(cell.getIndex());
                            }
                        }
                    }
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private TreeCell&lt;T&gt; createCell(VirtualFlow&lt;TreeCell&lt;T&gt;&gt; flow) {
        final TreeCell&lt;T&gt; cell;
        if (getSkinnable().getCellFactory() != null) {
            cell = getSkinnable().getCellFactory().call(getSkinnable());
        } else {
            cell = createDefaultCellImpl();
<A NAME="33"></A>        }

        // If there is no disclosure node, then add one of my own
        if (cell.getDisclosureNode() == null) <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#33',2,'match44-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            final StackPane disclosureNode = new StackPane();

            /* This code is intentionally commented.
             * Currently as it stands it does provided any functionality and interferes
             * with TreeView. The VO cursor move over the DISCLOSURE_NODE instead of the
             * tree item itself. This is possibly caused by the order of item's children
             * (the Labeled and the disclosure node).
             */
//            final StackPane disclosureNode = new StackPane() {
//                @Override protected Object accGetAttribute(Attribute attribute, Object... parameters) {
//                    switch (attribute) {
//                        case ROLE: return Role.DISCLOSURE_NODE;
//                        default: return super.accGetAttribute(attribute, parameters);
//                    }
//                }
//            };
            disclosureNode.getStyleClass().setAll(&quot;tree-disclosure-node&quot;);

            final StackPane disclosureNodeArrow = new StackPane();
            disclosureNodeArrow.getStyleClass().setAll(&quot;arrow&quot;);
            disclosureNode.getChildren().add</B></FONT>(disclosureNodeArrow);

            cell.setDisclosureNode(disclosureNode);
        }

        cell.updateTreeView(getSkinnable());

        return cell;
    }

    private TreeItem&lt;T&gt; getRoot() {
        return weakRoot == null ? null : weakRoot.get();
    }
    private void setRoot(TreeItem&lt;T&gt; newRoot) {
        if (getRoot() != null &amp;&amp; weakRootListener != null) {
            getRoot().removeEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }
        weakRoot = new WeakReference&lt;&gt;(newRoot);
        if (getRoot() != null) {
            weakRootListener = new WeakEventHandler&lt;&gt;(rootListener);
            getRoot().addEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootListener);
        }

        updateItemCount();
    }

    /** {@inheritDoc} */
    @Override protected int getItemCount() {
        return getSkinnable().getExpandedItemCount();
    }

    /** {@inheritDoc} */
    @Override protected void updateItemCount() {
//        int oldCount = flow.getCellCount();
        int newCount = getItemCount();

        // if this is not called even when the count is the same, we get a
        // memory leak in VirtualFlow.sheet.children. This can probably be
        // optimised in the future when time permits.
        requestRebuildCells();
        flow.setCellCount(newCount);

        // Ideally we would be more nuanced above, toggling a cheaper needs*
        // field, but if we do we hit issues such as those identified in
        // RT-27852, where the expended item count of the new root equals the
        // EIC of the old root, which would lead to the visuals not updating
        // properly.
        getSkinnable().requestLayout();
    }

    // Note: This is a copy/paste of javafx.scene.control.cell.DefaultTreeCell,
    // which is package-protected
    private TreeCell&lt;T&gt; createDefaultCellImpl() {
        return new TreeCell&lt;T&gt;() {
            private HBox hbox;

            private WeakReference&lt;TreeItem&lt;T&gt;&gt; treeItemRef;

            private InvalidationListener treeItemGraphicListener = observable -&gt; {
                updateDisplay(getItem(), isEmpty());
            };

            private InvalidationListener treeItemListener = new InvalidationListener() {
                @Override public void invalidated(Observable observable) {
                    TreeItem&lt;T&gt; oldTreeItem = treeItemRef == null ? null : treeItemRef.get();
                    if (oldTreeItem != null) {
                        oldTreeItem.graphicProperty().removeListener(weakTreeItemGraphicListener);
                    }

                    TreeItem&lt;T&gt; newTreeItem = getTreeItem();
                    if (newTreeItem != null) {
                        newTreeItem.graphicProperty().addListener(weakTreeItemGraphicListener);
                        treeItemRef = new WeakReference&lt;TreeItem&lt;T&gt;&gt;(newTreeItem);
                    }
                }
            };

            private WeakInvalidationListener weakTreeItemGraphicListener =
                    new WeakInvalidationListener(treeItemGraphicListener);

            private WeakInvalidationListener weakTreeItemListener =
                    new WeakInvalidationListener(treeItemListener);

            {
                treeItemProperty().addListener(weakTreeItemListener);

                if (getTreeItem() != null) {
                    getTreeItem().graphicProperty().addListener(weakTreeItemGraphicListener);
                }
            }

            private void updateDisplay(T item, boolean empty) {
                if (item == null || empty) {
                    hbox = null;
                    setText(null);
                    setGraphic(null);
                } else {
                    // update the graphic if one is set in the TreeItem
                    TreeItem&lt;T&gt; treeItem = getTreeItem();
                    Node graphic = treeItem == null ? null : treeItem.getGraphic();
                    if (graphic != null) {
                        if (item instanceof Node) {
                            setText(null);

                            // the item is a Node, and the graphic exists, so
                            // we must insert both into an HBox and present that
                            // to the user (see RT-15910)
                            if (hbox == null) {
                                hbox = new HBox(3);
                            }
                            hbox.getChildren().setAll(graphic, (Node)item);
                            setGraphic(hbox);
                        } else {
                            hbox = null;
                            setText(item.toString());
                            setGraphic(graphic);
                        }
                    } else {
                        hbox = null;
                        if (item instanceof Node) {
                            setText(null);
                            setGraphic((Node)item);
                        } else {
                            setText(item.toString());
                            setGraphic(null);
                        }
                    }
                }
            }

            @Override public void updateItem(T item, boolean empty) {
                super.updateItem(item, empty);
                updateDisplay(item, empty);
            }
        };
    }

    private void onFocusPreviousCell() {
        FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (fm == null) return;
        flow.scrollTo(fm.getFocusedIndex());
    }

    private void onFocusNextCell() {
        FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (fm == null) return;
        flow.scrollTo(fm.getFocusedIndex());
    }

    private void onSelectPreviousCell() {
        int row = getSkinnable().getSelectionModel().getSelectedIndex();
        flow.scrollTo(row);
    }

    private void onSelectNextCell() {
        int row = getSkinnable().getSelectionModel().getSelectedIndex();
        flow.scrollTo(row);
    }

    private void onMoveToFirstCell() {
        flow.scrollTo(0);
        flow.setPosition(0);
    }

    private void onMoveToLastCell() {
        flow.scrollTo(getItemCount());
        flow.setPosition(1);
    }

    /**
     * Function used to scroll the container down by one 'page'.
     */
    private int onScrollPageDown(boolean isFocusDriven) {
        TreeCell&lt;T&gt; lastVisibleCell = flow.getLastVisibleCellWithinViewPort();
        if (lastVisibleCell == null) return -1;

        final SelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
        final FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (sm == null || fm == null) return -1;

        int lastVisibleCellIndex = lastVisibleCell.getIndex();

        // isSelected represents focus OR selection
        boolean isSelected = false;
        if (isFocusDriven) {
            isSelected = lastVisibleCell.isFocused() || fm.isFocused(lastVisibleCellIndex);
        } else {
            isSelected = lastVisibleCell.isSelected() || sm.isSelected(lastVisibleCellIndex);
        }

        if (isSelected) {
            boolean isLeadIndex = (isFocusDriven &amp;&amp; fm.getFocusedIndex() == lastVisibleCellIndex)
                    || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == lastVisibleCellIndex);

            if (isLeadIndex) {
                // if the last visible cell is selected, we want to shift that cell up
                // to be the top-most cell, or at least as far to the top as we can go.
                flow.scrollToTop(lastVisibleCell);

                TreeCell&lt;T&gt; newLastVisibleCell = flow.getLastVisibleCellWithinViewPort();
                lastVisibleCell = newLastVisibleCell == null ? lastVisibleCell : newLastVisibleCell;
            }
        } else {
            // if the selection is not on the 'bottom' most cell, we firstly move
            // the selection down to that, without scrolling the contents, so
            // this is a no-op
        }

        int newSelectionIndex = lastVisibleCell.getIndex();
        flow.scrollTo(lastVisibleCell);
        return newSelectionIndex;
    }

    /**
     * Function used to scroll the container up by one 'page'.
     */
    private int onScrollPageUp(boolean isFocusDriven) {
        TreeCell&lt;T&gt; firstVisibleCell = flow.getFirstVisibleCellWithinViewPort();
        if (firstVisibleCell == null) return -1;

        final SelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSkinnable().getSelectionModel();
        final FocusModel&lt;TreeItem&lt;T&gt;&gt; fm = getSkinnable().getFocusModel();
        if (sm == null || fm == null) return -1;

        int firstVisibleCellIndex = firstVisibleCell.getIndex();

        // isSelected represents focus OR selection
        boolean isSelected = false;
        if (isFocusDriven) {
            isSelected = firstVisibleCell.isFocused() || fm.isFocused(firstVisibleCellIndex);
        } else {
            isSelected = firstVisibleCell.isSelected() || sm.isSelected(firstVisibleCellIndex);
        }

        if (isSelected) {
            boolean isLeadIndex = (isFocusDriven &amp;&amp; fm.getFocusedIndex() == firstVisibleCellIndex)
                    || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == firstVisibleCellIndex);

            if (isLeadIndex) {
                // if the first visible cell is selected, we want to shift that cell down
                // to be the bottom-most cell, or at least as far to the bottom as we can go.
                flow.scrollToBottom(firstVisibleCell);

                TreeCell&lt;T&gt; newFirstVisibleCell = flow.getFirstVisibleCellWithinViewPort();
                firstVisibleCell = newFirstVisibleCell == null ? firstVisibleCell : newFirstVisibleCell;
            }
        } else {
            // if the selection is not on the 'top' most cell, we firstly move
            // the selection up to that, without scrolling the contents, so
            // this is a no-op
        }

        int newSelectionIndex = firstVisibleCell.getIndex();
        flow.scrollTo(firstVisibleCell);
        return newSelectionIndex;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Clipboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
<A NAME="19"></A> * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#19',2,'match44-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.glass.ui;

import com.sun.glass.ui.delegate.ClipboardDelegate;

import java.lang.annotation.Native;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import java.nio.ByteBuffer;

public class Clipboard {
    /**
     * predefined mime types
     * Have to be synchronized with native realization.
     */
    @</B></FONT>Native public final static String TEXT_TYPE = &quot;text/plain&quot;;
    @Native public final static String HTML_TYPE = &quot;text/html&quot;;
    @Native public final static String RTF_TYPE = &quot;text/rtf&quot;;
    @Native public final static String URI_TYPE = &quot;text/uri-list&quot;;//http://www.ietf.org/rfc/rfc2483.txt
    @Native public final static String FILE_LIST_TYPE = &quot;application/x-java-file-list&quot;;
    @Native public final static String RAW_IMAGE_TYPE = &quot;application/x-java-rawimage&quot;;
    @Native public final static String DRAG_IMAGE = &quot;application/x-java-drag-image&quot;;
    @Native public final static String DRAG_IMAGE_OFFSET = &quot;application/x-java-drag-image-offset&quot;;
    @Native public final static String IE_URL_SHORTCUT_FILENAME = &quot;text/ie-shortcut-filename&quot;;

<A NAME="23"></A>    /**
     * predefined drop-effect actions and combinations.
     */
    <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#23',2,'match44-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native public final static int ACTION_NONE = 0x0;
    @Native public final static int ACTION_COPY = 0x1;
    @Native public final static int ACTION_MOVE = 0x2;
    @Native public final static int ACTION_REFERENCE = 0x40000000;
    @Native public final static int ACTION_COPY_OR_MOVE = ACTION_COPY | ACTION_MOVE;
    @Native public final static int ACTION_ANY       = 0x4FFFFFFF;

    /**
     * predefined clipboard name for system shared buffers
     */
    @Native public final static String DND = &quot;DND&quot;;
    @Native public final static String SYSTEM = &quot;SYSTEM&quot;;
    @Native public final static String SELECTION = &quot;SELECTION&quot;;

    private final static Map &lt;String, Clipboard&gt; clipboards  = new HashMap &lt;String, Clipboard&gt; ();
    private final static ClipboardDelegate delegate = PlatformFactory.getPlatformFactory().createClipboardDelegate()</B></FONT>;

    private final HashSet &lt;ClipboardAssistance&gt; assistants  =  new HashSet &lt;ClipboardAssistance&gt; ();
    private final String name;
    private final Object localDataProtector = new Object();
    private HashMap &lt;String, Object&gt; localSharedData;
    private ClipboardAssistance dataSource;

    /**
     * combination of ACTION_XXXX constants
     */
    protected int supportedActions = ACTION_COPY;

    protected Clipboard (String name) {
        Application.checkEventThread();
        this.name = name;
    }

    public void add (ClipboardAssistance assistant) {
        Application.checkEventThread();
        synchronized(assistants) {
            assistants.add(assistant);
        }
    }

    public void remove (ClipboardAssistance assistant) {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (assistant==dataSource) {
                dataSource = null;
            }
        }
        boolean needClose;
        synchronized(assistants) {
            assistants.remove(assistant);
            needClose = assistants.isEmpty();
        }

        if (needClose) {
            synchronized(clipboards) {
                clipboards.remove(name);
            }
            close();
        }
    }

    protected void setSharedData (
            ClipboardAssistance dataSource,
            HashMap&lt;String, Object&gt; cacheData,
            int supportedActions)
    {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            localSharedData = (HashMap&lt;String, Object&gt;) cacheData.clone();
            this.supportedActions = supportedActions;
            this.dataSource = dataSource;
        }
    }

    /**
     *
     * @param cacheData
     * @param supportedActions combination of ACTION_XXXX consts
     */
    public void flush(
        ClipboardAssistance dataSource,
        HashMap&lt;String, Object&gt; cacheData,
        int supportedActions)
    {
        Application.checkEventThread();
        setSharedData(dataSource, cacheData, supportedActions);
        contentChanged();
    }

    public int getSupportedSourceActions() {
        Application.checkEventThread();
        return this.supportedActions;
    }

    public void setTargetAction(int actionDone) {
        Application.checkEventThread();
        actionPerformed(actionDone);
    }

    public void contentChanged() {
        Application.checkEventThread();
        final HashSet &lt;ClipboardAssistance&gt; _assistants;
        synchronized(assistants) {
            _assistants = (HashSet &lt;ClipboardAssistance&gt;)assistants.clone();
        }
        for (ClipboardAssistance assistant : _assistants) {
            assistant.contentChanged();
        }
    }

    /**
     * Called by system and notifies about successful data transfer.
     * Delete-on-move functionality should be implemented here.
     * @param action Clipboard.ACTION_COPY, or Clipboard.ACTION_MOVE, or Clipboard.ACTION_REFERENCE
     */
    public void actionPerformed(int action) {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (null!=dataSource) {
                dataSource.actionPerformed(action);
            }
        }
    }


    public Object getData (String mimeType) {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (localSharedData == null) {
                return null;
            }
            Object ret = localSharedData.get(mimeType);
            return (ret instanceof DelayedCallback)
                ? ((DelayedCallback)ret).providedData()
                : ret;
        }
    }

    public String[] getMimeTypes () {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (localSharedData == null) {
                return null;
            }
            Set&lt;String&gt; mimes = localSharedData.keySet();
            String [] ret = new String[mimes.size()];
            int i = 0;
            for (String mime : mimes) {
                ret[i++] = mime;
            }
            return ret;
        }
    }

    /* We have only one clipboard for each name.
     * but it can be used by several @code{ClipboardAssistance}s
     */
    protected static Clipboard get (String clipboardName) {
        Application.checkEventThread();
        /* return apropriate one*/
        synchronized(clipboards) {
            if (!clipboards.keySet().contains(clipboardName)) {
                Clipboard newClipboard = delegate.createClipboard(clipboardName);
                if (newClipboard == null) {
                    newClipboard = new Clipboard(clipboardName);
                }
                clipboards.put(clipboardName, newClipboard);
            }
            return clipboards.get(clipboardName);
        }
    }

    public Pixels getPixelsForRawImage(byte rawimage[]) {
        Application.checkEventThread();
        ByteBuffer size = ByteBuffer.wrap(rawimage, 0, 8);
        int width = size.getInt();
        int height = size.getInt();

        ByteBuffer pixels = ByteBuffer.wrap(rawimage, 8, rawimage.length - 8); // drop width+height
        return Application.GetApplication().createPixels(width, height, pixels.slice());
    }

    @Override public String toString () {
        return &quot;Clipboard: &quot; + name + &quot;@&quot; + hashCode();
    }

    protected void close() {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            dataSource = null;
        }
    }

    public String getName() {
        Application.checkEventThread();
        return name;
    }

    public static String getActionString (int action) {
        Application.checkEventThread();
        StringBuilder ret = new StringBuilder(&quot;&quot;);
        int[] test = {
            ACTION_COPY,
            ACTION_MOVE,
            ACTION_REFERENCE};
        String[] canDo = {
            &quot;copy&quot;,
            &quot;move&quot;,
            &quot;link&quot;};
        for (int i =0; i &lt; 3; ++i) {
            if ((test[i] &amp; action) &gt; 0) {
                if (ret.length() &gt; 0) {
                    ret.append(&quot;,&quot;);
                }
                ret.append(canDo[i]);
            }
        }
        return ret.toString();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/View.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.ViewEvent;

import java.lang.annotation.Native;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Map;

public abstract class View {

    @Native public final static int GESTURE_NO_VALUE = Integer.MAX_VALUE;
    @Native public final static double GESTURE_NO_DOUBLE_VALUE = Double.NaN;

    @Native public final static byte IME_ATTR_INPUT                 = 0x00;
    @Native public final static byte IME_ATTR_TARGET_CONVERTED      = 0x01;
    @Native public final static byte IME_ATTR_CONVERTED             = 0x02;
    @Native public final static byte IME_ATTR_TARGET_NOTCONVERTED   = 0x03;
    @Native public final static byte IME_ATTR_INPUT_ERROR           = 0x04;

    final static boolean accessible = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
        String force = System.getProperty(&quot;glass.accessible.force&quot;);
        if (force != null) return Boolean.parseBoolean(force);

        /* By default accessibility is enabled for Mac 10.9 or greater and Windows 7 or greater. */
        try {
            String platform = Platform.determinePlatform();
            String major = System.getProperty(&quot;os.version&quot;).replaceFirst(&quot;(\\d+)\\.\\d+.*&quot;, &quot;$1&quot;);
            String minor = System.getProperty(&quot;os.version&quot;).replaceFirst(&quot;\\d+\\.(\\d+).*&quot;, &quot;$1&quot;);
            int v = Integer.parseInt(major) * 100 + Integer.parseInt(minor);
            return (platform.equals(Platform.MAC) &amp;&amp; v &gt;= 1009) ||
                   (platform.equals(Platform.WINDOWS) &amp;&amp; v &gt;= 601);
        } catch (Exception e) {
            return false;
        }
    });

    public static class EventHandler {
        public void handleViewEvent(View view, long time, int type) {
        }
        public void handleKeyEvent(View view, long time, int action,
                int keyCode, char[] keyChars, int modifiers) {
        }
        public void handleMenuEvent(View view, int x, int y, int xAbs,
                int yAbs, boolean isKeyboardTrigger) {
        }
        public void handleMouseEvent(View view, long time, int type, int button,
                                     int x, int y, int xAbs, int yAbs,
                                     int modifiers, boolean isPopupTrigger, boolean isSynthesized)
        {
        }

        /**
         * A Scroll event handler.
         *
         * The lines argument:
         * &amp;gt; 0 - a number of lines to scroll per each 1.0 of deltaY scroll amount
         * == 0 - the scroll amount is in pixel units
         * &amp;lt; 0 - the scrolling should be performed by pages. Each 1.0 of scroll amount
         * corresponds to exactly one page of scrollable content.
         *
         * Similarly, the chars argument specifies the number of characters
         * to scroll per 1.0 of the deltaX scrolling amount.
         * If the parameter is zero, the deltaX represents the number of
         * pixels to scroll.
         *
         * The defaultLines and defaultChars arguments contain the system-default
         * values of lines and chars. This can be used by the app to compute
         * the ratio of current settings and default settings and adjust the
         * pixel values accordingly.
         *
         * Multiplers are used when an app receives a non-zero unit values (i.e.
         * either the lines or chars are not zeroes), but wants instead get delta
         * values in pixels. In this case the app needs to multiply the deltas
         * on the provided multiplier parameter.
         */
        public void handleScrollEvent(View view, long time,
                int x, int y, int xAbs, int yAbs,
                double deltaX, double deltaY, int modifiers, int lines, int chars,
                int defaultLines, int defaultChars,
                double xMultiplier, double yMultiplier)
        {
        }

        public void handleInputMethodEvent(long time, String text,
                int[] clauseBoundary,
                int[] attrBoundary, byte[] attrValue,
                int commitCount, int cursorPos) {
        }

        public double[] getInputMethodCandidatePos(int offset) {
            return null;
        }

        public void handleDragStart(View view, int button, int x, int y, int xAbs, int yAbs,
                ClipboardAssistance dropSourceAssistant) {
        }

        public void handleDragEnd(View view, int performedAction) {
        }

        public int handleDragEnter(View view, int x, int y, int xAbs, int yAbs,
                int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
            return recommendedDropAction;
        }

        public int handleDragOver(View view, int x, int y, int xAbs, int yAbs,
                int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
            return recommendedDropAction;
        }

        public void handleDragLeave(View view, ClipboardAssistance dropTargetAssistant) {
        }

        public int handleDragDrop(View view, int x, int y, int xAbs, int yAbs,
                int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
            return Clipboard.ACTION_NONE;
        }

        /**
         * Touch event handler. Called when touch event occures.
         * Always followed with one ore more #handleNextTouchEvent() calls
         * and a single #handleEndTouchEvent() call.
         *
         * @param isDirect if event reported by direct or indirect touch device;
         *        touch screen is an example of direct touch device and
         *        touch pad is an example of indirect one
         * @param touchEventCount indicates number of #handleNextTouchEvent() calls
         *        that will follow this method call.
         */
        public void handleBeginTouchEvent(View view, long time, int modifiers,
                                          boolean isDirect, int touchEventCount) {
        }

        /**
         * Touch event handler. Called for every touch point in some touch event.
         *
         * If the touch event has been emitted with direct touch device
         * (touch screen) then x and y arguments designate touch point position
         * relative to the top-left corner of the view and xAbs and yAbs
         * arguments designate position relative to the top-left corner of the
         * screen. Both positions are measured in pixels.
         *
         * If the touch event has been emitted with indirect touch device
         * (touch pad) then x and y arguments designate normalized touch point
         * position. It is measured between (0,0) and (10000,10000), where (0,0)
         * is the top-left and (10000,10000) is the bottom-right position on
         * the indirect touch input device (touch pad). xAbs and yAbs
         * arguments are equal values of x and y arguments respectively.
         *
         * @see #handleBeginTouchEvent(com.sun.glass.ui.View, long, int, boolean, int)
         *
         * @param type touch event type. One of constants declared in
         *        #com.sun.glass.events.TouchEvent class.
         * @param touchId touch point identifier;
         *        every touch point has its own unique identifier;
         *        the identifier remains the same across multiple calls of
         *        #handleNextTouchEvent method for the same touch point until
         *        it is not released.
         * @param x the X coordinate of the touch point;
         * @param y the Y coordinate of the touch point;
         * @param xAbs absolute X coordinate of the touch point;
         * @param yAbs absolute Y coordinate of the touch point;
         */
        public void handleNextTouchEvent(View view, long time, int type,
                                         long touchId, int x, int y, int xAbs,
                                         int yAbs) {
        }

        /**
         * Touch event handler. Called to notify that all #handleNextTouchEvent
         * methods corresponding to some touch event have been called already.
         *
         * @see #handleBeginTouchEvent(com.sun.glass.ui.View, long, int, boolean, int)
         */
        public void handleEndTouchEvent(View view, long time) {
        }

        /**
         * Scroll gesture handler.
         *
         * If underlying system supports coordinates for gestures then x and y
         * arguments designate gesture position relative to the top-left
         * corner of the view and xAbs and yAbs designate gesture position
         * relative to the top-left corner of the screen. For gestures emitted
         * from direct touch input device (touch screen) positions are measured
         * in pixels. For gestures emitted from indirect touch input device
         * (touch pad) positions are normalized. For details of normalized
         * touch input position see #handleBeginTouchEvent method.
         *
         * If underlying system doesn't support coordinates for gestures then
         * x and y arguments designate mouse position relative to the top-left
         * corner of the view and xAbs and yAbs designate mouse position
         * relative to the top-left corner of the screen. Positions are measured
         * in pixels.
         *
         * If gesture handler is called to notify end of gesture, i.e. value of
         * type argument is equal to
         * com.sun.glass.events.GestureEvent.GESTURE_FINISHED constant then
         * x, y, xAbs and yAbs arguments may be set to View.GESTURE_NO_VALUE
         * constant indicating no data is available. This is implementation
         * specific behavior.
         *
         * Values of dx and dy arguments are always 0.0 if type argument
         * is set to com.sun.glass.events.GestureEvent.GESTURE_FINISHED
         * constant.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * @param type gesture state. One of constants declared in
         *        #com.sun.glass.events.GestureEvent class.
         * @param isInertia if gesture is caused by inertia.
         * @param touchCount number of touch points at
         *        the moment of gesture execution; it is always set to
         *        View.GESTURE_NO_VALUE constant if value of type argument is
         *        set to com.sun.glass.events.GestureEvent.GESTURE_FINISHED
         *        constant
         * @param x the X coordinate of the gesture;
         * @param y the Y coordinate of the gesture;
         * @param xAbs absolute X coordinate of the gesture;
         * @param yAbs absolute Y coordinate of the gesture;
         * @param dx horizontal scroll delta. Positive if scrolling from
         *        left to right, non-positive otherwise
         * @param dy vertical scroll delta. Positive if scrolling from
         *        up to down, non-positive otherwise
         * @param totaldx total horizontal scroll calculated from all
         *        sequential scroll gestures, i.e. sum of all 'dx' values from
         *        previous sequential calls to this method
         * @param totaldy total vertical scroll calculated from all
         *        sequential scroll gestures, i.e. sum of all 'dy' values from
         *        previous sequential calls to this method
         * @param multiplierX the X multiplier
         * @param multiplierY the Y multiplier
         *
         * Multiplers are used when an app receives a non-zero unit values (i.e.
         * either the lines or chars are not zeroes), but wants instead get delta
         * values in pixels. In this case the app needs to multiply the deltas
         * on the provided multiplier parameter.
         */
        public void handleScrollGestureEvent(View view, long time, int type,
                                             int modifiers, boolean isDirect,
                                             boolean isInertia, int touchCount,
                                             int x, int y, int xAbs, int yAbs,
                                             double dx, double dy,
                                             double totaldx, double totaldy,
                                             double multiplierX, double multiplierY) {
        }

        /**
         * Zoom gesture handler.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * For description of isInertia argument see #handleScrollGestureEvent
         * method.
         *
         * For description of type, x,y, xAbs and yAbs arguments
         * see #handleBeginTouchEvent method.
         *
         * If underlying system doesn't support measurement of expansion value
         * in zoom gestures then expansion and totalexpansion arguments are
         * always set to View.GESTURE_NO_DOUBLE_VALUE.
         *
         * If type argument is set to
         * com.sun.glass.events.GestureEvent.GESTURE_FINISHED constant value of
         * scale argument is always set to View.GESTURE_NO_DOUBLE_VALUE constant
         * and expansion argument is always 0.0.
         *
         * @param scale current zoom delta; the value is multiplicative
         *        and not additive.
         * @param expansion current expansion delta. Measured in pixels on
         *        direct touch input devices and normalized values on indirect
         *        touch input devices. See #handleBeginTouchEvent for
         *        description of units of indirect touch input devices.
         * @param totalscale total zoom calculated from all
         *        sequential zoom gestures, i.e. sum of all 'scale' values from
         *        previous sequential calls to this method
         * @param totalexpansion total expansion calculated from all
         *        sequential zoom gestures, i.e. sum of all 'expansion' values
         *        from previous sequential calls of this method
         */
        public void handleZoomGestureEvent(View view, long time, int type,
                                           int modifiers, boolean isDirect,
                                           boolean isInertia, int x, int y,
                                           int xAbs, int yAbs, double scale,
                                           double expansion, double totalscale,
                                           double totalexpansion) {
        }

        /**
         * Rotation gesture handler.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * For description of isInertia argument see #handleScrollGestureEvent
         * method.
         *
         * For description of type, x,y, xAbs and yAbs arguments
         * see #handleBeginTouchEvent method.
         *
         * @param dangle current angle delta in degrees. Positive for clockwise
         *        rotation
         * @param totalangle total angle calculated from all
         *        sequential rotation gestures, i.e. sum of all 'dangle' values
         *        from previous sequential calls of this method
         */
        public void handleRotateGestureEvent(View view, long time, int type,
                                             int modifiers, boolean isDirect,
                                             boolean isInertia, int x, int y,
                                             int xAbs, int yAbs, double dangle,
                                             double totalangle) {
        }

        /**
         * Swipe gesture handler.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * For description of isInertia and touchCount arguments
         * see #handleScrollGestureEvent method.
         *
         * For description of type, x,y, xAbs and yAbs arguments
         * see #handleBeginTouchEvent method.
         *
         * @param dir gesture direction.
         *        One of constants defined in com.sun.glass.events.SwipeGesture
         *        class.
         */
        public void handleSwipeGestureEvent(View view, long time, int type,
                                            int modifiers, boolean isDirect,
                                            boolean isInertia, int touchCount,
                                            int dir, int x, int y, int xAbs,
                                            int yAbs) {
        }

        public Accessible getSceneAccessible() {
            return null;
        }
    }

    public static long getMultiClickTime() {
        Application.checkEventThread();
        return Application.GetApplication().staticView_getMultiClickTime();
    }

    public static int getMultiClickMaxX() {
        Application.checkEventThread();
        return Application.GetApplication().staticView_getMultiClickMaxX();
    }

    public static int getMultiClickMaxY() {
        Application.checkEventThread();
        return Application.GetApplication().staticView_getMultiClickMaxY();
    }

    protected abstract void _enableInputMethodEvents(long ptr, boolean enable);
    protected void _finishInputMethodComposition(long ptr) {
        // Action needed only on Windows.
    }

    /*
        Read by the checkNotClosed method which could be called from lock/unlock on render thread
     */
    private volatile long ptr; // Native handle (NSView*, or internal structure pointer)
    private Window window; // parent window
    private EventHandler eventHandler;

    private int width = -1;     // not set
    private int height = -1;    // not set

    private boolean isValid = false; // true between ViewEvent.Add &amp; ViewEvent.REMOVE
    private boolean isVisible = false;
    private boolean inFullscreen = false;

    static final public class Capability {
        // we need these for native code
        @Native static final public int k3dKeyValue                     = 0;
        @Native static final public int kSyncKeyValue                   = 1;
        @Native static final public int k3dProjectionKeyValue           = 2;
        @Native static final public int k3dProjectionAngleKeyValue      = 3;
        @Native static final public int k3dDepthKeyValue                = 4;
        @Native static final public int kHiDPIAwareKeyValue             = 5;

        static final public Object k3dKey                       = Integer.valueOf(k3dKeyValue); // value must be Boolean
        static final public Object kSyncKey                     = Integer.valueOf(kSyncKeyValue); // value must be Boolean
        static final public Object k3dProjectionKey             = Integer.valueOf(k3dProjectionKeyValue); // value must be Boolean
        static final public Object k3dProjectionAngleKey        = Integer.valueOf(k3dProjectionAngleKeyValue); // value must be Float
        static final public Object k3dDepthKey                  = Integer.valueOf(k3dDepthKeyValue); // value must be Integer(depth), where depth = 0, 4, 8, 16, 32etc
        static final public Object kHiDPIAwareKey               = Integer.valueOf(kHiDPIAwareKeyValue); // value must be Boolean; default = false (i.e. NOT HiDPI-aware)
    }


    protected abstract long _create(Map capabilities);
    protected View() {
        Application.checkEventThread();
        this.ptr = _create(Application.GetApplication().getDeviceDetails());
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform view&quot;);
        }
    }

    private void checkNotClosed() {
        if (this.ptr == 0L) {
            throw new IllegalStateException(&quot;The view has already been closed&quot;);
        }
    }

    public boolean isClosed() {
        Application.checkEventThread();
        return this.ptr == 0L;
    }

    protected abstract long _getNativeView(long ptr);
    /**
     * On Windows ptr is a pointer to a native structure.
     * However, for external clients of the API, a HWND has to be returned.
     * Hence the native method.
     */
    public long getNativeView() {
        Application.checkEventThread();
        checkNotClosed();
        return _getNativeView(this.ptr);
    }

    /** Only used on Mac when run inside a plugin */
    public int getNativeRemoteLayerId(String serverName) {
        Application.checkEventThread();
        throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
    }

    public Window getWindow() {
        Application.checkEventThread();
        return this.window;
    }

    protected abstract int _getX(long ptr);
    /** X coordinate relative to the host (window or applet). */
    public int getX() {
        Application.checkEventThread();
        checkNotClosed();
        return _getX(this.ptr);
    }

    protected abstract int _getY(long ptr);
    /** Y coordinate relative to the host (window or applet). */
    public int getY() {
        Application.checkEventThread();
        checkNotClosed();
        return _getY(this.ptr);
    }

    public int getWidth() {
        Application.checkEventThread();
        return this.width;
    }

    public int getHeight() {
        Application.checkEventThread();
        return this.height;
    }

    protected abstract void _setParent(long ptr, long parentPtr);
    // Window calls the method from Window.setView()
    // package private
    void setWindow(Window window) {
        Application.checkEventThread();
        checkNotClosed();
        this.window = window;
        _setParent(this.ptr, window == null ? 0L : window.getNativeHandle());
        this.isValid = this.ptr != 0 &amp;&amp; window != null;
    }

    // package private
    void setVisible(boolean visible) {
        this.isVisible = visible;
    }

    protected abstract boolean _close(long ptr);
    public void close() {
        Application.checkEventThread();
        if (this.ptr == 0) {
            return;
        }
        if (isInFullscreen()) {
            _exitFullscreen(this.ptr, false);
        }
        Window host = getWindow();
        if (host != null) {
            host.setView(null); // will call this.setWindow(null)
        }
        this.isValid = false;
        _close(this.ptr);
        this.ptr = 0;
    }

    public EventHandler getEventHandler() {
        Application.checkEventThread();
        return this.eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        Application.checkEventThread();
        this.eventHandler = eventHandler;
    }

    //-------- EVENTS --------//

    private void handleViewEvent(long time, int type) {
        if (this.eventHandler != null) {
            this.eventHandler.handleViewEvent(this, time, type);
        }
    }

    private void handleKeyEvent(long time, int action,
            int keyCode, char[] keyChars, int modifiers) {
        if (this.eventHandler != null) {
            this.eventHandler.handleKeyEvent(this, time, action, keyCode, keyChars, modifiers);
        }
    }

    private void handleMouseEvent(long time, int type, int button, int x, int y,
                                  int xAbs, int yAbs,
                                  int modifiers, boolean isPopupTrigger,
                                  boolean isSynthesized) {
        if (eventHandler != null) {
            eventHandler.handleMouseEvent(this, time, type, button, x, y, xAbs,
                                          yAbs, modifiers,
                                          isPopupTrigger, isSynthesized);
        }
    }

    private void handleMenuEvent(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {
        if (this.eventHandler != null) {
            this.eventHandler.handleMenuEvent(this, x, y, xAbs, yAbs, isKeyboardTrigger);
        }
    }

    public void handleBeginTouchEvent(View view, long time, int modifiers,
                                      boolean isDirect, int touchEventCount) {
        if (eventHandler != null) {
            eventHandler.handleBeginTouchEvent(view, time, modifiers, isDirect,
                    touchEventCount);
        }
    }

    public void handleNextTouchEvent(View view, long time, int type,
                                     long touchId, int x, int y, int xAbs,
                                     int yAbs) {
        if (eventHandler != null) {
            eventHandler.handleNextTouchEvent(view, time, type, touchId, x, y, xAbs, yAbs);
        }
    }

    public void handleEndTouchEvent(View view, long time) {
        if (eventHandler != null) {
            eventHandler.handleEndTouchEvent(view, time);
        }
    }

    public void handleScrollGestureEvent(View view, long time, int type,
                                         int modifiers, boolean isDirect,
                                         boolean isInertia, int touchCount,
                                         int x, int y, int xAbs, int yAbs,
                                         double dx, double dy, double totaldx,
                                         double totaldy, double multiplierX,
                                         double multiplierY) {
        if (eventHandler != null) {
            eventHandler.handleScrollGestureEvent(view, time, type, modifiers, isDirect,
                    isInertia, touchCount, x, y, xAbs, yAbs,
                    dx, dy, totaldx, totaldy, multiplierX, multiplierY);
        }
    }

    public void handleZoomGestureEvent(View view, long time, int type,
                                       int modifiers, boolean isDirect,
                                       boolean isInertia, int originx,
                                       int originy, int originxAbs,
                                       int originyAbs, double scale,
                                       double expansion, double totalscale,
                                       double totalexpansion) {
        if (eventHandler != null) {
            eventHandler.handleZoomGestureEvent(view, time, type, modifiers, isDirect,
                                     isInertia, originx, originy, originxAbs,
                                     originyAbs, scale, expansion, totalscale,
                                     totalexpansion);
        }
    }

    public void handleRotateGestureEvent(View view, long time, int type,
                                         int modifiers, boolean isDirect,
                                         boolean isInertia, int originx,
                                         int originy, int originxAbs,
                                         int originyAbs, double dangle,
                                         double totalangle) {
        if (eventHandler != null) {
            eventHandler.handleRotateGestureEvent(view, time, type, modifiers, isDirect,
                    isInertia, originx, originy, originxAbs,
                    originyAbs, dangle, totalangle);
        }
    }

    public void handleSwipeGestureEvent(View view, long time, int type,
                                        int modifiers, boolean isDirect,
                                        boolean isInertia, int touchCount,
                                        int dir, int originx, int originy,
                                        int originxAbs, int originyAbs) {
        if (eventHandler != null) {
            eventHandler.handleSwipeGestureEvent(view, time, type, modifiers, isDirect,
                    isInertia, touchCount, dir, originx,
                    originy, originxAbs, originyAbs);
        }
    }

    private void handleInputMethodEvent(long time, String text, int[] clauseBoundary,
<A NAME="21"></A>                int[] attrBoundary, byte[] attrValue,
                int commitCount, int cursorPos) {
        if (this.eventHandler != null) {
            <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#21',2,'match44-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.eventHandler.handleInputMethodEvent(time, text, clauseBoundary,
                attrBoundary, attrValue,
                commitCount, cursorPos);
        }
    }

    public void enableInputMethodEvents(boolean enable) {
        Application.checkEventThread();
        checkNotClosed();
        _enableInputMethodEvents(this.ptr, enable);
    }

    public void finishInputMetho</B></FONT>dComposition() {
        Application.checkEventThread();
        checkNotClosed();
        _finishInputMethodComposition(this.ptr);
    }

    private double[] getInputMethodCandidatePos(int offset) {
        if (this.eventHandler != null) {
            return this.eventHandler.getInputMethodCandidatePos(offset);
        }
        return null;
    }

    private void handleDragStart(int button, int x, int y, int xAbs, int yAbs,
            ClipboardAssistance dropSourceAssistant) {
        if (this.eventHandler != null) {
            this.eventHandler.handleDragStart(this, button, x, y, xAbs, yAbs, dropSourceAssistant);
        }
    }

    private void handleDragEnd(int performedAction) {
        if (this.eventHandler != null) {
            this.eventHandler.handleDragEnd(this, performedAction);
        }
    }

    private int handleDragEnter(int x, int y, int xAbs, int yAbs,
            int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            return this.eventHandler.handleDragEnter(this, x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        } else {
            return recommendedDropAction;
        }
    }

    private int handleDragOver(int x, int y, int xAbs, int yAbs,
            int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            return this.eventHandler.handleDragOver(this, x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        } else {
            return recommendedDropAction;
        }
    }

    private void handleDragLeave(ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            this.eventHandler.handleDragLeave(this, dropTargetAssistant);
        }
    }

    private int handleDragDrop(int x, int y, int xAbs, int yAbs,
            int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            return this.eventHandler.handleDragDrop(this, x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        } else {
            return Clipboard.ACTION_NONE;
        }
    }

    //-------- DRAWING --------//
    protected abstract void _scheduleRepaint(long ptr);
    /** marks native surface dirty, so the system itself will create repaint event
     * */
    public void scheduleRepaint() {
        Application.checkEventThread();
        checkNotClosed();
        _scheduleRepaint(this.ptr);
    }

    protected abstract void _begin(long ptr);
    /** prepares to painting by locking native surface
     *
     * Called on the render thread
     */
    public void lock() {
        checkNotClosed();
        _begin(this.ptr);
    }

    protected abstract void _end(long ptr);
    /** ends painting by unlocking native surface and flushing
     * flushes surface (if flush == true) or discard it (flush == false)
     *
     * Called on the render thread
     */
    public void unlock() {
        checkNotClosed();
        _end(this.ptr);
    }

    protected abstract int _getNativeFrameBuffer(long ptr);

    /**
     * Called on the renderer thread and must be between lock and unlock
     */
    public int getNativeFrameBuffer() {
        return _getNativeFrameBuffer(this.ptr);
    }


    protected abstract void _uploadPixels(long ptr, Pixels pixels);
    /**
     * This method dumps the pixels on to the view.
     *
     * NOTE: On MS Windows calling this method is REQUIRED for
     * transparent windows in order to update them.
     */
    public void uploadPixels(Pixels pixels) {
        Application.checkEventThread();
        checkNotClosed();
        lock();
        try {
            _uploadPixels(this.ptr, pixels);
        } finally {
            unlock();
        }
    }


    //-------- FULLSCREEN --------//

    protected abstract boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);
    public boolean enterFullscreen(boolean animate, boolean keepRatio, boolean hideCursor) {
        Application.checkEventThread();
        checkNotClosed();
        return _enterFullscreen(this.ptr, animate, keepRatio, hideCursor);
    }

    protected abstract void _exitFullscreen(long ptr, boolean animate);
    public void exitFullscreen(boolean animate) {
        Application.checkEventThread();
        checkNotClosed();
        _exitFullscreen(this.ptr, animate);
    }

    public boolean isInFullscreen() {
        Application.checkEventThread();
        return this.inFullscreen;
    }

    public boolean toggleFullscreen(boolean animate, boolean keepRatio, boolean hideCursor) {
        Application.checkEventThread();
        checkNotClosed();
        if (!this.inFullscreen) {
            enterFullscreen(animate, keepRatio, hideCursor);
        } else {
            exitFullscreen(animate);
        }

        _scheduleRepaint(this.ptr);

        return this.inFullscreen;
    }

    public void updateLocation() {
        notifyView(ViewEvent.MOVE);
    }


    //-------- DELEGATE NOTIFICATIONS --------//

    protected void notifyView(int type) {
        //System.err.println(&quot;    notifyView: &quot;+ViewEvent.getTypeString(type)+&quot; on thread&quot;+Thread.currentThread());
        if (type == ViewEvent.REPAINT) {
            if (isValid) {
                handleViewEvent(System.nanoTime(), type);
            }
        }
        else
        {
            boolean synthesizeMOVE = false;

            switch (type) {
                case ViewEvent.REMOVE:
                    isValid = false;
                    synthesizeMOVE = true;
                    break;
                case ViewEvent.ADD:
                    isValid = true;
                    synthesizeMOVE = true;
                    break;
                case ViewEvent.FULLSCREEN_ENTER:
                    this.inFullscreen = true;
                    synthesizeMOVE = true;
                    if (getWindow() != null) {
                        getWindow().notifyFullscreen(true);
                    }
                    break;
                case ViewEvent.FULLSCREEN_EXIT:
                    this.inFullscreen = false;
                    synthesizeMOVE = true;
                    if (getWindow() != null) {
                        getWindow().notifyFullscreen(false);
                    }
                    break;
                case ViewEvent.MOVE:
                case ViewEvent.RESIZE:
                    break;
                default:
                    System.err.println(&quot;Unknown view event type: &quot; + type);
                    return;
            }

            handleViewEvent(System.nanoTime(), type);

            if (synthesizeMOVE) {
                // Generate MOVE event to update current insets. Native code may
                // send additional MOVE events when it detects insets change.
                handleViewEvent(System.nanoTime(), ViewEvent.MOVE);
            }
        }
    }

    protected void notifyResize(int width, int height) {
        if (this.width == width &amp;&amp; this.height == height) {
            return;
        }

        this.width = width;
        this.height = height;
        handleViewEvent(System.nanoTime(), ViewEvent.RESIZE);
    }

    /*
     * x, y, width, heigth define the &quot;dirty&quot; rect
     */
    protected void notifyRepaint(int x, int y, int width, int height) {
        notifyView(ViewEvent.REPAINT);
    }


    // ------------ MENU EVENT HANDLING -----------------
//    protected void notifyMenu(int type, int button, int x, int y, int xAbs, int yAbs, int keyCode, char[] keyChars, int modifiers) {
        protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {
        handleMenuEvent(x, y, xAbs, yAbs, isKeyboardTrigger);
    }

    // ------------ MOUSE EVENTS HANDLING -----------------

    // Synchronized on the Main thread of the underlying native system
    private static WeakReference&lt;View&gt; lastClickedView = null;
    private static int lastClickedButton;
    private static long lastClickedTime;
    private static int lastClickedX, lastClickedY;
    private static int clickCount;
    private static boolean dragProcessed = false;

    protected void notifyMouse(int type, int button, int x, int y, int xAbs,
                               int yAbs, int modifiers, boolean isPopupTrigger,
                               boolean isSynthesized) {
        // gznote: optimize - only call for undecorated Windows!
        if (this.window != null) {
            // handled by window (programmatical move/resize)
            if (this.window.handleMouseEvent(type, button, x, y, xAbs, yAbs)) {
                // The evnet has been processed by Glass
                return;
            }
        }

        long now = System.nanoTime();
        if (type == MouseEvent.DOWN) {
            View lastClickedView = View.lastClickedView == null ? null : View.lastClickedView.get();

            if (lastClickedView == this &amp;&amp;
                    lastClickedButton == button &amp;&amp;
                    (now - lastClickedTime) &lt;= 1000000L*getMultiClickTime() &amp;&amp;
                    Math.abs(x - lastClickedX) &lt;= getMultiClickMaxX() &amp;&amp;
                    Math.abs(y - lastClickedY) &lt;= getMultiClickMaxY())
            {
                clickCount++;
            } else {
                clickCount = 1;

                View.lastClickedView = new WeakReference&lt;View&gt;(this);
                lastClickedButton = button;
                lastClickedX = x;
                lastClickedY = y;
            }

            lastClickedTime = now;
        }

        handleMouseEvent(now, type, button, x, y, xAbs, yAbs,
                         modifiers, isPopupTrigger, isSynthesized);

        if (type == MouseEvent.DRAG) {
            // Send the handleDragStart() only once per a drag gesture
            if (!dragProcessed) {
                notifyDragStart(button, x, y, xAbs, yAbs);
                dragProcessed = true;
            }
        } else {
            dragProcessed = false;
        }
    }

    // ------------- END OF MOUSE EVENTS -----------------

    protected void notifyScroll(int x, int y, int xAbs, int yAbs,
            double deltaX, double deltaY, int modifiers, int lines, int chars,
            int defaultLines, int defaultChars,
            double xMultiplier, double yMultiplier)
    {
        if (this.eventHandler != null) {
            this.eventHandler.handleScrollEvent(this, System.nanoTime(),
                    x, y, xAbs, yAbs, deltaX, deltaY, modifiers, lines, chars,
                    defaultLines, defaultChars, xMultiplier, yMultiplier);
        }
    }

    protected void notifyKey(int type, int keyCode, char[] keyChars, int modifiers) {
        handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers);
    }

    protected void notifyInputMethod(String text, int[] clauseBoundary,
        int[] attrBoundary, byte[] attrValue,
        int committedTextLength, int caretPos, int visiblePos) {
        handleInputMethodEvent(System.nanoTime(), text, clauseBoundary,
                attrBoundary, attrValue, committedTextLength, caretPos);
    }

    protected double[] notifyInputMethodCandidatePosRequest(int offset) {
        double[] ret = getInputMethodCandidatePos(offset);
        if (ret == null) {
            ret = new double[2];
            ret[0] = 0.0;
            ret[1] = 0.0;
        }
        return ret;
    }

    private ClipboardAssistance dropSourceAssistant;
    protected void notifyDragStart(int button, int x, int y, int xAbs, int yAbs) {
        dropSourceAssistant = new ClipboardAssistance(Clipboard.DND) {
            @Override public void actionPerformed(int performedAction) {
                // on Windows called from DnD modal loop
                // on Mac the View is the drag delegate and calls notifyDragEnd directly
                notifyDragEnd(performedAction);
            }
        };
        //DnD loop is inside dropSourceAssistant.flush()
        handleDragStart(button, x, y, xAbs, yAbs, dropSourceAssistant);
        //utilize dropSourceAssistant if DnD was not started.
        if (dropSourceAssistant != null) {
            dropSourceAssistant.close();
            dropSourceAssistant = null;
        }
    }

    protected void notifyDragEnd(int performedAction) {
        handleDragEnd(performedAction);
        if (dropSourceAssistant != null) {
            dropSourceAssistant.close();
            dropSourceAssistant = null;
        }
    }

    ClipboardAssistance  dropTargetAssistant;
    // callback for native code
    protected int notifyDragEnter(int x, int y, int xAbs, int yAbs, int recommendedDropAction) {
        dropTargetAssistant = new ClipboardAssistance(Clipboard.DND) {
            @Override public void flush() {
                throw new UnsupportedOperationException(&quot;Flush is forbidden from target!&quot;);
            }
        };
        return handleDragEnter(x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
    }

    // callback for native code
    protected int notifyDragOver(int x, int y, int xAbs, int yAbs, int recommendedDropAction) {
        return handleDragOver(x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
    }

    // callback for native code
    protected void notifyDragLeave() {
        handleDragLeave(dropTargetAssistant);
        dropTargetAssistant.close();
    }

    // callback for native code
    // gznote: should be renamed to notifyDragDrop/notifyDragPerformed to be consistent
    protected int notifyDragDrop(int x, int y, int xAbs, int yAbs, int recommendedDropAction) {
        int performedAction = handleDragDrop(x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        dropTargetAssistant.close();
        return performedAction;
    }

    public void notifyBeginTouchEvent(int modifiers, boolean isDirect,
                                      int touchEventCount) {
        handleBeginTouchEvent(this, System.nanoTime(), modifiers, isDirect,
                              touchEventCount);
    }

    public void notifyNextTouchEvent(int type, long touchId, int x, int y,
                                     int xAbs, int yAbs) {
        handleNextTouchEvent(this, System.nanoTime(), type, touchId, x, y, xAbs,
                             yAbs);
    }

    public void notifyEndTouchEvent() {
        handleEndTouchEvent(this, System.nanoTime());
    }

    public void notifyScrollGestureEvent(int type, int modifiers,
                                         boolean isDirect, boolean isInertia,
                                         int touchCount, int x, int y, int xAbs,
                                         int yAbs, double dx, double dy,
                                         double totaldx, double totaldy,
                                         double multiplierX, double multiplierY) {
        handleScrollGestureEvent(this, System.nanoTime(), type, modifiers,
                                 isDirect, isInertia, touchCount, x, y, xAbs,
                                 yAbs, dx, dy, totaldx, totaldy, multiplierX, multiplierY);
    }

    public void notifyZoomGestureEvent(int type, int modifiers, boolean isDirect,
                                       boolean isInertia, int originx,
                                       int originy, int originxAbs,
                                       int originyAbs, double scale,
                                       double expansion, double totalscale,
                                       double totalexpansion) {
        handleZoomGestureEvent(this, System.nanoTime(), type, modifiers,
                               isDirect, isInertia, originx, originy, originxAbs,
                               originyAbs, scale, expansion, totalscale,
                               totalexpansion);
    }

    public void notifyRotateGestureEvent(int type, int modifiers,
                                         boolean isDirect, boolean isInertia,
                                         int originx, int originy,
                                         int originxAbs, int originyAbs,
                                         double dangle, double totalangle) {
        handleRotateGestureEvent(this, System.nanoTime(), type, modifiers,
                                 isDirect, isInertia, originx, originy,
                                 originxAbs, originyAbs, dangle, totalangle);
    }

    public void notifySwipeGestureEvent(int type, int modifiers,
                                        boolean isDirect, boolean isInertia,
                                        int touchCount, int dir, int originx,
                                        int originy, int originxAbs,
                                        int originyAbs) {
        handleSwipeGestureEvent(this, System.nanoTime(), type, modifiers,
                                isDirect, isInertia, touchCount, dir, originx,
                                originy, originxAbs, originyAbs);
    }

    /**
     * Returns the accessible object for the view.
     * This method is called by JNI code when the
     * platform requested the accessible peer for the view.
     * On Windows it happens on WM_GETOBJECT.
     * On Mac it happens on NSView#accessibilityAttributeNames.
     */
    long getAccessible() {
        Application.checkEventThread();
        checkNotClosed();
        if (accessible) {
            Accessible acc = eventHandler.getSceneAccessible();
            if (acc != null) {
                acc.setView(this);
                return acc.getNativeAccessible();
            }
        }
        return 0L;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/VNCScreen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.MouseEvent;
import javafx.application.Platform;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.BitSet;
import java.util.HashSet;
import java.util.Set;

/** A headless screen that is available for remote connections using the
 * RFB 3.3 protocol on port 5901.
 */
class VNCScreen extends HeadlessScreen {

    private ServerSocketChannel server;
    private Set&lt;ClientConnection&gt; clients = new HashSet&lt;ClientConnection&gt;();

    VNCScreen() {
        super(1024, 600, 32);
        try {
            server = ServerSocketChannel.open();
            int vncPort = AccessController.doPrivileged(
                    (PrivilegedAction&lt;Integer&gt;)
                            () -&gt; Integer.getInteger(&quot;vnc.port&quot;, 5901));
            server.bind(new InetSocketAddress(vncPort));
            Thread t = new Thread(new ConnectionAccepter());
            t.setDaemon(true);
            t.setName(&quot;VNC Server on port &quot; + vncPort);
            t.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

<A NAME="2"></A>    @Override
    public void shutdown() {
        super.shutdown();
        for (<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#2',2,'match44-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ClientConnection cc : clients) {
            try {
                cc.socket.close();
            } catch (IOException e) { }
        }</B></FONT>
    }

    @Override
    public void swapBuffers() {
        ClientConnection[] ccs;
        synchronized (clients) {
            ccs = clients.toArray(new ClientConnection[clients.size()]);
        }
        for (ClientConnection cc : ccs) {
            try {
                sendBuffer(cc.socket);
            } catch (IOException e) {
                clients.remove(cc);
            }
        }
        super.swapBuffers();
    }

    private void removeClient(ClientConnection cc, IOException e) {
        synchronized (clients) {
            if (clients.contains(cc)) {
                System.out.format(&quot;Disconnecting %s: %s\n&quot;,
                                  cc.descriptor, e.getMessage());
                clients.remove(cc);
            }
        }
    }

    private void sendBuffer(WritableByteChannel out) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(16);
        buffer.order(ByteOrder.BIG_ENDIAN);
        buffer.put((byte) 0);
        buffer.put((byte) 0);
        buffer.putShort((short) 1); // rectangle count
        buffer.putShort((short) 0); // x
        buffer.putShort((short) 0); // y
        buffer.putShort((short) width);
        buffer.putShort((short) height);
        buffer.putInt(0); // raw
        buffer.flip();
        out.write(buffer);
        fb.write(out);
    }

    private class ConnectionAccepter implements Runnable {
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(64);
            buffer.order(ByteOrder.BIG_ENDIAN);
            while (true) {
                try {
                    SocketChannel client = server.accept();
                    System.out.format(&quot;Connection received from %s\n&quot;,
                                      client.getRemoteAddress());
                    // Declare the server protocol version
                    buffer.clear();
                    buffer.put(&quot;RFB 003.003\n&quot;.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    // Read the client protocol version
                    buffer.clear();
                    buffer.limit(12);
                    client.read(buffer);
                    buffer.flip();
                    System.out.format(&quot;Client supports %s\n&quot;,
                                      Charset.forName(&quot;UTF-8&quot;)
                                              .decode(buffer).toString().trim());
                    buffer.clear();
                    buffer.putInt(1); // no authentication
                    buffer.flip();
                    client.write(buffer);
                    buffer.clear();
                    buffer.limit(1);
                    client.read(buffer);
                    System.out.format(&quot;Client share request: %d\n&quot;,
                                      buffer.get(0));
                    buffer.clear();
                    buffer.putShort((short) width);
                    buffer.putShort((short) height);
                    buffer.put((byte) depth);
                    buffer.put((byte) depth);
                    buffer.put((byte) (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN) ? 0 : 1));
                    buffer.put((byte) 1); // true color
                    if (depth == 32) {
                        buffer.putShort((short) 255); // red max
                        buffer.putShort((short) 255); // green max
                        buffer.putShort((short) 255); // blue max
                        buffer.put((byte) 16); // red offset
                        buffer.put((byte) 8); // blue offset
                        buffer.put((byte) 0); // green offset
                    } else {
                        buffer.putShort((byte) (short) 31);
                        buffer.putShort((byte) (short) 63);
                        buffer.putShort((byte) (short) 31);
                        buffer.put((byte) 11);
                        buffer.put((byte) 5);
                        buffer.put((byte) 0);
                    }
                    buffer.put((byte) 0); // padding
                    buffer.put((byte) 0);
                    buffer.put((byte) 0);
                    String name = &quot;JavaFX on &quot; + client.getLocalAddress();
                    buffer.putInt(name.length());
                    buffer.put(name.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    ClientConnection cc = new ClientConnection();
                    cc.socket = client;
                    Thread t = new Thread(cc);
                    t.setDaemon(true);
                    t.setName(&quot;VNC client connection from &quot;
                                      + client.getRemoteAddress());
                    t.start();
                    synchronized (clients) {
                        clients.add(cc);
                    }
                    sendBuffer(client);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private class ClientConnection implements Runnable {
        private SocketChannel socket;
        private String descriptor;
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(32);
            buffer.order(ByteOrder.BIG_ENDIAN);
            try {
                descriptor = socket.getRemoteAddress().toString();
                while (true) {
                    buffer.clear();
                    buffer.limit(4);
                    socket.read(buffer);
                    switch (buffer.get(0)) {
                        case 0: // SetPixelFormat
                            // discard the message in the next 16 bytes
                            buffer.clear();
                            buffer.limit(16);
                            socket.read(buffer);
                            break;
                        case 1: // FixColorMapEntries
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            // discard color map entries
                            int colorMapEntryCount = buffer.getShort(0);
                            for (int i = 0; i &lt; colorMapEntryCount; i++) {
                                buffer.clear();
                                buffer.limit(6);
                                socket.read(buffer);
                            }
                            break;
                        case 2: // SetEncodings
                            // discard encodings
                            int encodingCount = buffer.getShort(2);
                            for (int i = 0; i &lt; encodingCount; i++) {
                                buffer.clear();
                                buffer.limit(4);
                                socket.read(buffer);
                            }
                        case 3: // FramebufferUpdateRequest
                            buffer.clear();
                            buffer.limit(6);
                            socket.read(buffer);
                            Platform.runLater(() -&gt; {
                                try {
                                    if (fb.hasReceivedData()) {
                                        // an update is in progress and will
                                        // be sent on the next call to
                                        // swapBuffers. No need to
                                        // respond to this request.
                                    } else {
                                        sendBuffer(socket);
                                    }
                                } catch (IOException e) {
                                    removeClient(ClientConnection.this, e);
                                }
                            });
                            break;
                        case 4: // KeyEvent
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            break;
                        case 5: { // PointerEvent
                            int x = buffer.getShort(2);
                            buffer.position(1);
                            buffer.limit(2);
                            BitSet buttons = BitSet.valueOf(buffer);
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            int y = buffer.getShort(0);
                            final MouseState state = new MouseState();
                            state.setX(x);
                            state.setY(y);
                            if (buttons.get(0)) {
                                state.pressButton(MouseEvent.BUTTON_LEFT);
                            }
                            if (buttons.get(1)) {
                                state.pressButton(MouseEvent.BUTTON_OTHER);
                            }
                            if (buttons.get(2)) {
                                state.pressButton(MouseEvent.BUTTON_RIGHT);
                            }
                            Platform.runLater(() -&gt; MouseInput.getInstance().setState(state, false));
                            break;
                        }
                        case 6: // ClientCutText
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            int textLength = buffer.getInt(0);
                            for (int i = 0; i &lt; textLength; i++) {
                                buffer.clear();
                                buffer.limit(1);
                                socket.read(buffer);
                            }
                            break;
                        default:
                            System.err.format(
                                    &quot;Unknown message %d from client %s\n&quot;,
                                    buffer.get(0), socket.getRemoteAddress());
                    }
                }
            } catch (IOException e) {
                removeClient(this, e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/application/HostServicesDelegate.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.application;

import java.awt.Desktop;
import java.io.File;
import java.net.URI;
import javafx.application.Application;

public abstract class HostServicesDelegate {

    public static HostServicesDelegate getInstance(final Application app) {
        return StandaloneHostService.getInstance(app);
    }

    protected HostServicesDelegate() {
    }

    public abstract String getCodeBase();

    public abstract String getDocumentBase();

    public abstract void showDocument(String uri);

    // StandaloneHostService implementation
    private static class StandaloneHostService extends HostServicesDelegate {

        private static HostServicesDelegate instance = null;

        private Class appClass = null;

        public static HostServicesDelegate getInstance(Application app) {
            synchronized (StandaloneHostService.class) {
                if (instance == null) {
                    instance = new StandaloneHostService(app);
                }
                return instance;
            }
        }

        private StandaloneHostService(Application app) {
             appClass = app.getClass();
        }

        @Override
        public String getCodeBase() {
            // If the application was launched in standalone mode, this method
            // returns the directory containing the application jar file.
            // If the application is not packaged in a jar file, this method
            // returns the empty string.
            String theClassFile = appClass.getName();
            int idx = theClassFile.lastIndexOf(&quot;.&quot;);
            if (idx &gt;= 0) {
                // Strip off package name prefix in class name if exists
                // getResoruce will automatically add in package name during
                // lookup; see Class.getResource javadoc for more details
                theClassFile = theClassFile.substring(idx + 1);
            }
            theClassFile = theClassFile + &quot;.class&quot;;

            String classUrlString = appClass.getResource(theClassFile).toString();
            if (!classUrlString.startsWith(&quot;jar:file:&quot;) ||
                    classUrlString.indexOf(&quot;!&quot;) == -1) {
                return &quot;&quot;;
            }
            // Strip out the &quot;jar:&quot; and everything after and including the &quot;!&quot;
            String urlString = classUrlString.substring(4,
                    classUrlString.lastIndexOf(&quot;!&quot;));
            File jarFile = null;
            try {
                jarFile = new File(new URI(urlString).getPath());
            } catch (Exception e) {
                // should not happen
            }
            if (jarFile != null) {
                String codebase = jarFile.getParent();
                if (codebase != null) {
                    return toURIString(codebase);
                }
            }

            return &quot;&quot;;
        }
<A NAME="48"></A>
        private String toURIString(String filePath) {
            try {
                return <FONT color="#c57726"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#48',2,'match44-top.html#48',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new File(filePath).toURI().toString();
            } catch (Exception e) {
                // should not happen
                // dump stack for debug purpose
                e.printStackTrace();
            }</B></FONT>
            return &quot;&quot;;
        }

        @Override public String getDocumentBase() {
            // If the application was launched in standalone mode,
            // this method returns the URI of the current directory.
            return toURIString(System.getProperty(&quot;user.dir&quot;));
        }

        static final String[] browsers = {&quot;google-chrome&quot;, &quot;firefox&quot;, &quot;opera&quot;,
            &quot;konqueror&quot;, &quot;mozilla&quot;};

        @Override
        public void showDocument(final String uri) {
            String osName = System.getProperty(&quot;os.name&quot;);
            try {
                if (osName.startsWith(&quot;Mac OS&quot;)) {
                    Desktop.getDesktop().browse(URI.create(uri));
                } else if (osName.startsWith(&quot;Windows&quot;)) {
                    Runtime.getRuntime().exec(
                            &quot;rundll32 url.dll,FileProtocolHandler &quot; + uri);
                } else { //assume Unix or Linux
                    String browser = null;
                    for (String b : browsers) {
                        if (browser == null &amp;&amp; Runtime.getRuntime().exec(
                                new String[]{&quot;which&quot;, b}).getInputStream().read() != -1) {
                            Runtime.getRuntime().exec(new String[]{browser = b, uri});
                        }
                    }
                    if (browser == null) {
                        throw new Exception(&quot;No web browser found&quot;);
                    }
                }
            } catch (Exception e) {
                // should not happen
                // dump stack for debug purpose
                e.printStackTrace();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/application/LauncherImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.application;

import javafx.application.Application;
import javafx.application.Preloader;
import javafx.application.Preloader.ErrorNotification;
import javafx.application.Preloader.PreloaderNotification;
import javafx.application.Preloader.StateChangeNotification;
import javafx.stage.Stage;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.Base64;
import java.util.Optional;
import com.sun.javafx.stage.StageHelper;


public class LauncherImpl {
    /**
     * When passed as launchMode to launchApplication, tells the method that
     * launchName is the name of the JavaFX application class to launch.
     */
    public static final String LAUNCH_MODE_CLASS = &quot;LM_CLASS&quot;;

    /**
     * When passed as launchMode to launchApplication, tells the method that
     * launchName is a path to a JavaFX application jar file to be launched.
     */
    public static final String LAUNCH_MODE_JAR = &quot;LM_JAR&quot;;

    /**
     * When passed as launchMode to launchApplication, tells the method that
     * launchName is the name of the JavaFX application class within a module
     * to be launched. Either the class name will be provided or the main class
     * will be defined in the module's descriptor.
     */
    public static final String LAUNCH_MODE_MODULE = &quot;LM_MODULE&quot;;

    // set to true to debug launch issues from Java launcher
    private static final boolean trace = false;

    // set system property javafx.verbose to true to make the launcher noisy
    private static final boolean verbose;

    private static final String MF_MAIN_CLASS = &quot;Main-Class&quot;;
    private static final String MF_JAVAFX_MAIN = &quot;JavaFX-Application-Class&quot;;
    private static final String MF_JAVAFX_PRELOADER = &quot;JavaFX-Preloader-Class&quot;;
    private static final String MF_JAVAFX_CLASS_PATH = &quot;JavaFX-Class-Path&quot;;
    private static final String MF_JAVAFX_ARGUMENT_PREFIX = &quot;JavaFX-Argument-&quot;;
    private static final String MF_JAVAFX_PARAMETER_NAME_PREFIX = &quot;JavaFX-Parameter-Name-&quot;;
    private static final String MF_JAVAFX_PARAMETER_VALUE_PREFIX = &quot;JavaFX-Parameter-Value-&quot;;

    // Set to true to simulate a slow download progress
    private static final boolean simulateSlowProgress = false;

    // Ensure that launchApplication method is only called once
    private static AtomicBoolean launchCalled = new AtomicBoolean(false);

    // Flag indicating that the toolkit has been started
    private static final AtomicBoolean toolkitStarted = new AtomicBoolean(false);

    // Exception found during launching
    private static volatile RuntimeException launchException = null;

    // The current preloader, used for notification in the standalone
    // launcher mode
    private static Preloader currentPreloader = null;

    // Saved preloader class from the launchApplicationWithArgs method (called
    // from the Java 8 launcher). It is used in the case where we call main,
    // which is turn calls into launchApplication.
    private static Class&lt;? extends Preloader&gt; savedPreloaderClass = null;

    // The following is used to determine whether the main() method
    // has set the CCL in the case where main is called after the FX toolkit
    // is started.
    private static ClassLoader savedMainCcl = null;

    static {
        verbose = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
                Boolean.getBoolean(&quot;javafx.verbose&quot;));
    }

    /**
     * This method is called by the Application.launch method.
     * It must not be called more than once or an exception will be thrown.
     *
     * Note that it is always called on a thread other than the FX application
     * thread, since that thread is only created at startup.
     *
     * @param appClass application class
     * @param args command line arguments
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void launchApplication(final Class&lt;? extends Application&gt; appClass,
            final String[] args) {

        Class&lt;? extends Preloader&gt; preloaderClass = savedPreloaderClass;

        if (preloaderClass == null) {
            String preloaderByProperty = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
                    System.getProperty(&quot;javafx.preloader&quot;));
            if (preloaderByProperty != null) {
                try {
                    preloaderClass = (Class&lt;? extends Preloader&gt;) Class.forName(preloaderByProperty,
                            false, appClass.getClassLoader());
                } catch (Exception e) {
                    System.err.printf(&quot;Could not load preloader class '&quot; + preloaderByProperty +
                            &quot;', continuing without preloader.&quot;);
                    e.printStackTrace();
                }
            }
        }

        launchApplication(appClass, preloaderClass, args);
    }

    /**
     * This method is called by the standalone launcher.
     * It must not be called more than once or an exception will be thrown.
     *
     * Note that it is always called on a thread other than the FX application
     * thread, since that thread is only created at startup.
     *
     * @param appClass application class
     * @param preloaderClass preloader class, may be null
     * @param args command line arguments
     */
    public static void launchApplication(final Class&lt;? extends Application&gt; appClass,
            final Class&lt;? extends Preloader&gt; preloaderClass,
            final String[] args) {

        if (launchCalled.getAndSet(true)) {
            throw new IllegalStateException(&quot;Application launch must not be called more than once&quot;);
        }

        if (! Application.class.isAssignableFrom(appClass)) {
            throw new IllegalArgumentException(&quot;Error: &quot; + appClass.getName()
                    + &quot; is not a subclass of javafx.application.Application&quot;);
        }

        if (preloaderClass != null &amp;&amp; ! Preloader.class.isAssignableFrom(preloaderClass)) {
            throw new IllegalArgumentException(&quot;Error: &quot; + preloaderClass.getName()
                    + &quot; is not a subclass of javafx.application.Preloader&quot;);
        }

//        System.err.println(&quot;launch standalone app: preloader class = &quot;
//                + preloaderClass);

        // Create a new Launcher thread and then wait for that thread to finish
        final CountDownLatch launchLatch = new CountDownLatch(1);
        Thread launcherThread = new Thread(() -&gt; {
            try {
                launchApplication1(appClass, preloaderClass, args);
            } catch (RuntimeException rte) {
                launchException = rte;
            } catch (Exception ex) {
                launchException =
                    new RuntimeException(&quot;Application launch exception&quot;, ex);
            } catch (Error err) {
                launchException =
                    new RuntimeException(&quot;Application launch error&quot;, err);
            } finally {
                launchLatch.countDown();
            }
        });
        launcherThread.setName(&quot;JavaFX-Launcher&quot;);
        launcherThread.start();

        // Wait for FX launcher thread to finish before returning to user
        try {
            launchLatch.await();
        } catch (InterruptedException ex) {
            throw new RuntimeException(&quot;Unexpected exception: &quot;, ex);
        }

        if (launchException != null) {
            throw launchException;
        }
    }

    /**
     * This method is called by the Java launcher. This allows us to be launched
     * directly from the command line via &quot;java -jar fxapp.jar&quot;,
     * &quot;java -cp path some.fx.App&quot;, or &quot;java -m module/some.fx.App&quot;. The launchMode
     * argument must be one of &quot;LM_CLASS&quot;, &quot;LM_JAR&quot;, or &quot;LM_MODULE&quot; or execution will
     * abort with an error.
     *
     * @param launchName The path to a jar file, the application class name to launch,
     * or the module and optional class name to launch
     * @param launchMode The method of launching the application, one of LM_JAR,
     * LM_CLASS, or LM_MODULE
     * @param args Application arguments from the command line
     */
    public static void launchApplication(final String launchName,
            final String launchMode,
            final String[] args) {

        if (verbose) {
            System.err.println(&quot;JavaFX launchApplication method: launchMode=&quot;
                    + launchMode);
        }

        /*
         * For now, just open the jar and get JavaFX-Application-Class and
         * JavaFX-Preloader and pass them to launchApplication. In the future
         * we'll need to load requested jar files
         */
        String mainClassName = null;
        String preloaderClassName = null;
        String[] appArgs = args;
        ClassLoader appLoader = null;
        ModuleAccess mainModule = null;

        if (launchMode.equals(LAUNCH_MODE_JAR)) {
            Attributes jarAttrs = getJarAttributes(launchName);
            if (jarAttrs == null) {
                abort(null, &quot;Can't get manifest attributes from jar&quot;);
            }

            // If we ever need to check JavaFX-Version, do that here...

            // Support JavaFX-Class-Path, but warn that it's deprecated if used
            String fxClassPath = jarAttrs.getValue(MF_JAVAFX_CLASS_PATH);
            if (fxClassPath != null) {
                if (fxClassPath.trim().length() == 0) {
                    fxClassPath = null;
                } else {
                    if (verbose) {
                        System.err.println(&quot;WARNING: Application jar uses deprecated JavaFX-Class-Path attribute.&quot;
                               +&quot; Please use Class-Path instead.&quot;);
                    }

                    /*
                     * create a new ClassLoader to pull in the requested jar files
                     * OK if it returns null, that just means we didn't need to load
                     * anything
                     */
                    appLoader = setupJavaFXClassLoader(new File(launchName), fxClassPath);
                }
            }

            // process arguments and parameters if no args have been passed by the launcher
            if (args.length == 0) {
                appArgs = getAppArguments(jarAttrs);
            }

            // grab JavaFX-Application-Class
            mainClassName = jarAttrs.getValue(MF_JAVAFX_MAIN);
            if (mainClassName == null) {
                // fall back on Main-Class if no JAC
                mainClassName = jarAttrs.getValue(MF_MAIN_CLASS);
                if (mainClassName == null) {
                    // Should not happen as the launcher enforces the presence of Main-Class
                    abort(null, &quot;JavaFX jar manifest requires a valid JavaFX-Appliation-Class or Main-Class entry&quot;);
                }
            }
            mainClassName = mainClassName.trim();

            // grab JavaFX-Preloader-Class
            preloaderClassName = jarAttrs.getValue(MF_JAVAFX_PRELOADER);
            if (preloaderClassName != null) {
                preloaderClassName = preloaderClassName.trim();
            }
        } else if (launchMode.equals(LAUNCH_MODE_CLASS)) {
            mainClassName = launchName;
        } else if (launchMode.equals(LAUNCH_MODE_MODULE)) {
            // This is largely copied from java.base/sun.launcher.LauncherHelper
            int i = launchName.indexOf('/');
            String moduleName;
            if (i == -1) {
                moduleName = launchName;
                mainClassName = null;
            } else {
                moduleName = launchName.substring(0, i);
                mainClassName = launchName.substring(i+1);
            }

            mainModule = ModuleAccess.load(moduleName);

            // get main class from module descriptor
            if (mainClassName == null) {
                Optional&lt;String&gt; omc = mainModule.getDescriptor().mainClass();
                if (!omc.isPresent()) {
                    abort(null, &quot;Module %1$s does not have a MainClass attribute, use -m &lt;module&gt;/&lt;main-class&gt;&quot;,
                            moduleName);
                }
                mainClassName = omc.get();
            }
        } else {
            abort(new IllegalArgumentException(
                    &quot;The launchMode argument must be one of LM_CLASS, LM_JAR or LM_MODULE&quot;),
                    &quot;Invalid launch mode: %1$s&quot;, launchMode);
        }

        // fall back if no MF_JAVAFX_PRELOADER attribute, or not launching using -jar
        if (preloaderClassName == null) {
            preloaderClassName = System.getProperty(&quot;javafx.preloader&quot;);
        }

        if (mainClassName == null) {
            abort(null, &quot;No main JavaFX class to launch&quot;);
        }

        // check if we have to load through a custom classloader
        if (appLoader != null) {
            try {
                // reload this class through the app classloader
                Class&lt;?&gt; launcherClass = appLoader.loadClass(LauncherImpl.class.getName());

                // then invoke the second part of this launcher using reflection
                Method lawa = launcherClass.getMethod(&quot;launchApplicationWithArgs&quot;,
                        new Class[] { ModuleAccess.class, String.class, String.class, (new String[0]).getClass()});

                // set the thread context class loader before we continue, or it won't load properly
                Thread.currentThread().setContextClassLoader(appLoader);
                lawa.invoke(null, new Object[] {null, mainClassName, preloaderClassName, appArgs});
            } catch (Exception e) {
                abort(e, &quot;Exception while launching application&quot;);
            }
        } else {
            launchApplicationWithArgs(mainModule, mainClassName, preloaderClassName, appArgs);
        }
    }

    // wrapper for Class.forName that handles cases where diacritical marks in the name
    // cause the class to not be loaded, also largely copied from LauncherHelper.java
    // this method returns null if the class cannot be loaded
    private static Class&lt;?&gt; loadClass(final ModuleAccess mainModule, final String className) {
        Class&lt;?&gt; clz = null;
        final ClassLoader loader = Thread.currentThread().getContextClassLoader();

        // loader is ignored for modular mode
        // the only time we need to use a separate loader is LM_JAR with
        // a MF_JAVAFX_CLASS_PATH attribute which is deprecated

        if (mainModule != null) {
            clz = mainModule.classForName(className);
        } else {
            try {
                clz = Class.forName(className, true, loader);
            } catch (ClassNotFoundException | NoClassDefFoundError cnfe) {}
        }

        if (clz == null &amp;&amp; System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
                    &amp;&amp; Normalizer.isNormalized(className, Normalizer.Form.NFD)) {
            // macOS may have decomposed diacritical marks in mainClassName
            // recompose them and try again
            String cn = Normalizer.normalize(className, Normalizer.Form.NFC);

            if (mainModule != null) {
                clz = mainModule.classForName(cn);
            } else {
                try {
                    clz = Class.forName(cn, true, loader);
                } catch (ClassNotFoundException | NoClassDefFoundError cnfe) {}
            }
        }

        return clz;
    }

    // Must be public since we could be called from a different class loader
    public static void launchApplicationWithArgs(final ModuleAccess mainModule,
            final String mainClassName,
            final String preloaderClassName, String[] args) {
        try {
            startToolkit();
        } catch (InterruptedException ex) {
            abort(ex, &quot;Toolkit initialization error&quot;, mainClassName);
        }

        Class&lt;? extends Application&gt; appClass;
        Class&lt;? extends Preloader&gt; preClass = null;
        Class&lt;?&gt; tempAppClass = null;

        final AtomicReference&lt;Class&lt;?&gt;&gt; tmpClassRef = new AtomicReference&lt;&gt;();
        final AtomicReference&lt;Class&lt;? extends Preloader&gt;&gt; preClassRef = new AtomicReference&lt;&gt;();
        PlatformImpl.runAndWait(() -&gt; {
            Class&lt;?&gt; clz = loadClass(mainModule, mainClassName);
            if (clz == null) {
                if (mainModule != null) {
                    abort(null, &quot;Missing JavaFX application class %1$s in module %2$s&quot;,
                            mainClassName, mainModule.getName());
                } else {
                    abort(null, &quot;Missing JavaFX application class %1$s&quot;, mainClassName);
                }
            }

            tmpClassRef.set(clz);

            if (preloaderClassName != null) {
                // TODO: modular preloader?
                clz = loadClass(null, preloaderClassName);
                if (clz == null) {
                    abort(null, &quot;Missing JavaFX preloader class %1$s&quot;, preloaderClassName);
                }

                if (!Preloader.class.isAssignableFrom(clz)) {
                    abort(null, &quot;JavaFX preloader class %1$s does not extend javafx.application.Preloader&quot;, clz.getName());
                }
                preClassRef.set(clz.asSubclass(Preloader.class));
            }
        });
        preClass = preClassRef.get();
        tempAppClass = tmpClassRef.get();

        // Save the preloader class in a static field for later use when
        // main calls back into launchApplication.
        savedPreloaderClass = preClass;

        // If there is a public static void main(String[]) method then call it
        // otherwise just hand off to the other launchApplication method

        Exception theEx = null;
        try {
            Method mainMethod = tempAppClass.getMethod(&quot;main&quot;,
                    new Class[] { (new String[0]).getClass() });
            if (verbose) {
                System.err.println(&quot;Calling main(String[]) method&quot;);
            }
            savedMainCcl = Thread.currentThread().getContextClassLoader();
            mainMethod.invoke(null, new Object[] { args });
            return;
        } catch (NoSuchMethodException | IllegalAccessException ex) {
            theEx = ex;
            savedPreloaderClass = null;
            if (verbose) {
                System.err.println(&quot;WARNING: Cannot access application main method: &quot; + ex);
            }
        } catch (InvocationTargetException ex) {
            ex.printStackTrace();
            abort(null, &quot;Exception running application %1$s&quot;, tempAppClass.getName());
            return;
        }

        // Verify appClass extends Application
        if (!Application.class.isAssignableFrom(tempAppClass)) {
            abort(theEx, &quot;JavaFX application class %1$s does not extend javafx.application.Application&quot;, tempAppClass.getName());
        }
        appClass = tempAppClass.asSubclass(Application.class);

        if (verbose) {
            System.err.println(&quot;Launching application directly&quot;);
        }
        launchApplication(appClass, preClass, args);
    }

    private static URL fileToURL(File file) throws IOException {
        return file.getCanonicalFile().toURI().toURL();
    }

    private static ClassLoader setupJavaFXClassLoader(File appJar, String fxClassPath) {
        try {
            File baseDir = appJar.getParentFile();
            ArrayList jcpList = new ArrayList();

            // Add in the jars from the JavaFX-Class-Path entry
            // TODO: should check current classpath for duplicate entries and ignore them
            String cp = fxClassPath;
            if (cp != null) {
                // these paths are relative to baseDir, which should be the
                // directory containing the app jar file
                while (cp.length() &gt; 0) {
                    int pathSepIdx = cp.indexOf(&quot; &quot;);
                    if (pathSepIdx &lt; 0) {
                        String pathElem = cp;
                        File f = (baseDir == null) ?
                                new File(pathElem) : new File(baseDir, pathElem);
                        if (f.exists()) {
                            jcpList.add(fileToURL(f));
                        } else if (verbose) {
                            System.err.println(&quot;Class Path entry \&quot;&quot;+pathElem
                                    +&quot;\&quot; does not exist, ignoring&quot;);
                        }
                        break;
                    } else if (pathSepIdx &gt; 0) {
                        String pathElem = cp.substring(0, pathSepIdx);
                        File f = (baseDir == null) ?
                                new File(pathElem) : new File(baseDir, pathElem);
                        if (f.exists()) {
                            jcpList.add(fileToURL(f));
                        } else if (verbose) {
                            System.err.println(&quot;Class Path entry \&quot;&quot;+pathElem
                                    +&quot;\&quot; does not exist, ignoring&quot;);
                        }
                    }
                    cp = cp.substring(pathSepIdx + 1);
                }
            }

            // don't bother if there's nothing to add
            if (!jcpList.isEmpty()) {
                ArrayList&lt;URL&gt; urlList = new ArrayList&lt;URL&gt;();

                // prepend the existing classpath
                // this will already have the app jar, so no need to worry about it
                cp = System.getProperty(&quot;java.class.path&quot;);
                if (cp != null) {
                    while (cp.length() &gt; 0) {
                        int pathSepIdx = cp.indexOf(File.pathSeparatorChar);
                        if (pathSepIdx &lt; 0) {
                            String pathElem = cp;
                            urlList.add(fileToURL(new File(pathElem)));
                            break;
                        } else if (pathSepIdx &gt; 0) {
                            String pathElem = cp.substring(0, pathSepIdx);
                            urlList.add(fileToURL(new File(pathElem)));
                        }
                        cp = cp.substring(pathSepIdx + 1);
                    }
                }

                // and finally append the JavaFX-Class-Path entries
                urlList.addAll(jcpList);

                URL[] urls = (URL[])urlList.toArray(new URL[0]);
                if (verbose) {
                    System.err.println(&quot;===== URL list&quot;);
                    for (int i = 0; i &lt; urls.length; i++) {
                        System.err.println(&quot;&quot; + urls[i]);
                    }
                    System.err.println(&quot;=====&quot;);
                }
                return new URLClassLoader(urls, ClassLoader.getPlatformClassLoader());
            }
        } catch (Exception ex) {
            if (trace) {
                System.err.println(&quot;Exception creating JavaFX class loader: &quot;+ex);
                ex.printStackTrace();
            }
        }
        return null;
<A NAME="8"></A>    }

    private static String decodeBase64(String inp) throws IOException {
        return new String(<FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#8',2,'match44-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Base64.getDecoder().decode(inp));
    }

    private static String[] getAppArguments(Attributes attrs) {
        List args = new LinkedList();

        try {
            int idx = 1</B></FONT>;
            String argNamePrefix = MF_JAVAFX_ARGUMENT_PREFIX;
            while (attrs.getValue(argNamePrefix + idx) != null) {
                args.add(decodeBase64(attrs.getValue(argNamePrefix + idx)));
                idx++;
            }

            String paramNamePrefix = MF_JAVAFX_PARAMETER_NAME_PREFIX;
            String paramValuePrefix = MF_JAVAFX_PARAMETER_VALUE_PREFIX;
            idx = 1;
            while (attrs.getValue(paramNamePrefix + idx) != null) {
                String k = decodeBase64(attrs.getValue(paramNamePrefix + idx));
                String v = null;
                if (attrs.getValue(paramValuePrefix + idx) != null) {
                    v = decodeBase64(attrs.getValue(paramValuePrefix + idx));
                }
                args.add(&quot;--&quot; + k + &quot;=&quot; + (v != null ? v : &quot;&quot;));
                idx++;
            }
        } catch (IOException ioe) {
            if (verbose) {
                System.err.println(&quot;Failed to extract application parameters&quot;);
            }
            ioe.printStackTrace();
        }

        return (String[]) args.toArray(new String[0]);
    }

    // FIXME: needs localization, since these are presented to the user
    private static void abort(final Throwable cause, final String fmt, final Object... args) {
        String msg = String.format(fmt, args);
        if (msg != null) {
            System.err.println(msg);
        }

        if (trace) {
            if (cause != null) {
                cause.printStackTrace();
            } else {
                Thread.dumpStack();
            }
        }
        System.exit(1);
    }

    private static Attributes getJarAttributes(String jarPath) {
        JarFile jarFile = null;
        try {
            jarFile = new JarFile(jarPath);
            Manifest manifest = jarFile.getManifest();
            if (manifest == null) {
                abort(null, &quot;No manifest in jar file %1$s&quot;, jarPath);
            }
            return manifest.getMainAttributes();
        } catch (IOException ioe) {
            abort(ioe, &quot;Error launching jar file %1%s&quot;, jarPath);
        } finally {
            try {
                jarFile.close();
            } catch (IOException ioe) {}
        }
        return null;
    }

    private static void startToolkit() throws InterruptedException {
        if (toolkitStarted.getAndSet(true)) {
            return;
        }

        final CountDownLatch startupLatch = new CountDownLatch(1);

        // Note, this method is called on the FX Application Thread
        PlatformImpl.startup(() -&gt; startupLatch.countDown());

        // Wait for FX platform to start
        startupLatch.await();
    }

    private static volatile boolean error = false;
    private static volatile Throwable pConstructorError = null;
    private static volatile Throwable pInitError = null;
    private static volatile Throwable pStartError = null;
    private static volatile Throwable pStopError = null;
    private static volatile Throwable constructorError = null;
    private static volatile Throwable initError = null;
    private static volatile Throwable startError = null;
    private static volatile Throwable stopError = null;

    private static void launchApplication1(final Class&lt;? extends Application&gt; appClass,
            final Class&lt;? extends Preloader&gt; preloaderClass,
            final String[] args) throws Exception {

        startToolkit();

        if (savedMainCcl != null) {
            /*
             * The toolkit was already started by the java launcher, and the
             * main method of the application class was called. Check to see
             * whether the CCL has been changed. If so, then we need
             * to pass the context class loader to the FX app thread so that it
             * correctly picks up the current setting.
             */
            final ClassLoader ccl = Thread.currentThread().getContextClassLoader();
            if (ccl != null &amp;&amp; ccl != savedMainCcl) {
                PlatformImpl.runLater(() -&gt; {
                    Thread.currentThread().setContextClassLoader(ccl);
                });
            }
        }

        final AtomicBoolean pStartCalled = new AtomicBoolean(false);
        final AtomicBoolean startCalled = new AtomicBoolean(false);
        final AtomicBoolean exitCalled = new AtomicBoolean(false);
        final AtomicBoolean pExitCalled = new AtomicBoolean(false);
        final CountDownLatch shutdownLatch = new CountDownLatch(1);
        final CountDownLatch pShutdownLatch = new CountDownLatch(1);

        final PlatformImpl.FinishListener listener = new PlatformImpl.FinishListener() {
            @Override public void idle(boolean implicitExit) {
                if (!implicitExit) {
                    return;
                }

//                System.err.println(&quot;JavaFX Launcher: system is idle&quot;);
                if (startCalled.get()) {
                    shutdownLatch.countDown();
                } else if (pStartCalled.get()) {
                    pShutdownLatch.countDown();
                }
            }

            @Override public void exitCalled() {
//                System.err.println(&quot;JavaFX Launcher: received exit notification&quot;);
                exitCalled.set(true);
                shutdownLatch.countDown();
            }
        };
        PlatformImpl.addListener(listener);

        try {
            final AtomicReference&lt;Preloader&gt; pldr = new AtomicReference&lt;&gt;();
            if (preloaderClass != null) {
                // Construct an instance of the preloader on the FX thread, then
                // call its init method on this (launcher) thread. Then call
                // the start method on the FX thread.
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        Constructor&lt;? extends Preloader&gt; c = preloaderClass.getConstructor();
                        pldr.set(c.newInstance());
                        // Set startup parameters
                        ParametersImpl.registerParameters(pldr.get(), new ParametersImpl(args));
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Preloader constructor&quot;);
                        pConstructorError = t;
                        error = true;
                    }
                });
            }
            currentPreloader = pldr.get();

            // Call init method unless exit called or error detected
            if (currentPreloader != null &amp;&amp; !error &amp;&amp; !exitCalled.get()) {
                try {
                    // Call the application init method (on the Launcher thread)
                    currentPreloader.init();
                } catch (Throwable t) {
                    System.err.println(&quot;Exception in Preloader init method&quot;);
                    pInitError = t;
                    error = true;
                }
            }

            // Call start method unless exit called or error detected
            if (currentPreloader != null &amp;&amp; !error &amp;&amp; !exitCalled.get()) {
                // Call the application start method on FX thread
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        pStartCalled.set(true);

                        // Create primary stage and call preloader start method
                        final Stage primaryStage = new Stage();
                        StageHelper.setPrimary(primaryStage, true);
                        currentPreloader.start(primaryStage);
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Preloader start method&quot;);
                        pStartError = t;
                        error = true;
                    }
                });

                // Notify preloader of progress
                if (!error &amp;&amp; !exitCalled.get()) {
                    notifyProgress(currentPreloader, 0.0);
                }
            }

            // Construct an instance of the application on the FX thread, then
            // call its init method on this (launcher) thread. Then call
            // the start method on the FX thread.
            final AtomicReference&lt;Application&gt; app = new AtomicReference&lt;&gt;();
            if (!error &amp;&amp; !exitCalled.get()) {
                if (currentPreloader != null) {
                    if (simulateSlowProgress) {
                        for (int i = 0; i &lt; 100; i++) {
                            notifyProgress(currentPreloader, (double)i / 100.0);
                            Thread.sleep(10);
                        }
                    }
                    notifyProgress(currentPreloader, 1.0);
                    notifyStateChange(currentPreloader,
                            StateChangeNotification.Type.BEFORE_LOAD, null);
                }

                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        Constructor&lt;? extends Application&gt; c = appClass.getConstructor();
                        app.set(c.newInstance());
                        // Set startup parameters
                        ParametersImpl.registerParameters(app.get(), new ParametersImpl(args));
                        PlatformImpl.setApplicationName(appClass);
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Application constructor&quot;);
                        constructorError = t;
                        error = true;
                    }
                });
            }
            final Application theApp = app.get();

            // Call init method unless exit called or error detected
            if (!error &amp;&amp; !exitCalled.get()) {
                if (currentPreloader != null) {
                    notifyStateChange(currentPreloader,
                            StateChangeNotification.Type.BEFORE_INIT, theApp);
                }

                try {
                    // Call the application init method (on the Launcher thread)
                    theApp.init();
                } catch (Throwable t) {
                    System.err.println(&quot;Exception in Application init method&quot;);
                    initError = t;
                    error = true;
                }
            }

            // Call start method unless exit called or error detected
            if (!error &amp;&amp; !exitCalled.get()) {
                if (currentPreloader != null) {
                    notifyStateChange(currentPreloader,
                            StateChangeNotification.Type.BEFORE_START, theApp);
                }
                // Call the application start method on FX thread
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        startCalled.set(true);

                        // Create primary stage and call application start method
                        final Stage primaryStage = new Stage();
                        StageHelper.setPrimary(primaryStage, true);
                        theApp.start(primaryStage);
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Application start method&quot;);
                        startError = t;
                        error = true;
                    }
                });
            }

            if (!error) {
                shutdownLatch.await();
//                System.err.println(&quot;JavaFX Launcher: time to call stop&quot;);
            }

            // Call stop method if start was called
            if (startCalled.get()) {
                // Call Application stop method on FX thread
                PlatformImpl.runAndWait(() -&gt; {
                    try {
                        theApp.stop();
                    } catch (Throwable t) {
                        System.err.println(&quot;Exception in Application stop method&quot;);
                        stopError = t;
                        error = true;
                    }
                });
            }

            if (error) {
                if (pConstructorError != null) {
                    throw new RuntimeException(&quot;Unable to construct Preloader instance: &quot;
                            + appClass, pConstructorError);
                } else if (pInitError != null) {
                    throw new RuntimeException(&quot;Exception in Preloader init method&quot;,
                            pInitError);
                } else if(pStartError != null) {
                    throw new RuntimeException(&quot;Exception in Preloader start method&quot;,
                            pStartError);
                } else if (pStopError != null) {
                    throw new RuntimeException(&quot;Exception in Preloader stop method&quot;,
                            pStopError);
                } else if (constructorError != null) {
                    String msg = &quot;Unable to construct Application instance: &quot; + appClass;
                    if (!notifyError(msg, constructorError)) {
                        throw new RuntimeException(msg, constructorError);
                    }
                } else if (initError != null) {
                    String msg = &quot;Exception in Application init method&quot;;
                    if (!notifyError(msg, initError)) {
                        throw new RuntimeException(msg, initError);
                    }
                } else if(startError != null) {
                    String msg = &quot;Exception in Application start method&quot;;
                    if (!notifyError(msg, startError)) {
                        throw new RuntimeException(msg, startError);
                    }
                } else if (stopError != null) {
                    String msg = &quot;Exception in Application stop method&quot;;
                    if (!notifyError(msg, stopError)) {
                        throw new RuntimeException(msg, stopError);
                    }
                }
            }
        } finally {
            PlatformImpl.removeListener(listener);
            PlatformImpl.tkExit();
        }
    }

    private static void notifyStateChange(final Preloader preloader,
            final StateChangeNotification.Type type,
            final Application app) {

        PlatformImpl.runAndWait(() -&gt; preloader.handleStateChangeNotification(
            new StateChangeNotification(type, app)));
    }

    private static void notifyProgress(final Preloader preloader, final double d) {
        PlatformImpl.runAndWait(() -&gt; preloader.handleProgressNotification(
                new Preloader.ProgressNotification(d)));
    }

    private static boolean notifyError(final String msg, final Throwable constructorError) {
        final AtomicBoolean result = new AtomicBoolean(false);
        PlatformImpl.runAndWait(() -&gt; {
            if (currentPreloader != null) {
                try {
                    ErrorNotification evt = new ErrorNotification(null, msg, constructorError);
                    boolean rval = currentPreloader.handleErrorNotification(evt);
                    result.set(rval);
                } catch (Throwable t) {
                    t.printStackTrace();
                }
            }
        });

        return result.get();
    }

    private static void notifyCurrentPreloader(final PreloaderNotification pe) {
        PlatformImpl.runAndWait(() -&gt; {
            if (currentPreloader != null) {
                currentPreloader.handleApplicationNotification(pe);
            }
        });
    }

    public static void notifyPreloader(Application app, final PreloaderNotification info) {
        if (launchCalled.get()) {
            // Standalone launcher mode
            notifyCurrentPreloader(info);
            return;
        }
    }

    // Not an instantiable class.
    private LauncherImpl() {
        // Should never get here.
        throw new InternalError();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/PrismFontLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import com.sun.javafx.scene.text.FontHelper;
import javafx.scene.text.*;
import com.sun.javafx.tk.*;
import java.lang.reflect.Method;
import java.net.URL;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.Properties;

public class PrismFontLoader extends FontLoader {
    private static PrismFontLoader theInstance = new PrismFontLoader();
    public static PrismFontLoader getInstance() { return theInstance; }

    /**
     * Flag to keep track whether the fontCache map has been initialized with
     * the embedded fonts.
     */
    private boolean embeddedFontsLoaded = false;

    Properties loadEmbeddedFontDefinitions() {
        Properties map = new Properties();
        // locate the META-INF directory and search for a fonts.mf
        // located there
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader == null) return map;
        URL u = loader.getResource(&quot;META-INF/fonts.mf&quot;);
        if (u == null) return map;

        // read in the contents of the file
        try (InputStream in = u.openStream()) {
            map.load(in);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return map;
    }

    private void loadEmbeddedFonts() {
        if (!embeddedFontsLoaded) {
            FontFactory fontFactory = getFontFactoryFromPipeline();
            if (!fontFactory.hasPermission()) {
                embeddedFontsLoaded = true;
                return;
            }
            Properties map = loadEmbeddedFontDefinitions();
            Enumeration&lt;?&gt; names = map.keys();
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            while (names.hasMoreElements()) {
                String n = (String)names.nextElement();
                String p = map.getProperty(n);
                if (p.startsWith(&quot;/&quot;)) {
                    p = p.substring(1);
                    try (InputStream in = loader.getResourceAsStream(p)) {
                        fontFactory.loadEmbeddedFont(n, in, 0, true, false);
                    } catch (Exception e) {
                    }
                }
            }
            embeddedFontsLoaded = true;
        }
    }

    private Font[] createFonts(PGFont[] fonts) {
        if (fonts == null || fonts.length == 0) {
            return null;
        }
        Font[] fxFonts = new Font[fonts.length];
        for (int i=0; i&lt;fonts.length; i++) {
            fxFonts[i] = createFont(fonts[i]);
        }
        return fxFonts;
    }

    @Override public Font[] loadFont(InputStream in,
                                     double size,
                                     boolean loadAll) {

        FontFactory factory = getFontFactoryFromPipeline();
        PGFont[] fonts =
            factory.loadEmbeddedFont(null, in, (float)size, true, loadAll);
        return createFonts(fonts);
     }

    @Override public Font[] loadFont(String path,
                                     double size,
                                     boolean loadAll) {

        FontFactory factory = getFontFactoryFromPipeline();
        PGFont[] fonts =
            factory.loadEmbeddedFont(null, path, (float)size, true, loadAll);
        return createFonts(fonts);
<A NAME="42"></A>    }

    @SuppressWarnings(&quot;deprecation&quot;)
    private Font createFont(PGFont font) <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#42',2,'match44-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        return FontHelper.nativeFont(font,
                                     font.getName(),
                                     font.getFamilyName(),
                                     font.getStyleName(),
                                     font.getSize());
    }

    /**
     * Gets all the font families installed on the user's system, including any
     * embedded fonts or SDK fonts.
     *
     * @profile common
     */
    @Override public List&lt;String&gt; getFamilies() {
        loadEmbeddedFonts</B></FONT>();
        return Arrays.asList(getFontFactoryFromPipeline().
                             getFontFamilyNames());
    }

    /**
     * Gets the names of all fonts that are installed on the users system,
     * including any embedded fonts and SDK fonts.
     *
     * @profile common
     */
    @Override public List&lt;String&gt; getFontNames() {
        loadEmbeddedFonts();
        return Arrays.asList(getFontFactoryFromPipeline().getFontFullNames());
    }

    /**
     * Gets the names of all fonts in the specified font family that are
     * installed  on the users system, including any embedded fonts and
     * SDK fonts.
     *
     * @profile common
     */
    @Override public List&lt;String&gt; getFontNames(String family) {
        loadEmbeddedFonts();
        return Arrays.asList(getFontFactoryFromPipeline().
                             getFontFullNames(family));
    }

    /**
     * Searches for an appropriate font based on the font family name and
     * weight and posture style. This method is not guaranteed to return
     * a specific font, but does its best to find one that fits the
     * specified requirements.
     *
     * For SDK/runtime fonts, we will attempt to match properties to a
     * SDK/runtime fonts.  If a specific SDK font is not found in the runtime
     * JAR, the font loading will revert to FontFactory default font, rather
     * then finding closest matching available SDK font. This is how SDK font
     * loading was handled in the past.
     *
     * @param family The family of the font
     * @param weight The weight of the font
     * @param posture The posture or posture of the font
     * @param size The point size of the font. This can be a fractional value
     *
     * @profile desktop
     */
    @Override public Font font(String family, FontWeight weight,
                               FontPosture posture, float size) {

        FontFactory fontFactory = getFontFactoryFromPipeline();
        if (!embeddedFontsLoaded &amp;&amp; !fontFactory.isPlatformFont(family)) {
            loadEmbeddedFonts();
        }

        // REMIND. Some day need to have better granularity.

        boolean bold = weight != null &amp;&amp;
                       weight.ordinal() &gt;= FontWeight.BOLD.ordinal();
        boolean italic = posture == FontPosture.ITALIC;
        PGFont prismFont = fontFactory.createFont(family, bold, italic, size);

        // Create Font and set implementation
        Font fxFont = FontHelper.nativeFont(prismFont, prismFont.getName(),
                                            prismFont.getFamilyName(),
                                            prismFont.getStyleName(), size);
        return fxFont;
    }

    /**
     * @param font
     */
    @Override public void loadFont(Font font) {
        FontFactory fontFactory = getFontFactoryFromPipeline();
        String fullName = font.getName();
        if (!embeddedFontsLoaded &amp;&amp; !fontFactory.isPlatformFont(fullName)) {
            loadEmbeddedFonts();
        }

        // find the native Prism Font object based on this JavaFX font. At the
        // conclusion of this method, be sure to set the name, family, and
        // style on the Font object via the setNativeFont method.

        // the Prism font we're trying to find
        PGFont prismFont = fontFactory.createFont(fullName, (float)font.getSize());

        // update the name variable to match what was actually loaded
        String name = prismFont.getName();
        String family = prismFont.getFamilyName();
        String style = prismFont.getStyleName();
        FontHelper.setNativeFont(font, prismFont, name, family, style);
    }

    @Override public FontMetrics getFontMetrics(Font font) {
        if (font != null) {
            PGFont prismFont = (PGFont) FontHelper.getNativeFont(font);
            Metrics metrics = PrismFontUtils.getFontMetrics(prismFont);
            // TODO: what's the difference between ascent and maxAscent?
            float maxAscent = -metrics.getAscent();//metrics.getMaxAscent();
            float ascent = -metrics.getAscent();
            float xheight = metrics.getXHeight();
            float descent = metrics.getDescent();
            // TODO: what's the difference between descent and maxDescent?
            float maxDescent = metrics.getDescent();//metrics.getMaxDescent();
            float leading = metrics.getLineGap();
            return FontMetrics.createFontMetrics(maxAscent, ascent, xheight, descent, maxDescent, leading, font);
        } else {
            return null; // this should never happen
        }
    }

    @Override public float getCharWidth(char ch, Font font) {
        PGFont prismFont = (PGFont) FontHelper.getNativeFont(font);
        return (float)PrismFontUtils.getCharWidth(prismFont, ch);
    }

    @Override public float getSystemFontSize() {
        // PrismFontFactory is what loads the DLL, so we may as
        // well place the required native method there.
        return PrismFontFactory.getSystemFontSize();
    }

    FontFactory installedFontFactory = null;
    private FontFactory getFontFactoryFromPipeline() {
        if (installedFontFactory != null) {
            return installedFontFactory;
        }
        try {
            Class plc = Class.forName(&quot;com.sun.prism.GraphicsPipeline&quot;);
            Method gpm = plc.getMethod(&quot;getPipeline&quot;, (Class[])null);
            Object plo = gpm.invoke(null);
            Method gfm = plc.getMethod(&quot;getFontFactory&quot;, (Class[])null);
            Object ffo = gfm.invoke(plo);
            installedFontFactory = (FontFactory)ffo;
        } catch (Exception e) {
        }
        return installedFontFactory;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/iio/ImageStorage.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.iio;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.iio.ImageFormatDescription.Signature;
import com.sun.javafx.iio.bmp.BMPImageLoaderFactory;
import com.sun.javafx.iio.common.ImageTools;
import com.sun.javafx.iio.gif.GIFImageLoaderFactory;
import com.sun.javafx.iio.ios.IosImageLoaderFactory;
import com.sun.javafx.iio.jpeg.JPEGImageLoaderFactory;
import com.sun.javafx.iio.png.PNGImageLoaderFactory;
import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

/**
 * A convenience class for simple image loading. Factories for creating loaders
 * for image formats must be registered with this class.
 */
public class ImageStorage {

    /**
     * An enumeration of supported image types.
     */
    public static enum ImageType {

        /**
         * An image with a single channel of 8-bit valued gray levels.
         */
        GRAY,
        /**
         * An image with with two 8-bit valued channels, one of gray levels,
         * the other of non-premultiplied opacity, ordered as GAGAGA...
         */
        GRAY_ALPHA,
        /**
         * An image with with two 8-bit valued channels, one of gray levels,
         * the other of premultiplied opacity, ordered as GAGAGA...
         */
        GRAY_ALPHA_PRE,
        /**
         * An image with with one 8-bit channel of indexes into a 24-bit
         * lookup table which maps the indexes to 8-bit RGB components.
         */
        PALETTE,
        /**
         * An image with with one 8-bit channel of indexes into a 32-bit
         * lookup table which maps the indexes to 8-bit RGBA components
         * wherein the opacity is not-premultiplied.
         */
        PALETTE_ALPHA,
        /**
         * An image with with one 8-bit channel of indexes into a 32-bit
         * lookup table which maps the indexes to 8-bit RGBA components
         * wherein the opacity is premultiplied.
         */
        PALETTE_ALPHA_PRE,
        /**
         * An image with with one 8-bit channel of indexes into a 24-bit
         * lookup table which maps the indexes to 8-bit RGB components, and
         * a single transparent index to indicate the location of transparent
         * pixels.
         */
        PALETTE_TRANS,
        /**
         * An image with with three 8-bit valued channels of red, green, and
         * blue, respectively, ordered as RGBRGBRGB...
         */
        RGB,
        /**
         * An image with with four 8-bit valued channels of red, green, blue,
         * and non-premultiplied opacity, respectively, ordered as
         * RGBARGBARGBA...
         */
        RGBA,
        /**
         * An image with with four 8-bit valued channels of red, green, blue,
         * and premultiplied opacity, respectively, ordered as
         * RGBARGBARGBA...
         */
        RGBA_PRE
    };
    /**
     * A mapping of lower case file extensions to loader factories.
     */
//    private static HashMap&lt;String, ImageLoaderFactory&gt; loaderFactoriesByExtension;
    /**
     * A mapping of format signature byte sequences to loader factories.
     */
    private static final HashMap&lt;Signature, ImageLoaderFactory&gt; loaderFactoriesBySignature;
    private static final ImageLoaderFactory[] loaderFactories;
    private static final boolean isIOS = PlatformUtil.isIOS();

    private static int maxSignatureLength;

    static {
        if (isIOS) {
            //On iOS we have single factory/ native loader
            //for all image formats
            loaderFactories = new ImageLoaderFactory[]{
                IosImageLoaderFactory.getInstance()
            };
        } else {
            loaderFactories = new ImageLoaderFactory[]{
                GIFImageLoaderFactory.getInstance(),
                JPEGImageLoaderFactory.getInstance(),
                PNGImageLoaderFactory.getInstance(),
                BMPImageLoaderFactory.getInstance()
                // Note: append ImageLoadFactory for any new format here.
            };
        }

//        loaderFactoriesByExtension = new HashMap(numExtensions);
        loaderFactoriesBySignature = new HashMap&lt;Signature, ImageLoaderFactory&gt;(loaderFactories.length);

        for (int i = 0; i &lt; loaderFactories.length; i++) {
            addImageLoaderFactory(loaderFactories[i]);
        }
    }

    public static ImageFormatDescription[] getSupportedDescriptions() {
        ImageFormatDescription[] formats = new ImageFormatDescription[loaderFactories.length];
        for (int i = 0; i &lt; loaderFactories.length; i++) {
            formats[i] = loaderFactories[i].getFormatDescription();
        }
        return (formats);
    }

    /**
     * Returns the number of bands for a raw image of the specified type.
     *
     * @param type the type of image
     * @return the number of bands of a raw image of this type
     */
    public static int getNumBands(ImageType type) {
        int numBands = -1;
        switch (type) {
            case GRAY:
            case PALETTE:
            case PALETTE_ALPHA:
            case PALETTE_ALPHA_PRE:
            case PALETTE_TRANS:
                numBands = 1;
                break;
            case GRAY_ALPHA:
            case GRAY_ALPHA_PRE:
                numBands = 2;
                break;
            case RGB:
                numBands = 3;
                break;
            case RGBA:
            case RGBA_PRE:
                numBands = 4;
                break;
            default:
                throw new IllegalArgumentException(&quot;Unknown ImageType &quot; + type);
        }
        return numBands;
    }

    /**
     * Registers an image loader factory. The factory replaces any other factory
     * previously registered for the file extensions (converted to lower case)
     * and signature indicated by the format description.
     *
     * @param factory the factory to register.
     */
    public static void addImageLoaderFactory(ImageLoaderFactory factory) {
        ImageFormatDescription desc = factory.getFormatDescription();
//        String[] extensions = desc.getExtensions();
//        for (int j = 0; j &lt; extensions.length; j++) {
//            loaderFactoriesByExtension.put(extensions[j].toLowerCase(), factory);
//        }

        for (final Signature signature: desc.getSignatures()) {
            loaderFactoriesBySignature.put(signature, factory);
        }

        // invalidate max signature length
        synchronized (ImageStorage.class) {
            maxSignatureLength = -1;
        }
    }

    /**
     * Load all images present in the specified stream. The image will be
     * rescaled according to this algorithm:
     *
     * &lt;code&gt;&lt;pre&gt;
     * int finalWidth, finalHeight; // final dimensions
     * int width, height;     // specified maximum dimensions
     * // Use source dimensions as default values.
     * if (width &lt;= 0) {
     *     width = sourceWidth;
     * }
     * if (height &lt;= 0) {
     *     height = sourceHeight;
     * }
     * // If not downscaling reset the dimensions to those of the source.
     * if (!((width &lt; sourceWidth &amp;&amp; height &lt;= sourceHeight) ||
     *       (width &lt;= sourceWidth &amp;&amp; height &lt; sourceHeight))) {
     *      finalWidth = sourceWidth;
     *      finalHeight = sourceHeight;
     * } else if(preserveAspectRatio) {
     *      double r = (double) sourceWidth / (double) sourceHeight;
     *      finalHeight = (int) ((width / r &lt; height ? width / r : height) + 0.5);
     *      finalWidth = (int) (r * finalHeight + 0.5);
     * } else {
     *      finalWidth = width;
     *      finalHeight = height;
     * }
     * &lt;/pre&gt;&lt;/code&gt;
     *
     * @param input the image data stream.
     * @param listener a listener to receive notifications about image loading.
     * @param width the desired width of the image; if non-positive,
     * the original image width will be used.
     * @param height the desired height of the image; if non-positive, the
     * original image height will be used.
     * @param preserveAspectRatio whether to preserve the width-to-height ratio
     * of the image.
     * @param smooth whether to apply smoothing when downsampling.
     * @return the sequence of all images in the specified source or
     * &lt;code&gt;null&lt;/code&gt; on error.
     */
    public static ImageFrame[] loadAll(InputStream input, ImageLoadListener listener,
            double width, double height, boolean preserveAspectRatio,
            float pixelScale, boolean smooth) throws ImageStorageException {
        ImageLoader loader = null;
        try {
            if (isIOS) {
                // no extension/signature recognition done here,
                // we always want the iOS native loader
                loader = IosImageLoaderFactory.getInstance().createImageLoader(input);
            } else {
                loader = getLoaderBySignature(input, listener);
            }
        } catch (IOException e) {
            throw new ImageStorageException(e.getMessage(), e);
        }

        ImageFrame[] images = null;
        if (loader != null) {
            images = loadAll(loader, width, height, preserveAspectRatio, pixelScale, smooth);
        } else {
            throw new ImageStorageException(&quot;No loader for image data&quot;);
        }

        return images;
    }

    /**
     * Load all images present in the specified input. For more details refer to
     * {@link #loadAll(java.io.InputStream, com.sun.javafx.iio.ImageLoadListener, int, int, boolean, boolean)}.
     */
    public static ImageFrame[] loadAll(String input, ImageLoadListener listener,
            double width, double height, boolean preserveAspectRatio,
            float devPixelScale, boolean smooth) throws ImageStorageException {

        if (input == null || input.isEmpty()) {
            throw new ImageStorageException(&quot;URL can't be null or empty&quot;);
        }

        ImageFrame[] images = null;
        InputStream theStream = null;
        ImageLoader loader = null;

        try {
            float imgPixelScale = 1.0f;
            try {
                if (devPixelScale &gt;= 1.5f) {
                    // Use Mac Retina conventions for &gt;= 1.5f
                    try {
                        String name2x = ImageTools.getScaledImageName(input);
                        theStream = ImageTools.createInputStream(name2x);
                        imgPixelScale = 2.0f;
                    } catch (IOException e) {
                    }
                }
                if (theStream == null) {
                    theStream = ImageTools.createInputStream(input);
                }

                if (isIOS) {
                    loader = IosImageLoaderFactory.getInstance().createImageLoader(theStream);
                } else {
                    loader = getLoaderBySignature(theStream, listener);
                }
            } catch (IOException e) {
                throw new ImageStorageException(e.getMessage(), e);
            }

            if (loader != null) {
                images = loadAll(loader, width, height, preserveAspectRatio, imgPixelScale, smooth);
            } else {
                throw new ImageStorageException(&quot;No loader for image data&quot;);
            }
        } finally {
            try {
                if (theStream != null) {
                    theStream.close();
                }
            } catch (IOException e) {
            }
        }

        return images;
    }

    private static synchronized int getMaxSignatureLength() {
        if (maxSignatureLength &lt; 0) {
            maxSignatureLength = 0;
            for (final Signature signature:
                    loaderFactoriesBySignature.keySet()) {
                final int signatureLength = signature.getLength();
                if (maxSignatureLength &lt; signatureLength) {
                    maxSignatureLength = signatureLength;
                }
            }
        }

        return maxSignatureLength;
    }

    private static ImageFrame[] loadAll(ImageLoader loader,
            double width, double height, boolean preserveAspectRatio,
            float pixelScale, boolean smooth) throws ImageStorageException {
        ImageFrame[] images = null;
        ArrayList&lt;ImageFrame&gt; list = new ArrayList&lt;ImageFrame&gt;();
        int imageIndex = 0;
        ImageFrame image = null;
        int imgw = (int) Math.round(width * pixelScale);
        int imgh = (int) Math.round(height * pixelScale);
        do {
            try {
                image = loader.load(imageIndex++, imgw, imgh, preserveAspectRatio, smooth);
            } catch (Exception e) {
                // allow partially loaded animated images
                if (imageIndex &gt; 1) {
                    break;
                } else {
                    throw new ImageStorageException(e.getMessage(), e);
                }
            }
            if (image != null) {
                image.setPixelScale(pixelScale);
                list.add(image);
            } else {
                break;
            }
        } while (true);
        int numImages = list.size();
        if (numImages &gt; 0) {
            images = new ImageFrame[numImages];
            list.toArray(images);
        }
        return images;
    }

//    private static ImageLoader getLoaderByExtension(String input, ImageLoadListener listener) {
//        ImageLoader loader = null;
//
//        int dotIndex = input.lastIndexOf(&quot;.&quot;);
//        if (dotIndex != -1) {
//            String extension = input.substring(dotIndex + 1).toLowerCase();
//            Set extensions = loaderFactoriesByExtension.keySet();
//            if (extensions.contains(extension)) {
//                ImageLoaderFactory factory = loaderFactoriesByExtension.get(extension);
//                InputStream stream = ImageTools.createInputStream(input);
//                if (stream != null) {
//                    loader = factory.createImageLoader(stream);
//                    if (listener != null) {
//                        loader.addListener(listener);
//                    }
//                }
//            }
//        }
//
//        return loader;
//    }

    private static ImageLoader getLoaderBySignature(InputStream stream, ImageLoadListener listener) throws IOException {
        byte[] header = new byte[getMaxSignatureLength()];
        ImageTools.readFully(stream, header);

        for (final Entry&lt;Signature, ImageLoaderFactory&gt; factoryRegistration:
                 loaderFactoriesBySignature.entrySet()) {
<A NAME="38"></A>            if (factoryRegistration.getKey().matches(header)) {
                InputStream headerStream = new ByteArrayInputStream(header);
                InputStream seqStream = new SequenceInputStream(headerStream, stream);
                ImageLoader loader = <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#38',2,'match44-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>factoryRegistration.getValue().createImageLoader(seqStream);
                if (listener != null) {
                    loader.addListener(listener);
                }

                return loader;
            }</B></FONT>
        }

        // not found
        return null;
    }

    private ImageStorage() {
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/iio/common/ImageTools.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.iio.common;

import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.iio.ImageFrame;
import com.sun.javafx.iio.ImageMetadata;
import com.sun.javafx.iio.ImageStorage;
import com.sun.javafx.iio.ImageStorage.ImageType;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.Buffer;
import java.nio.ByteBuffer;

/**
 * A set of format-independent convenience methods useful in image loading
 * and saving.
 */
public class ImageTools {

    /**
     * The percentage increment between progress report updates.
     */
    public static final int PROGRESS_INTERVAL = 5;

    /**
     * See the general contract of the &lt;code&gt;readFully&lt;/code&gt;
     * method of &lt;code&gt;DataInput&lt;/code&gt;.
     * &lt;p&gt;
     * Bytes
     * for this operation are read from the specified
     * input stream.
     *
     * @param      stream the stream from which to read the data.
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset of the data.
     * @param      len   the number of bytes to read.
     * @exception  EOFException  if this input stream reaches the end before
     *               reading all the bytes.
     * @exception  IOException   if another I/O error occurs.
     */
    public static int readFully(InputStream stream,
            byte[] b, int off, int len) throws IOException {
        if (len &lt; 0) {
            throw new IndexOutOfBoundsException();
        }
        int requestedLength = len;
        // Fix 4430357 - if off + len &lt; 0, overflow occurred
        if (off &lt; 0 || len &lt; 0 || off + len &gt; b.length || off + len &lt; 0) {
            throw new IndexOutOfBoundsException(&quot;off &lt; 0 || len &lt; 0 || off + len &gt; b.length!&quot;);
        }

        while (len &gt; 0) {
            int nbytes = stream.read(b, off, len);
            if (nbytes == -1) {
                throw new EOFException();
            }
            off += nbytes;
            len -= nbytes;
        }

        return requestedLength;
    }

    /**
     * See the general contract of the &lt;code&gt;readFully&lt;/code&gt;
     * method of &lt;code&gt;DataInput&lt;/code&gt;.
     * &lt;p&gt;
     * Bytes
     * for this operation are read from the contained
     * input stream.
     *
     * @param      stream the stream from which to read the data.
     * @param      b   the buffer into which the data is read.
     * @exception  EOFException  if this input stream reaches the end before
     *             reading all the bytes.
     * @exception  IOException   if another I/O error occurs.
     */
    public static int readFully(InputStream stream, byte[] b) throws IOException {
        return readFully(stream, b, 0, b.length);
    }

    /**
     * Skips over &lt;code&gt;n&lt;/code&gt; bytes of data from the input stream.
     * @param      stream the stream to skip.
     * @param      n the number of bytes to be skipped.
     * @exception  EOFException if this input stream reaches the end before
     *             skipping all the bytes.
     * @exception  IOException if another I/O error occurs.
     */
    public static void skipFully(InputStream stream, long n) throws IOException {
        while (n &gt; 0) {
            long skipped = stream.skip(n);
            if (skipped &lt;= 0) {
                // check if the EOF is reached
                if (stream.read() == -1) {
                    throw new EOFException();
                }
                n--;
            } else {
                n -= skipped;
            }
        }
    }
//    public static PixelFormat getPixelFormat(ImageType type) {
//        PixelFormat format;
//        switch (type) {
//            case GRAY:
//                format = PixelFormat.BYTE_GRAY;
//                break;
//            case GRAY_ALPHA:
//            case GRAY_ALPHA_PRE:
//                format = PixelFormat.BYTE_RGBA_PRE;
//                break;
//            case PALETTE:
//                format = PixelFormat.BYTE_RGB;
//                break;
//            case PALETTE_ALPHA:
//            case PALETTE_ALPHA_PRE:
//                format = PixelFormat.BYTE_RGBA_PRE;
//                break;
//            case RGB:
//                format = PixelFormat.BYTE_RGB;
//                break;
//            case RGBA:
//            case RGBA_PRE:
//                format = PixelFormat.BYTE_RGBA_PRE;
//                break;
//            default:
//                // This should not be possible ...
//                throw new IllegalArgumentException(&quot;Unknown ImageType &quot; + type);
//        }
//
//        return format;
//    }
//    public static boolean isConversionACopy(ImageType type, PixelFormat format) {
//        return (type == ImageType.GRAY &amp;&amp; format == PixelFormat.BYTE_GRAY) ||
//                (type == ImageType.RGB &amp;&amp; format == PixelFormat.BYTE_RGB) ||
//                (type == ImageType.RGBA_PRE &amp;&amp; format == PixelFormat.BYTE_RGBA_PRE);
//    }
    public static ImageType getConvertedType(ImageType type) {
        ImageType retType = type;
        switch (type) {
            case GRAY:
                retType = ImageType.GRAY;
                break;
            case GRAY_ALPHA:
            case GRAY_ALPHA_PRE:
            case PALETTE_ALPHA:
            case PALETTE_ALPHA_PRE:
            case PALETTE_TRANS:
            case RGBA:
                retType = ImageType.RGBA_PRE;
                break;
            case PALETTE:
            case RGB:
                retType = ImageType.RGB;
                break;
            case RGBA_PRE:
                retType = ImageType.RGBA_PRE;
                break;
            default:
                throw new IllegalArgumentException(&quot;Unsupported ImageType &quot; + type);
        }
        return retType;
    }

    public static byte[] createImageArray(ImageType type, int width, int height) {
        int numBands = 0;
        switch (type) {
            case GRAY:
            case PALETTE:
            case PALETTE_ALPHA:
            case PALETTE_ALPHA_PRE:
                numBands = 1;
                break;
            case GRAY_ALPHA:
            case GRAY_ALPHA_PRE:
                numBands = 2;
                break;
            case RGB:
                numBands = 3;
                break;
            case RGBA:
            case RGBA_PRE:
                numBands = 4;
                break;
            default:
                throw new IllegalArgumentException(&quot;Unsupported ImageType &quot; + type);
        }
        return new byte[width * height * numBands];
    }

    public static ImageFrame convertImageFrame(ImageFrame frame) {
        ImageFrame retFrame;
        ImageType type = frame.getImageType();
        ImageType convertedType = getConvertedType(type);
        if (convertedType == type) {
            retFrame = frame;
        } else {
            byte[] inArray = null;
            Buffer buf = frame.getImageData();
            if (!(buf instanceof ByteBuffer)) {
                throw new IllegalArgumentException(&quot;!(frame.getImageData() instanceof ByteBuffer)&quot;);
            }
            ByteBuffer bbuf = (ByteBuffer) buf;
            if (bbuf.hasArray()) {
                inArray = bbuf.array();
            } else {
                inArray = new byte[bbuf.capacity()];
                bbuf.get(inArray);
            }
            int width = frame.getWidth();
            int height = frame.getHeight();
            int inStride = frame.getStride();
            byte[] outArray = createImageArray(convertedType, width, height);
            ByteBuffer newBuf = ByteBuffer.wrap(outArray);
            int outStride = outArray.length / height;
            byte[][] palette = frame.getPalette();
            ImageMetadata metadata = frame.getMetadata();
            int transparentIndex = metadata.transparentIndex != null ? metadata.transparentIndex : 0;
            convert(width, height, type,
                    inArray, 0, inStride, outArray, 0, outStride,
                    palette, transparentIndex, false);
            ImageMetadata imd = new ImageMetadata(metadata.gamma,
                    metadata.blackIsZero, null,
                    metadata.backgroundColor, null,
                    metadata.delayTime, metadata.loopCount,
                    metadata.imageWidth, metadata.imageHeight,
                    metadata.imageLeftPosition, metadata.imageTopPosition,
                    metadata.disposalMethod);
            retFrame = new ImageFrame(convertedType, newBuf, width, height,
                    outStride, null, imd);
        }
        return retFrame;
    }

    public static byte[] convert(int width, int height, ImageType inputType,
            byte[] input, int inputOffset, int inRowStride,
            byte[] output, int outputOffset, int outRowStride,
            byte[][] palette, int transparentIndex, boolean skipTransparent) {
        //
        // Take care of the layouts that are a direct copy.
        //
        if (inputType == ImageType.GRAY ||
                inputType == ImageType.RGB ||
                inputType == ImageType.RGBA_PRE) {
            if (input != output) {
                int bytesPerRow = width;
                if (inputType == ImageType.RGB) {
                    bytesPerRow *= 3;
                } else if (inputType == ImageType.RGBA_PRE) {
                    bytesPerRow *= 4;
                }
                if (height == 1) {
                    System.arraycopy(input, inputOffset, output, outputOffset, bytesPerRow);
                } else {
                    int inRowOffset = inputOffset;
                    int outRowOffset = outputOffset;
                    for (int row = 0; row &lt; height; row++) {
                        System.arraycopy(input, inRowOffset, output, outRowOffset, bytesPerRow);
                        inRowOffset += inRowStride;
                        outRowOffset += outRowStride;
                    }
                }
            }
        } else if (inputType == ImageType.GRAY_ALPHA || inputType == ImageType.GRAY_ALPHA_PRE) {
            int inOffset = inputOffset;
            int outOffset = outputOffset;
            if (inputType == ImageType.GRAY_ALPHA) {
                for (int y = 0; y &lt; height; y++) {
                    int inOff = inOffset;
                    int outOff = outOffset;
                    for (int x = 0; x &lt; width; x++) {
                        // copy input to local variables in case operating in place
                        byte gray = input[inOff++];
                        int alpha = input[inOff++] &amp; 0xff;
                        float f = alpha / 255.0F;
                        gray = (byte) (f * (gray &amp; 0xff));
                        output[outOff++] = gray;
                        output[outOff++] = gray;
                        output[outOff++] = gray;
                        output[outOff++] = (byte) alpha;
                    }
                    inOffset += inRowStride;
                    outOffset += outRowStride;
                }
            } else {
                for (int y = 0; y &lt; height; y++) {
                    int inOff = inOffset;
                    int outOff = outOffset;
                    for (int x = 0; x &lt; width; x++) {
                        // copy input to local variables in case operating in place
                        byte gray = input[inOff++];
                        output[outOff++] = gray;
                        output[outOff++] = gray;
                        output[outOff++] = gray;
                        output[outOff++] = input[inOff++];
                    }
                    inOffset += inRowStride;
                    outOffset += outRowStride;
                }
            }
        } else if (inputType == ImageType.PALETTE) {
            int inOffset = inputOffset;
            int outOffset = outputOffset;
            byte[] red = palette[0];
            byte[] green = palette[1];
            byte[] blue = palette[2];
            int inOff = inOffset;
            int outOff = outOffset;
            //loop through the scanline and mask for the value if each byte.
            //the byte is an index into the palette array for that pixel.
            for (int x = 0; x &lt; width; x++) {
                int index = (input[inOff++] &amp; 0xff);

                output[outOff++] = red[index];
                output[outOff++] = green[index];
                output[outOff++] = blue[index];

                outOffset += outRowStride;
            }
        } else if (inputType == ImageType.PALETTE_ALPHA) {
            int inOffset = inputOffset;
            int outOffset = outputOffset;
            byte[] red = palette[0];
            byte[] green = palette[1];
            byte[] blue = palette[2];
            byte[] alpha = palette[3];
                int inOff = inOffset;
                int outOff = outOffset;
                for (int x = 0; x &lt; width; x++) {
                    int index = input[inOff++] &amp; 0xff;
                    byte r = red[index];
                    byte g = green[index];
                    byte b = blue[index];
                    int a = alpha[index] &amp; 0xff;
                    float f = a / 255.0F;
                    output[outOff++] = (byte) (f * (r &amp; 0xff));
                    output[outOff++] = (byte) (f * (g &amp; 0xff));
                    output[outOff++] = (byte) (f * (b &amp; 0xff));
                    output[outOff++] = (byte) a;
                }
                inOffset += inRowStride;
                outOffset += outRowStride;
        } else if (inputType == ImageType.PALETTE_ALPHA_PRE) {
            int inOffset = inputOffset;
            int outOffset = outputOffset;
            byte[] red = palette[0];
            byte[] green = palette[1];
            byte[] blue = palette[2];
            byte[] alpha = palette[3];
            for (int y = 0; y &lt; height; y++) {
                int inOff = inOffset;
                int outOff = outOffset;
                for (int x = 0; x &lt; width; x++) {
                    int index = input[inOff++] &amp; 0xff;
                    output[outOff++] = red[index];
                    output[outOff++] = green[index];
                    output[outOff++] = blue[index];
                    output[outOff++] = alpha[index];
                }
                inOffset += inRowStride;
                outOffset += outRowStride;
            }
        } else if (inputType == ImageType.PALETTE_TRANS) {
            int inOffset = inputOffset;
            int outOffset = outputOffset;
            for (int y = 0; y &lt; height; y++) {
                int inOff = inOffset;
                int outOff = outOffset;
                byte[] red = palette[0];
                byte[] green = palette[1];
                byte[] blue = palette[2];
                for (int x = 0; x &lt; width; x++) {
                    int index = input[inOff++] &amp; 0xff;
                    if (index == transparentIndex) {
                        if (skipTransparent) {
                            outOff+=4;
                        } else {
                            output[outOff++] = (byte) 0;
                            output[outOff++] = (byte) 0;
                            output[outOff++] = (byte) 0;
                            output[outOff++] = (byte) 0;
                        }
                    } else {
                        output[outOff++] = red[index];
                        output[outOff++] = green[index];
                        output[outOff++] = blue[index];
                        output[outOff++] = (byte) 255;
                    }
                }
                inOffset += inRowStride;
                outOffset += outRowStride;
            }
        } else if (inputType == ImageType.RGBA) {
            int inOffset = inputOffset;
            int outOffset = outputOffset;
            for (int y = 0; y &lt; height; y++) {
                int inOff = inOffset;
                int outOff = outOffset;
                for (int x = 0; x &lt; width; x++) {
                    // copy input to local variables in case operating in place
                    byte red = input[inOff++];
                    byte green = input[inOff++];
                    byte blue = input[inOff++];
                    int alpha = input[inOff++] &amp; 0xff;
                    float f = alpha / 255.0F;
                    output[outOff++] = (byte) (f * (red &amp; 0xff));
                    output[outOff++] = (byte) (f * (green &amp; 0xff));
                    output[outOff++] = (byte) (f * (blue &amp; 0xff));
                    output[outOff++] = (byte) alpha;
                }
//                System.arraycopy(input, inOffset, output, outOffset, width*4);
                inOffset += inRowStride;
                outOffset += outRowStride;
            }
        } else {
            throw new UnsupportedOperationException(&quot;Unsupported ImageType &quot; +
                    inputType);
        }

        return output;
    }

    public static String getScaledImageName(String path) {
        StringBuilder result = new StringBuilder();
        int slash = path.lastIndexOf('/');
        String name = (slash &lt; 0) ? path : path.substring(slash + 1);
        int dot = name.lastIndexOf(&quot;.&quot;);
        if (dot &lt; 0) {
            dot = name.length();
        }
        if (slash &gt;= 0) {
            result.append(path.substring(0, slash + 1));
        }
        result.append(name.substring(0, dot));
        result.append(&quot;@2x&quot;);
        result.append(name.substring(dot));
        return result.toString();
    }

    public static InputStream createInputStream(String input) throws IOException {
        InputStream stream = null;

        // there should be a central utility  for mapping these Strings to their
        // inputStreams
        try {
            File file = new File(input);
            if (file.exists()) {
                stream = new FileInputStream(file);
            }
        } catch (Exception e) {
            // ignore exception and try as url.
        }
        if (stream == null) {
            URL url = new URL(input);
            stream = url.openStream();
        }
        return stream;
    }

    // Helper for computeUpdatedPixels method
    private static void computeUpdatedPixels(int sourceOffset,
            int sourceExtent,
            int destinationOffset,
            int dstMin,
            int dstMax,
            int sourceSubsampling,
            int passStart,
            int passExtent,
            int passPeriod,
            int[] vals,
            int offset) {
        // We need to satisfy the congruences:
        // dst = destinationOffset + (src - sourceOffset)/sourceSubsampling
        //
        // src - passStart == 0 (mod passPeriod)
        // src - sourceOffset == 0 (mod sourceSubsampling)
        //
        // subject to the inequalities:
        //
        // src &gt;= passStart
        // src &lt; passStart + passExtent
        // src &gt;= sourceOffset
        // src &lt; sourceOffset + sourceExtent
        // dst &gt;= dstMin
        // dst &lt;= dstmax
        //
        // where
        //
        // dst = destinationOffset + (src - sourceOffset)/sourceSubsampling
        //
        // For now we use a brute-force approach although we could
        // attempt to analyze the congruences.  If passPeriod and
        // sourceSubsamling are relatively prime, the period will be
        // their product.  If they share a common factor, either the
        // period will be equal to the larger value, or the sequences
        // will be completely disjoint, depending on the relationship
        // between passStart and sourceOffset.  Since we only have to do this
        // twice per image (once each for X and Y), it seems cheap enough
        // to do it the straightforward way.

        boolean gotPixel = false;
        int firstDst = -1;
        int secondDst = -1;
        int lastDst = -1;

        for (int i = 0; i &lt; passExtent; i++) {
            int src = passStart + i * passPeriod;
            if (src &lt; sourceOffset) {
                continue;
            }
            if ((src - sourceOffset) % sourceSubsampling != 0) {
                continue;
            }
            if (src &gt;= sourceOffset + sourceExtent) {
                break;
            }

            int dst = destinationOffset +
                    (src - sourceOffset) / sourceSubsampling;
            if (dst &lt; dstMin) {
                continue;
            }
            if (dst &gt; dstMax) {
                break;
            }

            if (!gotPixel) {
                firstDst = dst; // Record smallest valid pixel
                gotPixel = true;
            } else if (secondDst == -1) {
                secondDst = dst; // Record second smallest valid pixel
            }
            lastDst = dst; // Record largest valid pixel
        }

        vals[offset] = firstDst;

        // If we never saw a valid pixel, set width to 0
        if (!gotPixel) {
            vals[offset + 2] = 0;
        } else {
            vals[offset + 2] = lastDst - firstDst + 1;
        }

        // The period is given by the difference of any two adjacent pixels
        vals[offset + 4] = Math.max(secondDst - firstDst, 1);
    }

    /**
     * A utility method that computes the exact set of destination
     * pixels that will be written during a particular decoding pass.
     * The intent is to simplify the work done by readers in combining
     * the source region, source subsampling, and destination offset
     * information obtained from the &lt;code&gt;ImageReadParam&lt;/code&gt; with
     * the offsets and periods of a progressive or interlaced decoding
     * pass.
     *
     * @param sourceRegion a &lt;code&gt;Rectangle&lt;/code&gt; containing the
     * source region being read, offset by the source subsampling
     * offsets, and clipped against the source bounds, as returned by
     * the &lt;code&gt;getSourceRegion&lt;/code&gt; method.
     * @param destinationOffset a &lt;code&gt;Point&lt;/code&gt; containing the
     * coordinates of the upper-left pixel to be written in the
     * destination.
     * @param dstMinX the smallest X coordinate (inclusive) of the
     * destination &lt;code&gt;Raster&lt;/code&gt;.
     * @param dstMinY the smallest Y coordinate (inclusive) of the
     * destination &lt;code&gt;Raster&lt;/code&gt;.
     * @param dstMaxX the largest X coordinate (inclusive) of the destination
     * &lt;code&gt;Raster&lt;/code&gt;.
     * @param dstMaxY the largest Y coordinate (inclusive) of the destination
     * &lt;code&gt;Raster&lt;/code&gt;.
     * @param sourceXSubsampling the X subsampling factor.
     * @param sourceYSubsampling the Y subsampling factor.
     * @param passXStart the smallest source X coordinate (inclusive)
     * of the current progressive pass.
     * @param passYStart the smallest source Y coordinate (inclusive)
     * of the current progressive pass.
     * @param passWidth the width in pixels of the current progressive
     * pass.
     * @param passHeight the height in pixels of the current progressive
     * pass.
     * @param passPeriodX the X period (horizontal spacing between
     * pixels) of the current progressive pass.
     * @param passPeriodY the Y period (vertical spacing between
     * pixels) of the current progressive pass.
     *
     * @return an array of 6 &lt;code&gt;int&lt;/code&gt;s containing the
     * destination min X, min Y, width, height, X period and Y period
     * of the region that will be updated.
     */
    public static int[] computeUpdatedPixels(Rectangle sourceRegion,
            Point2D destinationOffset,
            int dstMinX,
            int dstMinY,
            int dstMaxX,
            int dstMaxY,
            int sourceXSubsampling,
            int sourceYSubsampling,
            int passXStart,
            int passYStart,
            int passWidth,
            int passHeight,
            int passPeriodX,
            int passPeriodY) {
        int[] vals = new int[6];
        computeUpdatedPixels(sourceRegion.x, sourceRegion.width,
                (int) (destinationOffset.x + 0.5F),
                dstMinX, dstMaxX, sourceXSubsampling,
                passXStart, passWidth, passPeriodX,
                vals, 0);
        computeUpdatedPixels(sourceRegion.y, sourceRegion.height,
                (int) (destinationOffset.y + 0.5F),
                dstMinY, dstMaxY, sourceYSubsampling,
                passYStart, passHeight, passPeriodY,
                vals, 1);
        return vals;
    }

    public static int[] computeDimensions(int sourceWidth, int sourceHeight,
            int maxWidth, int maxHeight, boolean preserveAspectRatio) {
        // ensure non-negative dimensions (0 implies default)
        int finalWidth = maxWidth &lt; 0 ? 0 : maxWidth;
        int finalHeight = maxHeight &lt; 0 ? 0 : maxHeight;

        if(finalWidth == 0 &amp;&amp; finalHeight == 0) {
            // default to source dimensions
            finalWidth = sourceWidth;
            finalHeight = sourceHeight;
        } else if (finalWidth != sourceWidth || finalHeight != sourceHeight) {
            if (preserveAspectRatio) {
                // compute the final dimensions
                if (finalWidth == 0) {
                    finalWidth = (int) ((float) sourceWidth * finalHeight / sourceHeight);
                } else if (finalHeight == 0) {
                    finalHeight = (int) ((float) sourceHeight * finalWidth / sourceWidth);
                } else {
                    float scale = Math.min((float) finalWidth / sourceWidth, (float) finalHeight / sourceHeight);
                    finalWidth = (int) (sourceWidth * scale);
                    finalHeight = (int) (sourceHeight * scale);
                }
            } else {
                // set final dimensions to default if zero
                if (finalHeight == 0) {
                    finalHeight = sourceHeight;
                }
                if (finalWidth == 0) {
                    finalWidth = sourceWidth;
                }
            }


            // clamp dimensions to positive values
            if (finalWidth == 0) {
                finalWidth = 1;
            }
            if (finalHeight == 0) {
                finalHeight = 1;
            }
        }
<A NAME="40"></A>

        return new int[]{finalWidth, finalHeight};
    <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#40',2,'match44-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public static ImageFrame scaleImageFrame(ImageFrame src,
            int destWidth, int destHeight, boolean isSmooth)
    {
        int numBands = ImageStorage.getNumBands(src.getImageType());
        ByteBuffer dst = scaleImage((ByteBuffer) src.getImageData</B></FONT>(),
                src.getWidth(), src.getHeight(), numBands,
                destWidth, destHeight, isSmooth);
        return new ImageFrame(src.getImageType(), dst,
                destWidth, destHeight, destWidth * numBands, null, src.getMetadata());
    }

    public static ByteBuffer scaleImage(ByteBuffer src,
            int sourceWidth, int sourceHeight, int numBands,
            int destWidth, int destHeight, boolean isSmooth)
    {
        PushbroomScaler scaler = ScalerFactory.createScaler(
                sourceWidth, sourceHeight, numBands,
                destWidth, destHeight, isSmooth);

        int stride = sourceWidth * numBands;
        if (src.hasArray()) {
            byte image[] = src.array();
            for (int y = 0; y != sourceHeight; ++y) {
                scaler.putSourceScanline(image, y * stride);
            }
        } else {
            byte scanline[] = new byte[stride];
            for (int y = 0; y != sourceHeight; ++y) {
                src.get(scanline);
                scaler.putSourceScanline(scanline, 0);
            }
        }

        return scaler.getDestination();
    }
//    public static final java.awt.image.BufferedImage getAsBufferedImage(Image prismImage) {
//        java.awt.image.BufferedImage image = null;
//
//        int width = prismImage.getWidth();
//        int height = prismImage.getHeight();
//        int scanlineStride = prismImage.getScanlineStride();
//        byte[] pixels = ((java.nio.ByteBuffer) prismImage.getPixelBuffer()).array();
//        switch (prismImage.getPixelFormat()) {
//            case BYTE_GRAY: {
//                image = new java.awt.image.BufferedImage(width, height,
//                        java.awt.image.BufferedImage.TYPE_BYTE_GRAY);
//                java.awt.image.DataBufferByte db =
//                        (java.awt.image.DataBufferByte) image.getRaster().getDataBuffer();
//                byte[] data = db.getData();
//                System.arraycopy(pixels, 0, data, 0, width * height);
//            }
//            break;
//            case BYTE_RGB: {
//                image = new java.awt.image.BufferedImage(width, height,
//                        java.awt.image.BufferedImage.TYPE_3BYTE_BGR);
//                for (int y = 0; y &lt; height; y++) {
//                    int off = y * scanlineStride;
//                    for (int x = 0; x &lt; width; x++) {
//                        int rgb = ((pixels[off++] &amp; 0xff) &lt;&lt; 16) |
//                                ((pixels[off++] &amp; 0xff) &lt;&lt; 8) |
//                                (pixels[off++] &amp; 0xff);
//                        image.setRGB(x, y, rgb);
//                    }
//                }
//            }
//            break;
//            case BYTE_RGBA_PRE: {
//                image = new java.awt.image.BufferedImage(width, height,
//                        java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE);
////                for (int y = 0; y &lt; height; y++) {
////                    int off = y * scanlineStride;
////                    for (int x = 0; x &lt; width; x++) {
////                        int rgb = ((pixels[off++] &amp; 0xff) &lt;&lt; 16) |
////                                ((pixels[off++] &amp; 0xff) &lt;&lt; 8) |
////                                (pixels[off++] &amp; 0xff) |
////                                ((pixels[off++] &amp; 0xff) &lt;&lt; 24);
////                        image.setRGB(x, y, rgb);
////                    }
////                }
//                java.awt.image.DataBufferByte db =
//                        (java.awt.image.DataBufferByte) image.getRaster().getDataBuffer();
//                byte[] data = db.getData();
//                for (int y = 0; y &lt; height; y++) {
//                    int offPrism = y * scanlineStride;
//                    int offImage = y * width * 4;
//                    for (int x = 0; x &lt; width; x++) {
//                        data[offImage++] = pixels[offPrism + 3]; // A
//                        data[offImage++] = pixels[offPrism + 2]; // B
//                        data[offImage++] = pixels[offPrism + 1]; // G
//                        data[offImage++] = pixels[offPrism];     // R
//                        offPrism += 4;
//                    }
//                }
//            }
//            break;
//            default:
//                throw new UnsupportedOperationException(&quot;Unsupported test case &quot; +
//                        prismImage.getPixelFormat());
//        }
//
//        return image;
//    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/iio/gif/GIFImageLoader2.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.iio.gif;

import com.sun.javafx.iio.ImageFrame;
import com.sun.javafx.iio.ImageMetadata;
import com.sun.javafx.iio.ImageStorage;
import com.sun.javafx.iio.common.ImageLoaderImpl;
import com.sun.javafx.iio.common.ImageTools;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;

/*
 * loader implementation for GIF89 file format
 */

public class GIFImageLoader2 extends ImageLoaderImpl {

    static final byte FILE_SIG87[] = {'G', 'I', 'F', '8', '7', 'a'};
    static final byte FILE_SIG89[] = {'G', 'I', 'F', '8', '9', 'a'};
    static final byte NETSCAPE_SIG[] = {'N', 'E', 'T', 'S', 'C', 'A', 'P', 'E', '2', '.', '0'};
    static final int DEFAULT_FPS = 25;

    InputStream stream = null;
    int screenW, screenH, bgColor;
    byte globalPalette[][];  // r,g,b,a
    byte image[];
<A NAME="29"></A>    int loopCount = 1;

    public GIFImageLoader2(InputStream input) throws IOException {
        <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#29',2,'match44-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super(GIFDescriptor.getInstance());
        this.stream = input;
        readGlobalHeader();
    }

    // read GIF file header
    private void readGlobalHeader() throws IOException {
        byte signature[] = readBytes(new byte[6])</B></FONT>;
        if (!Arrays.equals(FILE_SIG87, signature) &amp;&amp; !Arrays.equals(FILE_SIG89, signature)) {
            throw new IOException(&quot;Bad GIF signature!&quot;);
        }
        screenW = readShort();
        screenH = readShort();
        int cInfo = readByte();
        bgColor = readByte();
        int aspectR = readByte();

        if ((cInfo &amp; 0x80) != 0) {
            globalPalette = readPalete(2 &lt;&lt; (cInfo &amp; 7), -1);
        }
        image = new byte[screenW * screenH * 4];
    }

    // read palette data from the stream
    private byte[][] readPalete(int size, int trnsIndex) throws IOException {
        byte palette[][] = new byte[4][size];
        byte paletteData[] = readBytes(new byte[size*3]);
        for (int i = 0, idx = 0; i != size; ++i) {
            for (int k = 0; k != 3; ++k) {
                palette[k][i] = paletteData[idx++];
            }
            palette[3][i] = (i == trnsIndex) ? 0 : (byte)0xFF;
        }
        return palette;
    }

    // skip an extension
    private void consumeAnExtension() throws IOException {
        for (int blSize = readByte(); blSize != 0; blSize = readByte()) {
            skipBytes(blSize);
        }
    }

    private void readAppExtension() throws IOException {
        int size = readByte();
        byte buf[] = readBytes(new byte[size]);
        if (Arrays.equals(NETSCAPE_SIG, buf)) {
            for (int subBlockSize = readByte(); subBlockSize != 0; subBlockSize = readByte()) {
                byte subBlock[] = readBytes(new byte[subBlockSize]);
                int subBlockId = subBlock[0];
                if (subBlockSize == 3 &amp;&amp; subBlockId == 1) { // loop count extension
                    loopCount = (subBlock[1] &amp; 0xff) | ((subBlock[2] &amp; 0xff) &lt;&lt; 8);
                }
            }
        } else {
            consumeAnExtension(); // read data sub-blocks
        }
    }

    // reads Image Control extension information
    // returns ((pField &amp; 0x1F) &lt;&lt; 24) + (trnsIndex &lt;&lt; 16) + frameDelay;
    private int readControlCode() throws IOException {
        int size = readByte();
        int pField = readByte();
        int frameDelay = readShort();
        int trnsIndex = readByte();

        if (size != 4 || readByte() != 0) {
            throw new IOException(&quot;Bad GIF GraphicControlExtension&quot;);
        }
        return ((pField &amp; 0x1F) &lt;&lt; 24) + (trnsIndex &lt;&lt; 16) + frameDelay;
    }

    // The method waits until image data in the stream
    // The method also reads and return Image Control extension information
    // returns -1 if EOF reached or the value of readControlCode
    private int waitForImageFrame() throws IOException {
        int controlData = 0;
        while (true) {
            int ch = stream.read();
            switch (ch) {
                case 0x2C:
                    return controlData;
                case 0x21:
                    switch (readByte()) {
                        case 0xF9:
                            controlData = readControlCode();
                            break;
                        case 0xFF:
                            readAppExtension();
                            break;
                        default:
                            consumeAnExtension();
                    }
                    break;
                case -1: case 0x3B: // EOF or end of GIF
                    return -1;
                default:
                    throw new IOException(&quot;Unexpected GIF control characher 0x&quot;
                            + String.format(&quot;%02X&quot;, ch));
            }
        }
    }

    // Decode the one frame of GIF form the input stread using internal LZWDecoder class
    private void decodeImage(byte image[], int w, int h, int interlace[]) throws IOException {
        LZWDecoder dec = new LZWDecoder();
        byte data[] = dec.getString();
        int y = 0, iPos = 0, xr = w;
        while (true) {
            int len = dec.readString();
            if (len == -1) { // end of stream
                dec.waitForTerminator();
                return;
            }
            for (int pos = 0; pos != len;) {
                int ax = xr &lt; (len - pos) ? xr : (len - pos);
                System.arraycopy(data, pos, image, iPos, ax);
                iPos += ax;
                pos += ax;
                if ((xr -= ax) == 0) {
                    if (++y == h) { // image is full
                        dec.waitForTerminator();
                        return;
                    }
                    int iY = interlace == null ? y : interlace[y];
                    iPos = iY * w;
                    xr = w;
                }
            }
        }
    }

    // computes row re-index for interlaced case
    private int[] computeInterlaceReIndex(int h) {
        int data[] = new int[h], pos = 0;
        for (int i = 0; i &lt; h; i += 8) data[pos++] = i;
        for (int i = 4; i &lt; h; i += 8) data[pos++] = i;
        for (int i = 2; i &lt; h; i += 4) data[pos++] = i;
        for (int i = 1; i &lt; h; i += 2) data[pos++] = i;
        return data;
    }

    // loads next image frame or null if no more
    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {
        int imageControlCode = waitForImageFrame();

        if (imageControlCode &lt; 0) {
            return null;
        }

        int left = readShort(), top = readShort(), w = readShort(), h = readShort();

        // check if the image is in the virtual screen boundaries
        if (left + w &gt; screenW || top + h &gt; screenH) {
            throw new IOException(&quot;Wrong GIF image frame size&quot;);
        }

        int imgCtrl = readByte();

        boolean isTRNS = ((imageControlCode &gt;&gt;&gt; 24) &amp; 1) == 1;
        int trnsIndex = isTRNS ? (imageControlCode &gt;&gt;&gt; 16) &amp; 0xFF : -1;
        boolean localPalette = (imgCtrl &amp; 0x80) != 0;
        boolean isInterlaced = (imgCtrl &amp; 0x40) != 0;

        byte palette[][] = localPalette ? readPalete(2 &lt;&lt; (imgCtrl &amp; 7), trnsIndex) : globalPalette;

        int[] outWH = ImageTools.computeDimensions(screenW, screenH, width, height, preserveAspectRatio);
        width = outWH[0];
        height = outWH[1];

        ImageMetadata metadata = updateMetadata(width, height, imageControlCode &amp; 0xFFFF);

        int disposalCode = (imageControlCode &gt;&gt;&gt; 26) &amp; 7;
        byte pImage[] = new byte[w * h];
        decodeImage(pImage, w, h, isInterlaced ? computeInterlaceReIndex(h) : null);

        ByteBuffer img = decodePalette(pImage, palette, trnsIndex,
                left, top, w, h, disposalCode);

        if (screenW != width || screenH != height) {
            img = ImageTools.scaleImage(img, screenW, screenH, 4,
                    width, height, smooth);
        }

        return new ImageFrame(ImageStorage.ImageType.RGBA, img,
                width, height, width * 4, null, metadata);
    }

    // IO helpers
    private int readByte() throws IOException {
        int ch = stream.read();
        if (ch &lt; 0) {
            throw new EOFException();
        }
        return ch;
    }

    private int readShort() throws IOException {
        int lsb = readByte(), msb = readByte();
        return lsb + (msb &lt;&lt; 8);
    }

    private byte[] readBytes(byte data[]) throws IOException {
        return readBytes(data, 0, data.length);
    }

    private byte[] readBytes(byte data[], int offs, int size) throws IOException {
        while (size &gt; 0) {
            int sz = stream.read(data, offs, size);
            if (sz &lt; 0) {
                throw new EOFException();
            }
            offs += sz;
            size -= sz;
        }
        return data;
    }

    private void skipBytes(int n) throws IOException {
        ImageTools.skipFully(stream, n);
    }

    public void dispose() {}

    // GIF specification states that restore to background should fill the frame
    // with background color, but actually all modern programs fill with transparent color.
    private void restoreToBackground(byte img[], int left, int top, int w, int h) {
        for (int y = 0; y != h; ++y) {
            int iPos = ((top + y) * screenW + left) * 4;
            for (int x = 0; x != w; iPos += 4, ++x) {
                img[iPos + 3] = 0;
            }
        }
    }

    // decode palletized image into RGBA
    private ByteBuffer decodePalette(byte[] srcImage, byte[][] palette, int trnsIndex,
            int left, int top, int w, int h, int disposalCode) {

        byte img[] = (disposalCode == 3) ? image.clone() : image;

        for (int y = 0; y != h; ++y) {
            int iPos = ((top + y) * screenW + left) * 4;
            int i = y * w;
            if (trnsIndex &lt; 0) {
                for (int x = 0; x != w; iPos += 4, ++x) {
                    int index = 0xFF &amp; srcImage[i + x];
                    img[iPos + 0] = palette[0][index];
                    img[iPos + 1] = palette[1][index];
                    img[iPos + 2] = palette[2][index];
                    img[iPos + 3] = palette[3][index];
                }
            } else {
                for (int x = 0; x != w; iPos += 4, ++x) {
                    int index = 0xFF &amp; srcImage[i + x];
                    if (index != trnsIndex) {
                        img[iPos + 0] = palette[0][index];
                        img[iPos + 1] = palette[1][index];
                        img[iPos + 2] = palette[2][index];
                        img[iPos + 3] = palette[3][index];
                    }
                }
            }
        }

        if (disposalCode != 3) img = img.clone();
        if (disposalCode == 2) restoreToBackground(image, left, top, w, h);

        return ByteBuffer.wrap(img);
    }

    // fill metadata
    private ImageMetadata updateMetadata(int w, int h, int delayTime) {
        ImageMetadata metaData = new ImageMetadata(null, true, null, null, null,
                delayTime != 0 ? delayTime*10 : 1000/DEFAULT_FPS, loopCount, w, h, null, null, null);
        updateImageMetadata(metaData);
        return metaData;
    }

    class LZWDecoder {
        private final int initCodeSize, clearCode, eofCode;
        private int codeSize, codeMask, tableIndex, oldCode;

        // input data buffer
        private int blockLength = 0, blockPos = 0;
        private byte block[] = new byte[255];
        private int inData = 0, inBits = 0;

        // table
        private int[] prefix = new int[4096];
        private byte[] suffix = new byte[4096];
        private byte[] initial = new byte[4096];
        private int[] length = new int[4096];
        private byte[] string = new byte[4096];

        public LZWDecoder() throws IOException {
            initCodeSize = readByte();
            clearCode = 1 &lt;&lt; initCodeSize;
            eofCode = clearCode + 1;
            initTable();
        }

        // decode next string of data, which can be accessed by getString() method
        public final int readString() throws IOException {
            int code = getCode();
            if (code == eofCode) {
                return -1;
            } else if (code == clearCode) {
                initTable();
                code = getCode();
                if (code == eofCode) {
                    return -1;
                }
            } else {
                int newSuffixIndex;
                int ti = tableIndex;
                if (code &lt; ti) {
                    newSuffixIndex = code;
                } else { // code == tableIndex
                    newSuffixIndex = oldCode;
                    if (code != ti) {
                        throw new IOException(&quot;Bad GIF LZW: Out-of-sequence code!&quot;);
                    }
                }

                int oc = oldCode;

                prefix[ti] = oc;
                suffix[ti] = initial[newSuffixIndex];
                initial[ti] = initial[oc];
                length[ti] = length[oc] + 1;

                ++tableIndex;
                if ((tableIndex == (1 &lt;&lt; codeSize)) &amp;&amp; (tableIndex &lt; 4096)) {
                    ++codeSize;
                    codeMask = (1 &lt;&lt; codeSize) - 1;
                }
            }
            // Reverse code
            int c = code;
            int len = length[c];
            for (int i = len - 1; i &gt;= 0; i--) {
                string[i] = suffix[c];
                c = prefix[c];
            }

            oldCode = code;
            return len;
        }

        // data accessor, the data length returned by readString method
        public final byte[] getString() { return string; }

        // waits until data ends
        public final void waitForTerminator() throws IOException {
            consumeAnExtension();
        }

        // initialize LZW dctionary
        private void initTable() {
            int numEntries = 1 &lt;&lt; initCodeSize;
            for (int i = 0; i &lt; numEntries; i++) {
                prefix[i] = -1;
                suffix[i] = (byte) i;
                initial[i] = (byte) i;
                length[i] = 1;
            }

            // fill in the entire table for robustness against
            // out-of-sequence codes.
            for (int i = numEntries; i &lt; 4096; i++) {
                prefix[i] = -1;
                length[i] = 1;
            }

            codeSize = initCodeSize + 1;
            codeMask = (1 &lt;&lt; codeSize) - 1;
            tableIndex = numEntries + 2;
            oldCode = 0;
        }

        // reads codeSize bits from the stream
        private int getCode()  throws IOException  {
            while (inBits &lt; codeSize) {
                inData |= nextByte() &lt;&lt; inBits;
                inBits += 8;
            }
            int code = inData &amp; codeMask;
            inBits -= codeSize;
            inData &gt;&gt;&gt;= codeSize;
            return code;
        }

        // reads next in byte
        private int nextByte() throws IOException {
            if (blockPos == blockLength) {
                readData();
            }
            return (int)block[blockPos++] &amp; 0xFF;
        }

        // reads next block if data
        private void readData() throws IOException {
            blockPos = 0;
            blockLength = readByte();
            if (blockLength &gt; 0) {
                readBytes(block, 0, blockLength);
            } else {
                throw new EOFException();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/GlassStage.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="50"></A> * questions.
 */

<FONT color="#ff0000"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#50',2,'match44-top.html#50',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.tk.quantum;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.EventLoop;
import com.sun.javafx.tk.FocusCause;
import com.sun.javafx.tk.TKScene;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.TKStageListener;
import com.sun.javafx.tk.Toolkit;

abstract class GlassStage implements TKStage {

    // A list of all GlassStage objects regardless of visibility.
    private static final List&lt;GlassStage&gt; windows = new ArrayList&lt;&gt;();

    // A list of currently visible important windows. This list is used to
    // check if the application should exit, when idle
    private static List&lt;TKStage&gt; importantWindows = new ArrayList&lt;&gt;()</B></FONT>;

    private GlassScene scene;

    protected TKStageListener stageListener;

    private boolean visible;

    private boolean important = true;

    private AccessControlContext accessCtrlCtx = null;

    protected static final AtomicReference&lt;GlassStage&gt; activeFSWindow = new AtomicReference&lt;&gt;();

    protected GlassStage() {
        windows.add(this);
    }

    @Override public void close() {
        assert scene == null; // close() is called after setScene(null)
        windows.remove(this);
        importantWindows.remove(this);
        notifyWindowListeners();
    }

    /**
     * Listener for this stage peer to pass updates and events back to the stage
     *
     * @param listener The listener provided by the stage
     */
    @Override public void setTKStageListener(final TKStageListener listener) {
        this.stageListener = listener;
    }

    protected final GlassScene getScene() {
        return scene;
    }

    @Override public void setScene(TKScene scene) {
        if (this.scene != null) {
            this.scene.setStage(null);
        }
        this.scene = (GlassScene)scene;
        if (this.scene != null) {
            this.scene.setStage(this);
        }
    }

    // To be used by subclasses to enforce context check
    final AccessControlContext getAccessControlContext() {
        if (accessCtrlCtx == null) {
            throw new RuntimeException(&quot;Stage security context has not been set!&quot;);
        }
        return accessCtrlCtx;
    }

    static AccessControlContext doIntersectionPrivilege(PrivilegedAction&lt;AccessControlContext&gt; action,
                                                       AccessControlContext stack,
                                                       AccessControlContext context) {
        return AccessController.doPrivileged((PrivilegedAction&lt;AccessControlContext&gt;) () -&gt; {
            return AccessController.doPrivilegedWithCombiner((PrivilegedAction&lt;AccessControlContext&gt;) () -&gt; {
                return AccessController.getContext();
            }, stack);
        },  context);
    }

    public final void setSecurityContext(AccessControlContext ctx) {
        if (accessCtrlCtx != null) {
            throw new RuntimeException(&quot;Stage security context has been already set!&quot;);
        }
        AccessControlContext acc = AccessController.getContext();
        // JDK doesn't provide public APIs to get ACC intersection,
        // so using this ugly workaround
        accessCtrlCtx = doIntersectionPrivilege(
                () -&gt; AccessController.getContext(), acc, ctx);
    }

    @Override public void requestFocus() {
    }

    @Override public void requestFocus(FocusCause cause) {
    }

    /**
     * Set if the stage is visible on screen
     *
     * @param visible True if the stage should be visible
     */
    @Override public void setVisible(boolean visible) {
        this.visible = visible;
        if (visible) {
            if (important) {
                importantWindows.add(this);
                notifyWindowListeners();
            }
        } else {
            if (important) {
                importantWindows.remove(this);
                notifyWindowListeners();
            }
        }
        if (scene != null) {
            scene.stageVisible(visible);
        }
    }

    boolean isVisible() {
        return visible;
    }

    // We do blocking on windows that are backed by WindowStage and EmbeddedStage
    protected void setPlatformEnabled(boolean enabled) {
        // Overridden in subclasses
    }

    void windowsSetEnabled(boolean enabled) {
        // TODO: Need to solve RT-12605:
        // If Window #1 pops up an APPLICATION modal dialog #2 it should block
        // Window #1, but will also block Window #3, #4, etc., unless those
        // windows are descendants of #2.

        // Make a copy of the windows list, since it could change as the result
        // of a child window being closed when the parent is closed.
        for (GlassStage window : windows.toArray(new GlassStage[windows.size()])) {
            if (window != this &amp;&amp; windows.contains(window)) {
                window.setPlatformEnabled(enabled);
            }
        }
    }

    @Override
    public void setImportant(boolean important) {
        this.important = important;
    }

    private static void notifyWindowListeners() {
        Toolkit.getToolkit().notifyWindowListeners(importantWindows);
    }

    // Cmd+Q action
    static void requestClosingAllWindows() {
        GlassStage fsWindow = activeFSWindow.get();
        if (fsWindow != null) {
            fsWindow.setFullScreen(false);
        }

        for (final GlassStage window : windows.toArray(new GlassStage[windows.size()])) {
            // In case of child windows some of them could already be closed
            // so check if list still contains an object
            if (windows.contains(window) &amp;&amp; window.isVisible() &amp;&amp; window.stageListener != null) {
                AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                    window.stageListener.closing();
                    return null;
                }, window.getAccessControlContext());
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/QuantumClipboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FilePermission;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.net.MalformedURLException;
import java.net.SocketPermission;
import java.net.URL;
import java.nio.ByteBuffer;
import java.security.AccessControlContext;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.scene.image.Image;
import javafx.scene.input.DataFormat;
import javafx.scene.input.TransferMode;
import javafx.util.Pair;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Clipboard;
import com.sun.glass.ui.ClipboardAssistance;
import com.sun.glass.ui.Pixels;
import com.sun.javafx.tk.ImageLoader;
import com.sun.javafx.tk.PermissionHelper;
import com.sun.javafx.tk.TKClipboard;
import com.sun.javafx.tk.Toolkit;
import javafx.scene.image.PixelReader;
import java.io.ObjectStreamClass;
import javafx.scene.image.WritablePixelFormat;

/**
 * The implementation of TKClipboard, which is used both for clipboards
 * and dragboards.
 */
final class QuantumClipboard implements TKClipboard {

    /**
     * Handle to the Glass peer.
     */
    private ClipboardAssistance systemAssistant;

    /**
     * Security access context for image loading
     *      com.sun.javafx.tk.quantum.QuantumClipboard
     *      javafx.scene.input.Clipboard
     *          ... user code ...
     */
    private AccessControlContext accessContext = null;

    /**
     * Distinguishes between clipboard and dragboard. This is needed
     * because dragboard's flush() starts DnD operation so it mustn't be
     * called too early.
     */
    private boolean isCaching;

    /**
     * Cache of the data used for dragboard between setting them and flushing
     * them to system dragboard.
     */
    private List&lt;Pair&lt;DataFormat, Object&gt;&gt; dataCache;

    /**
     * Cache of the transfer modes used for dragboard between setting them and
     * flushing them to system dragboard.
     */
    private Set&lt;TransferMode&gt; transferModesCache;

    /**
     * An image which is displayed during the drag operation. Set by the user.
     */
    private Image dragImage = null;

    /**
     * An offset of the image which is displayed during the drag operation.
     * Set by the user.
     */
    private double dragOffsetX = 0;
    private double dragOffsetY = 0;

    private static ClipboardAssistance currentDragboard;

    /**
     * Disallow direct creation of QuantumClipboard
     */
    private QuantumClipboard() {
    }

    @Override public void setSecurityContext(AccessControlContext acc) {
        if (accessContext != null) {
            throw new RuntimeException(&quot;Clipboard security context has been already set!&quot;);
        }
        accessContext = acc;
    }

    private AccessControlContext getAccessControlContext() {
        if (accessContext == null) {
            throw new RuntimeException(&quot;Clipboard security context has not been set!&quot;);
        }
        return accessContext;
    }

    /**
     * Gets an instance of QuantumClipboard for the given assistant. This may be
     * a new instance after each call.
     * @param assistant
     * @return
     */
    public static QuantumClipboard getClipboardInstance(ClipboardAssistance assistant) {
        QuantumClipboard c = new QuantumClipboard();
        c.systemAssistant = assistant;
        c.isCaching = false;
        return c;
    }

    static ClipboardAssistance getCurrentDragboard() {
        return currentDragboard;
    }

    static void releaseCurrentDragboard() {
        // RT-34510: assert currentDragboard != null;
        currentDragboard = null;
    }

    /**
     * Gets an instance of QuantumClipboard for the given assistant for usage
     * as dragboard during drag and drop. It doesn't flush the data implicitly
     * and caches them until flush() is called. This may be
     * a new instance after each call.
     * @param assistant
     * @return
     */
    public static QuantumClipboard getDragboardInstance(ClipboardAssistance assistant, boolean isDragSource) {
        QuantumClipboard c = new QuantumClipboard();
        c.systemAssistant = assistant;
        c.isCaching = true;
        if (isDragSource) {
            currentDragboard = assistant;
        }
        return c;
    }

    public static int transferModesToClipboardActions(final Set&lt;TransferMode&gt; tms) {
        int actions = Clipboard.ACTION_NONE;
        for (TransferMode t : tms) {
            switch (t) {
                case COPY:
                    actions |= Clipboard.ACTION_COPY;
                    break;
                case MOVE:
                    actions |= Clipboard.ACTION_MOVE;
                    break;
                case LINK:
                    actions |= Clipboard.ACTION_REFERENCE;
                    break;
                default:
                    throw new IllegalArgumentException(
                            &quot;unsupported TransferMode &quot; + tms);
            }
        }
        return actions;
    }

    public void setSupportedTransferMode(Set&lt;TransferMode&gt; tm) {
        if (isCaching) {
            transferModesCache = tm;
        }
        final int actions = transferModesToClipboardActions(tm);
        systemAssistant.setSupportedActions(actions);
    }

    public static Set&lt;TransferMode&gt; clipboardActionsToTransferModes(final int actions) {
        final Set&lt;TransferMode&gt; tms = EnumSet.noneOf(TransferMode.class);

        if ((actions &amp; Clipboard.ACTION_COPY) != 0) {
            tms.add(TransferMode.COPY);
        }
        if ((actions &amp; Clipboard.ACTION_MOVE) != 0) {
            tms.add(TransferMode.MOVE);
        }
        if ((actions &amp; Clipboard.ACTION_REFERENCE) != 0) {
            tms.add(TransferMode.LINK);
        }

        return tms;
    }

    @Override public Set&lt;TransferMode&gt; getTransferModes() {
        if (transferModesCache != null) {
            return EnumSet.copyOf(transferModesCache);
        }

        ClipboardAssistance assistant = (currentDragboard != null) ? currentDragboard : systemAssistant;
        final Set&lt;TransferMode&gt; tms = clipboardActionsToTransferModes(assistant.getSupportedSourceActions());

        return tms;
    }

    @Override public void setDragView(Image image) {
        dragImage = image;
    }

    @Override public void setDragViewOffsetX(double offsetX) {
        dragOffsetX = offsetX;
    }

    @Override public void setDragViewOffsetY(double offsetY) {
        dragOffsetY = offsetY;
    }

    @Override public Image getDragView() {
        return dragImage;
    }

    @Override public double getDragViewOffsetX() {
        return dragOffsetX;
    }

    @Override public double getDragViewOffsetY() {
        return dragOffsetY;
    }

    public void close() {
        systemAssistant.close();
    }

    public void flush() {
        if (isCaching) {
            putContentToPeer(dataCache.toArray(new Pair[0]));
        }

        clearCache();
        clearDragView();
        systemAssistant.flush();
    }

    @Override public Object getContent(DataFormat dataFormat) {
        if (dataCache != null) {
            for (Pair&lt;DataFormat, Object&gt; pair : dataCache) {
                if (pair.getKey() == dataFormat) {
                    return pair.getValue();
                }
            }
            return null;
        }

        ClipboardAssistance assistant =
                (currentDragboard != null) ? currentDragboard : systemAssistant;

        if (dataFormat == DataFormat.IMAGE) {
            return readImage();
        } else if (dataFormat == DataFormat.URL) {
            return assistant.getData(Clipboard.URI_TYPE);
        } else if (dataFormat == DataFormat.FILES) {
            Object data = assistant.getData(Clipboard.FILE_LIST_TYPE);
            if (data == null) return Collections.emptyList();
            String[] paths = (String[]) data;
            List&lt;File&gt; list = new ArrayList&lt;File&gt;(paths.length);
            for (int i=0; i&lt;paths.length; i++) {
                list.add(new File(paths[i]));
            }
            return list;
        }

        for (String mimeType : dataFormat.getIdentifiers()) {
            Object data = assistant.getData(mimeType);
            if (data instanceof ByteBuffer) {
                try {
                    ByteBuffer bb = (ByteBuffer) data;
                    ByteArrayInputStream bis = new ByteArrayInputStream(
                            bb.array());
                    ObjectInput in = new ObjectInputStream(bis) {
                        @Override protected Class&lt;?&gt; resolveClass(
                                ObjectStreamClass desc)
                                throws IOException, ClassNotFoundException {
                            return Class.forName(desc.getName(), false,
                                    Thread.currentThread().getContextClassLoader());
                        }
                    };
                    data = in.readObject();
                } catch (IOException e) {
                    // ignore, just return the ByteBuffer if we cannot parse it
                } catch (ClassNotFoundException e) {
                    // ignore, just return the ByteBuffer if we cannot parse it
                }
            }
            if (data != null) return data;
        }
        return null;
    }

    private static Image convertObjectToImage(Object obj) {
        if (obj instanceof Image) {
            return (Image) obj;
        } else {
            final Pixels pixels;
            if (obj instanceof ByteBuffer) {
                ByteBuffer bb = (ByteBuffer)obj;
                try {
                    bb.rewind();
                    int width = bb.getInt();
                    int height = bb.getInt();
                    pixels = Application.GetApplication().createPixels(
                        width, height, bb.slice());
                } catch (Exception e) {
                    //ignore incorrect sized arrays
                    //not a client problem
                    return null;
                }
            } else if (obj instanceof Pixels) {
                pixels = (Pixels)obj;
            } else {
                return null;
            }
            com.sun.prism.Image platformImage = PixelUtils.pixelsToImage(
                pixels);
            ImageLoader il =  Toolkit.getToolkit().loadPlatformImage(
                platformImage);
            return Toolkit.getImageAccessor().fromPlatformImage(il);
        }
    }

    private Image readImage() {
        ClipboardAssistance assistant =
                (currentDragboard != null) ? currentDragboard : systemAssistant;

        Object rawData = assistant.getData(Clipboard.RAW_IMAGE_TYPE);
        if (rawData == null) {
            Object htmlData = assistant.getData(Clipboard.HTML_TYPE);
            if (htmlData != null) {
                String url = parseIMG(htmlData);
                if (url != null) {
                    try {
                        SecurityManager sm = System.getSecurityManager();
                        if (sm != null) {
                            AccessControlContext context = getAccessControlContext();
                            URL u = new URL(url);
                            String protocol = u.getProtocol();
                            if (protocol.equalsIgnoreCase(&quot;jar&quot;)) {
                                String file = u.getFile();
                                u = new URL(file);
                                protocol = u.getProtocol();
                            }
                            if (protocol.equalsIgnoreCase(&quot;file&quot;)) {
                                FilePermission fp = new FilePermission(u.getFile(), &quot;read&quot;);
                                sm.checkPermission(fp, context);
                            } else if (protocol.equalsIgnoreCase(&quot;ftp&quot;) ||
                                       protocol.equalsIgnoreCase(&quot;http&quot;) ||
                                       protocol.equalsIgnoreCase(&quot;https&quot;)) {
                                int port = u.getPort();
                                String hoststr = (port == -1 ? u.getHost() : u.getHost() + &quot;:&quot; + port);
                                SocketPermission sp = new SocketPermission(hoststr, &quot;connect&quot;);
                                sm.checkPermission(sp, context);
                            } else {
                                PermissionHelper.checkClipboardPermission(context);
                            }
                        }
                        return (new Image(url));
                    } catch (MalformedURLException mue) {
                        return null;
                    } catch (SecurityException se) {
                        return null;
                    }
                }
            }
            return null;
        }
        return convertObjectToImage(rawData);
    }

    private static final Pattern findTagIMG =
            Pattern.compile(&quot;IMG\\s+SRC=\\\&quot;([^\\\&quot;]+)\\\&quot;&quot;,
                            Pattern.DOTALL | Pattern.CASE_INSENSITIVE);

    private String parseIMG(Object data) {
        if (data == null) {
            return null;
        }
        if ((data instanceof String) == false) {
            return null;
        }
        String str = (String)data;
        Matcher matcher = findTagIMG.matcher(str);
        if (matcher.find()) {
             return (matcher.group(1));
        } else {
            return null;
        }
    }

    private boolean placeImage(final Image image) {
        if (image == null) {
            return false;
        }

        String url = image.getUrl();
        if (url == null || PixelUtils.supportedFormatType(url)) {
            com.sun.prism.Image prismImage =
                    (com.sun.prism.Image) Toolkit.getImageAccessor().getPlatformImage(image);
            Pixels pixels = PixelUtils.imageToPixels(prismImage);
            if (pixels != null) {
                systemAssistant.setData(Clipboard.RAW_IMAGE_TYPE, pixels);
                return true;
            } else {
                return false;
            }
        } else {
            systemAssistant.setData(Clipboard.URI_TYPE, url);
            return true;
        }
    }

    @Override public Set&lt;DataFormat&gt; getContentTypes() {
        Set&lt;DataFormat&gt; set = new HashSet&lt;DataFormat&gt;();

        if (dataCache != null) {
            for (Pair&lt;DataFormat, Object&gt; pair : dataCache) {
                set.add(pair.getKey());
            }
            return set;
        }

        ClipboardAssistance assistant =
                (currentDragboard != null) ? currentDragboard : systemAssistant;

        String[] types = assistant.getMimeTypes();
        if (types == null) {
            return set;
        }
        for (String t: types) {
            if (t.equalsIgnoreCase(Clipboard.RAW_IMAGE_TYPE)) {
                set.add(DataFormat.IMAGE);
            } else if (t.equalsIgnoreCase(Clipboard.URI_TYPE)) {
                set.add(DataFormat.URL);
            } else if (t.equalsIgnoreCase(Clipboard.FILE_LIST_TYPE)) {
                set.add(DataFormat.FILES);
            } else if (t.equalsIgnoreCase(Clipboard.HTML_TYPE)) {
                set.add(DataFormat.HTML);
                // RT-16812 - IE puts images on the clipboard in a HTML IMG url
                try {
                    //HTML header could be improperly formatted and we can get an exception here
                    if (parseIMG(assistant.getData(Clipboard.HTML_TYPE)) != null) {
                        set.add(DataFormat.IMAGE);
                    }
                } catch (Exception ex) {
                    //do nothing - it was just an attempt
                }
            } else {
                DataFormat dataFormat = DataFormat.lookupMimeType(t);
                if (dataFormat == null) {
                    //The user is interested in any format.
                    dataFormat = new DataFormat(t);
                }
                set.add(dataFormat);
            }
        }
        return set;
    }

    @Override public boolean hasContent(DataFormat dataFormat) {
        if (dataCache != null) {
            for (Pair&lt;DataFormat, Object&gt; pair : dataCache) {
                if (pair.getKey() == dataFormat) {
                    return true;
                }
            }
            return false;
        }

        ClipboardAssistance assistant =
                (currentDragboard != null) ? currentDragboard : systemAssistant;

        String[] stypes = assistant.getMimeTypes();
        if (stypes == null) {
            return false;
        }
        for (String t: stypes) {
            if (dataFormat == DataFormat.IMAGE &amp;&amp;
                    t.equalsIgnoreCase(Clipboard.RAW_IMAGE_TYPE)) {
                return true;
            } else if (dataFormat == DataFormat.URL &amp;&amp;
                       t.equalsIgnoreCase(Clipboard.URI_TYPE)) {
                return true;
            } else if (dataFormat == DataFormat.IMAGE &amp;&amp;
                       t.equalsIgnoreCase(Clipboard.HTML_TYPE) &amp;&amp;
                       parseIMG(assistant.getData(Clipboard.HTML_TYPE)) != null) {
                return true;
            } else if (dataFormat == DataFormat.FILES &amp;&amp;
                    t.equalsIgnoreCase(Clipboard.FILE_LIST_TYPE)) {
                return true;
            }

            DataFormat found = DataFormat.lookupMimeType(t);
            if (found != null &amp;&amp; found.equals(dataFormat)) {
                return true;
            }
        }
        return false;
    }

    private static ByteBuffer prepareImage(Image image) {
        PixelReader pr = image.getPixelReader();

        int w = (int) image.getWidth();
        int h = (int) image.getHeight();

        byte[] pixels = new byte[w * h * 4];
        pr.getPixels(0, 0, w, h, WritablePixelFormat.getByteBgraInstance(), pixels, 0, w*4);

        ByteBuffer dragImageBuffer = ByteBuffer.allocate(8 + w * h * 4);
        dragImageBuffer.putInt(w);
        dragImageBuffer.putInt(h);
        dragImageBuffer.put(pixels);

        return dragImageBuffer;
    }

    private static ByteBuffer prepareOffset(double offsetX, double offsetY) {
        ByteBuffer dragImageOffset = ByteBuffer.allocate(8);

        dragImageOffset.rewind();
        dragImageOffset.putInt((int) offsetX);
        dragImageOffset.putInt((int) offsetY);

        return dragImageOffset;
    }

    private boolean putContentToPeer(Pair&lt;DataFormat, Object&gt;... content) {
        systemAssistant.emptyCache();

        boolean dataSet = false;

        // For each pair, we need to extract the DataFormat and data associated with
        // that pair. We then will send the data down to Glass, having done
        // some work for well known types (such as Image and File) in order to
        // adapt from FX to Glass requirements. For everything else, we just
        // pass down the mime type and data, for each mime type supported by
        // the DataFormat type.
        for (Pair&lt;DataFormat, Object&gt; pair : content) {
            final DataFormat dataFormat = pair.getKey();
            Object data = pair.getValue();

            // Images are handled specially. On Windows, the image type supported
            // on the clipboard is a DIB (device independent bitmap), while on Mac
            // it is a TIFF. Other native apps expect this entry on the clipboard
            // for image copy/paste. However other Java apps or FX apps (for example)
            // might expect the JPG bits directly, rather than the DIB / TIFF bits.
            // So what we do is, any IMAGE type DataFormat that comes in will be stored
            // in DIB / TIFF, while specific bits will also be stored (in the future).
            if (dataFormat == DataFormat.IMAGE) {
                dataSet = placeImage(convertObjectToImage(data));
            } else if (dataFormat == DataFormat.URL) {
                // TODO Weird, but this is how Glass wants it...
                systemAssistant.setData(Clipboard.URI_TYPE, data);
                dataSet = true;
            } else if (dataFormat == DataFormat.RTF) {
                systemAssistant.setData(Clipboard.RTF_TYPE, data);
                dataSet = true;
            } else if (dataFormat == DataFormat.FILES) {
                // Have to convert from List&lt;File&gt; to String[]
                List&lt;File&gt; list = (List&lt;File&gt;)data;
                if (list.size() != 0) {
                    String[] paths = new String[list.size()];
                    int i = 0;
                    for (File f : list) {
                        paths[i++] = f.getAbsolutePath();
                    }
                    systemAssistant.setData(Clipboard.FILE_LIST_TYPE, paths);
                    dataSet = true;
                }
            } else {
<A NAME="47"></A>                if (data instanceof Serializable) {
                    if ((dataFormat != DataFormat.PLAIN_TEXT &amp;&amp; dataFormat != DataFormat.HTML) ||
                        !(data instanceof String))
                    <FONT color="#d16587"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#47',2,'match44-top.html#47',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                        try {
                            ByteArrayOutputStream bos = new ByteArrayOutputStream();
                            ObjectOutput out = new ObjectOutputStream(bos);
                            out.writeObject(data);
                            out.close</B></FONT>();
                            data = ByteBuffer.wrap(bos.toByteArray());
                        } catch (IOException e) {
                            throw new IllegalArgumentException(&quot;Could not serialize the data&quot;, e);
                        }
                    }
                } else if (data instanceof InputStream) {
                    ByteArrayOutputStream bout = new ByteArrayOutputStream();
                    try (InputStream is = (InputStream)data) {
                        // TODO: performance
                        int i = is.read();
                        while (i != -1) {
                            bout.write(i);
                            i = is.read();
                        }
                    } catch (IOException e) {
                        throw new IllegalArgumentException(&quot;Could not serialize the data&quot;, e);
                    }
                    data = ByteBuffer.wrap(bout.toByteArray());
                } else if (!(data instanceof ByteBuffer)) {
                    throw new IllegalArgumentException(&quot;Only serializable &quot;
                            + &quot;objects or ByteBuffer can be used as data &quot;
                            + &quot;with data format &quot; + dataFormat);
                }
                for (String mimeType : dataFormat.getIdentifiers()) {
                    systemAssistant.setData(mimeType, data);
                    dataSet = true;
                }
            }
        }

        // add drag image and offsets to the peer
        if (dragImage != null) {
            ByteBuffer imageBuffer = prepareImage(dragImage);
            ByteBuffer offsetBuffer = prepareOffset(dragOffsetX, dragOffsetY);
            systemAssistant.setData(Clipboard.DRAG_IMAGE, imageBuffer);
            systemAssistant.setData(Clipboard.DRAG_IMAGE_OFFSET, offsetBuffer);
        }

        return dataSet;
    }


    @Override public boolean putContent(Pair&lt;DataFormat, Object&gt;... content) {

        for (Pair&lt;DataFormat, Object&gt; pair : content) {
            final DataFormat format = pair.getKey();
            final Object     data   = pair.getValue();

            if (format == null) {
                throw new NullPointerException(&quot;Clipboard.putContent: null data format&quot;);
            }
            if (data == null) {
                throw new NullPointerException(&quot;Clipboard.putContent: null data&quot;);
            }
        }

        boolean dataSet = false;

        if (isCaching) {
            if (dataCache == null) {
                dataCache = new ArrayList&lt;Pair&lt;DataFormat, Object&gt;&gt;(content.length);
            }
            for (Pair&lt;DataFormat, Object&gt; pair : content) {
                dataCache.add(pair);
                dataSet = true;
            }
        } else {
            dataSet = putContentToPeer(content);
            systemAssistant.flush();
        }

        return dataSet;
    }

    private void clearCache() {
        dataCache = null;
        transferModesCache = null;
    }

    private void clearDragView() {
        dragImage = null;
        dragOffsetX = dragOffsetY = 0;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/ViewPainter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.ReentrantLock;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGPerspectiveCamera;
import com.sun.javafx.sg.prism.NodePath;
import com.sun.prism.Graphics;
import com.sun.prism.GraphicsResource;
import com.sun.prism.Image;
import com.sun.prism.Presentable;
import com.sun.prism.RTTexture;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Paint;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;

/**
 * Responsible for &quot;painting&quot; a scene. It invokes as appropriate API on the root NGNode
 * of a scene to determine dirty regions, render roots, etc. Also calls the render root
 * to render. Also invokes code to print dirty opts and paint overdraw rectangles according
 * to debug flags.
 */
abstract class ViewPainter implements Runnable {
    /**
     * An array of initially empty ROOT_PATHS. They are created on demand as
     * needed. Each path is associated with a different dirty region. We have
     * up to PrismSettings.dirtyRegionCount max dirty regions
     */
    private static NodePath[] ROOT_PATHS = new NodePath[PrismSettings.dirtyRegionCount];

    /*
     * This could be a per-scene lock but there is no guarantee that the
     * FX handlers called in GlassViewEventHandler would not modify other scenes.
     */
    protected static final ReentrantLock renderLock = new ReentrantLock();

    // Pen dimensions. Pen width and height are checked on every repaint
    // to match its scene width/height. If any difference is found, the
    // pen surface (Presentable or RTTexture) is recreated.
    protected int penWidth = -1;
    protected int penHeight = -1;
    protected int viewWidth;
    protected int viewHeight;

    protected final SceneState sceneState;

    protected Presentable presentable;
    protected ResourceFactory factory;
    protected boolean freshBackBuffer;

    private int width;
    private int height;

    /**
     * root is the root node of the scene. overlayRoot is the root node of any
     * overlay which may be present (such as used for full screen overlay).
     */
    private NGNode root, overlayRoot;

    // These variables are all used as part of the dirty region optimizations,
    // and if dirty opts are turned off via a runtime flag, then these fields
    // are never initialized or used.
    private Rectangle dirtyRect;
    private RectBounds clip;
    private RectBounds dirtyRegionTemp;
    private DirtyRegionPool dirtyRegionPool;
    private DirtyRegionContainer dirtyRegionContainer;
    private Affine3D tx;
    private Affine3D scaleTx;
    private GeneralTransform3D viewProjTx;
    private GeneralTransform3D projTx;

    /**
     * This is used for drawing dirty regions and overdraw rectangles in cases where we are
     * not drawing the entire scene every time (specifically, when depth buffer is disabled).
     * In those cases we will draw the scene to the sceneBuffer, clear the actual back buffer,
     * blit the sceneBuffer into the back buffer, and then scribble on top of the back buffer
     * with the dirty regions and/or overdraw rectangles.
     *
     * When the depthBuffer is enabled on a scene, we always end up drawing the entire scene
     * anyway, so we don't bother with this sceneBuffer in that case. Of course, if dirty
     * region / overdraw rectangle drawing is turned off, then we don't use this. Thus,
     * only when you are doing some kind of debugging would this field be used and the
     * extra buffer copy incurred.
     */
    private RTTexture sceneBuffer;

    protected ViewPainter(GlassScene gs) {
        sceneState = gs.getSceneState();
        if (sceneState == null) {
            throw new NullPointerException(&quot;Scene state is null&quot;);
        }

        if (PrismSettings.dirtyOptsEnabled) {
            tx = new Affine3D();
            viewProjTx = new GeneralTransform3D();
            projTx = new GeneralTransform3D();
            scaleTx = new Affine3D();
            clip = new RectBounds();
            dirtyRect = new Rectangle();
            dirtyRegionTemp = new RectBounds();
            dirtyRegionPool = new DirtyRegionPool(PrismSettings.dirtyRegionCount);
            dirtyRegionContainer = dirtyRegionPool.checkOut();
        }
    }

    protected final void setRoot(NGNode node) {
        root = node;
    }

    protected final void setOverlayRoot(NGNode node) {
        overlayRoot = node;
    }

    private void adjustPerspective(NGCamera camera) {
        // This should definitely be true since this is only called by setDirtyRect
        assert PrismSettings.dirtyOptsEnabled;
        if (camera instanceof NGPerspectiveCamera) {
            scaleTx.setToScale(width / 2.0, -height / 2.0, 1);
            scaleTx.translate(1, -1);
            projTx.mul(scaleTx);
            viewProjTx = camera.getProjViewTx(viewProjTx);
            projTx.mul(viewProjTx);
        }
    }

    protected void paintImpl(final Graphics backBufferGraphics) {
        // We should not be painting anything with a width / height
        // that is &lt;= 0, so we might as well bail right off.
        if (width &lt;= 0 || height &lt;= 0 || backBufferGraphics == null) {
            root.renderForcedContent(backBufferGraphics);
            return;
        }

        // This &quot;g&quot; variable might represent the back buffer graphics, or it
        // might be reassigned to the sceneBuffer graphics.
        Graphics g = backBufferGraphics;
        // Take into account the pixel scale factor for retina displays
        final float pixelScaleX = getPixelScaleFactorX();
        final float pixelScaleY = getPixelScaleFactorY();
        // Cache pixelScale in Graphics for use in 3D shaders such as camera and light positions.
        g.setPixelScaleFactors(pixelScaleX, pixelScaleY);

        // Initialize renderEverything based on various conditions that will cause us to render
        // the entire scene every time.
        boolean renderEverything = overlayRoot != null ||
                freshBackBuffer ||
                sceneState.getScene().isEntireSceneDirty() ||
                sceneState.getScene().getDepthBuffer() ||
                !PrismSettings.dirtyOptsEnabled;
        // We are going to draw dirty opt boxes either if we're supposed to show the dirty
        // regions, or if we're supposed to show the overdraw boxes.
        final boolean showDirtyOpts = PrismSettings.showDirtyRegions || PrismSettings.showOverdraw;
        // If showDirtyOpts is turned on and we're not using a depth buffer
        // then we will render the scene to an intermediate texture, and then at the end we'll
        // draw that intermediate texture to the back buffer.
        if (showDirtyOpts &amp;&amp; !sceneState.getScene().getDepthBuffer()) {
            final int bufferWidth = (int) Math.ceil(width * pixelScaleX);
            final int bufferHeight = (int) Math.ceil(height * pixelScaleY);
            // Check whether the sceneBuffer texture needs to be reconstructed
            if (sceneBuffer != null) {
                sceneBuffer.lock();
                if (sceneBuffer.isSurfaceLost() ||
                        bufferWidth != sceneBuffer.getContentWidth() ||
                        bufferHeight != sceneBuffer.getContentHeight()) {
                    sceneBuffer.unlock();
                    sceneBuffer.dispose();
                    sceneBuffer = null;
                }
            }
            // If sceneBuffer is null, we need to create a new texture. In this
            // case we will also need to render the whole scene (so don't bother
            // with dirty opts)
            if (sceneBuffer == null) {
                sceneBuffer = g.getResourceFactory().createRTTexture(
                        bufferWidth,
                        bufferHeight,
                        Texture.WrapMode.CLAMP_TO_ZERO,
                        false);
                renderEverything = true;
            }
            sceneBuffer.contentsUseful();
            // Hijack the &quot;g&quot; graphics variable
            g = sceneBuffer.createGraphics();
            g.setPixelScaleFactors(pixelScaleX, pixelScaleY);
            g.scale(pixelScaleX, pixelScaleY);
        } else if (sceneBuffer != null) {
            // We're in a situation where we have previously rendered to the sceneBuffer, but in
            // this render pass for whatever reason we're going to draw directly to the back buffer.
            // In this case we need to release the sceneBuffer.
            sceneBuffer.dispose();
            sceneBuffer = null;
        }

        // The status will be set only if we're rendering with dirty regions
        int status = -1;

        // If we're rendering with dirty regions, then we'll call the root node to accumulate
        // the dirty regions and then again to do the pre culling.
        if (!renderEverything) {
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Dirty Opts Computed&quot;);
            }
            clip.setBounds(0, 0, width, height);
            dirtyRegionTemp.makeEmpty();
            dirtyRegionContainer.reset();
            tx.setToIdentity();
            projTx.setIdentity();
            adjustPerspective(sceneState.getCamera());
            status = root.accumulateDirtyRegions(clip, dirtyRegionTemp,
                                                     dirtyRegionPool, dirtyRegionContainer,
                                                     tx, projTx);
            dirtyRegionContainer.roundOut();
            if (status == DirtyRegionContainer.DTR_OK) {
                root.doPreCulling(dirtyRegionContainer, tx, projTx);
            }
        }

        // We're going to need to iterate over the dirty region container a lot, so we
        // might as well save this reference.
        final int dirtyRegionSize = status == DirtyRegionContainer.DTR_OK ? dirtyRegionContainer.size() : 0;

        if (dirtyRegionSize &gt; 0) {
            // We set this flag on Graphics so that subsequent code in the render paths of
            // NGNode know whether they ought to be paying attention to dirty region
            // culling bits.
            g.setHasPreCullingBits(true);

            // Find the render roots. There is a different render root for each dirty region
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Render Roots Discovered&quot;);
            }
            for (int i = 0; i &lt; dirtyRegionSize; ++i) {
                NodePath path = getRootPath(i);
                path.clear();
                root.getRenderRoot(getRootPath(i), dirtyRegionContainer.getDirtyRegion(i), i, tx, projTx);
            }

            // For debug purposes, write out to the pulse logger the number and size of the dirty
            // regions that are being used to render this pulse.
            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.addMessage(dirtyRegionSize + &quot; different dirty regions to render&quot;);
                for (int i=0; i&lt;dirtyRegionSize; i++) {
                    PulseLogger.addMessage(&quot;Dirty Region &quot; + i + &quot;: &quot; + dirtyRegionContainer.getDirtyRegion(i));
                    PulseLogger.addMessage(&quot;Render Root Path &quot; + i + &quot;: &quot; + getRootPath(i));
                }
            }

            // If -Dprism.printrendergraph=true then we want to print out the render graph to the
            // pulse logger, annotated with all the dirty opts. Invisible nodes are skipped.
            if (PULSE_LOGGING_ENABLED &amp;&amp; PrismSettings.printRenderGraph) {
                StringBuilder s = new StringBuilder();
                List&lt;NGNode&gt; roots = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; dirtyRegionSize; i++) {
                    final RectBounds dirtyRegion = dirtyRegionContainer.getDirtyRegion(i);
                    // TODO it should be impossible to have ever created a dirty region that was empty...
                    if (dirtyRegion.getWidth() &gt; 0 &amp;&amp; dirtyRegion.getHeight() &gt; 0) {
                        NodePath nodePath = getRootPath(i);
                        if (!nodePath.isEmpty()) {
                            roots.add(nodePath.last());
                        }
                    }
                }
                root.printDirtyOpts(s, roots);
                PulseLogger.addMessage(s.toString());
            }

            // Paint each dirty region
            for (int i = 0; i &lt; dirtyRegionSize; ++i) {
                final RectBounds dirtyRegion = dirtyRegionContainer.getDirtyRegion(i);
                // TODO it should be impossible to have ever created a dirty region that was empty...
                // Make sure we are not trying to render in some invalid region
                if (dirtyRegion.getWidth() &gt; 0 &amp;&amp; dirtyRegion.getHeight() &gt; 0) {
                    // Set the clip rectangle using integer bounds since a fractional bounding box will
                    // still require a complete repaint on pixel boundaries
                    int x0, y0;
                    dirtyRect.x = x0 = (int) Math.floor(dirtyRegion.getMinX() * pixelScaleX);
                    dirtyRect.y = y0 = (int) Math.floor(dirtyRegion.getMinY() * pixelScaleY);
                    dirtyRect.width  = (int) Math.ceil (dirtyRegion.getMaxX() * pixelScaleX) - x0;
                    dirtyRect.height = (int) Math.ceil (dirtyRegion.getMaxY() * pixelScaleY) - y0;
                    g.setClipRect(dirtyRect);
                    g.setClipRectIndex(i);
                    doPaint(g, getRootPath(i));
                }
            }
        } else {
            // There are no dirty regions, so just paint everything
            g.setHasPreCullingBits(false);
            g.setClipRect(null);
            this.doPaint(g, null);
        }
        root.renderForcedContent(g);

        // If we have an overlay then we need to render it too.
        if (overlayRoot != null) {
            overlayRoot.render(g);
        }

        // If we're showing dirty regions or overdraw, then we're going to need to draw
        // over-top the normal scene. If we have been drawing do the back buffer, then we
        // will just draw on top of it. If we have been drawing to the sceneBuffer, then
        // we will first blit the sceneBuffer into the back buffer, and then draw directly
        // on the back buffer.
        if (showDirtyOpts) {
            if (sceneBuffer != null) {
                g.sync();
                backBufferGraphics.clear();
                backBufferGraphics.drawTexture(sceneBuffer, 0, 0, width, height,
                        sceneBuffer.getContentX(), sceneBuffer.getContentY(),
                        sceneBuffer.getContentX() + sceneBuffer.getContentWidth(),
                        sceneBuffer.getContentY() + sceneBuffer.getContentHeight());
                sceneBuffer.unlock();
            }

            if (PrismSettings.showOverdraw) {
                // We are going to show the overdraw rectangles.
                if (dirtyRegionSize &gt; 0) {
<A NAME="31"></A>                    // In this case we have dirty regions, so we will iterate over them all
                    // and draw each dirty region's overdraw individually
                    for (int i = 0; i &lt; dirtyRegionSize; i++) {
                        final Rectangle clip = <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#31',2,'match44-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Rectangle(dirtyRegionContainer.getDirtyRegion(i));
                        backBufferGraphics.setClipRectIndex(i);
                        paintOverdraw(backBufferGraphics, clip);
                        backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                        backBufferGraphics.drawRect(clip.x, clip.y, clip.width, clip.height);
                    }
                }</B></FONT> else {
                    // In this case there were no dirty regions, so the clip is the entire scene
                    final Rectangle clip = new Rectangle(0, 0, width, height);
                    assert backBufferGraphics.getClipRectIndex() == 0;
                    paintOverdraw(backBufferGraphics, clip);
                    backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                    backBufferGraphics.drawRect(clip.x, clip.y, clip.width, clip.height);
                }
            } else {
                // We are going to show the dirty regions
                if (dirtyRegionSize &gt; 0) {
                    // We have dirty regions to draw
                    backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                    for (int i = 0; i &lt; dirtyRegionSize; i++) {
                        final RectBounds reg = dirtyRegionContainer.getDirtyRegion(i);
                        backBufferGraphics.fillRect(reg.getMinX(), reg.getMinY(), reg.getWidth(), reg.getHeight());
                    }
                } else {
                    // No dirty regions, fill the entire view area
                    backBufferGraphics.setPaint(new Color(1, 0, 0, .3f));
                    backBufferGraphics.fillRect(0, 0, width, height);
                }
            }
            root.clearPainted();
        }
    }

    /**
     * Utility method for painting the overdraw rectangles. Right now we're using a computationally
     * intensive approach of having an array of integers (image data) that we then write to in the
     * NGNodes, recording how many times each pixel position has been touched (well, technically, we're
     * just recording the bounds of drawn objects, so some pixels might be &quot;red&quot; but actually were never
     * drawn).
     *
     * @param g
     * @param clip
     */
    private void paintOverdraw(final Graphics g, final Rectangle clip) {
        final int[] pixels = new int[clip.width * clip.height];
        root.drawDirtyOpts(BaseTransform.IDENTITY_TRANSFORM, projTx, clip, pixels, g.getClipRectIndex());
        final Image image = Image.fromIntArgbPreData(pixels, clip.width, clip.height);
        final Texture texture = factory.getCachedTexture(image, Texture.WrapMode.CLAMP_TO_EDGE);
        g.drawTexture(texture, clip.x, clip.y, clip.x+clip.width, clip.y+clip.height, 0, 0, clip.width, clip.height);
        texture.unlock();
    }

    private static NodePath getRootPath(int i) {
        if (ROOT_PATHS[i] == null) {
            ROOT_PATHS[i] = new NodePath();
        }
        return ROOT_PATHS[i];
    }

    protected void disposePresentable() {
        if (presentable instanceof GraphicsResource) {
            ((GraphicsResource)presentable).dispose();
        }
        presentable = null;
    }

    protected boolean validateStageGraphics() {
        if (!sceneState.isValid()) {
            // indicates something happened between the scheduling of the
            // job and the running of this job.
            return false;
        }

        width = viewWidth = sceneState.getWidth();
        height = viewHeight = sceneState.getHeight();

        return sceneState.isWindowVisible() &amp;&amp; !sceneState.isWindowMinimized();
    }

    protected float getPixelScaleFactorX() {
        return presentable == null ? 1.0f : presentable.getPixelScaleFactorX();
    }

    protected float getPixelScaleFactorY() {
        return presentable == null ? 1.0f : presentable.getPixelScaleFactorY();
    }

    private void doPaint(Graphics g, NodePath renderRootPath) {
        // Null path indicates that occlusion culling is not used
        if (renderRootPath != null) {
            if (renderRootPath.isEmpty()) {
                // empty render path indicates that no rendering is needed.
                // There may be occluded dirty Nodes however, so we need to clear them
                root.clearDirtyTree();
                return;
            }
            // If the path is not empty, the first node must be the root node
            assert(renderRootPath.getCurrentNode() == root);
        }
        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.newPhase(&quot;Painting&quot;);
        }
        GlassScene scene = sceneState.getScene();
        scene.clearEntireSceneDirty();
        g.setLights(scene.getLights());
        g.setDepthBuffer(scene.getDepthBuffer());
        Color clearColor = sceneState.getClearColor();
        if (clearColor != null) {
            g.clear(clearColor);
        }
        Paint curPaint = sceneState.getCurrentPaint();
        if (curPaint != null) {
            if (curPaint.getType() != com.sun.prism.paint.Paint.Type.COLOR) {
                g.getRenderTarget().setOpaque(curPaint.isOpaque());
            }
            g.setPaint(curPaint);
            g.fillQuad(0, 0, width, height);
        }
        g.setCamera(sceneState.getCamera());
        g.setRenderRoot(renderRootPath);
        root.render(g);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/marlin/RendererStats.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.marlin;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentLinkedQueue;
import com.sun.marlin.ArrayCacheConst.CacheStats;
import static com.sun.marlin.MarlinUtils.logInfo;
import com.sun.marlin.stats.Histogram;
import com.sun.marlin.stats.Monitor;
import com.sun.marlin.stats.StatLong;

/**
 * This class gathers global rendering statistics for debugging purposes only
 */
public final class RendererStats implements MarlinConst {

    static RendererStats createInstance(final Object parent, final String name)
    {
        final RendererStats stats = new RendererStats(name);

        // Keep a strong reference to dump it later:
        RendererStatsHolder.getInstance().add(parent, stats);

        return stats;
    }

    public static void dumpStats() {
        RendererStatsHolder.dumpStats();
    }

    // context name (debugging purposes)
    final String name;
    // stats
    final StatLong stat_cache_rowAA
        = new StatLong(&quot;cache.rowAA&quot;);
    final StatLong stat_cache_rowAAChunk
        = new StatLong(&quot;cache.rowAAChunk&quot;);
    final StatLong stat_cache_tiles
        = new StatLong(&quot;cache.tiles&quot;);
    final StatLong stat_rdr_addLine
        = new StatLong(&quot;renderer.addLine&quot;);
    final StatLong stat_rdr_addLine_skip
        = new StatLong(&quot;renderer.addLine.skip&quot;);
    final StatLong stat_rdr_curveBreak
        = new StatLong(&quot;renderer.curveBreakIntoLinesAndAdd&quot;);
    final StatLong stat_rdr_curveBreak_dec
        = new StatLong(&quot;renderer.curveBreakIntoLinesAndAdd.dec&quot;);
    final StatLong stat_rdr_curveBreak_inc
        = new StatLong(&quot;renderer.curveBreakIntoLinesAndAdd.inc&quot;);
    final StatLong stat_rdr_quadBreak
        = new StatLong(&quot;renderer.quadBreakIntoLinesAndAdd&quot;);
    final StatLong stat_rdr_quadBreak_dec
        = new StatLong(&quot;renderer.quadBreakIntoLinesAndAdd.dec&quot;);
    final StatLong stat_rdr_edges
        = new StatLong(&quot;renderer.edges&quot;);
    final StatLong stat_rdr_edges_count
        = new StatLong(&quot;renderer.edges.count&quot;);
    final StatLong stat_rdr_edges_resizes
        = new StatLong(&quot;renderer.edges.resize&quot;);
    final StatLong stat_rdr_activeEdges
        = new StatLong(&quot;renderer.activeEdges&quot;);
    final StatLong stat_rdr_activeEdges_updates
        = new StatLong(&quot;renderer.activeEdges.updates&quot;);
    final StatLong stat_rdr_activeEdges_adds
        = new StatLong(&quot;renderer.activeEdges.adds&quot;);
    final StatLong stat_rdr_activeEdges_adds_high
        = new StatLong(&quot;renderer.activeEdges.adds_high&quot;);
    final StatLong stat_rdr_crossings_updates
        = new StatLong(&quot;renderer.crossings.updates&quot;);
    final StatLong stat_rdr_crossings_sorts
        = new StatLong(&quot;renderer.crossings.sorts&quot;);
    final StatLong stat_rdr_crossings_bsearch
        = new StatLong(&quot;renderer.crossings.bsearch&quot;);
    final StatLong stat_rdr_crossings_msorts
        = new StatLong(&quot;renderer.crossings.msorts&quot;);
    final StatLong stat_str_polystack_curves
        = new StatLong(&quot;stroker.polystack.curves&quot;);
    final StatLong stat_str_polystack_types
        = new StatLong(&quot;stroker.polystack.types&quot;);
    final StatLong stat_cpd_polystack_curves
        = new StatLong(&quot;closedPathDetector.polystack.curves&quot;);
    final StatLong stat_cpd_polystack_types
        = new StatLong(&quot;closedPathDetector.polystack.types&quot;);
    final StatLong stat_pcf_idxstack_indices
        = new StatLong(&quot;pathClipFilter.stack.indices&quot;);
    // growable arrays
    final StatLong stat_array_dasher_dasher
        = new StatLong(&quot;array.dasher.dasher.d_float&quot;);
    final StatLong stat_array_dasher_firstSegmentsBuffer
        = new StatLong(&quot;array.dasher.firstSegmentsBuffer.d_float&quot;);
    final StatLong stat_array_marlincache_rowAAChunk
        = new StatLong(&quot;array.marlincache.rowAAChunk.resize&quot;);
    final StatLong stat_array_marlincache_touchedTile
        = new StatLong(&quot;array.marlincache.touchedTile.int&quot;);
    final StatLong stat_array_renderer_alphaline
        = new StatLong(&quot;array.renderer.alphaline.int&quot;);
    final StatLong stat_array_renderer_crossings
        = new StatLong(&quot;array.renderer.crossings.int&quot;);
    final StatLong stat_array_renderer_aux_crossings
        = new StatLong(&quot;array.renderer.aux_crossings.int&quot;);
    final StatLong stat_array_renderer_edgeBuckets
        = new StatLong(&quot;array.renderer.edgeBuckets.int&quot;);
    final StatLong stat_array_renderer_edgeBucketCounts
        = new StatLong(&quot;array.renderer.edgeBucketCounts.int&quot;);
    final StatLong stat_array_renderer_edgePtrs
        = new StatLong(&quot;array.renderer.edgePtrs.int&quot;);
    final StatLong stat_array_renderer_aux_edgePtrs
        = new StatLong(&quot;array.renderer.aux_edgePtrs.int&quot;);
    final StatLong stat_array_str_polystack_curves
        = new StatLong(&quot;array.stroker.polystack.curves.d_float&quot;);
    final StatLong stat_array_str_polystack_types
        = new StatLong(&quot;array.stroker.polystack.curveTypes.d_byte&quot;);
    final StatLong stat_array_cpd_polystack_curves
        = new StatLong(&quot;array.closedPathDetector.polystack.curves.d_float&quot;);
    final StatLong stat_array_cpd_polystack_types
        = new StatLong(&quot;array.closedPathDetector.polystack.curveTypes.d_byte&quot;);
    final StatLong stat_array_pcf_idxstack_indices
        = new StatLong(&quot;array.pathClipFilter.stack.indices.d_int&quot;);
    // histograms
    final Histogram hist_rdr_edges_count
        = new Histogram(&quot;renderer.edges.count&quot;);
    final Histogram hist_rdr_crossings
        = new Histogram(&quot;renderer.crossings&quot;);
    final Histogram hist_rdr_crossings_ratio
        = new Histogram(&quot;renderer.crossings.ratio&quot;);
    final Histogram hist_rdr_crossings_adds
        = new Histogram(&quot;renderer.crossings.adds&quot;);
    final Histogram hist_rdr_crossings_msorts
        = new Histogram(&quot;renderer.crossings.msorts&quot;);
    final Histogram hist_rdr_crossings_msorts_adds
        = new Histogram(&quot;renderer.crossings.msorts.adds&quot;);
    final Histogram hist_str_polystack_curves
        = new Histogram(&quot;stroker.polystack.curves&quot;);
    final Histogram hist_tile_generator_alpha
        = new Histogram(&quot;tile_generator.alpha&quot;);
    final Histogram hist_tile_generator_encoding
        = new Histogram(&quot;tile_generator.encoding&quot;);
    final Histogram hist_tile_generator_encoding_dist
        = new Histogram(&quot;tile_generator.encoding.dist&quot;);
    final Histogram hist_tile_generator_encoding_ratio
        = new Histogram(&quot;tile_generator.encoding.ratio&quot;);
    final Histogram hist_tile_generator_encoding_runLen
        = new Histogram(&quot;tile_generator.encoding.runLen&quot;);
    final Histogram hist_cpd_polystack_curves
        = new Histogram(&quot;closedPathDetector.polystack.curves&quot;);
    final Histogram hist_pcf_idxstack_indices
        = new Histogram(&quot;pathClipFilter.stack.indices&quot;);
    // all stats
    final StatLong[] statistics = new StatLong[]{
        stat_cache_rowAA,
        stat_cache_rowAAChunk,
        stat_cache_tiles,
        stat_rdr_addLine,
        stat_rdr_addLine_skip,
        stat_rdr_curveBreak,
        stat_rdr_curveBreak_dec,
        stat_rdr_curveBreak_inc,
        stat_rdr_quadBreak,
        stat_rdr_quadBreak_dec,
        stat_rdr_edges,
        stat_rdr_edges_count,
        stat_rdr_edges_resizes,
        stat_rdr_activeEdges,
        stat_rdr_activeEdges_updates,
        stat_rdr_activeEdges_adds,
        stat_rdr_activeEdges_adds_high,
        stat_rdr_crossings_updates,
        stat_rdr_crossings_sorts,
        stat_rdr_crossings_bsearch,
        stat_rdr_crossings_msorts,
        stat_str_polystack_types,
        stat_str_polystack_curves,
        stat_cpd_polystack_curves,
        stat_cpd_polystack_types,
        stat_pcf_idxstack_indices,
        hist_rdr_edges_count,
        hist_rdr_crossings,
        hist_rdr_crossings_ratio,
        hist_rdr_crossings_adds,
        hist_rdr_crossings_msorts,
        hist_rdr_crossings_msorts_adds,
        hist_tile_generator_alpha,
        hist_tile_generator_encoding,
        hist_tile_generator_encoding_dist,
        hist_tile_generator_encoding_ratio,
        hist_tile_generator_encoding_runLen,
        hist_str_polystack_curves,
        hist_cpd_polystack_curves,
        hist_pcf_idxstack_indices,
        stat_array_dasher_dasher,
        stat_array_dasher_firstSegmentsBuffer,
        stat_array_marlincache_rowAAChunk,
        stat_array_marlincache_touchedTile,
        stat_array_renderer_alphaline,
        stat_array_renderer_crossings,
        stat_array_renderer_aux_crossings,
        stat_array_renderer_edgeBuckets,
        stat_array_renderer_edgeBucketCounts,
        stat_array_renderer_edgePtrs,
        stat_array_renderer_aux_edgePtrs,
        stat_array_str_polystack_curves,
        stat_array_str_polystack_types,
        stat_array_cpd_polystack_curves,
        stat_array_cpd_polystack_types,
        stat_array_pcf_idxstack_indices
    };
    // monitors
    final Monitor mon_pre_getAATileGenerator
        = new Monitor(&quot;MarlinRenderingEngine.getAATileGenerator()&quot;);
    final Monitor mon_rdr_addLine
        = new Monitor(&quot;Renderer.addLine()&quot;);
    final Monitor mon_rdr_endRendering
        = new Monitor(&quot;Renderer.endRendering()&quot;);
    final Monitor mon_rdr_endRendering_Y
        = new Monitor(&quot;Renderer._endRendering(Y)&quot;);
    final Monitor mon_rdr_copyAARow
        = new Monitor(&quot;Renderer.copyAARow()&quot;);
    final Monitor mon_pipe_renderTiles
        = new Monitor(&quot;AAShapePipe.renderTiles()&quot;);
    final Monitor mon_ptg_getAlpha
        = new Monitor(&quot;MarlinTileGenerator.getAlpha()&quot;);
    final Monitor mon_debug
        = new Monitor(&quot;DEBUG()&quot;);
    // all monitors
    final Monitor[] monitors = new Monitor[]{
        mon_pre_getAATileGenerator,
        mon_rdr_addLine,
        mon_rdr_endRendering,
        mon_rdr_endRendering_Y,
        mon_rdr_copyAARow,
        mon_pipe_renderTiles,
        mon_ptg_getAlpha,
        mon_debug
    };
    // offheap stats
    long totalOffHeapInitial = 0L;
     // live accumulator
    long totalOffHeap = 0L;
    long totalOffHeapMax = 0L;
    // cache stats
    CacheStats[] cacheStats = null;

    private RendererStats(final String name) {
        this.name = name;
    }

    void dump() {
        logInfo(&quot;RendererContext: &quot; + name);

        if (DO_MONITORS) {
            for (Monitor monitor : monitors) {
                if (monitor.count != 0) {
                    logInfo(monitor.toString());
                }
            }
            // As getAATileGenerator percents:
            final long total = mon_pre_getAATileGenerator.sum;
            if (total != 0L) {
                for (Monitor monitor : monitors) {
                    logInfo(monitor.name + &quot; : &quot;
                            + ((100d * monitor.sum) / total) + &quot; %&quot;);
                }
            }
            if (DO_FLUSH_MONITORS) {
                for (Monitor m : monitors) {
                    m.reset();
                }
            }
        }

        if (DO_STATS) {
            for (StatLong stat : statistics) {
                if (stat.count != 0) {
                    logInfo(stat.toString());
                    if (DO_FLUSH_STATS) {
                        stat.reset();
                    }
                }
            }

            logInfo(&quot;OffHeap footprint: initial: &quot; + totalOffHeapInitial
                + &quot; bytes - max: &quot; + totalOffHeapMax + &quot; bytes&quot;);
            if (DO_FLUSH_STATS) {
                totalOffHeapMax = 0L;
            }

            logInfo(&quot;Array caches for RendererContext: &quot; + name);

            long totalInitialBytes = totalOffHeapInitial;
            long totalCacheBytes   = 0L;

            if (cacheStats != null) {
                for (CacheStats stat : cacheStats) {
                    totalCacheBytes   += stat.dumpStats();
                    totalInitialBytes += stat.getTotalInitialBytes();
                    if (DO_FLUSH_STATS) {
                        stat.reset();
                    }
                }
            }
            logInfo(&quot;Heap footprint: initial: &quot; + totalInitialBytes
                    + &quot; bytes - cache: &quot; + totalCacheBytes + &quot; bytes&quot;);
        }
    }

    static final class RendererStatsHolder {

        // singleton
        private static volatile RendererStatsHolder SINGLETON = null;

        static synchronized RendererStatsHolder getInstance() {
            if (SINGLETON == null) {
                SINGLETON = new RendererStatsHolder();
            }
            return SINGLETON;
        }

        static void dumpStats() {
            if (SINGLETON != null) {
                SINGLETON.dump();
            }
        }

        /* RendererStats collection as hard references
           (only used for debugging purposes) */
        private final ConcurrentLinkedQueue&lt;RendererStats&gt; allStats
            = new ConcurrentLinkedQueue&lt;RendererStats&gt;();

<A NAME="4"></A>        private RendererStatsHolder() {
            AccessController.doPrivileged(
                (PrivilegedAction&lt;Void&gt;) () -&gt; {
                    final Thread hook = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#4',2,'match44-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Thread(
                        MarlinUtils.getRootThreadGroup(),
                        new Runnable() {
                            @Override
                            public void run() {
                                dump();
                            }
                        },
                        &quot;MarlinStatsHook&quot;
                    );
                    hook.setContextClassLoader</B></FONT>(null);
                    Runtime.getRuntime().addShutdownHook(hook);

                    if (USE_DUMP_THREAD) {
                        final Timer statTimer = new Timer(&quot;RendererStats&quot;);
                        statTimer.scheduleAtFixedRate(new TimerTask() {
                            @Override
                            public void run() {
                                dump();
                            }
                        }, DUMP_INTERVAL, DUMP_INTERVAL);
                    }
                    return null;
                }
            );
        }

        void add(final Object parent, final RendererStats stats) {
            allStats.add(stats);

            // Register a cleaning function to ensure removing dead entries:
            MarlinUtils.getCleaner().register(parent, () -&gt; remove(stats));
        }

        void remove(final RendererStats stats) {
            stats.dump(); // dump anyway
            allStats.remove(stats);
        }

        void dump() {
            for (RendererStats stats : allStats) {
                stats.dump();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/openpisces/Helpers.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.openpisces;

import java.util.Arrays;
import static java.lang.Math.PI;
import static java.lang.Math.cos;
import static java.lang.Math.sqrt;
import static java.lang.Math.cbrt;
import static java.lang.Math.acos;


final class Helpers {
    private Helpers() {
        throw new Error(&quot;This is a non instantiable class&quot;);
    }

    static boolean within(final float x, final float y, final float err) {
        final float d = y - x;
        return (d &lt;= err &amp;&amp; d &gt;= -err);
    }

    static boolean within(final double x, final double y, final double err) {
        final double d = y - x;
        return (d &lt;= err &amp;&amp; d &gt;= -err);
    }

    static int quadraticRoots(final float a, final float b,
                              final float c, float[] zeroes, final int off)
    {
        int ret = off;
        float t;
        if (a != 0f) {
            final float dis = b*b - 4*a*c;
            if (dis &gt; 0) {
                final float sqrtDis = (float)Math.sqrt(dis);
                // depending on the sign of b we use a slightly different
                // algorithm than the traditional one to find one of the roots
                // so we can avoid adding numbers of different signs (which
                // might result in loss of precision).
                if (b &gt;= 0) {
                    zeroes[ret++] = (2 * c) / (-b - sqrtDis);
                    zeroes[ret++] = (-b - sqrtDis) / (2 * a);
                } else {
                    zeroes[ret++] = (-b + sqrtDis) / (2 * a);
                    zeroes[ret++] = (2 * c) / (-b + sqrtDis);
                }
            } else if (dis == 0f) {
                t = (-b) / (2 * a);
                zeroes[ret++] = t;
            }
        } else {
            if (b != 0f) {
                t = (-c) / b;
                zeroes[ret++] = t;
            }
        }
        return ret - off;
    }

    // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
    static int cubicRootsInAB(float d, float a, float b, float c,
                              float[] pts, final int off,
                              final float A, final float B)
    {
        if (d == 0) {
            int num = quadraticRoots(a, b, c, pts, off);
            return filterOutNotInAB(pts, off, num, A, B) - off;
        }
        // From Graphics Gems:
        // http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
        // (also from awt.geom.CubicCurve2D. But here we don't need as
        // much accuracy and we don't want to create arrays so we use
        // our own customized version).

        /* normal form: x^3 + ax^2 + bx + c = 0 */
        a /= d;
        b /= d;
        c /= d;

        //  substitute x = y - A/3 to eliminate quadratic term:
        //     x^3 +Px + Q = 0
        //
        // Since we actually need P/3 and Q/2 for all of the
        // calculations that follow, we will calculate
        // p = P/3
        // q = Q/2
        // instead and use those values for simplicity of the code.
        double sq_A = a * a;
        double p = 1.0/3 * (-1.0/3 * sq_A + b);
        double q = 1.0/2 * (2.0/27 * a * sq_A - 1.0/3 * a * b + c);

        /* use Cardano's formula */

        double cb_p = p * p * p;
        double D = q * q + cb_p;

        int num;
        if (D &lt; 0) {
            // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
            final double phi = 1.0/3 * acos(-q / sqrt(-cb_p));
            final double t = 2 * sqrt(-p);

            pts[ off+0 ] =  (float)( t * cos(phi));
            pts[ off+1 ] =  (float)(-t * cos(phi + PI / 3));
            pts[ off+2 ] =  (float)(-t * cos(phi - PI / 3));
            num = 3;
        } else {
            final double sqrt_D = sqrt(D);
            final double u = cbrt(sqrt_D - q);
            final double v = - cbrt(sqrt_D + q);

            pts[ off ] = (float)(u + v);
            num = 1;

            if (within(D, 0, 1e-8)) {
                pts[off+1] = -(pts[off] / 2);
                num = 2;
            }
        }

        final float sub = 1.0f/3 * a;

        for (int i = 0; i &lt; num; ++i) {
            pts[ off+i ] -= sub;
        }

        return filterOutNotInAB(pts, off, num, A, B) - off;
    }

    // These use a hardcoded factor of 2 for increasing sizes. Perhaps this
    // should be provided as an argument.
    static float[] widenArray(float[] in, final int cursize, final int numToAdd) {
        if (in.length &gt;= cursize + numToAdd) {
            return in;
        }
        return Arrays.copyOf(in, 2 * (cursize + numToAdd));
    }

    static int[] widenArray(int[] in, final int cursize, final int numToAdd) {
        if (in.length &gt;= cursize + numToAdd) {
            return in;
        }
        return Arrays.copyOf(in, 2 * (cursize + numToAdd));
    }

    static float evalCubic(final float a, final float b,
                           final float c, final float d,
                           final float t)
    {
        return t * (t * (t * a + b) + c) + d;
    }

    static float evalQuad(final float a, final float b,
                          final float c, final float t)
    {
        return t * (t * a + b) + c;
    }

    // returns the index 1 past the last valid element remaining after filtering
    static int filterOutNotInAB(float[] nums, final int off, final int len,
                                final float a, final float b)
    {
        int ret = off;
        for (int i = off; i &lt; off + len; i++) {
            if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
                nums[ret++] = nums[i];
            }
        }
        return ret;
    }
<A NAME="5"></A>
    static float polyLineLength(float[] poly, final int off, final int nCoords) {
        assert nCoords % 2 == 0 &amp;&amp; poly.length &gt;= off + nCoords : &quot;&quot;;
        <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#5',2,'match44-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>float acc = 0;
        for (int i = off + 2; i &lt; off + nCoords; i += 2) {
            acc += linelen(poly[i], poly[i+1], poly[i-2], poly[i-1]);
        }
        return acc;
    }

    static float linelen(float x1, float y1, float x2</B></FONT>, float y2) {
        final float dx = x2 - x1;
        final float dy = y2 - y1;
        return (float)Math.sqrt(dx*dx + dy*dy);
    }

    static void subdivide(float[] src, int srcoff, float[] left, int leftoff,
                          float[] right, int rightoff, int type)
    {
        switch(type) {
        case 6:
            Helpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);
            break;
        case 8:
            Helpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);
            break;
        default:
            throw new InternalError(&quot;Unsupported curve type&quot;);
        }
    }

    static void isort(float[] a, int off, int len) {
        for (int i = off + 1; i &lt; off + len; i++) {
            float ai = a[i];
            int j = i - 1;
            for (; j &gt;= off &amp;&amp; a[j] &gt; ai; j--) {
                a[j+1] = a[j];
            }
            a[j+1] = ai;
        }
    }

    // Most of these are copied from classes in java.awt.geom because we need
    // float versions of these functions, and Line2D, CubicCurve2D,
    // QuadCurve2D don't provide them.
    /**
     * Subdivides the cubic curve specified by the coordinates
     * stored in the &lt;code&gt;src&lt;/code&gt; array at indices &lt;code&gt;srcoff&lt;/code&gt;
     * through (&lt;code&gt;srcoff&lt;/code&gt;&amp;nbsp;+&amp;nbsp;7) and stores the
     * resulting two subdivided curves into the two result arrays at the
     * corresponding indices.
     * Either or both of the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;
     * arrays may be &lt;code&gt;null&lt;/code&gt; or a reference to the same array
     * as the &lt;code&gt;src&lt;/code&gt; array.
     * Note that the last point in the first subdivided curve is the
     * same as the first point in the second subdivided curve. Thus,
     * it is possible to pass the same array for &lt;code&gt;left&lt;/code&gt;
     * and &lt;code&gt;right&lt;/code&gt; and to use offsets, such as &lt;code&gt;rightoff&lt;/code&gt;
     * equals (&lt;code&gt;leftoff&lt;/code&gt; + 6), in order
     * to avoid allocating extra storage for this common point.
     * @param src the array holding the coordinates for the source curve
     * @param srcoff the offset into the array of the beginning of the
     * the 6 source coordinates
     * @param left the array for storing the coordinates for the first
     * half of the subdivided curve
     * @param leftoff the offset into the array of the beginning of the
     * the 6 left coordinates
     * @param right the array for storing the coordinates for the second
     * half of the subdivided curve
     * @param rightoff the offset into the array of the beginning of the
     * the 6 right coordinates
     */
    static void subdivideCubic(float src[], int srcoff,
                               float left[], int leftoff,
                               float right[], int rightoff)
    {
        float x1 = src[srcoff + 0];
        float y1 = src[srcoff + 1];
        float ctrlx1 = src[srcoff + 2];
        float ctrly1 = src[srcoff + 3];
        float ctrlx2 = src[srcoff + 4];
        float ctrly2 = src[srcoff + 5];
        float x2 = src[srcoff + 6];
        float y2 = src[srcoff + 7];
        if (left != null) {
            left[leftoff + 0] = x1;
            left[leftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 6] = x2;
            right[rightoff + 7] = y2;
        }
        x1 = (x1 + ctrlx1) / 2.0f;
        y1 = (y1 + ctrly1) / 2.0f;
        x2 = (x2 + ctrlx2) / 2.0f;
        y2 = (y2 + ctrly2) / 2.0f;
        float centerx = (ctrlx1 + ctrlx2) / 2.0f;
        float centery = (ctrly1 + ctrly2) / 2.0f;
        ctrlx1 = (x1 + centerx) / 2.0f;
        ctrly1 = (y1 + centery) / 2.0f;
        ctrlx2 = (x2 + centerx) / 2.0f;
        ctrly2 = (y2 + centery) / 2.0f;
        centerx = (ctrlx1 + ctrlx2) / 2.0f;
        centery = (ctrly1 + ctrly2) / 2.0f;
        if (left != null) {
            left[leftoff + 2] = x1;
            left[leftoff + 3] = y1;
            left[leftoff + 4] = ctrlx1;
            left[leftoff + 5] = ctrly1;
            left[leftoff + 6] = centerx;
            left[leftoff + 7] = centery;
        }
        if (right != null) {
            right[rightoff + 0] = centerx;
            right[rightoff + 1] = centery;
            right[rightoff + 2] = ctrlx2;
            right[rightoff + 3] = ctrly2;
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
    }


    static void subdivideCubicAt(float t, float src[], int srcoff,
                                 float left[], int leftoff,
                                 float right[], int rightoff)
    {
        float x1 = src[srcoff + 0];
        float y1 = src[srcoff + 1];
        float ctrlx1 = src[srcoff + 2];
        float ctrly1 = src[srcoff + 3];
        float ctrlx2 = src[srcoff + 4];
        float ctrly2 = src[srcoff + 5];
        float x2 = src[srcoff + 6];
        float y2 = src[srcoff + 7];
        if (left != null) {
            left[leftoff + 0] = x1;
            left[leftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 6] = x2;
            right[rightoff + 7] = y2;
        }
        x1 = x1 + t * (ctrlx1 - x1);
        y1 = y1 + t * (ctrly1 - y1);
        x2 = ctrlx2 + t * (x2 - ctrlx2);
        y2 = ctrly2 + t * (y2 - ctrly2);
        float centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
        float centery = ctrly1 + t * (ctrly2 - ctrly1);
        ctrlx1 = x1 + t * (centerx - x1);
        ctrly1 = y1 + t * (centery - y1);
        ctrlx2 = centerx + t * (x2 - centerx);
        ctrly2 = centery + t * (y2 - centery);
        centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
        centery = ctrly1 + t * (ctrly2 - ctrly1);
        if (left != null) {
            left[leftoff + 2] = x1;
            left[leftoff + 3] = y1;
            left[leftoff + 4] = ctrlx1;
            left[leftoff + 5] = ctrly1;
            left[leftoff + 6] = centerx;
            left[leftoff + 7] = centery;
        }
        if (right != null) {
            right[rightoff + 0] = centerx;
            right[rightoff + 1] = centery;
            right[rightoff + 2] = ctrlx2;
            right[rightoff + 3] = ctrly2;
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
    }

    static void subdivideQuad(float src[], int srcoff,
                              float left[], int leftoff,
                              float right[], int rightoff)
    {
        float x1 = src[srcoff + 0];
        float y1 = src[srcoff + 1];
        float ctrlx = src[srcoff + 2];
        float ctrly = src[srcoff + 3];
        float x2 = src[srcoff + 4];
        float y2 = src[srcoff + 5];
        if (left != null) {
            left[leftoff + 0] = x1;
            left[leftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
        x1 = (x1 + ctrlx) / 2.0f;
        y1 = (y1 + ctrly) / 2.0f;
        x2 = (x2 + ctrlx) / 2.0f;
        y2 = (y2 + ctrly) / 2.0f;
        ctrlx = (x1 + x2) / 2.0f;
        ctrly = (y1 + y2) / 2.0f;
        if (left != null) {
            left[leftoff + 2] = x1;
            left[leftoff + 3] = y1;
            left[leftoff + 4] = ctrlx;
            left[leftoff + 5] = ctrly;
        }
        if (right != null) {
            right[rightoff + 0] = ctrlx;
            right[rightoff + 1] = ctrly;
            right[rightoff + 2] = x2;
            right[rightoff + 3] = y2;
        }
    }

    static void subdivideQuadAt(float t, float src[], int srcoff,
                                float left[], int leftoff,
                                float right[], int rightoff)
    {
        float x1 = src[srcoff + 0];
        float y1 = src[srcoff + 1];
        float ctrlx = src[srcoff + 2];
        float ctrly = src[srcoff + 3];
        float x2 = src[srcoff + 4];
        float y2 = src[srcoff + 5];
        if (left != null) {
            left[leftoff + 0] = x1;
            left[leftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
        x1 = x1 + t * (ctrlx - x1);
        y1 = y1 + t * (ctrly - y1);
        x2 = ctrlx + t * (x2 - ctrlx);
        y2 = ctrly + t * (y2 - ctrly);
        ctrlx = x1 + t * (x2 - x1);
        ctrly = y1 + t * (y2 - y1);
        if (left != null) {
            left[leftoff + 2] = x1;
            left[leftoff + 3] = y1;
            left[leftoff + 4] = ctrlx;
            left[leftoff + 5] = ctrly;
        }
        if (right != null) {
            right[rightoff + 0] = ctrlx;
            right[rightoff + 1] = ctrly;
            right[rightoff + 2] = x2;
            right[rightoff + 3] = y2;
        }
    }

    static void subdivideAt(float t, float src[], int srcoff,
                            float left[], int leftoff,
                            float right[], int rightoff, int size)
    {
        switch(size) {
        case 8:
            subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);
            break;
        case 6:
            subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);
            break;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/ps/PaintHelper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.ps;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.List;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.AffineBase;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGPerspectiveCamera;
import com.sun.prism.Image;
import com.sun.prism.PixelFormat;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.Texture.Usage;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.impl.BufferUtil;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.paint.Stop;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderGraphics;

class PaintHelper {

/****************** Shared MultipleGradientPaint support ********************/

    /**
     * The maximum number of gradient &quot;stops&quot; supported by our native
     * fragment shader implementations.
     *
     * This value has been empirically determined and capped to allow
     * our native shaders to run on all shader-level graphics hardware,
     * even on the older, more limited GPUs.  Even the oldest Nvidia
     * hardware could handle 16, or even 32 fractions without any problem.
     * But the first-generation boards from ATI would fall back into
     * software mode (which is unusably slow) for values larger than 12;
     * it appears that those boards do not have enough native registers
     * to support the number of array accesses required by our gradient
     * shaders.  So for now we will cap this value at 12, but we can
     * re-evaluate this in the future as hardware becomes more capable.
     */
    static final int MULTI_MAX_FRACTIONS = 12;

    /**
     * Make the texture width a power of two value larger
     * than MULTI_MAX_FRACTIONS.
     */
    private static final int MULTI_TEXTURE_SIZE = 16;
    private static final int MULTI_CACHE_SIZE = 256;
    private static final int GTEX_CLR_TABLE_SIZE = 101; // for every % from 0% to 100%
    private static final int GTEX_CLR_TABLE_MIRRORED_SIZE =
        GTEX_CLR_TABLE_SIZE * 2 - 1;

    private static final float FULL_TEXEL_Y = 1.0f / MULTI_CACHE_SIZE;
    private static final float HALF_TEXEL_Y = FULL_TEXEL_Y / 2.0f;

    private static final FloatBuffer stopVals =
        BufferUtil.newFloatBuffer(MULTI_MAX_FRACTIONS * 4);
    private static final ByteBuffer bgraColors =
        BufferUtil.newByteBuffer(MULTI_TEXTURE_SIZE*4);
    private static final Image colorsImg =
        Image.fromByteBgraPreData(bgraColors, MULTI_TEXTURE_SIZE, 1);
    private static final int[] previousColors = new int[MULTI_TEXTURE_SIZE];

    private static final byte gtexColors[] = new byte[GTEX_CLR_TABLE_MIRRORED_SIZE * 4];
    private static final Image gtexImg =
        Image.fromByteBgraPreData(ByteBuffer.wrap(gtexColors), GTEX_CLR_TABLE_MIRRORED_SIZE, 1);

    private static long cacheOffset = -1;

    private static Texture gradientCacheTexture = null;
    private static Texture gtexCacheTexture = null;

    private static final Affine2D scratchXform2D = new Affine2D();
    private static final Affine3D scratchXform3D = new Affine3D();

    private static float len(float dx, float dy) {
        return ((dx == 0f) ? Math.abs(dy)
                : ((dy == 0f) ? Math.abs(dx)
                   : (float)Math.sqrt(dx * dx + dy * dy)));
    }

    static void initGradientTextures(ShaderGraphics g) {
        gradientCacheTexture = g.getResourceFactory().createTexture(
                PixelFormat.BYTE_BGRA_PRE, Usage.DEFAULT, WrapMode.CLAMP_TO_EDGE,
                MULTI_TEXTURE_SIZE, MULTI_CACHE_SIZE);
        gradientCacheTexture.setLinearFiltering(true);
        // gradientCacheTexture remains permanently locked, useful, and permanent
        // an additional lock is added when a caller calls getGreientTeture for
        // them to unlock
        gradientCacheTexture.contentsUseful();
        gradientCacheTexture.makePermanent();

        gtexCacheTexture = g.getResourceFactory().createTexture(
                PixelFormat.BYTE_BGRA_PRE, Usage.DEFAULT, WrapMode.CLAMP_NOT_NEEDED,
                GTEX_CLR_TABLE_MIRRORED_SIZE, MULTI_CACHE_SIZE);
        gtexCacheTexture.setLinearFiltering(true);
        // gtexCacheTexture remains permanently locked, useful, and permanent
        // an additional lock is added when a caller calls getWrapGreientTeture for
        // them to unlock
        gtexCacheTexture.contentsUseful();
        gtexCacheTexture.makePermanent();
    }

    static Texture getGradientTexture(ShaderGraphics g, Gradient paint) {
        if (gradientCacheTexture == null) {
            initGradientTextures(g);
        }

        // gradientCacheTexture is left permanent and locked so it never
        // goes away or needs to be checked for isSurfaceLost(), but we
        // add a lock here so that the caller can unlock without knowing
        // our inner implementation details
        gradientCacheTexture.lock();
        return gradientCacheTexture;
    }

    static Texture getWrapGradientTexture(ShaderGraphics g) {
        if (gtexCacheTexture == null) {
            initGradientTextures(g);
        }

        // gtexCacheTexture is left permanent and locked so it never
        // goes away or needs to be checked for isSurfaceLost(), but we
        // add a lock here so that the caller can unlock without knowing
        // our inner implementation details
        gtexCacheTexture.lock();
        return gtexCacheTexture;
    }

    private static void stopsToImage(List&lt;Stop&gt; stops, int numStops)
    {
        if (numStops &gt; MULTI_MAX_FRACTIONS) {
            throw new RuntimeException(
                &quot;Maximum number of gradient stops exceeded &quot; +
                &quot;(paint uses &quot; + numStops +
                &quot; stops, but max is &quot; + MULTI_MAX_FRACTIONS + &quot;)&quot;);
        }

        bgraColors.clear();
        Color lastColor = null;
        for (int i = 0; i &lt; MULTI_TEXTURE_SIZE; i++) {
            Color c;
            if (i &lt; numStops) {
                c = stops.get(i).getColor();
                lastColor = c;
            } else {
                // repeat the last color for the remaining slots so that
                // we can simply reference the last pixel of the texture when
                // dealing with edge conditions
                c = lastColor;
            }
            c.putBgraPreBytes(bgraColors);

            // optimization: keep track of colors used each time so that
            // we can skip updating the texture if the colors are same as
            // the last time
            int argb = c.getIntArgbPre();
            if (argb != previousColors[i]) {
                previousColors[i] = argb;
            }
        }
        bgraColors.rewind();
    }

    private static void insertInterpColor(byte colors[], int index,
                                          Color c0, Color c1, float t)
    {
        t *= 255.0f;
        float u = 255.0f - t;
        index *= 4;
        colors[index + 0] = (byte) (c0.getBluePremult()  * u + c1.getBluePremult()  * t + 0.5f);
        colors[index + 1] = (byte) (c0.getGreenPremult() * u + c1.getGreenPremult() * t + 0.5f);
        colors[index + 2] = (byte) (c0.getRedPremult()   * u + c1.getRedPremult()   * t + 0.5f);
        colors[index + 3] = (byte) (c0.getAlpha()        * u + c1.getAlpha()        * t + 0.5f);
    }

    private static Color PINK = new Color(1.0f, 0.078431375f, 0.5764706f, 1.0f);

    private static void stopsToGtexImage(List&lt;Stop&gt; stops, int numStops) {
        Color lastColor = stops.get(0).getColor();
        float offset = stops.get(0).getOffset();
        int lastIndex = (int) (offset * (GTEX_CLR_TABLE_SIZE - 1) + 0.5f);
        insertInterpColor(gtexColors, 0, lastColor, lastColor, 0.0f);
        for (int i = 1; i &lt; numStops; i++) {
            Color color = stops.get(i).getColor();
            offset = stops.get(i).getOffset();
            int index = (int) (offset * (GTEX_CLR_TABLE_SIZE - 1) + 0.5f);
            if (index == lastIndex) {
                insertInterpColor(gtexColors, index, lastColor, color, 0.5f);
            } else {
                for (int j = lastIndex+1; j &lt;= index; j++) {
                    float t = j - lastIndex;
                    t /= (index - lastIndex);
                    insertInterpColor(gtexColors, j, lastColor, color, t);
                }
            }
            lastIndex = index;
            lastColor = color;
        }
        // assert (lastIndex = GTEX_CLR_TABLE_SIZE);
        // now mirror the list for fast REFLECT calculations
        // mirroring is around index = (GTEX_CLR_TABLE_SIZE-1) which is
        // where the last color for fract=1.0 should have been stored
        for (int i = 1; i &lt; GTEX_CLR_TABLE_SIZE; i++) {
            int j = (GTEX_CLR_TABLE_SIZE - 1 + i) * 4;
            int k = (GTEX_CLR_TABLE_SIZE - 1 - i) * 4;
            gtexColors[j + 0] = gtexColors[k + 0];
            gtexColors[j + 1] = gtexColors[k + 1];
            gtexColors[j + 2] = gtexColors[k + 2];
            gtexColors[j + 3] = gtexColors[k + 3];
        }
    }

    // Uses a least recently allocated algorithm for caching Gradient colors.
    // This could be optimized so that we never use the same color twice.
    // We always increment the cacheOffset (long) and keep the gradients stored
    // the cache in the range [cacheOffset - cacheSize + 1, cacheOffset]..
    public static int initGradient(Gradient paint) {
        long offset = paint.getGradientOffset();
        if (offset &gt;= 0 &amp;&amp; (offset &gt; cacheOffset - MULTI_CACHE_SIZE)) {
            return (int) (offset % MULTI_CACHE_SIZE);
        } else {
            List&lt;Stop&gt; stops = paint.getStops();
            int numStops = paint.getNumStops();
            stopsToImage(stops,numStops);
            stopsToGtexImage(stops, numStops);
            long nextOffset = ++cacheOffset;
            paint.setGradientOffset(nextOffset);
            int cacheIdx = (int)(nextOffset % MULTI_CACHE_SIZE);
            // both gradientCacheTexture and gtexCacheTexture should be
            // left permanent and locked so we can always call update on
            // either or both of them here.
            gradientCacheTexture.update(colorsImg, 0, cacheIdx);
            gtexCacheTexture.update(gtexImg, 0, cacheIdx);
            return cacheIdx;
        }
    }

    private static void setMultiGradient(Shader shader,
                                         Gradient paint)
    {
        List&lt;Stop&gt; stops = paint.getStops();
        int numStops = paint.getNumStops();

        stopVals.clear();
        for (int i = 0; i &lt; MULTI_MAX_FRACTIONS; i++) {
            // TODO: optimize this... (RT-27377)
            stopVals.put((i &lt; numStops)   ?
                         stops.get(i).getOffset() : 0f);
            stopVals.put((i &lt; numStops-1) ?
                         1f / (stops.get(i+1).getOffset() - stops.get(i).getOffset()) : 0f);
            stopVals.put(0f); // unused
            stopVals.put(0f); // unused
        }
        stopVals.rewind();
        shader.setConstants(&quot;fractions&quot;, stopVals, 0, MULTI_MAX_FRACTIONS);
        float index_y = initGradient(paint);
        shader.setConstant(&quot;offset&quot;, index_y / (float)MULTI_CACHE_SIZE + HALF_TEXEL_Y);

        // Note that the colors image/texture has already been updated
        // in BaseShaderContext.validatePaintOp()...
    }

    private static void setTextureGradient(Shader shader,
                                           Gradient paint)
    {
        float cy = initGradient(paint) + 0.5f;
        float cx = 0.5f;
        float fractmul = 0.0f, clampmul = 0.0f;
        switch (paint.getSpreadMethod()) {
            case Gradient.PAD:
                // distance from 0.5 texels to TABLE_SIZE - 0.5 texels
                clampmul = GTEX_CLR_TABLE_SIZE - 1.0f;
                break;
            case Gradient.REPEAT:
                // distance from 0.5 texels to TABLE_SIZE - 0.5 texels
                fractmul = GTEX_CLR_TABLE_SIZE - 1.0f;
                break;
            case Gradient.REFLECT:
                // distance from 0.5 texels to MIRROR_TABLE_SIZE - 0.5 texels
                fractmul = GTEX_CLR_TABLE_MIRRORED_SIZE - 1.0f;
                break;
        }
        float xscale = 1.0f / gtexCacheTexture.getPhysicalWidth();
        float yscale = 1.0f / gtexCacheTexture.getPhysicalHeight();
        cx *= xscale;
        cy *= yscale;
        fractmul *= xscale;
        clampmul *= xscale;
        shader.setConstant(&quot;content&quot;, cx, cy, fractmul, clampmul);

        // Note that the colors image/texture has already been updated
        // in BaseShaderContext.validatePaintOp()...
    }

/********************** LinearGradientPaint support *************************/

    /**
     * This method uses techniques that are nearly identical to those
     * employed in setGradientPaint() above.  The primary difference
     * is that at the native level we use a fragment shader to manually
     * apply the plane equation constants to the current fragment position
     * to calculate the gradient position in the range [0,1] (the native
     * code for GradientPaint does the same, except that it uses OpenGL's
     * automatic texture coordinate generation facilities). We Also, project
     * in the 3D case to create a perspective vector which is used in the
     * fragment shader.
     *
     * One other minor difference worth mentioning is that
     * setGradientPaint() calculates the plane equation constants
     * such that the gradient end points are positioned at 0.25 and 0.75
     * (for reasons discussed in the comments for that method).  In
     * contrast, for LinearGradientPaint we setup the equation constants
     * such that the gradient end points fall at 0.0 and 1.0.  The
     * reason for this difference is that in the fragment shader we
     * have more control over how the gradient values are interpreted
     * (depending on the paint's CycleMethod).
     */
    static void setLinearGradient(ShaderGraphics g,
                                  Shader shader,
                                  LinearGradient paint,
                                  float rx, float ry, float rw, float rh)
    {
        BaseTransform paintXform = paint.getGradientTransformNoClone();
        Affine3D at = scratchXform3D;
        g.getPaintShaderTransform(at);

        if (paintXform != null) {
            at.concatenate(paintXform);
        }

        float x1 = rx + (paint.getX1() * rw);
        float y1 = ry + (paint.getY1() * rh);
        float x2 = rx + (paint.getX2() * rw);
        float y2 = ry + (paint.getY2() * rh);

        // calculate plane equation constants
        float x = x1;
        float y = y1;
        at.translate(x, y);
        // now gradient point 1 is at the origin
        x = x2 - x;
        y = y2 - y;
        double len = len(x, y);

        at.rotate(Math.atan2(y, x));
        // now gradient point 2 is on the positive x-axis
        at.scale(len, 1);
        // now gradient point 1 is at (0.0, 0), point 2 is at (1.0, 0)

        double p0, p1, p2;

        if (!at.is2D()) {
            BaseTransform inv;
            try {
                inv = at.createInverse();
            } catch (NoninvertibleTransformException e) {
                at.setToScale(0, 0, 0);
                inv = at;
            }

            NGCamera cam = g.getCameraNoClone();
            Vec3d tmpVec = new Vec3d();
            PickRay tmpvec = new PickRay();

            PickRay ray00 = project(0,0,cam,inv,tmpvec,tmpVec,null);
            PickRay ray10 = project(1,0,cam,inv,tmpvec,tmpVec,null);
            PickRay ray01 = project(0,1,cam,inv,tmpvec,tmpVec,null);

            p0 = ray10.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
            p1 = ray01.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
            p2 = ray00.getDirectionNoClone().x;

            p0 *= -ray00.getOriginNoClone().z;
            p1 *= -ray00.getOriginNoClone().z;
            p2 *= -ray00.getOriginNoClone().z;

            double wv0 = ray10.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
            double wv1 = ray01.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
            double wv2 = ray00.getDirectionNoClone().z;

            shader.setConstant(&quot;gradParams&quot;, (float)p0, (float)p1, (float)p2, (float)ray00.getOriginNoClone().x);
            shader.setConstant(&quot;perspVec&quot;, (float)wv0, (float)wv1, (float)wv2);
        } else {
            try {
                at.invert();
            } catch (NoninvertibleTransformException ex) {
                at.setToScale(0, 0, 0);
            }
            p0 = (float)at.getMxx();
            p1 = (float)at.getMxy();
            p2 = (float)at.getMxt();
            shader.setConstant(&quot;gradParams&quot;, (float)p0, (float)p1, (float)p2, 0.0f);
            shader.setConstant(&quot;perspVec&quot;, 0.0f, 0.0f, 1.0f);
        }

        setMultiGradient(shader, paint);
    }

    static AffineBase getLinearGradientTx(LinearGradient paint,
                                          Shader shader,
                                          BaseTransform renderTx,
                                          float rx, float ry, float rw, float rh)
    {
        AffineBase ret;

        float x1 = paint.getX1();
        float y1 = paint.getY1();
        float x2 = paint.getX2();
        float y2 = paint.getY2();
        if (paint.isProportional()) {
            x1 = rx + x1 * rw;
            y1 = ry + y1 * rh;
            x2 = rx + x2 * rw;
            y2 = ry + y2 * rh;
        }
        float dx = x2 - x1;
        float dy = y2 - y1;
        float len = len(dx, dy);
        if (paint.getSpreadMethod() == Gradient.REFLECT) {
            len *= 2.0f;
        }

        BaseTransform paintXform = paint.getGradientTransformNoClone();
        if (paintXform.isIdentity() &amp;&amp; renderTx.isIdentity()) {
            Affine2D at = scratchXform2D;

            // calculate plane equation constants
            at.setToTranslation(x1, y1);
            // now gradient point 1 is at the origin
            at.rotate(dx, dy);
            // now gradient point 2 is on the positive x-axis
            at.scale(len, 1);
            // now 0,0 maps to gradient point 1 and 1,0 maps to point 2

            ret = at;
        } else {
            Affine3D at = scratchXform3D;
            at.setTransform(renderTx);
            at.concatenate(paintXform);

            // calculate plane equation constants
            at.translate(x1, y1);
            // now gradient point 1 is at the origin
            at.rotate(Math.atan2(dy, dx));
            // now gradient point 2 is on the positive x-axis
            at.scale(len, 1);
            // now 0,0 maps to gradient point 1 and 1,0 maps to point 2

            ret = at;
        }

        try {
            ret.invert();
        } catch (NoninvertibleTransformException e) {
            scratchXform2D.setToScale(0, 0);
            ret = scratchXform2D;
        }

        setTextureGradient(shader, paint);

        return ret;
    }

/********************** RadialGradientPaint support *************************/

    /**
     * This method calculates six m** values and a focus adjustment value that
     * are used by the native fragment shader. (See LinearGradient Comment for
     * the 3D case.) These techniques are based on a whitepaper by Daniel Rice
     * on radial gradient performance (attached to the bug report for 6521533).
     * One can refer to that document for the complete set of formulas and
     * calculations, but the basic goal is to compose a transform that will
     * convert an (x,y) position in device space into a &quot;u&quot; value that represents
     * the relative distance to the gradient focus point.  The resulting
     * value can be used to look up the appropriate color by linearly
     * interpolating between the two nearest colors in the gradient.
     */
    static void setRadialGradient(ShaderGraphics g,
                                  Shader shader,
                                  RadialGradient paint,
                                  float rx, float ry, float rw, float rh)
    {
        Affine3D at = scratchXform3D;
        g.getPaintShaderTransform(at);

        // save original (untransformed) center and focus points and
        // adjust to account for proportional attribute if necessary
        float radius = paint.getRadius();
        float cx = paint.getCenterX();
        float cy = paint.getCenterY();
        float fa = paint.getFocusAngle();
        float fd = paint.getFocusDistance();
        if (fd &lt; 0) {
            fd = -fd;
            fa = fa+180;
        }
        fa = (float) Math.toRadians(fa);
        if (paint.isProportional()) {
            float bcx = rx + (rw / 2f);
            float bcy = ry + (rh / 2f);
            float scale = Math.min(rw, rh);
            cx = (cx - 0.5f) * scale + bcx;
            cy = (cy - 0.5f) * scale + bcy;
            if (rw != rh &amp;&amp; rw != 0f &amp;&amp; rh != 0f) {
                at.translate(bcx, bcy);
                at.scale(rw / scale, rh / scale);
                at.translate(-bcx, -bcy);
            }
            radius = radius * scale;
        }

        // transform from gradient coords to device coords
        BaseTransform paintXform = paint.getGradientTransformNoClone();
        if (paintXform != null) {
            at.concatenate(paintXform);
        }

        // transform unit circle to gradient coords; we start with the
        // unit circle (center=(0,0), focus on positive x-axis, radius=1)
        // and then transform into gradient space
        at.translate(cx, cy);
        at.rotate(fa);
<A NAME="39"></A>        at.scale(radius, radius);

            // invert to get mapping from device coords to unit circle
        <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#39',2,'match44-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
            at.invert();
        } catch (Exception e) {
            at.setToScale(0.0, 0.0, 0.0);
        }

        if (!at.is2D()) {</B></FONT>
            NGCamera cam = g.getCameraNoClone();
            Vec3d tmpVec = new Vec3d();
            PickRay tmpvec = new PickRay();

            PickRay ray00 = project(0, 0, cam, at, tmpvec, tmpVec, null);
            PickRay ray10 = project(1, 0, cam, at, tmpvec, tmpVec, null);
            PickRay ray01 = project(0, 1, cam, at, tmpvec, tmpVec, null);

            double p0 = ray10.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
            double p1 = ray01.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
            double p2 = ray00.getDirectionNoClone().x;

            double py0 = ray10.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
            double py1 = ray01.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
            double py2 = ray00.getDirectionNoClone().y;

            p0 *= -ray00.getOriginNoClone().z;
            p1 *= -ray00.getOriginNoClone().z;
            p2 *= -ray00.getOriginNoClone().z;

            py0 *= -ray00.getOriginNoClone().z;
            py1 *= -ray00.getOriginNoClone().z;
            py2 *= -ray00.getOriginNoClone().z;

            double wv0 = ray10.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
            double wv1 = ray01.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
            double wv2 = ray00.getDirectionNoClone().z;

            shader.setConstant(&quot;perspVec&quot;, (float) wv0, (float) wv1, (float) wv2);
            shader.setConstant(&quot;m0&quot;, (float) p0, (float) p1, (float) p2, (float) ray00.getOriginNoClone().x);
            shader.setConstant(&quot;m1&quot;, (float) py0, (float) py1, (float) py2, (float) ray00.getOriginNoClone().y);
        } else {
            float m00 = (float) at.getMxx();
            float m01 = (float) at.getMxy();
            float m02 = (float) at.getMxt();
            shader.setConstant(&quot;m0&quot;, m00, m01, m02, 0.0f);

            float m10 = (float) at.getMyx();
            float m11 = (float) at.getMyy();
            float m12 = (float) at.getMyt();
            shader.setConstant(&quot;m1&quot;, m10, m11, m12, 0.0f);

            shader.setConstant(&quot;perspVec&quot;, 0.0f, 0.0f, 1.0f);
        }

        // clamp the focus point so that it does not rest on, or outside
        // of, the circumference of the gradient circle
        fd = (float) Math.min(fd, 0.99f);

        // pack a few unrelated, precalculated values into a single float4
        float denom = 1.0f - (fd * fd);
        float inv_denom = 1.0f / denom;
        shader.setConstant(&quot;precalc&quot;, fd, denom, inv_denom);

        setMultiGradient(shader, paint);
    }

    static AffineBase getRadialGradientTx(RadialGradient paint,
                                          Shader shader,
                                          BaseTransform renderTx,
                                          float rx, float ry, float rw, float rh)
    {
        Affine3D at = scratchXform3D;
        at.setTransform(renderTx);

        // save original (untransformed) center and focus points and
        // adjust to account for proportional attribute if necessary
        float radius = paint.getRadius();
        float cx = paint.getCenterX();
        float cy = paint.getCenterY();
        float fa = paint.getFocusAngle();
        float fd = paint.getFocusDistance();
        if (fd &lt; 0) {
            fd = -fd;
            fa = fa+180;
        }
        fa = (float) Math.toRadians(fa);
        if (paint.isProportional()) {
            float bcx = rx + (rw / 2f);
            float bcy = ry + (rh / 2f);
            float scale = Math.min(rw, rh);
            cx = (cx - 0.5f) * scale + bcx;
            cy = (cy - 0.5f) * scale + bcy;
            if (rw != rh &amp;&amp; rw != 0f &amp;&amp; rh != 0f) {
                at.translate(bcx, bcy);
                at.scale(rw / scale, rh / scale);
                at.translate(-bcx, -bcy);
            }
            radius = radius * scale;
        }
        if (paint.getSpreadMethod() == Gradient.REFLECT) {
            radius *= 2.0f;
        }

        // transform from gradient coords to device coords
        BaseTransform paintXform = paint.getGradientTransformNoClone();
        if (paintXform != null) {
            at.concatenate(paintXform);
        }

        // transform unit circle to gradient coords; we start with the
        // unit circle (center=(0,0), focus on positive x-axis, radius=1)
        // and then transform into gradient space
        at.translate(cx, cy);
        at.rotate(fa);
        at.scale(radius, radius);

            // invert to get mapping from device coords to unit circle
        try {
            at.invert();
        } catch (Exception e) {
            at.setToScale(0.0, 0.0, 0.0);
        }

        // clamp the focus point so that it does not rest on, or outside
        // of, the circumference of the gradient circle
        fd = (float) Math.min(fd, 0.99f);

        // pack a few unrelated, precalculated values into a single float4
        float denom = 1.0f - (fd * fd);
        float inv_denom = 1.0f / denom;
        shader.setConstant(&quot;precalc&quot;, fd, denom, inv_denom);

        setTextureGradient(shader, paint);

        return at;
    }

/************************** ImagePattern support ****************************/

    /**
     * We use the plane equation to automatically
     * map the ImagePattern image to the geometry being rendered.  The
     * shader uses two separate plane equations that take the (x,y)
     * location (in device space) of the fragment being rendered to
     * calculate (u,v) texture coordinates for that fragment:
     *     u = Ax + By + Cz + Dw
     *     v = Ex + Fy + Gz + Hw
     *
     * For the 3D case we calculate a perspective vector by projecting rays
     * at various points, can finding the deltas. So we need to calculate appropriate
     * values for the plane equation constants (A,B,D) and (E,F,H) such
     * that {u,v}=0 for the top-left of the ImagePattern's anchor
     * rectangle and {u,v}=1 for the bottom-right of the anchor rectangle.
     * We can easily make the texture image repeat for {u,v} values
     * outside the range [0,1] by using the fract() instruction within
     * the shader.
     *
     * Calculating the plane equation constants is surprisingly simple.
     * We can think of it as an inverse matrix operation that takes
     * device space coordinates and transforms them into user space
     * coordinates that correspond to a location relative to the anchor
     * rectangle.  First, we translate and scale the current user space
     * transform by applying the anchor rectangle bounds.  We then take
     * the inverse of this affine transform.  The rows of the resulting
     * inverse matrix correlate nicely to the plane equation constants
     * we were seeking.
     */

    static void setImagePattern(ShaderGraphics g,
                                Shader shader,
                                ImagePattern paint,
                                float rx, float ry, float rw, float rh)
    {
        float x1 = rx + (paint.getX() * rw);
        float y1 = ry + (paint.getY() * rh);
        float x2 = x1 + (paint.getWidth() * rw);
        float y2 = y1 + (paint.getHeight() * rh);

        ResourceFactory rf = g.getResourceFactory();
        Image img = paint.getImage();
        Texture paintTex = rf.getCachedTexture(img, Texture.WrapMode.REPEAT);
        float cx = paintTex.getContentX();
        float cy = paintTex.getContentY();
        float cw = paintTex.getContentWidth();
        float ch = paintTex.getContentHeight();
        float texw = paintTex.getPhysicalWidth();
        float texh = paintTex.getPhysicalHeight();
        paintTex.unlock();

        // calculate plane equation constants
        Affine3D at = scratchXform3D;
        g.getPaintShaderTransform(at);

        at.translate(x1, y1);
        at.scale(x2 - x1, y2 - y1);
        // Adjustment for case when WrapMode.REPEAT is simulated
        if (cw &lt; texw) {
            at.translate(0.5/cw, 0.0);
            cx += 0.5f;
        }
        if (ch &lt; texh) {
            at.translate(0.0, 0.5/ch);
            cy += 0.5f;
        }

        try {
            at.invert();
        } catch (Exception e) {
            at.setToScale(0.0, 0.0, 0.0);
        }

        if (!at.is2D()) {
            NGCamera cam = g.getCameraNoClone();
            Vec3d tmpVec = new Vec3d();
            PickRay tmpvec = new PickRay();
            PickRay ray00 = project(0,0,cam,at,tmpvec,tmpVec,null);
            PickRay ray10 = project(1,0,cam,at,tmpvec,tmpVec,null);
            PickRay ray01 = project(0,1,cam,at,tmpvec,tmpVec,null);

            double p0 = ray10.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
            double p1 = ray01.getDirectionNoClone().x - ray00.getDirectionNoClone().x;
            double p2 = ray00.getDirectionNoClone().x;

            double py0 = ray10.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
            double py1 = ray01.getDirectionNoClone().y - ray00.getDirectionNoClone().y;
            double py2 = ray00.getDirectionNoClone().y;

            p0 *= -ray00.getOriginNoClone().z;
            p1 *= -ray00.getOriginNoClone().z;
            p2 *= -ray00.getOriginNoClone().z;

            py0 *= -ray00.getOriginNoClone().z;
            py1 *= -ray00.getOriginNoClone().z;
            py2 *= -ray00.getOriginNoClone().z;

            double wv0 = ray10.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
            double wv1 = ray01.getDirectionNoClone().z - ray00.getDirectionNoClone().z;
            double wv2 = ray00.getDirectionNoClone().z;

            shader.setConstant(&quot;perspVec&quot;, (float)wv0, (float)wv1, (float)wv2);
            shader.setConstant(&quot;xParams&quot;, (float)p0, (float)p1, (float)p2, (float)ray00.getOriginNoClone().x);
            shader.setConstant(&quot;yParams&quot;, (float)py0, (float)py1, (float)py2, (float)ray00.getOriginNoClone().y);
        } else {
            float m00 = (float)at.getMxx();
            float m01 = (float)at.getMxy();
            float m02 = (float)at.getMxt();
            shader.setConstant(&quot;xParams&quot;, m00, m01, m02, 0.0f);

            float m10 = (float)at.getMyx();
            float m11 = (float)at.getMyy();
            float m12 = (float)at.getMyt();
            shader.setConstant(&quot;yParams&quot;, m10, m11, m12, 0.0f);
            shader.setConstant(&quot;perspVec&quot;, 0.0f, 0.0f, 1.0f);
        }

        cx /= texw;
        cy /= texh;
        cw /= texw;
        ch /= texh;
        shader.setConstant(&quot;content&quot;, cx, cy, cw, ch);
    }

    static AffineBase getImagePatternTx(ShaderGraphics g,
                                        ImagePattern paint,
                                        Shader shader,
                                        BaseTransform renderTx,
                                        float rx, float ry, float rw, float rh)
    {
        float px = paint.getX();
        float py = paint.getY();
        float pw = paint.getWidth();
        float ph = paint.getHeight();
        if (paint.isProportional()) {
            px = rx + px * rw;
            py = ry + py * rh;
            pw = pw * rw;
            ph = ph * rh;
        }

        ResourceFactory rf = g.getResourceFactory();
        Image img = paint.getImage();
        Texture paintTex = rf.getCachedTexture(img, Texture.WrapMode.REPEAT);
        float cx = paintTex.getContentX();
        float cy = paintTex.getContentY();
        float cw = paintTex.getContentWidth();
        float ch = paintTex.getContentHeight();
        float texw = paintTex.getPhysicalWidth();
        float texh = paintTex.getPhysicalHeight();
        paintTex.unlock();

        // calculate plane equation constants
        AffineBase ret;
        if (renderTx.isIdentity()) {
            Affine2D at = scratchXform2D;

            at.setToTranslation(px, py);
            at.scale(pw, ph);
            ret = at;
        } else {
            Affine3D at = scratchXform3D;
            at.setTransform(renderTx);

            at.translate(px, py);
            at.scale(pw, ph);
            ret = at;
        }

        // Adjustment for case when WrapMode.REPEAT is simulated
        if (cw &lt; texw) {
            ret.translate(0.5/cw, 0.0);
            cx += 0.5f;
        }
        if (ch &lt; texh) {
            ret.translate(0.0, 0.5/ch);
            cy += 0.5f;
        }

        try {
            ret.invert();
        } catch (Exception e) {
            ret = scratchXform2D;
            scratchXform2D.setToScale(0.0, 0.0);
        }

        cx /= texw;
        cy /= texh;
        cw /= texw;
        ch /= texh;
        shader.setConstant(&quot;content&quot;, cx, cy, cw, ch);

        return ret;
    }

    static PickRay project(float x, float y,
                           NGCamera cam, BaseTransform inv,
                           PickRay tmpray, Vec3d tmpvec, Point2D ret)
    {
        tmpray = cam.computePickRay(x, y, tmpray);
        return tmpray.project(inv, cam instanceof NGPerspectiveCamera,
                                         tmpvec, ret);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/J2DFontFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.awt.Font;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;

import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.PGFont;
import com.sun.javafx.font.FontFactory;
import com.sun.javafx.PlatformUtil;

/**
 * This is mostly just delegating, except for allowing for the
 * registration of embedded fonts with Java 2D.
 * Its possible it could also be check the names of all fonts that
 * are being used are known to 2D but I'm not sure I need that.
 */

final class J2DFontFactory implements FontFactory {

    FontFactory prismFontFactory;

    J2DFontFactory(FontFactory fontFactory) {
        prismFontFactory = fontFactory;
    }

    public PGFont createFont(String name, float size) {
        return prismFontFactory.createFont(name, size);
    }

    public PGFont createFont(String family,
                             boolean bold, boolean italic, float size) {
        return prismFontFactory.createFont(family, bold, italic, size);
    }

    public synchronized PGFont deriveFont(PGFont font, boolean bold,
                                          boolean italic, float size) {
        return prismFontFactory.deriveFont(font, bold, italic, size);
    }

    public String[] getFontFamilyNames() {
        return prismFontFactory.getFontFamilyNames();
    }

    public String[] getFontFullNames() {
        return prismFontFactory.getFontFullNames();
    }

    public String[] getFontFullNames(String family) {
        return prismFontFactory.getFontFullNames(family);
    }

    public boolean isPlatformFont(String name) {
        return prismFontFactory.isPlatformFont(name);
    }

    public final boolean hasPermission() {
        return prismFontFactory.hasPermission();
    }

    /* This is an important but tricky one. We need to copy the
     * stream. I don't want to have to manage the temp file deletion here,
     * so although its non-optimal I will create a temp file, provide
     * input streams on it to both prism and 2D, then when they are done,
     * remove it.
     */
    public PGFont[] loadEmbeddedFont(String name, InputStream fontStream,
                                     float size,
                                     boolean register,
                                     boolean loadAll) {

        if (!hasPermission()) {
            PGFont[] fonts = new PGFont[1];
            fonts[0] = createFont(DEFAULT_FULLNAME, size);
            return fonts;
        }

        PGFont[] fonts =
          prismFontFactory.loadEmbeddedFont(name, fontStream,
                                            size, register, loadAll);

        if (fonts == null || fonts.length == 0) return null;
        final FontResource fr = fonts[0].getFontResource();
        // REMIND: this needs to be upgraded to use JDK9 createFont
        // which can handle a collection.
        registerFont(fonts[0].getFontResource());
        return fonts;
    }

    /**
     * Printing uses the 2D pipeline which isn't initialised until
     * printing begins, so grabs a copy of the file holding an
     * embedded font to 2D on first use.
     */
    public static void registerFont(final FontResource fr) {

        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            InputStream stream = null;
            try {
                File file = new File(fr.getFileName());
                stream = new FileInputStream(file);
                Font font = Font.createFont(Font.TRUETYPE_FONT, stream);
                fr.setPeer(font);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (Exception e2) {
                    }
                }
            }
            return null;
        });
    }

    public PGFont[] loadEmbeddedFont(String name, String path,
                                     float size,
                                     boolean register,
                                     boolean loadAll) {

        if (!hasPermission()) {
            PGFont[] fonts = new PGFont[1];
            fonts[0] = createFont(DEFAULT_FULLNAME, size);
            return fonts;
        }

        PGFont[] fonts =
            prismFontFactory.loadEmbeddedFont(name, path,
                                              size, register, loadAll);

        if (fonts == null || fonts.length == 0) return null;
        // REMIND: this needs to be upgraded to use JDK9 createFont
        // which can handle a collection.
        final FontResource fr = fonts[0].getFontResource();
        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
<A NAME="9"></A>            public Object run() {
                try {
                    File file = new File(fr.getFileName());
                    Font font = <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#9',2,'match44-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Font.createFont(Font.TRUETYPE_FONT, file);
                    fr.setPeer(font);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return null;
            }
        }</B></FONT>);
        return fonts;
    }

    private static boolean compositeFontMethodsInitialized = false;
    private static Method getCompositeFontUIResource = null;

    /**
     * Returns a composite font from the font passed in the argument.
     * Note: This method relies on Java2D's sun.* APIs which are
     * subject to change.
     * ALso this may be just a stop gap measure.
     */
    static java.awt.Font getCompositeFont(final java.awt.Font srcFont) {
        if (PlatformUtil.isMac()) {
            return srcFont;
        }
        synchronized (J2DFontFactory.class) {
            if (!compositeFontMethodsInitialized) {
                AccessController.doPrivileged(
                        (PrivilegedAction&lt;Void&gt;) () -&gt; {
                            compositeFontMethodsInitialized = true;
                            Class&lt;?&gt; fontMgrCls;
                            try {
                                // JDK7
                                fontMgrCls = Class.forName(
                                        &quot;sun.font.FontUtilities&quot;, true, null);
                            } catch (ClassNotFoundException cnfe) {
                                try {
                                    // JDK5/6
                                    fontMgrCls = Class.forName(
                                       &quot;sun.font.FontManager&quot;, true, null);
                                } catch (ClassNotFoundException cnfe2) {
                                    return null;
                                }
                            }

                            try {
                                getCompositeFontUIResource =
                                    fontMgrCls.getMethod(
                                    &quot;getCompositeFontUIResource&quot;,
                                    Font.class);
                            } catch (NoSuchMethodException nsme) {
                            }
                            return null;
                        }
                );
            }
        }

        if (getCompositeFontUIResource != null) {
            try {
                return
                    (java.awt.Font)getCompositeFontUIResource.
                    invoke(null, srcFont);
            } catch (IllegalAccessException iae) {
            } catch (InvocationTargetException ite) {}
        }

        return srcFont;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/J2DPrismGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d;

import java.awt.LinearGradientPaint;
import java.awt.font.GlyphVector;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.lang.ref.WeakReference;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import com.sun.glass.ui.Screen;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.font.CompositeGlyphMapper;
import com.sun.javafx.font.CompositeStrike;
import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NodePath;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.MaskTextureGraphics;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.j2d.paint.MultipleGradientPaint.ColorSpaceType;
import com.sun.prism.j2d.paint.RadialGradientPaint;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.paint.Stop;
import static java.awt.RenderingHints.KEY_ANTIALIASING;
import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_OFF;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;
import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;
import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;

public class J2DPrismGraphics
    // Do not subclass BaseGraphics without fixing drawTextureVO below...
    implements ReadbackGraphics, MaskTextureGraphics
    // Do not implement RectShadowGraphics without fixing RT-15016 (note that
    // BaseGraphics implements RectShadowGraphics).
{
    static {
        // Assuming direct translation of BasicStroke enums:
        assert(com.sun.prism.BasicStroke.CAP_BUTT == java.awt.BasicStroke.CAP_BUTT);
        assert(com.sun.prism.BasicStroke.CAP_ROUND == java.awt.BasicStroke.CAP_ROUND);
        assert(com.sun.prism.BasicStroke.CAP_SQUARE == java.awt.BasicStroke.CAP_SQUARE);
        assert(com.sun.prism.BasicStroke.JOIN_BEVEL == java.awt.BasicStroke.JOIN_BEVEL);
        assert(com.sun.prism.BasicStroke.JOIN_MITER == java.awt.BasicStroke.JOIN_MITER);
        assert(com.sun.prism.BasicStroke.JOIN_ROUND == java.awt.BasicStroke.JOIN_ROUND);
        // Assuming direct translation of PathIterator enums:
        assert(com.sun.javafx.geom.PathIterator.WIND_EVEN_ODD == java.awt.geom.PathIterator.WIND_EVEN_ODD);
        assert(com.sun.javafx.geom.PathIterator.WIND_NON_ZERO == java.awt.geom.PathIterator.WIND_NON_ZERO);
        assert(com.sun.javafx.geom.PathIterator.SEG_MOVETO == java.awt.geom.PathIterator.SEG_MOVETO);
        assert(com.sun.javafx.geom.PathIterator.SEG_LINETO == java.awt.geom.PathIterator.SEG_LINETO);
        assert(com.sun.javafx.geom.PathIterator.SEG_QUADTO == java.awt.geom.PathIterator.SEG_QUADTO);
        assert(com.sun.javafx.geom.PathIterator.SEG_CUBICTO == java.awt.geom.PathIterator.SEG_CUBICTO);
        assert(com.sun.javafx.geom.PathIterator.SEG_CLOSE == java.awt.geom.PathIterator.SEG_CLOSE);
    }
    static final LinearGradientPaint.CycleMethod LGP_CYCLE_METHODS[] = {
        LinearGradientPaint.CycleMethod.NO_CYCLE,
        LinearGradientPaint.CycleMethod.REFLECT,
        LinearGradientPaint.CycleMethod.REPEAT,
    };
    static final RadialGradientPaint.CycleMethod RGP_CYCLE_METHODS[] = {
        RadialGradientPaint.CycleMethod.NO_CYCLE,
        RadialGradientPaint.CycleMethod.REFLECT,
        RadialGradientPaint.CycleMethod.REPEAT,
    };

    private static final BasicStroke DEFAULT_STROKE =
        new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f);
    private static final Paint DEFAULT_PAINT = Color.WHITE;
    static java.awt.geom.AffineTransform J2D_IDENTITY =
        new java.awt.geom.AffineTransform();
    private int clipRectIndex;
    private boolean hasPreCullingBits = false;
    private float pixelScaleX = 1.0f;
    private float pixelScaleY = 1.0f;

    static java.awt.Color toJ2DColor(Color c) {
        return new java.awt.Color(c.getRed(),
                                  c.getGreen(),
                                  c.getBlue(),
                                  c.getAlpha());
    }

    /*
     * Ensure that no fractions are equal
     *
     * Note that the J2D objects reject equal fractions, but the FX versions
     * allow them.
     *
     * The FX version treats values with equal fractions such that as you
     * approach the fractional value from below it interpolates to the
     * first color associated with that fraction and as you interpolate
     * away from it from above it interpolates the last such color.
     *
     * To get the J2D version to exhibit the FX behavior we collapse all
     * adjacent fractional values into a pair of values that are stored
     * with a pair of immediately adjacent floating point values.  This way
     * they have unique fractions, but no fractional value can be generated
     * which fits between them.  Yet, as you approach from below it will
     * interpolate to the first of the pair of colors and as you move away
     * above it, the second value will take precedence for interpolation.
     *
     * Math.ulp() is used to generate an &quot;immediately adjacent fp value&quot;.
     */
    static int fixFractions(float fractions[], java.awt.Color colors[]) {
        float fprev = fractions[0];
        int i = 1;  // index of next incoming color/fractions we will examine
        int n = 1;  // index of next outgoing color/fraction we will store
        while (i &lt; fractions.length) {
            float f = fractions[i];
            java.awt.Color c = colors[i++];
            if (f &lt;= fprev) {
                // If we find any duplicates after we reach 1.0 we can
                // just ignore the rest of the array.  Not only is there
                // no more &quot;fraction room&quot; to assign them to, but we will
                // never generate a fraction &gt;1.0 to access them anyway
                if (f &gt;= 1.0f) break;
                // Find all fractions that are either fprev or fprev+ulp
                // and collapse them into two entries, the first at fprev
                // which is already stored, and the last matching entry
                // will be stored with fraction fprev+ulp
                f = fprev + Math.ulp(fprev);
                while (i &lt; fractions.length) {
                    if (fractions[i] &gt; f) break;
                    // We continue to remember the color of the last
                    // &quot;matching&quot; entry so it can be stored below
                    c = colors[i++];
                }
            }
            fractions[n] = fprev = f;
            colors[n++] = c;
        }
        return n;
    }

    java.awt.Paint toJ2DPaint(Paint p, java.awt.geom.Rectangle2D b) {
        if (p instanceof Color) {
            return toJ2DColor((Color) p);
        } else if (p instanceof Gradient) {
            Gradient g = (Gradient) p;
            if (g.isProportional()) {
                if (b == null) {
                    return null;
                }
            }
            List&lt;Stop&gt; stops = g.getStops();
            int n = stops.size();
            float fractions[] = new float[n];
            java.awt.Color colors[] = new java.awt.Color[n];
            float prevf = -1f;
            boolean needsFix = false;
            for (int i = 0; i &lt; n; i++) {
                Stop stop = stops.get(i);
                float f = stop.getOffset();
                needsFix = (needsFix || f &lt;= prevf);
                fractions[i] = prevf = f;
                colors[i] = toJ2DColor(stop.getColor());
            }
            if (needsFix) {
                n = fixFractions(fractions, colors);
                if (n &lt; fractions.length) {
                    float newf[] = new float[n];
                    System.arraycopy(fractions, 0, newf, 0, n);
                    fractions = newf;
                    java.awt.Color newc[] = new java.awt.Color[n];
                    System.arraycopy(colors, 0, newc, 0, n);
                    colors = newc;
                }
            }
            if (g instanceof LinearGradient) {
                LinearGradient lg = (LinearGradient) p;
                float x1 = lg.getX1();
                float y1 = lg.getY1();
                float x2 = lg.getX2();
                float y2 = lg.getY2();
                if (g.isProportional()) {
                    float x = (float) b.getX();
                    float y = (float) b.getY();
                    float w = (float) b.getWidth();
                    float h = (float) b.getHeight();
                    x1 = x + w * x1;
                    y1 = y + h * y1;
                    x2 = x + w * x2;
                    y2 = y + h * y2;
                }
                if (x1 == x2 &amp;&amp; y1 == y2) {
                    // Hardware pipelines use an inverse transform of
                    // all zeros to choose colors when the start and end
                    // point are the same so that the first color is
                    // always chosen...
                    return colors[0];
                }
                java.awt.geom.Point2D p1 =
                    new java.awt.geom.Point2D.Float(x1, y1);
                java.awt.geom.Point2D p2 =
                    new java.awt.geom.Point2D.Float(x2, y2);
                LinearGradientPaint.CycleMethod method =
                    LGP_CYCLE_METHODS[g.getSpreadMethod()];
                return new LinearGradientPaint(p1, p2, fractions, colors, method);
            } else if (g instanceof RadialGradient) {
                RadialGradient rg = (RadialGradient) g;
                float cx = rg.getCenterX();
                float cy = rg.getCenterY();
                float r = rg.getRadius();
                double fa = Math.toRadians(rg.getFocusAngle());
                float fd = rg.getFocusDistance();
                java.awt.geom.AffineTransform at = J2D_IDENTITY;
                if (g.isProportional()) {
                    float x = (float) b.getX();
                    float y = (float) b.getY();
                    float w = (float) b.getWidth();
                    float h = (float) b.getHeight();
                    float dim = Math.min(w, h);
                    float bcx = x + w * 0.5f;
                    float bcy = y + h * 0.5f;
                    cx = bcx + (cx - 0.5f) * dim;
                    cy = bcy + (cy - 0.5f) * dim;
                    r *= dim;
                    if (w != h &amp;&amp; w != 0.0 &amp;&amp; h != 0.0) {
                        at = java.awt.geom.AffineTransform.getTranslateInstance(bcx, bcy);
                        at.scale(w / dim, h / dim);
                        at.translate(-bcx, -bcy);
                    }
                }
                java.awt.geom.Point2D center =
                    new java.awt.geom.Point2D.Float(cx, cy);
                float fx = (float) (cx + fd * r * Math.cos(fa));
                float fy = (float) (cy + fd * r * Math.sin(fa));
                java.awt.geom.Point2D focus =
                    new java.awt.geom.Point2D.Float(fx, fy);
                RadialGradientPaint.CycleMethod method =
                    RGP_CYCLE_METHODS[g.getSpreadMethod()];
                return new RadialGradientPaint(center, r, focus, fractions, colors,
                                               method, ColorSpaceType.SRGB, at);
            }
        } else if (p instanceof ImagePattern) {
            ImagePattern imgpat = (ImagePattern) p;
            float x = imgpat.getX();
            float y = imgpat.getY();
            float w = imgpat.getWidth();
            float h = imgpat.getHeight();
            if (p.isProportional()) {
                if (b == null) {
                    return null;
                }
                float bx = (float) b.getX();
                float by = (float) b.getY();
                float bw = (float) b.getWidth();
                float bh = (float) b.getHeight();
                w += x;
                h += y;
                x = bx + x * bw;
                y = by + y * bh;
                w = bx + w * bw;
                h = by + h * bh;
                w -= x;
                h -= y;
            }
            Texture tex =
                getResourceFactory().getCachedTexture(imgpat.getImage(), WrapMode.REPEAT);
            java.awt.image.BufferedImage bimg = ((J2DTexture) tex).getBufferedImage();
            tex.unlock();
            return new java.awt.TexturePaint(bimg, tmpRect(x, y, w, h));
        }
        throw new UnsupportedOperationException(&quot;Paint &quot;+p+&quot; not supported yet.&quot;);
    }

    static java.awt.Stroke toJ2DStroke(BasicStroke stroke) {
        float lineWidth = stroke.getLineWidth();
        int type = stroke.getType();
        if (type != BasicStroke.TYPE_CENTERED) {
            lineWidth *= 2;
        }
        java.awt.BasicStroke bs =
                new java.awt.BasicStroke(lineWidth,
                                         stroke.getEndCap(),
                                         stroke.getLineJoin(),
                                         stroke.getMiterLimit(),
                                         stroke.getDashArray(),
                                         stroke.getDashPhase());
        if (type == BasicStroke.TYPE_INNER) {
            return new InnerStroke(bs);
        } else if (type == BasicStroke.TYPE_OUTER) {
            return new OuterStroke(bs);
        } else {
            return bs;
        }
    }

    private static ConcurrentHashMap&lt;java.awt.Font,
                                     WeakReference&lt;java.awt.Font&gt;&gt;
        fontMap = new ConcurrentHashMap&lt;java.awt.Font,
                                        WeakReference&lt;java.awt.Font&gt;&gt;();
    private static volatile int cleared = 0;

    private static java.awt.Font toJ2DFont(FontStrike strike) {
        FontResource fr = strike.getFontResource();
        java.awt.Font j2dfont;
        Object peer = fr.getPeer();
        if (peer == null &amp;&amp; fr.isEmbeddedFont()) {
            J2DFontFactory.registerFont(fr);
            peer = fr.getPeer();
        }
        if (peer != null &amp;&amp; peer instanceof java.awt.Font) {
            j2dfont = (java.awt.Font)peer;
        } else {
            if (PlatformUtil.isMac()) {
                // Looking up J2D fonts via full name is not reliable on the
                // Mac, however using the PostScript font name is. The likely
                // cause is Mac platform internals heavy reliance on PostScript
                // names for font identification.
                String psName = fr.getPSName();
                // dummy size
                j2dfont = new java.awt.Font(psName, java.awt.Font.PLAIN, 12);

                // REMIND: Due to bugs in j2d font lookup, these two workarounds
                // are required to ensure the correct font is used. Once fixed
                // in the jdk these workarounds should be removed.
                if (!j2dfont.getPSName().equals(psName)) {
                    // 1. Lookup font via family and style. This covers the
                    // case when the J2D PostScript name does not match psName
                    // in font file. For example &quot;HelveticaCYBold&quot; has the
                    // psName &quot;HelveticaCY-Bold&quot; in j2d.
                    int style = fr.isBold() ? java.awt.Font.BOLD : 0;
                    style = style | (fr.isItalic() ? java.awt.Font.ITALIC : 0);
                    j2dfont = new java.awt.Font(fr.getFamilyName(), style, 12);

                    if(!j2dfont.getPSName().equals(psName)) {
                        // 2. J2D seems to be unable to find a few fonts where
                        // psName == familyName.  Workaround is an exhaustive
                        // search of all fonts.
                        java.awt.Font[] allj2dFonts =
                                java.awt.GraphicsEnvironment.
                                getLocalGraphicsEnvironment().getAllFonts();
                        for (java.awt.Font f : allj2dFonts) {
                            if (f.getPSName().equals(psName)) {
                                j2dfont = f;
                                break;
                            }
                        }
                    }
                }
            } else {
                // dummy size
                j2dfont = new java.awt.Font(fr.getFullName(),
                                            java.awt.Font.PLAIN, 12);
            }

            // Adding j2dfont as peer is OK since fr is a decomposed
            // FontResource. Thus preventing font lookup next time we render.
            fr.setPeer(j2dfont);
        }
        // deriveFont(...) still has a bug and will cause #2 problem to occur
        j2dfont = j2dfont.deriveFont(strike.getSize()); // exact float font size
        java.awt.Font compFont = null;
        WeakReference&lt;java.awt.Font&gt; ref = fontMap.get(j2dfont);
        if (ref != null) {
            compFont = ref.get();
            if (compFont == null) {
                cleared++;
            }
        }
        if (compFont == null) {
            if (fontMap.size() &gt; 100 &amp;&amp; cleared &gt; 10) { // purge the map.
                for (java.awt.Font key : fontMap.keySet()) {
                    ref = fontMap.get(key);
                    if (ref == null || ref.get() == null) {
                        fontMap.remove(key);
                    }
                }
                cleared = 0;
            }
            compFont = J2DFontFactory.getCompositeFont(j2dfont);
            ref = new WeakReference(compFont);
            fontMap.put(j2dfont, ref);
        }
        return compFont;
    }

    public static java.awt.geom.AffineTransform
        toJ2DTransform(BaseTransform t)
    {
        return new java.awt.geom.AffineTransform(t.getMxx(), t.getMyx(),
                                                 t.getMxy(), t.getMyy(),
                                                 t.getMxt(), t.getMyt());
    }

    private static java.awt.geom.AffineTransform tmpAT =
        new java.awt.geom.AffineTransform();
    static java.awt.geom.AffineTransform tmpJ2DTransform(BaseTransform t)
    {
        tmpAT.setTransform(t.getMxx(), t.getMyx(),
                           t.getMxy(), t.getMyy(),
                           t.getMxt(), t.getMyt());
        return tmpAT;
    }

    static BaseTransform toPrTransform(java.awt.geom.AffineTransform t)
    {
        return BaseTransform.getInstance(t.getScaleX(), t.getShearY(),
                                         t.getShearX(), t.getScaleY(),
                                         t.getTranslateX(), t.getTranslateY());
    }

    static Rectangle toPrRect(java.awt.Rectangle r)
    {
        return new Rectangle(r.x, r.y, r.width, r.height);
    }

    private static java.awt.geom.Path2D tmpQuadShape =
        new java.awt.geom.Path2D.Float();
    private static java.awt.Shape tmpQuad(float x1, float y1,
                                          float x2, float y2)
    {
        tmpQuadShape.reset();
        tmpQuadShape.moveTo(x1, y1);
        tmpQuadShape.lineTo(x2, y1);
        tmpQuadShape.lineTo(x2, y2);
        tmpQuadShape.lineTo(x1, y2);
        tmpQuadShape.closePath();
        return tmpQuadShape;
    }

    private static java.awt.geom.Rectangle2D.Float tmpRect =
        new java.awt.geom.Rectangle2D.Float();
    private static java.awt.geom.Rectangle2D tmpRect(float x, float y, float w, float h) {
        tmpRect.setRect(x, y, w, h);
        return tmpRect;
    }

    private static java.awt.geom.Ellipse2D tmpEllipse =
        new java.awt.geom.Ellipse2D.Float();
    private static java.awt.Shape tmpEllipse(float x, float y, float w, float h) {
        tmpEllipse.setFrame(x, y, w, h);
        return tmpEllipse;
    }

    private static java.awt.geom.RoundRectangle2D tmpRRect =
        new java.awt.geom.RoundRectangle2D.Float();
    private static java.awt.Shape tmpRRect(float x, float y, float w, float h,
                                           float aw, float ah)
    {
        tmpRRect.setRoundRect(x, y, w, h, aw, ah);
        return tmpRRect;
    }

    private static java.awt.geom.Line2D tmpLine =
        new java.awt.geom.Line2D.Float();
    private static java.awt.Shape tmpLine(float x1, float y1, float x2, float y2) {
        tmpLine.setLine(x1, y1, x2, y2);
        return tmpLine;
    }

    private static AdaptorShape tmpAdaptor = new AdaptorShape();
    private static java.awt.Shape tmpShape(Shape s) {
        tmpAdaptor.setShape(s);
        return tmpAdaptor;
    }

    private boolean antialiasedShape = true;
    J2DPresentable target;
    java.awt.Graphics2D g2d;
    Affine2D transform;
    Rectangle clipRect;
    RectBounds devClipRect;
    RectBounds finalClipRect;
    Paint paint;
    boolean paintWasProportional;
    BasicStroke stroke;
    boolean cull;

    J2DPrismGraphics(J2DPresentable target, java.awt.Graphics2D g2d) {
        this(g2d, target.getContentWidth(), target.getContentHeight());
        this.target = target;
    }

    J2DPrismGraphics(java.awt.Graphics2D g2d, int width, int height) {
        this.g2d = g2d;
        captureTransform(g2d);
        this.transform = new Affine2D();
        this.devClipRect = new RectBounds(0, 0, width, height);
        this.finalClipRect = new RectBounds(0, 0, width, height);
        this.cull = true;

        g2d.setRenderingHint(java.awt.RenderingHints.KEY_STROKE_CONTROL,
                             java.awt.RenderingHints.VALUE_STROKE_PURE);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                              java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_INTERPOLATION,
                             java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        /* Set the text hints to those most equivalent to FX rendering.
         * Will need to revisit this since its unlikely to be sufficient.
         */
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
                           java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
                             java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);


        setTransform(BaseTransform.IDENTITY_TRANSFORM);
        setPaint(DEFAULT_PAINT);
        setStroke(DEFAULT_STROKE);
    }

    public RenderTarget getRenderTarget() {
        return target;
    }

    public Screen getAssociatedScreen() {
        return target.getAssociatedScreen();
    }

    public ResourceFactory getResourceFactory() {
        return target.getResourceFactory();
    }

    public void reset() {
    }

    public Rectangle getClipRect() {
        return clipRect == null ? null : new Rectangle(clipRect);
    }

    public Rectangle getClipRectNoClone() {
        return clipRect;
    }

    public RectBounds getFinalClipNoClone() {
        return finalClipRect;
    }

    public void setClipRect(Rectangle clipRect) {
        this.finalClipRect.setBounds(devClipRect);
        if (clipRect == null) {
            this.clipRect = null;
            g2d.setClip(null);
        } else {
            this.clipRect = new Rectangle(clipRect);
            this.finalClipRect.intersectWith(clipRect);
            setTransformG2D(J2D_IDENTITY);
            g2d.setClip(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
            setTransformG2D(tmpJ2DTransform(transform));
        }
    }

    private java.awt.AlphaComposite getAWTComposite() {
        return (java.awt.AlphaComposite) g2d.getComposite();
    }

    public float getExtraAlpha() {
        return getAWTComposite().getAlpha();
    }

    public void setExtraAlpha(float extraAlpha) {
        g2d.setComposite(getAWTComposite().derive(extraAlpha));
    }

    public CompositeMode getCompositeMode() {
        int rule = getAWTComposite().getRule();
        switch (rule) {
            case java.awt.AlphaComposite.CLEAR:
                return CompositeMode.CLEAR;
            case java.awt.AlphaComposite.SRC:
                return CompositeMode.SRC;
            case java.awt.AlphaComposite.SRC_OVER:
                return CompositeMode.SRC_OVER;
            default:
                throw new InternalError(&quot;Unrecognized AlphaCompsite rule: &quot;+rule);
        }
    }

    public void setCompositeMode(CompositeMode mode) {
        java.awt.AlphaComposite awtComp = getAWTComposite();
        switch (mode) {
            case CLEAR:
                awtComp = awtComp.derive(java.awt.AlphaComposite.CLEAR);
                break;
            case SRC:
                awtComp = awtComp.derive(java.awt.AlphaComposite.SRC);
                break;
            case SRC_OVER:
                awtComp = awtComp.derive(java.awt.AlphaComposite.SRC_OVER);
                break;
            default:
                throw new InternalError(&quot;Unrecognized composite mode: &quot;+mode);
        }
        g2d.setComposite(awtComp);
    }

    public Paint getPaint() {
        return paint;
    }

    public void setPaint(Paint paint) {
        this.paint = paint;
        java.awt.Paint j2dpaint = toJ2DPaint(paint, null);
        if (j2dpaint == null) {
            paintWasProportional = true;
        } else {
            paintWasProportional = false;
            g2d.setPaint(j2dpaint);
        }
    }

    public BasicStroke getStroke() {
        return stroke;
    }

    public void setStroke(BasicStroke stroke) {
        this.stroke = stroke;
        g2d.setStroke(toJ2DStroke(stroke));
    }

    public BaseTransform getTransformNoClone() {
        return transform;
    }

    public void translate(float tx, float ty) {
        transform.translate(tx, ty);
        g2d.translate(tx, ty);
    }

    public void scale(float sx, float sy) {
        transform.scale(sx, sy);
        g2d.scale(sx, sy);
    }

    public void transform(BaseTransform xform) {
        if (!xform.is2D()) {
            // No-op until we support 3D
            return;
        }
        transform.concatenate(xform);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void setTransform(BaseTransform xform) {
        // TODO: Modify PrEffectHelper to not pass a null... (RT-27384)
        if (xform == null) xform = BaseTransform.IDENTITY_TRANSFORM;
        transform.setTransform(xform);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void setTransform(double m00, double m10,
                             double m01, double m11,
                             double m02, double m12)
    {
        transform.setTransform(m00, m10, m01, m11, m02, m12);
        setTransformG2D(tmpJ2DTransform(transform));
    }

    public void clear() {
        clear(Color.TRANSPARENT);
    }

    public void clear(Color color) {
        this.getRenderTarget().setOpaque(color.isOpaque());
        clear(toJ2DColor(color));
    }

    void clear(java.awt.Color c) {
        java.awt.Graphics2D gtmp = (java.awt.Graphics2D) g2d.create();
        gtmp.setTransform(J2D_IDENTITY);
        gtmp.setComposite(java.awt.AlphaComposite.Src);
        gtmp.setColor(c);
        gtmp.fillRect(0, 0, target.getContentWidth(), target.getContentHeight());
        gtmp.dispose();
    }

    public void clearQuad(float x1, float y1, float x2, float y2) {
        g2d.setComposite(java.awt.AlphaComposite.Clear);
        g2d.fill(tmpQuad(x1, y1, x2, y2));
    }

    void fill(java.awt.Shape shape) {
        if (paintWasProportional) {
            if (nodeBounds != null) {
                g2d.setPaint(toJ2DPaint(paint, nodeBounds));
            } else {
                g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
            }
        }
        g2d.fill(shape);
    }

    public void fill(Shape shape) {
        fill(tmpShape(shape));
    }

    public void fillRect(float x, float y, float width, float height) {
        fill(tmpRect(x, y, width, height));
    }

    public void fillRoundRect(float x, float y, float width, float height,
                              float arcw, float arch)
    {
        fill(tmpRRect(x, y, width, height, arcw, arch));
    }

    public void fillEllipse(float x, float y, float width, float height) {
        fill(tmpEllipse(x, y, width, height));
    }

    public void fillQuad(float x1, float y1, float x2, float y2) {
        fill(tmpQuad(x1, y1, x2, y2));
    }

    void draw(java.awt.Shape shape) {
        if (paintWasProportional) {
            if (nodeBounds != null) {
                g2d.setPaint(toJ2DPaint(paint, nodeBounds));
            } else {
                g2d.setPaint(toJ2DPaint(paint, shape.getBounds2D()));
<A NAME="34"></A>            }
        }
        try {
            <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#34',2,'match44-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>g2d.draw(shape);
        } catch (Throwable t) {
            // Workaround for JDK bug 6670624
            // We may get a Ductus PRError (extends RuntimeException)
            // or we may get an InternalError (extends Error)
            // The only common superclass of the two is Throwable...
        }
    }

    public void draw(Shape shape) {</B></FONT>
        draw(tmpShape(shape));
    }

    public void drawLine(float x1, float y1, float x2, float y2) {
        draw(tmpLine(x1, y1, x2, y2));
    }

    public void drawRect(float x, float y, float width, float height) {
        draw(tmpRect(x, y, width, height));
    }

    public void drawRoundRect(float x, float y, float width, float height, float arcw, float arch) {
        draw(tmpRRect(x, y, width, height, arcw, arch));
    }

    public void drawEllipse(float x, float y, float width, float height) {
        draw(tmpEllipse(x, y, width, height));
    }

    Rectangle2D nodeBounds = null;

    public void setNodeBounds(RectBounds bounds) {
        nodeBounds = bounds != null ?
                new Rectangle2D.Float(bounds.getMinX(), bounds.getMinY(),
                                      bounds.getWidth(),bounds.getHeight()) :
                null;
    }

    private void drawString(GlyphList gl, int start, int end,
                            FontStrike strike, float x, float y) {
        if (start == end) return;
        int count = end - start;
        int[] glyphs = new int[count];
        for (int i = 0; i &lt; count; i++) {
            glyphs[i] = gl.getGlyphCode(start + i) &amp; CompositeGlyphMapper.GLYPHMASK;
        }
        java.awt.Font j2dfont = toJ2DFont(strike);
        GlyphVector gv = j2dfont.createGlyphVector(g2d.getFontRenderContext(), glyphs);
        java.awt.geom.Point2D pt = new java.awt.geom.Point2D.Float();
        for (int i = 0; i &lt; count; i++) {
            pt.setLocation(gl.getPosX(start + i), gl.getPosY(start + i));
            gv.setGlyphPosition(i, pt);
        }
        g2d.drawGlyphVector(gv, x, y);
    }

    public void drawString(GlyphList gl, FontStrike strike, float x, float y,
                           Color selectColor, int start, int end) {

        int count = gl.getGlyphCount();
        if (count == 0) return;

        // In JDK6, setting graphics AA disables fast text loops
        g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_OFF);

        // If the surface has Alpha, JDK will ignore the LCD loops.
        // So for this to have any effect we need to fix JDK, or
        // ensure an opaque surface type.
        if (strike.getAAMode() == FontResource.AA_LCD) {
            g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_LCD_HRGB);
        }

        if (paintWasProportional) {
            Rectangle2D rectBounds = nodeBounds;
            if (rectBounds == null) {
                Metrics m = strike.getMetrics();
                rectBounds = new Rectangle2D.Float(0,
                                                   m.getAscent(),
                                                   gl.getWidth(),
                                                   m.getLineHeight());
            }
            g2d.setPaint(toJ2DPaint(paint, rectBounds));
        }

        CompositeStrike cStrike = null;
        int slot = 0;
        if (strike instanceof CompositeStrike) {
            cStrike = (CompositeStrike)strike;
            int glyphCode = gl.getGlyphCode(0);
            slot = cStrike.getStrikeSlotForGlyph(glyphCode);
        }
        java.awt.Color sColor = null;
        java.awt.Color tColor = null;
        boolean selected = false;
        if (selectColor != null) {
            sColor = toJ2DColor(selectColor);
            tColor = g2d.getColor();
            int offset = gl.getCharOffset(0);
            selected = start &lt;= offset &amp;&amp; offset &lt; end;
        }
        int index = 0;
        if (sColor != null || cStrike != null) {
            /* Draw a segment every time selection or font changes */
            for (int i = 1; i &lt; count; i++) {
                if (sColor != null) {
                    int offset = gl.getCharOffset(i);
                    boolean glyphSelected = start &lt;= offset &amp;&amp; offset &lt; end;
                    if (selected != glyphSelected) {
                        if (cStrike != null) {
                            strike = cStrike.getStrikeSlot(slot);
                        }
                        g2d.setColor(selected ? sColor : tColor);
                        drawString(gl, index, i, strike, x, y);
                        index = i;
                        selected = glyphSelected;
                    }
                }
                if (cStrike != null) {
                    int glyphCode = gl.getGlyphCode(i);
                    int glyphSlot = cStrike.getStrikeSlotForGlyph(glyphCode);
                    if (slot != glyphSlot) {
                        strike = cStrike.getStrikeSlot(slot);
                        if (sColor != null) {
                            g2d.setColor(selected ? sColor : tColor);
                        }
                        drawString(gl, index, i, strike, x, y);
                        index = i;
                        slot = glyphSlot;
                    }
                }
            }

            /* Set strike and color to draw the last segment */
            if (cStrike != null) {
                strike = cStrike.getStrikeSlot(slot);
            }
            if (sColor != null) {
                g2d.setColor(selected ? sColor : tColor);
            }
        }
        drawString(gl, index, count, strike, x, y);

        /* Always restore the graphics to its initial color */
        if (selectColor != null) {
            g2d.setColor(tColor);
        }

        // Set hints back to the default.
        g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);
        g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
    }

    /**
     * Overridden by printing subclass to preserve the printer graphics
     * transform.
     */
    protected void setTransformG2D(java.awt.geom.AffineTransform tx) {
        g2d.setTransform(tx);
    }

    /**
     * Needed only by printing subclass, which over-rides it.
     */
    protected void captureTransform(java.awt.Graphics2D g2d) {
        return;
    }

    public void drawMappedTextureRaw(Texture tex,
                                     float dx1, float dy1, float dx2, float dy2,
                                     float tx11, float ty11, float tx21, float ty21,
                                     float tx12, float ty12, float tx22, float ty22)
    {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        float mxx = tx21-tx11;
        float myx = ty21-ty11;
        float mxy = tx12-tx11;
        float myy = ty12-ty11;
//        assert(Math.abs(mxx - (tx22-tx12)) &lt; .000001);
//        assert(Math.abs(myx - (ty22-ty12)) &lt; .000001);
//        assert(Math.abs(mxy - (tx22-tx21)) &lt; .000001);
//        assert(Math.abs(myy - (ty22-ty21)) &lt; .000001);
        setTransformG2D(J2D_IDENTITY);
        tmpAT.setTransform(mxx, myx, mxy, myy, tx11, ty11);
        try {
            tmpAT.invert();
            g2d.translate(dx1, dy1);
            g2d.scale(dx2-dx1, dy2-dy1);
            g2d.transform(tmpAT);
            g2d.drawImage(img, 0, 0, 1, 1, null);
        } catch (NoninvertibleTransformException e) {
        }
        setTransform(transform);
    }

    public void drawTexture(Texture tex, float x, float y, float w, float h) {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        g2d.drawImage(img, (int) x, (int) y, (int) (x+w), (int) (y+h), 0, 0, (int)w, (int) h, null);
    }

    public void drawTexture(Texture tex,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2)
    {
        java.awt.Image img = ((J2DTexture) tex).getBufferedImage();
        // Simply casting the subimage coordinates to integers does not
        // produce the same behavior as the Prism hw pipelines (see RT-19270).
        g2d.drawImage(img,
                (int) dx1, (int) dy1, (int) dx2, (int) dy2,
                (int) sx1, (int) sy1, (int) sx2, (int) sy2,
                null);
    }

    @Override
    public void drawTexture3SliceH(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dh1, float dh2, float sh1, float sh2)
    {
        // Workaround for problems in NGRegion which may pass zero-width
        // source image area.
        if (sh1 + 0.1f &gt; sh2) sh2 += 1;
        drawTexture(tex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
        drawTexture(tex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
        drawTexture(tex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
    }

    @Override
    public void drawTexture3SliceV(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dv1, float dv2, float sv1, float sv2)
    {
        // Workaround for problems in NGRegion which may pass zero-height
        // source image area.
        if (sv1 +0.1f &gt; sv2) sv2 += 1;
        drawTexture(tex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
        drawTexture(tex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
        drawTexture(tex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
    }

    @Override
    public void drawTexture9Slice(Texture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2,
                                  float dh1, float dv1, float dh2, float dv2,
                                  float sh1, float sv1, float sh2, float sv2)
    {
        // Workaround for problems in NGRegion which may pass zero-width
        // or zero height source image area.
        if (sh1 + 0.1f &gt; sh2) sh2 += 1;
        if (sv1 + 0.1f &gt; sv2) sv2 += 1;
        drawTexture(tex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
        drawTexture(tex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
        drawTexture(tex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);

        drawTexture(tex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
        drawTexture(tex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
        drawTexture(tex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);

        drawTexture(tex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
        drawTexture(tex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
        drawTexture(tex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
    }

    public void drawTextureRaw(Texture tex,
                               float dx1, float dy1, float dx2, float dy2,
                               float tx1, float ty1, float tx2, float ty2)
    {
        int w = tex.getContentWidth();
        int h = tex.getContentHeight();
        tx1 *= w;
        ty1 *= h;
        tx2 *= w;
        ty2 *= h;
        drawTexture(tex, dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
    }

    public void drawTextureVO(Texture tex,
                              float topopacity, float botopacity,
                              float dx1, float dy1, float dx2, float dy2,
                              float sx1, float sy1, float sx2, float sy2)
    {
        // assert(caller is PrReflectionPeer and buffer is cleared to transparent)
        // NOTE: the assert conditions are true because that is the only
        // place where this method is used (unless we subclass BaseGraphics),
        // but there is no code here to verify that information.
        // The workarounds to do this for the general case would cost a lot
        // because they would involve creating a temporary intermediate buffer,
        // doing the operations below into the buffer, and then applying the
        // buffer to the destination.  That is not hard, but it costs a lot
        // of buffer allocation (or caching) when it is not really necessary
        // given the way this method is called currently.
        // Note that isoEdgeMask is ignored here, but since this is only ever
        // called by PrReflectionPeer and that code always uses ISOLATE_NONE
        // then we would only need to support ISOLATE_NONE.  The code below
        // does not yet verify if the results will be compatible with
        // ISOLATE_NONE, but given that the source coordinates are rounded to
        // integers in drawTexture() there is not much it can do to get exact
        // edge condition behavior until that deficiency is fixed (see
        // RT-19270 and RT-19271).
        java.awt.Paint savepaint = g2d.getPaint();
        java.awt.Composite savecomp = g2d.getComposite();
        java.awt.Color c1 = new java.awt.Color(1f, 1f, 1f, topopacity);
        java.awt.Color c2 = new java.awt.Color(1f, 1f, 1f, botopacity);
        g2d.setPaint(new java.awt.GradientPaint(0f, dy1, c1, 0f, dy2, c2, true));
        g2d.setComposite(java.awt.AlphaComposite.Src);
        int x = (int) Math.floor(Math.min(dx1, dx2));
        int y = (int) Math.floor(Math.min(dy1, dy2));
        int w = (int) Math.ceil(Math.max(dx1, dx2)) - x;
        int h = (int) Math.ceil(Math.max(dy1, dy2)) - y;
        g2d.fillRect(x, y, w, h);
        g2d.setComposite(java.awt.AlphaComposite.SrcIn);
        drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        g2d.setComposite(savecomp);
        g2d.setPaint(savepaint);
    }

    public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
                                 int dx, int dy, int dw, int dh,
                                 int ix, int iy, int mx, int my)
    {
        doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
                          dx, dy, dw, dh,
                          ix, iy, mx, my,
                          true);
    }

    public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex, int dx,
                                      int dy, int dw, int dh, int ix, int iy,
                                      int mx, int my) {
        doDrawMaskTexture((J2DRTTexture) imgtex, (J2DRTTexture) masktex,
                          dx, dy, dw, dh,
                          ix, iy, mx, my,
                          false);
    }

    private void doDrawMaskTexture(J2DRTTexture imgtex, J2DRTTexture masktex,
                                   int dx, int dy, int dw, int dh,
                                   int ix, int iy, int mx, int my,
                                   boolean srcover)
    {
        int cx0 = clipRect.x;
        int cy0 = clipRect.y;
        int cx1 = cx0 + clipRect.width;
        int cy1 = cy0 + clipRect.height;

        if (dw &lt;= 0 || dh &lt;= 0) return;
        if (dx &lt; cx0) {
            int bump = cx0 - dx;
            if ((dw -= bump) &lt;= 0) return;
            ix += bump;
            mx += bump;
            dx = cx0;
        }
        if (dy &lt; cy0) {
            int bump = cy0 - dy;
            if ((dh -= bump) &lt;= 0) return;
            iy += bump;
            my += bump;
            dy = cy0;
        }
        if (dx + dw &gt; cx1 &amp;&amp; (dw = cx1 - dx) &lt;= 0) return;
        if (dy + dh &gt; cy1 &amp;&amp; (dh = cy1 - dy) &lt;= 0) return;

        int iw = imgtex.getContentWidth();
        int ih = imgtex.getContentHeight();
        if (ix &lt; 0) {
            if ((dw += ix) &lt;= 0) return;
            dx -= ix;
            mx -= ix;
            ix = 0;
        }
        if (iy &lt; 0) {
            if ((dh += iy) &lt;= 0) return;
            dy -= iy;
            my -= iy;
            iy = 0;
        }
        if (ix + dw &gt; iw &amp;&amp; (dw = iw - ix) &lt;= 0) return;
        if (iy + dh &gt; ih &amp;&amp; (dh = ih - iy) &lt;= 0) return;

        int mw = masktex.getContentWidth();
        int mh = masktex.getContentHeight();
        if (mx &lt; 0) {
            if ((dw += mx) &lt;= 0) return;
            dx -= mx;
            ix -= mx;
            mx = 0;
        }
        if (my &lt; 0) {
            if ((dh += my) &lt;= 0) return;
            dy -= my;
            iy -= my;
            my = 0;
        }
        if (mx + dw &gt; mw &amp;&amp; (dw = mw - mx) &lt;= 0) return;
        if (my + dh &gt; mh &amp;&amp; (dh = mh - my) &lt;= 0) return;

        int imgbuf[] = imgtex.getPixels();
        int maskbuf[] = masktex.getPixels();
        java.awt.image.DataBuffer db = target.getBackBuffer().getRaster().getDataBuffer();
        int dstbuf[] = ((java.awt.image.DataBufferInt) db).getData();
        int iscan = imgtex.getBufferedImage().getWidth();
        int mscan = masktex.getBufferedImage().getWidth();
        int dscan = target.getBackBuffer().getWidth();
        int ioff = iy * iscan + ix;
        int moff = my * mscan + mx;
        int doff = dy * dscan + dx;
        if (srcover) {
            for (int y = 0; y &lt; dh; y++) {
                for (int x = 0; x &lt; dw; x++) {
                    int a, r, g, b;
                    int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
                    if (maskalpha == 0) continue;
                    int imgpix = imgbuf[ioff+x];
                    a = (imgpix &gt;&gt;&gt; 24);
                    if (a == 0) continue;
                    if (maskalpha &lt; 0xff) {
                        maskalpha += (maskalpha &gt;&gt; 7);
                        a *= maskalpha;
                        r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
                        g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
                        b = ((imgpix       ) &amp; 0xff) * maskalpha;
                    } else if (a &lt; 0xff) {
                        a &lt;&lt;= 8;
                        r = ((imgpix &gt;&gt;  16) &amp; 0xff) &lt;&lt; 8;
                        g = ((imgpix &gt;&gt;   8) &amp; 0xff) &lt;&lt; 8;
                        b = ((imgpix       ) &amp; 0xff) &lt;&lt; 8;
                    } else {
                        dstbuf[doff+x] = imgpix;
                        continue;
                    }
                    maskalpha = ((a + 128) &gt;&gt; 8);
                    maskalpha += (maskalpha &gt;&gt; 7);
                    maskalpha = 256 - maskalpha;
                    imgpix = dstbuf[doff+x];
                    a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
                    r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
                    g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
                    b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
                    imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
                             ((r &gt;&gt; 8) &lt;&lt; 16) +
                             ((g &gt;&gt; 8) &lt;&lt;  8) +
                             ((b &gt;&gt; 8)      );
                    dstbuf[doff+x] = imgpix;
                }
                ioff += iscan;
                moff += mscan;
                doff += dscan;
            }
        } else {
            for (int y = 0; y &lt; dh; y++) {
                for (int x = 0; x &lt; dw; x++) {
                    int maskalpha = maskbuf[moff+x] &gt;&gt;&gt; 24;
                    if (maskalpha == 0) continue;
                    int imgpix = imgbuf[ioff+x];
                    if (maskalpha &lt; 0xff) {
                        maskalpha += (maskalpha &gt;&gt; 7);
                        int a = ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha;
                        int r = ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha;
                        int g = ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha;
                        int b = ((imgpix       ) &amp; 0xff) * maskalpha;
                        maskalpha = 256 - maskalpha;
                        imgpix = dstbuf[doff+x];
                        a += ((imgpix &gt;&gt;&gt; 24)       ) * maskalpha + 128;
                        r += ((imgpix &gt;&gt;  16) &amp; 0xff) * maskalpha + 128;
                        g += ((imgpix &gt;&gt;   8) &amp; 0xff) * maskalpha + 128;
                        b += ((imgpix       ) &amp; 0xff) * maskalpha + 128;
                        imgpix = ((a &gt;&gt; 8) &lt;&lt; 24) +
                                 ((r &gt;&gt; 8) &lt;&lt; 16) +
                                 ((g &gt;&gt; 8) &lt;&lt;  8) +
                                 ((b &gt;&gt; 8)      );
                    }
                    dstbuf[doff+x] = imgpix;
                }
                ioff += iscan;
                moff += mscan;
                doff += dscan;
            }
        }
    }

    public boolean canReadBack() {
        return true;
    }

    public RTTexture readBack(Rectangle view) {
        J2DRTTexture rtt = target.getReadbackBuffer();
        java.awt.Graphics2D rttg2d = rtt.createAWTGraphics2D();
        rttg2d.setComposite(java.awt.AlphaComposite.Src);
        int x0 = view.x;
        int y0 = view.y;
        int w = view.width;
        int h = view.height;
        int x1 = x0 + w;
        int y1 = y0 + h;
        rttg2d.drawImage(target.getBackBuffer(),
                          0,  0,  w,  h,
                         x0, y0, x1, y1, null);
        rttg2d.dispose();
        return rtt;
    }

    public void releaseReadBackBuffer(RTTexture view) {
        // This will be needed when we track LCD buffer locks and uses.
        // (See RT-29488)
//        target.getReadbackBuffer().unlock();
    }

    public NGCamera getCameraNoClone() {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setPerspectiveTransform(GeneralTransform3D transform) {
    }


    public boolean isDepthBuffer() {
        return false;
    }

    public boolean isDepthTest() {
        return false;
    }

    public boolean isAlphaTestShader() {
        if (PrismSettings.verbose &amp;&amp; PrismSettings.forceAlphaTestShader) {
            System.out.println(&quot;J2D pipe doesn't support shader with alpha testing&quot;);
        }
        return false;
    }

    public void setAntialiasedShape(boolean aa) {
        antialiasedShape = aa;
        g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                antialiasedShape ? java.awt.RenderingHints.VALUE_ANTIALIAS_ON
                        : java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
    }

    public boolean isAntialiasedShape() {
        return antialiasedShape;
    }

    public void scale(float sx, float sy, float sz) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setTransform3D(double mxx, double mxy, double mxz, double mxt,
                               double myx, double myy, double myz, double myt,
                               double mzx, double mzy, double mzz, double mzt)
    {
        if (mxz != 0.0 || myz != 0.0 ||
            mzx != 0.0 || mzy != 0.0 || mzz != 1.0 || mzt != 0.0)
        {
            throw new UnsupportedOperationException(&quot;3D transforms not supported.&quot;);
        }
        setTransform(mxx, myx, mxy, myy, mxt, myt);
    }

    public void setCamera(NGCamera camera) {
        // No-op until we support 3D
        /*
        if (!(camera instanceof PrismParallelCameraImpl)) {

            throw new UnsupportedOperationException(camera+&quot; not supported.&quot;);
        }
        */
    }

    public void setDepthBuffer(boolean depthBuffer) {
        // No-op until we support 3D
    }

    public void setDepthTest(boolean depthTest) {
        // No-op until we support 3D
    }

    public void sync() {
    }

    public void translate(float tx, float ty, float tz) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    public void setCulling(boolean cull) {
        this.cull = cull;
    }

    public boolean isCulling() {
        return this.cull;
    }

 public void setClipRectIndex(int index) {
        this.clipRectIndex = index;
    }
    public int getClipRectIndex() {
        return this.clipRectIndex;
    }

    public void setHasPreCullingBits(boolean hasBits) {
        this.hasPreCullingBits = hasBits;
    }

    public boolean hasPreCullingBits() {
        return hasPreCullingBits;
    }

    private NodePath renderRoot;
    @Override
    public void setRenderRoot(NodePath root) {
        this.renderRoot = root;
    }

    @Override
    public NodePath getRenderRoot() {
        return renderRoot;
    }

    public void setState3D(boolean flag) {
    }

    public boolean isState3D() {
        return false;
    }

    public void setup3DRendering() {
    }

    @Override
    public void setPixelScaleFactors(float pixelScaleX, float pixelScaleY) {
        this.pixelScaleX = pixelScaleX;
        this.pixelScaleY = pixelScaleY;
    }

    @Override
    public float getPixelScaleFactorX() {
        return pixelScaleX;
    }

    @Override
    public float getPixelScaleFactorY() {
        return pixelScaleY;
    }

    @Override
    public void blit(RTTexture srcTex, RTTexture dstTex,
            int srcX0, int srcY0, int srcX1, int srcY1,
            int dstX0, int dstY0, int dstX1, int dstY1) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    private static class AdaptorShape implements java.awt.Shape {
        private Shape prshape;

        public void setShape(Shape prshape) {
            this.prshape = prshape;
        }

        public boolean contains(double x, double y) {
            return prshape.contains((float) x, (float) y);
        }

        public boolean contains(java.awt.geom.Point2D p) {
            return contains(p.getX(), p.getY());
        }

        public boolean contains(double x, double y, double w, double h) {
            return prshape.contains((float) x, (float) y, (float) w, (float) h);
        }

        public boolean contains(java.awt.geom.Rectangle2D r) {
            return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
        }

        public boolean intersects(double x, double y, double w, double h) {
            return prshape.intersects((float) x, (float) y, (float) w, (float) h);
        }

        public boolean intersects(java.awt.geom.Rectangle2D r) {
            return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
        }

        public java.awt.Rectangle getBounds() {
            return getBounds2D().getBounds();
        }

        public java.awt.geom.Rectangle2D getBounds2D() {
            RectBounds b = prshape.getBounds();
            java.awt.geom.Rectangle2D r2d =
                new java.awt.geom.Rectangle2D.Float();
            r2d.setFrameFromDiagonal(b.getMinX(), b.getMinY(), b.getMaxX(), b.getMaxY());
            return r2d;
        }

        private static AdaptorPathIterator tmpAdaptor =
                new AdaptorPathIterator();
        private static java.awt.geom.PathIterator tmpAdaptor(PathIterator pi) {
            tmpAdaptor.setIterator(pi);
            return tmpAdaptor;
        }

        public java.awt.geom.PathIterator
            getPathIterator(java.awt.geom.AffineTransform at)
        {
            BaseTransform tx = (at == null) ? null : toPrTransform(at);
            return tmpAdaptor(prshape.getPathIterator(tx));
        }

        public java.awt.geom.PathIterator
            getPathIterator(java.awt.geom.AffineTransform at,
                            double flatness)
        {
            BaseTransform tx = (at == null) ? null : toPrTransform(at);
            return tmpAdaptor(prshape.getPathIterator(tx, (float) flatness));
        }
    }

    private static class AdaptorPathIterator
        implements java.awt.geom.PathIterator
    {
        private static int NUM_COORDS[] = { 2, 2, 4, 6, 0 };
        PathIterator priterator;
        float tmpcoords[];

        public void setIterator(PathIterator priterator) {
            this.priterator = priterator;
        }

        public int currentSegment(float[] coords) {
            return priterator.currentSegment(coords);
        }

        public int currentSegment(double[] coords) {
            if (tmpcoords == null) {
                tmpcoords = new float[6];
            }
            int ret = priterator.currentSegment(tmpcoords);
            for (int i = 0; i &lt; NUM_COORDS[ret]; i++) {
                coords[i] = (double) tmpcoords[i];
            }
            return ret;
        }

        public int getWindingRule() {
            return priterator.getWindingRule();
        }

        public boolean isDone() {
            return priterator.isDone();
        }

        public void next() {
            priterator.next();
        }
    }

    static abstract class FilterStroke implements java.awt.Stroke {
        protected java.awt.BasicStroke stroke;

        FilterStroke(java.awt.BasicStroke stroke) {
            this.stroke = stroke;
        }

        abstract protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r);
        abstract protected java.awt.Shape makeStrokedShape(java.awt.Shape s);

        public java.awt.Shape createStrokedShape(java.awt.Shape p) {
            if (p instanceof java.awt.geom.Rectangle2D) {
                java.awt.Shape s = makeStrokedRect((java.awt.geom.Rectangle2D) p);
                if (s != null) {
                    return s;
                }
            }
            return makeStrokedShape(p);
        }

        // ArcIterator.btan(Math.PI/2)
        static final double CtrlVal = 0.5522847498307933;

        static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
                                                      float x0, float y0,
                                                      float xc, float yc,
                                                      float x1, float y1)
        {
            return cornerArc(gp, x0, y0, xc, yc, x1, y1, 0.5f);
        }

        static java.awt.geom.Point2D cornerArc(java.awt.geom.GeneralPath gp,
                                                      float x0, float y0,
                                                      float xc, float yc,
                                                      float x1, float y1, float t)
        {
            float xc0 = (float) (x0 + CtrlVal * (xc - x0));
            float yc0 = (float) (y0 + CtrlVal * (yc - y0));
            float xc1 = (float) (x1 + CtrlVal * (xc - x1));
            float yc1 = (float) (y1 + CtrlVal * (yc - y1));
            gp.curveTo(xc0, yc0, xc1, yc1, x1, y1);

            return new java.awt.geom.Point2D.Float(eval(x0, xc0, xc1, x1, t),
                                                   eval(y0, yc0, yc1, y1, t));
        }

        static float eval(float c0, float c1, float c2, float c3, float t) {
            c0 = c0 + (c1-c0) * t;
            c1 = c1 + (c2-c1) * t;
            c2 = c2 + (c3-c2) * t;
            c0 = c0 + (c1-c0) * t;
            c1 = c1 + (c2-c1) * t;
            return c0 + (c1-c0) * t;
        }
    }

    static class InnerStroke extends FilterStroke {
        InnerStroke(java.awt.BasicStroke stroke) {
            super(stroke);
        }

        protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            if (pad &gt;= r.getWidth() || pad &gt;= r.getHeight()) {
                return r;
            }
            float rx0 = (float) r.getX();
            float ry0 = (float) r.getY();
            float rx1 = rx0 + (float) r.getWidth();
            float ry1 = ry0 + (float) r.getHeight();
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx1, ry0);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx0, ry1);
            gp.closePath();
            rx0 += pad;
            ry0 += pad;
            rx1 -= pad;
            ry1 -= pad;
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx0, ry1);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx1, ry0);
            gp.closePath();
            return gp;
        }

        // NOTE: This is a work in progress, not used yet
        protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float w = (float) e.getWidth();
            float h = (float) e.getHeight();
            if (w - 2*pad &gt; h * 2 || h - 2*pad &gt; w * 2) {
                // If the inner ellipse is too &quot;squashed&quot; then we can not
                // approximate it with just a single cubic per quadrant.
                // NOTE: measure so we can relax this restriction and
                // also consider modifying the code below to insert
                // more cubics in those cases.
                return null;
            }
            if (pad &gt;= w || pad &gt;= h) {
                return e;
            }
            float x0 = (float) e.getX();
            float y0 = (float) e.getY();
            float xc = x0 + w / 2f;
            float yc = y0 + h / 2f;
            float x1 = x0 + w;
            float y1 = y0 + h;
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x1, y0, x1, yc);
            cornerArc(gp, x1, yc, x1, y1, xc, y1);
            cornerArc(gp, xc, y1, x0, y1, x0, yc);
            cornerArc(gp, x0, yc, x0, y0, xc, y0);
            gp.closePath();
            x0 += pad;
            y0 += pad;
            x1 -= pad;
            y1 -= pad;
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x0, y0, x0, yc);
            cornerArc(gp, x0, yc, x0, y1, xc, y1);
            cornerArc(gp, xc, y1, x1, y1, x1, yc);
            cornerArc(gp, x1, yc, x1, y0, xc, y0);
            gp.closePath();
            return gp;
        }

        @Override
        protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
            java.awt.Shape ss = stroke.createStrokedShape(s);
            java.awt.geom.Area b = new java.awt.geom.Area(ss);
            b.intersect(new java.awt.geom.Area(s));
            return b;
        }
    }

    static class OuterStroke extends FilterStroke {
        static double SQRT_2 = Math.sqrt(2);

        OuterStroke(java.awt.BasicStroke stroke) {
            super(stroke);
        }

        protected java.awt.Shape makeStrokedRect(java.awt.geom.Rectangle2D r) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float rx0 = (float) r.getX();
            float ry0 = (float) r.getY();
            float rx1 = rx0 + (float) r.getWidth();
            float ry1 = ry0 + (float) r.getHeight();
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            // clockwise
            gp.moveTo(rx0, ry0);
            gp.lineTo(rx1, ry0);
            gp.lineTo(rx1, ry1);
            gp.lineTo(rx0, ry1);
            gp.closePath();
            float ox0 = rx0 - pad;
            float oy0 = ry0 - pad;
            float ox1 = rx1 + pad;
            float oy1 = ry1 + pad;
            switch (stroke.getLineJoin()) {
            case BasicStroke.JOIN_MITER:
                // A miter limit of less than sqrt(2) bevels right angles...
                if (stroke.getMiterLimit() &gt;= SQRT_2) {
                    // counter-clockwise
                    gp.moveTo(ox0, oy0);
                    gp.lineTo(ox0, oy1);
                    gp.lineTo(ox1, oy1);
                    gp.lineTo(ox1, oy0);
                    gp.closePath();
                    break;
                }
                // NO BREAK
            case BasicStroke.JOIN_BEVEL:
                // counter-clockwise
                gp.moveTo(ox0, ry0);
                gp.lineTo(ox0, ry1);  // left edge
                gp.lineTo(rx0, oy1);  // ll corner
                gp.lineTo(rx1, oy1);  // bottom edge
                gp.lineTo(ox1, ry1);  // lr corner
                gp.lineTo(ox1, ry0);  // right edge
                gp.lineTo(rx1, oy0);  // ur corner
                gp.lineTo(rx0, oy0);  // top edge
                gp.closePath();       // ul corner
                break;
            case BasicStroke.JOIN_ROUND:
                // counter-clockwise
                gp.moveTo(ox0, ry0);
                gp.lineTo(ox0, ry1);                          // left edge
                cornerArc(gp, ox0, ry1, ox0, oy1, rx0, oy1);  // ll corner
                gp.lineTo(rx1, oy1);                          // bottom edge
                cornerArc(gp, rx1, oy1, ox1, oy1, ox1, ry1);  // lr corner
                gp.lineTo(ox1, ry0);                          // right edge
                cornerArc(gp, ox1, ry0, ox1, oy0, rx1, oy0);  // ur corner
                gp.lineTo(rx0, oy0);                          // top edge
                cornerArc(gp, rx0, oy0, ox0, oy0, ox0, ry0);  // ul corner
                gp.closePath();
                break;
            default:
                throw new InternalError(&quot;Unrecognized line join style&quot;);
            }
            return gp;
        }

        // NOTE: This is a work in progress, not used yet
        protected java.awt.Shape makeStrokedEllipse(java.awt.geom.Ellipse2D e) {
            if (stroke.getDashArray() != null) {
                return null;
            }
            float pad = stroke.getLineWidth() / 2f;
            float w = (float) e.getWidth();
            float h = (float) e.getHeight();
            if (w &gt; h * 2 || h &gt; w * 2) {
                // If the inner ellipse is too &quot;squashed&quot; then we can not
                // approximate it with just a single cubic per quadrant.
                // NOTE: measure so we can relax this restriction and
                // also consider modifying the code below to insert
                // more cubics in those cases.
                return null;
            }
            float x0 = (float) e.getX();
            float y0 = (float) e.getY();
            float xc = x0 + w / 2f;
            float yc = y0 + h / 2f;
            float x1 = x0 + w;
            float y1 = y0 + h;
            java.awt.geom.GeneralPath gp = new java.awt.geom.GeneralPath();
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x1, y0, x1, yc);
            cornerArc(gp, x1, yc, x1, y1, xc, y1);
            cornerArc(gp, xc, y1, x0, y1, x0, yc);
            cornerArc(gp, x0, yc, x0, y0, xc, y0);
            gp.closePath();
            x0 -= pad;
            y0 -= pad;
            x1 += pad;
            y1 += pad;
            gp.moveTo(xc, y0);
            cornerArc(gp, xc, y0, x0, y0, x0, yc);
            cornerArc(gp, x0, yc, x0, y1, xc, y1);
            cornerArc(gp, xc, y1, x1, y1, x1, yc);
            cornerArc(gp, x1, yc, x1, y0, xc, y0);
            gp.closePath();
            return gp;
        }

        @Override
        protected java.awt.Shape makeStrokedShape(java.awt.Shape s) {
            java.awt.Shape ss = stroke.createStrokedShape(s);
            java.awt.geom.Area b = new java.awt.geom.Area(ss);
            b.subtract(new java.awt.geom.Area(s));
            return b;
        }
    }

    @Override
    public void setLights(NGLightBase[] lights) {
        // Light are not supported by J2d
    }

    @Override
    public NGLightBase[] getLights() {
        // Light are not supported by J2d
        return null;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/paint/MultipleGradientPaintContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d.paint;

import com.sun.prism.j2d.paint.MultipleGradientPaint.ColorSpaceType;
import com.sun.prism.j2d.paint.MultipleGradientPaint.CycleMethod;
import java.awt.Color;
import java.awt.PaintContext;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;
import java.awt.image.DataBufferInt;
import java.awt.image.DirectColorModel;
import java.awt.image.Raster;
import java.awt.image.SinglePixelPackedSampleModel;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;

/**
 * This is the superclass for all PaintContexts which use a multiple color
 * gradient to fill in their raster.  It provides the actual color
 * interpolation functionality.  Subclasses only have to deal with using
 * the gradient to fill pixels in a raster.
 */
abstract class MultipleGradientPaintContext implements PaintContext {

    /**
     * The PaintContext's ColorModel.  This is ARGB if colors are not all
     * opaque, otherwise it is RGB.
     */
    protected ColorModel model;

    /** Color model used if gradient colors are all opaque. */
    private static ColorModel xrgbmodel =
        new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff);

    /** The cached ColorModel. */
    protected static ColorModel cachedModel;

    /** The cached raster, which is reusable among instances. */
    protected static WeakReference&lt;Raster&gt; cached;

    /** Raster is reused whenever possible. */
    protected Raster saved;

    /** The method to use when painting out of the gradient bounds. */
    protected CycleMethod cycleMethod;

    /** The ColorSpace in which to perform the interpolation */
    protected ColorSpaceType colorSpace;

    /** Elements of the inverse transform matrix. */
    protected float a00, a01, a10, a11, a02, a12;

    /**
     * This boolean specifies whether we are in simple lookup mode, where an
     * input value between 0 and 1 may be used to directly index into a single
     * array of gradient colors.  If this boolean value is false, then we have
     * to use a 2-step process where we have to determine which gradient array
     * we fall into, then determine the index into that array.
     */
    protected boolean isSimpleLookup;

    /**
     * Size of gradients array for scaling the 0-1 index when looking up
     * colors the fast way.
     */
    protected int fastGradientArraySize;

    /**
     * Array which contains the interpolated color values for each interval,
     * used by calculateSingleArrayGradient().  It is protected for possible
     * direct access by subclasses.
     */
    protected int[] gradient;

    /**
     * Array of gradient arrays, one array for each interval.  Used by
     * calculateMultipleArrayGradient().
     */
    private int[][] gradients;

    /** Normalized intervals array. */
    private float[] normalizedIntervals;

    /** Fractions array. */
    private float[] fractions;

    /** Used to determine if gradient colors are all opaque. */
    private int transparencyTest;

    /** Color space conversion lookup tables. */
    private static final int SRGBtoLinearRGB[] = new int[256];
    private static final int LinearRGBtoSRGB[] = new int[256];

    static {
        // build the tables
        for (int k = 0; k &lt; 256; k++) {
            SRGBtoLinearRGB[k] = convertSRGBtoLinearRGB(k);
            LinearRGBtoSRGB[k] = convertLinearRGBtoSRGB(k);
        }
    }

    /**
     * Constant number of max colors between any 2 arbitrary colors.
     * Used for creating and indexing gradients arrays.
     */
    protected static final int GRADIENT_SIZE = 256;
    protected static final int GRADIENT_SIZE_INDEX = GRADIENT_SIZE -1;

    /**
     * Maximum length of the fast single-array.  If the estimated array size
     * is greater than this, switch over to the slow lookup method.
     * No particular reason for choosing this number, but it seems to provide
     * satisfactory performance for the common case (fast lookup).
     */
    private static final int MAX_GRADIENT_ARRAY_SIZE = 5000;

    /**
     * Constructor for MultipleGradientPaintContext superclass.
     */
    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,
                                           ColorModel cm,
                                           Rectangle deviceBounds,
                                           Rectangle2D userBounds,
                                           AffineTransform t,
                                           RenderingHints hints,
                                           float[] fractions,
                                           Color[] colors,
                                           CycleMethod cycleMethod,
                                           ColorSpaceType colorSpace)
    {
        if (deviceBounds == null) {
            throw new NullPointerException(&quot;Device bounds cannot be null&quot;);
        }

        if (userBounds == null) {
            throw new NullPointerException(&quot;User bounds cannot be null&quot;);
        }

        if (t == null) {
            throw new NullPointerException(&quot;Transform cannot be null&quot;);
        }

<A NAME="1"></A>        // The inverse transform is needed to go from device to user space.
        // Get all the components of the inverse transform matrix.
        AffineTransform tInv;
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#1',2,'match44-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
            // the following assumes that the caller has copied the incoming
            // transform and is not concerned about it being modified
            tInv = t.createInverse();
        } catch (NoninvertibleTransformException e) {
            // just use identity transform in this case; better to show
            // (incorrect) results than to throw an exception and/or no-op
            tInv = new AffineTransform();
        }</B></FONT>
        double m[] = new double[6];
        tInv.getMatrix(m);
        a00 = (float)m[0];
        a10 = (float)m[1];
        a01 = (float)m[2];
        a11 = (float)m[3];
        a02 = (float)m[4];
        a12 = (float)m[5];

        // copy some flags
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;

        // we can avoid copying this array since we do not modify its values
        this.fractions = fractions;

        // note that only one of these values can ever be non-null (we either
        // store the fast gradient array or the slow one, but never both
        // at the same time)
        this.gradient =
            (mgp.gradient != null) ? mgp.gradient.get() : null;
        this.gradients =
            (mgp.gradients != null) ? mgp.gradients.get() : null;

        if (gradient == null &amp;&amp; gradients == null) {
            // we need to (re)create the appropriate values
            calculateLookupData(colors);

            // now cache the calculated values in the
            // MultipleGradientPaint instance for future use
            mgp.model               = this.model;
            mgp.normalizedIntervals = this.normalizedIntervals;
            mgp.isSimpleLookup      = this.isSimpleLookup;
            if (isSimpleLookup) {
                // only cache the fast array
                mgp.fastGradientArraySize = this.fastGradientArraySize;
                mgp.gradient = new SoftReference&lt;int[]&gt;(this.gradient);
            } else {
                // only cache the slow array
                mgp.gradients = new SoftReference&lt;int[][]&gt;(this.gradients);
            }
        } else {
            // use the values cached in the MultipleGradientPaint instance
            this.model                 = mgp.model;
            this.normalizedIntervals   = mgp.normalizedIntervals;
            this.isSimpleLookup        = mgp.isSimpleLookup;
            this.fastGradientArraySize = mgp.fastGradientArraySize;
        }
    }

    /**
     * This function is the meat of this class.  It calculates an array of
     * gradient colors based on an array of fractions and color values at
     * those fractions.
     */
    private void calculateLookupData(Color[] colors) {
        Color[] normalizedColors;
        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
            // create a new colors array
            normalizedColors = new Color[colors.length];
            // convert the colors using the lookup table
            for (int i = 0; i &lt; colors.length; i++) {
                int argb = colors[i].getRGB();
                int a = argb &gt;&gt;&gt; 24;
                int r = SRGBtoLinearRGB[(argb &gt;&gt; 16) &amp; 0xff];
                int g = SRGBtoLinearRGB[(argb &gt;&gt;  8) &amp; 0xff];
                int b = SRGBtoLinearRGB[(argb      ) &amp; 0xff];
                normalizedColors[i] = new Color(r, g, b, a);
            }
        } else {
            // we can just use this array by reference since we do not
            // modify its values in the case of SRGB
            normalizedColors = colors;
        }

        // this will store the intervals (distances) between gradient stops
        normalizedIntervals = new float[fractions.length-1];

        // convert from fractions into intervals
        for (int i = 0; i &lt; normalizedIntervals.length; i++) {
            // interval distance is equal to the difference in positions
            normalizedIntervals[i] = this.fractions[i+1] - this.fractions[i];
        }

        // initialize to be fully opaque for ANDing with colors
        transparencyTest = 0xff000000;

        // array of interpolation arrays
        gradients = new int[normalizedIntervals.length][];

        // find smallest interval
        float Imin = 1;
        for (int i = 0; i &lt; normalizedIntervals.length; i++) {
            Imin = (Imin &gt; normalizedIntervals[i]) ?
                normalizedIntervals[i] : Imin;
        }

        // Estimate the size of the entire gradients array.
        // This is to prevent a tiny interval from causing the size of array
        // to explode.  If the estimated size is too large, break to using
        // separate arrays for each interval, and using an indexing scheme at
        // look-up time.
        int estimatedSize = 0;
        for (int i = 0; i &lt; normalizedIntervals.length; i++) {
            estimatedSize += (normalizedIntervals[i]/Imin) * GRADIENT_SIZE;
        }

        if (estimatedSize &gt; MAX_GRADIENT_ARRAY_SIZE) {
            // slow method
            calculateMultipleArrayGradient(normalizedColors);
        } else {
            // fast method
            calculateSingleArrayGradient(normalizedColors, Imin);
        }

        // use the most &quot;economical&quot; model
        if ((transparencyTest &gt;&gt;&gt; 24) == 0xff) {
            model = xrgbmodel;
        } else {
            model = ColorModel.getRGBdefault();
        }
    }

    /**
     * FAST LOOKUP METHOD
     *
     * This method calculates the gradient color values and places them in a
     * single int array, gradient[].  It does this by allocating space for
     * each interval based on its size relative to the smallest interval in
     * the array.  The smallest interval is allocated 255 interpolated values
     * (the maximum number of unique in-between colors in a 24 bit color
     * system), and all other intervals are allocated
     * size = (255 * the ratio of their size to the smallest interval).
     *
     * This scheme expedites a speedy retrieval because the colors are
     * distributed along the array according to their user-specified
     * distribution.  All that is needed is a relative index from 0 to 1.
     *
     * The only problem with this method is that the possibility exists for
     * the array size to balloon in the case where there is a
     * disproportionately small gradient interval.  In this case the other
     * intervals will be allocated huge space, but much of that data is
     * redundant.  We thus need to use the space conserving scheme below.
     *
     * @param Imin the size of the smallest interval
     */
    private void calculateSingleArrayGradient(Color[] colors, float Imin) {
        // set the flag so we know later it is a simple (fast) lookup
        isSimpleLookup = true;

        // 2 colors to interpolate
        int rgb1, rgb2;

        //the eventual size of the single array
        int gradientsTot = 1;

        // for every interval (transition between 2 colors)
        for (int i = 0; i &lt; gradients.length; i++) {
            // create an array whose size is based on the ratio to the
            // smallest interval
            int nGradients = (int)((normalizedIntervals[i]/Imin)*255f);
            gradientsTot += nGradients;
            gradients[i] = new int[nGradients];

            // the 2 colors (keyframes) to interpolate between
            rgb1 = colors[i].getRGB();
            rgb2 = colors[i+1].getRGB();

            // fill this array with the colors in between rgb1 and rgb2
            interpolate(rgb1, rgb2, gradients[i]);

            // if the colors are opaque, transparency should still
            // be 0xff000000
            transparencyTest &amp;= rgb1;
            transparencyTest &amp;= rgb2;
        }

        // put all gradients in a single array
        gradient = new int[gradientsTot];
        int curOffset = 0;
        for (int i = 0; i &lt; gradients.length; i++){
            System.arraycopy(gradients[i], 0, gradient,
                             curOffset, gradients[i].length);
            curOffset += gradients[i].length;
        }
        gradient[gradient.length-1] = colors[colors.length-1].getRGB();

        // if interpolation occurred in Linear RGB space, convert the
        // gradients back to sRGB using the lookup table
        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
            for (int i = 0; i &lt; gradient.length; i++) {
                gradient[i] = convertEntireColorLinearRGBtoSRGB(gradient[i]);
            }
        }

        fastGradientArraySize = gradient.length - 1;
    }

    /**
     * SLOW LOOKUP METHOD
     *
     * This method calculates the gradient color values for each interval and
     * places each into its own 255 size array.  The arrays are stored in
     * gradients[][].  (255 is used because this is the maximum number of
     * unique colors between 2 arbitrary colors in a 24 bit color system.)
     *
     * This method uses the minimum amount of space (only 255 * number of
     * intervals), but it aggravates the lookup procedure, because now we
     * have to find out which interval to select, then calculate the index
     * within that interval.  This causes a significant performance hit,
     * because it requires this calculation be done for every point in
     * the rendering loop.
     *
     * For those of you who are interested, this is a classic example of the
     * time-space tradeoff.
     */
    private void calculateMultipleArrayGradient(Color[] colors) {
        // set the flag so we know later it is a non-simple lookup
        isSimpleLookup = false;

        // 2 colors to interpolate
        int rgb1, rgb2;

        // for every interval (transition between 2 colors)
        for (int i = 0; i &lt; gradients.length; i++){
            // create an array of the maximum theoretical size for
            // each interval
            gradients[i] = new int[GRADIENT_SIZE];

            // get the the 2 colors
            rgb1 = colors[i].getRGB();
            rgb2 = colors[i+1].getRGB();

            // fill this array with the colors in between rgb1 and rgb2
            interpolate(rgb1, rgb2, gradients[i]);

            // if the colors are opaque, transparency should still
            // be 0xff000000
            transparencyTest &amp;= rgb1;
            transparencyTest &amp;= rgb2;
        }

        // if interpolation occurred in Linear RGB space, convert the
        // gradients back to SRGB using the lookup table
        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
            for (int j = 0; j &lt; gradients.length; j++) {
                for (int i = 0; i &lt; gradients[j].length; i++) {
                    gradients[j][i] =
                        convertEntireColorLinearRGBtoSRGB(gradients[j][i]);
                }
            }
        }
    }

    /**
     * Yet another helper function.  This one linearly interpolates between
     * 2 colors, filling up the output array.
     *
     * @param rgb1 the start color
     * @param rgb2 the end color
     * @param output the output array of colors; must not be null
     */
    private void interpolate(int rgb1, int rgb2, int[] output) {
        // color components
        int a1, r1, g1, b1, da, dr, dg, db;

        // step between interpolated values
        float stepSize = 1.0f / output.length;

        // extract color components from packed integer
        a1 = (rgb1 &gt;&gt; 24) &amp; 0xff;
        r1 = (rgb1 &gt;&gt; 16) &amp; 0xff;
        g1 = (rgb1 &gt;&gt;  8) &amp; 0xff;
        b1 = (rgb1      ) &amp; 0xff;

        // calculate the total change in alpha, red, green, blue
        da = ((rgb2 &gt;&gt; 24) &amp; 0xff) - a1;
        dr = ((rgb2 &gt;&gt; 16) &amp; 0xff) - r1;
        dg = ((rgb2 &gt;&gt;  8) &amp; 0xff) - g1;
        db = ((rgb2      ) &amp; 0xff) - b1;

        // for each step in the interval calculate the in-between color by
        // multiplying the normalized current position by the total color
        // change (0.5 is added to prevent truncation round-off error)
        for (int i = 0; i &lt; output.length; i++) {
            output[i] =
                (((int) ((a1 + i * da * stepSize) + 0.5) &lt;&lt; 24)) |
                (((int) ((r1 + i * dr * stepSize) + 0.5) &lt;&lt; 16)) |
                (((int) ((g1 + i * dg * stepSize) + 0.5) &lt;&lt;  8)) |
                (((int) ((b1 + i * db * stepSize) + 0.5)      ));
        }
    }

    /**
     * Yet another helper function.  This one extracts the color components
     * of an integer RGB triple, converts them from LinearRGB to SRGB, then
     * recompacts them into an int.
     */
    private int convertEntireColorLinearRGBtoSRGB(int rgb) {
        // color components
        int a1, r1, g1, b1;

        // extract red, green, blue components
        a1 = (rgb &gt;&gt; 24) &amp; 0xff;
        r1 = (rgb &gt;&gt; 16) &amp; 0xff;
        g1 = (rgb &gt;&gt;  8) &amp; 0xff;
        b1 = (rgb      ) &amp; 0xff;

        // use the lookup table
        r1 = LinearRGBtoSRGB[r1];
        g1 = LinearRGBtoSRGB[g1];
        b1 = LinearRGBtoSRGB[b1];

        // re-compact the components
        return ((a1 &lt;&lt; 24) |
                (r1 &lt;&lt; 16) |
                (g1 &lt;&lt;  8) |
                (b1      ));
    }

    /**
     * Helper function to index into the gradients array.  This is necessary
     * because each interval has an array of colors with uniform size 255.
     * However, the color intervals are not necessarily of uniform length, so
     * a conversion is required.
     *
     * @param position the unmanipulated position, which will be mapped
     *                 into the range 0 to 1
     * @returns integer color to display
     */
    protected final int indexIntoGradientsArrays(float position) {
        // first, manipulate position value depending on the cycle method
        if (cycleMethod == CycleMethod.NO_CYCLE) {
            if (position &gt; 1) {
                // upper bound is 1
                position = 1;
            } else if (position &lt; 0) {
                // lower bound is 0
                position = 0;
            }
        } else if (cycleMethod == CycleMethod.REPEAT) {
            // get the fractional part
            // (modulo behavior discards integer component)
            position = position - (int)position;

            //position should now be between -1 and 1
            if (position &lt; 0) {
                // force it to be in the range 0-1
                position = position + 1;
            }
        } else { // cycleMethod == CycleMethod.REFLECT
            if (position &lt; 0) {
                // take absolute value
                position = -position;
            }

            // get the integer part
            int part = (int)position;

            // get the fractional part
            position = position - part;

            if ((part &amp; 1) == 1) {
                // integer part is odd, get reflected color instead
                position = 1 - position;
            }
        }

        // now, get the color based on this 0-1 position...

        if (isSimpleLookup) {
            // easy to compute: just scale index by array size
            return gradient[(int)(position * fastGradientArraySize)];
        } else {
            // more complicated computation, to save space

            // for all the gradient interval arrays
            for (int i = 0; i &lt; gradients.length; i++) {
                if (position &lt; fractions[i+1]) {
                    // this is the array we want
                    float delta = position - fractions[i];

                    // this is the interval we want
                    int index = (int)((delta / normalizedIntervals[i])
                                      * (GRADIENT_SIZE_INDEX));

                    return gradients[i][index];
                }
            }
        }

        return gradients[gradients.length - 1][GRADIENT_SIZE_INDEX];
    }

    /**
     * Helper function to convert a color component in sRGB space to linear
     * RGB space.  Used to build a static lookup table.
     */
    private static int convertSRGBtoLinearRGB(int color) {
        float input, output;

        input = color / 255.0f;
        if (input &lt;= 0.04045f) {
            output = input / 12.92f;
        } else {
            output = (float)Math.pow((input + 0.055) / 1.055, 2.4);
        }

        return Math.round(output * 255.0f);
    }

    /**
     * Helper function to convert a color component in linear RGB space to
     * SRGB space.  Used to build a static lookup table.
     */
    private static int convertLinearRGBtoSRGB(int color) {
        float input, output;

        input = color/255.0f;
        if (input &lt;= 0.0031308) {
            output = input * 12.92f;
        } else {
            output = (1.055f *
                ((float) Math.pow(input, (1.0 / 2.4)))) - 0.055f;
        }

        return Math.round(output * 255.0f);
    }

    /**
     * {@inheritDoc}
     */
    public final Raster getRaster(int x, int y, int w, int h) {
        // If working raster is big enough, reuse it. Otherwise,
        // build a large enough new one.
        Raster raster = saved;
        if (raster == null ||
            raster.getWidth() &lt; w || raster.getHeight() &lt; h)
        {
            raster = getCachedRaster(model, w, h);
            saved = raster;
        }

        // Access raster internal int array. Because we use a DirectColorModel,
        // we know the DataBuffer is of type DataBufferInt and the SampleModel
        // is SinglePixelPackedSampleModel.
        // Adjust for initial offset in DataBuffer and also for the scanline
        // stride.
        // These calls make the DataBuffer non-acceleratable, but the
        // Raster is never Stable long enough to accelerate anyway...
        DataBufferInt rasterDB = (DataBufferInt)raster.getDataBuffer();
        int[] pixels = rasterDB.getData(0);
        int off = rasterDB.getOffset();
        int scanlineStride = ((SinglePixelPackedSampleModel)
                              raster.getSampleModel()).getScanlineStride();
        int adjust = scanlineStride - w;

        fillRaster(pixels, off, adjust, x, y, w, h); // delegate to subclass

        return raster;
    }

    protected abstract void fillRaster(int pixels[], int off, int adjust,
                                       int x, int y, int w, int h);


    /**
     * Took this cacheRaster code from GradientPaint. It appears to recycle
     * rasters for use by any other instance, as long as they are sufficiently
     * large.
     */
    private static synchronized Raster getCachedRaster(ColorModel cm,
                                                       int w, int h)
    {
        if (cm == cachedModel) {
            if (cached != null) {
                Raster ras = (Raster) cached.get();
                if (ras != null &amp;&amp;
                    ras.getWidth() &gt;= w &amp;&amp;
                    ras.getHeight() &gt;= h)
                {
                    cached = null;
                    return ras;
                }
            }
        }
        return cm.createCompatibleWritableRaster(w, h);
    }

    /**
     * Took this cacheRaster code from GradientPaint. It appears to recycle
     * rasters for use by any other instance, as long as they are sufficiently
     * large.
     */
    private static synchronized void putCachedRaster(ColorModel cm,
                                                     Raster ras)
    {
        if (cached != null) {
            Raster cras = (Raster) cached.get();
            if (cras != null) {
                int cw = cras.getWidth();
                int ch = cras.getHeight();
                int iw = ras.getWidth();
                int ih = ras.getHeight();
                if (cw &gt;= iw &amp;&amp; ch &gt;= ih) {
                    return;
                }
                if (cw * ch &gt;= iw * ih) {
                    return;
                }
            }
        }
        cachedModel = cm;
        cached = new WeakReference&lt;Raster&gt;(ras);
    }

    /**
     * {@inheritDoc}
     */
    public final void dispose() {
        if (saved != null) {
            putCachedRaster(model, saved);
            saved = null;
        }
    }

    /**
     * {@inheritDoc}
     */
    public final ColorModel getColorModel() {
        return model;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/sw/SWPaint.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.sw;

import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.pisces.GradientColorMap;
import com.sun.pisces.PiscesRenderer;
import com.sun.pisces.RendererBase;
import com.sun.pisces.Transform6;
import com.sun.prism.Image;
import com.sun.prism.PixelFormat;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.paint.Stop;

final class SWPaint {

    private final SWContext context;
<A NAME="24"></A>    private final PiscesRenderer pr;

    private final BaseTransform paintTx = new Affine2D();
    private final Transform6 piscesTx = <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#24',2,'match44-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Transform6();

    private float compositeAlpha = 1.0f;
    private float px, py, pw, ph;

    SWPaint(SWContext context, PiscesRenderer pr) {
        this.context = context;
        this.pr = pr;
    }

    float getComposit</B></FONT>eAlpha() {
        return compositeAlpha;
    }

    void setCompositeAlpha(float newValue) {
        compositeAlpha = newValue;
    }

    void setColor(Color c, float compositeAlpha) {
        if (PrismSettings.debug) {
            System.out.println(&quot;PR.setColor: &quot; + c);
        }
        this.pr.setColor((int) (c.getRed() * 255),
                (int) (255 * c.getGreen()),
                (int) (255 * c.getBlue()),
                (int) (255 * c.getAlpha() * compositeAlpha));
    }

    void setPaintFromShape(Paint p, BaseTransform tx, Shape shape, RectBounds nodeBounds,
                           float localX, float localY, float localWidth, float localHeight)
    {
        this.computePaintBounds(p, shape, nodeBounds, localX, localY, localWidth, localHeight);
        this.setPaintBeforeDraw(p, tx, px, py, pw, ph);
    }

    private void computePaintBounds(Paint p, Shape shape, RectBounds nodeBounds,
                                    float localX, float localY, float localWidth, float localHeight)
    {
        if (p.isProportional()) {
            if (nodeBounds != null) {
                px = nodeBounds.getMinX();
                py = nodeBounds.getMinY();
                pw = nodeBounds.getWidth();
                ph = nodeBounds.getHeight();
            } else if (shape != null) {
                final RectBounds bounds = shape.getBounds();
                px = bounds.getMinX();
                py = bounds.getMinY();
                pw = bounds.getWidth();
                ph = bounds.getHeight();
            } else {
                px = localX;
                py = localY;
                pw = localWidth;
                ph = localHeight;
            }
        } else {
            px = py = pw = ph = 0;
        }
    }

    void setPaintBeforeDraw(Paint p, BaseTransform tx, float x, float y, float width, float height) {
        switch (p.getType()) {
            case COLOR:
                this.setColor((Color)p, this.compositeAlpha);
                break;
            case LINEAR_GRADIENT:
                final LinearGradient lg = (LinearGradient)p;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setLinearGradient: &quot; + lg.getX1() + &quot;, &quot; + lg.getY1() + &quot;, &quot; + lg.getX2() + &quot;, &quot; + lg.getY2());
                }

                paintTx.setTransform(tx);
                SWUtils.convertToPiscesTransform(paintTx, piscesTx);

                float x1 = lg.getX1();
                float y1 = lg.getY1();
                float x2 = lg.getX2();
                float y2 = lg.getY2();
                if (lg.isProportional()) {
                    x1 = x + width * x1;
                    y1 = y + height * y1;
                    x2 = x + width * x2;
                    y2 = y + height * y2;
                }
                this.pr.setLinearGradient((int)(SWUtils.TO_PISCES * x1), (int)(SWUtils.TO_PISCES * y1),
                        (int)(SWUtils.TO_PISCES * x2), (int)(SWUtils.TO_PISCES * y2),
                        getFractions(lg), getARGB(lg, this.compositeAlpha), getPiscesGradientCycleMethod(lg.getSpreadMethod()), piscesTx);
                break;
            case RADIAL_GRADIENT:
                final RadialGradient rg = (RadialGradient)p;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setRadialGradient: &quot; + rg.getCenterX() + &quot;, &quot; + rg.getCenterY() + &quot;, &quot; + rg.getFocusAngle() + &quot;, &quot; + rg.getFocusDistance() + &quot;, &quot; + rg.getRadius());
                }

                paintTx.setTransform(tx);

                float cx = rg.getCenterX();
                float cy = rg.getCenterY();
                float r = rg.getRadius();
                if (rg.isProportional()) {
                    float dim = Math.min(width, height);
                    float bcx = x + width * 0.5f;
                    float bcy = y + height * 0.5f;
                    cx = bcx + (cx - 0.5f) * dim;
                    cy = bcy + (cy - 0.5f) * dim;
                    r *= dim;
                    if (width != height &amp;&amp; width != 0.0 &amp;&amp; height != 0.0) {
                        paintTx.deriveWithTranslation(bcx, bcy);
                        paintTx.deriveWithConcatenation(width / dim, 0, 0, height / dim, 0, 0);
                        paintTx.deriveWithTranslation(-bcx, -bcy);
                    }
                }
                SWUtils.convertToPiscesTransform(paintTx, piscesTx);

                final float fx = (float)(cx + rg.getFocusDistance() * r * Math.cos(Math.toRadians(rg.getFocusAngle())));
                final float fy = (float)(cy + rg.getFocusDistance() * r * Math.sin(Math.toRadians(rg.getFocusAngle())));

                this.pr.setRadialGradient((int) (SWUtils.TO_PISCES * cx), (int) (SWUtils.TO_PISCES * cy),
                        (int) (SWUtils.TO_PISCES * fx), (int) (SWUtils.TO_PISCES * fy), (int) (SWUtils.TO_PISCES * r),
                        getFractions(rg), getARGB(rg, this.compositeAlpha), getPiscesGradientCycleMethod(rg.getSpreadMethod()), piscesTx);
                break;
            case IMAGE_PATTERN:
                final ImagePattern ip = (ImagePattern)p;
                if (ip.getImage().getPixelFormat() == PixelFormat.BYTE_ALPHA) {
                    throw new UnsupportedOperationException(&quot;Alpha image is not supported as an image pattern.&quot;);
                } else {
                    this.computeImagePatternTransform(ip, tx, x, y, width, height);
                    final SWArgbPreTexture tex = context.validateImagePaintTexture(ip.getImage().getWidth(), ip.getImage().getHeight());
                    tex.update(ip.getImage());
                    if (this.compositeAlpha &lt; 1.0f) {
                        tex.applyCompositeAlpha(this.compositeAlpha);
                    }

                    this.pr.setTexture(RendererBase.TYPE_INT_ARGB_PRE, tex.getDataNoClone(),
                            tex.getContentWidth(), tex.getContentHeight(), tex.getPhysicalWidth(),
                            piscesTx,
                            tex.getWrapMode() == Texture.WrapMode.REPEAT,
                            tex.hasAlpha());
                }
                break;
            default:
                throw new IllegalArgumentException(&quot;Unknown paint type: &quot; + p.getType());
        }
    }

    private static int[] getARGB(Gradient grd, float compositeAlpha) {
        final int nstops = grd.getNumStops();
        final int argb[] = new int[nstops];
        for (int i = 0; i &lt; nstops; i++) {
            final Stop stop = grd.getStops().get(i);
            final Color stopColor = stop.getColor();
            float alpha255 = 255 * stopColor.getAlpha() * compositeAlpha;
            argb[i] = ((((int)(alpha255)) &amp; 0xFF) &lt;&lt; 24) +
                    ((((int)(alpha255 * stopColor.getRed())) &amp; 0xFF) &lt;&lt; 16) +
                    ((((int)(alpha255 * stopColor.getGreen())) &amp; 0xFF) &lt;&lt; 8) +
                    (((int)(alpha255 * stopColor.getBlue())) &amp; 0xFF);
        }
        return argb;
    }

    private static int[] getFractions(Gradient grd) {
        final int nstops = grd.getNumStops();
        final int fractions[] = new int[nstops];
        for (int i = 0; i &lt; nstops; i++) {
            final Stop stop = grd.getStops().get(i);
            fractions[i] = (int)(SWUtils.TO_PISCES * stop.getOffset());
        }
        return fractions;
    }

    private static int getPiscesGradientCycleMethod(final int prismCycleMethod) {
        switch (prismCycleMethod) {
            case Gradient.PAD:
                return GradientColorMap.CYCLE_NONE;
            case Gradient.REFLECT:
                return GradientColorMap.CYCLE_REFLECT;
            case Gradient.REPEAT:
                return GradientColorMap.CYCLE_REPEAT;
        }
        return GradientColorMap.CYCLE_NONE;
    }

    Transform6 computeDrawTexturePaintTransform(BaseTransform tx, float dx1, float dy1, float dx2, float dy2,
                                                float sx1, float sy1, float sx2, float sy2)
    {
        paintTx.setTransform(tx);

        final float scaleX = computeScale(dx1, dx2, sx1, sx2);
        final float scaleY = computeScale(dy1, dy2, sy1, sy2);

        if (scaleX == 1 &amp;&amp; scaleY == 1) {
            paintTx.deriveWithTranslation(-Math.min(sx1, sx2) + Math.min(dx1, dx2),
                    -Math.min(sy1, sy2) + Math.min(dy1, dy2));
        } else {
            paintTx.deriveWithTranslation(Math.min(dx1, dx2), Math.min(dy1, dy2));
            paintTx.deriveWithTranslation((scaleX &gt;= 0) ? 0 : Math.abs(dx2 - dx1),
                    (scaleY &gt;= 0) ? 0 : Math.abs(dy2 - dy1));
            paintTx.deriveWithConcatenation(scaleX, 0, 0, scaleY, 0, 0);
            paintTx.deriveWithTranslation(-Math.min(sx1, sx2), -Math.min(sy1, sy2));
        }

        SWUtils.convertToPiscesTransform(paintTx, piscesTx);
        return piscesTx;
    }

    private float computeScale(float dv1, float dv2, float sv1, float sv2) {
        final float dv_diff = dv2 - dv1;
        float scale = dv_diff / (sv2 - sv1);
        if (Math.abs(scale) &gt; (Integer.MAX_VALUE &gt;&gt; 16)) {
            scale = Math.signum(scale) * (Integer.MAX_VALUE &gt;&gt; 16);
        }
        return scale;
    }

    Transform6 computeSetTexturePaintTransform(Paint p, BaseTransform tx, RectBounds nodeBounds,
                                               float localX, float localY, float localWidth, float localHeight)
    {
        this.computePaintBounds(p, null, nodeBounds, localX, localY, localWidth, localHeight);

        final ImagePattern ip = (ImagePattern)p;
        this.computeImagePatternTransform(ip, tx, px, py, pw, ph);
        return piscesTx;
    }

    private void computeImagePatternTransform(ImagePattern ip, BaseTransform tx, float x, float y, float width, float height) {
        final Image image = ip.getImage();
        if (PrismSettings.debug) {
            System.out.println(&quot;PR.setTexturePaint: &quot; + image);
            System.out.println(&quot;imagePattern: x: &quot; + ip.getX() + &quot;, y: &quot; + ip.getY() +
                    &quot;, w: &quot; + ip.getWidth() + &quot;, h: &quot; + ip.getHeight() + &quot;, proportional: &quot; + ip.isProportional());
        }

        paintTx.setTransform(tx);
        if (ip.isProportional()) {
            paintTx.deriveWithConcatenation(width / image.getWidth() * ip.getWidth(), 0,
                    0, height / image.getHeight() * ip.getHeight(),
                    x + width * ip.getX(), y + height * ip.getY());
        } else {
            paintTx.deriveWithConcatenation(ip.getWidth() / image.getWidth(), 0,
                    0, ip.getHeight() / image.getHeight(),
                    x + ip.getX(), y + ip.getY());
        }
        SWUtils.convertToPiscesTransform(paintTx, piscesTx);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/animation/shared/SimpleClipInterpolator.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.animation.shared;

import java.util.HashMap;
import java.util.Map;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.beans.value.WritableValue;
import javafx.util.Duration;

/**
 * Simplified implementation of ClipCore, which is used for timelines with
 * exactly two keyframes.
 */

class SimpleClipInterpolator extends ClipInterpolator {

    private static final KeyFrame ZERO_FRAME = new KeyFrame(Duration.ZERO);

    // The list of all targets in this clip
    private KeyFrame startKeyFrame;
    private KeyFrame endKeyFrame;
    private long endTicks;
    private InterpolationInterval[] interval;
    private int undefinedStartValueCount;
    private long ticks;

    // Is internal representation uptodate?
    private boolean invalid = true;

    SimpleClipInterpolator(KeyFrame startKeyFrame, KeyFrame endKeyFrame, long ticks) {
        this.startKeyFrame = startKeyFrame;
        this.endKeyFrame = endKeyFrame;
<A NAME="15"></A>        this.endTicks = ticks;
    }

    SimpleClipInterpolator(KeyFrame endKeyFrame, <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#15',2,'match44-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>long ticks) {
        this.startKeyFrame = ZERO_FRAME;
        this.endKeyFrame = endKeyFrame;
        this.endTicks = ticks;
    }

    // See comment in ClipInterpolator
    @Override
    ClipInterpolator setKeyFrames(KeyFrame[] keyFrames, long[] keyFrameTicks</B></FONT>) {
        if (ClipInterpolator.getRealKeyFrameCount(keyFrames) != 2) {
            return ClipInterpolator.create(keyFrames, keyFrameTicks);
        }
        if (keyFrames.length == 1) {
            startKeyFrame = ZERO_FRAME;
            endKeyFrame = keyFrames[0];
            endTicks = keyFrameTicks[0];
        } else {
            startKeyFrame = keyFrames[0];
            endKeyFrame = keyFrames[1];
            endTicks = keyFrameTicks[1];
        }
        invalid = true;
        return this;
    }

    @Override
    void validate(boolean forceSync) {
        if (invalid) {
            ticks = endTicks;

            final Map&lt;WritableValue&lt;?&gt;, KeyValue&gt; map = new HashMap&lt;&gt;();
            // create a map from target =&gt; keyValues of endFrame
            for (final KeyValue keyValue : endKeyFrame.getValues()) {
                map.put(keyValue.getTarget(), keyValue);
            }

            final int valueCount = map.size();
            interval = new InterpolationInterval[valueCount];

            // iterate through keyValues in startFrame and generate intervals
            // if we find a matching keyValue in the startFrame, the entry is
            // removed from the map
            int i = 0;
            for (final KeyValue startKeyValue : startKeyFrame.getValues()) {
                final WritableValue&lt;?&gt; target = startKeyValue.getTarget();
                final KeyValue endKeyValue = map.get(target);
                if (endKeyValue != null) {
                    interval[i++] = InterpolationInterval.create(endKeyValue,
                            ticks, startKeyValue, ticks);
                    map.remove(target);
                }
            }

            // remaining entries in the map have no start value defined
            undefinedStartValueCount = map.values().size();
            for (final KeyValue endKeyValue : map.values()) {
                interval[i++] = InterpolationInterval.create(endKeyValue,
                        ticks);
            }

            invalid = false;
        } else if (forceSync) {
            // iterate through keyValues with undefined start value
            final int n = interval.length;
            for (int i = n - undefinedStartValueCount; i &lt; n; i++) {
                interval[i].recalculateStartValue();
            }
        }
    }

    @Override
    void interpolate(long ticks) {
        final double frac = ((double)ticks / this.ticks);
        final int n = interval.length;
        for (int i = 0; i &lt; n; i++) {
            interval[i].interpolate(frac);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/BoxShadow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.scenario.effect.impl.Renderer;
import com.sun.scenario.effect.impl.state.BoxShadowState;
import com.sun.scenario.effect.impl.state.LinearConvolveKernel;

/**
 * A shadow effect using a box-shaped convolution kernel, with a configurable
 * size for each dimension of the kernel and a number of passes to control
 * the quality of the blur.
 */
public class BoxShadow extends AbstractShadow {

    private final BoxShadowState state = new BoxShadowState();

    /**
     * Constructs a new {@code BoxShadow} effect with
     * the default blur sizes (1, 1)
     * and the default number of passes (1),
     * using the default input for source data.
     * This is a shorthand equivalent to:
     * &lt;pre&gt;
     *     new BoxShadow(1, 1, 1, DefaultInput)
     * &lt;/pre&gt;
     */
    public BoxShadow() {
        this(1, 1);
    }

    /**
     * Constructs a new {@code BoxShadow} effect with
     * the given blur sizes
     * and the default number of passes (1),
     * using the default input for source data.
     * This is a shorthand equivalent to:
     * &lt;pre&gt;
     *     new BoxShadow(hsize, vsize, 1, DefaultInput)
     * &lt;/pre&gt;
     *
     * @param hsize the horizontal size of the BoxShadow kernel
     * @param vsize the vertical size of the BoxShadow kernel
     * @throws IllegalArgumentException if either {@code hsize}
     * or {@code vsize} is outside the allowable range
     */
    public BoxShadow(int hsize, int vsize) {
        this(hsize, vsize, 1, DefaultInput);
    }

    /**
     * Constructs a new {@code BoxShadow} effect with
     * the given blur sizes
     * and number of passes,
     * using the default input for source data.
     * This is a shorthand equivalent to:
     * &lt;pre&gt;
     *     new BoxShadow(hsize, vsize, passes, DefaultInput)
     * &lt;/pre&gt;
     *
     * @param hsize the horizontal size of the BoxShadow kernel
     * @param vsize the vertical size of the BoxShadow kernel
     * @param passes the number of blur passes to execute
     * @throws IllegalArgumentException if either {@code hsize}
     * or {@code vsize} or {@code passes}
     * is outside the allowable range
     */
    public BoxShadow(int hsize, int vsize, int passes) {
        this(hsize, vsize, passes, DefaultInput);
    }

    /**
     * Constructs a new {@code BoxShadow} effect with
     * the given blur sizes
     * and number of passes,
     * using the output of the specified effect for source data.
     *
     * @param hsize the horizontal size of the BoxShadow kernel
     * @param vsize the vertical size of the BoxShadow kernel
     * @param passes the number of blur passes to execute
     * @param input the single input {@code Effect}
     * @throws IllegalArgumentException if either {@code hsize}
     * or {@code vsize} or {@code passes}
     * is outside the allowable range
     */
    public BoxShadow(int hsize, int vsize, int passes, Effect input) {
        super(input);
        setHorizontalSize(hsize);
        setVerticalSize(vsize);
        setPasses(passes);
        setColor(Color4f.BLACK);
        setSpread(0f);
    }

    @Override
    LinearConvolveKernel getState() {
        return state;
    }

    /**
     * Returns the input for this {@code Effect}.
     *
     * @return the input for this {@code Effect}
     */
    public final Effect getInput() {
        return getInputs().get(0);
    }

    /**
     * Sets the input for this {@code Effect}.
     * Sets the input for this {@code Effect} to a specific
     * {@code Effect} or to the default input if {@code input} is
     * {@code null}.
     *
     * @param input the input for this {@code Effect}
     */
    public void setInput(Effect input) {
        setInput(0, input);
    }

    /**
     * Returns the horizontal size of the effect kernel.
     *
     * @return the horizontal size of the effect kernel
     */
    public int getHorizontalSize() {
        return state.getHsize();
    }

    /**
     * Sets the horizontal size of the effect kernel.
     * &lt;pre&gt;
     *       Min:   0
     *       Max: 255
     *   Default:   1
     *  Identity:   0
     * &lt;/pre&gt;
     *
     * @param hsize the horizontal size of the effect kernel
     * @throws IllegalArgumentException if {@code hsize}
     * is outside the allowable range
     */
    public final void setHorizontalSize(int hsize) {
        state.setHsize(hsize);
    }

    /**
     * Returns the vertical size of the effect kernel.
     *
     * @return the vertical size of the effect kernel
     */
    public int getVerticalSize() {
        return state.getVsize();
    }

    /**
     * Sets the vertical size of the effect kernel.
     * &lt;pre&gt;
     *       Min:   0
     *       Max: 255
     *   Default:   1
     *  Identity:   0
     * &lt;/pre&gt;
     *
     * @param vsize the vertical size of the effect kernel
     * @throws IllegalArgumentException if {@code vsize}
     * is outside the allowable range
     */
    public final void setVerticalSize(int vsize) {
        state.setVsize(vsize);
    }

    /**
     * Returns the number of passes of the effect kernel to control the
     * quality of the blur.
     *
     * @return the number of passes of the effect kernel
     */
    public int getPasses() {
        return state.getBlurPasses();
    }

    /**
     * Sets the number of passes of the effect kernel to control the
     * quality of the blur.
     * &lt;pre&gt;
     *       Min:   0
     *       Max:   3
     *   Default:   1
     *  Identity:   0
     * &lt;/pre&gt;
     * A setting of 1 creates a low quality blur.  A setting of 3 creates
     * a blur that is very close to a Gaussian blur.
     *
     * @param passes
     * @throws IllegalArgumentException if {@code passes} is outside the
     * allowable range
     */
    public final void setPasses(int passes) {
        state.setBlurPasses(passes);
    }

    /**
     * Returns the shadow color.
     *
     * @return the shadow color
     */
    public Color4f getColor() {
        return state.getShadowColor();
    }

    /**
     * Sets the shadow color.
     * &lt;pre&gt;
     *       Min: n/a
     *       Max: n/a
     *   Default: Color4f.BLACK
     *  Identity: n/a
     * &lt;/pre&gt;
     *
     * @param color the shadow color
     * @throws IllegalArgumentException if {@code color} is null
     */
    public final void setColor(Color4f color) {
        state.setShadowColor(color);
    }

    /**
     * Gets the spread of the shadow effect.
     *
<A NAME="3"></A>     * @return the spread of the shadow effect
     */
    public float getSpread() {
        return <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#3',2,'match44-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>state.getSpread();
    }

    /**
     * Sets the spread of the shadow effect.
     * The spread is the portion of the radius where the contribution of
     * the source material will be 100%.
     * The remaining portion of the radius will have a contribution
     * controlled by the Blur kernel.
     * A spread of {@code 0.0} will result in a pure box-blur distribution
     * of the shadow.
     * A spread of {@code 1.0} will result in a solid growth outward of the
     * source material opacity to the limit of the kernel sizes with a very
     * sharp cutoff to transparency at the edge of the kernel.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 1.0
     *   Default: 0.0
     *  Identity: 0.0
     * &lt;/pre&gt;
     *
     * @param spread the spread of the shadow effect
     * @throws IllegalArgumentException if {@code spread} is outside the
     * allowable range
     */
    public final void setSpread(float spread) {
        state.setSpread(spread);
    }

    public float getGaussianRadius() {
        float d = (getHorizontalSize() + getVerticalSize()) / 2.0f</B></FONT>;
        d *= 3.0f;
        return (d &lt; 1.0f ? 0.0f : ((d - 1.0f) / 2.0f));
    }

    public float getGaussianWidth() {
        return getHorizontalSize() * 3.0f;
    }

    public float getGaussianHeight() {
        return getVerticalSize() * 3.0f;
    }

    public void setGaussianRadius(float r) {
        float d = r * 2.0f + 1.0f;
        setGaussianWidth(d);
        setGaussianHeight(d);
    }

    public void setGaussianWidth(float w) {
        w /= 3.0f;
        setHorizontalSize(Math.round(w));
    }

    public void setGaussianHeight(float h) {
        h /= 3.0f;
        setVerticalSize(Math.round(h));
    }

    public ShadowMode getMode() {
        switch (getPasses()) {
            case 1:
                return ShadowMode.ONE_PASS_BOX;
            case 2:
                return ShadowMode.TWO_PASS_BOX;
            default:
                return ShadowMode.THREE_PASS_BOX;
        }
    }

    public AbstractShadow implFor(ShadowMode mode) {
        switch (mode) {
            case GAUSSIAN:
                GaussianShadow gs = new GaussianShadow();
                gs.setInput(getInput());
                gs.setGaussianWidth(getGaussianWidth());
                gs.setGaussianHeight(getGaussianHeight());
                gs.setColor(getColor());
                gs.setSpread(getSpread());
                return gs;
            case ONE_PASS_BOX:
                setPasses(1);
                break;
            case TWO_PASS_BOX:
                setPasses(2);
                break;
            case THREE_PASS_BOX:
                setPasses(3);
                break;
        }
        return this;
    }

    @Override
    public AccelType getAccelType(FilterContext fctx) {
        return Renderer.getRenderer(fctx).getAccelType();
    }

    @Override
    public BaseBounds getBounds(BaseTransform transform, Effect defaultInput) {
        BaseBounds r = super.getBounds(null, defaultInput);
        int hgrow = state.getKernelSize(0) / 2;
        int vgrow = state.getKernelSize(1) / 2;
        RectBounds ret = new RectBounds(r.getMinX(), r.getMinY(), r.getMaxX(), r.getMaxY());
        ret.grow(hgrow, vgrow);
        return transformBounds(transform, ret);
    }

    @Override
    public Rectangle getResultBounds(BaseTransform transform,
                                     Rectangle outputClip,
                                     ImageData... inputDatas)
    {
        Rectangle r = inputDatas[0].getUntransformedBounds();
        r = state.getResultBounds(r, 0);
        r = state.getResultBounds(r, 1);
        r.intersectWith(outputClip);
        return r;
    }

    @Override
    public boolean reducesOpaquePixels() {
        return true;
    }

    @Override
    public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
        Effect di = getDefaultedInput(0, defaultInput);
        DirtyRegionContainer drc = di.getDirtyRegions(defaultInput, regionPool);

        drc.grow(state.getKernelSize(0) / 2, state.getKernelSize(1) / 2);

        return drc;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/state/ZoomRadialBlurState.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="10"></A> * questions.
 */

<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#10',2,'match44-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.scenario.effect.impl.state;

import com.sun.scenario.effect.ZoomRadialBlur;

public class ZoomRadialBlurState {

    private float dx = -1f;
    private float dy = -1f;
    private final ZoomRadialBlur effect;

    public ZoomRadialBlurState(ZoomRadialBlur effect) {
        t</B></FONT>his.effect = effect;
    }

    public int getRadius() {
        return effect.getRadius();
    }

    /**
     * Updates offsets by X and Y axes.
     */
    public void updateDeltas(float dx, float dy) {
        this.dx = dx;
        this.dy = dy;
    }

    /**
     * Invalidates X and Y offsets.
     */
    public void invalidateDeltas() {
        this.dx = -1f;
        this.dy = -1f;
    }

    /**
     * Returns offset by X axis to the next pixel
     * @return offset by X axis to the next pixel
     */
    public float getDx() {
        return dx;
    }

    /**
     * Returns offset by Y axis to the next pixel
     * @return offset by Y axis to the next pixel
     */
    public float getDy() {
        return dy;
    }

    public int getNumSteps() {
        int r = getRadius();
        return r * 2 + 1;
    }

    public float getAlpha() {
        float r = getRadius();
        return 1.0f/(2.0f*r + 1.0f);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/text/Text.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.text;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.TransformedShape;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.shape.ShapeHelper;
import com.sun.javafx.scene.shape.TextHelper;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.scene.text.TextLayout;
import com.sun.javafx.scene.text.TextLayoutFactory;
import com.sun.javafx.scene.text.TextLine;
import com.sun.javafx.scene.text.TextSpan;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGShape;
import com.sun.javafx.sg.prism.NGText;
import com.sun.javafx.scene.text.FontHelper;
import com.sun.javafx.tk.Toolkit;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.Shape;
import javafx.scene.shape.StrokeType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.IntegerPropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoubleWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.VPos;
import javafx.scene.Node;

/**
 * The {@code Text} class defines a node that displays a text.
 *
 * Paragraphs are separated by {@code '\n'} and the text is wrapped on
 * paragraph boundaries.
 *
&lt;PRE&gt;
import javafx.scene.text.*;

Text t = new Text(10, 50, &quot;This is a test&quot;);
t.setFont(new Font(20));
&lt;/PRE&gt;
 *
&lt;PRE&gt;
import javafx.scene.text.*;

Text t = new Text();
text.setFont(new Font(20));
text.setText(&quot;First row\nSecond row&quot;);
&lt;/PRE&gt;
 *
&lt;PRE&gt;
import javafx.scene.text.*;

Text t = new Text();
text.setFont(new Font(20));
text.setWrappingWidth(200);
text.setTextAlignment(TextAlignment.JUSTIFY)
text.setText(&quot;The quick brown fox jumps over the lazy dog&quot;);
&lt;/PRE&gt;
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public class Text extends Shape {
    static {
        TextHelper.setTextAccessor(new TextHelper.TextAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Text) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Text) node).doUpdatePeer();
            }

            @Override
            public Bounds doComputeLayoutBounds(Node node) {
                return ((Text) node).doComputeLayoutBounds();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Text) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Text) node).doComputeContains(localX, localY);
            }

            @Override
            public void doGeomChanged(Node node) {
                ((Text) node).doGeomChanged();
            }

            @Override
            public com.sun.javafx.geom.Shape doConfigShape(Shape shape) {
                return ((Text) shape).doConfigShape();
            }
        });
    }

    private TextLayout layout;
    private static final PathElement[] EMPTY_PATH_ELEMENT_ARRAY = new PathElement[0];

    {
        // To initialize the class helper at the begining each constructor of this class
        TextHelper.initHelper(this);
    }

    /**
     * Creates an empty instance of Text.
     */
    public Text() {
        setAccessibleRole(AccessibleRole.TEXT);
        InvalidationListener listener = observable -&gt; checkSpan();
        parentProperty().addListener(listener);
        managedProperty().addListener(listener);
        effectiveNodeOrientationProperty().addListener(observable -&gt; checkOrientation());
        setPickOnBounds(true);
    }

    /**
     * Creates an instance of Text containing the given string.
     * @param text text to be contained in the instance
     */
    public Text(String text) {
        this();
        setText(text);
    }

    /**
     * Creates an instance of Text on the given coordinates containing the
     * given string.
     * @param x the horizontal position of the text
     * @param y the vertical position of the text
     * @param text text to be contained in the instance
     */
    public Text(double x, double y, String text) {
        this(text);
        setX(x);
        setY(y);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGText();
    }

    private boolean isSpan;
    private boolean isSpan() {
        return isSpan;
    }

    private void checkSpan() {
        isSpan = isManaged() &amp;&amp; getParent() instanceof TextFlow;
        if (isSpan() &amp;&amp; !pickOnBoundsProperty().isBound()) {
            /* Documented behavior. See class description for TextFlow */
            setPickOnBounds(false);
        }
    }

    private void checkOrientation() {
        if (!isSpan()) {
            NodeOrientation orientation = getEffectiveNodeOrientation();
            boolean rtl =  orientation == NodeOrientation.RIGHT_TO_LEFT;
            int dir = rtl ? TextLayout.DIRECTION_RTL : TextLayout.DIRECTION_LTR;
            TextLayout layout = getTextLayout();
            if (layout.setDirection(dir)) {
                needsTextLayout();
            }
        }
    }

    @Override
    public boolean usesMirroring() {
        return false;
    }

    private void needsFullTextLayout() {
        if (isSpan()) {
            /* Create new text span every time the font or text changes
             * so the text layout can see that the content has changed.
             */
            textSpan = null;

            /* Relies on NodeHelper.geomChanged(this) to request text flow to relayout */
        } else {
            TextLayout layout = getTextLayout();
            String string = getTextInternal();
            Object font = getFontInternal();
            layout.setContent(string, font);
        }
        needsTextLayout();
    }

    private void needsTextLayout() {
        textRuns = null;
        NodeHelper.geomChanged(this);
        NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
    }

    private TextSpan textSpan;
    TextSpan getTextSpan() {
        if (textSpan == null) {
            textSpan = new TextSpan() {
                @Override public String getText() {
                    return getTextInternal();
                }
                @Override public Object getFont() {
                    return getFontInternal();
                }
                @Override public RectBounds getBounds() {
                    return null;
                }
            };
        }
        return textSpan;
    }

    private TextLayout getTextLayout() {
        if (isSpan()) {
            layout = null;
            TextFlow parent = (TextFlow)getParent();
            return parent.getTextLayout();
        }
        if (layout == null) {
            TextLayoutFactory factory = Toolkit.getToolkit().getTextLayoutFactory();
            layout = factory.createLayout();
            String string = getTextInternal();
            Object font = getFontInternal();
            TextAlignment alignment = getTextAlignment();
            if (alignment == null) alignment = DEFAULT_TEXT_ALIGNMENT;
            layout.setContent(string, font);
            layout.setAlignment(alignment.ordinal());
            layout.setLineSpacing((float)getLineSpacing());
            layout.setWrapWidth((float)getWrappingWidth());
            if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                layout.setDirection(TextLayout.DIRECTION_RTL);
            } else {
                layout.setDirection(TextLayout.DIRECTION_LTR);
            }
        }
        return layout;
    }

    private GlyphList[] textRuns = null;
    private BaseBounds spanBounds = new RectBounds(); /* relative to the textlayout */
    private boolean spanBoundsInvalid = true;

    void layoutSpan(GlyphList[] runs) {
        TextSpan span = getTextSpan();
        int count = 0;
        for (int i = 0; i &lt; runs.length; i++) {
            GlyphList run = runs[i];
            if (run.getTextSpan() == span) {
                count++;
            }
        }
        textRuns = new GlyphList[count];
        count = 0;
        for (int i = 0; i &lt; runs.length; i++) {
            GlyphList run = runs[i];
            if (run.getTextSpan() == span) {
                textRuns[count++] = run;
            }
        }
        spanBoundsInvalid = true;

        /* Sometimes a property change in the text node will causes layout in
         * text flow. In this case all the dirty bits are already clear and no
         * extra work is necessary. Other times the layout is caused by changes
         * in the text flow object (wrapping width and text alignment for example).
         * In the second case the dirty bits must be set here using
         * NodeHelper.geomChanged(this) and NodeHelper.markDirty(). Note that NodeHelper.geomChanged(this)
         * causes another (undesired) layout request in the parent.
         * In general this is not a problem because shapes are not resizable and
         * region objects do not propagate layout changes to the parent.
         * This is a special case where a shape is resized by the parent during
         * layoutChildren(). See TextFlow#requestLayout() for information how
         * text flow deals with this situation.
         */
        NodeHelper.geomChanged(this);
        NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
    }

    BaseBounds getSpanBounds() {
        if (spanBoundsInvalid) {
            GlyphList[] runs = getRuns();
            if (runs.length != 0) {
                float left = Float.POSITIVE_INFINITY;
                float top = Float.POSITIVE_INFINITY;
                float right = 0;
                float bottom = 0;
                for (int i = 0; i &lt; runs.length; i++) {
                    GlyphList run = runs[i];
                    com.sun.javafx.geom.Point2D location = run.getLocation();
                    float width = run.getWidth();
                    float height = run.getLineBounds().getHeight();
                    left = Math.min(location.x, left);
                    top = Math.min(location.y, top);
                    right = Math.max(location.x + width, right);
                    bottom = Math.max(location.y + height, bottom);
                }
                spanBounds = spanBounds.deriveWithNewBounds(left, top, 0,
                                                            right, bottom, 0);
            } else {
                spanBounds = spanBounds.makeEmpty();
            }
            spanBoundsInvalid = false;
        }
        return spanBounds;
    }

    private GlyphList[] getRuns() {
        if (textRuns != null) return textRuns;
        if (isSpan()) {
            /* List of run is initialized when the TextFlow layout the children */
            getParent().layout();
        } else {
            TextLayout layout = getTextLayout();
            textRuns = layout.getRuns();
        }
        return textRuns;
    }

    private com.sun.javafx.geom.Shape getShape() {
        TextLayout layout = getTextLayout();
        /* TextLayout has the text shape cached */
        int type = TextLayout.TYPE_TEXT;
        if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
        if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;

        TextSpan filter = null;
        if (isSpan()) {
            /* Spans are always relative to the top */
            type |= TextLayout.TYPE_TOP;
            filter = getTextSpan();
        } else {
            /* Relative to baseline (first line)
             * This shape can be translate in the y axis according
             * to text origin, see ShapeHelper.configShape().
             */
            type |= TextLayout.TYPE_BASELINE;
        }
        return layout.getShape(type, filter);
    }

    private BaseBounds getVisualBounds() {
        if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
            int type = TextLayout.TYPE_TEXT;
            if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
            if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;
            return getTextLayout().getVisualBounds(type);
        } else {
            return getShape().getBounds();
        }
    }

    private BaseBounds getLogicalBounds() {
        TextLayout layout = getTextLayout();
        /* TextLayout has the bounds cached */
        return layout.getBounds();
    }

    /**
     * Defines text string that is to be displayed.
     *
     * @defaultValue empty string
     */
    private StringProperty text;

    public final void setText(String value) {
        if (value == null) value = &quot;&quot;;
        textProperty().set(value);
    }

    public final String getText() {
        return text == null ? &quot;&quot; : text.get();
    }

    private String getTextInternal() {
        // this might return null in case of bound property
        String localText = getText();
        return localText == null ? &quot;&quot; : localText;
    }

    public final StringProperty textProperty() {
        if (text == null) {
            text = new StringPropertyBase(&quot;&quot;) {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;text&quot;; }
                @Override  public void invalidated() {
                    needsFullTextLayout();
                    setSelectionStart(-1);
                    setSelectionEnd(-1);
                    setCaretPosition(-1);
                    setCaretBias(true);

                    // MH: Functionality copied from store() method,
                    // which was removed.
                    // Wonder what should happen if text is bound
                    //  and becomes null?
                    final String value = get();
                    if ((value == null) &amp;&amp; !isBound()) {
                        set(&quot;&quot;);
                    }
                    notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
                }
            };
        }
        return text;
    }

    /**
     * Defines the X coordinate of text origin.
     *
     * @defaultValue 0
     */
    private DoubleProperty x;

    public final void setX(double value) {
        xProperty().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase() {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;x&quot;; }
                @Override public void invalidated() {
                    NodeHelper.geomChanged(Text.this);
                }
            };
        }
        return x;
    }

    /**
     * Defines the Y coordinate of text origin.
     *
     * @defaultValue 0
     */
    private DoubleProperty y;

    public final void setY(double value) {
        yProperty().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase() {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;y&quot;; }
                @Override public void invalidated() {
                    NodeHelper.geomChanged(Text.this);
                }
            };
        }
        return y;
    }

    /**
     * Defines the font of text.
     *
     * @defaultValue Font{}
     */
    private ObjectProperty&lt;Font&gt; font;

    public final void setFont(Font value) {
        fontProperty().set(value);
    }

    public final Font getFont() {
        return font == null ? Font.getDefault() : font.get();
    }

    /**
     * Internally used safe version of getFont which never returns null.
     *
     * @return the font
     */
    private Object getFontInternal() {
        Font font = getFont();
        if (font == null) font = Font.getDefault();
        return FontHelper.getNativeFont(font);
    }

    public final ObjectProperty&lt;Font&gt; fontProperty() {
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;font&quot;; }
                @Override public CssMetaData&lt;Text,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }
                @Override public void invalidated() {
                    needsFullTextLayout();
                    NodeHelper.markDirty(Text.this, DirtyBits.TEXT_FONT);
                }
            };
        }
        return font;
    }

    public final void setTextOrigin(VPos value) {
        textOriginProperty().set(value);
    }

    public final VPos getTextOrigin() {
        if (attributes == null || attributes.textOrigin == null) {
            return DEFAULT_TEXT_ORIGIN;
        }
        return attributes.getTextOrigin();
    }

    /**
     * Defines the origin of text coordinate system in local coordinates.
     * Note: in case multiple rows are rendered {@code VPos.BASELINE} and
     * {@code VPos.TOP} define the origin of the top row while
     * {@code VPos.BOTTOM} defines the origin of the bottom row.
     *
     * @return the origin of text coordinate system in local coordinates
     * @defaultValue VPos.BASELINE
     */
    public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
        return getTextAttribute().textOriginProperty();
    }

    /**
     * Determines how the bounds of the text node are calculated.
     * Logical bounds is a more appropriate default for text than
     * the visual bounds. See {@code TextBoundsType} for more information.
     *
     * @defaultValue TextBoundsType.LOGICAL
     */
    private ObjectProperty&lt;TextBoundsType&gt; boundsType;

    public final void setBoundsType(TextBoundsType value) {
        boundsTypeProperty().set(value);
    }

    public final TextBoundsType getBoundsType() {
        return boundsType == null ?
            DEFAULT_BOUNDS_TYPE : boundsTypeProperty().get();
    }

    public final ObjectProperty&lt;TextBoundsType&gt; boundsTypeProperty() {
        if (boundsType == null) {
            boundsType =
               new StyleableObjectProperty&lt;TextBoundsType&gt;(DEFAULT_BOUNDS_TYPE) {
                   @Override public Object getBean() { return Text.this; }
                   @Override public String getName() { return &quot;boundsType&quot;; }
                   @Override public CssMetaData&lt;Text,TextBoundsType&gt; getCssMetaData() {
                       return StyleableProperties.BOUNDS_TYPE;
                   }
                   @Override public void invalidated() {
                       TextLayout layout = getTextLayout();
                       int type = 0;
                       if (boundsType.get() == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
                           type |= TextLayout.BOUNDS_CENTER;
                       }
                       if (layout.setBoundsType(type)) {
                           needsTextLayout();
                       } else {
                           NodeHelper.geomChanged(Text.this);
                       }
                   }
            };
        }
        return boundsType;
    }

    /**
     * Defines a width constraint for the text in user space coordinates,
     * e.g. pixels, not glyph or character count.
     * If the value is {@code &gt; 0} text will be line wrapped as needed
     * to satisfy this constraint.
     *
     * @defaultValue 0
     */
    private DoubleProperty wrappingWidth;

    public final void setWrappingWidth(double value) {
        wrappingWidthProperty().set(value);
    }

    public final double getWrappingWidth() {
        return wrappingWidth == null ? 0 : wrappingWidth.get();
    }

    public final DoubleProperty wrappingWidthProperty() {
        if (wrappingWidth == null) {
            wrappingWidth = new DoublePropertyBase() {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;wrappingWidth&quot;; }
                @Override public void invalidated() {
                    if (!isSpan()) {
                        TextLayout layout = getTextLayout();
                        if (layout.setWrapWidth((float)get())) {
                            needsTextLayout();
                        } else {
                            NodeHelper.geomChanged(Text.this);
                        }
                    }
                }
            };
        }
        return wrappingWidth;
    }

    public final void setUnderline(boolean value) {
        underlineProperty().set(value);
    }

    public final boolean isUnderline() {
        if (attributes == null || attributes.underline == null) {
            return DEFAULT_UNDERLINE;
        }
        return attributes.isUnderline();
    }

    /**
     * Defines if each line of text should have a line below it.
     *
     * @return if each line of text should have a line below it
     * @defaultValue false
     */
    public final BooleanProperty underlineProperty() {
        return getTextAttribute().underlineProperty();
    }

    public final void setStrikethrough(boolean value) {
        strikethroughProperty().set(value);
    }

    public final boolean isStrikethrough() {
        if (attributes == null || attributes.strikethrough == null) {
            return DEFAULT_STRIKETHROUGH;
        }
        return attributes.isStrikethrough();
    }

    /**
     * Defines if each line of text should have a line through it.
     *
     * @return if each line of text should have a line through it
     * @defaultValue false
     */
    public final BooleanProperty strikethroughProperty() {
        return getTextAttribute().strikethroughProperty();
    }

    public final void setTextAlignment(TextAlignment value) {
        textAlignmentProperty().set(value);
    }

    public final TextAlignment getTextAlignment() {
        if (attributes == null || attributes.textAlignment == null) {
            return DEFAULT_TEXT_ALIGNMENT;
        }
        return attributes.getTextAlignment();
    }

    /**
     * Defines horizontal text alignment in the bounding box.
     *
     * The width of the bounding box is defined by the widest row.
     *
     * Note: In the case of a single line of text, where the width of the
     * node is determined by the width of the text, the alignment setting
     * has no effect.
     *
     * @return the horizontal text alignment in the bounding box
     * @defaultValue TextAlignment.LEFT
     */
    public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
        return getTextAttribute().textAlignmentProperty();
    }

    public final void setLineSpacing(double spacing) {
        lineSpacingProperty().set(spacing);
    }

    public final double getLineSpacing() {
        if (attributes == null || attributes.lineSpacing == null) {
            return DEFAULT_LINE_SPACING;
        }
        return attributes.getLineSpacing();
    }

    /**
     * Defines the vertical space in pixel between lines.
     *
     * @return the vertical space in pixel between lines
     * @defaultValue 0
     *
     * @since JavaFX 8.0
     */
    public final DoubleProperty lineSpacingProperty() {
        return getTextAttribute().lineSpacingProperty();
    }

    @Override
    public final double getBaselineOffset() {
        return baselineOffsetProperty().get();
    }

    /**
     * The 'alphabetic' (or roman) baseline offset from the Text node's
     * layoutBounds.minY location.
     * The value typically corresponds to the max ascent of the font.
     * @return the baseline offset from this text node
     */
    public final ReadOnlyDoubleProperty baselineOffsetProperty() {
        return getTextAttribute().baselineOffsetProperty();
    }

    /**
     * Specifies a requested font smoothing type : gray or LCD.
     *
     * The width of the bounding box is defined by the widest row.
     *
     * Note: LCD mode doesn't apply in numerous cases, such as various
     * compositing modes, where effects are applied and very large glyphs.
     *
     * @defaultValue FontSmoothingType.GRAY
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;

    public final void setFontSmoothingType(FontSmoothingType value) {
        fontSmoothingTypeProperty().set(value);
    }

    public final FontSmoothingType getFontSmoothingType() {
        return fontSmoothingType == null ?
            FontSmoothingType.GRAY : fontSmoothingType.get();
    }

    public final ObjectProperty&lt;FontSmoothingType&gt;
        fontSmoothingTypeProperty() {
        if (fontSmoothingType == null) {
            fontSmoothingType =
                new StyleableObjectProperty&lt;FontSmoothingType&gt;
                                               (FontSmoothingType.GRAY) {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;fontSmoothingType&quot;; }
                @Override public CssMetaData&lt;Text,FontSmoothingType&gt; getCssMetaData() {
                    return StyleableProperties.FONT_SMOOTHING_TYPE;
                }
                @Override public void invalidated() {
                    NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
                    NodeHelper.geomChanged(Text.this);
                }
            };
        }
        return fontSmoothingType;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doGeomChanged() {
        if (attributes != null) {
            if (attributes.caretBinding != null) {
                attributes.caretBinding.invalidate();
            }
            if (attributes.selectionBinding != null) {
                attributes.selectionBinding.invalidate();
            }
        }
        NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
    }

    /**
     * Shape of selection in local coordinates.
     *
     * @return the shape of selection in local coordinates
     * @since 9
     */
    public final PathElement[] getSelectionShape() {
        return selectionShapeProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
        return getTextAttribute().selectionShapeProperty();
    }

    /**
     * Selection start index in the content.
     * Set to {@code -1} to unset selection.
     *
     * @param value the selection start index
     * @since 9
     */
    public final void setSelectionStart(int value) {
        if (value == -1 &amp;&amp;
                (attributes == null || attributes.selectionStart == null)) {
            return;
        }
        selectionStartProperty().set(value);
    }

    public final int getSelectionStart() {
        if (attributes == null || attributes.selectionStart == null) {
            return DEFAULT_SELECTION_START;
        }
        return attributes.getSelectionStart();
    }

    public final IntegerProperty selectionStartProperty() {
        return getTextAttribute().selectionStartProperty();
    }

    /**
     * Selection end index in the content.
     * Set to {@code -1} to unset selection.
     *
     * @param value the selection end index
     * @since 9
     */
    public final void setSelectionEnd(int value) {
        if (value == -1 &amp;&amp;
                (attributes == null || attributes.selectionEnd == null)) {
            return;
        }
        selectionEndProperty().set(value);
    }

    public final int getSelectionEnd() {
        if (attributes == null || attributes.selectionEnd == null) {
            return DEFAULT_SELECTION_END;
        }
        return attributes.getSelectionEnd();
    }

    public final IntegerProperty selectionEndProperty() {
        return getTextAttribute().selectionEndProperty();
    }

    /**
     * The fill color of selected text.
     *
     * @return the fill color of selected text
     * @since 9
     */
    public final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
        return getTextAttribute().selectionFillProperty();
    }

    public final void setSelectionFill(Paint paint) {
        selectionFillProperty().set(paint);
    }
    public final Paint getSelectionFill() {
        return selectionFillProperty().get();
    }

    /**
     * Shape of caret in local coordinates.
     *
     * @return the shape of caret in local coordinates
     * @since 9
     */
    public final PathElement[] getCaretShape() {
        return caretShapeProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
        return getTextAttribute().caretShapeProperty();
    }

    /**
     * Caret index in the content.
     * Set to {@code -1} to unset caret.
     *
     * @param value the caret index in the content
     * @since 9
     */
    public final void setCaretPosition(int value) {
        if (value == -1 &amp;&amp;
                (attributes == null || attributes.caretPosition == null)) {
            return;
        }
        caretPositionProperty().set(value);
    }

    public final int getCaretPosition() {
        if (attributes == null || attributes.caretPosition == null) {
            return DEFAULT_CARET_POSITION;
        }
        return attributes.getCaretPosition();
    }

    public final IntegerProperty caretPositionProperty() {
        return getTextAttribute().caretPositionProperty();
    }

    /**
     * caret bias in the content. {@code true} means a bias towards the leading character edge.
     * (true=leading/false=trailing)
     *
     * @param value the caret bias in the content
     * @since 9
     */
    public final void setCaretBias(boolean value) {
        if (value &amp;&amp; (attributes == null || attributes.caretBias == null)) {
            return;
        }
        caretBiasProperty().set(value);
    }

    public final boolean isCaretBias() {
        if (attributes == null || attributes.caretBias == null) {
            return DEFAULT_CARET_BIAS;
        }
        return getTextAttribute().isCaretBias();
    }

    public final BooleanProperty caretBiasProperty() {
        return getTextAttribute().caretBiasProperty();
    }

    /**
     * Maps local point to index in the content.
     *
     * @param point the specified point to be tested
     * @return a {@code HitInfo} representing the character index found
     * @since 9
     */
    public final HitInfo hitTest(Point2D point) {
        if (point == null) return null;
        TextLayout layout = getTextLayout();
        double x = point.getX() - getX();
        double y = point.getY() - getY() + getYRendering();
        TextLayout.Hit layoutHit = layout.getHitInfo((float)x, (float)y);
        return new HitInfo(layoutHit.getCharIndex(), layoutHit.getInsertionIndex(),
                           layoutHit.isLeading(), getText());
    }

    private PathElement[] getRange(int start, int end, int type) {
        int length = getTextInternal().length();
        if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
            TextLayout layout = getTextLayout();
            float x = (float)getX();
            float y = (float)getY() - getYRendering();
            return layout.getRange(start, end, type, x, y);
        }
        return EMPTY_PATH_ELEMENT_ARRAY;
    }

    /**
     * Returns shape for the caret at given index and bias.
     *
     * @param charIndex the character index for the caret
     * @param caretBias whether the caret is biased on the leading edge of the character
     * @return an array of {@code PathElement} which can be used to create a {@code Shape}
     * @since 9
     */
    public final PathElement[] caretShape(int charIndex, boolean caretBias) {
        if (0 &lt;= charIndex &amp;&amp; charIndex &lt;= getTextInternal().length()) {
            float x = (float)getX();
            float y = (float)getY() - getYRendering();
            return getTextLayout().getCaretShape(charIndex, caretBias, x, y);
        } else {
            return null;
        }
    }

    /**
     * Returns shape for the range of the text in local coordinates.
     *
     * @param start the beginning character index for the range
     * @param end the end character index (non-inclusive) for the range
     * @return an array of {@code PathElement} which can be used to create a {@code Shape}
     * @since 9
     */
    public final PathElement[] rangeShape(int start, int end) {
        return getRange(start, end, TextLayout.TYPE_TEXT);
    }

    /**
     * Returns shape for the underline in local coordinates.
     *
     * @param start the beginning character index for the range
     * @param end the end character index (non-inclusive) for the range
     * @return an array of {@code PathElement} which can be used to create a {@code Shape}
     * @since 9
     */
    public final PathElement[] underlineShape(int start, int end) {
        return getRange(start, end, TextLayout.TYPE_UNDERLINE);
    }

    private float getYAdjustment(BaseBounds bounds) {
        VPos origin = getTextOrigin();
        if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
        switch (origin) {
        case TOP: return -bounds.getMinY();
        case BASELINE: return 0;
        case CENTER: return -bounds.getMinY() - bounds.getHeight() / 2;
        case BOTTOM: return -bounds.getMinY() - bounds.getHeight();
        default: return 0;
        }
    }

    private float getYRendering() {
        if (isSpan()) return 0;

        /* Always logical for rendering */
        BaseBounds bounds = getLogicalBounds();

        VPos origin = getTextOrigin();
        if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
        if (getBoundsType() == TextBoundsType.VISUAL) {
            BaseBounds vBounds = getVisualBounds();
            float delta = vBounds.getMinY() - bounds.getMinY();
            switch (origin) {
            case TOP: return delta;
            case BASELINE: return -vBounds.getMinY() + delta;
            case CENTER: return vBounds.getHeight() / 2 + delta;
            case BOTTOM: return vBounds.getHeight() + delta;
            default: return 0;
            }
        } else {
            switch (origin) {
            case TOP: return 0;
            case BASELINE: return -bounds.getMinY();
            case CENTER: return bounds.getHeight() / 2;
            case BOTTOM: return bounds.getHeight();
            default: return 0;
            }
        }
    }

    private Bounds doComputeLayoutBounds() {
        if (isSpan()) {
            BaseBounds bounds = getSpanBounds();
            double width = bounds.getWidth();
            double height = bounds.getHeight();
            return new BoundingBox(0, 0, width, height);
        }

        if (getBoundsType() == TextBoundsType.VISUAL) {
            /* In Node the layout bounds is computed based in the geom
             * bounds and in Shape the geom bounds is computed based
             * on the shape (generated here in #configShape()) */
            return TextHelper.superComputeLayoutBounds(this);
        }
        BaseBounds bounds = getLogicalBounds();
        double x = bounds.getMinX() + getX();
        double y = bounds.getMinY() + getY() + getYAdjustment(bounds);
        double width = bounds.getWidth();
        double height = bounds.getHeight();
        double wrappingWidth = getWrappingWidth();
        if (wrappingWidth != 0) width = wrappingWidth;
        return new BoundingBox(x, y, width, height);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds,
                                                   BaseTransform tx) {
        if (isSpan()) {
            if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
                return TextHelper.superComputeGeomBounds(this, bounds, tx);
            }
            TextLayout layout = getTextLayout();
            bounds = layout.getBounds(getTextSpan(), bounds);
            BaseBounds spanBounds = getSpanBounds();
            float minX = bounds.getMinX() - spanBounds.getMinX();
            float minY = bounds.getMinY() - spanBounds.getMinY();
            float maxX = minX + bounds.getWidth();
            float maxY = minY + bounds.getHeight();
            bounds = bounds.deriveWithNewBounds(minX, minY, 0, maxX, maxY, 0);
            return tx.transform(bounds, bounds);
        }

       if (getBoundsType() == TextBoundsType.VISUAL) {
            if (getTextInternal().length() == 0 || ShapeHelper.getMode(this) == NGShape.Mode.EMPTY) {
                return bounds.makeEmpty();
            }
            if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
                /* Optimize for FILL and INNER STROKE: save the cost of shaping each glyph */
                BaseBounds visualBounds = getVisualBounds();
                float x = visualBounds.getMinX() + (float) getX();
                float yadj = getYAdjustment(visualBounds);
                float y = visualBounds.getMinY() + yadj + (float) getY();
                bounds.deriveWithNewBounds(x, y, 0, x + visualBounds.getWidth(),
                        y + visualBounds.getHeight(), 0);
                return tx.transform(bounds, bounds);
            } else {
                /* Let the superclass compute the bounds using shape */
                return TextHelper.superComputeGeomBounds(this, bounds, tx);
            }
        }

        BaseBounds textBounds = getLogicalBounds();
        float x = textBounds.getMinX() + (float)getX();
        float yadj = getYAdjustment(textBounds);
        float y = textBounds.getMinY() + yadj + (float)getY();
        float width = textBounds.getWidth();
        float height = textBounds.getHeight();
        float wrappingWidth = (float)getWrappingWidth();
        if (wrappingWidth &gt; width) {
            width = wrappingWidth;
        } else {
            /* The following adjustment is necessary for the text bounds to be
             * relative to the same location as the mirrored bounds returned
             * by layout.getBounds().
             */
            if (wrappingWidth &gt; 0) {
                NodeOrientation orientation = getEffectiveNodeOrientation();
                if (orientation == NodeOrientation.RIGHT_TO_LEFT) {
                    x -= width - wrappingWidth;
                }
            }
        }
        textBounds = new RectBounds(x, y, x + width, y + height);

        /* handle stroked text */
        if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
            bounds = TextHelper.superComputeGeomBounds(this, bounds,
                    BaseTransform.IDENTITY_TRANSFORM);
        } else {
            TextLayout layout = getTextLayout();
            bounds = layout.getBounds(null, bounds);
            x = bounds.getMinX() + (float)getX();
            width = bounds.getWidth();
            bounds = bounds.deriveWithNewBounds(x, y, 0, x + width, y + height, 0);
        }

        bounds = bounds.deriveWithUnion(textBounds);
        return tx.transform(bounds, bounds);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        /* Used for spans, regular text uses bounds based picking */
        double x = localX + getSpanBounds().getMinX();
        double y = localY + getSpanBounds().getMinY();
        GlyphList[] runs = getRuns();
        if (runs.length != 0) {
            for (int i = 0; i &lt; runs.length; i++) {
                GlyphList run = runs[i];
                com.sun.javafx.geom.Point2D location = run.getLocation();
                float width = run.getWidth();
                RectBounds lineBounds = run.getLineBounds();
                float height = lineBounds.getHeight();
                if (location.x &lt;= x &amp;&amp; x &lt; location.x + width &amp;&amp;
                    location.y &lt;= y &amp;&amp; y &lt; location.y + height) {
                        return true;
                }
            }
        }
        return false;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private com.sun.javafx.geom.Shape doConfigShape() {
        if (ShapeHelper.getMode(this) == NGShape.Mode.EMPTY || getTextInternal().length() == 0) {
            return new Path2D();
        }
        com.sun.javafx.geom.Shape shape = getShape();
        float x, y;
        if (isSpan()) {
            BaseBounds bounds = getSpanBounds();
            x = -bounds.getMinX();
            y = -bounds.getMinY();
        } else {
            x = (float)getX();
            y = getYAdjustment(getVisualBounds()) + (float)getY();
        }
        return TransformedShape.translatedShape(shape, x, y);
    }

   /***************************************************************************
    *                                                                         *
    *                            Stylesheet Handling                          *
    *                                                                         *
    **************************************************************************/

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {

         private static final CssMetaData&lt;Text,Font&gt; FONT =
            new FontCssMetaData&lt;Text&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(Text node) {
                return node.font == null || !node.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Font&gt;)node.fontProperty();
            }
         };

         private static final CssMetaData&lt;Text,Boolean&gt; UNDERLINE =
            new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-underline&quot;,
                 BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.underline == null ||
                      !node.attributes.underline.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Boolean&gt;)node.underlineProperty();
            }
         };

         private static final CssMetaData&lt;Text,Boolean&gt; STRIKETHROUGH =
            new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-strikethrough&quot;,
                 BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.strikethrough == null ||
                      !node.attributes.strikethrough.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Boolean&gt;)node.strikethroughProperty();
            }
         };

         private static final
             CssMetaData&lt;Text,TextAlignment&gt; TEXT_ALIGNMENT =
                 new CssMetaData&lt;Text,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
                 TextAlignment.LEFT) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.textAlignment == null ||
                      !node.attributes.textAlignment.isBound();
            }

            @Override
            public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;TextAlignment&gt;)node.textAlignmentProperty();
            }
         };

         private static final CssMetaData&lt;Text,VPos&gt; TEXT_ORIGIN =
                 new CssMetaData&lt;Text,VPos&gt;(&quot;-fx-text-origin&quot;,
                 new EnumConverter&lt;VPos&gt;(VPos.class),
                 VPos.BASELINE) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.textOrigin == null ||
                      !node.attributes.textOrigin.isBound();
            }

            @Override
            public StyleableProperty&lt;VPos&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;VPos&gt;)node.textOriginProperty();
            }
         };

         private static final CssMetaData&lt;Text,FontSmoothingType&gt;
             FONT_SMOOTHING_TYPE =
             new CssMetaData&lt;Text,FontSmoothingType&gt;(
                 &quot;-fx-font-smoothing-type&quot;,
                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
                 FontSmoothingType.GRAY) {

            @Override
            public boolean isSettable(Text node) {
                return node.fontSmoothingType == null ||
                       !node.fontSmoothingType.isBound();
            }

            @Override
            public StyleableProperty&lt;FontSmoothingType&gt;
                                 getStyleableProperty(Text node) {

                return (StyleableProperty&lt;FontSmoothingType&gt;)node.fontSmoothingTypeProperty();
            }
         };

         private static final
             CssMetaData&lt;Text,Number&gt; LINE_SPACING =
                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-line-spacing&quot;,
                 SizeConverter.getInstance(), 0) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.lineSpacing == null ||
                      !node.attributes.lineSpacing.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Number&gt;)node.lineSpacingProperty();
            }
         };

         private static final CssMetaData&lt;Text, TextBoundsType&gt;
             BOUNDS_TYPE =
             new CssMetaData&lt;Text,TextBoundsType&gt;(
                 &quot;-fx-bounds-type&quot;,
                 new EnumConverter&lt;TextBoundsType&gt;(TextBoundsType.class),
                 DEFAULT_BOUNDS_TYPE) {

            @Override
            public boolean isSettable(Text node) {
                return node.boundsType == null || !node.boundsType.isBound();
            }

            @Override
            public StyleableProperty&lt;TextBoundsType&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;TextBoundsType&gt;)node.boundsTypeProperty();
            }
         };

     private final static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Shape.getClassCssMetaData());
            styleables.add(FONT);
            styleables.add(UNDERLINE);
            styleables.add(STRIKETHROUGH);
            styleables.add(TEXT_ALIGNMENT);
            styleables.add(TEXT_ORIGIN);
            styleables.add(FONT_SMOOTHING_TYPE);
            styleables.add(LINE_SPACING);
            styleables.add(BOUNDS_TYPE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     *
     * @since JavaFX 8.0
     */


    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    private void updatePGText() {
        final NGText peer = NodeHelper.getPeer(this);
        if (NodeHelper.isDirty(this, DirtyBits.TEXT_ATTRS)) {
            peer.setUnderline(isUnderline());
            peer.setStrikethrough(isStrikethrough());
            FontSmoothingType smoothing = getFontSmoothingType();
            if (smoothing == null) smoothing = FontSmoothingType.GRAY;
            peer.setFontSmoothingType(smoothing.ordinal());
        }
        if (NodeHelper.isDirty(this, DirtyBits.TEXT_FONT)) {
            peer.setFont(getFontInternal());
        }
<A NAME="20"></A>        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.setGlyphs(getRuns());
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#20',2,'match44-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            if (isSpan()) {
                BaseBounds spanBounds = getSpanBounds();
                peer.setLayoutLocation(spanBounds.getMinX(), spanBounds.getMinY());
            } else {
                float x = (float)getX</B></FONT>();
                float y = (float)getY();
                float yadj = getYRendering();
                peer.setLayoutLocation(-x, yadj - y);
            }
        }
        if (NodeHelper.isDirty(this, DirtyBits.TEXT_SELECTION)) {
            Object fillObj = null;
            int start = getSelectionStart();
            int end = getSelectionEnd();
            int length = getTextInternal().length();
            if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
                Paint fill = selectionFillProperty().get();
                fillObj = fill != null ? Toolkit.getPaintAccessor().getPlatformPaint(fill) : null;
            }
            peer.setSelection(start, end, fillObj);
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        updatePGText();
    }

    /***************************************************************************
     *                                                                         *
     *                       Seldom Used Properties                            *
     *                                                                         *
     **************************************************************************/

    private TextAttribute attributes;

    private TextAttribute getTextAttribute() {
        if (attributes == null) {
            attributes = new TextAttribute();
        }
        return attributes;
    }

    private static final VPos DEFAULT_TEXT_ORIGIN = VPos.BASELINE;
    private static final TextBoundsType DEFAULT_BOUNDS_TYPE = TextBoundsType.LOGICAL;
    private static final boolean DEFAULT_UNDERLINE = false;
    private static final boolean DEFAULT_STRIKETHROUGH = false;
    private static final TextAlignment DEFAULT_TEXT_ALIGNMENT = TextAlignment.LEFT;
    private static final double DEFAULT_LINE_SPACING = 0;
    private static final int DEFAULT_CARET_POSITION = -1;
    private static final int DEFAULT_SELECTION_START = -1;
    private static final int DEFAULT_SELECTION_END = -1;
    private static final Color DEFAULT_SELECTION_FILL= Color.WHITE;
    private static final boolean DEFAULT_CARET_BIAS = true;

    private final class TextAttribute {

        private ObjectProperty&lt;VPos&gt; textOrigin;

        final VPos getTextOrigin() {
            return textOrigin == null ? DEFAULT_TEXT_ORIGIN : textOrigin.get();
        }

        public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
            if (textOrigin == null) {
                textOrigin = new StyleableObjectProperty&lt;VPos&gt;(DEFAULT_TEXT_ORIGIN) {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;textOrigin&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.TEXT_ORIGIN;
                    }
                    @Override public void invalidated() {
                        NodeHelper.geomChanged(Text.this);
                    }
                };
            }
            return textOrigin;
        }

        private BooleanProperty underline;

        final boolean isUnderline() {
            return underline == null ? DEFAULT_UNDERLINE : underline.get();
        }

        final BooleanProperty underlineProperty() {
            if (underline == null) {
                underline = new StyleableBooleanProperty() {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;underline&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.UNDERLINE;
                    }
                    @Override public void invalidated() {
                        NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
                        if (getBoundsType() == TextBoundsType.VISUAL) {
                            NodeHelper.geomChanged(Text.this);
                        }
                    }
                };
            }
            return underline;
        }

        private BooleanProperty strikethrough;

        final boolean isStrikethrough() {
            return strikethrough == null ? DEFAULT_STRIKETHROUGH : strikethrough.get();
        }

        final BooleanProperty strikethroughProperty() {
            if (strikethrough == null) {
                strikethrough = new StyleableBooleanProperty() {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;strikethrough&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.STRIKETHROUGH;
                    }
                    @Override public void invalidated() {
                        NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
                        if (getBoundsType() == TextBoundsType.VISUAL) {
                            NodeHelper.geomChanged(Text.this);
                        }
                    }
                };
            }
            return strikethrough;
        }

        private ObjectProperty&lt;TextAlignment&gt; textAlignment;

        final TextAlignment getTextAlignment() {
            return textAlignment == null ? DEFAULT_TEXT_ALIGNMENT : textAlignment.get();
        }

        final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
            if (textAlignment == null) {
                textAlignment =
                    new StyleableObjectProperty&lt;TextAlignment&gt;(DEFAULT_TEXT_ALIGNMENT) {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;textAlignment&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.TEXT_ALIGNMENT;
                    }
                    @Override public void invalidated() {
                        if (!isSpan()) {
                            TextAlignment alignment = get();
                            if (alignment == null) {
                                alignment = DEFAULT_TEXT_ALIGNMENT;
                            }
                            TextLayout layout = getTextLayout();
                            if (layout.setAlignment(alignment.ordinal())) {
                                needsTextLayout();
                            }
                        }
                    }
                };
            }
            return textAlignment;
        }

        private DoubleProperty lineSpacing;

        final double getLineSpacing() {
            return lineSpacing == null ? DEFAULT_LINE_SPACING : lineSpacing.get();
        }

        final DoubleProperty lineSpacingProperty() {
            if (lineSpacing == null) {
                lineSpacing =
                    new StyleableDoubleProperty(DEFAULT_LINE_SPACING) {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;lineSpacing&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.LINE_SPACING;
                    }
                    @Override public void invalidated() {
                        if (!isSpan()) {
                            TextLayout layout = getTextLayout();
                            if (layout.setLineSpacing((float)get())) {
                                needsTextLayout();
                            }
                        }
                    }
                };
            }
            return lineSpacing;
        }

        private ReadOnlyDoubleWrapper baselineOffset;

        final ReadOnlyDoubleProperty baselineOffsetProperty() {
            if (baselineOffset == null) {
                baselineOffset = new ReadOnlyDoubleWrapper(Text.this, &quot;baselineOffset&quot;) {
                    {bind(new DoubleBinding() {
                        {bind(fontProperty());}
                        @Override protected double computeValue() {
                            /* This method should never be used for spans.
                             * If it is, it will still returns the ascent
                             * for the first line in the layout */
                            BaseBounds bounds = getLogicalBounds();
                            return -bounds.getMinY();
                        }
                    });}
                };
            }
            return baselineOffset.getReadOnlyProperty();
        }

        private ObjectProperty&lt;PathElement[]&gt; selectionShape;
        private ObjectBinding&lt;PathElement[]&gt; selectionBinding;

        final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
            if (selectionShape == null) {
                selectionBinding = new ObjectBinding&lt;PathElement[]&gt;() {
                    {bind(selectionStartProperty(), selectionEndProperty());}
                    @Override protected PathElement[] computeValue() {
                        int start = getSelectionStart();
                        int end = getSelectionEnd();
                        return getRange(start, end, TextLayout.TYPE_TEXT);
                    }
              };
              selectionShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;selectionShape&quot;);
              selectionShape.bind(selectionBinding);
            }
            return selectionShape;
        }

        private ObjectProperty&lt;Paint&gt; selectionFill;

        final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
            if (selectionFill == null) {
                selectionFill =
                    new ObjectPropertyBase&lt;Paint&gt;(DEFAULT_SELECTION_FILL) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;selectionFill&quot;; }
                        @Override protected void invalidated() {
                            NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
                        }
                    };
            }
            return selectionFill;
        }

        private IntegerProperty selectionStart;

        final int getSelectionStart() {
            return selectionStart == null ? DEFAULT_SELECTION_START : selectionStart.get();
        }

        final IntegerProperty selectionStartProperty() {
            if (selectionStart == null) {
                selectionStart =
                    new IntegerPropertyBase(DEFAULT_SELECTION_START) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;selectionStart&quot;; }
                        @Override protected void invalidated() {
                            NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
                            notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
                        }
                };
            }
            return selectionStart;
        }

        private IntegerProperty selectionEnd;

        final int getSelectionEnd() {
            return selectionEnd == null ? DEFAULT_SELECTION_END : selectionEnd.get();
        }

        final IntegerProperty selectionEndProperty() {
            if (selectionEnd == null) {
                selectionEnd =
                    new IntegerPropertyBase(DEFAULT_SELECTION_END) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;selectionEnd&quot;; }
                        @Override protected void invalidated() {
                            NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
                            notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
                        }
                    };
            }
            return selectionEnd;
        }

        private ObjectProperty&lt;PathElement[]&gt; caretShape;
        private ObjectBinding&lt;PathElement[]&gt; caretBinding;

        final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
            if (caretShape == null) {
                caretBinding = new ObjectBinding&lt;PathElement[]&gt;() {
                    {bind(caretPositionProperty(), caretBiasProperty());}
                    @Override protected PathElement[] computeValue() {
                        int pos = getCaretPosition();
                        int length = getTextInternal().length();
                        if (0 &lt;= pos &amp;&amp; pos &lt;= length) {
                            boolean bias = isCaretBias();
                            float x = (float)getX();
                            float y = (float)getY() - getYRendering();
                            TextLayout layout = getTextLayout();
                            return layout.getCaretShape(pos, bias, x, y);
                        }
                        return EMPTY_PATH_ELEMENT_ARRAY;
                    }
                };
                caretShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;caretShape&quot;);
                caretShape.bind(caretBinding);
            }
            return caretShape;
        }

        private IntegerProperty caretPosition;

        final int getCaretPosition() {
            return caretPosition == null ? DEFAULT_CARET_POSITION : caretPosition.get();
        }

        final IntegerProperty caretPositionProperty() {
            if (caretPosition == null) {
                caretPosition =
                    new IntegerPropertyBase(DEFAULT_CARET_POSITION) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;caretPosition&quot;; }
                        @Override protected void invalidated() {
                            notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
                        }
                    };
            }
            return caretPosition;
        }

        private BooleanProperty caretBias;

        final boolean isCaretBias() {
            return caretBias == null ? DEFAULT_CARET_BIAS : caretBias.get();
        }

        final BooleanProperty caretBiasProperty() {
            if (caretBias == null) {
                caretBias =
                        new SimpleBooleanProperty(Text.this, &quot;caretBias&quot;, DEFAULT_CARET_BIAS);
            }
            return caretBias;
        }
    }

    /**
     * Returns a string representation of this {@code Text} object.
     * @return a string representation of this {@code Text} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Text[&quot;);

        String id = getId();
        if (id != null) {
            sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
        }

        sb.append(&quot;text=\&quot;&quot;).append(getText()).append(&quot;\&quot;&quot;);
        sb.append(&quot;, x=&quot;).append(getX());
        sb.append(&quot;, y=&quot;).append(getY());
        sb.append(&quot;, alignment=&quot;).append(getTextAlignment());
        sb.append(&quot;, origin=&quot;).append(getTextOrigin());
        sb.append(&quot;, boundsType=&quot;).append(getBoundsType());

        double spacing = getLineSpacing();
        if (spacing != DEFAULT_LINE_SPACING) {
            sb.append(&quot;, lineSpacing=&quot;).append(spacing);
        }

        double wrap = getWrappingWidth();
        if (wrap != 0) {
            sb.append(&quot;, wrappingWidth=&quot;).append(wrap);
        }

        sb.append(&quot;, font=&quot;).append(getFont());
        sb.append(&quot;, fontSmoothingType=&quot;).append(getFontSmoothingType());

        if (isStrikethrough()) {
            sb.append(&quot;, strikethrough&quot;);
        }
        if (isUnderline()) {
            sb.append(&quot;, underline&quot;);
        }

        sb.append(&quot;, fill=&quot;).append(getFill());

        Paint stroke = getStroke();
        if (stroke != null) {
            sb.append(&quot;, stroke=&quot;).append(stroke);
            sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
        }

        return sb.append(&quot;]&quot;).toString();
    }

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
                return getText();
            }
            case FONT: return getFont();
            case CARET_OFFSET: {
                int sel = getCaretPosition();
                if (sel &gt;=  0) return sel;
                return getText().length();
            }
            case SELECTION_START: {
                int sel = getSelectionStart();
                if (sel &gt;=  0) return sel;
                sel = getCaretPosition();
                if (sel &gt;=  0) return sel;
                return getText().length();
            }
            case SELECTION_END:  {
                int sel = getSelectionEnd();
                if (sel &gt;=  0) return sel;
                sel = getCaretPosition();
                if (sel &gt;=  0) return sel;
                return getText().length();
            }
            case LINE_FOR_OFFSET: {
                int offset = (Integer)parameters[0];
                if (offset &gt; getTextInternal().length()) return null;
                TextLine[] lines = getTextLayout().getLines();
                int lineIndex = 0;
                for (int i = 1; i &lt; lines.length; i++) {
                    TextLine line = lines[i];
                    if (line.getStart() &gt; offset) break;
                    lineIndex++;
                }
                return lineIndex;
            }
            case LINE_START: {
                int lineIndex = (Integer)parameters[0];
                TextLine[] lines = getTextLayout().getLines();
                if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
                    TextLine line = lines[lineIndex];
                    return line.getStart();
                }
                return null;
            }
            case LINE_END: {
                int lineIndex = (Integer)parameters[0];
                TextLine[] lines = getTextLayout().getLines();
                if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
                    TextLine line = lines[lineIndex];
                    return line.getStart() + line.getLength();
                }
                return null;
            }
            case OFFSET_AT_POINT: {
                Point2D point = (Point2D)parameters[0];
                point = screenToLocal(point);
                return hitTest(point).getCharIndex();
            }
            case BOUNDS_FOR_RANGE: {
                int start = (Integer)parameters[0];
                int end = (Integer)parameters[1];
                PathElement[] elements = rangeShape(start, end + 1);
                /* Each bounds is defined by a MoveTo (top-left) followed by
                 * 4 LineTo (to top-right, bottom-right, bottom-left, back to top-left).
                 */
                Bounds[] bounds = new Bounds[elements.length / 5];
                int index = 0;
                for (int i = 0; i &lt; bounds.length; i++) {
                    MoveTo topLeft = (MoveTo)elements[index];
                    LineTo topRight = (LineTo)elements[index+1];
                    LineTo bottomRight = (LineTo)elements[index+2];
                    BoundingBox b = new BoundingBox(topLeft.getX(), topLeft.getY(),
                                                    topRight.getX() - topLeft.getX(),
                                                    bottomRight.getY() - topRight.getY());
                    bounds[i] = localToScreen(b);
                    index += 5;
                }
                return bounds;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Transform.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import java.util.Iterator;

import com.sun.javafx.geometry.BoundsUtils;
import javafx.event.EventDispatchChain;

import javafx.scene.Node;

import com.sun.javafx.util.WeakReferenceQueue;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.event.EventHandlerManager;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.scene.transform.TransformUtils;
import java.lang.ref.SoftReference;
import javafx.beans.InvalidationListener;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;

// PENDING_DOC_REVIEW of this whole class
/**
 * This class is a base class for different affine transformations.
 * It provides factory methods for the simple transformations - rotating,
 * scaling, shearing, and translation. It allows to get the transformation
 * matrix elements for any transform.
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;{@code
 *  Rectangle rect = new Rectangle(50,50, Color.RED);
 *  rect.getTransforms().add(new Rotate(45,0,0)); //rotate by 45 degrees
 * }&lt;/pre&gt;
 * @since JavaFX 2.0
 */
public abstract class Transform implements Cloneable, EventTarget {

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        TransformHelper.setTransformAccessor(new TransformHelper.TransformAccessor() {

            @Override
            public void add(Transform transform, Node node) {
                transform.add(node);
            }

            @Override
            public void remove(Transform transform, Node node) {
                transform.remove(node);
            }

            @Override
            public void apply(Transform transform, Affine3D affine3D) {
                transform.apply(affine3D);
            }

            @Override
            public BaseTransform derive(Transform transform, BaseTransform baseTransform) {
                return transform.derive(baseTransform);
            }

            @Override
            public Transform createImmutableTransform() {
                return Transform.createImmutableTransform();
            }

            @Override
            public Transform createImmutableTransform(
                    double mxx, double mxy, double mxz, double tx,
                    double myx, double myy, double myz, double ty,
                    double mzx, double mzy, double mzz, double tz) {
                return Transform.createImmutableTransform(mxx, mxy, mxz, tx,
                        myx, myy, myz, ty, mzx, mzy, mzz, tz);
            }

            @Override
            public Transform createImmutableTransform(Transform transform,
                    double mxx, double mxy, double mxz, double tx,
                    double myx, double myy, double myz, double ty,
                    double mzx, double mzy, double mzz, double tz) {
                return Transform.createImmutableTransform(transform,
                        mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz);
            }

            @Override
            public Transform createImmutableTransform(Transform transform,
                    Transform left, Transform right) {
                return Transform.createImmutableTransform(transform, left, right);
            }
        });
    }

    /* *************************************************************************
     *                                                                         *
     *                            Factories                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a new {@code Affine} object from 12 number
     * values representing the 6 specifiable entries of the 3x4
     * Affine transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x4 matrix
     * @param myx the Y coordinate shearing element of the 3x4 matrix
     * @param mxy the X coordinate shearing element of the 3x4 matrix
     * @param myy the Y coordinate scaling element of the 3x4 matrix
     * @param tx the X coordinate translation element of the 3x4 matrix
     * @param ty the Y coordinate translation element of the 3x4 matrix
<A NAME="41"></A>     * @return a new {@code Affine} object derived from specified parameters
     */
    public static Affine affine(
        double mxx, double myx, double mxy, <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#41',2,'match44-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>double myy, double tx, double ty) {
        final Affine affine = new Affine();
        affine.setMxx(mxx);
        affine.setMxy(mxy);
        affine.setTx(tx);
        affine.setMyx(myx);
        affine.setMyy(myy);
        affine.setTy(ty);
        return affine;
    }


    /**
     * Returns a new {@code Affine} object from 12 number
     * values representing the 12 specifiable entries of the 3x4
     * Affine transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x4 matrix
     * @param mxy the XY element of the 3x4 matrix
     * @param mxz the XZ element of the 3x4 matrix
     * @param tx the X coordinate translation element of the 3x4 matrix
     * @param myx the YX element of the 3x4 matrix
     * @param myy the Y coordinate scaling element of the 3x4 matrix
     * @param myz the YZ element of the 3x4 matrix
     * @param ty the Y coordinate translation element of the 3x4 matrix
     * @param mzx the ZX element of the 3x4 matrix
     * @param mzy the ZY element of the 3x4 matrix
     * @param mzz the Z coordinate scaling element of the 3x4 matrix
     * @param tz the Z coordinate translation element of the 3x4 matrix
     * @return a new {@code Affine} object derived from specified parameters
     */
    public static Affine affine(
        double mxx, double mxy</B></FONT>, double mxz, double tx,
        double myx, double myy, double myz, double ty,
        double mzx, double mzy, double mzz, double tz) {
        final Affine affine = new Affine();
        affine.setMxx(mxx);
        affine.setMxy(mxy);
        affine.setMxz(mxz);
        affine.setTx(tx);
        affine.setMyx(myx);
        affine.setMyy(myy);
        affine.setMyz(myz);
        affine.setTy(ty);
        affine.setMzx(mzx);
        affine.setMzy(mzy);
        affine.setMzz(mzz);
        affine.setTz(tz);
        return affine;
    }


    /**
     * Returns a {@code Translate} object representing a translation transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Translate(x, y);
     * &lt;/pre&gt;
     * @param x the translate x value
     * @param y the translate y value
     * @return the Translate object representing a translation transformation
     */
    public static Translate translate(double x, double y) {
        final Translate translate = new Translate();
        translate.setX(x);
        translate.setY(y);
        return translate;
    }


    /**
     * Returns a {@code Rotate} object that rotates coordinates around a pivot
     * point.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Rotate(angle, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param angle the rotation angle
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Rotate object that rotates coordinates around a pivot point
     */
    public static Rotate rotate(double angle, double pivotX, double pivotY) {
        final Rotate rotate = new Rotate();
        rotate.setAngle(angle);
        rotate.setPivotX(pivotX);
        rotate.setPivotY(pivotY);
        return rotate;
    }


    /**
     * Returns a {@code Scale} object representing a scaling transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Scale(x, y);
     * &lt;/pre&gt;
     * @param x the scale x value
     * @param y the scale y value
     * @return the Scale object representing a scaling transformation
     */
    public static Scale scale(double x, double y) {
        final Scale scale = new Scale();
        scale.setX(x);
        scale.setY(y);
        return scale;
    }


    /**
     * Returns a {@code Scale} object representing a scaling transformation.
     * The returned scale operation will be about the given pivot point.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Scale(x, y, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param x the scale x value
     * @param y the scale y value
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Scale object representing a scaling transformation
     */
    public static Scale scale(double x, double y, double pivotX, double pivotY) {
        final Scale scale = new Scale();
        scale.setX(x);
        scale.setY(y);
        scale.setPivotX(pivotX);
        scale.setPivotY(pivotY);
        return scale;
    }


    /**
     * Returns a {@code Shear} object representing a shearing transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Shear(x, y);
     * &lt;/pre&gt;
     * @param x the shear x value
     * @param y the shear y value
     * @return the Shear object representing a shearing transformation
     */
    public static Shear shear(double x, double y) {
        final Shear shear = new Shear();
        shear.setX(x);
        shear.setY(y);
        return shear;
    }

    /**
     * Returns a {@code Shear} object representing a shearing transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Shear(x, y, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param x the shear x value
     * @param y the shear y value
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Shear object representing a shearing transformation
     */
    public static Shear shear(double x, double y, double pivotX, double pivotY) {
        final Shear shear = new Shear();
        shear.setX(x);
        shear.setY(y);
        shear.setPivotX(pivotX);
        shear.setPivotY(pivotY);
        return shear;
    }

    /**
     * For transforms with expensive inversion we cache the inverted matrix
     * once it is needed and computed for some operation.
     */
    private SoftReference&lt;Transform&gt; inverseCache = null;

    private WeakReferenceQueue nodes = new WeakReferenceQueue();

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the X coordinate scaling element of the 3x4 matrix.
     *
     * @return the X coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxx() {
        return 1.0;
    }

    /**
     * Gets the XY coordinate element of the 3x4 matrix.
     *
     * @return the XY coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxy() {
        return 0.0;
    }

    /**
     * Gets the XZ coordinate element of the 3x4 matrix.
     *
     * @return the XZ coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxz() {
        return 0.0;
    }

    /**
     * Gets the X coordinate translation element of the 3x4 matrix.
     *
     * @return the X coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTx() {
        return 0.0;
    }

    /**
     * Gets the YX coordinate element of the 3x4 matrix.
     *
     * @return the YX coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyx() {
        return 0.0;
    }

    /**
     * Gets the Y coordinate scaling element of the 3x4 matrix.
     *
     * @return the Y coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyy() {
        return 1.0;
    }

    /**
     * Gets the YZ coordinate element of the 3x4 matrix.
     *
     * @return the YZ coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyz() {
        return 0.0;
    }

    /**
     * Gets the Y coordinate translation element of the 3x4 matrix.
     *
     * @return the Y coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTy() {
        return 0.0;
    }

    /**
     * Gets the ZX coordinate element of the 3x4 matrix.
     *
     * @return the ZX coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzx() {
        return 0.0;
    }

    /**
     * Gets the ZY coordinate element of the 3x4 matrix.
     *
     * @return the ZY coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzy() {
        return 0.0;
    }

    /**
     * Gets the Z coordinate scaling element of the 3x4 matrix.
     *
     * @return the Z coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzz() {
        return 1.0;
    }

    /**
     * Gets the Z coordinate translation element of the 3x4 matrix.
     *
     * @return the Z coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTz() {
        return 0.0;
    }

    /**
     * Gets the specified element of the transformation matrix.
     * @param type type of matrix to get the value from
     * @param row zero-based row number
     * @param column zero-based column number
     * @return value of the specified transformation matrix element
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the indices are not within
     *         the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double getElement(MatrixType type, int row, int column) {
        if (row &lt; 0 || row &gt;= type.rows() || column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
                    + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
        }
        switch(type) {
            case MT_2D_2x3:
                // fall-through
            case MT_2D_3x3:
                if (!isType2D()) {
                    throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                            + &quot;of a 3D transform&quot;);
                }
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: return getMxx();
                            case 1: return getMxy();
                            case 2: return getTx();
                        }
                    case 1:
                        switch(column) {
                            case 0: return getMyx();
                            case 1: return getMyy();
                            case 2: return getTy();
                        }
                    case 2:
                        switch(column) {
                            case 0: return 0.0;
                            case 1: return 0.0;
                            case 2: return 1.0;
                        }
                }
                break;
            case MT_3D_3x4:
                // fall-through
            case MT_3D_4x4:
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: return getMxx();
                            case 1: return getMxy();
                            case 2: return getMxz();
                            case 3: return getTx();
                        }
                    case 1:
                        switch(column) {
                            case 0: return getMyx();
                            case 1: return getMyy();
                            case 2: return getMyz();
                            case 3: return getTy();
                        }
                    case 2:
                        switch(column) {
                            case 0: return getMzx();
                            case 1: return getMzy();
                            case 2: return getMzz();
                            case 3: return getTz();
                        }
                    case 3:
                        switch(column) {
                            case 0: return 0.0;
                            case 1: return 0.0;
                            case 2: return 0.0;
                            case 3: return 1.0;
                        }
                }
                break;
        }
        // cannot reach here
        throw new InternalError(&quot;Unsupported matrix type &quot; + type);
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Computes if this transform is currently a 2D transform (has no effect
     * in the direction of Z axis).
     * Used by the subclasses to effectively provide value of the type2D
     * property.
     * @return true if this transform is currently 2D-only
     */
    boolean computeIs2D() {
        return getMxz() == 0.0 &amp;&amp; getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp;
                    getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
    }

    /**
     * Computes if this transform is currently an identity (has
     * no effect in any direction).
     * Used by the subclasses to effectively provide value of the identity
     * property.
     * @return true if this transform is currently an identity transform
     */
    boolean computeIsIdentity() {
        return
            getMxx() == 1.0 &amp;&amp; getMxy() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getTx() == 0.0 &amp;&amp;
            getMyx() == 0.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMyz() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp;
            getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
    }

    /**
     * Computes determinant of the transformation matrix.
     * Among other things, determinant can be used for testing this transform's
     * invertibility - it is invertible if determinant is not equal to zero.
     * @return Determinant of the transformation matrix
     * @since JavaFX 8.0
     */
    public double determinant() {
        final double myx = getMyx();
        final double myy = getMyy();
        final double myz = getMyz();
        final double mzx = getMzx();
        final double mzy = getMzy();
        final double mzz = getMzz();

        return (getMxx() * (myy * mzz - mzy * myz) +
                getMxy() * (myz * mzx - mzz * myx) +
                getMxz() * (myx * mzy - mzx * myy));
    }

    /**
     * Determines if this is currently a 2D transform.
     * Transform is 2D if it has no effect along the Z axis.
     * @since JavaFX 8.0
     */
    private LazyBooleanProperty type2D;

    public final boolean isType2D() {
        return type2D == null ? computeIs2D() : type2D.get();
    }

    public final ReadOnlyBooleanProperty type2DProperty() {
        if (type2D == null) {
            type2D = new LazyBooleanProperty() {

                @Override
                protected boolean computeValue() {
                    return computeIs2D();
                }

                @Override
                public Object getBean() {
                    return Transform.this;
                }

                @Override
                public String getName() {
                    return &quot;type2D&quot;;
                }
            };
        }
        return type2D;
    }

    /**
     * Determines if this is currently an identity transform.
     * Identity transform has no effect on the transformed nodes.
     * @since JavaFX 8.0
     */
    private LazyBooleanProperty identity;

    public final boolean isIdentity() {
        return identity == null ? computeIsIdentity() : identity.get();
    }

    public final ReadOnlyBooleanProperty identityProperty() {
        if (identity == null) {
            identity = new LazyBooleanProperty() {

                @Override
                protected boolean computeValue() {
                    return computeIsIdentity();
                }

                @Override
                public Object getBean() {
                    return Transform.this;
                }

                @Override
                public String getName() {
                    return &quot;identity&quot;;
                }
            };
        }
        return identity;
    }

    /**
     * Lazily computed read-only boolean property implementation.
     * Used for type2D and identity properties.
     */
    private static abstract class LazyBooleanProperty
            extends ReadOnlyBooleanProperty {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;
        private boolean value;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public boolean get() {
            if (!valid) {
                value = computeValue();
                valid = true;
            }

            return value;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract boolean computeValue();
    }

    /**
     * Transforms the specified point by this transform and by the specified
     * transform and returns distance of the result points. Used for similarTo
     * method. Has to be used only for 2D transforms (otherwise throws an
     * exception).
     * @param t the other transform
     * @param x point's X coordinate
     * @param y point's Y coordinate
     * @return distance of the transformed points
     */
    private double transformDiff(Transform t, double x, double y) {
        final Point2D byThis = transform(x, y);
        final Point2D byOther = t.transform(x, y);
        return byThis.distance(byOther);
    }

    /**
     * Transforms the specified point by this transform and by the specified
     * transform and returns distance of the result points. Used for similarTo
     * method.
     * @param t the other transform
     * @param x point's X coordinate
     * @param y point's Y coordinate
     * @param z point's Z coordinate
     * @return distance of the transformed points
     */
    private double transformDiff(Transform t, double x, double y, double z) {
        final Point3D byThis = transform(x, y, z);
        final Point3D byOther = t.transform(x, y, z);
        return byThis.distance(byOther);
    }

    /**
     * Checks if this transform is similar to the specified transform.
     * The two transforms are considered similar if any point from
     * {@code range} is transformed by them to points that are no farther
     * than {@code maxDelta} from each other.
     * @param transform transform to be compared to this transform
     * @param range region of interest on which the two transforms are compared
     * @param maxDelta maximum allowed distance for the results of transforming
     *                 any single point from {@code range} by the two transforms
     * @return true if the transforms are similar according to the specified
     *              criteria
     * @throws NullPointerException if the specified {@code transform}
     *         or {@code range} is null
     * @since JavaFX 8.0
     */
    public boolean similarTo(Transform transform, Bounds range, double maxDelta) {

        double cornerX, cornerY, cornerZ;

        if (isType2D() &amp;&amp; transform.isType2D()) {
            cornerX = range.getMinX();
            cornerY = range.getMinY();

            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerX = range.getMaxX();
            cornerY = range.getMinY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            return true;
        }

        cornerX = range.getMinX();
        cornerY = range.getMinY();
        cornerZ = range.getMinZ();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerY = range.getMaxY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerX = range.getMaxX();
        cornerY = range.getMinY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerY = range.getMaxY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        if (range.getDepth() != 0.0) {
            cornerX = range.getMinX();
            cornerY = range.getMinY();
            cornerZ = range.getMaxZ();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerX = range.getMaxX();
            cornerY = range.getMinY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }
        }

        return true;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Core of the toArray implementation for the 2D case.
     * All of the checks has been made by the enclosing method as well as
     * the constant elements filled, this method only fills the varying
     * elements to the array. Used by subclasses to fill
     * the elements efficiently.
     * @param array array to be filled with the 6 2D elements
     */
    void fill2DArray(double[] array) {
        array[0] = getMxx();
        array[1] = getMxy();
        array[2] = getTx();
        array[3] = getMyx();
        array[4] = getMyy();
        array[5] = getTy();
    }

    /**
     * Core of the toArray implementation for the 3D case.
     * All of the checks has been made by the enclosing method as well as
     * the constant elements filled, this method only fills the varying
     * elements to the array. Used by subclasses to fill
     * the elements efficiently.
     * @param array array to be filled with the 12 3D elements
     */
    void fill3DArray(double[] array) {
        array[0] = getMxx();
        array[1] = getMxy();
        array[2] = getMxz();
        array[3] = getTx();
        array[4] = getMyx();
        array[5] = getMyy();
        array[6] = getMyz();
        array[7] = getTy();
        array[8] = getMzx();
        array[9] = getMzy();
        array[10] = getMzz();
        array[11] = getTz();
    }

    /**
     * Returns an array containing the flattened transformation matrix.
     * If the requested matrix type fits in the specified array, it is returned
     * therein. Otherwise, a new array is created.
     * @param type matrix type to be filled in the array
     * @param array array into which the elements of the matrix are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the elements of the requested matrix type
     *         representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] toArray(MatrixType type, double[] array) {
        checkRequestedMAT(type);

        if (array == null || array.length &lt; type.elements()) {
            array = new double[type.elements()];
        }

        switch (type) {
            case MT_2D_3x3:
                array[6] = 0.0;
                array[7] = 0.0;
                array[8] = 1.0;
                // fall-through
            case MT_2D_2x3:
                fill2DArray(array);
                break;
            case MT_3D_4x4:
                array[12] = 0.0;
                array[13] = 0.0;
                array[14] = 0.0;
                array[15] = 1.0;
                // fall-through
            case MT_3D_3x4:
                fill3DArray(array);
                break;
            default:
                throw new InternalError(&quot;Unsupported matrix type &quot; + type);
        }

        return array;
    }

    /**
     * Returns an array containing the flattened transformation matrix.
     * @param type matrix type to be filled in the array
     * @return an array containing the elements of the requested matrix type
     *         representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] toArray(MatrixType type) {
        return toArray(type, null);
    }

    /**
     * Returns an array containing a row of the transformation matrix.
     * If the row of the requested matrix type fits in the specified array,
     * it is returned therein. Otherwise, a new array is created.
     * @param type matrix type whose row is to be filled in the array
     * @param row zero-based index of the row
     * @param array array into which the elements of the row are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the requested row of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code row} index is not within
     *         the number of rows of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] row(MatrixType type, int row, double[] array) {

        checkRequestedMAT(type);

        if (row &lt; 0 || row &gt;= type.rows()) {
            throw new IndexOutOfBoundsException(
                    &quot;Cannot get row &quot; + row + &quot; from &quot; + type);
        }

        if (array == null || array.length &lt; type.columns()) {
            array = new double[type.columns()];
        }

        switch(type) {
            case MT_2D_2x3:
            case MT_2D_3x3:
                switch (row) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMxy();
                        array[2] = getTx();
                        break;
                    case 1:
                        array[0] = getMyx();
                        array[1] = getMyy();
                        array[2] = getTy();
                        break;
                    case 2:
                        array[0] = 0.0;
                        array[1] = 0.0;
                        array[2] = 1.0;
                        break;
                }
                break;
            case MT_3D_3x4:
            case MT_3D_4x4:
                switch (row) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMxy();
                        array[2] = getMxz();
                        array[3] = getTx();
                        break;
                    case 1:
                        array[0] = getMyx();
                        array[1] = getMyy();
                        array[2] = getMyz();
                        array[3] = getTy();
                        break;
                    case 2:
                        array[0] = getMzx();
                        array[1] = getMzy();
                        array[2] = getMzz();
                        array[3] = getTz();
                        break;
                    case 3:
                        array[0] = 0.0;
                        array[1] = 0.0;
                        array[2] = 0.0;
                        array[3] = 1.0;
                        break;
                }
                break;
            default:
                throw new InternalError(&quot;Unsupported row &quot; + row + &quot; of &quot; + type);
        }
        return array;
    }

    /**
     * Returns an array containing a row of the transformation matrix.
     * @param type matrix type whose row is to be filled in the array
     * @param row zero-based index of the row
     * @return an array containing the requested row of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code row} index is not within
     *         the number of rows of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] row(MatrixType type, int row) {
        return row(type, row, null);
    }

    /**
     * Returns an array containing a column of the transformation matrix.
     * If the column of the requested matrix type fits in the specified array,
     * it is returned therein. Otherwise, a new array is created.
     * @param type matrix type whose column is to be filled in the array
     * @param column zero-based index of the column
     * @param array array into which the elements of the column are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the requested column of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code column} index
     *         is not within the number of columns of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] column(MatrixType type, int column, double[] array) {

        checkRequestedMAT(type);

        if (column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(
                    &quot;Cannot get row &quot; + column + &quot; from &quot; + type);
        }

        if (array == null || array.length &lt; type.rows()) {
            array = new double[type.rows()];
        }

        switch(type) {
            case MT_2D_2x3:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        break;
                    case 2:
                        array[0] = getTx();
                        array[1] = getTy();
                        break;
                }
                break;
            case MT_2D_3x3:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = 0.0;
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = 0.0;
                        break;
                    case 2:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = 1.0;
                        break;
                }
                break;
            case MT_3D_3x4:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = getMzx();
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = getMzy();
                        break;
                    case 2:
                        array[0] = getMxz();
                        array[1] = getMyz();
                        array[2] = getMzz();
                        break;
                    case 3:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = getTz();
                        break;
                }
                break;
            case MT_3D_4x4:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = getMzx();
                        array[3] = 0.0;
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = getMzy();
                        array[3] = 0.0;
                        break;
                    case 2:
                        array[0] = getMxz();
                        array[1] = getMyz();
                        array[2] = getMzz();
                        array[3] = 0.0;
                        break;
                    case 3:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = getTz();
                        array[3] = 1.0;
                        break;
                }
                break;
            default:
                throw new InternalError(&quot;Unsupported column &quot; + column + &quot; of &quot;
                        + type);
        }
        return array;
    }

    /**
     * Returns an array containing a column of the transformation matrix.
     * @param type matrix type whose column is to be filled in the array
     * @param column zero-based index of the column
     * @return an array containing the requested column of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code column} index
     *         is not within the number of columns of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] column(MatrixType type, int column) {
        return column(type, column, null);
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the concatenation of this transform and the specified transform.
     * Applying the resulting transform to a node has the same effect as
     * adding the two transforms to its {@code getTransforms()} list,
     * {@code this} transform first and the specified {@code transform} second.
     * @param transform transform to be concatenated with this transform
     * @return The concatenated transform
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public Transform createConcatenation(Transform transform) {
        final double txx = transform.getMxx();
        final double txy = transform.getMxy();
        final double txz = transform.getMxz();
        final double ttx = transform.getTx();
        final double tyx = transform.getMyx();
        final double tyy = transform.getMyy();
        final double tyz = transform.getMyz();
        final double tty = transform.getTy();
        final double tzx = transform.getMzx();
        final double tzy = transform.getMzy();
        final double tzz = transform.getMzz();
        final double ttz = transform.getTz();
        return new Affine(
            (getMxx() * txx + getMxy() * tyx + getMxz() * tzx),
            (getMxx() * txy + getMxy() * tyy + getMxz() * tzy),
            (getMxx() * txz + getMxy() * tyz + getMxz() * tzz),
            (getMxx() * ttx + getMxy() * tty + getMxz() * ttz + getTx()),
            (getMyx() * txx + getMyy() * tyx + getMyz() * tzx),
            (getMyx() * txy + getMyy() * tyy + getMyz() * tzy),
            (getMyx() * txz + getMyy() * tyz + getMyz() * tzz),
            (getMyx() * ttx + getMyy() * tty + getMyz() * ttz + getTy()),
            (getMzx() * txx + getMzy() * tyx + getMzz() * tzx),
            (getMzx() * txy + getMzy() * tyy + getMzz() * tzy),
            (getMzx() * txz + getMzy() * tyz + getMzz() * tzz),
            (getMzx() * ttx + getMzy() * tty + getMzz() * ttz + getTz()));
    }

    /**
     * Returns the inverse transform of this transform.
     * @return the inverse transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Transform createInverse() throws NonInvertibleTransformException {
        return getInverseCache().clone();
    }

    /**
     * Returns a deep copy of this transform.
     * @return a copy of this transform
     * @since JavaFX 8.0
     */
    @Override
    public Transform clone() {
        return TransformUtils.immutableTransform(this);
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Transforms the specified point by this transform.
     * This method can be used only for 2D transforms.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @return the transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @since JavaFX 8.0
     */
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
            getMxx() * x + getMxy() * y + getTx(),
            getMyx() * x + getMyy() * y + getTy());
    }

    /**
     * Transforms the specified point by this transform.
     * This method can be used only for 2D transforms.
     * @param point the point to be transformed
     * @return the transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D transform(Point2D point) {
        return transform(point.getX(), point.getY());
    }

    /**
     * Transforms the specified point by this transform.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @param z the Z coordinate of the point
     * @return the transformed point
     * @since JavaFX 8.0
     */
    public Point3D transform(double x, double y, double z) {
        return new Point3D(
            getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
            getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
            getMzx() * x + getMzy() * y + getMzz() * z + getTz());
    }

    /**
     * Transforms the specified point by this transform.
     * @param point the point to be transformed
     * @return the transformed point
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D transform(Point3D point) {
        return transform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified bounds by this transform.
     * @param bounds the bounds to be transformed
     * @return the transformed bounds
     * @since JavaFX 8.0
     */
    public Bounds transform(Bounds bounds) {
        if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
            Point2D p1 = transform(bounds.getMinX(), bounds.getMinY());
            Point2D p2 = transform(bounds.getMaxX(), bounds.getMinY());
            Point2D p3 = transform(bounds.getMaxX(), bounds.getMaxY());
            Point2D p4 = transform(bounds.getMinX(), bounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p2 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
        Point3D p3 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p4 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p5 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p6 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p7 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p8 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Core of the transform2DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getMxx();
        final double xy = getMxy();
        final double tx = getTx();
        final double yx = getMyx();
        final double yy = getMyy();
        final double ty = getTy();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + xy * y + tx;
            dstPts[dstOff++] = yx * x + yy * y + ty;
        }
    }

    /**
     * Core of the transform3DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        final double xx = getMxx();
        final double xy = getMxy();
        final double xz = getMxz();
        final double tx = getTx();
        final double yx = getMyx();
        final double yy = getMyy();
        final double yz = getMyz();
        final double ty = getTy();
        final double zx = getMzx();
        final double zy = getMzy();
        final double zz = getMzz();
        final double tz = getTz();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + xy * y + xz * z + tx;
            dstPts[dstOff++] = yx * x + yy * y + yz * z + ty;
            dstPts[dstOff++] = zx * x + zy * y + zz * z + tz;
        }
    }

    /**
     * Transforms an array of coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * This method can be used only for 2D transforms.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void transform2DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
                    + &quot;with a 3D transform&quot;);
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);

        // do the transformations
        transform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of floating point coordinates by this transform.
     * The three coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a tiplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void transform3DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);

        // do the transformations
        transform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms the relative magnitude vector by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @since JavaFX 8.0
     */
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
            getMxx() * x + getMxy() * y,
            getMyx() * x + getMyy() * y);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point2D} instance by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param point the relative magnitude vector
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D deltaTransform(Point2D point) {
        return deltaTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the relative magnitude vector by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @param z vector magnitude in the direction of the Z axis
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @since JavaFX 8.0
     */
    public Point3D deltaTransform(double x, double y, double z) {
        return new Point3D(
            getMxx() * x + getMxy() * y + getMxz() * z,
            getMyx() * x + getMyy() * y + getMyz() * z,
            getMzx() * x + getMzy() * y + getMzz() * z);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point3D} instance by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param point the relative magnitude vector
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D deltaTransform(Point3D point) {
        return deltaTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * This method can be used only for 2D transforms.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @return the inversely transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {

        ensureCanTransform2DPoint();

        return getInverseCache().transform(x, y);
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * This method can be used only for 2D transforms.
     * @param point the point to be transformed
     * @return the inversely transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D inverseTransform(Point2D point)
            throws NonInvertibleTransformException {
        return inverseTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @param z the Z coordinate of the point
     * @return the inversely transformed point
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        return getInverseCache().transform(x, y, z);
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * @param point the point to be transformed
     * @return the inversely transformed point
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D inverseTransform(Point3D point)
            throws NonInvertibleTransformException {
        return inverseTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified bounds by the inverse of this transform.
     * @param bounds the bounds to be transformed
     * @return the inversely transformed bounds
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code bounds} is null
     * @since JavaFX 8.0
     */
    public Bounds inverseTransform(Bounds bounds)
            throws NonInvertibleTransformException {
        if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
            Point2D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY());
            Point2D p2 = inverseTransform(bounds.getMaxX(), bounds.getMinY());
            Point2D p3 = inverseTransform(bounds.getMaxX(), bounds.getMaxY());
            Point2D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p2 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
        Point3D p3 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p5 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p6 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p7 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p8 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);

    }

    /**
     * Core of the inverseTransform2DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        getInverseCache().transform2DPointsImpl(srcPts, srcOff,
                dstPts, dstOff, numPts);
    }

    /**
     * Core of the inverseTransform3DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        getInverseCache().transform3DPointsImpl(srcPts, srcOff,
                dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of coordinates by the inverse of this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * This method can be used only for 2D transforms.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void inverseTransform2DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) throws NonInvertibleTransformException{

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
                    + &quot;with a 3D transform&quot;);
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);

        // do the transformations
        inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of floating point coordinates by the inverse
     * of this transform.
     * The three coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void inverseTransform3DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) throws NonInvertibleTransformException {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);

        // do the transformations
        inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms the relative magnitude vector by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {

        ensureCanTransform2DPoint();

        return getInverseCache().deltaTransform(x, y);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point2D} instance by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param point the relative magnitude vector
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D inverseDeltaTransform(Point2D point)
            throws NonInvertibleTransformException {
        return inverseDeltaTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the relative magnitude vector by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @param z vector magnitude in the direction of the Z axis
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        return getInverseCache().deltaTransform(x, y, z);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point3D} instance by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param point the relative magnitude vector
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D inverseDeltaTransform(Point3D point)
            throws NonInvertibleTransformException {
        return inverseDeltaTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Helper method for transforming arrays of points that deals with
     * overlapping arrays.
     * @return the (if necessary fixed) srcOff
     */
    private int getFixedSrcOffset(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff,
            int numPts, int dimensions) {

        if (dstPts == srcPts &amp;&amp;
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * dimensions)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * dimensions);
            return dstOff;
        }

        return srcOff;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    private EventHandlerManager internalEventDispatcher;
    private EventHandlerManager getInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = new EventHandlerManager(this);
        }
        return internalEventDispatcher;
    }
    private ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
            onTransformChanged;

    @Override
    public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
        return internalEventDispatcher == null
                ? tail : tail.append(getInternalEventDispatcher());
    }

    /**
     * &lt;p&gt;
     * Registers an event handler to this transform. Any event filters are first
     * processed, then the specified onFoo event handlers, and finally any
     * event handlers registered by this method.
     * &lt;/p&gt;&lt;p&gt;
     * Currently the only event delivered to a {@code Transform} is the
     * {@code TransformChangedEvent} with it's single type
     * {@code TRANSFORM_CHANGED}.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .addEventHandler(eventType, eventHandler);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Unregisters a previously registered event handler from this transform.
     * One handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .removeEventHandler(eventType, eventHandler);
    }

    /**
     * &lt;p&gt;
     * Registers an event filter to this transform. Registered event filters get
     * an event before any associated event handlers.
     * &lt;/p&gt;&lt;p&gt;
     * Currently the only event delivered to a {@code Transform} is the
     * {@code TransformChangedEvent} with it's single type
     * {@code TRANSFORM_CHANGED}.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher()
                .addEventFilter(eventType, eventFilter);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Unregisters a previously registered event filter from this transform. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher()
                .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the onTransformChanged event handler which is called whenever
     * the transform changes any of its parameters.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 8.0
     */
    public final void setOnTransformChanged(
            EventHandler&lt;? super TransformChangedEvent&gt; value) {
        onTransformChangedProperty().set(value);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Gets the onTransformChanged event handler.
     * @return the event handler previously set by {@code setOnTransformChanged}
     * method, null if the handler is not set.
     * @since JavaFX 8.0
     */
    public final EventHandler&lt;? super TransformChangedEvent&gt; getOnTransformChanged() {
        return (onTransformChanged == null) ? null : onTransformChanged.get();
    }

    /**
     * The onTransformChanged event handler is called whenever the transform
     * changes any of its parameters.
     * @return the onTransformChanged event handler
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
            onTransformChangedProperty() {
        if (onTransformChanged == null) {

            onTransformChanged = new SimpleObjectProperty&lt;EventHandler
                    &lt;? super TransformChangedEvent&gt;&gt;(this, &quot;onTransformChanged&quot;) {

                @Override protected void invalidated() {
                    getInternalEventDispatcher().setEventHandler(
                            TransformChangedEvent.TRANSFORM_CHANGED, get());
                }
            };
        }

        return onTransformChanged;
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Makes sure the specified matrix type can be requested from this transform.
     * Is used for convenience in various methods that accept
     * the MatrixType argument.
     * @param type matrix type to check
     * @throws IllegalArgumentException if this is a 3D transform and
     *                                  a 2D type is requested
     */
    void checkRequestedMAT(MatrixType type) throws IllegalArgumentException{
        if (type.is2D() &amp;&amp; !isType2D()) {
            throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                    + &quot;for a 3D transform&quot;);
        }
    }

    /**
     * Makes sure this is a 2D transform.
     * Is used for convenience in various 2D point transformation methods.
     * @throws IllegalStateException if this is a 2D transform
     */
    void ensureCanTransform2DPoint() throws IllegalStateException {
        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
                    + &quot;with a 3D transform&quot;);
        }
    }

    /**
     * Needed for the proper delivery of the TransformChangedEvent.
     * If the members are invalid, the transformChanged() notification
     * is not called and the event is not delivered. To avoid that
     * we need to manually validate all properties. Subclasses validate
     * their specific properties.
     */
    void validate() {
        getMxx(); getMxy(); getMxz(); getTx();
        getMyx(); getMyy(); getMyz(); getTy();
        getMzx(); getMzy(); getMzz(); getTz();
    }

    abstract void apply(Affine3D t);

    abstract BaseTransform derive(BaseTransform t);

    void add(final Node node) {
        nodes.add(node);
    }

    void remove(final Node node) {
        nodes.remove(node);
    }

    /**
     * This method must be called by all transforms whenever any of their
     * parameters changes. It is typically called when any of the transform's
     * properties is invalidated (it is OK to skip the call if an invalid
     * property is set).
     * @since JavaFX 8.0
     */
    protected void transformChanged() {
        inverseCache = null;
        final Iterator iterator = nodes.iterator();
        while (iterator.hasNext()) {
            NodeHelper.transformsChanged(((Node) iterator.next()));
        }

        if (type2D != null) {
            type2D.invalidate();
        }

        if (identity != null) {
            identity.invalidate();
        }

        if (internalEventDispatcher != null) {
            // need to validate all properties for the event to be fired next time
            validate();
            Event.fireEvent(this, new TransformChangedEvent(this, this));
        }
    }

    /**
     * Visitor from {@code Affine} class which provides an efficient
     * {@code append} operation for the subclasses.
     * @param a {@code Affine} instance to append to
     */
    void appendTo(Affine a) {
        a.append(getMxx(), getMxy(), getMxz(), getTx(),
                 getMyx(), getMyy(), getMyz(), getTy(),
                 getMzx(), getMzy(), getMzz(), getTz());
    }

    /**
     * Visitor from {@code Affine} class which provides an efficient
     * {@code prepend} operation for the subclasses.
     * @param a {@code Affine} instance to prepend to
     */
    void prependTo(Affine a) {
        a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
                  getMyx(), getMyy(), getMyz(), getTy(),
                  getMzx(), getMzy(), getMzz(), getTz());
    }

    /**
     * &lt;p&gt;
     * Gets the inverse transform cache.
     * &lt;/p&gt;&lt;p&gt;
     * Computing the inverse transform is generally an expensive operation,
     * so once it is needed we cache the result (throwing it away when the
     * transform changes). The subclasses may avoid using the cache if their
     * inverse can be computed quickly on the fly.
     * &lt;/p&gt;&lt;p&gt;
     * This method computes the inverse if the cache is not valid.
     * &lt;/p&gt;
     * @return the cached inverse transformation
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     */
    private Transform getInverseCache() throws NonInvertibleTransformException {
        if (inverseCache == null || inverseCache.get() == null) {
            Affine inv = new Affine(
                    getMxx(), getMxy(), getMxz(), getTx(),
                    getMyx(), getMyy(), getMyz(), getTy(),
                    getMzx(), getMzy(), getMzz(), getTz());
            inv.invert();
            inverseCache = new SoftReference&lt;Transform&gt;(inv);
            return inv;
        }

        return inverseCache.get();
    }

    /**
     * Used only by tests to emulate garbage collecting the soft references
     */
    void clearInverseCache() {
        if (inverseCache != null) {
            inverseCache.clear();
        }
    }

    /**************************************************************************
     *  ImmutableTransform Class and supporting methods
     **************************************************************************/

    static Transform createImmutableTransform() {
        return new ImmutableTransform();
    }

    static Transform createImmutableTransform(
            double mxx, double mxy, double mxz, double tx,
            double myx, double myy, double myz, double ty,
            double mzx, double mzy, double mzz, double tz) {
        return new ImmutableTransform(
                mxx, mxy, mxz, tx,
                myx, myy, myz, ty,
                mzx, mzy, mzz, tz);
    }

    static Transform createImmutableTransform(Transform transform,
            double mxx, double mxy, double mxz, double tx,
            double myx, double myy, double myz, double ty,
            double mzx, double mzy, double mzz, double tz) {
        if (transform == null) {
            return new ImmutableTransform(
                    mxx, mxy, mxz, tx,
                    myx, myy, myz, ty,
                    mzx, mzy, mzz, tz);
        }
        ((Transform.ImmutableTransform) transform).setToTransform(
                mxx, mxy, mxz, tx,
                myx, myy, myz, ty,
                mzx, mzy, mzz, tz);
        return transform;
    }

    static Transform createImmutableTransform(Transform transform,
            Transform left, Transform right) {
        if (transform == null) {
            transform = new ImmutableTransform();
        }
        ((Transform.ImmutableTransform) transform).setToConcatenation(
                (ImmutableTransform) left, (ImmutableTransform) right);
        return transform;
    }

    /**
     * Immutable transformation with performance optimizations based on Affine.
     *
     * From user's perspective, this transform is immutable. However, we can
     * modify it internally. This allows for reusing instances that were
     * not handed to users. The caller is responsible for not modifying
     * user-visible instances.
     *
     * Note: can't override Transform's package private methods so they cannot
     * be optimized. Currently not a big deal.
     */
    static class ImmutableTransform extends Transform {

        private static final int APPLY_IDENTITY = 0;
        private static final int APPLY_TRANSLATE = 1;
        private static final int APPLY_SCALE = 2;
        private static final int APPLY_SHEAR = 4;
        private static final int APPLY_NON_3D = 0;
        private static final int APPLY_3D_COMPLEX = 4;
        private transient int state2d;
        private transient int state3d;

        private double xx;
        private double xy;
        private double xz;
        private double yx;
        private double yy;
        private double yz;
        private double zx;
        private double zy;
        private double zz;
        private double xt;
        private double yt;
        private double zt;

        ImmutableTransform() {
            xx = yy = zz = 1.0;
        }

        ImmutableTransform(Transform transform) {
            this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
                                                                 transform.getTx(),
                 transform.getMyx(), transform.getMyy(), transform.getMyz(),
                                                                 transform.getTy(),
                 transform.getMzx(), transform.getMzy(), transform.getMzz(),
                                                                 transform.getTz());
        }

        ImmutableTransform(double mxx, double mxy, double mxz, double tx,
                      double myx, double myy, double myz, double ty,
                      double mzx, double mzy, double mzz, double tz) {
            xx = mxx;
            xy = mxy;
            xz = mxz;
            xt = tx;

            yx = myx;
            yy = myy;
            yz = myz;
            yt = ty;

            zx = mzx;
            zy = mzy;
            zz = mzz;
            zt = tz;

            updateState();
        }

        // Beware: this is modifying immutable transform!
        // It is private and it is there just for the purpose of reusing
        // instances not given to users
        private void setToTransform(double mxx, double mxy, double mxz, double tx,
                                    double myx, double myy, double myz, double ty,
                                    double mzx, double mzy, double mzz, double tz)
        {
            xx = mxx;
            xy = mxy;
            xz = mxz;
            xt = tx;
            yx = myx;
            yy = myy;
            yz = myz;
            yt = ty;
            zx = mzx;
            zy = mzy;
            zz = mzz;
            zt = tz;
            updateState();
        }

        // Beware: this is modifying immutable transform!
        // It is private and it is there just for the purpose of reusing
        // instances not given to users
        private void setToConcatenation(ImmutableTransform left, ImmutableTransform right) {
            if (left.state3d == APPLY_NON_3D &amp;&amp; right.state3d == APPLY_NON_3D) {
                xx = left.xx * right.xx + left.xy * right.yx;
                xy = left.xx * right.xy + left.xy * right.yy;
                xt = left.xx * right.xt + left.xy * right.yt + left.xt;
                yx = left.yx * right.xx + left.yy * right.yx;
                yy = left.yx * right.xy + left.yy * right.yy;
                yt = left.yx * right.xt + left.yy * right.yt + left.yt;
                if (state3d != APPLY_NON_3D) {
                    xz = yz = zx = zy = zt = 0.0;
                    zz = 1.0;
                    state3d = APPLY_NON_3D;
                }
                updateState2D();
            } else {
                xx = left.xx * right.xx + left.xy * right.yx + left.xz * right.zx;
                xy = left.xx * right.xy + left.xy * right.yy + left.xz * right.zy;
                xz = left.xx * right.xz + left.xy * right.yz + left.xz * right.zz;
                xt = left.xx * right.xt + left.xy * right.yt + left.xz * right.zt + left.xt;
                yx = left.yx * right.xx + left.yy * right.yx + left.yz * right.zx;
                yy = left.yx * right.xy + left.yy * right.yy + left.yz * right.zy;
                yz = left.yx * right.xz + left.yy * right.yz + left.yz * right.zz;
                yt = left.yx * right.xt + left.yy * right.yt + left.yz * right.zt + left.yt;
                zx = left.zx * right.xx + left.zy * right.yx + left.zz * right.zx;
                zy = left.zx * right.xy + left.zy * right.yy + left.zz * right.zy;
                zz = left.zx * right.xz + left.zy * right.yz + left.zz * right.zz;
                zt = left.zx * right.xt + left.zy * right.yt + left.zz * right.zt + left.zt;
                updateState();
            }
            // could be further optimized using the states, but that would
            // require a lot of code (see Affine and all its append* methods)
        }

        @Override
        public double getMxx() {
            return xx;
        }

        @Override
        public double getMxy() {
            return xy;
        }

        @Override
        public double getMxz() {
            return xz;
        }

        @Override
        public double getTx() {
            return xt;
        }

        @Override
        public double getMyx() {
            return yx;
        }

        @Override
        public double getMyy() {
            return yy;
        }

        @Override
        public double getMyz() {
            return yz;
        }

        @Override
        public double getTy() {
            return yt;
        }

        @Override
        public double getMzx() {
            return zx;
        }

        @Override
        public double getMzy() {
            return zy;
        }

        @Override
        public double getMzz() {
            return zz;
        }

        @Override
        public double getTz() {
            return zt;
        }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

        @Override
        public double determinant() {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SHEAR | APPLY_SCALE:
                            return xx * yy - xy * yx;
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            return -(xy* yx);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            return xx * yy;
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return 1.0;
                    }
                case APPLY_TRANSLATE:
                    return 1.0;
                case APPLY_SCALE:
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return xx * yy * zz;
                case APPLY_3D_COMPLEX:
                    return (xx* (yy * zz - zy * yz) +
                            xy* (yz * zx - zz * yx) +
                            xz* (yx * zy - zx * yy));
            }
        }

        @Override
        public Transform createConcatenation(Transform transform) {
            javafx.scene.transform.Affine a = new Affine(this);
            a.append(transform);
            return a;
        }

        @Override
        public javafx.scene.transform.Affine createInverse() throws NonInvertibleTransformException {
            javafx.scene.transform.Affine t = new Affine(this);
            t.invert();
            return t;
        }

        @Override
        public Transform clone() {
            return new ImmutableTransform(this);
        }

        /* *************************************************************************
         *                                                                         *
         *                     Transform, Inverse Transform                        *
         *                                                                         *
         **************************************************************************/

        @Override
        public Point2D transform(double x, double y) {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point2D(
                        xx * x + xy * y + xt,
                        yx * x + yy * y + yt);
                case APPLY_SHEAR | APPLY_SCALE:
                    return new Point2D(
                        xx * x + xy * y,
                        yx * x + yy * y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                    return new Point2D(
                            xy * y + xt,
                            yx * x + yt);
                case APPLY_SHEAR:
                    return new Point2D(xy * y, yx * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point2D(
                            xx * x + xt,
                            yy * y + yt);
                case APPLY_SCALE:
                    return new Point2D(xx * x, yy * y);
                case APPLY_TRANSLATE:
                    return new Point2D(x + xt, y + yt);
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D transform(double x, double y, double z) {
            switch (state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                            return new Point3D(
                                xx * x + xy * y + xt,
                                yx * x + yy * y + yt, z);
                        case APPLY_SHEAR | APPLY_SCALE:
                            return new Point3D(
                                xx * x + xy * y,
                                yx * x + yy * y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                            return new Point3D(
                                    xy * y + xt, yx * x + yt,
                                    z);
                        case APPLY_SHEAR:
                            return new Point3D(xy * y, yx * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                            return new Point3D(
                                    xx * x + xt, yy * y + yt,
                                    z);
                        case APPLY_SCALE:
                            return new Point3D(xx * x, yy * y, z);
                        case APPLY_TRANSLATE:
                            return new Point3D(x + xt, y + yt, z);
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x + xt, y + yt, z + zt);
                case APPLY_SCALE:
                    return new Point3D(xx * x, yy * y, zz * z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point3D(
                            xx * x + xt,
                            yy * y + yt,
                            zz * z + zt);
                case APPLY_3D_COMPLEX:
                    return new Point3D(
                        xx * x + xy * y + xz * z + xt,
                        yx * x + yy * y + yz * z + yt,
                        zx * x + zy * y + zz * z + zt);
            }
        }

        @Override
        public Point2D deltaTransform(double x, double y) {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SHEAR | APPLY_SCALE:
                    return new Point2D(
                        xx * x + xy * y,
                        yx * x + yy * y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                case APPLY_SHEAR:
                    return new Point2D(xy * y, yx * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    return new Point2D(xx * x, yy * y);
                case APPLY_TRANSLATE:
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D deltaTransform(double x, double y, double z) {
            switch (state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SHEAR | APPLY_SCALE:
                            return new Point3D(
                                xx * x + xy * y,
                                yx * x + yy * y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            return new Point3D(xy * y, yx * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            return new Point3D(xx * x, yy * y, z);
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x, y, z);
                case APPLY_SCALE:
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point3D(xx * x, yy * y, zz * z);
                case APPLY_3D_COMPLEX:
                    return new Point3D(
                        xx * x + xy * y + xz * z,
                        yx * x + yy * y + yz * z,
                        zx * x + zy * y + zz * z);
            }
        }

        @Override
        public Point2D inverseTransform(double x, double y)
                throws NonInvertibleTransformException {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    return super.inverseTransform(x, y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D(
                            (1.0 / yx) * y - yt / yx,
                            (1.0 / xy) * x - xt / xy);
                case APPLY_SHEAR:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D(
                            (1.0 / xx) * x - xt / xx,
                            (1.0 / yy) * y - yt / yy);
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
                case APPLY_TRANSLATE:
                    return new Point2D(x - xt, y - yt);
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D inverseTransform(double x, double y, double z)
                throws NonInvertibleTransformException {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            return super.inverseTransform(x, y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y - yt / yx,
                                    (1.0 / xy) * x - xt / xy, z);
                        case APPLY_SHEAR:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y,
                                    (1.0 / xy) * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / xx) * x - xt / xx,
                                    (1.0 / yy) * y - yt / yy, z);
                        case APPLY_SCALE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D((1.0 / xx) * x, (1.0 / yy) * y, z);
                        case APPLY_TRANSLATE:
                            return new Point3D(x - xt, y - yt, z);
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x - xt, y - yt, z - zt);
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x,
                            (1.0 / yy) * y,
                            (1.0 / zz) * z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x - xt / xx,
                            (1.0 / yy) * y - yt / yy,
                            (1.0 / zz) * z - zt / zz);
                case APPLY_3D_COMPLEX:
                    return super.inverseTransform(x, y, z);
            }
        }

        @Override
        public Point2D inverseDeltaTransform(double x, double y)
                throws NonInvertibleTransformException {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    return super.inverseDeltaTransform(x, y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                case APPLY_SHEAR:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
                case APPLY_TRANSLATE:
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D inverseDeltaTransform(double x, double y, double z)
                throws NonInvertibleTransformException {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            return super.inverseDeltaTransform(x, y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y,
                                    (1.0 / xy) * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / xx) * x,
                                    (1.0 / yy) * y, z);
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }

                case APPLY_TRANSLATE:
                    return new Point3D(x, y, z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x,
                            (1.0 / yy) * y,
                            (1.0 / zz) * z);
                case APPLY_3D_COMPLEX:
                    return super.inverseDeltaTransform(x, y, z);
            }
        }

        /* *************************************************************************
         *                                                                         *
         *                               Other API                                 *
         *                                                                         *
         **************************************************************************/

        @Override
        public String toString() {
           final StringBuilder sb = new StringBuilder(&quot;Transform [\n&quot;);

            sb.append(&quot;\t&quot;).append(xx);
            sb.append(&quot;, &quot;).append(xy);
            sb.append(&quot;, &quot;).append(xz);
            sb.append(&quot;, &quot;).append(xt);
            sb.append('\n');
            sb.append(&quot;\t&quot;).append(yx);
            sb.append(&quot;, &quot;).append(yy);
            sb.append(&quot;, &quot;).append(yz);
            sb.append(&quot;, &quot;).append(yt);
            sb.append('\n');
            sb.append(&quot;\t&quot;).append(zx);
            sb.append(&quot;, &quot;).append(zy);
            sb.append(&quot;, &quot;).append(zz);
            sb.append(&quot;, &quot;).append(zt);

            return sb.append(&quot;\n]&quot;).toString();
        }

        /* *************************************************************************
         *                                                                         *
         *                    Internal implementation stuff                        *
         *                                                                         *
         **************************************************************************/

        private void updateState() {
            updateState2D();

            state3d = APPLY_NON_3D;

            if (xz != 0.0 ||
                yz != 0.0 ||
                zx != 0.0 ||
                zy != 0.0)
            {
                state3d = APPLY_3D_COMPLEX;
            } else {
                if ((state2d &amp; APPLY_SHEAR) == 0) {
                    if (zt != 0.0) {
                        state3d |= APPLY_TRANSLATE;
                    }
                    if (zz != 1.0) {
                        state3d |= APPLY_SCALE;
                    }
                    if (state3d != APPLY_NON_3D) {
                        state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
                    }
                } else {
                    if (zz != 1.0 || zt != 0.0) {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
            }
        }

        private void updateState2D() {
            if (xy == 0.0 &amp;&amp; yx == 0.0) {
                if (xx == 1.0 &amp;&amp; yy == 1.0) {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                } else {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_SCALE;
                    } else {
                        state2d = (APPLY_SCALE | APPLY_TRANSLATE);
                    }
                }
            } else {
                if (xx == 0.0 &amp;&amp; yy == 0.0) {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_SHEAR;
                    } else {
                        state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
                    }
                } else {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = (APPLY_SHEAR | APPLY_SCALE);
                    } else {
                        state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
                    }
                }
            }
        }

        void ensureCanTransform2DPoint() throws IllegalStateException {
            if (state3d != APPLY_NON_3D) {
                throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
                        + &quot;with a 3D transform&quot;);
            }
        }

        private static void stateError() {
            throw new InternalError(&quot;missing case in a switch&quot;);
        }


        @Override
        void apply(final Affine3D trans) {
            trans.concatenate(xx, xy, xz, xt,
                              yx, yy, yz, yt,
                              zx, zy, zz, zt);
        }

        @Override
        BaseTransform derive(final BaseTransform trans) {
            return trans.deriveWithConcatenation(xx, xy, xz, xt,
                                                 yx, yy, yz, yt,
                                                 zx, zy, zz, zt);
        }

        /**
         * Used only by tests to check the 2d matrix state
         */
        int getState2d() {
            return state2d;
        }

        /**
         * Used only by tests to check the 3d matrix state
         */
        int getState3d() {
            return state3d;
        }

    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/NativeMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl;

import java.lang.annotation.Native;
import com.sun.media.jfxmedia.Media;
import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmedia.MediaException;
import com.sun.media.jfxmedia.MediaPlayer;
import com.sun.media.jfxmedia.control.VideoRenderControl;
import com.sun.media.jfxmedia.effects.AudioEqualizer;
import com.sun.media.jfxmedia.effects.AudioSpectrum;
import com.sun.media.jfxmedia.events.AudioSpectrumEvent;
import com.sun.media.jfxmedia.events.AudioSpectrumListener;
import com.sun.media.jfxmedia.events.BufferListener;
import com.sun.media.jfxmedia.events.BufferProgressEvent;
import com.sun.media.jfxmedia.events.MarkerEvent;
import com.sun.media.jfxmedia.events.MarkerListener;
import com.sun.media.jfxmedia.events.MediaErrorListener;
import com.sun.media.jfxmedia.events.NewFrameEvent;
import com.sun.media.jfxmedia.events.PlayerEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent.PlayerState;
import com.sun.media.jfxmedia.events.PlayerStateListener;
import com.sun.media.jfxmedia.events.PlayerTimeListener;
<A NAME="45"></A>import com.sun.media.jfxmedia.events.VideoFrameRateListener;
import com.sun.media.jfxmedia.events.VideoRendererListener;
import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
<FONT color="#79d867"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#45',2,'match44-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.media.jfxmedia.logging.Logger;
import com.sun.media.jfxmedia.track.AudioTrack;
import com.sun.media.jfxmedia.track.SubtitleTrack;
import com.sun.media.jfxmedia.track.Track;
import com.sun.media.jfxmedia.track.Track.Encoding;
import com.sun.media.jfxmedia.track.VideoResolution;
import com.sun.media.jfxmedia.track.VideoTrack;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Base implementation of a
 * &lt;code&gt;MediaPlayer&lt;/code&gt;.
 */
public abstract class NativeMediaPlayer implements MediaPlayer, MarkerStateListener {
    //***** Event IDs for PlayerStateEvent.  IDs sent from native JNI layer.

    @Native public final static int eventPlayerUnknown = 100;
    @Native public final static int eventPlayerReady = 101;
    @Native public final static int eventPlayerPlaying = 102;
    @Native public final static int eventPlayerPaused = 103;
    @Native public final static int eventPlayerStopped = 104;
    @Native public final static int eventPlayerStalled = 105;
    @Native public final static int eventPlayerFinished = 106;
    @Native public final static int eventPlayerError = 107</B></FONT>;
    // Nominal video frames per second.
    @Native private static final int NOMINAL_VIDEO_FPS = 30;
    // Nanoseconds per second.
    @Native public static final long ONE_SECOND = 1000000000L;

    /**
     * The
     * &lt;code&gt;Media&lt;/code&gt; corresponding to the media source.
     */
    private NativeMedia media;
    private VideoRenderControl videoRenderControl;
    private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerStateListener&gt;&gt; playerStateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; playerTimeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; videoTrackSizeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoRendererListener&gt;&gt; videoUpdateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; videoFrameRateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;MarkerListener&gt;&gt; markerListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;BufferListener&gt;&gt; bufferListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; audioSpectrumListeners = new ArrayList&lt;&gt;();
    private final List&lt;PlayerStateEvent&gt; cachedStateEvents = new ArrayList&lt;&gt;();
    private final List&lt;PlayerTimeEvent&gt; cachedTimeEvents = new ArrayList&lt;&gt;();
    private final List&lt;BufferProgressEvent&gt; cachedBufferEvents = new ArrayList&lt;&gt;();
    private final List&lt;MediaErrorEvent&gt; cachedErrorEvents = new ArrayList&lt;&gt;();
    private boolean isFirstFrame = true;
    private NewFrameEvent firstFrameEvent = null;
    private double firstFrameTime;
    private final Object firstFrameLock = new Object();
    private EventQueueThread eventLoop = new EventQueueThread();
    private int frameWidth = -1;
    private int frameHeight = -1;
    private final AtomicBoolean isMediaPulseEnabled = new AtomicBoolean(false);
    private final Lock mediaPulseLock = new ReentrantLock();
    private Timer mediaPulseTimer;
    private final Lock markerLock = new ReentrantLock();
    private boolean checkSeek = false;
    private double timeBeforeSeek = 0.0;
    private double timeAfterSeek = 0.0;
    private double previousTime = 0.0;
    private double firedMarkerTime = -1.0;
    private double startTime = 0.0;
    private double stopTime = Double.POSITIVE_INFINITY;
    private boolean isStartTimeUpdated = false;
    private boolean isStopTimeSet = false;

    // --- Begin decoded frame rate fields
    private double encodedFrameRate = 0.0;
    private boolean recomputeFrameRate = true;
    private double previousFrameTime;
    private long numFramesSincePlaying;
    private double meanFrameDuration;
    private double decodedFrameRate;
    // --- End decoded frame rate fields
    private PlayerState playerState = PlayerState.UNKNOWN;
    private final Lock disposeLock = new ReentrantLock();
    private boolean isDisposed = false;
    private Runnable onDispose;

    //**************************************************************************
    //***** Constructors
    //**************************************************************************
    /**
     * Construct a NativeMediaPlayer for the referenced clip.
     *
     * @param clip Media object
     * @throws IllegalArgumentException if
     * &lt;code&gt;clip&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    protected NativeMediaPlayer(NativeMedia clip) {
        if (clip == null) {
            throw new IllegalArgumentException(&quot;clip == null!&quot;);
        }
        media = clip;
        videoRenderControl = new VideoRenderer();
    }

    /**
     * Initialization method which must be called after construction to
     * initialize the internal state of the player. This method should be
     * invoked directly after the player is constructed.
     */
    protected void init() {
        media.addMarkerStateListener(this);
        eventLoop.start();
    }

    /**
     * Set a callback to invoke when the player is disposed.
     *
     * @param onDispose object on which to invoke {@link Runnable#run()} in
     * {@link #dispose()}.
     */
    void setOnDispose(Runnable onDispose) {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                this.onDispose = onDispose;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    /**
     * Event to be posted to any registered {@link MediaErrorListener}s.
     */
    private static class WarningEvent extends PlayerEvent {

        private final Object source;
        private final String message;

        WarningEvent(Object source, String message) {
            this.source = source;
            this.message = message;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return message;
        }
    }

    /**
     * Event to be posted to any registered (@link MediaErrorListener)s
     */
    public static class MediaErrorEvent extends PlayerEvent {

        private final Object source;
        private final MediaError error;

        public MediaErrorEvent(Object source, MediaError error) {
            this.source = source;
            this.error = error;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return error.description();
        }

        public int getErrorCode() {
            return error.code();
        }
    }

    private static class PlayerTimeEvent extends PlayerEvent {

        private final double time;

        public PlayerTimeEvent(double time) {
            this.time = time;
        }

        public double getTime() {
            return time;
        }
    }

    /**
     * Event to be posted to any registered {@link PlayerStateListener}s.
     */
    private static class TrackEvent extends PlayerEvent {

        private final Track track;

        TrackEvent(Track track) {
            this.track = track;
        }

        public Track getTrack() {
            return this.track;
        }
    }

    /**
     * Event to be posted to any registered {@link VideoTrackSizeListener}s.
     */
    private static class FrameSizeChangedEvent extends PlayerEvent {

        private final int width;
        private final int height;

        public FrameSizeChangedEvent(int width, int height) {
            if (width &gt; 0) {
                this.width = width;
            } else {
                this.width = 0;
            }

            if (height &gt; 0) {
                this.height = height;
            } else {
                this.height = 0;
            }
        }

        public int getWidth() {
            return width;
        }

        public int getHeight() {
            return height;
        }
    }

    /**
     * Helper class which managers {@link VideoRendererListener}s. This allows
     * any registered listeners, specifically AWT and Prism, to receive video
     * frames.
     */
    private class VideoRenderer implements VideoRenderControl {

        /**
         * adds the listener to the player's videoUpdate. The listener will be
         * called whenever a new frame of video is ready to be painted or
         * fetched by getData()
         *
         * @param listener the object which provides the VideoUpdateListener
         * callback interface
         */
        @Override
        public void addVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                synchronized (firstFrameLock) {
                    // If the first frame is cached, post it to the listener
                    // directly. The lock is obtained first so the cached
                    // frame is not cleared between the non-null test and
                    // posting the event.
                    if (firstFrameEvent != null) {
                        listener.videoFrameUpdated(firstFrameEvent);
                    }
                }
                videoUpdateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        /**
         * removes the listener from the player.
         *
         * @param listener to be removed from the player
         */
        @Override
        public void removeVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                    VideoRendererListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public void addVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                videoFrameRateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        @Override
        public void removeVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                    VideoFrameRateListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public int getFrameWidth() {
            return frameWidth;
        }

        @Override
        public int getFrameHeight() {
            return frameHeight;
        }
    }

    //***** EventQueueThread Helper Class -- Provides event handling.
    /**
     * Thread for media player event processing. The thread maintains an
     * internal queue of
     * &lt;code&gt;PlayerEvent&lt;/code&gt;s to which callers post using
     * &lt;code&gt;postEvent()&lt;/code&gt;. The thread blocks until an event becomes
     * available on the queue, and then removes the event from the queue and
     * posts it to any registered listeners appropriate to the type of event.
     */
    private class EventQueueThread extends Thread {

        private final BlockingQueue&lt;PlayerEvent&gt; eventQueue =
                new LinkedBlockingQueue&lt;&gt;();
        private volatile boolean stopped = false;

        EventQueueThread() {
            setName(&quot;JFXMedia Player EventQueueThread&quot;);
            setDaemon(true);
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    // trying to take an event from the queue.
                    // this method will block until an event becomes available.
                    PlayerEvent evt = eventQueue.take();

                    if (!stopped) {
                        if (evt instanceof NewFrameEvent) {
                            try {
                                HandleRendererEvents((NewFrameEvent) evt);
                            } catch (Throwable t) {
                                if (Logger.canLog(Logger.ERROR)) {
                                    Logger.logMsg(Logger.ERROR, &quot;Caught exception in HandleRendererEvents: &quot; + t.toString());
                                }
                            }
                        } else if (evt instanceof PlayerStateEvent) {
                            HandleStateEvents((PlayerStateEvent) evt);
                        } else if (evt instanceof FrameSizeChangedEvent) {
                            HandleFrameSizeChangedEvents((FrameSizeChangedEvent) evt);
                        } else if (evt instanceof TrackEvent) {
                            HandleTrackEvents((TrackEvent) evt);
                        } else if (evt instanceof MarkerEvent) {
                            HandleMarkerEvents((MarkerEvent) evt);
                        } else if (evt instanceof WarningEvent) {
                            HandleWarningEvents((WarningEvent) evt);
                        } else if (evt instanceof PlayerTimeEvent) {
                            HandlePlayerTimeEvents((PlayerTimeEvent) evt);
                        } else if (evt instanceof BufferProgressEvent) {
                            HandleBufferEvents((BufferProgressEvent) evt);
                        } else if (evt instanceof AudioSpectrumEvent) {
                            HandleAudioSpectrumEvents((AudioSpectrumEvent) evt);
                        } else if (evt instanceof MediaErrorEvent) {
                            HandleErrorEvents((MediaErrorEvent) evt);
                        }
                    }
                } catch (Exception e) {
                    // eventQueue.take() can throw InterruptedException,
                    // also in rare case it can throw wrong
                    // IllegalMonitorStateException
                    // so we catch Exception
                    // nothing to do, restart the loop unless it was properly stopped.
                }
            }

            eventQueue.clear();
        }

        private void HandleRendererEvents(NewFrameEvent evt) {
            if (isFirstFrame) {
                // Cache first frame. Frames are delivered time-sequentially
                // so there should be no thread contention problem here.
                isFirstFrame = false;
                synchronized (firstFrameLock) {
                    firstFrameEvent = evt;
                    firstFrameTime = firstFrameEvent.getFrameData().getTimestamp();
                    firstFrameEvent.getFrameData().holdFrame(); // hold as long as we cache it, else we'll crash
                }
            } else if (firstFrameEvent != null
                    &amp;&amp; firstFrameTime != evt.getFrameData().getTimestamp()) {
                // If this branch is entered then it cannot be the first frame.
                // This means that the player must be in the PLAYING state as
                // the first frame will arrive upon completion of prerolling.
                // When playing, listeners should receive the current frame,
                // not the first frame in the stream.

                // Clear the cached first frame. Obtain the lock first to avoid
                // a race condition with a listener newly being added.
                synchronized (firstFrameLock) {
                    firstFrameEvent.getFrameData().releaseFrame();
                    firstFrameEvent = null;
                }
            }

            // notify videoUpdateListeners
            for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                VideoRendererListener l = it.next().get();
                if (l != null) {
                    l.videoFrameUpdated(evt);
                } else {
                    it.remove();
                }
            }
            // done with the frame, we can release our hold now
            evt.getFrameData().releaseFrame();

            if (!videoFrameRateListeners.isEmpty()) {
                // Decoded frame rate calculations.
                double currentFrameTime = System.nanoTime() / (double) ONE_SECOND;

                if (recomputeFrameRate) {
                    // First frame in new computation sequence.
                    recomputeFrameRate = false;
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying = 1;
                } else {
                    boolean fireFrameRateEvent = false;

                    if (numFramesSincePlaying == 1) {
                        // Second frame. Estimate the initial frame rate and
                        // set event flag.
                        meanFrameDuration = currentFrameTime - previousFrameTime;
                        if (meanFrameDuration &gt; 0.0) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    } else {
                        // Update decoded frame rate estimate using a moving
                        // average over encodedFrameRate frames.
                        double previousMeanFrameDuration = meanFrameDuration;

                        // Determine moving average length.
                        int movingAverageLength = encodedFrameRate != 0.0
                                ? ((int) (encodedFrameRate + 0.5)) : NOMINAL_VIDEO_FPS;

                        // Claculate number of frames in current average.
                        long numFrames = numFramesSincePlaying &lt; movingAverageLength
                                ? numFramesSincePlaying : movingAverageLength;

                        // Update the mean frame duration.
                        meanFrameDuration = ((numFrames - 1) * previousMeanFrameDuration
                                + currentFrameTime - previousFrameTime) / numFrames;

                        // If mean frame duration changed by more than 0.5 set
                        // event flag.
                        if (meanFrameDuration &gt; 0.0
                                &amp;&amp; Math.abs(decodedFrameRate - 1.0 / meanFrameDuration) &gt; 0.5) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    }

                    if (fireFrameRateEvent) {
                        // Fire event.
                        for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                            VideoFrameRateListener l = it.next().get();
                            if (l != null) {
                                l.onFrameRateChanged(decodedFrameRate);
                            } else {
                                it.remove();
                            }
                        }
                    }

                    // Update running values.
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying++;
                }
            }
        }

        private void HandleStateEvents(PlayerStateEvent evt) {
            playerState = evt.getState();

            recomputeFrameRate = PlayerState.PLAYING == evt.getState();

            switch (playerState) {
                case READY:
                    onNativeInit();
                    sendFakeBufferProgressEvent();
                    break;
                case PLAYING:
                    isMediaPulseEnabled.set(true);
                    break;
                case STOPPED:
                case FINISHED:
                    // Force a time update here to catch the time going to
                    // zero for STOPPED and any trailing markers for FINISHED.
                    doMediaPulseTask();
                case PAUSED:
                case STALLED:
                case HALTED:
                    isMediaPulseEnabled.set(false);
                    break;
                default:
                    break;
            }

            synchronized (cachedStateEvents) {
                if (playerStateListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedStateEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener listener = it.next().get();
                if (listener != null) {
                    switch (playerState) {
                        case READY:
                            onNativeInit();
                            sendFakeBufferProgressEvent();
                            listener.onReady(evt);
                            break;

                        case PLAYING:
                            listener.onPlaying(evt);
                            break;

                        case PAUSED:
                            listener.onPause(evt);
                            break;

                        case STOPPED:
                            listener.onStop(evt);
                            break;

                        case STALLED:
                            listener.onStall(evt);
                            break;

                        case FINISHED:
                            listener.onFinish(evt);
                            break;

                        case HALTED:
                            listener.onHalt(evt);
                            break;

                        default:
                            break;
                    }
                } else {
                    it.remove();
                }
            }
        }

        private void HandlePlayerTimeEvents(PlayerTimeEvent evt) {
            synchronized (cachedTimeEvents) {
                if (playerTimeListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedTimeEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener listener = it.next().get();
                if (listener != null) {
                    listener.onDurationChanged(evt.getTime());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleFrameSizeChangedEvents(FrameSizeChangedEvent evt) {
            frameWidth = evt.getWidth();
            frameHeight = evt.getHeight();
            Logger.logMsg(Logger.DEBUG, &quot;** Frame size changed (&quot; + frameWidth + &quot;, &quot; + frameHeight + &quot;)&quot;);
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener listener = it.next().get();
                if (listener != null) {
                    listener.onSizeChanged(frameWidth, frameHeight);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleTrackEvents(TrackEvent evt) {
            media.addTrack(evt.getTrack());

            if (evt.getTrack() instanceof VideoTrack) {
                encodedFrameRate = ((VideoTrack) evt.getTrack()).getEncodedFrameRate();
            }
        }

        private void HandleMarkerEvents(MarkerEvent evt) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener listener = it.next().get();
                if (listener != null) {
                    listener.onMarker(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleWarningEvents(WarningEvent evt) {
            Logger.logMsg(Logger.WARNING, evt.getSource() + evt.getMessage());
        }

        private void HandleErrorEvents(MediaErrorEvent evt) {
            Logger.logMsg(Logger.ERROR, evt.getMessage());

            synchronized (cachedErrorEvents) {
                if (errorListeners.isEmpty()) {
                    // cache error events until at least one listener is added
                    cachedErrorEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l != null) {
                    l.onError(evt.getSource(), evt.getErrorCode(), evt.getMessage());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleBufferEvents(BufferProgressEvent evt) {
            synchronized (cachedBufferEvents) {
                if (bufferListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedBufferEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener listener = it.next().get();
                if (listener != null) {
                    listener.onBufferProgress(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleAudioSpectrumEvents(AudioSpectrumEvent evt) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener listener = it.next().get();
                if (listener != null) {
                    listener.onAudioSpectrumEvent(evt);
                } else {
                    it.remove();
                }
            }
        }

        /**
         * Puts an event to the EventQuery.
         */
        public void postEvent(PlayerEvent event) {
            if (eventQueue != null) {
                eventQueue.offer(event);
            }
        }

        /**
         * Signals the thread to terminate.
         */
        public void terminateLoop() {
            stopped = true;
            // put an event to unblock eventQueue.take()
            try {
                eventQueue.put(new PlayerEvent());
            } catch(InterruptedException ex) {}
        }

        private void sendFakeBufferProgressEvent() {
            // Send fake 100% buffer progress event for HLS or !http protcol
            String contentType = media.getLocator().getContentType();
            String protocol = media.getLocator().getProtocol();
            if ((contentType != null &amp;&amp; (contentType.equals(MediaUtils.CONTENT_TYPE_M3U) || contentType.equals(MediaUtils.CONTENT_TYPE_M3U8)))
                    || (protocol != null &amp;&amp; !protocol.equals(&quot;http&quot;) &amp;&amp; !protocol.equals(&quot;https&quot;))) {
                HandleBufferEvents(new BufferProgressEvent(getDuration(), 0, 1, 1));
            }
        }
    }

    /**
     * Internal function to get called when the native player is ready.
     */
    private synchronized void onNativeInit() {
        try {
            playerInit();
        } catch (MediaException me) {
            sendPlayerMediaErrorEvent(me.getMediaError().code());
        }
    }

    //**************************************************************************
    //***** MediaPlayer implementation
    //**************************************************************************
    //***** Listener (un)registration.
    @Override
    public void addMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            this.errorListeners.add(new WeakReference&lt;&gt;(listener));

            synchronized (cachedErrorEvents) {
                if (!cachedErrorEvents.isEmpty() &amp;&amp; !errorListeners.isEmpty()) {
                    cachedErrorEvents.stream().forEach((evt) -&gt; {
                        sendPlayerEvent(evt);
                    });
                    cachedErrorEvents.clear();
                }
            }
        }
    }

    @Override
    public void removeMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            synchronized (cachedStateEvents) {
                if (!cachedStateEvents.isEmpty() &amp;&amp; playerStateListeners.isEmpty()) {
                    // Forward all cached state events to first listener to register.
                    Iterator&lt;PlayerStateEvent&gt; events = cachedStateEvents.iterator();
                    while (events.hasNext()) {
                        PlayerStateEvent evt = events.next();
                        switch (evt.getState()) {
                            case READY:
                                listener.onReady(evt);
                                break;
                            case PLAYING:
                                listener.onPlaying(evt);
                                break;
                            case PAUSED:
                                listener.onPause(evt);
                                break;
                            case STOPPED:
                                listener.onStop(evt);
                                break;
                            case STALLED:
                                listener.onStall(evt);
                                break;
                            case FINISHED:
                                listener.onFinish(evt);
                                break;
                            case HALTED:
                                listener.onHalt(evt);
                                break;
                            default:
                                break;
                        }
                    }

                    // Clear state event cache.
                    cachedStateEvents.clear();
                }

                playerStateListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            synchronized (cachedTimeEvents) {
                if (!cachedTimeEvents.isEmpty() &amp;&amp; playerTimeListeners.isEmpty()) {
                    // Forward all cached time events to first listener to register.
                    Iterator&lt;PlayerTimeEvent&gt; events = cachedTimeEvents.iterator();
                    while (events.hasNext()) {
                        PlayerTimeEvent evt = events.next();
                        listener.onDurationChanged(evt.getTime());
                    }

                    // Clear time event cache.
                    cachedTimeEvents.clear();
                } else {
                    // Let listener to know about duration
                    double duration = getDuration();
                    if (duration != Double.POSITIVE_INFINITY) {
                        listener.onDurationChanged(duration);
                    }
                }

                playerTimeListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            if (frameWidth != -1 &amp;&amp; frameHeight != -1) {
                listener.onSizeChanged(frameWidth, frameHeight);
            }
            videoTrackSizeListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMarkerListener(MarkerListener listener) {
        if (listener != null) {
            markerListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeMarkerListener(MarkerListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addBufferListener(BufferListener listener) {
        if (listener != null) {
            synchronized (cachedBufferEvents) {
                if (!cachedBufferEvents.isEmpty() &amp;&amp; bufferListeners.isEmpty()) {
                    cachedBufferEvents.stream().forEach((evt) -&gt; {
                        listener.onBufferProgress(evt);
                    });
                    // Clear buffer event cache.
                    cachedBufferEvents.clear();
                }

                bufferListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeBufferListener(BufferListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            audioSpectrumListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    //***** Control functions
    @Override
    public VideoRenderControl getVideoRenderControl() {
        return videoRenderControl;
    }

    @Override
    public Media getMedia() {
        return media;
    }

    @Override
    public void setAudioSyncDelay(long delay) {
        try {
            playerSetAudioSyncDelay(delay);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public long getAudioSyncDelay() {
        try {
            return playerGetAudioSyncDelay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void play() {
        try {
            if (isStartTimeUpdated) {
                playerSeek(startTime);
            }
            isMediaPulseEnabled.set(true);
            playerPlay();
<A NAME="43"></A>        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    <FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#43',2,'match44-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public void stop() {
        try {
            playerStop();
            playerSeek(startTime);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;stop() failed!&quot;);
        }
    }

    @Over</B></FONT>ride
    public void pause() {
        try {
            playerPause();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getRate() {
        try {
            return playerGetRate();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    //***** Public properties
    @Override
    public void setRate(float rate) {
        try {
            playerSetRate(rate);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;setRate(&quot; + rate + &quot;) failed!&quot;);
        }
    }

    @Override
    public double getPresentationTime() {
        try {
            return playerGetPresentationTime();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return -1.0;
    }

    @Override
    public float getVolume() {
        try {
            return playerGetVolume();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setVolume(float vol) {
        if (vol &lt; 0.0F) {
            vol = 0.0F;
        } else if (vol &gt; 1.0F) {
            vol = 1.0F;
        }

        try {
            playerSetVolume(vol);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public boolean getMute() {
        try {
            return playerGetMute();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return false;
    }

    /**
     * Enables/disable mute. If mute is enabled then disabled, the previous
     * volume goes into effect.
     */
    @Override
    public void setMute(boolean enable) {
        try {
            playerSetMute(enable);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getBalance() {
        try {
            return playerGetBalance();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setBalance(float bal) {
        if (bal &lt; -1.0F) {
            bal = -1.0F;
        } else if (bal &gt; 1.0F) {
            bal = 1.0F;
        }

        try {
            playerSetBalance(bal);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public abstract AudioEqualizer getEqualizer();

    @Override
    public abstract AudioSpectrum getAudioSpectrum();

    @Override
    public double getDuration() {
        try {
            return playerGetDuration();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return Double.POSITIVE_INFINITY;
    }

    /**
     * Gets the time within the duration of the media to start playing.
     */
    @Override
    public double getStartTime() {
        return startTime;
    }

    /**
     * Sets the start time within the media to play.
     */
    @Override
    public void setStartTime(double startTime) {
        try {
            markerLock.lock();
            this.startTime = startTime;
            if (playerState != PlayerState.PLAYING &amp;&amp; playerState != PlayerState.FINISHED &amp;&amp; playerState != PlayerState.STOPPED) {
                playerSeek(startTime);
            } else if (playerState == PlayerState.STOPPED) {
                isStartTimeUpdated = true;
            }
        } finally {
            markerLock.unlock();
        }
    }

    /**
     * Gets the time within the duration of the media to stop playing.
     */
    @Override
    public double getStopTime() {
        return stopTime;
    }

    /**
     * Sets the stop time within the media to stop playback.
     */
    @Override
    public void setStopTime(double stopTime) {
        try {
            markerLock.lock();
            this.stopTime = stopTime;
            isStopTimeSet = true;
            createMediaPulse();
        } finally {
            markerLock.unlock();
        }
    }

    @Override
    public void seek(double streamTime) {
        if (playerState == PlayerState.STOPPED) {
            return; // No seek in stopped state
        }

        if (streamTime &lt; 0.0) {
            streamTime = 0.0;
        } else {
            double duration = getDuration();
            if (duration &gt;= 0.0 &amp;&amp; streamTime &gt; duration) {
                streamTime = duration;
            }
        }

        if (!isMediaPulseEnabled.get()) {
            if ((playerState == PlayerState.PLAYING
                    || playerState == PlayerState.PAUSED
                    || playerState == PlayerState.FINISHED)
                    &amp;&amp; getStartTime() &lt;= streamTime &amp;&amp; streamTime &lt;= getStopTime()) {
                isMediaPulseEnabled.set(true);
            }
        }

        markerLock.lock();
        try {
            timeBeforeSeek = getPresentationTime();
            timeAfterSeek = streamTime;
            checkSeek = timeBeforeSeek != timeAfterSeek;
            previousTime = streamTime;
            firedMarkerTime = -1.0;
//            System.out.println(&quot;seek @ &quot;+System.currentTimeMillis());
//            System.out.println(&quot;seek to &quot;+streamTime+&quot; previousTime &quot;+previousTime);

            try {
                playerSeek(streamTime);
            } catch (MediaException me) {
                //sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
                MediaUtils.warning(this, &quot;seek(&quot; + streamTime + &quot;) failed!&quot;);
            }
        } finally {
            markerLock.unlock();
        }
    }

    protected abstract long playerGetAudioSyncDelay() throws MediaException;

    protected abstract void playerSetAudioSyncDelay(long delay) throws MediaException;

    protected abstract void playerPlay() throws MediaException;

    protected abstract void playerStop() throws MediaException;

    protected abstract void playerPause() throws MediaException;

    protected abstract void playerFinish() throws MediaException;

    protected abstract float playerGetRate() throws MediaException;

    protected abstract void playerSetRate(float rate) throws MediaException;

    protected abstract double playerGetPresentationTime() throws MediaException;

    protected abstract boolean playerGetMute() throws MediaException;

    protected abstract void playerSetMute(boolean state) throws MediaException;

    protected abstract float playerGetVolume() throws MediaException;

    protected abstract void playerSetVolume(float volume) throws MediaException;

    protected abstract float playerGetBalance() throws MediaException;

    protected abstract void playerSetBalance(float balance) throws MediaException;

    protected abstract double playerGetDuration() throws MediaException;

    protected abstract void playerSeek(double streamTime) throws MediaException;

    protected abstract void playerInit() throws MediaException;

    protected abstract void playerDispose();

    /**
     * Retrieves the current {@link PlayerState state} of the player.
     *
     * @return the current player state.
     */
    @Override
    public PlayerState getState() {
        return playerState;
    }

    @Override
    final public void dispose() {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                // Terminate event firing
                destroyMediaPulse();

                if (eventLoop != null) {
                    eventLoop.terminateLoop();
                    eventLoop = null;
                }

                synchronized (firstFrameLock) {
                    if (firstFrameEvent != null) {
                        firstFrameEvent.getFrameData().releaseFrame();
                        firstFrameEvent = null;
                    }
                }

                // Terminate native layer
                playerDispose();

                // Dispose media object and clear reference
                if (media != null) {
                    media.dispose();
                    media = null;
                }

                if (videoUpdateListeners != null) {
                    for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                        VideoRendererListener l = it.next().get();
                        if (l != null) {
                            l.releaseVideoFrames();
                        } else {
                            it.remove();
                        }
                    }

                    videoUpdateListeners.clear();
                }

                if (playerStateListeners != null) {
                    playerStateListeners.clear();
                }

                if (videoTrackSizeListeners != null) {
                    videoTrackSizeListeners.clear();
                }

                if (videoFrameRateListeners != null) {
                    videoFrameRateListeners.clear();
                }

                if (cachedStateEvents != null) {
                    cachedStateEvents.clear();
                }

                if (cachedTimeEvents != null) {
                    cachedTimeEvents.clear();
                }

                if (cachedBufferEvents != null) {
                    cachedBufferEvents.clear();
                }

                if (errorListeners != null) {
                    errorListeners.clear();
                }

                if (playerTimeListeners != null) {
                    playerTimeListeners.clear();
                }

                if (markerListeners != null) {
                    markerListeners.clear();
                }

                if (bufferListeners != null) {
                    bufferListeners.clear();
                }

                if (audioSpectrumListeners != null) {
                    audioSpectrumListeners.clear();
                }

                if (videoRenderControl != null) {
                    videoRenderControl = null;
                }

                if (onDispose != null) {
                    onDispose.run();
                }

                isDisposed = true;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    //**************************************************************************
    //***** Non-JNI methods called by the native layer. These methods are called
    //***** from the native layer via the invocation API. Their purpose is to
    //***** dispatch certain events to the Java layer. Each of these methods
    //***** posts an event on the &lt;code&gt;EventQueueThread&lt;/code&gt; which in turn
    //***** forwards the event to any registered listeners.
    //**************************************************************************
    protected void sendWarning(int warningCode, String warningMessage) {
        if (eventLoop != null) {
            String message = String.format(MediaUtils.NATIVE_MEDIA_WARNING_FORMAT,
                    warningCode);
            if (warningMessage != null) {
                message += &quot;: &quot; + warningMessage;
            }
            eventLoop.postEvent(new WarningEvent(this, message));
        }
    }

    protected void sendPlayerEvent(PlayerEvent evt) {
        if (eventLoop != null) {
            eventLoop.postEvent(evt);
        }
    }

    protected void sendPlayerHaltEvent(String message, double time) {
        // Log the error.  Since these are most likely playback engine message (e.g. GStreamer or PacketVideo),
        // it makes no sense to propogate it above.
        Logger.logMsg(Logger.ERROR, message);

        if (eventLoop != null) {
            eventLoop.postEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.HALTED, time, message));
        }
    }

    protected void sendPlayerMediaErrorEvent(int errorCode) {
        sendPlayerEvent(new MediaErrorEvent(this, MediaError.getFromCode(errorCode)));
    }

    protected void sendPlayerStateEvent(int eventID, double time) {
        switch (eventID) {
            case eventPlayerReady:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.READY, time));
                break;
            case eventPlayerPlaying:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PLAYING, time));
                break;
            case eventPlayerPaused:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PAUSED, time));
                break;
            case eventPlayerStopped:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STOPPED, time));
                break;
            case eventPlayerStalled:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STALLED, time));
                break;
            case eventPlayerFinished:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.FINISHED, time));
                break;
            default:
                break;
        }
    }

    protected void sendNewFrameEvent(long nativeRef) {
        NativeVideoBuffer newFrameData = NativeVideoBuffer.createVideoBuffer(nativeRef);
        // createVideoBuffer puts a hold on the frame
        // we need to keep that hold until the event thread can process this event
        sendPlayerEvent(new NewFrameEvent(newFrameData));
    }

    protected void sendFrameSizeChangedEvent(int width, int height) {
        sendPlayerEvent(new FrameSizeChangedEvent(width, height));
    }

    protected void sendAudioTrack(boolean enabled, long trackID, String name, int encoding,
            String language, int numChannels,
            int channelMask, float sampleRate) {
        Locale locale = null;
        if (!language.equals(&quot;und&quot;)) {
            locale = new Locale(language);
        }

        Track track = new AudioTrack(enabled, trackID, name,
                locale, Encoding.toEncoding(encoding),
                numChannels, channelMask, sampleRate);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendVideoTrack(boolean enabled, long trackID, String name, int encoding,
            int width, int height, float frameRate,
            boolean hasAlphaChannel) {
        // No locale (currently) for video, so pass null
        Track track = new VideoTrack(enabled, trackID, name, null,
                Encoding.toEncoding(encoding),
                new VideoResolution(width, height), frameRate, hasAlphaChannel);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendSubtitleTrack(boolean enabled, long trackID, String name,
            int encoding, String language)
    {
        Locale locale = null;
        if (null != language) {
            locale = new Locale(language);
        }
        Track track = new SubtitleTrack(enabled, trackID, name, locale,
                Encoding.toEncoding(encoding));

        sendPlayerEvent(new TrackEvent(track));
    }

    protected void sendMarkerEvent(String name, double time) {
        sendPlayerEvent(new MarkerEvent(name, time));
    }

    protected void sendDurationUpdateEvent(double duration) {
        sendPlayerEvent(new PlayerTimeEvent(duration));
    }

    protected void sendBufferProgressEvent(double clipDuration, long bufferStart, long bufferStop, long bufferPosition) {
        sendPlayerEvent(new BufferProgressEvent(clipDuration, bufferStart, bufferStop, bufferPosition));
    }

    protected void sendAudioSpectrumEvent(double timestamp, double duration) {
        sendPlayerEvent(new AudioSpectrumEvent(getAudioSpectrum(), timestamp, duration));
    }

    @Override
    public void markerStateChanged(boolean hasMarkers) {
        if (hasMarkers) {
            markerLock.lock();
            try {
                previousTime = getPresentationTime();
            } finally {
                markerLock.unlock();
            }
            createMediaPulse();
        } else {
            if (!isStopTimeSet) {
                destroyMediaPulse();
            }
        }
    }

    private void createMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer == null) {
                mediaPulseTimer = new Timer(true);
                mediaPulseTimer.scheduleAtFixedRate(new MediaPulseTask(this), 0, 40 /*
                         * period ms
                         */);
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    private void destroyMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer != null) {
                mediaPulseTimer.cancel();
                mediaPulseTimer = null;
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    boolean doMediaPulseTask() {
        if (this.isMediaPulseEnabled.get()) {
            disposeLock.lock();

            if (isDisposed) {
                disposeLock.unlock();
                return false;
            }

            double thisTime = getPresentationTime();

            markerLock.lock();

            try {
                //System.out.println(&quot;Media pulse @ pts &quot;+thisTime+&quot; previous &quot;+previousTime);

                if (checkSeek) {
                    if (timeAfterSeek &gt; timeBeforeSeek) {
                        // Forward seek
                        if (thisTime &gt;= timeAfterSeek) {
//                        System.out.println(&quot;bail 1&quot;);
                            checkSeek = false;
                        } else {
                            return true;
                        }
                    } else if (timeAfterSeek &lt; timeBeforeSeek) {
                        // Backward seek
                        if (thisTime &gt;= timeBeforeSeek) {
//                        System.out.println(&quot;bail 2&quot;);
                            return true;
                        } else {
                            checkSeek = false;
                        }
                    }
                }

                Map.Entry&lt;Double, String&gt; marker = media.getNextMarker(previousTime, true);
//                System.out.println(&quot;marker &quot;+marker);
//                System.out.println(&quot;Checking: &quot; + previousTime + &quot; &quot; + thisTime + &quot; &quot;
//                        + getStartTime() + &quot; &quot; + getStopTime() + &quot; &quot;
//                        + marker.getKey());

                while (marker != null) {
                    double nextMarkerTime = marker.getKey();
                    if (nextMarkerTime &gt; thisTime) {
                        break;
                    } else if (nextMarkerTime != firedMarkerTime
                            &amp;&amp; nextMarkerTime &gt;= previousTime
                            &amp;&amp; nextMarkerTime &gt;= getStartTime()
                            &amp;&amp; nextMarkerTime &lt;= getStopTime()) {
//                            System.out.println(&quot;Firing: &quot;+previousTime+&quot; &quot;+thisTime+&quot; &quot;+
//                                    getStartTime()+&quot; &quot;+getStopTime()+&quot; &quot;+
//                                    nextMarkerTime);
                        MarkerEvent evt = new MarkerEvent(marker.getValue(), nextMarkerTime);
                        for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                            MarkerListener listener = it.next().get();
                            if (listener != null) {
                                listener.onMarker(evt);
                            } else {
                                it.remove();
                            }
                        }
                        firedMarkerTime = nextMarkerTime;
                    }
                    marker = media.getNextMarker(nextMarkerTime, false);
                }

                previousTime = thisTime;

                // Do stopTime
                if (isStopTimeSet &amp;&amp; thisTime &gt;= stopTime) {
                    playerFinish();
                }
            } finally {
                disposeLock.unlock();
                markerLock.unlock();
            }
        }

        return true;
    }

    /* Audio EQ and spectrum creation, used by sub-classes */
    protected AudioEqualizer createNativeAudioEqualizer(long nativeRef) {
        return new NativeAudioEqualizer(nativeRef);
    }

    protected AudioSpectrum createNativeAudioSpectrum(long nativeRef) {
        return new NativeAudioSpectrum(nativeRef);
    }
}

class MediaPulseTask extends TimerTask {

    WeakReference&lt;NativeMediaPlayer&gt; playerRef;

    MediaPulseTask(NativeMediaPlayer player) {
        playerRef = new WeakReference&lt;&gt;(player);
    }

    @Override
    public void run() {
        final NativeMediaPlayer player = playerRef.get();
        if (player != null) {
            if (!player.doMediaPulseTask()) {
                cancel(); // Stop if doMediaPulseTask() returns false. False means doMediaPulseTask() cannot continue (like after dispose).cy
            }
        } else {
            cancel();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/platform/ios/IOSMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl.platform.ios;

import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmedia.MediaException;
import com.sun.media.jfxmedia.effects.AudioEqualizer;
import com.sun.media.jfxmedia.effects.AudioSpectrum;
import com.sun.media.jfxmedia.effects.EqualizerBand;
import com.sun.media.jfxmedia.locator.Locator;
import com.sun.media.jfxmedia.control.MediaPlayerOverlay;
import com.sun.media.jfxmediaimpl.NativeMediaPlayer;

import java.util.Map;
import java.util.HashMap;

/**
 * iOS MediaPlayer implementation.
 */
public final class IOSMediaPlayer extends NativeMediaPlayer {

    private IOSMedia iosMedia;

    private final NullAudioEQ audioEqualizer;
    private final NullAudioSpectrum audioSpectrum;
    private final MediaPlayerOverlay mediaPlayerOverlay;

    private float mutedVolume = 1.0f;  // last volume before mute
    private boolean muteEnabled; // false by default

    private IOSMediaPlayer(final IOSMedia sourceMedia) {
        super(sourceMedia);
        iosMedia = sourceMedia;

        // run event loop
        init();

        handleError(iosInitPlayer(iosMedia.getNativeMediaRef()));

        audioEqualizer = new NullAudioEQ();
        audioSpectrum = new NullAudioSpectrum();
        mediaPlayerOverlay = new MediaPlayerOverlayImpl();
    }

    IOSMediaPlayer(final Locator source) {
        this(new IOSMedia(source));
    }

    @Override
    public AudioEqualizer getEqualizer() {
        return audioEqualizer;
    }

    @Override
    public AudioSpectrum getAudioSpectrum() {
        return audioSpectrum;
    }

    @Override
    public MediaPlayerOverlay getMediaPlayerOverlay() {
        return mediaPlayerOverlay;
    }

    private void handleError(final int err) throws MediaException {
        if (0 != err) {
            final MediaError me = MediaError.getFromCode(err);
            throw new MediaException(&quot;Media error occurred&quot;, null, me);
        }
    }

    @Override
    protected long playerGetAudioSyncDelay() throws MediaException {
        final long[] audioSyncDelay = new long[1];
        handleError(iosGetAudioSyncDelay(iosMedia.getNativeMediaRef(), audioSyncDelay));
        return audioSyncDelay[0];
    }

    @Override
    protected void playerSetAudioSyncDelay(final long delay) throws MediaException {
        handleError(iosSetAudioSyncDelay(iosMedia.getNativeMediaRef(), delay));
    }

    @Override
    protected void playerPlay() throws MediaException {
        handleError(iosPlay(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected void playerStop() throws MediaException {
        handleError(iosStop(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected void playerPause() throws MediaException {
        handleError(iosPause(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected float playerGetRate() throws MediaException {
        final float[] rate = new float[1];
        handleError(iosGetRate(iosMedia.getNativeMediaRef(), rate));
        return rate[0];
    }

    @Override
    protected void playerSetRate(final float rate) throws MediaException {
        handleError(iosSetRate(iosMedia.getNativeMediaRef(), rate));
    }

    @Override
    protected double playerGetPresentationTime() throws MediaException {
        double[] presentationTime = new double[1];
        handleError(iosGetPresentationTime(iosMedia.getNativeMediaRef(), presentationTime));
        return presentationTime[0];
    }

    @Override
    protected boolean playerGetMute() throws MediaException {
        return muteEnabled;
    }

    @Override
    protected synchronized void playerSetMute(final boolean enable) throws MediaException {
        if (enable != muteEnabled) {
            if (enable) {
                final float currentVolume = getVolume();
                playerSetVolume(0);
                muteEnabled = true;
                mutedVolume = currentVolume;
            }
            else {
                muteEnabled = false;
                playerSetVolume(mutedVolume);
            }
        }
    }

    @Override
    protected float playerGetVolume() throws MediaException {
        synchronized(this) {
            if (muteEnabled) {
                return mutedVolume;
            }
        }
        final float[] volume = new float[1];
        handleError(iosGetVolume(iosMedia.getNativeMediaRef(), volume));
        return volume[0];
    }

    @Override
    protected synchronized void playerSetVolume(final float volume) throws MediaException {
        if (!muteEnabled) {
            final int err = iosSetVolume(iosMedia.getNativeMediaRef(), volume);
            if (0 != err) {
                handleError(err);
            } else {
                mutedVolume = volume;
            }
        } else {
            mutedVolume = volume;
        }
    }

    @Override
    protected float playerGetBalance() throws MediaException {
        final float[] balance = new float[1];
        handleError(iosGetBalance(iosMedia.getNativeMediaRef(), balance));
        return balance[0];
    }

    @Override
    protected void playerSetBalance(final float balance) throws MediaException {
        handleError(iosSetBalance(iosMedia.getNativeMediaRef(), balance));
    }

    @Override
    protected double playerGetDuration() throws MediaException {
        final double[] durationArr = new double[1];
        handleError(iosGetDuration(iosMedia.getNativeMediaRef(), durationArr));
        double duration;
        if (durationArr[0] == -1.0) {
            duration = Double.POSITIVE_INFINITY;
        } else {
            duration = durationArr[0];
        }
        return duration;
    }

    @Override
    protected void playerSeek(final double streamTime) throws MediaException {
        handleError(iosSeek(iosMedia.getNativeMediaRef(), streamTime));
    }

    @Override
    protected void playerInit() throws MediaException {
    }

    @Override
    protected void playerFinish() throws MediaException {
        handleError(iosFinish(iosMedia.getNativeMediaRef()));
    }

    @Override
    protected void playerDispose() {
        iosDispose(iosMedia.getNativeMediaRef());
        iosMedia = null;
    }

    // Native methods
    private native int iosInitPlayer(long refNativeMedia);
    private native int iosGetAudioSyncDelay(long refNativeMedia, long[] syncDelay);
    private native int iosSetAudioSyncDelay(long refNativeMedia, long delay);
    private native int iosPlay(long refNativeMedia);
    private native int iosPause(long refNativeMedia);
    private native int iosStop(long refNativeMedia);
    private native int iosGetRate(long refNativeMedia, float[] rate);
    private native int iosSetRate(long refNativeMedia, float rate);
    private native int iosGetPresentationTime(long refNativeMedia, double[] time);
    private native int iosGetVolume(long refNativeMedia, float[] volume);
    private native int iosSetVolume(long refNativeMedia, float volume);
    private native int iosGetBalance(long refNativeMedia, float[] balance);
    private native int iosSetBalance(long refNativeMedia, float balance);
    private native int iosGetDuration(long refNativeMedia, double[] duration);
    private native int iosSeek(long refNativeMedia, double streamTime);
    private native void iosDispose(long refNativeMedia);
    private native int iosFinish(long refNativeMedia);

    // Overlay native methods
    private native int iosSetOverlayX(long mediaRef, double x);
    private native int iosSetOverlayY(long mediaRef, double y);
    private native int iosSetOverlayVisible(long mediaRef, boolean visible);
    private native int iosSetOverlayWidth(long mediaRef, double width);
    private native int iosSetOverlayHeight(long mediaRef, double height);
    private native int iosSetOverlayPreserveRatio(long mediaRef, boolean preserveRatio);
    private native int iosSetOverlayOpacity(long mediaRef, double opacity);
    private native int iosSetOverlayTransform(long mediaRef,
            double mxx, double mxy, double mxz, double mxt,
            double myx, double myy, double myz, double myt,
            double mzx, double mzy, double mzz, double mzt);

    private static final class NullAudioEQ implements AudioEqualizer {
        private boolean enabled = false;
        private Map&lt;Double, EqualizerBand&gt; bands
                = new HashMap&lt;Double,EqualizerBand&gt;();

        public boolean getEnabled() {
            return enabled;
        }

        public void setEnabled(boolean bEnable) {
            enabled = bEnable;
        }

        public EqualizerBand addBand(double centerFrequency, double bandwidth, double gain) {
            Double key = new Double(centerFrequency);
            if (bands.containsKey(key)) {
                removeBand(centerFrequency);
            }

            EqualizerBand newBand = new NullEQBand(centerFrequency, bandwidth, gain);
            bands.put(key, newBand);
            return newBand;
        }

        public boolean removeBand(double centerFrequency) {
            Double key = new Double(centerFrequency);
            if (bands.containsKey(key)) {
                bands.remove(key);
                return true;
            }
            return false;
        }
    }

    private static final class NullAudioSpectrum implements AudioSpectrum {
        private boolean enabled = false;
        private int bandCount = 128;
        private double interval = 0.1;
        private int threshold = 60;
        private float[] fakeData;

        public boolean getEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public int getBandCount() {
            return bandCount;
        }

        public void setBandCount(int bands) {
            bandCount = bands;
            fakeData = new float[bandCount];
        }

        public double getInterval() {
            return interval;
        }

        public void setInterval(double interval) {
            this.interval = interval;
        }

        public int getSensitivityThreshold() {
            return threshold;
        }

        public void setSensitivityThreshold(int threshold) {
            this.threshold = threshold;
        }

        public float[] getMagnitudes(float[] mag) {
            int size = fakeData.length;
            if (mag == null || mag.length &lt; size) {
                mag = new float[size];
            }
            System.arraycopy(fakeData, 0, mag, 0, size);
            return mag;
        }

        public float[] getPhases(float[] phs) {
            int size = fakeData.length;
            if (phs == null || phs.length &lt; size) {
                phs = new float[size];
            }
            System.arraycopy(fakeData, 0, phs, 0, size);
            return phs;
        }
    }

    private static final class NullEQBand implements EqualizerBand {
        private double center;
        private double bandwidth;
        private double gain;
<A NAME="12"></A>
        NullEQBand(double center, double bandwidth, double gain) {
            this.center = center;
            <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#12',2,'match44-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.bandwidth = bandwidth;
            this.gain = gain;
        }

        public double getCenterFrequency() {
            return center;
        }

        public void setCenterFrequency(double centerFrequency) {
            center = centerFrequency;
        }

        public double getBandwidth() {
            return bandwidth;
        }

        public void setBandwidth(double bandwidth) {
            this.bandwidth = bandwidth;
        }

        public double getGain() {
            return gain;
        }

        public void setGain(double gain) {
            this.gain = gain;
        }
    }</B></FONT>

    private final class MediaPlayerOverlayImpl implements MediaPlayerOverlay {

        @Override
        public void setOverlayX(final double x) {
            handleError(iosSetOverlayX(iosMedia.getNativeMediaRef(), x));
        }

        @Override
        public void setOverlayY(final double y) {
            handleError(iosSetOverlayY(iosMedia.getNativeMediaRef(), y));
        }

        @Override
        public void setOverlayVisible(final boolean visible) {
            handleError(iosSetOverlayVisible(iosMedia.getNativeMediaRef(), visible));
        }

        @Override
        public void setOverlayWidth(final double width) {
            handleError(iosSetOverlayWidth(iosMedia.getNativeMediaRef(), width));
        }

        @Override
        public void setOverlayHeight(final double height) {
            handleError(iosSetOverlayHeight(iosMedia.getNativeMediaRef(), height));
        }

        @Override
        public void setOverlayPreserveRatio(final boolean preserveRatio) {
            handleError(iosSetOverlayPreserveRatio(iosMedia.getNativeMediaRef(), preserveRatio));
        }

        @Override
        public void setOverlayOpacity(final double opacity) {
            handleError(iosSetOverlayOpacity(iosMedia.getNativeMediaRef(), opacity));
        }

        @Override
        public void setOverlayTransform(
                final double mxx, final double mxy, final double mxz, final double mxt,
                final double myx, final double myy, final double myz, final double myt,
                final double mzx, final double mzy, final double mzz, final double mzt) {
            handleError(iosSetOverlayTransform(
                    iosMedia.getNativeMediaRef(),
                    mxx, mxy, mxz, mxt,
                    myx, myy, myz, myt,
                    mzx, mzy, mzz, mzt));
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/javafx/scene/media/Media.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.media;

import com.sun.media.jfxmedia.MetadataParser;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.scene.image.Image;
import javafx.util.Duration;

import com.sun.media.jfxmedia.locator.Locator;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import com.sun.media.jfxmedia.events.MetadataListener;
import com.sun.media.jfxmedia.track.VideoResolution;

/**
 * The &lt;code&gt;Media&lt;/code&gt; class represents a media resource. It is instantiated
 * from the string form of a source URI. Information about the media such as
 * duration, metadata, tracks, and video resolution may be obtained from a
 * &lt;code&gt;Media&lt;/code&gt; instance. The media information is obtained asynchronously
 * and so not necessarily available immediately after instantiation of the class.
 * All information should however be available if the instance has been
 * associated with a {@link MediaPlayer} and that player has transitioned to
 * {@link MediaPlayer.Status#READY} status. To be notified when metadata or
 * {@link Track}s are added, observers may be registered with the collections
 * returned by {@link #getMetadata()}and {@link #getTracks()}, respectively.
 *
 * &lt;p&gt;The same &lt;code&gt;Media&lt;/code&gt; object may be shared among multiple
 * &lt;code&gt;MediaPlayer&lt;/code&gt; objects. Such a shared instance might manage a single
 * copy of the source media data to be used by all players, or it might require a
 * separate copy of the data for each player. The choice of implementation will
 * not however have any effect on player behavior at the interface level.&lt;/p&gt;
 *
 * @see MediaPlayer
 * @see MediaException
 * @since JavaFX 2.0
 */
public final class Media {
    /**
     * A property set to a MediaException value when an error occurs.
     * If &lt;code&gt;error&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, then the media could not
     * be loaded and is not usable. If {@link #onErrorProperty onError} is non-&lt;code&gt;null&lt;/code&gt;,
     * it will be invoked when the &lt;code&gt;error&lt;/code&gt; property is set.
     *
     * @see MediaException
     */
    private ReadOnlyObjectWrapper&lt;MediaException&gt; error;

    private void setError(MediaException value) {
        if (getError() == null) {
            errorPropertyImpl().set(value);
        }
    }

    /**
     * Return any error encountered in the media.
     * @return a {@link MediaException} or &lt;code&gt;null&lt;/code&gt; if there is no error.
     */
    public final MediaException getError() {
        return error == null ? null : error.get();
    }

    public ReadOnlyObjectProperty&lt;MediaException&gt; errorProperty() {
        return errorPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;MediaException&gt; errorPropertyImpl() {
        if (error == null) {
            error = new ReadOnlyObjectWrapper&lt;MediaException&gt;() {

                @Override
                protected void invalidated() {
                    if (getOnError() != null) {
                        Platform.runLater(getOnError());
                    }
                }

                @Override
                public Object getBean() {
                    return Media.this;
                }

                @Override
                public String getName() {
                    return &quot;error&quot;;
                }
            };
        }
        return error;
    }
    /**
     * Event handler called when an error occurs. This will happen
     * if a malformed or invalid URL is passed to the constructor or there is
     * a problem accessing the URL.
     */
    private ObjectProperty&lt;Runnable&gt; onError;

    /**
     * Set the event handler to be called when an error occurs.
     * @param value the error event handler.
     */
    public final void setOnError(Runnable value) {
        onErrorProperty().set(value);
    }

    /**
     * Retrieve the error handler to be called if an error occurs.
     * @return the error handler or &lt;code&gt;null&lt;/code&gt; if none is defined.
     */
    public final Runnable getOnError() {
        return onError == null ? null : onError.get();
    }

    public ObjectProperty&lt;Runnable&gt; onErrorProperty() {
        if (onError == null) {
            onError = new ObjectPropertyBase&lt;Runnable&gt;() {

                @Override
                protected void invalidated() {
                    /*
                     * if we have an existing error condition schedule the handler to be
                     * called immediately. This way the client app does not have to perform
                     * an explicit error check.
                     */
                    if (get() != null &amp;&amp; getError() != null) {
                        Platform.runLater(get());
                    }
                }

                @Override
                public Object getBean() {
                    return Media.this;
                }

                @Override
                public String getName() {
                    return &quot;onError&quot;;
                }
            };
        }
        return onError;
    }

    private MetadataListener metadataListener = new _MetadataListener();

    /**
     * An {@link ObservableMap} of metadata which can contain information about
     * the media. Metadata entries use {@link String}s for keys and contain
     * {@link Object} values. This map is unmodifiable: its contents or stored
     * values cannot be changed.
     */
    // FIXME: define standard metadata keys and the corresponding objects types
    // FIXME: figure out how to make the entries read-only to observers, we'll
    //        need to enhance javafx.collections a bit to accomodate this
    private ObservableMap&lt;String, Object&gt; metadata;

    /**
     * Retrieve the metadata contained in this media source. If there are
     * no metadata, the returned {@link ObservableMap} will be empty.
     * @return the metadata contained in this media source.
     */
    public final ObservableMap&lt;String, Object&gt; getMetadata() {
        return metadata;
    }

    private final ObservableMap&lt;String,Object&gt; metadataBacking = FXCollections.observableMap(new HashMap&lt;String,Object&gt;());
    /**
     * The width in pixels of the source media.
     * This may be zero if the media has no width, e.g., when playing audio,
     * or if the width is currently unknown which may occur with streaming
     * media.
     * @see height
     */
    private ReadOnlyIntegerWrapper width;


    final void setWidth(int value) {
        widthPropertyImpl().set(value);
    }

    /**
     * Retrieve the width in pixels of the media.
     * @return the media width or zero if the width is undefined or unknown.
     */
    public final int getWidth() {
        return width == null ? 0 : width.get();
    }

    public ReadOnlyIntegerProperty widthProperty() {
        return widthPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyIntegerWrapper widthPropertyImpl() {
        if (width == null) {
            width = new ReadOnlyIntegerWrapper(this, &quot;width&quot;);
        }
        return width;
    }
    /**
     * The height in pixels of the source media.
     * This may be zero if the media has no height, e.g., when playing audio,
     * or if the height is currently unknown which may occur with streaming
     * media.
     * @see width
     */
    private ReadOnlyIntegerWrapper height;


    final void setHeight(int value) {
        heightPropertyImpl().set(value);
    }

    /**
     * Retrieve the height in pixels of the media.
     * @return the media height or zero if the height is undefined or unknown.
     */
    public final int getHeight() {
        return height == null ? 0 : height.get();
    }

    public ReadOnlyIntegerProperty heightProperty() {
        return heightPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyIntegerWrapper heightPropertyImpl() {
        if (height == null) {
            height = new ReadOnlyIntegerWrapper(this, &quot;height&quot;);
        }
        return height;
    }
    /**
     * The duration in seconds of the source media. If the media duration is
     * unknown then this property value will be {@link Duration#UNKNOWN}.
     */
    private ReadOnlyObjectWrapper&lt;Duration&gt; duration;

    final void setDuration(Duration value) {
        durationPropertyImpl().set(value);
    }

    /**
     * Retrieve the duration in seconds of the media.
     * @return the duration of the media, {@link Duration#UNKNOWN} if unknown or {@link Duration#INDEFINITE} for live streams
     */
    public final Duration getDuration() {
        return duration == null || duration.get() == null ? Duration.UNKNOWN : duration.get();
    }

    public ReadOnlyObjectProperty&lt;Duration&gt; durationProperty() {
        return durationPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Duration&gt; durationPropertyImpl() {
        if (duration == null) {
            duration = new ReadOnlyObjectWrapper&lt;Duration&gt;(this, &quot;duration&quot;);
        }
        return duration;
    }
    /**
     * An &lt;code&gt;ObservableList&lt;/code&gt; of tracks contained in this media object.
     * A &lt;code&gt;Media&lt;/code&gt; object can contain multiple tracks, such as a video track
     * with several audio track. This list is unmodifiable: the contents cannot
     * be changed.
     * @see Track
     */
    private ObservableList&lt;Track&gt; tracks;

    /**
     * Retrieve the tracks contained in this media source. If there are
     * no tracks, the returned {@link ObservableList} will be empty.
     * @return the tracks contained in this media source.
     */
    public final ObservableList&lt;Track&gt; getTracks() {
        return tracks;
    }
    private final ObservableList&lt;Track&gt; tracksBacking = FXCollections.observableArrayList();

    /**
     * The markers defined on this media source. A marker is defined to be a
     * mapping from a name to a point in time between the beginning and end of
     * the media.
     */
    private ObservableMap&lt;String, Duration&gt; markers = FXCollections.observableMap(new HashMap&lt;String,Duration&gt;());

    /**
     * Retrieve the markers defined on this &lt;code&gt;Media&lt;/code&gt; instance. If
     * there are no markers the returned {@link ObservableMap} will be empty.
     * Programmatic markers may be added by inserting entries in the returned
     * &lt;code&gt;Map&lt;/code&gt;.
     *
     * @return the markers defined on this media source.
     */
    public final ObservableMap&lt;String, Duration&gt; getMarkers() {
        return markers;
    }

    /**
     * Constructs a &lt;code&gt;Media&lt;/code&gt; instance.  This is the only way to
     * specify the media source. The source must represent a valid &lt;code&gt;URI&lt;/code&gt;
     * and is immutable. Only HTTP, HTTPS, FILE, and JAR &lt;code&gt;URL&lt;/code&gt;s are supported. If the
     * provided URL is invalid then an exception will be thrown.  If an
     * asynchronous error occurs, the {@link #errorProperty error} property will be set. Listen
     * to this property to be notified of any such errors.
     *
     * &lt;p&gt;If the source uses a non-blocking protocol such as FILE, then any
     * problems which can be detected immediately will cause a &lt;code&gt;MediaException&lt;/code&gt;
     * to be thrown. Such problems include the media being inaccessible or in an
     * unsupported format. If however a potentially blocking protocol such as
     * HTTP is used, then the connection will be initialized asynchronously so
     * that these sorts of errors will be signaled by setting the {@link #errorProperty error}
     * property.&lt;/p&gt;
     *
     * &lt;p&gt;Constraints:
     * &lt;ul&gt;
     * &lt;li&gt;The supplied URI must conform to RFC-2396 as required by
     * &lt;A href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;java.net.URI&lt;/A&gt;.&lt;/li&gt;
     * &lt;li&gt;Only HTTP, HTTPS, FILE, and JAR URIs are supported.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;See &lt;A href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;java.net.URI&lt;/A&gt;
     * for more information about URI formatting in general.
     * JAR URL syntax is specified in &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/JarURLConnection.html&quot;&gt;java.net.JarURLConnection&lt;/A&gt;.
     *
     * @param source The URI of the source media.
     * @throws NullPointerException if the URI string is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if the URI string does not conform to RFC-2396
     * or, if appropriate, the Jar URL specification, or is in a non-compliant
     * form which cannot be modified to a compliant form.
     * @throws IllegalArgumentException if the URI string has a &lt;code&gt;null&lt;/code&gt;
     * scheme.
     * @throws UnsupportedOperationException if the protocol specified for the
     * source is not supported.
     * @throws MediaException if the media source cannot be connected
     * (type {@link MediaException.Type#MEDIA_INACCESSIBLE}) or is not supported
     * (type {@link MediaException.Type#MEDIA_UNSUPPORTED}).
     */
    public Media(@NamedArg(&quot;source&quot;) String source) {
        this.source = source;

        URI uri = null;
        try {
            // URI will throw NPE if source == null: do not catch it!
            uri = new URI(source);
        } catch(URISyntaxException use) {
            throw new IllegalArgumentException(use);
        }

        metadata = FXCollections.unmodifiableObservableMap(metadataBacking);
        tracks = FXCollections.unmodifiableObservableList(tracksBacking);

        Locator locator = null;
        try {
            locator = new com.sun.media.jfxmedia.locator.Locator(uri);
            jfxLocator = locator;
            if (locator.canBlock()) {
                InitLocator locatorInit = new InitLocator();
                Thread t = new Thread(locatorInit);
                t.setDaemon(true);
                t.start();
            } else {
                locator.init();
                runMetadataParser();
            }
        } catch(URISyntaxException use) {
            throw new IllegalArgumentException(use);
        } catch(FileNotFoundException fnfe) {
            throw new MediaException(MediaException.Type.MEDIA_UNAVAILABLE, fnfe.getMessage());
        } catch(IOException ioe) {
            throw new MediaException(MediaException.Type.MEDIA_INACCESSIBLE, ioe.getMessage());
        } catch(com.sun.media.jfxmedia.MediaException me) {
            throw new MediaException(MediaException.Type.MEDIA_UNSUPPORTED, me.getMessage());
        }
<A NAME="32"></A>    }

    private void runMetadataParser() {
        <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#32',2,'match44-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
            jfxParser = com.sun.media.jfxmedia.MediaManager.getMetadataParser(jfxLocator);
            jfxParser.addListener(metadataListener);
            jfxParser.startParser();
        } catch (Exception e) {
            jfxParser = null;
        }</B></FONT>
    }

    /**
     * The source URI of the media;
     */
    private final String source;

    /**
     * Retrieve the source URI of the media.
     * @return the media source URI as a {@link String}.
     */
    public String getSource() {
        return source;
    }

    /**
     * Locator used by the jfxmedia player, MediaPlayer needs access to this
     */
    private final Locator jfxLocator;
    Locator retrieveJfxLocator() {
        return jfxLocator;
    }

    private MetadataParser jfxParser;

    private Track getTrackWithID(long trackID) {
        for (Track track : tracksBacking) {
            if (track.getTrackID() == trackID) {
                return track;
            }
        }
        return null;
    }

    // http://javafx-jira.kenai.com/browse/RT-24594
    // TODO: Remove this entire method (and associated stuff) when we switch to track parsing in MetadataParser
    void _updateMedia(com.sun.media.jfxmedia.Media _media) {
        try {
            List&lt;com.sun.media.jfxmedia.track.Track&gt; trackList = _media.getTracks();

            if (trackList != null) {
                for (com.sun.media.jfxmedia.track.Track trackElement : trackList) {
                    long trackID = trackElement.getTrackID();
                    if (getTrackWithID(trackID) == null) {
                        Track newTrack = null;
                        Map&lt;String,Object&gt; trackMetadata = new HashMap&lt;String,Object&gt;();
                        if (null != trackElement.getName()) {
                            // FIXME: need constants for metadata keys (globally)
                            trackMetadata.put(&quot;name&quot;, trackElement.getName());
                        }
                        if (null != trackElement.getLocale()) {
                            trackMetadata.put(&quot;locale&quot;, trackElement.getLocale());
                        }
                        trackMetadata.put(&quot;encoding&quot;, trackElement.getEncodingType().toString());
                        trackMetadata.put(&quot;enabled&quot;, Boolean.valueOf(trackElement.isEnabled()));

                        if (trackElement instanceof com.sun.media.jfxmedia.track.VideoTrack) {
                            com.sun.media.jfxmedia.track.VideoTrack vt =
                                    (com.sun.media.jfxmedia.track.VideoTrack) trackElement;

                            int videoWidth = vt.getFrameSize().getWidth();
                            int videoHeight = vt.getFrameSize().getHeight();

                            // FIXME: this isn't valid when there are multiple video tracks...
                            setWidth(videoWidth);
                            setHeight(videoHeight);

                            trackMetadata.put(&quot;video width&quot;, Integer.valueOf(videoWidth));
                            trackMetadata.put(&quot;video height&quot;, Integer.valueOf(videoHeight));

                            newTrack = new VideoTrack(trackElement.getTrackID(), trackMetadata);
                        } else if (trackElement instanceof com.sun.media.jfxmedia.track.AudioTrack) {
                            newTrack = new AudioTrack(trackElement.getTrackID(), trackMetadata);
                        } else if (trackElement instanceof com.sun.media.jfxmedia.track.SubtitleTrack) {
                            newTrack = new SubtitleTrack(trackID, trackMetadata);
                        }

                        if (null != newTrack) {
                            tracksBacking.add(newTrack);
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Save any async exceptions as an error.
            setError(new MediaException(MediaException.Type.UNKNOWN, e));
        }
    }

    void _setError(MediaException.Type type, String message) {
        setError(new MediaException(type, message));
    }

    private synchronized void updateMetadata(Map&lt;String, Object&gt; metadata) {
        if (metadata != null) {
            for (Map.Entry&lt;String,Object&gt; entry : metadata.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();
                if (key.equals(MetadataParser.IMAGE_TAG_NAME) &amp;&amp; value instanceof byte[]) {
                    byte[] imageData = (byte[]) value;
                    Image image = new Image(new ByteArrayInputStream(imageData));
                    if (!image.isError()) {
                        metadataBacking.put(MetadataParser.IMAGE_TAG_NAME, image);
                    }
                } else if (key.equals(MetadataParser.DURATION_TAG_NAME) &amp;&amp; value instanceof java.lang.Long) {
                    Duration d = new Duration((Long) value);
                    if (d != null) {
                        metadataBacking.put(MetadataParser.DURATION_TAG_NAME, d);
                    }
                } else {
                    metadataBacking.put(key, value);
                }
            }
        }
    }

    private class _MetadataListener implements MetadataListener {
        @Override
        public void onMetadata(final Map&lt;String, Object&gt; metadata) {
            // Clean up metadata
            Platform.runLater(() -&gt; {
                updateMetadata(metadata);
                jfxParser.removeListener(metadataListener);
                jfxParser.stopParser();
                jfxParser = null;
            });
        }
    }

    private class InitLocator implements Runnable {

        @Override
        public void run() {
            try {
                jfxLocator.init();
                runMetadataParser();
            } catch (URISyntaxException use) {
                _setError(MediaException.Type.OPERATION_UNSUPPORTED, use.getMessage());
            } catch (FileNotFoundException fnfe) {
                _setError(MediaException.Type.MEDIA_UNAVAILABLE, fnfe.getMessage());
            } catch (IOException ioe) {
                _setError(MediaException.Type.MEDIA_INACCESSIBLE, ioe.getMessage());
            } catch (com.sun.media.jfxmedia.MediaException me) {
                _setError(MediaException.Type.MEDIA_UNSUPPORTED, me.getMessage());
            } catch (Exception e) {
                _setError(MediaException.Type.UNKNOWN, e.getMessage());
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/CursorManagerImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<A NAME="0"></A>
package com.sun.javafx.webkit;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#0',2,'match44-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.javafx.tk.Toolkit;
import com.sun.webkit.CursorManager;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.graphics.WCImage;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import javafx.scene.Cursor;
import javafx.scene.ImageCursor;
import javafx.scene.image.Image;

public final class CursorManagerImpl extends CursorManager&lt;Cursor&gt; {

    private final Map&lt;String, Cursor&gt; map = new HashMap&lt;String, Cursor&gt;();
    private ResourceBundle bundle;

    @Override protected Cursor getCustomCursor(WCImage image</B></FONT>, int hotspotX, int hotspotY) {
        return new ImageCursor(
                Toolkit.getImageAccessor().fromPlatformImage(
                    WCGraphicsManager.getGraphicsManager().toPlatformImage(image)),
                hotspotX, hotspotY);
    }

    @Override protected Cursor getPredefinedCursor(int type) {
        switch (type) {
            default:
            case POINTER:                      return                                   Cursor.DEFAULT;
            case CROSS:                        return                                   Cursor.CROSSHAIR;
            case HAND:                         return                                   Cursor.HAND;
            case MOVE:                         return                                   Cursor.MOVE;
            case TEXT:                         return                                   Cursor.TEXT;
            case WAIT:                         return                                   Cursor.WAIT;
            case HELP:                         return getCustomCursor(&quot;help&quot;,           Cursor.DEFAULT);
            case EAST_RESIZE:                  return                                   Cursor.E_RESIZE;
            case NORTH_RESIZE:                 return                                   Cursor.N_RESIZE;
            case NORTH_EAST_RESIZE:            return                                   Cursor.NE_RESIZE;
            case NORTH_WEST_RESIZE:            return                                   Cursor.NW_RESIZE;
            case SOUTH_RESIZE:                 return                                   Cursor.S_RESIZE;
            case SOUTH_EAST_RESIZE:            return                                   Cursor.SE_RESIZE;
            case SOUTH_WEST_RESIZE:            return                                   Cursor.SW_RESIZE;
            case WEST_RESIZE:                  return                                   Cursor.W_RESIZE;
            case NORTH_SOUTH_RESIZE:           return                                   Cursor.V_RESIZE;
            case EAST_WEST_RESIZE:             return                                   Cursor.H_RESIZE;
            case NORTH_EAST_SOUTH_WEST_RESIZE: return getCustomCursor(&quot;resize.nesw&quot;,    Cursor.DEFAULT);
            case NORTH_WEST_SOUTH_EAST_RESIZE: return getCustomCursor(&quot;resize.nwse&quot;,    Cursor.DEFAULT);
            case COLUMN_RESIZE:                return getCustomCursor(&quot;resize.column&quot;,  Cursor.H_RESIZE);
            case ROW_RESIZE:                   return getCustomCursor(&quot;resize.row&quot;,     Cursor.V_RESIZE);
            case MIDDLE_PANNING:               return getCustomCursor(&quot;panning.middle&quot;, Cursor.DEFAULT);
            case EAST_PANNING:                 return getCustomCursor(&quot;panning.east&quot;,   Cursor.DEFAULT);
            case NORTH_PANNING:                return getCustomCursor(&quot;panning.north&quot;,  Cursor.DEFAULT);
            case NORTH_EAST_PANNING:           return getCustomCursor(&quot;panning.ne&quot;,     Cursor.DEFAULT);
            case NORTH_WEST_PANNING:           return getCustomCursor(&quot;panning.nw&quot;,     Cursor.DEFAULT);
            case SOUTH_PANNING:                return getCustomCursor(&quot;panning.south&quot;,  Cursor.DEFAULT);
            case SOUTH_EAST_PANNING:           return getCustomCursor(&quot;panning.se&quot;,     Cursor.DEFAULT);
            case SOUTH_WEST_PANNING:           return getCustomCursor(&quot;panning.sw&quot;,     Cursor.DEFAULT);
            case WEST_PANNING:                 return getCustomCursor(&quot;panning.west&quot;,   Cursor.DEFAULT);
            case VERTICAL_TEXT:                return getCustomCursor(&quot;vertical.text&quot;,  Cursor.DEFAULT);
            case CELL:                         return getCustomCursor(&quot;cell&quot;,           Cursor.DEFAULT);
            case CONTEXT_MENU:                 return getCustomCursor(&quot;context.menu&quot;,   Cursor.DEFAULT);
            case NO_DROP:                      return getCustomCursor(&quot;no.drop&quot;,        Cursor.DEFAULT);
            case NOT_ALLOWED:                  return getCustomCursor(&quot;not.allowed&quot;,    Cursor.DEFAULT);
            case PROGRESS:                     return getCustomCursor(&quot;progress&quot;,       Cursor.WAIT);
            case ALIAS:                        return getCustomCursor(&quot;alias&quot;,          Cursor.DEFAULT);
            case ZOOM_IN:                      return getCustomCursor(&quot;zoom.in&quot;,        Cursor.DEFAULT);
            case ZOOM_OUT:                     return getCustomCursor(&quot;zoom.out&quot;,       Cursor.DEFAULT);
            case COPY:                         return getCustomCursor(&quot;copy&quot;,           Cursor.DEFAULT);
            case NONE:                         return                                   Cursor.NONE;
            case GRAB:                         return getCustomCursor(&quot;grab&quot;,           Cursor.OPEN_HAND);
            case GRABBING:                     return getCustomCursor(&quot;grabbing&quot;,       Cursor.CLOSED_HAND);
        }
    }

    private Cursor getCustomCursor(String name, Cursor predefined) {
        Cursor cursor = this.map.get(name);
        if (cursor == null) {
            try {
                if (bundle == null) {
                    bundle = ResourceBundle.getBundle(&quot;com.sun.javafx.webkit.Cursors&quot;, Locale.getDefault());
                }
                if (bundle != null) {
                    String resource = bundle.getString(name + &quot;.file&quot;);
                    Image image = new Image(CursorManagerImpl.class.getResourceAsStream(resource));

                    resource = bundle.getString(name + &quot;.hotspotX&quot;);
                    int hotspotX = Integer.parseInt(resource);

                    resource = bundle.getString(name + &quot;.hotspotY&quot;);
                    int hotspotY = Integer.parseInt(resource);

                    cursor = new ImageCursor(image, hotspotX, hotspotY);
                }
            } catch (MissingResourceException e) {
                // ignore, treat cursor as missing, use predefined instead
            }
            if (cursor == null) {
                cursor = predefined;
            }
            this.map.put(name, cursor);
        }
        return cursor;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/event/WCFocusEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.event;

import java.lang.annotation.Native;

<A NAME="14"></A>public final class WCFocusEvent {

    // id
    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#14',2,'match44-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native public final static int WINDOW_ACTIVATED = 0;
    @Native public final static int WINDOW_DEACTIVATED = 1;
    @Native public final static int FOCUS_GAINED = 2;
    @Native public final static int FOCUS_LOST = 3;

    // direction
    @Native public final static int UNKNOWN = -1;
    @Native public final static int FORWARD = 0;
    @Native public final static int BACKWARD = 1;

    private final int id;
    private final int direction;

    public WCFocusEvent(int id, int direction</B></FONT>) {
        this.id = id;
        this.direction = direction;
    }

    public int getID() { return id; }

    public int getDirection() { return direction; }

    @Override
    public String toString() {
        return &quot;WCFocusEvent(&quot; + id + &quot;, &quot; + direction + &quot;)&quot;;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/javafx/scene/web/WebEngine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.web;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.scene.web.Debugger;
import com.sun.javafx.scene.web.Printable;
import com.sun.javafx.tk.TKPulseListener;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.webkit.*;
import com.sun.javafx.webkit.prism.PrismGraphicsManager;
import com.sun.javafx.webkit.prism.PrismInvoker;
import com.sun.javafx.webkit.prism.theme.PrismRenderer;
import com.sun.javafx.webkit.theme.RenderThemeImpl;
import com.sun.javafx.webkit.theme.Renderer;
import com.sun.webkit.*;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.network.URLs;
import com.sun.webkit.network.Util;
import javafx.animation.AnimationTimer;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.property.*;
import javafx.concurrent.Worker;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Rectangle2D;
import javafx.print.PageLayout;
import javafx.print.PrinterJob;
import javafx.scene.Node;
import javafx.util.Callback;
import org.w3c.dom.Document;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import static java.lang.String.format;
import java.lang.ref.WeakReference;
import java.net.MalformedURLException;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.PosixFilePermissions;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Objects;

import static com.sun.webkit.LoadListenerClient.*;

/**
 * {@code WebEngine} is a non-visual object capable of managing one Web page
 * at a time. It loads Web pages, creates their document models, applies
 * styles as necessary, and runs JavaScript on pages. It provides access
 * to the document model of the current page, and enables two-way
 * communication between a Java application and JavaScript code of the page.
 *
 * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
 * {@code WebEngine} object:
 * &lt;ul&gt;
 * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
 *     the {@code java.net} package for network access and protocol handling.
 * &lt;li&gt;From an in-memory String using the
 *     {@link #loadContent(java.lang.String, java.lang.String)} and
 *     {@link #loadContent(java.lang.String)} methods.
 * &lt;/ul&gt;
 * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
 * loading return immediately after scheduling a background job. To track
 * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
 * instance available from the {@link #getLoadWorker} method.
 *
 * &lt;p&gt;The following example changes the stage title when loading completes
 * successfully:
 * &lt;pre&gt;{@code
    import javafx.concurrent.Worker.State;
    final Stage stage;
    webEngine.getLoadWorker().stateProperty().addListener(
        new ChangeListener&lt;State&gt;() {
            public void changed(ObservableValue ov, State oldState, State newState) {
                if (newState == State.SUCCEEDED) {
                    stage.setTitle(webEngine.getLocation());
                }
            }
        });
    webEngine.load(&quot;http://javafx.com&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;A number of user interface callbacks may be registered with a
 * {@code WebEngine} object. These callbacks are invoked when a script running
 * on the page requests a user interface operation to be performed, for
 * example, opens a popup window or changes status text. A {@code WebEngine}
 * object cannot handle such requests internally, so it passes the request to
 * the corresponding callbacks. If no callback is defined for a specific
 * operation, the request is silently ignored.
 *
 * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 * with their corresponding {@code WebEngine} callbacks:
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 * &lt;tr&gt;
 *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;The following example shows a callback that resizes a browser window:
 * &lt;pre&gt;{@code
    Stage stage;
    webEngine.setOnResized(
        new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
            public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
                Rectangle2D r = ev.getData();
                stage.setWidth(r.getWidth());
                stage.setHeight(r.getHeight());
            }
        });
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 * (DOM) for their Web pages. The model can be accessed and modified using
 * Java DOM Core classes. The {@link #getDocument()} method provides access
 * to the root of the model. Additionally DOM Event specification is supported
 * to define event handlers in Java code.
 *
 * &lt;p&gt;The following example attaches a Java event listener to an element of
 * a Web page. Clicking on the element causes the application to exit:
 * &lt;pre&gt;{@code
    EventListener listener = new EventListener() {
        public void handleEvent(Event ev) {
            Platform.exit();
        }
    };

    Document doc = webEngine.getDocument();
    Element el = doc.getElementById(&quot;exit-app&quot;);
    ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 * the current page using the {@link #executeScript} method. For example:
 * &lt;pre&gt;{@code
    webEngine.executeScript(&quot;history.back()&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;The execution result is returned to the caller,
 * as described in the next section.
 *
 * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 *
 * JavaScript values are represented using the obvious Java classes:
 * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 * and a string becomes a {@code java.lang.String}.
 * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 * depending.
 * The undefined value maps to a specific unique String
 * object whose value is {@code &quot;undefined&quot;}.
 * &lt;p&gt;
 * If the result is a
 * JavaScript object, it is wrapped as an instance of the
 * {@link netscape.javascript.JSObject} class.
 * (As a special case, if the JavaScript object is
 * a {@code JavaRuntimeObject} as discussed in the next section,
 * then the original Java object is extracted instead.)
 * The {@code JSObject} class is a proxy that provides access to
 * methods and properties of its underlying JavaScript object.
 * The most commonly used {@code JSObject} methods are
 * {@link netscape.javascript.JSObject#getMember getMember}
 * (to read a named property),
 * {@link netscape.javascript.JSObject#setMember setMember}
 * (to set or define a property),
 * and {@link netscape.javascript.JSObject#call call}
 * (to call a function-valued property).
 * &lt;p&gt;
 * A DOM {@code Node} is mapped to an object that both extends
 * {@code JSObject} and implements the appropriate DOM interfaces.
 * To get a {@code JSObject} object for a {@code Node} just do a cast:
 * &lt;pre&gt;
 * JSObject jdoc = (JSObject) webEngine.getDocument();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In some cases the context provides a specific Java type that guides
 * the conversion.
 * For example if setting a Java {@code String} field from a JavaScript
 * expression, then the JavaScript value is converted to a string.
 *
 * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 *
 * The arguments of the {@code JSObject} methods {@code setMember} and
 * {@code call} pass Java objects to the JavaScript environment.
 * This is roughly the inverse of the JavaScript-to-Java mapping
 * described above:
 * Java {@code String},  {@code Number}, or {@code Boolean} objects
 * are converted to the obvious JavaScript values. A  {@code JSObject}
 * object is converted to the original wrapped JavaScript object.
 * Otherwise a {@code JavaRuntimeObject} is created.  This is
 * a JavaScript object that acts as a proxy for the Java object,
 * in that accessing properties of the {@code JavaRuntimeObject}
 * causes the Java field or method with the same name to be accessed.
 * &lt;p&gt; Note that the Java objects bound using
 * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 * {@link netscape.javascript.JSObject#call JSObject.call}
 * are implemented using weak references. This means that the Java object
 * can be garbage collected, causing subsequent accesses to the JavaScript
 * objects to have no effect.
 *
 * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 * method is useful to enable upcalls from JavaScript
 * into Java code, as illustrated by the following example. The Java code
 * establishes a new JavaScript object named {@code app}. This object has one
 * public member, the method {@code exit}.
 * &lt;pre&gt;&lt;code&gt;
public class JavaApplication {
    public void exit() {
        Platform.exit();
    }
}
...
JavaApplication javaApp = new JavaApplication();
JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
window.setMember(&quot;app&quot;, javaApp);
 * &lt;/code&gt;&lt;/pre&gt;
 * You can then refer to the object and the method from your HTML page:
 * &lt;pre&gt;{@code
    &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 * }&lt;/pre&gt;
 * &lt;p&gt;When a user clicks the link the application is closed.
 * &lt;p&gt;
 * Note that in the above example, the application holds a reference
 * to the {@code JavaApplication} instance. This is required for the callback
 * from JavaScript to execute the desired method.
 * &lt;p&gt; In the following example, the application does not hold a reference
 * to the Java object:
 * &lt;pre&gt;&lt;code&gt;
 * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 * window.setMember(&quot;app&quot;, new JavaApplication());
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 * the value may be garbage collected in next GC cycle.
 * &lt;p&gt;
 * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 * &lt;p&gt;
 * If there are multiple Java methods with the given name,
 * then the engine selects one matching the number of parameters
 * in the call.  (Varargs are not handled.) An unspecified one is
 * chosen if there are multiple ones with the correct number of parameters.
 * &lt;p&gt;
 * You can pick a specific overloaded method by listing the
 * parameter types in an &quot;extended method name&quot;, which has the
 * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you'd write the JavaScript expression:
 * &lt;pre&gt;
 * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The Java class and method must both be declared public.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * If any Java class passed to JavaScript is in a named module, then it must
 * be reflectively accessible to the {@code javafx.web} module.
 * A class is reflectively accessible if the module
 * {@link Module#isOpen(String,Module) opens} the containing package to at
 * least the {@code javafx.web} module.
 * Otherwise, the method will not be called, and no error or
 * warning will be produced.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 * the {@code module-info.java} might
 * look like this:
 * &lt;/p&gt;
 *
&lt;pre&gt;{@code module foo.app {
    opens com.foo to javafx.web;
}}&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Alternatively, a class is reflectively accessible if the module
 * {@link Module#isExported(String) exports} the containing package
 * unconditionally.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 * objects obtained from the {@code WebEngine} object.
 * @since JavaFX 2.0
 */
final public class WebEngine {
    static {
        Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());

        Invoker.setInvoker(new PrismInvoker());
        Renderer.setRenderer(new PrismRenderer());
        WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
        CursorManager.setCursorManager(new CursorManagerImpl());
        com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
        ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
        Utilities.setUtilities(new UtilitiesImpl());
    }

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(WebEngine.class.getName());

    /**
     * The number of instances of this class.
     * Used to start and stop the pulse timer.
     */
    private static int instanceCount = 0;

    /**
     * The node associated with this engine. There is a one-to-one correspondence
     * between the WebView and its WebEngine (although not all WebEngines have
     * a WebView, every WebView has one and only one WebEngine).
     */
    private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);

    /**
     * The Worker which shows progress of the web engine as it loads pages.
     */
    private final LoadWorker loadWorker = new LoadWorker();

    /**
     * The object that provides interaction with the native webkit core.
     */
    private final WebPage page;

    private final SelfDisposer disposer;

    private final DebuggerImpl debugger = new DebuggerImpl();

    private boolean userDataDirectoryApplied = false;


    /**
     * Returns a {@link javafx.concurrent.Worker} object that can be used to
     * track loading progress.
     *
     * @return the {@code Worker} object
     */
    public final Worker&lt;Void&gt; getLoadWorker() {
        return loadWorker;
    }


    /*
     * The final document. This may be null if no document has been loaded.
     */
    private final DocumentProperty document = new DocumentProperty();

    public final Document getDocument() { return document.getValue(); }

    /**
     * Document object for the current Web page. The value is {@code null}
     * if the Web page failed to load.
     *
     * @return the document property
     */
    public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
        return document;
    }


    /*
     * The location of the current page. This may return null.
     */
    private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);

    public final String getLocation() { return location.getValue(); }

    /**
     * URL of the current Web page. If the current page has no URL,
     * the value is an empty String.
     *
     * @return the location property
     */
    public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }

    private void updateLocation(String value) {
        this.location.set(value);
        this.document.invalidate(false);
        this.title.set(null);
    }


    /*
     * The page title.
     */
    private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);

    public final String getTitle() { return title.getValue(); }

    /**
     * Title of the current Web page. If the current page has no title,
     * the value is {@code null}.
     *
     * @return the title property
     */
    public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

    private void updateTitle() {
        title.set(page.getTitle(page.getMainFrame()));
    }

    //
    // Settings

    /**
     * Specifies whether JavaScript execution is enabled.
     *
     * @defaultValue true
     * @since JavaFX 2.2
     */
    private BooleanProperty javaScriptEnabled;

    public final void setJavaScriptEnabled(boolean value) {
        javaScriptEnabledProperty().set(value);
    }

    public final boolean isJavaScriptEnabled() {
        return javaScriptEnabled == null ? true : javaScriptEnabled.get();
    }

    public final BooleanProperty javaScriptEnabledProperty() {
        if (javaScriptEnabled == null) {
            javaScriptEnabled = new BooleanPropertyBase(true) {
                @Override public void invalidated() {
                    checkThread();
                    page.setJavaScriptEnabled(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;javaScriptEnabled&quot;;
                }
            };
        }
        return javaScriptEnabled;
    }

    /**
     * Location of the user stylesheet as a string URL.
     *
     * &lt;p&gt;This should be a local URL, i.e. either {@code 'data:'},
     * {@code 'file:'}, or {@code 'jar:'}. Remote URLs are not allowed
     * for security reasons.
     *
     * @defaultValue null
     * @since JavaFX 2.2
     */
    private StringProperty userStyleSheetLocation;

    public final void setUserStyleSheetLocation(String value) {
        userStyleSheetLocationProperty().set(value);
    }

    public final String getUserStyleSheetLocation() {
        return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
    }

    private byte[] readFully(BufferedInputStream in) throws IOException {
        final int BUF_SIZE = 4096;
        int outSize = 0;
        final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
        byte[] buffer = new byte[BUF_SIZE];

        while (true) {
            int nBytes = in.read(buffer);
            if (nBytes &lt; 0) break;

            byte[] chunk;
            if (nBytes == buffer.length) {
                chunk = buffer;
                buffer = new byte[BUF_SIZE];
            } else {
                chunk = new byte[nBytes];
                System.arraycopy(buffer, 0, chunk, 0, nBytes);
            }
            outList.add(chunk);
            outSize += nBytes;
        }

        final byte[] out = new byte[outSize];
        int outPos = 0;
        for (byte[] chunk : outList) {
            System.arraycopy(chunk, 0, out, outPos, chunk.length);
            outPos += chunk.length;
        }

        return out;
    }

    public final StringProperty userStyleSheetLocationProperty() {
        if (userStyleSheetLocation == null) {
            userStyleSheetLocation = new StringPropertyBase(null) {
                private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;

                @Override public void invalidated() {
                    checkThread();
                    String url = get();
                    String dataUrl;
                    if (url == null || url.length() &lt;= 0) {
                        dataUrl = null;
                    } else if (url.startsWith(DATA_PREFIX)) {
                        dataUrl = url;
                    } else if (url.startsWith(&quot;file:&quot;) ||
                               url.startsWith(&quot;jar:&quot;)  ||
                               url.startsWith(&quot;data:&quot;))
                    {
                        try {
                            URLConnection conn = URLs.newURL(url).openConnection();
                            conn.connect();

                            BufferedInputStream in =
                                    new BufferedInputStream(conn.getInputStream());
                            byte[] inBytes = readFully(in);
                            String out = Base64.getMimeEncoder().encodeToString(inBytes);
                            dataUrl = DATA_PREFIX + out;
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } else {
                        throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
                    }
                    page.setUserStyleSheetLocation(dataUrl);
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userStyleSheetLocation&quot;;
                }
            };
        }
        return userStyleSheetLocation;
    }

    /**
     * Specifies the directory to be used by this {@code WebEngine}
     * to store local user data.
     *
     * &lt;p&gt;If the value of this property is not {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in the respective directory.
     * If the value of this property is {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in an automatically selected system-dependent user- and
     * application-specific directory.
     *
     * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
     * page or executing a script for the first time, it checks whether
     * it can actually use the directory specified by this property.
     * If the check fails for some reason, the {@code WebEngine} invokes
     * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
     * if any, with a {@link WebErrorEvent} describing the reason.
     * If the invoked event handler modifies the {@code userDataDirectory}
     * property, the {@code WebEngine} retries with the new value as soon
     * as the handler returns. If the handler does not modify the
     * {@code userDataDirectory} property (which is the default),
     * the {@code WebEngine} continues without local user data.
     *
     * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
     * executing a script, changes made to this property have no effect
     * on where the {@code WebEngine} stores or will store local user
     * data.
     *
     * &lt;p&gt;Currently, the directory specified by this property is used
     * only to store the data that backs the {@code window.localStorage}
     * objects. In the future, more types of data can be added.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;File&gt; userDataDirectory =
            new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);

    public final File getUserDataDirectory() {
        return userDataDirectory.get();
    }

    public final void setUserDataDirectory(File value) {
        userDataDirectory.set(value);
    }

    public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
        return userDataDirectory;
    }

    /**
     * Specifies user agent ID string. This string is the value of the
     * {@code User-Agent} HTTP header.
     *
     * @defaultValue system dependent
     * @since JavaFX 8.0
     */
    private StringProperty userAgent;

    public final void setUserAgent(String value) {
        userAgentProperty().set(value);
    }

    public final String getUserAgent() {
        return userAgent == null ? page.getUserAgent() : userAgent.get();
    }

    public final StringProperty userAgentProperty() {
        if (userAgent == null) {
            userAgent = new StringPropertyBase(page.getUserAgent()) {
                @Override public void invalidated() {
                    checkThread();
                    page.setUserAgent(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userAgent&quot;;
                }
            };
        }
        return userAgent;
    }

    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }

    public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }

    /**
     * JavaScript {@code alert} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code alert} function.
     * @return the onAlert property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }

    public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }

    /**
     * JavaScript status handler property. This handler is invoked when
     * a script running on the Web page sets {@code window.status} property.
     * @return the onStatusChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);

    public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }

    public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }

    /**
     * JavaScript window resize handler property. This handler is invoked
     * when a script running on the Web page moves or resizes the
     * {@code window} object.
     * @return the onResized property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }

    public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }

    /**
     * JavaScript window visibility handler property. This handler is invoked
     * when a script running on the Web page changes visibility of the
     * {@code window} object.
     * @return the onVisibilityChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }


    private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
            = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
            p -&gt; WebEngine.this);

    public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }

    public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }

    /**
     * JavaScript popup handler property. This handler is invoked when a script
     * running on the Web page requests a popup to be created.
     * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
     * attach a visibility handler and optionally a resize handler, and return
     * the newly created engine. To block the popup, a handler should return
     * {@code null}.
     * &lt;p&gt;By default, a popup handler is installed that opens popups in this
     * {@code WebEngine}.
     *
     * @return the createPopupHandler property
     *
     * @see PopupFeatures
     */
    public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }


    private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
            = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);

    public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }

    public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }

    /**
     * JavaScript {@code confirm} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code confirm} function.
     * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
     * and return the user's choice.
     *
     * @return the confirmHandler property
     */
    public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }


    private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
            = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);

    public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }

    public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }

    /**
     * JavaScript {@code prompt} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code prompt} function.
     * &lt;p&gt;An implementation may display a dialog box with an text field,
     * and return the user's input.
     *
     * @return the promptHandler property
     * @see PromptData
     */
    public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }

    /**
     * The event handler called when an error occurs.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
            new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);

    public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
        return onError.get();
    }

    public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
        onError.set(handler);
    }

    public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
        return onError;
    }


    /**
     * Creates a new engine.
     */
    public WebEngine() {
        this(null, false);
    }

    /**
     * Creates a new engine and loads a Web page into it.
     *
     * @param url the URL of the web page to load
     */
    public WebEngine(String url) {
        this(url, true);
    }

    private WebEngine(String url, boolean callLoad) {
        checkThread();
        Accessor accessor = new AccessorImpl(this);
        page = new WebPage(
            new WebPageClientImpl(accessor),
            new UIClientImpl(accessor),
            null,
            new InspectorClientImpl(this),
            new ThemeClientImpl(accessor),
            false);
        page.addLoadListenerClient(new PageLoadListener(this));

        history = new WebHistory(page);

        disposer = new SelfDisposer(page);
        Disposer.addRecord(this, disposer);

        if (callLoad) {
            load(url);
        }

        if (instanceCount == 0 &amp;&amp;
            Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
        {
            PulseTimer.start();
        }
        instanceCount++;
    }

    /**
     * Loads a Web page into this engine. This method starts asynchronous
     * loading and returns immediately.
     * @param url URL of the web page to load
     */
    public void load(String url) {
        checkThread();
        loadWorker.cancelAndReset();

        if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
            url = &quot;&quot;;
        } else {
            // verify and, if possible, adjust the url on the Java
            // side, otherwise it may crash native code
            try {
                url = Util.adjustUrlForWebKit(url);
            } catch (MalformedURLException e) {
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        PAGE_STARTED, url, null, 0.0, 0);
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
                return;
            }
        }
        applyUserDataDirectory();
        page.open(page.getMainFrame(), url);
    }

    /**
     * Loads the given HTML content directly. This method is useful when you have an HTML
     * String composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the HTML text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous.
     *
     * @param content the HTML content to load
     */
    public void loadContent(String content) {
        loadContent(content, &quot;text/html&quot;);
    }

    /**
     * Loads the given content directly. This method is useful when you have content
     * composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the SVG text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous. This method also allows you to
     * specify the content type of the string being loaded, and so may optionally support
     * other types besides just HTML.
     *
     * @param content the HTML content to load
     * @param contentType the type of content to load
     */
    public void loadContent(String content, String contentType) {
        checkThread();
        loadWorker.cancelAndReset();
        applyUserDataDirectory();
        page.load(page.getMainFrame(), content, contentType);
    }

    /**
     * Reloads the current page, whether loaded from URL or directly from a String in
     * one of the {@code loadContent} methods.
     */
    public void reload() {
        // TODO what happens if this is called while currently loading a page?
        checkThread();
        page.refresh(page.getMainFrame());
    }

    private final WebHistory history;

    /**
     * Returns the session history object.
     *
     * @return history object
     * @since JavaFX 2.2
     */
    public WebHistory getHistory() {
        return history;
    }

    /**
     * Executes a script in the context of the current page.
     *
     * @param script the script
     * @return execution result, converted to a Java object using the following
     * rules:
     * &lt;ul&gt;
     * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
     * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
     * &lt;li&gt;JavaScript string to {@code java.lang.String}
     * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
     * &lt;li&gt;JavaScript {@code null} to {@code null}
     * &lt;li&gt;Most JavaScript objects get wrapped as
     *     {@code netscape.javascript.JSObject}
     * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
     *     {@code netscape.javascript.JSObject}, that also implement
     *     {@code org.w3c.dom.Node}
     * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
     *     which is used to wrap a Java object as a JavaScript value - in this
     *     case we just extract the original Java value.
     * &lt;/ul&gt;
     */
    public Object executeScript(String script) {
        checkThread();
        applyUserDataDirectory();
        return page.executeScript(page.getMainFrame(), script);
    }

    private long getMainFrame() {
        return page.getMainFrame();
    }

    WebPage getPage() {
        return page;
    }

    void setView(WebView view) {
        this.view.setValue(view);
    }

    private void stop() {
        checkThread();
        page.stop(page.getMainFrame());
    }

    private void applyUserDataDirectory() {
        if (userDataDirectoryApplied) {
            return;
        }
        userDataDirectoryApplied = true;
        File nominalUserDataDir = getUserDataDirectory();
        while (true) {
            File userDataDir;
            String displayString;
            if (nominalUserDataDir == null) {
                userDataDir = defaultUserDataDirectory();
                displayString = format(&quot;null (%s)&quot;, userDataDir);
            } else {
                userDataDir = nominalUserDataDir;
                displayString = userDataDir.toString();
            }
            logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
            String errorMessage;
            EventType&lt;WebErrorEvent&gt; errorType;
            Throwable error;
            try {
                userDataDir = DirectoryLock.canonicalize(userDataDir);
                File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
                File[] dirs = new File[] {
                    userDataDir,
                    localStorageDir,
                };
                for (File dir : dirs) {
                    createDirectories(dir);
                    // Additional security check to make sure the caller
                    // has permission to write to the target directory
                    File test = new File(dir, &quot;.test&quot;);
                    if (test.createNewFile()) {
                        test.delete();
                    }
                }
                disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);

                page.setLocalStorageDatabasePath(localStorageDir.getPath());
                page.setLocalStorageEnabled(true);

                logger.fine(&quot;User data directory [{0}] has &quot;
                        + &quot;been applied successfully&quot;, displayString);
                return;

            } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
                errorMessage = &quot;User data directory [%s] is already in use&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
                error = ex;
            } catch (IOException ex) {
                errorMessage = &quot;An I/O error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
                error = ex;
            } catch (SecurityException ex) {
                errorMessage = &quot;A security error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
                error = ex;
            }

            errorMessage = format(errorMessage, displayString);
            logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
            File oldNominalUserDataDir = nominalUserDataDir;
            fireError(errorType, errorMessage, error);
            nominalUserDataDir = getUserDataDirectory();
            if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
                logger.fine(&quot;Error handler did not modify user data directory, &quot;
                        + &quot;continuing without user data directory&quot;);
                return;
            } else {
                logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
                        + &quot;retrying&quot;, nominalUserDataDir);
                continue;
            }
        }
    }

    private static File defaultUserDataDirectory() {
        return new File(
                com.sun.glass.ui.Application.GetApplication()
                        .getDataDirectory(),
                &quot;webview&quot;);
    }

    private static void createDirectories(File directory) throws IOException {
<A NAME="6"></A>        Path path = directory.toPath();
        try {
            Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
                    <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#6',2,'match44-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>PosixFilePermissions.fromString(&quot;rwx------&quot;)));
        } catch (UnsupportedOperationException ex) {
            Files.createDirectories(path);
        }
    }

    private void fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
                           Throwable exception)
    {
        EventHandler&lt;WebErrorEvent&gt; handler = getOnError()</B></FONT>;
        if (handler != null) {
            handler.handle(new WebErrorEvent(this, eventType,
                                             message, exception));
        }
    }

    // for testing purposes only
    void dispose() {
        disposer.dispose();
    }

    private static final class SelfDisposer implements DisposerRecord {
        private WebPage page;
        private DirectoryLock userDataDirectoryLock;

        private SelfDisposer(WebPage page) {
            this.page = page;
        }

        @Override public void dispose() {
            if (page == null) {
                return;
            }
            page.dispose();
            page = null;
            if (userDataDirectoryLock != null) {
                userDataDirectoryLock.close();
            }
            instanceCount--;
            if (instanceCount == 0 &amp;&amp;
                Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
            {
                PulseTimer.stop();
            }
        }
    }

    private static final class AccessorImpl extends Accessor {
        private final WeakReference&lt;WebEngine&gt; engine;

        private AccessorImpl(WebEngine w) {
            this.engine = new WeakReference&lt;WebEngine&gt;(w);
        }

        @Override public WebEngine getEngine() {
            return engine.get();
        }

        @Override public WebPage getPage() {
            WebEngine w = getEngine();
            return w == null ? null : w.page;
        }

        @Override public WebView getView() {
            WebEngine w = getEngine();
            return w == null ? null : w.view.get();
        }

        @Override public void addChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().add(child);
            }
        }

        @Override public void removeChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().remove(child);
            }
        }

        @Override public void addViewListener(InvalidationListener l) {
            WebEngine w = getEngine();
            if (w != null) {
                w.view.addListener(l);
            }
        }
    }

    /**
     * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
     */
    private static final class PulseTimer {

        // Used just to guarantee constant pulse activity. See RT-14433.
        private static final AnimationTimer animation =
            new AnimationTimer() {
                @Override public void handle(long l) {}
            };

        private static final TKPulseListener listener =
                () -&gt; {
                    // Note, the timer event is executed right in the notifyTick(),
                    // that is during the pulse event. This makes the timer more
                    // repsonsive, though prolongs the pulse. So far it causes no
                    // problems but nevertheless it should be kept in mind.

                    // Execute notifyTick in runLater to run outside of pulse so
                    // that events will run in order and be able to display dialogs
                    // or call other methods that require a nested event loop.
                    Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
                };

        private static void start(){
            Toolkit.getToolkit().addSceneTkPulseListener(listener);
            animation.start();
        }

        private static void stop() {
            Toolkit.getToolkit().removeSceneTkPulseListener(listener);
            animation.stop();
        }
    }

    static void checkThread() {
        Toolkit.getToolkit().checkFxUserThread();
    }


    /**
     * The page load event listener. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class PageLoadListener implements LoadListenerClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private PageLoadListener(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override public void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double progress, int errorCode)
        {
            WebEngine w = engine.get();
            if (w != null) {
                w.loadWorker.dispatchLoadEvent(frame, state, url,
                        contentType, progress, errorCode);
            }
        }

        @Override public void dispatchResourceLoadEvent(long frame,
                int state, String url, String contentType, double progress,
                int errorCode)
        {
        }
    }


    private final class LoadWorker implements Worker&lt;Void&gt; {

        private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
        @Override public final State getState() { checkThread(); return state.get(); }
        @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
        private void updateState(State value) {
            checkThread();
            this.state.set(value);
            running.set(value == State.SCHEDULED || value == State.RUNNING);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
        @Override public final Void getValue() { checkThread(); return value.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
        @Override public final Throwable getException() { checkThread(); return exception.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
        @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
        @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
        @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
        @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
        @Override public final double getProgress() { checkThread(); return progress.get(); }
        @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
        private void updateProgress(double p) {
            totalWorkToBeDone.set(100.0);
            workDone.set(p * 100.0);
            progress.set(p);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
        @Override public final boolean isRunning() { checkThread(); return running.get(); }
        @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
        @Override public final String getMessage() { return message.get(); }
        @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
        @Override public final String getTitle() { return title.get(); }
        @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

        /**
         * Cancels the loading of the page. If called after the page has already
         * been loaded, then this call takes no effect.
         */
        @Override public boolean cancel() {
            if (isRunning()) {
                stop(); // this call indirectly sets state
                return true;
            } else {
                return false;
            }
        }

        private void cancelAndReset() {
            cancel();
            exception.set(null);
            message.set(&quot;&quot;);
            totalWorkToBeDone.set(-1);
            workDone.set(-1);
            progress.set(-1);
            updateState(State.READY);
            running.set(false);
        }

        private void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double workDone, int errorCode)
        {
            if (frame != getMainFrame()) {
                return;
            }
            switch (state) {
                case PAGE_STARTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    updateProgress(0.0);
                    updateState(State.SCHEDULED);
                    updateState(State.RUNNING);
                    break;
                case PAGE_REDIRECTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    break;
                case PAGE_REPLACED:
                    message.set(&quot;Replaced &quot; + url);
                    // Update only the location, don't change title or document.
                    WebEngine.this.location.set(url);
                    break;
                case PAGE_FINISHED:
                    message.set(&quot;Loading complete&quot;);
                    updateProgress(1.0);
                    updateState(State.SUCCEEDED);
                    break;
                case LOAD_FAILED:
                    message.set(&quot;Loading failed&quot;);
                    exception.set(describeError(errorCode));
                    updateState(State.FAILED);
                    break;
                case LOAD_STOPPED:
                    message.set(&quot;Loading stopped&quot;);
                    updateState(State.CANCELLED);
                    break;
                case PROGRESS_CHANGED:
                    updateProgress(workDone);
                    break;
                case TITLE_RECEIVED:
                    updateTitle();
                    break;
                case DOCUMENT_AVAILABLE:
                    if (this.state.get() != State.RUNNING) {
                        // We have empty load; send a synthetic event (RT-32097)
                        dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
                    }
                    document.invalidate(true);
                    break;
            }
        }

        private Throwable describeError(int errorCode) {
            String reason = &quot;Unknown error&quot;;

            switch (errorCode) {
                case UNKNOWN_HOST:
                    reason = &quot;Unknown host&quot;;
                    break;
                case MALFORMED_URL:
                    reason = &quot;Malformed URL&quot;;
                    break;
                case SSL_HANDSHAKE:
                    reason = &quot;SSL handshake failed&quot;;
                    break;
                case CONNECTION_REFUSED:
                    reason = &quot;Connection refused by server&quot;;
                    break;
                case CONNECTION_RESET:
                    reason = &quot;Connection reset by server&quot;;
                    break;
                case NO_ROUTE_TO_HOST:
                    reason = &quot;No route to host&quot;;
                    break;
                case CONNECTION_TIMED_OUT:
                    reason = &quot;Connection timed out&quot;;
                    break;
                case PERMISSION_DENIED:
                    reason = &quot;Permission denied&quot;;
                    break;
                case INVALID_RESPONSE:
                    reason = &quot;Invalid response from server&quot;;
                    break;
                case TOO_MANY_REDIRECTS:
                    reason = &quot;Too many redirects&quot;;
                    break;
                case FILE_NOT_FOUND:
                    reason = &quot;File not found&quot;;
                    break;
            }
            return new Throwable(reason);
        }
    }


    private final class DocumentProperty
            extends ReadOnlyObjectPropertyBase&lt;Document&gt; {

        private boolean available;
        private Document document;

        private void invalidate(boolean available) {
            if (this.available || available) {
                this.available = available;
                this.document = null;
                fireValueChangedEvent();
            }
        }

        public Document get() {
            if (!this.available) {
                return null;
            }
            if (this.document == null) {
                this.document = page.getDocument(page.getMainFrame());
                if (this.document == null) {
                    this.available = false;
                }
            }
            return this.document;
        }

        public Object getBean() {
            return WebEngine.this;
        }

        public String getName() {
            return &quot;document&quot;;
        }
    }


    /*
     * Returns the debugger associated with this web engine.
     * The debugger is an object that can be used to debug
     * the web page currently loaded into the web engine.
     * &lt;p&gt;
     * All methods of the debugger must be called on
     * the JavaFX Application Thread.
     * The message callback object registered with the debugger
     * is always called on the JavaFX Application Thread.
     * @return the debugger associated with this web engine.
     *         The return value cannot be {@code null}.
     */
    Debugger getDebugger() {
        return debugger;
    }

    /**
     * The debugger implementation.
     */
    private final class DebuggerImpl implements Debugger {

        private boolean enabled;
        private Callback&lt;String,Void&gt; messageCallback;


        @Override
        public boolean isEnabled() {
            checkThread();
            return enabled;
        }

        @Override
        public void setEnabled(boolean enabled) {
            checkThread();
            if (enabled != this.enabled) {
                if (enabled) {
                    page.setDeveloperExtrasEnabled(true);
                    page.connectInspectorFrontend();
                } else {
                    page.disconnectInspectorFrontend();
                    page.setDeveloperExtrasEnabled(false);
                }
                this.enabled = enabled;
            }
        }

        @Override
        public void sendMessage(String message) {
            checkThread();
            if (!enabled) {
                throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
            }
            if (message == null) {
                throw new NullPointerException(&quot;message is null&quot;);
            }
            page.dispatchInspectorMessageFromFrontend(message);
        }

        @Override
        public Callback&lt;String,Void&gt; getMessageCallback() {
            checkThread();
            return messageCallback;
        }

        @Override
        public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
            checkThread();
            messageCallback = callback;
        }
    }

    /**
     * The inspector client implementation. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class InspectorClientImpl implements InspectorClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private InspectorClientImpl(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override
        public boolean sendMessageToFrontend(final String message) {
            boolean result = false;
            WebEngine webEngine = engine.get();
            if (webEngine != null) {
                final Callback&lt;String,Void&gt; messageCallback =
                        webEngine.debugger.messageCallback;
                if (messageCallback != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        messageCallback.call(message);
                        return null;
                    }, webEngine.page.getAccessControlContext());
                    result = true;
                }
            }
            return result;
        }
    }

    private static final boolean printStatusOK(PrinterJob job) {
        switch (job.getJobStatus()) {
            case NOT_STARTED:
            case PRINTING:
                return true;
            default:
                return false;
        }
    }

    /**
     * Prints the current Web page using the given printer job.
     * &lt;p&gt;This method does not modify the state of the job, nor does it call
     * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
     *
     * @param job printer job used for printing
     * @since JavaFX 8.0
     */
    public void print(PrinterJob job) {
        if (!printStatusOK(job)) {
            return;
        }

        PageLayout pl = job.getJobSettings().getPageLayout();
        float width = (float) pl.getPrintableWidth();
        float height = (float) pl.getPrintableHeight();
        int pageCount = page.beginPrinting(width, height);

        for (int i = 0; i &lt; pageCount; i++) {
            if (printStatusOK(job)) {
                Node printable = new Printable(page, i, width);
                job.printPage(printable);
            }
        }
        page.endPrinting();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/StartView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;


public class StartView extends VBox {
    private Button btLevel1;
    private Button btLevel2;
    private Button btLevel3;
    private Button btSoundPlay;
    private Button btSoundPause;
    private Label message;
    private Label message1;

    public StartView() {
        // Create a vBox
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        // Set name for buttons and message label
        setBtLevel1(new Button(&quot;Level 1&quot;));
        setBtLevel2(new Button(&quot;Level 2&quot;));
        setBtLevel3(new Button(&quot;Level 3&quot;));
        setBtSoundPlay(new Button(&quot;Music On&quot;));
        setBtSoundPause(new Button(&quot;Music Pause&quot;));
        setMessage(new Label(&quot;Hello, QUOC DAI ! &quot;));
        setMessage1(new Label(&quot;PLEASE CHOOSE THE LEVEL TO START !&quot;));
        //Set Front, Size, Color for Message
        getMessage().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage().setTextFill(Color.WHITE);
        //Set Front, Size, Color for Message1
        getMessage1().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage1().setTextFill(Color.WHITE);
        // add 4 buttons to hBox
        hBox.getChildren().addAll(getBtLevel1(), getBtLevel2(), getBtLevel3(), getBtSoundPlay(), getBtSoundPause());

        setAlignment(Pos.CENTER);
        setSpacing(10);

        // add hBox and label to vBox
        getChildren().addAll(getMessage(), getMessage1(),hBox);
    }

    public Button getBtLevel1() {
        return btLevel1;
    }

    public Button getBtLevel2() {
        return btLevel2;
    }

    public Button getBtLevel3() {
        return btLevel3;
    }

    private void setBtLevel1(Button btLevel1) {
        this.btLevel1 = btLevel1;
    }

    private void setBtLevel2(Button btLevel2) {
        this.btLevel2 = btLevel2;
    }

    private void setBtLevel3(Button btLevel3) {
        this.btLevel3 = btLevel3;
    }

    private Label getMessage() {
        return message;
<A NAME="11"></A>    }

    private void setMessage(Label message) {
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#11',2,'match44-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.message = message;
    }

    private Label getMessage1() {
        return message1;
    }

    private void setMessage1(Label message1) {
        this.message1 = message1;
    }

    public Button getBtSoundPlay() {
        return btSoundPlay;
    }

    private void setBtSoundPlay(Button btSoundPlay) {
        this.btSoundPlay = btSoundPlay;
    }

    public Button getBtSoundPause() {
        return btSoundPause;
    }

    private void setBtSoundPause(Button btSoundPause) {
        this.btSoundPause = btSoundPause;
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/TimeBar.java</CENTER></H3><HR>
<PRE>
package sample.View;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;


public class TimeBar extends AnchorPane{
    private Timeline timeline;
<A NAME="30"></A>
    public TimeBar() {
        //Create rectangle
        <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#30',2,'match44-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Rectangle rectangle = new Rectangle(1280, 30);
        rectangle.setFill(Color.YELLOW);
        // Create pane and add rectangle to it
        Pane pane = new Pane();
        pane.getChildren().add(rectangle);
        pane.setStyle(&quot;-fx-background-color: white;&quot;);
        AnchorPane.setTopAnchor(pane, 0.0);
        AnchorPane.setLeftAnchor(pane, 0.0);
        AnchorPane.setRightAnchor(pane, 0.0);
        AnchorPane.setBottomAnchor(pane,0.0);
        getChildren().addAll</B></FONT>(pane);
        // Create Timeline animation
        double paneWidth = pane.getWidth(); //
        double rectangleWidth = rectangle.getLayoutBounds().getWidth();
        KeyValue initKeyValue1 = new KeyValue(rectangle.translateXProperty(), paneWidth);
        KeyValue initKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 1.0);
        KeyFrame initFrame = new KeyFrame(Duration.ZERO, initKeyValue1, initKeyValue2);
        KeyValue endKeyValue1 = new KeyValue(rectangle.translateXProperty(), -1.0 * rectangleWidth);
        KeyValue endKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 0.2);
        KeyFrame endFrame = new KeyFrame(Duration.minutes(2), endKeyValue1, endKeyValue2);
        setTimeline(new Timeline(25 , initFrame, endFrame));
        getTimeline().setCycleCount(1);
        getTimeline().setRate(1);
        getTimeline().setAutoReverse(false);
        getTimeline().play();
    }
<A NAME="49"></A>
    private Timeline getTimeline() {
        return timeline;
    <FONT color="#8e35ef"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#49',2,'match44-top.html#49',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void setTimeline(Timeline timeline) {
        this.timeline = timeline;
    }
}</B></FONT>
</PRE>

</BODY>
</HTML>
